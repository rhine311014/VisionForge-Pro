# VisionForge Pro - 核心类图设计

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2025-12-14
- **设计者**: VisionForge Team

---

## 1. 整体类图概览

```
┌─────────────────────────────────────────────────────────────┐
│                       类图层次结构                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  UI层                    业务层                算法层        │
│  ┌──────────┐         ┌──────────┐         ┌──────────┐    │
│  │MainWindow│────────>│ Recipe   │────────>│VisionTool│    │
│  │          │         │ Manager  │         │          │    │
│  └──────────┘         └──────────┘         └──────────┘    │
│       │                    │                     │         │
│       ├─SimpleMode         ├─TaskScheduler       ├─GrayTool│
│       └─ProMode            └─ResultJudge         └─BlurTool│
│                                                             │
│  HAL层                   基础设施层                          │
│  ┌──────────┐         ┌──────────┐                         │
│  │ICamera   │         │MemPool   │                         │
│  │ILight    │         │Logger    │                         │
│  │IPLC      │         │Config    │                         │
│  └──────────┘         └──────────┘                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. UI层类图

### 2.1 主窗口及模式管理

```cpp
// ============================================================
// 主窗口类 - 应用程序入口
// ============================================================
class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    explicit MainWindow(QWidget* parent = nullptr);
    ~MainWindow() override;

    void loadRecipe(const QString& filePath);
    void saveRecipe(const QString& filePath);

public slots:
    void onSwitchMode(UIMode mode);
    void onRunClicked();
    void onStopClicked();

private:
    void setupUI();
    void createMenuBar();
    void createToolBar();
    void createStatusBar();

private:
    // 模式管理
    UIModeManager* modeManager_;

    // UI模式
    SimpleModeWidget* simpleMode_;
    ProfessionalModeWidget* proMode_;
    QStackedWidget* modeStack_;

    // 核心组件
    RecipeManager* recipeManager_;
    TaskScheduler* taskScheduler_;
    ImageDisplayWidget* imageDisplay_;

    // 状态
    QLabel* statusLabel_;
    QProgressBar* progressBar_;
};


// ============================================================
// UI模式管理器
// ============================================================
class UIModeManager : public QObject {
    Q_OBJECT

public:
    enum UIMode { Simple, Professional };

    explicit UIModeManager(QObject* parent = nullptr);

    UIMode currentMode() const { return currentMode_; }
    void switchMode(UIMode mode);

signals:
    void modeChanged(UIMode newMode);
    void modeWillChange(UIMode oldMode, UIMode newMode);

private:
    void saveState();
    void restoreState();

private:
    UIMode currentMode_;
    QSettings* settings_;
};
```

### 2.2 简单模式UI

```cpp
// ============================================================
// 简单模式主界面
// ============================================================
class SimpleModeWidget : public QWidget {
    Q_OBJECT

public:
    explicit SimpleModeWidget(QWidget* parent = nullptr);

    void setRecipe(Recipe* recipe);
    void updateCurrentStep(int stepIndex);

signals:
    void stepSelected(int stepIndex);
    void toolAdded(const QString& toolType);
    void paramChanged(int stepIndex, const QJsonObject& params);

private slots:
    void onAddStepClicked();
    void onStepItemClicked(int index);

private:
    void setupLayout();

private:
    // 核心组件
    StepListWidget* stepList_;          // 左侧步骤列表
    ImageDisplayWidget* imageDisplay_;  // 中间图像显示
    SimpleParamPanel* paramPanel_;      // 右侧参数面板

    // 工具选择器
    QuickToolSelector* toolSelector_;

    // 数据
    Recipe* currentRecipe_;
};


// ============================================================
// 步骤列表组件
// ============================================================
class StepListWidget : public QListWidget {
    Q_OBJECT

public:
    explicit StepListWidget(QWidget* parent = nullptr);

    void addStep(VisionTool* tool);
    void removeStep(int index);
    void setStepEnabled(int index, bool enabled);
    void setCurrentStep(int index);

signals:
    void stepClicked(int index);
    void stepMoved(int fromIndex, int toIndex);
    void stepEnabledChanged(int index, bool enabled);

protected:
    void dropEvent(QDropEvent* event) override;
    void dragEnterEvent(QDragEnterEvent* event) override;

private:
    // 自定义Item委托（绘制步骤项）
    StepItemDelegate* delegate_;
};


// ============================================================
// 步骤项委托 - 自定义绘制
// ============================================================
class StepItemDelegate : public QStyledItemDelegate {
    Q_OBJECT

public:
    explicit StepItemDelegate(QObject* parent = nullptr);

    void paint(QPainter* painter,
               const QStyleOptionViewItem& option,
               const QModelIndex& index) const override;

    QSize sizeHint(const QStyleOptionViewItem& option,
                   const QModelIndex& index) const override;

private:
    void drawStepIcon(QPainter* painter, const QRect& rect,
                      const QString& toolType) const;
    void drawStepStatus(QPainter* painter, const QRect& rect,
                        bool enabled, bool hasError) const;
};


// ============================================================
// 简化参数面板
// ============================================================
class SimpleParamPanel : public QScrollArea {
    Q_OBJECT

public:
    explicit SimpleParamPanel(QWidget* parent = nullptr);

    void setTool(VisionTool* tool);
    void clear();

signals:
    void paramChanged(const QJsonObject& params);

private:
    void createParamWidgets(VisionTool* tool);
    void createSliderParam(const QString& name,
                          double min, double max, double value);
    void createComboParam(const QString& name,
                         const QStringList& options, int current);

private:
    QWidget* contentWidget_;
    QFormLayout* layout_;
    VisionTool* currentTool_;

    // 参数控件映射
    QMap<QString, QWidget*> paramWidgets_;
};


// ============================================================
// 快速工具选择器对话框
// ============================================================
class QuickToolSelector : public QDialog {
    Q_OBJECT

public:
    explicit QuickToolSelector(QWidget* parent = nullptr);

    QString selectedToolType() const;

signals:
    void toolSelected(const QString& toolType);

private:
    void createToolButtons();
    void onToolButtonClicked(const QString& toolType);

private:
    QGridLayout* buttonLayout_;
    QMap<QString, QPushButton*> toolButtons_;
    QString selectedType_;
};
```

### 2.3 专业模式UI

```cpp
// ============================================================
// 专业模式主界面
// ============================================================
class ProfessionalModeWidget : public QWidget {
    Q_OBJECT

public:
    explicit ProfessionalModeWidget(QWidget* parent = nullptr);

    void setProject(Project* project);

signals:
    void recipeSelected(Recipe* recipe);
    void stepSelected(int stepIndex);

private:
    void setupLayout();

private:
    // 左侧
    ProjectTreeWidget* projectTree_;   // 项目树
    ToolboxWidget* toolbox_;           // 工具箱

    // 中间
    QTabWidget* workspaceTab_;         // 多Tab工作区
    ImageDisplayWidget* imageView_;    // 图像Tab
    FlowChartWidget* flowChart_;       // 流程Tab
    DataGridWidget* dataGrid_;         // 数据Tab
    LogViewerWidget* logViewer_;       // 日志Tab

    // 右侧
    PropertyPanel* propertyPanel_;     // 属性面板

    // 底部
    StepNavigator* stepNavigator_;     // 步骤导航条
};


// ============================================================
// 项目树组件
// ============================================================
class ProjectTreeWidget : public QTreeWidget {
    Q_OBJECT

public:
    explicit ProjectTreeWidget(QWidget* parent = nullptr);

    void setProject(Project* project);
    void addRecipe(Recipe* recipe);
    void removeRecipe(const QString& recipeId);

signals:
    void recipeSelected(Recipe* recipe);
    void taskSelected(Task* task);

private:
    void createContextMenu();

private:
    Project* currentProject_;
    QMenu* contextMenu_;
};


// ============================================================
// 工具箱组件（可拖拽）
// ============================================================
class ToolboxWidget : public QWidget {
    Q_OBJECT

public:
    explicit ToolboxWidget(QWidget* parent = nullptr);

    void addToolCategory(const QString& category,
                        const QStringList& tools);

signals:
    void toolDragged(const QString& toolType);

private:
    void createToolItems();

private:
    QVBoxLayout* layout_;
    QMap<QString, QListWidget*> categoryLists_;
};


// ============================================================
// 完整属性面板（分组、可折叠）
// ============================================================
class PropertyPanel : public QScrollArea {
    Q_OBJECT

public:
    explicit PropertyPanel(QWidget* parent = nullptr);

    void setTool(VisionTool* tool);
    void clear();

signals:
    void paramChanged(const QJsonObject& params);

private:
    void createBasicGroup(VisionTool* tool);
    void createAdvancedGroup(VisionTool* tool);
    void createDebugGroup(VisionTool* tool);

private:
    QWidget* contentWidget_;
    QVBoxLayout* layout_;

    // 分组面板
    QGroupBox* basicGroup_;
    QGroupBox* advancedGroup_;
    QGroupBox* debugGroup_;

    VisionTool* currentTool_;
};


// ============================================================
// 步骤导航条（快速跳转）
// ============================================================
class StepNavigator : public QWidget {
    Q_OBJECT

public:
    explicit StepNavigator(QWidget* parent = nullptr);

    void setSteps(const QList<VisionTool*>& steps);
    void setCurrentStep(int index);

signals:
    void stepClicked(int index);

private:
    void createStepButtons();

private:
    QHBoxLayout* layout_;
    QList<QPushButton*> stepButtons_;
    int currentStep_;
};
```

---

## 3. 业务逻辑层类图

### 3.1 配方管理

```cpp
// ============================================================
// 配方类 - 核心数据模型
// ============================================================
class Recipe : public QObject {
    Q_OBJECT

public:
    struct Metadata {
        QString name;
        int version;
        QDateTime createdTime;
        QDateTime modifiedTime;
        QString author;
    };

    explicit Recipe(QObject* parent = nullptr);
    ~Recipe() override;

    // 元数据
    const Metadata& metadata() const { return metadata_; }
    void setMetadata(const Metadata& meta) { metadata_ = meta; }

    // 步骤管理
    void addStep(VisionTool* tool);
    void insertStep(int index, VisionTool* tool);
    void removeStep(int index);
    void moveStep(int fromIndex, int toIndex);
    int stepCount() const { return steps_.size(); }
    VisionTool* step(int index) const;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);

    // 保存/加载
    bool save(const QString& filePath);
    bool load(const QString& filePath);

signals:
    void stepAdded(int index);
    void stepRemoved(int index);
    void stepMoved(int fromIndex, int toIndex);
    void metadataChanged();

private:
    Metadata metadata_;
    QList<VisionTool*> steps_;
    CameraConfig* cameraConfig_;
    JudgmentRules* judgmentRules_;
};


// ============================================================
// 配方管理器
// ============================================================
class RecipeManager : public QObject {
    Q_OBJECT

public:
    static RecipeManager& instance();

    Recipe* createRecipe(const QString& name);
    Recipe* openRecipe(const QString& filePath);
    bool saveRecipe(Recipe* recipe, const QString& filePath);
    void closeRecipe(Recipe* recipe);

    Recipe* currentRecipe() const { return currentRecipe_; }
    void setCurrentRecipe(Recipe* recipe);

    // 版本控制
    RecipeVersion* getVersion(Recipe* recipe, int version);
    void createSnapshot(Recipe* recipe, const QString& changeLog);
    bool rollback(Recipe* recipe, int targetVersion);

signals:
    void recipeOpened(Recipe* recipe);
    void recipeClosed(Recipe* recipe);
    void currentRecipeChanged(Recipe* recipe);

private:
    RecipeManager();
    ~RecipeManager();

private:
    Recipe* currentRecipe_;
    QMap<QString, Recipe*> loadedRecipes_;
    RecipeVersionControl* versionControl_;
};


// ============================================================
// 配方版本控制
// ============================================================
class RecipeVersionControl : public QObject {
    Q_OBJECT

public:
    struct Version {
        int versionNumber;
        QDateTime timestamp;
        QString author;
        QString changeLog;
        QJsonObject recipeSnapshot;
    };

    explicit RecipeVersionControl(QObject* parent = nullptr);

    void addVersion(const QString& recipeId, const Version& version);
    QList<Version> getVersionHistory(const QString& recipeId) const;
    Version getVersion(const QString& recipeId, int version) const;

    // 对比两个版本
    QJsonObject diff(const QString& recipeId, int v1, int v2) const;

private:
    // recipeId -> version list
    QMap<QString, QList<Version>> versionHistory_;
};
```

### 3.2 任务调度

```cpp
// ============================================================
// 任务调度器
// ============================================================
class TaskScheduler : public QObject {
    Q_OBJECT

public:
    enum RunMode {
        SingleRun,      // 单次运行
        Continuous,     // 连续运行
        Triggered       // 外部触发
    };

    explicit TaskScheduler(QObject* parent = nullptr);
    ~TaskScheduler() override;

    void setRecipe(Recipe* recipe);
    void setRunMode(RunMode mode);

    void start();
    void stop();
    void pause();
    void resume();

    bool isRunning() const { return isRunning_; }

signals:
    void started();
    void stopped();
    void stepStarted(int stepIndex);
    void stepFinished(int stepIndex, bool success);
    void resultReady(const InspectionResult& result);
    void errorOccurred(const QString& error);

private slots:
    void runPipeline();
    void onStepFinished(bool success);

private:
    Recipe* recipe_;
    RunMode runMode_;
    bool isRunning_;
    bool isPaused_;

    // 执行引擎
    PipelineExecutor* executor_;

    // 统计
    int runCount_;
    int okCount_;
    int ngCount_;
};


// ============================================================
// 流程执行引擎
// ============================================================
class PipelineExecutor : public QObject {
    Q_OBJECT

public:
    explicit PipelineExecutor(QObject* parent = nullptr);

    void setSteps(const QList<VisionTool*>& steps);
    bool execute(ImageData::Ptr input, InspectionResult& output);

    // 调试模式（单步执行）
    void setDebugMode(bool enabled);
    bool stepInto();  // 执行下一步
    ImageData::Ptr getCurrentStepResult() const;

signals:
    void stepExecuted(int stepIndex, qint64 elapsedMs);
    void pipelineFinished(bool success);

private:
    void executeStep(int index);

private:
    QList<VisionTool*> steps_;
    int currentStep_;
    bool debugMode_;

    // 中间结果缓存
    QVector<ImageData::Ptr> intermediateResults_;

    // 性能监控
    PerformanceMonitor* perfMonitor_;
};


// ============================================================
// 检测结果
// ============================================================
struct InspectionResult {
    bool ok;                       // OK/NG判定
    QDateTime timestamp;           // 时间戳
    qint64 totalTime;              // 总耗时(ms)

    // 步骤结果
    struct StepResult {
        QString toolType;
        bool success;
        qint64 elapsedTime;
        QJsonObject data;          // 结果数据
    };
    QList<StepResult> stepResults;

    // 图像
    ImageData::Ptr inputImage;     // 输入图像
    ImageData::Ptr resultImage;    // 结果图像（带标注）

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};
```

### 3.3 结果判定

```cpp
// ============================================================
// 判定规则引擎
// ============================================================
class JudgmentEngine : public QObject {
    Q_OBJECT

public:
    explicit JudgmentEngine(QObject* parent = nullptr);

    void setRules(const JudgmentRules& rules);
    bool evaluate(const InspectionResult& result) const;

private:
    bool evaluateExpression(const QString& expr,
                           const QJsonObject& data) const;

private:
    JudgmentRules rules_;
    ExpressionParser* parser_;
};


// ============================================================
// 判定规则
// ============================================================
struct JudgmentRules {
    QString okCondition;           // OK条件表达式
    QString ngCondition;           // NG条件表达式

    // 输出映射
    struct OutputMapping {
        QString condition;
        int outputPort;            // DO端口号
        bool value;                // 输出值
    };
    QList<OutputMapping> outputs;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 表达式解析器（简单实现）
// ============================================================
class ExpressionParser {
public:
    bool parse(const QString& expression, const QJsonObject& context);

private:
    QVariant evaluate(const QString& expr);
};
```

---

## 4. 算法服务层类图

### 4.1 视觉工具基类

```cpp
// ============================================================
// 视觉工具抽象基类
// ============================================================
class VisionTool : public QObject {
    Q_OBJECT

public:
    enum ToolType {
        // 图像源
        Camera, File, Video,

        // 预处理
        Gray, Blur, Binary, ROI, ColorConvert,

        // 定位检测
        TemplateMatch, FindCircle, FindLine, FindEdge,
        BlobAnalysis, AIDetection,

        // 测量计算
        MeasureDistance, MeasureAngle, MeasureArea,
        CalcCenter, CalcOrientation,

        // 判定输出
        RangeJudge, LogicOperation, PLCOutput, SaveImage
    };

    explicit VisionTool(QObject* parent = nullptr);
    virtual ~VisionTool() = default;

    // ========== 核心接口 ==========
    virtual ToolType toolType() const = 0;
    virtual QString toolName() const = 0;
    virtual QIcon toolIcon() const = 0;

    // 处理接口
    virtual bool process(const ImageData::Ptr& input,
                        ToolResult& output) = 0;

    // 参数接口
    virtual QWidget* createParamWidget() = 0;
    virtual QJsonObject serializeParams() const = 0;
    virtual void deserializeParams(const QJsonObject& json) = 0;

    // 调试接口
    virtual ImageData::Ptr getDebugImage() const { return debugImage_; }
    virtual QString getStatusText() const { return statusText_; }

    // ========== 属性 ==========
    bool isEnabled() const { return enabled_; }
    void setEnabled(bool enabled);

    QString displayName() const { return displayName_; }
    void setDisplayName(const QString& name);

signals:
    void paramChanged();
    void processingStarted();
    void processingFinished(bool success, qint64 elapsedMs);
    void debugImageUpdated();
    void statusTextChanged(const QString& text);

protected:
    void setDebugImage(const ImageData::Ptr& image);
    void setStatusText(const QString& text);

protected:
    bool enabled_;
    QString displayName_;
    ImageData::Ptr debugImage_;
    QString statusText_;
};


// ============================================================
// 工具结果
// ============================================================
struct ToolResult {
    bool success;                  // 是否成功
    QString errorMessage;          // 错误消息
    QJsonObject data;              // 结果数据
    ImageData::Ptr outputImage;    // 输出图像

    // 便捷方法
    template<typename T>
    T getValue(const QString& key, const T& defaultValue = T()) const {
        return data.value(key).toVariant().value<T>();
    }

    void setValue(const QString& key, const QVariant& value) {
        data[key] = QJsonValue::fromVariant(value);
    }
};
```

### 4.2 具体工具实现示例

```cpp
// ============================================================
// 灰度转换工具
// ============================================================
class GrayTool : public VisionTool {
    Q_OBJECT

public:
    enum ConvertMode {
        Average,      // 平均法
        Weighted,     // 加权法
        Desaturation, // 去饱和法
        SingleChannel // 单通道
    };

    explicit GrayTool(QObject* parent = nullptr);

    ToolType toolType() const override { return Gray; }
    QString toolName() const override { return tr("灰度转换"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // 参数设置
    void setConvertMode(ConvertMode mode) { convertMode_ = mode; }
    ConvertMode convertMode() const { return convertMode_; }

private:
    ConvertMode convertMode_;
};


// ============================================================
// 找圆工具
// ============================================================
class FindCircleTool : public VisionTool {
    Q_OBJECT

public:
    struct Params {
        double minRadius;          // 最小半径
        double maxRadius;          // 最大半径
        int edgeThreshold;         // 边缘强度
        int minEdgePoints;         // 最小边缘点数
        bool useROI;               // 是否使用ROI
        cv::Rect roi;              // ROI区域
    };

    explicit FindCircleTool(QObject* parent = nullptr);

    ToolType toolType() const override { return FindCircle; }
    QString toolName() const override { return tr("找圆"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // 参数访问
    Params& params() { return params_; }
    const Params& params() const { return params_; }

private:
    Params params_;
    cv::Vec3f lastFoundCircle_;  // 上次找到的圆(x, y, r)
};


// ============================================================
// AI检测工具
// ============================================================
class AIDetectionTool : public VisionTool {
    Q_OBJECT

public:
    explicit AIDetectionTool(QObject* parent = nullptr);
    ~AIDetectionTool() override;

    ToolType toolType() const override { return AIDetection; }
    QString toolName() const override { return tr("AI检测"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // AI模型管理
    bool loadModel(const QString& modelPath);
    void unloadModel();
    bool isModelLoaded() const { return inferenceEngine_ != nullptr; }

    // 参数设置
    void setConfidenceThreshold(float threshold);
    void setNMSThreshold(float threshold);

private:
    QString modelPath_;
    float confidenceThreshold_;
    float nmsThreshold_;

    // AI推理引擎
    AIInferenceEngine* inferenceEngine_;
};
```

### 4.3 工具工厂

```cpp
// ============================================================
// 工具工厂（单例）
// ============================================================
class ToolFactory {
public:
    static ToolFactory& instance();

    // 创建工具
    VisionTool* createTool(VisionTool::ToolType type);
    VisionTool* createTool(const QString& typeName);

    // 注册自定义工具
    void registerTool(const QString& typeName,
                     std::function<VisionTool*()> creator);

    // 获取所有工具类型
    QList<VisionTool::ToolType> availableToolTypes() const;
    QStringList availableToolNames() const;

    // 工具信息
    struct ToolInfo {
        VisionTool::ToolType type;
        QString name;
        QString category;      // 分类
        QString description;   // 描述
        QIcon icon;
    };
    ToolInfo getToolInfo(VisionTool::ToolType type) const;

private:
    ToolFactory();
    ~ToolFactory();

    void registerBuiltInTools();

private:
    QMap<VisionTool::ToolType, std::function<VisionTool*()>> creators_;
    QMap<VisionTool::ToolType, ToolInfo> toolInfos_;
};
```

---

## 5. 硬件抽象层(HAL)类图

### 5.1 相机接口

```cpp
// ============================================================
// 相机抽象接口
// ============================================================
class ICamera : public QObject {
    Q_OBJECT

public:
    enum TriggerMode {
        Continuous,    // 连续采集
        Software,      // 软件触发
        Hardware       // 硬件触发
    };

    struct Config {
        int width;
        int height;
        int offsetX;
        int offsetY;
        double exposure;       // 曝光时间(μs)
        double gain;           // 增益(dB)
        TriggerMode triggerMode;
    };

    virtual ~ICamera() = default;

    // ========== 设备管理 ==========
    virtual bool open() = 0;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;

    virtual QString deviceName() const = 0;
    virtual QString serialNumber() const = 0;

    // ========== 采集控制 ==========
    virtual bool startGrabbing() = 0;
    virtual void stopGrabbing() = 0;
    virtual bool isGrabbing() const = 0;

    virtual ImageData::Ptr grabImage(int timeoutMs = 1000) = 0;
    virtual bool trigger() = 0;  // 软触发

    // ========== 参数配置 ==========
    virtual void setConfig(const Config& config) = 0;
    virtual Config getConfig() const = 0;

    virtual void setExposure(double exposure) = 0;
    virtual double getExposure() const = 0;

    virtual void setGain(double gain) = 0;
    virtual double getGain() const = 0;

    virtual void setTriggerMode(TriggerMode mode) = 0;
    virtual TriggerMode getTriggerMode() const = 0;

signals:
    void imageGrabbed(ImageData::Ptr image);
    void errorOccurred(const QString& error);

protected:
    ICamera(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// GenICam相机实现
// ============================================================
class GenICamCamera : public ICamera {
    Q_OBJECT

public:
    explicit GenICamCamera(const QString& deviceId,
                          QObject* parent = nullptr);
    ~GenICamCamera() override;

    bool open() override;
    void close() override;
    bool isOpen() const override;

    QString deviceName() const override;
    QString serialNumber() const override;

    bool startGrabbing() override;
    void stopGrabbing() override;
    bool isGrabbing() const override;

    ImageData::Ptr grabImage(int timeoutMs = 1000) override;
    bool trigger() override;

    void setConfig(const Config& config) override;
    Config getConfig() const override;

    void setExposure(double exposure) override;
    double getExposure() const override;

    void setGain(double gain) override;
    double getGain() const override;

    void setTriggerMode(TriggerMode mode) override;
    TriggerMode getTriggerMode() const override;

private:
    class Impl;  // PIMPL模式隐藏GenICam SDK细节
    std::unique_ptr<Impl> impl_;
};


// ============================================================
// 模拟相机（用于测试）
// ============================================================
class SimulatedCamera : public ICamera {
    Q_OBJECT

public:
    explicit SimulatedCamera(QObject* parent = nullptr);

    void setImageSource(const QString& imagePath);  // 设置测试图像
    void setImageSequence(const QStringList& imagePaths);

    // ... 实现ICamera接口
};
```

### 5.2 光源接口

```cpp
// ============================================================
// 光源抽象接口
// ============================================================
class ILight : public QObject {
    Q_OBJECT

public:
    virtual ~ILight() = default;

    virtual bool open() = 0;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;

    // 亮度控制 (0-255)
    virtual void setBrightness(int channel, int value) = 0;
    virtual int getBrightness(int channel) const = 0;

    // 开关
    virtual void turnOn(int channel) = 0;
    virtual void turnOff(int channel) = 0;
    virtual void turnOnAll() = 0;
    virtual void turnOffAll() = 0;

signals:
    void errorOccurred(const QString& error);

protected:
    ILight(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// 串口光源控制器
// ============================================================
class SerialLightController : public ILight {
    Q_OBJECT

public:
    explicit SerialLightController(const QString& portName,
                                  QObject* parent = nullptr);
    ~SerialLightController() override;

    // ... 实现ILight接口

private:
    QSerialPort* serialPort_;
    QString portName_;
};
```

### 5.3 PLC接口

```cpp
// ============================================================
// PLC抽象接口
// ============================================================
class IPLC : public QObject {
    Q_OBJECT

public:
    virtual ~IPLC() = default;

    virtual bool connect() = 0;
    virtual void disconnect() = 0;
    virtual bool isConnected() const = 0;

    // 数字IO
    virtual bool readDI(int address) = 0;
    virtual void writeDO(int address, bool value) = 0;

    // 寄存器读写
    virtual quint16 readRegister(int address) = 0;
    virtual void writeRegister(int address, quint16 value) = 0;

signals:
    void connected();
    void disconnected();
    void errorOccurred(const QString& error);

protected:
    IPLC(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// Modbus PLC实现
// ============================================================
class ModbusPLC : public IPLC {
    Q_OBJECT

public:
    explicit ModbusPLC(const QString& ip, int port,
                      QObject* parent = nullptr);
    ~ModbusPLC() override;

    // ... 实现IPLC接口

private:
    QModbusTcpClient* modbusClient_;
    QString ipAddress_;
    int port_;
};
```

---

## 6. 基础设施层类图

### 6.1 图像数据管理

```cpp
// ============================================================
// 图像数据
// ============================================================
class ImageData {
public:
    using Ptr = std::shared_ptr<ImageData>;

    ImageData();
    explicit ImageData(const cv::Mat& mat);
    ~ImageData();

    // OpenCV矩阵
    cv::Mat& mat() { return mat_; }
    const cv::Mat& mat() const { return mat_; }

    // GPU数据（可选）
    void* gpuPtr() const { return gpuPtr_; }
    void allocateGPU();
    void uploadToGPU();
    void downloadFromGPU();

    // 元数据
    size_t timestamp() const { return timestamp_; }
    void setTimestamp(size_t ts) { timestamp_ = ts; }

    int width() const { return mat_.cols; }
    int height() const { return mat_.rows; }
    int channels() const { return mat_.channels(); }

    // 浅拷贝
    Ptr clone() const;

    // 禁止拷贝构造和赋值
    ImageData(const ImageData&) = delete;
    ImageData& operator=(const ImageData&) = delete;

private:
    cv::Mat mat_;
    void* gpuPtr_;
    size_t timestamp_;
};


// ============================================================
// 图像内存池
// ============================================================
class ImageMemoryPool {
public:
    static ImageMemoryPool& instance();

    ImageData::Ptr allocate(int width, int height, int type);
    void release(ImageData::Ptr image);

    void clear();  // 清空池
    size_t size() const;  // 池中对象数量

private:
    ImageMemoryPool();
    ~ImageMemoryPool();

    struct PoolKey {
        int width;
        int height;
        int type;

        bool operator<(const PoolKey& other) const;
    };

    QMap<PoolKey, QList<ImageData::Ptr>> pool_;
    QMutex mutex_;
};
```

### 6.2 日志系统

```cpp
// ============================================================
// 日志系统
// ============================================================
class Logger {
public:
    enum Level {
        Debug, Info, Warning, Error, Critical
    };

    static Logger& instance();

    void log(Level level, const QString& message,
            const QString& file = "", int line = 0);

    void setLogLevel(Level level);
    void setLogFile(const QString& filePath);
    void enableConsoleOutput(bool enabled);

    // 便捷宏
    #define LOG_DEBUG(msg) \
        Logger::instance().log(Logger::Debug, msg, __FILE__, __LINE__)
    #define LOG_INFO(msg) \
        Logger::instance().log(Logger::Info, msg, __FILE__, __LINE__)
    #define LOG_WARNING(msg) \
        Logger::instance().log(Logger::Warning, msg, __FILE__, __LINE__)
    #define LOG_ERROR(msg) \
        Logger::instance().log(Logger::Error, msg, __FILE__, __LINE__)

private:
    Logger();
    ~Logger();

    void writeToFile(const QString& formattedMessage);

private:
    Level logLevel_;
    QString logFilePath_;
    bool consoleOutput_;
    QMutex mutex_;
    QFile* logFile_;
};
```

### 6.3 配置管理

```cpp
// ============================================================
// 配置管理器
// ============================================================
class ConfigManager {
public:
    static ConfigManager& instance();

    // 读取配置
    QVariant getValue(const QString& key,
                     const QVariant& defaultValue = QVariant()) const;

    // 写入配置
    void setValue(const QString& key, const QVariant& value);

    // 保存/加载
    bool save();
    bool load();

    // 配置文件路径
    QString configFilePath() const;
    void setConfigFilePath(const QString& path);

private:
    ConfigManager();
    ~ConfigManager();

private:
    QString configPath_;
    QSettings* settings_;
};
```

---

## 7. 类关系总结

### 7.1 依赖关系

```
MainWindow
    ├─> RecipeManager
    ├─> TaskScheduler
    │       └─> PipelineExecutor
    │               └─> VisionTool (多个)
    ├─> SimpleModeWidget
    │       ├─> StepListWidget
    │       ├─> ImageDisplayWidget
    │       └─> SimpleParamPanel
    └─> ProfessionalModeWidget
            ├─> ProjectTreeWidget
            ├─> ToolboxWidget
            ├─> PropertyPanel
            └─> StepNavigator

Recipe
    ├─> VisionTool[] (步骤列表)
    ├─> CameraConfig
    └─> JudgmentRules

VisionTool (抽象)
    ├─> GrayTool
    ├─> FindCircleTool
    ├─> AIDetectionTool
    └─> ... (其他工具)

ICamera (抽象)
    ├─> GenICamCamera
    └─> SimulatedCamera

IPLC (抽象)
    ├─> ModbusPLC
    └─> EthernetIPPLC
```

### 7.2 继承关系

```
QObject
    ├─> VisionTool
    │       ├─> GrayTool
    │       ├─> FindCircleTool
    │       └─> ...
    │
    ├─> ICamera
    │       ├─> GenICamCamera
    │       └─> SimulatedCamera
    │
    ├─> IPLC
    │       ├─> ModbusPLC
    │       └─> ...
    │
    ├─> RecipeManager
    ├─> TaskScheduler
    └─> ...

QWidget
    ├─> MainWindow (继承QMainWindow)
    ├─> SimpleModeWidget
    ├─> ProfessionalModeWidget
    ├─> StepListWidget (继承QListWidget)
    ├─> PropertyPanel (继承QScrollArea)
    └─> ...
```

---

## 8. 设计模式应用

| 模式 | 应用场景 | 类 |
|------|---------|-----|
| **单例模式** | 全局唯一实例 | RecipeManager, ToolFactory, Logger |
| **工厂模式** | 创建工具对象 | ToolFactory |
| **策略模式** | 不同算法实现 | VisionTool子类 |
| **观察者模式** | UI更新通知 | Qt信号槽机制 |
| **命令模式** | 撤销/重做 | RecipeVersionControl |
| **适配器模式** | 硬件接口适配 | ICamera子类 |
| **外观模式** | 简化复杂接口 | RecipeManager |
| **PIMPL** | 隐藏实现细节 | GenICamCamera::Impl |

---

**文档状态**: ✅ 已完成
**下一步**: 编写交互流程图设计
