# VisionForge Pro - 核心类图设计

## 文档信息

- **文档版本**: v1.2
- **创建日期**: 2025-12-14
- **最后更新**: 2025-12-14 (v1.2 - 新增图像加速基础设施类图)
- **设计者**: VisionForge Team

---

## 1. 整体类图概览

```
┌─────────────────────────────────────────────────────────────┐
│                       类图层次结构                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  UI层                    业务层                算法层        │
│  ┌──────────┐         ┌──────────┐         ┌──────────┐    │
│  │MainWindow│────────>│ Recipe   │────────>│VisionTool│    │
│  │          │         │ Manager  │         │          │    │
│  └──────────┘         └──────────┘         └──────────┘    │
│       │                    │                     │         │
│       ├─SimpleMode         ├─TaskScheduler       ├─GrayTool│
│       └─ProMode            └─ResultJudge         └─BlurTool│
│                                                             │
│  HAL层                   基础设施层                          │
│  ┌──────────┐         ┌──────────┐                         │
│  │ICamera   │         │MemPool   │                         │
│  │ILight    │         │Logger    │                         │
│  │IPLC      │         │Config    │                         │
│  └──────────┘         └──────────┘                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. UI层类图

### 2.1 主窗口及模式管理

```cpp
// ============================================================
// 主窗口类 - 应用程序入口
// ============================================================
class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    explicit MainWindow(QWidget* parent = nullptr);
    ~MainWindow() override;

    void loadRecipe(const QString& filePath);
    void saveRecipe(const QString& filePath);

public slots:
    void onSwitchMode(UIMode mode);
    void onRunClicked();
    void onStopClicked();

private:
    void setupUI();
    void createMenuBar();
    void createToolBar();
    void createStatusBar();

private:
    // 模式管理
    UIModeManager* modeManager_;

    // UI模式
    SimpleModeWidget* simpleMode_;
    ProfessionalModeWidget* proMode_;
    QStackedWidget* modeStack_;

    // 核心组件
    RecipeManager* recipeManager_;
    TaskScheduler* taskScheduler_;
    ImageDisplayWidget* imageDisplay_;

    // 状态
    QLabel* statusLabel_;
    QProgressBar* progressBar_;
};


// ============================================================
// UI模式管理器
// ============================================================
class UIModeManager : public QObject {
    Q_OBJECT

public:
    enum UIMode { Simple, Professional };

    explicit UIModeManager(QObject* parent = nullptr);

    UIMode currentMode() const { return currentMode_; }
    void switchMode(UIMode mode);

signals:
    void modeChanged(UIMode newMode);
    void modeWillChange(UIMode oldMode, UIMode newMode);

private:
    void saveState();
    void restoreState();

private:
    UIMode currentMode_;
    QSettings* settings_;
};
```

### 2.2 简单模式UI

```cpp
// ============================================================
// 简单模式主界面
// ============================================================
class SimpleModeWidget : public QWidget {
    Q_OBJECT

public:
    explicit SimpleModeWidget(QWidget* parent = nullptr);

    void setRecipe(Recipe* recipe);
    void updateCurrentStep(int stepIndex);

signals:
    void stepSelected(int stepIndex);
    void toolAdded(const QString& toolType);
    void paramChanged(int stepIndex, const QJsonObject& params);

private slots:
    void onAddStepClicked();
    void onStepItemClicked(int index);

private:
    void setupLayout();

private:
    // 核心组件
    StepListWidget* stepList_;          // 左侧步骤列表
    ImageDisplayWidget* imageDisplay_;  // 中间图像显示
    SimpleParamPanel* paramPanel_;      // 右侧参数面板

    // 工具选择器
    QuickToolSelector* toolSelector_;

    // 数据
    Recipe* currentRecipe_;
};


// ============================================================
// 步骤列表组件
// ============================================================
class StepListWidget : public QListWidget {
    Q_OBJECT

public:
    explicit StepListWidget(QWidget* parent = nullptr);

    void addStep(VisionTool* tool);
    void removeStep(int index);
    void setStepEnabled(int index, bool enabled);
    void setCurrentStep(int index);

signals:
    void stepClicked(int index);
    void stepMoved(int fromIndex, int toIndex);
    void stepEnabledChanged(int index, bool enabled);

protected:
    void dropEvent(QDropEvent* event) override;
    void dragEnterEvent(QDragEnterEvent* event) override;

private:
    // 自定义Item委托（绘制步骤项）
    StepItemDelegate* delegate_;
};


// ============================================================
// 步骤项委托 - 自定义绘制
// ============================================================
class StepItemDelegate : public QStyledItemDelegate {
    Q_OBJECT

public:
    explicit StepItemDelegate(QObject* parent = nullptr);

    void paint(QPainter* painter,
               const QStyleOptionViewItem& option,
               const QModelIndex& index) const override;

    QSize sizeHint(const QStyleOptionViewItem& option,
                   const QModelIndex& index) const override;

private:
    void drawStepIcon(QPainter* painter, const QRect& rect,
                      const QString& toolType) const;
    void drawStepStatus(QPainter* painter, const QRect& rect,
                        bool enabled, bool hasError) const;
};


// ============================================================
// 简化参数面板
// ============================================================
class SimpleParamPanel : public QScrollArea {
    Q_OBJECT

public:
    explicit SimpleParamPanel(QWidget* parent = nullptr);

    void setTool(VisionTool* tool);
    void clear();

signals:
    void paramChanged(const QJsonObject& params);

private:
    void createParamWidgets(VisionTool* tool);
    void createSliderParam(const QString& name,
                          double min, double max, double value);
    void createComboParam(const QString& name,
                         const QStringList& options, int current);

private:
    QWidget* contentWidget_;
    QFormLayout* layout_;
    VisionTool* currentTool_;

    // 参数控件映射
    QMap<QString, QWidget*> paramWidgets_;
};


// ============================================================
// 快速工具选择器对话框
// ============================================================
class QuickToolSelector : public QDialog {
    Q_OBJECT

public:
    explicit QuickToolSelector(QWidget* parent = nullptr);

    QString selectedToolType() const;

signals:
    void toolSelected(const QString& toolType);

private:
    void createToolButtons();
    void onToolButtonClicked(const QString& toolType);

private:
    QGridLayout* buttonLayout_;
    QMap<QString, QPushButton*> toolButtons_;
    QString selectedType_;
};
```

### 2.3 专业模式UI

```cpp
// ============================================================
// 专业模式主界面
// ============================================================
class ProfessionalModeWidget : public QWidget {
    Q_OBJECT

public:
    explicit ProfessionalModeWidget(QWidget* parent = nullptr);

    void setProject(Project* project);

signals:
    void recipeSelected(Recipe* recipe);
    void stepSelected(int stepIndex);

private:
    void setupLayout();

private:
    // 左侧
    ProjectTreeWidget* projectTree_;   // 项目树
    ToolboxWidget* toolbox_;           // 工具箱

    // 中间
    QTabWidget* workspaceTab_;         // 多Tab工作区
    ImageDisplayWidget* imageView_;    // 图像Tab（高性能渲染）
    FlowEditorView* flowChart_;        // 流程Tab（优化的QGraphicsView）
    DataGridWidget* dataGrid_;         // 数据Tab
    LogViewerWidget* logViewer_;       // 日志Tab

    // 右侧
    PropertyPanel* propertyPanel_;     // 属性面板

    // 底部
    StepNavigator* stepNavigator_;     // 步骤导航条
};


// ============================================================
// 项目树组件
// ============================================================
class ProjectTreeWidget : public QTreeWidget {
    Q_OBJECT

public:
    explicit ProjectTreeWidget(QWidget* parent = nullptr);

    void setProject(Project* project);
    void addRecipe(Recipe* recipe);
    void removeRecipe(const QString& recipeId);

signals:
    void recipeSelected(Recipe* recipe);
    void taskSelected(Task* task);

private:
    void createContextMenu();

private:
    Project* currentProject_;
    QMenu* contextMenu_;
};


// ============================================================
// 工具箱组件（可拖拽）
// ============================================================
class ToolboxWidget : public QWidget {
    Q_OBJECT

public:
    explicit ToolboxWidget(QWidget* parent = nullptr);

    void addToolCategory(const QString& category,
                        const QStringList& tools);

signals:
    void toolDragged(const QString& toolType);

private:
    void createToolItems();

private:
    QVBoxLayout* layout_;
    QMap<QString, QListWidget*> categoryLists_;
};


// ============================================================
// 完整属性面板（分组、可折叠）
// ============================================================
class PropertyPanel : public QScrollArea {
    Q_OBJECT

public:
    explicit PropertyPanel(QWidget* parent = nullptr);

    void setTool(VisionTool* tool);
    void clear();

signals:
    void paramChanged(const QJsonObject& params);

private:
    void createBasicGroup(VisionTool* tool);
    void createAdvancedGroup(VisionTool* tool);
    void createDebugGroup(VisionTool* tool);

private:
    QWidget* contentWidget_;
    QVBoxLayout* layout_;

    // 分组面板
    QGroupBox* basicGroup_;
    QGroupBox* advancedGroup_;
    QGroupBox* debugGroup_;

    VisionTool* currentTool_;
};


// ============================================================
// 步骤导航条（快速跳转）
// ============================================================
class StepNavigator : public QWidget {
    Q_OBJECT

public:
    explicit StepNavigator(QWidget* parent = nullptr);

    void setSteps(const QList<VisionTool*>& steps);
    void setCurrentStep(int index);

signals:
    void stepClicked(int index);

private:
    void createStepButtons();

private:
    QHBoxLayout* layout_;
    QList<QPushButton*> stepButtons_;
    int currentStep_;
};
```

### 2.4 高性能UI组件

```cpp
// ============================================================
// 高性能图像显示组件（支持零拷贝、OpenGL渲染）
// ============================================================
class ImageDisplayWidget : public QOpenGLWidget {
    Q_OBJECT

public:
    explicit ImageDisplayWidget(QWidget* parent = nullptr);
    ~ImageDisplayWidget() override;

    // 显示图像（零拷贝）
    void setImage(ImageData::Ptr image);
    void setImage(const QImage& image);

    // 缩放控制
    void fitToWindow();
    void actualSize();
    void zoomIn();
    void zoomOut();
    void setZoomLevel(double level);  // 1.0 = 100%
    double zoomLevel() const { return zoomLevel_; }

    // ROI绘制
    void setROI(const QRect& roi);
    QRect getROI() const { return roi_; }
    void clearROI();

    // 叠加层（结果标注）
    void addOverlay(const QString& id, QGraphicsItem* item);
    void removeOverlay(const QString& id);
    void clearOverlays();

    // 性能优化选项
    void setUseOpenGL(bool enable);
    void setAntialiasing(bool enable);
    void setCacheMode(bool enable);

    // 渲染模式
    enum RenderMode {
        Quality,      // 高质量（抗锯齿）
        Performance   // 高性能（快速渲染）
    };
    void setRenderMode(RenderMode mode);

signals:
    void zoomChanged(double level);
    void roiChanged(const QRect& roi);
    void mousePositionChanged(const QPoint& pos, const QRgb& color);

protected:
    void initializeGL() override;
    void resizeGL(int w, int h) override;
    void paintGL() override;

    void wheelEvent(QWheelEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;

private:
    void updateTransform();
    QPointF imageToWidget(const QPointF& imagePos) const;
    QPointF widgetToImage(const QPointF& widgetPos) const;

private:
    ImageData::Ptr currentImage_;
    QOpenGLTexture* texture_;
    QOpenGLShaderProgram* shaderProgram_;

    double zoomLevel_;
    QPointF offset_;
    QTransform transform_;

    // ROI
    QRect roi_;
    bool drawingROI_;
    QPoint roiStartPoint_;

    // 叠加层
    QMap<QString, QGraphicsItem*> overlays_;

    // 渲染设置
    bool useOpenGL_;
    bool antialiasing_;
    bool cacheMode_;
    RenderMode renderMode_;

    // 鼠标交互
    bool panning_;
    QPoint lastMousePos_;
};


// ============================================================
// 优化的流程编辑器视图
// ============================================================
class FlowEditorView : public QGraphicsView {
    Q_OBJECT

public:
    explicit FlowEditorView(QWidget* parent = nullptr);
    ~FlowEditorView() override;

    void setScene(QGraphicsScene* scene);

    // 性能优化配置
    void setupOptimizations();

    // 缩放控制
    void zoomIn();
    void zoomOut();
    void fitInView();
    void resetZoom();

signals:
    void scaleChanged(double scale);

protected:
    void wheelEvent(QWheelEvent* event) override;
    void drawBackground(QPainter* painter, const QRectF& rect) override;

private:
    void applyOptimizationSettings();

private:
    double currentScale_;
};


// ============================================================
// 流程图节点基类（优化绘制）
// ============================================================
class FlowNodeItem : public QGraphicsItem {
public:
    explicit FlowNodeItem(VisionTool* tool, QGraphicsItem* parent = nullptr);

    QRectF boundingRect() const override;
    void paint(QPainter* painter, const QStyleOptionGraphicsItem* option,
              QWidget* widget) override;

    // 性能优化
    QPainterPath shape() const override;  // 精确碰撞检测
    int type() const override { return UserType + 1; }

    // 工具访问
    VisionTool* tool() const { return tool_; }

    // 视觉状态
    void setHighlighted(bool highlighted);
    void setExecuting(bool executing);
    void setError(bool error);

protected:
    void mousePressEvent(QGraphicsSceneMouseEvent* event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent* event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent* event) override;

private:
    void updateCachedPixmap();

private:
    VisionTool* tool_;
    bool highlighted_;
    bool executing_;
    bool hasError_;

    // 缓存的渲染结果
    QPixmap cachedPixmap_;
    bool pixmapDirty_;
};


// ============================================================
// 流程图连接线（优化绘制）
// ============================================================
class FlowConnectionItem : public QGraphicsItem {
public:
    FlowConnectionItem(FlowNodeItem* source, FlowNodeItem* target,
                      QGraphicsItem* parent = nullptr);

    QRectF boundingRect() const override;
    QPainterPath shape() const override;
    void paint(QPainter* painter, const QStyleOptionGraphicsItem* option,
              QWidget* widget) override;

    void updatePath();

    // 视觉状态
    void setHighlighted(bool highlighted);
    void setActive(bool active);

private:
    QPainterPath computePath() const;

private:
    FlowNodeItem* source_;
    FlowNodeItem* target_;
    QPainterPath path_;
    bool highlighted_;
    bool active_;
};
```

---

## 3. 业务逻辑层类图

### 3.1 配方管理

```cpp
// ============================================================
// 配方类 - 核心数据模型
// ============================================================
class Recipe : public QObject {
    Q_OBJECT

public:
    struct Metadata {
        QString name;
        int version;
        QDateTime createdTime;
        QDateTime modifiedTime;
        QString author;
    };

    explicit Recipe(QObject* parent = nullptr);
    ~Recipe() override;

    // 元数据
    const Metadata& metadata() const { return metadata_; }
    void setMetadata(const Metadata& meta) { metadata_ = meta; }

    // 步骤管理
    void addStep(VisionTool* tool);
    void insertStep(int index, VisionTool* tool);
    void removeStep(int index);
    void moveStep(int fromIndex, int toIndex);
    int stepCount() const { return steps_.size(); }
    VisionTool* step(int index) const;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);

    // 保存/加载
    bool save(const QString& filePath);
    bool load(const QString& filePath);

signals:
    void stepAdded(int index);
    void stepRemoved(int index);
    void stepMoved(int fromIndex, int toIndex);
    void metadataChanged();

private:
    Metadata metadata_;
    QList<VisionTool*> steps_;
    CameraConfig* cameraConfig_;
    JudgmentRules* judgmentRules_;
};


// ============================================================
// 配方管理器
// ============================================================
class RecipeManager : public QObject {
    Q_OBJECT

public:
    static RecipeManager& instance();

    Recipe* createRecipe(const QString& name);
    Recipe* openRecipe(const QString& filePath);
    bool saveRecipe(Recipe* recipe, const QString& filePath);
    void closeRecipe(Recipe* recipe);

    Recipe* currentRecipe() const { return currentRecipe_; }
    void setCurrentRecipe(Recipe* recipe);

    // 版本控制
    RecipeVersion* getVersion(Recipe* recipe, int version);
    void createSnapshot(Recipe* recipe, const QString& changeLog);
    bool rollback(Recipe* recipe, int targetVersion);

signals:
    void recipeOpened(Recipe* recipe);
    void recipeClosed(Recipe* recipe);
    void currentRecipeChanged(Recipe* recipe);

private:
    RecipeManager();
    ~RecipeManager();

private:
    Recipe* currentRecipe_;
    QMap<QString, Recipe*> loadedRecipes_;
    RecipeVersionControl* versionControl_;
};


// ============================================================
// 配方版本控制
// ============================================================
class RecipeVersionControl : public QObject {
    Q_OBJECT

public:
    struct Version {
        int versionNumber;
        QDateTime timestamp;
        QString author;
        QString changeLog;
        QJsonObject recipeSnapshot;
    };

    explicit RecipeVersionControl(QObject* parent = nullptr);

    void addVersion(const QString& recipeId, const Version& version);
    QList<Version> getVersionHistory(const QString& recipeId) const;
    Version getVersion(const QString& recipeId, int version) const;

    // 对比两个版本
    QJsonObject diff(const QString& recipeId, int v1, int v2) const;

private:
    // recipeId -> version list
    QMap<QString, QList<Version>> versionHistory_;
};
```

### 3.2 任务调度

```cpp
// ============================================================
// 任务调度器
// ============================================================
class TaskScheduler : public QObject {
    Q_OBJECT

public:
    enum RunMode {
        SingleRun,      // 单次运行
        Continuous,     // 连续运行
        Triggered       // 外部触发
    };

    explicit TaskScheduler(QObject* parent = nullptr);
    ~TaskScheduler() override;

    void setRecipe(Recipe* recipe);
    void setRunMode(RunMode mode);

    void start();
    void stop();
    void pause();
    void resume();

    bool isRunning() const { return isRunning_; }

signals:
    void started();
    void stopped();
    void stepStarted(int stepIndex);
    void stepFinished(int stepIndex, bool success);
    void resultReady(const InspectionResult& result);
    void errorOccurred(const QString& error);

private slots:
    void runPipeline();
    void onStepFinished(bool success);

private:
    Recipe* recipe_;
    RunMode runMode_;
    bool isRunning_;
    bool isPaused_;

    // 执行引擎
    PipelineExecutor* executor_;

    // 统计
    int runCount_;
    int okCount_;
    int ngCount_;
};


// ============================================================
// 流程执行引擎
// ============================================================
class PipelineExecutor : public QObject {
    Q_OBJECT

public:
    explicit PipelineExecutor(QObject* parent = nullptr);

    void setSteps(const QList<VisionTool*>& steps);
    bool execute(ImageData::Ptr input, InspectionResult& output);

    // 调试模式（单步执行）
    void setDebugMode(bool enabled);
    bool stepInto();  // 执行下一步
    ImageData::Ptr getCurrentStepResult() const;

signals:
    void stepExecuted(int stepIndex, qint64 elapsedMs);
    void pipelineFinished(bool success);

private:
    void executeStep(int index);

private:
    QList<VisionTool*> steps_;
    int currentStep_;
    bool debugMode_;

    // 中间结果缓存
    QVector<ImageData::Ptr> intermediateResults_;

    // 性能监控
    PerformanceMonitor* perfMonitor_;
};


// ============================================================
// 检测结果
// ============================================================
struct InspectionResult {
    bool ok;                       // OK/NG判定
    QDateTime timestamp;           // 时间戳
    qint64 totalTime;              // 总耗时(ms)

    // 步骤结果
    struct StepResult {
        QString toolType;
        bool success;
        qint64 elapsedTime;
        QJsonObject data;          // 结果数据
    };
    QList<StepResult> stepResults;

    // 图像
    ImageData::Ptr inputImage;     // 输入图像
    ImageData::Ptr resultImage;    // 结果图像（带标注）

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};
```

### 3.3 结果判定

```cpp
// ============================================================
// 判定规则引擎
// ============================================================
class JudgmentEngine : public QObject {
    Q_OBJECT

public:
    explicit JudgmentEngine(QObject* parent = nullptr);

    void setRules(const JudgmentRules& rules);
    bool evaluate(const InspectionResult& result) const;

private:
    bool evaluateExpression(const QString& expr,
                           const QJsonObject& data) const;

private:
    JudgmentRules rules_;
    ExpressionParser* parser_;
};


// ============================================================
// 判定规则
// ============================================================
struct JudgmentRules {
    QString okCondition;           // OK条件表达式
    QString ngCondition;           // NG条件表达式

    // 输出映射
    struct OutputMapping {
        QString condition;
        int outputPort;            // DO端口号
        bool value;                // 输出值
    };
    QList<OutputMapping> outputs;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 表达式解析器（简单实现）
// ============================================================
class ExpressionParser {
public:
    bool parse(const QString& expression, const QJsonObject& context);

private:
    QVariant evaluate(const QString& expr);
};
```

---

## 4. 算法服务层类图

### 4.1 视觉工具基类

```cpp
// ============================================================
// 视觉工具抽象基类
// ============================================================
class VisionTool : public QObject {
    Q_OBJECT

public:
    enum ToolType {
        // 图像源
        Camera, File, Video,

        // 预处理
        Gray, Blur, Binary, ROI, ColorConvert,

        // 定位检测
        TemplateMatch, FindCircle, FindLine, FindEdge,
        BlobAnalysis, AIDetection,

        // 测量计算
        MeasureDistance, MeasureAngle, MeasureArea,
        CalcCenter, CalcOrientation,

        // 判定输出
        RangeJudge, LogicOperation, PLCOutput, SaveImage
    };

    explicit VisionTool(QObject* parent = nullptr);
    virtual ~VisionTool() = default;

    // ========== 核心接口 ==========
    virtual ToolType toolType() const = 0;
    virtual QString toolName() const = 0;
    virtual QIcon toolIcon() const = 0;

    // 处理接口
    virtual bool process(const ImageData::Ptr& input,
                        ToolResult& output) = 0;

    // 参数接口
    virtual QWidget* createParamWidget() = 0;
    virtual QJsonObject serializeParams() const = 0;
    virtual void deserializeParams(const QJsonObject& json) = 0;

    // 调试接口
    virtual ImageData::Ptr getDebugImage() const { return debugImage_; }
    virtual QString getStatusText() const { return statusText_; }

    // ========== 属性 ==========
    bool isEnabled() const { return enabled_; }
    void setEnabled(bool enabled);

    QString displayName() const { return displayName_; }
    void setDisplayName(const QString& name);

signals:
    void paramChanged();
    void processingStarted();
    void processingFinished(bool success, qint64 elapsedMs);
    void debugImageUpdated();
    void statusTextChanged(const QString& text);

protected:
    void setDebugImage(const ImageData::Ptr& image);
    void setStatusText(const QString& text);

protected:
    bool enabled_;
    QString displayName_;
    ImageData::Ptr debugImage_;
    QString statusText_;
};


// ============================================================
// 工具结果
// ============================================================
struct ToolResult {
    bool success;                  // 是否成功
    QString errorMessage;          // 错误消息
    QJsonObject data;              // 结果数据
    ImageData::Ptr outputImage;    // 输出图像

    // 便捷方法
    template<typename T>
    T getValue(const QString& key, const T& defaultValue = T()) const {
        return data.value(key).toVariant().value<T>();
    }

    void setValue(const QString& key, const QVariant& value) {
        data[key] = QJsonValue::fromVariant(value);
    }
};
```

### 4.2 具体工具实现示例

```cpp
// ============================================================
// 灰度转换工具
// ============================================================
class GrayTool : public VisionTool {
    Q_OBJECT

public:
    enum ConvertMode {
        Average,      // 平均法
        Weighted,     // 加权法
        Desaturation, // 去饱和法
        SingleChannel // 单通道
    };

    explicit GrayTool(QObject* parent = nullptr);

    ToolType toolType() const override { return Gray; }
    QString toolName() const override { return tr("灰度转换"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // 参数设置
    void setConvertMode(ConvertMode mode) { convertMode_ = mode; }
    ConvertMode convertMode() const { return convertMode_; }

private:
    ConvertMode convertMode_;
};


// ============================================================
// 找圆工具
// ============================================================
class FindCircleTool : public VisionTool {
    Q_OBJECT

public:
    struct Params {
        double minRadius;          // 最小半径
        double maxRadius;          // 最大半径
        int edgeThreshold;         // 边缘强度
        int minEdgePoints;         // 最小边缘点数
        bool useROI;               // 是否使用ROI
        cv::Rect roi;              // ROI区域
    };

    explicit FindCircleTool(QObject* parent = nullptr);

    ToolType toolType() const override { return FindCircle; }
    QString toolName() const override { return tr("找圆"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // 参数访问
    Params& params() { return params_; }
    const Params& params() const { return params_; }

private:
    Params params_;
    cv::Vec3f lastFoundCircle_;  // 上次找到的圆(x, y, r)
};


// ============================================================
// AI检测工具
// ============================================================
class AIDetectionTool : public VisionTool {
    Q_OBJECT

public:
    explicit AIDetectionTool(QObject* parent = nullptr);
    ~AIDetectionTool() override;

    ToolType toolType() const override { return AIDetection; }
    QString toolName() const override { return tr("AI检测"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // AI模型管理
    bool loadModel(const QString& modelPath);
    void unloadModel();
    bool isModelLoaded() const { return inferenceEngine_ != nullptr; }

    // 参数设置
    void setConfidenceThreshold(float threshold);
    void setNMSThreshold(float threshold);

private:
    QString modelPath_;
    float confidenceThreshold_;
    float nmsThreshold_;

    // AI推理引擎
    AIInferenceEngine* inferenceEngine_;
};
```

### 4.3 工具工厂

```cpp
// ============================================================
// 工具工厂（单例）
// ============================================================
class ToolFactory {
public:
    static ToolFactory& instance();

    // 创建工具
    VisionTool* createTool(VisionTool::ToolType type);
    VisionTool* createTool(const QString& typeName);

    // 注册自定义工具
    void registerTool(const QString& typeName,
                     std::function<VisionTool*()> creator);

    // 获取所有工具类型
    QList<VisionTool::ToolType> availableToolTypes() const;
    QStringList availableToolNames() const;

    // 工具信息
    struct ToolInfo {
        VisionTool::ToolType type;
        QString name;
        QString category;      // 分类
        QString description;   // 描述
        QIcon icon;
    };
    ToolInfo getToolInfo(VisionTool::ToolType type) const;

private:
    ToolFactory();
    ~ToolFactory();

    void registerBuiltInTools();

private:
    QMap<VisionTool::ToolType, std::function<VisionTool*()>> creators_;
    QMap<VisionTool::ToolType, ToolInfo> toolInfos_;
};
```

---

## 5. 硬件抽象层(HAL)类图

### 5.1 相机接口

```cpp
// ============================================================
// 相机抽象接口
// ============================================================
class ICamera : public QObject {
    Q_OBJECT

public:
    enum TriggerMode {
        Continuous,    // 连续采集
        Software,      // 软件触发
        Hardware       // 硬件触发
    };

    struct Config {
        int width;
        int height;
        int offsetX;
        int offsetY;
        double exposure;       // 曝光时间(μs)
        double gain;           // 增益(dB)
        TriggerMode triggerMode;
    };

    virtual ~ICamera() = default;

    // ========== 设备管理 ==========
    virtual bool open() = 0;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;

    virtual QString deviceName() const = 0;
    virtual QString serialNumber() const = 0;

    // ========== 采集控制 ==========
    virtual bool startGrabbing() = 0;
    virtual void stopGrabbing() = 0;
    virtual bool isGrabbing() const = 0;

    virtual ImageData::Ptr grabImage(int timeoutMs = 1000) = 0;
    virtual bool trigger() = 0;  // 软触发

    // ========== 参数配置 ==========
    virtual void setConfig(const Config& config) = 0;
    virtual Config getConfig() const = 0;

    virtual void setExposure(double exposure) = 0;
    virtual double getExposure() const = 0;

    virtual void setGain(double gain) = 0;
    virtual double getGain() const = 0;

    virtual void setTriggerMode(TriggerMode mode) = 0;
    virtual TriggerMode getTriggerMode() const = 0;

signals:
    void imageGrabbed(ImageData::Ptr image);
    void errorOccurred(const QString& error);

protected:
    ICamera(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// GenICam相机实现
// ============================================================
class GenICamCamera : public ICamera {
    Q_OBJECT

public:
    explicit GenICamCamera(const QString& deviceId,
                          QObject* parent = nullptr);
    ~GenICamCamera() override;

    bool open() override;
    void close() override;
    bool isOpen() const override;

    QString deviceName() const override;
    QString serialNumber() const override;

    bool startGrabbing() override;
    void stopGrabbing() override;
    bool isGrabbing() const override;

    ImageData::Ptr grabImage(int timeoutMs = 1000) override;
    bool trigger() override;

    void setConfig(const Config& config) override;
    Config getConfig() const override;

    void setExposure(double exposure) override;
    double getExposure() const override;

    void setGain(double gain) override;
    double getGain() const override;

    void setTriggerMode(TriggerMode mode) override;
    TriggerMode getTriggerMode() const override;

private:
    class Impl;  // PIMPL模式隐藏GenICam SDK细节
    std::unique_ptr<Impl> impl_;
};


// ============================================================
// 模拟相机（用于测试）
// ============================================================
class SimulatedCamera : public ICamera {
    Q_OBJECT

public:
    explicit SimulatedCamera(QObject* parent = nullptr);

    void setImageSource(const QString& imagePath);  // 设置测试图像
    void setImageSequence(const QStringList& imagePaths);

    // ... 实现ICamera接口
};
```

### 5.2 光源接口

```cpp
// ============================================================
// 光源抽象接口
// ============================================================
class ILight : public QObject {
    Q_OBJECT

public:
    virtual ~ILight() = default;

    virtual bool open() = 0;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;

    // 亮度控制 (0-255)
    virtual void setBrightness(int channel, int value) = 0;
    virtual int getBrightness(int channel) const = 0;

    // 开关
    virtual void turnOn(int channel) = 0;
    virtual void turnOff(int channel) = 0;
    virtual void turnOnAll() = 0;
    virtual void turnOffAll() = 0;

signals:
    void errorOccurred(const QString& error);

protected:
    ILight(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// 串口光源控制器
// ============================================================
class SerialLightController : public ILight {
    Q_OBJECT

public:
    explicit SerialLightController(const QString& portName,
                                  QObject* parent = nullptr);
    ~SerialLightController() override;

    // ... 实现ILight接口

private:
    QSerialPort* serialPort_;
    QString portName_;
};
```

### 5.3 PLC接口

```cpp
// ============================================================
// PLC抽象接口
// ============================================================
class IPLC : public QObject {
    Q_OBJECT

public:
    virtual ~IPLC() = default;

    virtual bool connect() = 0;
    virtual void disconnect() = 0;
    virtual bool isConnected() const = 0;

    // 数字IO
    virtual bool readDI(int address) = 0;
    virtual void writeDO(int address, bool value) = 0;

    // 寄存器读写
    virtual quint16 readRegister(int address) = 0;
    virtual void writeRegister(int address, quint16 value) = 0;

signals:
    void connected();
    void disconnected();
    void errorOccurred(const QString& error);

protected:
    IPLC(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// Modbus PLC实现
// ============================================================
class ModbusPLC : public IPLC {
    Q_OBJECT

public:
    explicit ModbusPLC(const QString& ip, int port,
                      QObject* parent = nullptr);
    ~ModbusPLC() override;

    // ... 实现IPLC接口

private:
    QModbusTcpClient* modbusClient_;
    QString ipAddress_;
    int port_;
};
```

---

## 6. 基础设施层类图

### 6.1 图像数据管理

```cpp
// ============================================================
// 图像数据（支持零拷贝、内存对齐、GPU加速）
// ============================================================
class ImageData {
public:
    using Ptr = std::shared_ptr<ImageData>;

    // 构造函数（自动使用32字节对齐内存）
    ImageData();
    ImageData(int width, int height, int type);
    explicit ImageData(const cv::Mat& mat);
    ~ImageData();

    // OpenCV矩阵（零拷贝访问）
    cv::Mat& mat() { return mat_; }
    const cv::Mat& mat() const { return mat_; }

    // Qt图像转换（零拷贝）
    QImage toQImage() const;

    // 从外部对齐内存构造（零拷贝）
    static Ptr fromAlignedMemory(void* data, int width, int height, int type,
                                 std::function<void(void*)> deleter = nullptr);

    // GPU数据管理
    void* gpuPtr() const { return gpuPtr_; }
    bool hasGPUMemory() const { return gpuPtr_ != nullptr; }

    void allocateGPU();
    void uploadToGPU();
    void downloadFromGPU();
    void releaseGPU();

    // 内存对齐
    bool isMemoryAligned() const { return isAligned_; }
    size_t getAlignment() const { return alignment_; }

    // 元数据
    size_t timestamp() const { return timestamp_; }
    void setTimestamp(size_t ts) { timestamp_ = ts; }

    int width() const { return mat_.cols; }
    int height() const { return mat_.rows; }
    int channels() const { return mat_.channels(); }
    size_t totalBytes() const { return mat_.total() * mat_.elemSize(); }

    // 浅拷贝（共享数据）
    Ptr clone() const;

    // 深拷贝（复制数据）
    Ptr deepCopy() const;

    // 禁止拷贝构造和赋值
    ImageData(const ImageData&) = delete;
    ImageData& operator=(const ImageData&) = delete;

private:
    static void cleanupAlignedMemory(void* ptr);

private:
    cv::Mat mat_;                  // OpenCV矩阵
    void* alignedData_;            // 对齐的内存指针
    void* gpuPtr_;                 // GPU内存指针
    size_t timestamp_;             // 时间戳
    bool isAligned_;               // 是否内存对齐
    size_t alignment_;             // 对齐字节数（默认32字节）
    std::function<void(void*)> customDeleter_;  // 自定义析构函数
};


// ============================================================
// 图像内存池（预分配、零拷贝）
// ============================================================
class ImageMemoryPool {
public:
    static ImageMemoryPool& instance();

    // 分配图像（从池中获取或新建）
    ImageData::Ptr allocate(int width, int height, int type);

    // 归还图像到池中（自动调用）
    void release(ImageData::Ptr image);

    // 预分配指定规格的图像
    void preallocate(int width, int height, int type, int count);

    // 清空池
    void clear();

    // 池状态
    size_t size() const;              // 池中总对象数量
    size_t size(int width, int height, int type) const;  // 指定规格的对象数量
    size_t getTotalMemoryUsage() const;  // 总内存使用量（字节）

    // 池配置
    void setMaxPoolSize(size_t maxSize) { maxPoolSize_ = maxSize; }
    size_t getMaxPoolSize() const { return maxPoolSize_; }

    // 统计信息
    struct Statistics {
        size_t totalAllocations;      // 总分配次数
        size_t cacheHits;              // 缓存命中次数
        size_t cacheMisses;            // 缓存未命中次数
        double hitRate;                // 命中率
        size_t poolSize;               // 当前池大小
        size_t memoryUsage;            // 内存使用量（字节）

        QJsonObject toJson() const;
    };
    Statistics getStatistics() const;
    void resetStatistics();

private:
    ImageMemoryPool();
    ~ImageMemoryPool();

    // 池键定义
    struct PoolKey {
        int width;
        int height;
        int type;

        bool operator<(const PoolKey& other) const {
            if (width != other.width) return width < other.width;
            if (height != other.height) return height < other.height;
            return type < other.type;
        }

        size_t getMemorySize() const {
            return static_cast<size_t>(width) * height * CV_ELEM_SIZE(type);
        }
    };

    // 清理超出限制的池对象
    void evictExcess();

private:
    QMap<PoolKey, std::vector<ImageData::Ptr>> pool_;
    mutable QMutex mutex_;

    size_t maxPoolSize_;               // 最大池大小（默认10）

    // 统计信息
    mutable std::atomic<size_t> totalAllocations_{0};
    mutable std::atomic<size_t> cacheHits_{0};
    mutable std::atomic<size_t> cacheMisses_{0};
};
```

### 6.2 日志系统

```cpp
// ============================================================
// 日志系统
// ============================================================
class Logger {
public:
    enum Level {
        Debug, Info, Warning, Error, Critical
    };

    static Logger& instance();

    void log(Level level, const QString& message,
            const QString& file = "", int line = 0);

    void setLogLevel(Level level);
    void setLogFile(const QString& filePath);
    void enableConsoleOutput(bool enabled);

    // 便捷宏
    #define LOG_DEBUG(msg) \
        Logger::instance().log(Logger::Debug, msg, __FILE__, __LINE__)
    #define LOG_INFO(msg) \
        Logger::instance().log(Logger::Info, msg, __FILE__, __LINE__)
    #define LOG_WARNING(msg) \
        Logger::instance().log(Logger::Warning, msg, __FILE__, __LINE__)
    #define LOG_ERROR(msg) \
        Logger::instance().log(Logger::Error, msg, __FILE__, __LINE__)

private:
    Logger();
    ~Logger();

    void writeToFile(const QString& formattedMessage);

private:
    Level logLevel_;
    QString logFilePath_;
    bool consoleOutput_;
    QMutex mutex_;
    QFile* logFile_;
};
```

### 6.3 配置管理

```cpp
// ============================================================
// 配置管理器
// ============================================================
class ConfigManager {
public:
    static ConfigManager& instance();

    // 读取配置
    QVariant getValue(const QString& key,
                     const QVariant& defaultValue = QVariant()) const;

    // 写入配置
    void setValue(const QString& key, const QVariant& value);

    // 保存/加载
    bool save();
    bool load();

    // 配置文件路径
    QString configFilePath() const;
    void setConfigFilePath(const QString& path);

private:
    ConfigManager();
    ~ConfigManager();

private:
    QString configPath_;
    QSettings* settings_;
};
```

### 6.4 内存管理工具

```cpp
// ============================================================
// 内存对齐分配器
// ============================================================
template<typename T, size_t Alignment = 32>
class AlignedAllocator {
public:
    using value_type = T;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using size_type = size_t;
    using difference_type = ptrdiff_t;

    template<typename U>
    struct rebind {
        using other = AlignedAllocator<U, Alignment>;
    };

    AlignedAllocator() noexcept = default;

    template<typename U>
    AlignedAllocator(const AlignedAllocator<U, Alignment>&) noexcept {}

    // 分配对齐内存
    pointer allocate(size_type n) {
        if (n == 0) return nullptr;

        size_type size = n * sizeof(T);

#ifdef _WIN32
        void* ptr = _aligned_malloc(size, Alignment);
#else
        void* ptr = nullptr;
        if (posix_memalign(&ptr, Alignment, size) != 0) {
            ptr = nullptr;
        }
#endif

        if (!ptr) {
            throw std::bad_alloc();
        }

        return static_cast<pointer>(ptr);
    }

    // 释放对齐内存
    void deallocate(pointer p, size_type) noexcept {
        if (!p) return;

#ifdef _WIN32
        _aligned_free(p);
#else
        free(p);
#endif
    }

    // 构造对象
    template<typename U, typename... Args>
    void construct(U* p, Args&&... args) {
        ::new(static_cast<void*>(p)) U(std::forward<Args>(args)...);
    }

    // 析构对象
    template<typename U>
    void destroy(U* p) {
        p->~U();
    }

    size_type max_size() const noexcept {
        return std::numeric_limits<size_type>::max() / sizeof(T);
    }
};

template<typename T1, size_t A1, typename T2, size_t A2>
bool operator==(const AlignedAllocator<T1, A1>&, const AlignedAllocator<T2, A2>&) noexcept {
    return A1 == A2;
}

template<typename T1, size_t A1, typename T2, size_t A2>
bool operator!=(const AlignedAllocator<T1, A1>&, const AlignedAllocator<T2, A2>&) noexcept {
    return A1 != A2;
}


// ============================================================
// 对齐内存工具函数
// ============================================================
class AlignedMemoryHelper {
public:
    // 分配对齐内存
    static void* allocate(size_t size, size_t alignment = 32);

    // 释放对齐内存
    static void deallocate(void* ptr);

    // 检查内存是否对齐
    static bool isAligned(const void* ptr, size_t alignment = 32);

    // 获取对齐后的大小
    static size_t getAlignedSize(size_t size, size_t alignment = 32);

    // 对齐指针
    static void* alignPointer(void* ptr, size_t alignment = 32);
};
```

### 6.5 性能监控

```cpp
// ============================================================
// 性能计数器
// ============================================================
class PerformanceCounter {
public:
    PerformanceCounter() : startTime_(std::chrono::high_resolution_clock::now()) {}

    // 重置计时器
    void reset() {
        startTime_ = std::chrono::high_resolution_clock::now();
    }

    // 获取经过的时间（毫秒）
    double elapsedMs() const {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration<double, std::milli>(now - startTime_).count();
    }

    // 获取经过的时间（微秒）
    double elapsedUs() const {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration<double, std::micro>(now - startTime_).count();
    }

    // 获取经过的时间（纳秒）
    int64_t elapsedNs() const {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration_cast<std::chrono::nanoseconds>(now - startTime_).count();
    }

private:
    std::chrono::high_resolution_clock::time_point startTime_;
};


// ============================================================
// 性能监控器（单例）
// ============================================================
class PerformanceMonitor : public QObject {
    Q_OBJECT

public:
    static PerformanceMonitor& instance();

    // 记录性能数据
    struct Metrics {
        QString name;                  // 指标名称
        double value;                  // 指标值
        QString unit;                  // 单位（ms, fps, MB等）
        QDateTime timestamp;           // 时间戳
    };

    void recordMetric(const QString& name, double value, const QString& unit = "ms");

    // 记录步骤执行时间
    void recordStepTime(int stepIndex, const QString& toolName, double elapsedMs);

    // 记录帧率
    void recordFrameRate(double fps);

    // 记录内存使用
    void recordMemoryUsage(size_t bytes);

    // 获取统计信息
    struct Statistics {
        double avgStepTime;            // 平均步骤耗时
        double maxStepTime;            // 最大步骤耗时
        double minStepTime;            // 最小步骤耗时
        double avgFrameRate;           // 平均帧率
        double avgMemoryUsage;         // 平均内存使用（MB）
        size_t totalFrames;            // 总帧数

        QJsonObject toJson() const;
    };
    Statistics getStatistics(const QString& category = "") const;

    // 获取最近的N条记录
    QList<Metrics> getRecentMetrics(int count = 100) const;

    // 获取指定时间范围的记录
    QList<Metrics> getMetricsInRange(const QDateTime& start, const QDateTime& end) const;

    // 清除历史数据
    void clear();

    // 导出性能数据
    bool exportToCSV(const QString& filePath) const;
    bool exportToJSON(const QString& filePath) const;

    // 实时监控开关
    void setEnabled(bool enabled) { enabled_ = enabled; }
    bool isEnabled() const { return enabled_; }

    // 设置最大记录数
    void setMaxRecords(int maxRecords) { maxRecords_ = maxRecords; }
    int getMaxRecords() const { return maxRecords_; }

signals:
    void metricRecorded(const Metrics& metric);
    void statisticsUpdated();

private:
    PerformanceMonitor();
    ~PerformanceMonitor();

    void trimRecords();

private:
    mutable QMutex mutex_;
    QList<Metrics> metrics_;
    bool enabled_;
    int maxRecords_;

    // 分类统计缓存
    mutable QMap<QString, Statistics> cachedStats_;
    mutable bool statsDirty_;
};


// ============================================================
// 作用域性能计时器（RAII）
// ============================================================
class ScopedPerformanceTimer {
public:
    explicit ScopedPerformanceTimer(const QString& name, bool autoRecord = true)
        : name_(name), autoRecord_(autoRecord) {
        counter_.reset();
    }

    ~ScopedPerformanceTimer() {
        if (autoRecord_) {
            double elapsed = counter_.elapsedMs();
            PerformanceMonitor::instance().recordMetric(name_, elapsed, "ms");
        }
    }

    double elapsedMs() const {
        return counter_.elapsedMs();
    }

    void reset() {
        counter_.reset();
    }

private:
    QString name_;
    bool autoRecord_;
    PerformanceCounter counter_;
};

// 便捷宏
#define PERF_TIMER(name) ScopedPerformanceTimer __perf_timer__(name)
#define PERF_TIMER_MANUAL(name) ScopedPerformanceTimer __perf_timer__(name, false)
```

### 6.6 无锁数据结构

```cpp
// ============================================================
// 无锁队列（单生产者-单消费者）
// ============================================================
template<typename T>
class LockFreeQueue {
public:
    explicit LockFreeQueue(size_t capacity = 10000)
        : capacity_(capacity), buffer_(capacity) {
        writeIndex_.store(0, std::memory_order_relaxed);
        readIndex_.store(0, std::memory_order_relaxed);
    }

    // 生产者接口
    bool push(const T& item) {
        size_t currentWrite = writeIndex_.load(std::memory_order_relaxed);
        size_t nextWrite = (currentWrite + 1) % capacity_;

        // 检查队列是否已满
        if (nextWrite == readIndex_.load(std::memory_order_acquire)) {
            return false;  // 队列满
        }

        buffer_[currentWrite] = item;
        writeIndex_.store(nextWrite, std::memory_order_release);
        return true;
    }

    bool push(T&& item) {
        size_t currentWrite = writeIndex_.load(std::memory_order_relaxed);
        size_t nextWrite = (currentWrite + 1) % capacity_;

        if (nextWrite == readIndex_.load(std::memory_order_acquire)) {
            return false;
        }

        buffer_[currentWrite] = std::move(item);
        writeIndex_.store(nextWrite, std::memory_order_release);
        return true;
    }

    // 消费者接口
    bool pop(T& item) {
        size_t currentRead = readIndex_.load(std::memory_order_relaxed);

        // 检查队列是否为空
        if (currentRead == writeIndex_.load(std::memory_order_acquire)) {
            return false;  // 队列空
        }

        item = std::move(buffer_[currentRead]);
        readIndex_.store((currentRead + 1) % capacity_, std::memory_order_release);
        return true;
    }

    // 队列状态
    size_t size() const {
        size_t write = writeIndex_.load(std::memory_order_acquire);
        size_t read = readIndex_.load(std::memory_order_acquire);

        if (write >= read) {
            return write - read;
        } else {
            return capacity_ - read + write;
        }
    }

    bool isEmpty() const {
        return readIndex_.load(std::memory_order_acquire) ==
               writeIndex_.load(std::memory_order_acquire);
    }

    bool isFull() const {
        size_t nextWrite = (writeIndex_.load(std::memory_order_acquire) + 1) % capacity_;
        return nextWrite == readIndex_.load(std::memory_order_acquire);
    }

    size_t capacity() const {
        return capacity_ - 1;  // 实际可用容量
    }

    // 清空队列
    void clear() {
        readIndex_.store(writeIndex_.load(std::memory_order_acquire),
                        std::memory_order_release);
    }

private:
    size_t capacity_;
    std::vector<T> buffer_;
    std::atomic<size_t> writeIndex_;
    std::atomic<size_t> readIndex_;

    // 禁止拷贝
    LockFreeQueue(const LockFreeQueue&) = delete;
    LockFreeQueue& operator=(const LockFreeQueue&) = delete;
};


// ============================================================
// 无锁栈（单生产者-单消费者）
// ============================================================
template<typename T>
class LockFreeStack {
public:
    explicit LockFreeStack(size_t capacity = 1000)
        : capacity_(capacity), buffer_(capacity) {
        top_.store(0, std::memory_order_relaxed);
    }

    bool push(const T& item) {
        size_t currentTop = top_.load(std::memory_order_relaxed);

        if (currentTop >= capacity_) {
            return false;  // 栈满
        }

        buffer_[currentTop] = item;
        top_.store(currentTop + 1, std::memory_order_release);
        return true;
    }

    bool pop(T& item) {
        size_t currentTop = top_.load(std::memory_order_acquire);

        if (currentTop == 0) {
            return false;  // 栈空
        }

        item = std::move(buffer_[currentTop - 1]);
        top_.store(currentTop - 1, std::memory_order_release);
        return true;
    }

    size_t size() const {
        return top_.load(std::memory_order_acquire);
    }

    bool isEmpty() const {
        return top_.load(std::memory_order_acquire) == 0;
    }

    bool isFull() const {
        return top_.load(std::memory_order_acquire) >= capacity_;
    }

private:
    size_t capacity_;
    std::vector<T> buffer_;
    std::atomic<size_t> top_;
};
```

---

## 7. 架构增强模块类图

### 7.1 标定与坐标系管理

```cpp
// ============================================================
// 坐标系枚举
// ============================================================
enum CoordinateSystem {
    ImageCS,       // 图像坐标系 (pixel)
    CameraCS,      // 相机坐标系 (mm)
    WorldCS,       // 世界坐标系 (mm)
    RobotCS        // 机械臂坐标系 (mm)
};


// ============================================================
// 坐标变换结构
// ============================================================
struct CoordinateTransform {
    cv::Mat homography;        // 2D单应性矩阵 (3x3)
    cv::Mat rotationMatrix;    // 3D旋转矩阵 (3x3)
    cv::Mat translationVec;    // 3D平移向量 (3x1)
    double scaleX;             // X轴缩放比例 (mm/pixel)
    double scaleY;             // Y轴缩放比例 (mm/pixel)

    // 2D坐标转换
    cv::Point2d transform(const cv::Point2d& srcPoint) const;

    // 3D坐标转换
    cv::Point3d transform3D(const cv::Point3d& srcPoint) const;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 标定管理器（单例）
// ============================================================
class CalibrationManager : public QObject {
    Q_OBJECT

public:
    static CalibrationManager& instance();

    // ========== 标定方法 ==========
    // 9点标定
    bool calibrate9Point(const std::vector<cv::Point2d>& imagePoints,
                        const std::vector<cv::Point2d>& worldPoints);

    // N点标定
    bool calibrateNPoint(const std::vector<cv::Point2d>& imagePoints,
                        const std::vector<cv::Point2d>& worldPoints);

    // 棋盘格标定
    bool calibrateChessboard(const std::vector<cv::Mat>& images,
                            const cv::Size& patternSize,
                            double squareSize);

    // 圆点标定板
    bool calibrateCircleGrid(const std::vector<cv::Mat>& images,
                            const cv::Size& patternSize,
                            double circleSpacing);

    // ========== 坐标变换 ==========
    CoordinateTransform getTransform(CoordinateSystem from,
                                     CoordinateSystem to) const;

    cv::Point2d transformPoint(const cv::Point2d& pt,
                              CoordinateSystem from,
                              CoordinateSystem to) const;

    std::vector<cv::Point2d> transformPoints(
        const std::vector<cv::Point2d>& points,
        CoordinateSystem from,
        CoordinateSystem to) const;

    // ========== 标定精度 ==========
    double getReprojectionError() const;
    double getPixelToMM() const;  // 像素到毫米的转换比例

    // ========== 持久化 ==========
    bool saveCalibration(const QString& filePath);
    bool loadCalibration(const QString& filePath);

    // ========== 标定状态 ==========
    bool isCalibrated(CoordinateSystem from, CoordinateSystem to) const;
    void clearCalibration();

signals:
    void calibrationCompleted(bool success, double error);
    void calibrationDataChanged();

private:
    CalibrationManager();
    ~CalibrationManager();

    bool computeHomography(const std::vector<cv::Point2d>& srcPoints,
                          const std::vector<cv::Point2d>& dstPoints,
                          cv::Mat& homography);

private:
    // 存储各坐标系之间的变换矩阵
    QMap<QPair<CoordinateSystem, CoordinateSystem>, CoordinateTransform> transforms_;

    // 相机内参矩阵
    cv::Mat cameraMatrix_;
    cv::Mat distCoeffs_;

    // 标定精度
    double reprojectionError_;

    // 是否已标定
    bool isCalibrated_;
};


// ============================================================
// ImageData增强（添加坐标系支持）
// ============================================================
// 注意：此处仅展示新增成员，完整定义见第6章
class ImageDataEnhanced : public ImageData {
public:
    // 新增：坐标系信息
    CoordinateSystem coordinateSystem_ = ImageCS;
    CoordinateTransform transform_;

    // 带坐标系的点转换
    cv::Point2d toWorldCoordinate(const cv::Point2d& imagePoint) const {
        if (coordinateSystem_ == ImageCS) {
            return transform_.transform(imagePoint);
        }
        return imagePoint;
    }

    cv::Point2d toImageCoordinate(const cv::Point2d& worldPoint) const {
        // 需要逆变换
        cv::Mat invHomography = transform_.homography.inv();
        cv::Mat pt = (cv::Mat_<double>(3, 1) << worldPoint.x, worldPoint.y, 1.0);
        cv::Mat result = invHomography * pt;
        return cv::Point2d(result.at<double>(0) / result.at<double>(2),
                          result.at<double>(1) / result.at<double>(2));
    }
};
```

---

### 7.2 高频数据持久化

```cpp
// ============================================================
// 结果队列（无锁环形缓冲区）
// ============================================================
class ResultQueue {
public:
    static constexpr size_t QUEUE_SIZE = 10000;

    ResultQueue();
    ~ResultQueue();

    // 生产者接口
    bool push(const InspectionResult& result);

    // 消费者接口
    bool pop(InspectionResult& result);

    // 队列状态
    size_t size() const;
    bool isEmpty() const;
    bool isFull() const;

    // 清空队列
    void clear();

private:
    std::array<InspectionResult, QUEUE_SIZE> buffer_;
    std::atomic<size_t> writeIndex_{0};
    std::atomic<size_t> readIndex_{0};
};


// ============================================================
// 异步结果写入器（后台线程）
// ============================================================
class AsyncResultWriter : public QThread {
    Q_OBJECT

public:
    static AsyncResultWriter& instance();

    // 入队检测结果
    void enqueue(const InspectionResult& result);

    // 启动/停止写入线程
    void start();
    void stop();

    // 暂停/恢复（用于实时模式）
    void pause();
    void resume();

    // 立即刷新所有待写入数据
    void flush();

    // 统计信息
    size_t getPendingCount() const { return queue_.size(); }
    size_t getTotalWritten() const { return totalWritten_; }

signals:
    void batchWritten(int count, qint64 elapsedMs);
    void queueOverflow(int droppedCount);
    void errorOccurred(const QString& error);

protected:
    void run() override;

private:
    AsyncResultWriter();
    ~AsyncResultWriter();

    void writeBatch(const std::vector<InspectionResult>& batch);
    bool writeSingleResult(const InspectionResult& result);

private:
    ResultQueue queue_;
    std::atomic<bool> stopFlag_{false};
    std::atomic<bool> pauseFlag_{false};
    std::atomic<size_t> totalWritten_{0};

    // 批量写入配置
    static constexpr int BATCH_SIZE = 100;
    static constexpr int BATCH_TIMEOUT_MS = 500;

    QSqlDatabase db_;
};


// ============================================================
// 分层日志接口
// ============================================================
class IResultLogger {
public:
    virtual ~IResultLogger() = default;
    virtual void logResult(const InspectionResult& result) = 0;
};


// ============================================================
// 生产模式日志（精简）
// ============================================================
class ProductionLogger : public IResultLogger {
public:
    void logResult(const InspectionResult& result) override {
        // 仅记录：时间戳、OK/NG、总耗时
        QJsonObject log;
        log["timestamp"] = result.timestamp.toString(Qt::ISODate);
        log["ok"] = result.ok;
        log["totalTime"] = result.totalTime;

        // 写入轻量级日志文件
        writeToLog(log);
    }

private:
    void writeToLog(const QJsonObject& log);
};


// ============================================================
// 调试模式日志（完整）
// ============================================================
class DebugLogger : public IResultLogger {
public:
    void logResult(const InspectionResult& result) override {
        // 记录完整信息：所有步骤、中间结果、图像
        QJsonObject log = result.toJson();

        // 保存中间图像
        for (int i = 0; i < result.stepResults.size(); ++i) {
            if (result.stepResults[i].success) {
                QString imagePath = QString("debug/step%1_%2.png")
                    .arg(i)
                    .arg(result.timestamp.toMSecsSinceEpoch());
                // cv::imwrite(imagePath, ...);
            }
        }

        writeToLog(log);
    }

private:
    void writeToLog(const QJsonObject& log);
};
```

---

### 7.3 逻辑控制增强

```cpp
// ============================================================
// Lua脚本引擎
// ============================================================
class LuaScriptEngine : public QObject {
    Q_OBJECT

public:
    explicit LuaScriptEngine(QObject* parent = nullptr);
    ~LuaScriptEngine() override;

    // 执行脚本
    bool executeScript(const QString& script,
                      const InspectionResult& result,
                      bool& ok);

    // 注册自定义函数
    void registerFunction(const QString& name,
                         std::function<QVariant(const QVariantList&)> func);

    // 获取脚本变量
    QVariant getVariable(const QString& name) const;

    // 设置脚本变量
    void setVariable(const QString& name, const QVariant& value);

    // 获取错误信息
    QString lastError() const { return lastError_; }

signals:
    void scriptExecuted(bool success);
    void errorOccurred(const QString& error);

private:
    void injectResultData(const InspectionResult& result);
    void extractOutputData(bool& ok);

private:
    struct lua_State* L_;
    QString lastError_;
};


// ============================================================
// JavaScript脚本引擎（基于Qt QJSEngine）
// ============================================================
class JavaScriptEngine : public QObject {
    Q_OBJECT

public:
    explicit JavaScriptEngine(QObject* parent = nullptr);
    ~JavaScriptEngine() override;

    // 执行脚本
    bool executeScript(const QString& script,
                      const InspectionResult& result,
                      bool& ok);

    // 注册Qt对象到脚本环境
    void registerObject(const QString& name, QObject* object);

    // 注册全局函数
    Q_INVOKABLE void setStepParam(int stepIndex,
                                  const QString& paramName,
                                  const QVariant& value);

    // 获取错误信息
    QString lastError() const { return lastError_; }

signals:
    void scriptExecuted(bool success);
    void errorOccurred(const QString& error);

private:
    QJSValue convertResultToJS(const InspectionResult& result);
    void extractOutputData(bool& ok);

private:
    QJSEngine* engine_;
    QString lastError_;
};


// ============================================================
// 高级表达式解析器
// ============================================================
class AdvancedExpressionParser {
public:
    AdvancedExpressionParser();
    ~AdvancedExpressionParser();

    // 计算表达式
    bool evaluate(const QString& expression,
                 const QJsonObject& context,
                 QVariant& result);

    // 支持的运算符
    // 算术: +, -, *, /, %, ^
    // 比较: ==, !=, >, <, >=, <=
    // 逻辑: &&, ||, !
    // 函数: abs(), sqrt(), min(), max(), avg(), sum()

    // 注册自定义函数
    void registerFunction(const QString& name,
                         std::function<double(const std::vector<double>&)> func);

    // 获取错误信息
    QString lastError() const { return lastError_; }

private:
    enum TokenType {
        Number, Identifier, Operator, Function,
        LeftParen, RightParen, Comma, EndOfExpr
    };

    struct Token {
        TokenType type;
        QString value;
        double numValue;
    };

    struct ASTNode {
        enum Type { NumberNode, VariableNode, BinaryOpNode, UnaryOpNode, FunctionNode };

        Type type;
        QString name;           // 用于变量名、函数名
        double value;           // 用于数字常量
        QString op;             // 用于运算符
        std::vector<ASTNode*> children;

        ~ASTNode() {
            for (auto* child : children) {
                delete child;
            }
        }
    };

    // 词法分析
    std::vector<Token> tokenize(const QString& expr);

    // 语法分析（递归下降）
    ASTNode* parseExpression(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseLogicalOr(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseLogicalAnd(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseComparison(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseTerm(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseFactor(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parsePrimary(const std::vector<Token>& tokens, size_t& pos);

    // 求值
    QVariant evaluateNode(ASTNode* node, const QJsonObject& context);

private:
    QString lastError_;
    QMap<QString, std::function<double(const std::vector<double>&)>> customFunctions_;
};
```

---

### 7.4 HAL设备管理

```cpp
// ============================================================
// 重试策略
// ============================================================
struct RetryPolicy {
    int maxRetries = 3;           // 最大重试次数
    int retryInterval = 1000;     // 重试间隔(ms)
    bool exponentialBackoff = true; // 指数退避

    int getRetryDelay(int attemptCount) const {
        if (!exponentialBackoff) {
            return retryInterval;
        }
        return retryInterval * static_cast<int>(std::pow(2, attemptCount - 1));
    }

    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 设备管理器（单例）
// ============================================================
class DeviceManager : public QObject {
    Q_OBJECT

public:
    static DeviceManager& instance();

    // ========== 设备注册 ==========
    void registerDevice(const QString& deviceId, ICamera* camera);
    void registerDevice(const QString& deviceId, ILight* light);
    void registerDevice(const QString& deviceId, IPLC* plc);

    void unregisterDevice(const QString& deviceId);

    // ========== 健康检查 ==========
    void startMonitoring();
    void stopMonitoring();

    bool isDeviceOnline(const QString& deviceId) const;
    QDateTime getLastHeartbeat(const QString& deviceId) const;

    // ========== 重连策略 ==========
    void setRetryPolicy(const QString& deviceId, const RetryPolicy& policy);
    RetryPolicy getRetryPolicy(const QString& deviceId) const;

    // ========== 设备信息 ==========
    QStringList getAllDevices() const;
    QObject* getDevice(const QString& deviceId) const;

signals:
    void deviceStatusChanged(const QString& deviceId, bool online);
    void deviceReconnecting(const QString& deviceId, int attemptCount);
    void deviceReconnected(const QString& deviceId);
    void deviceReconnectFailed(const QString& deviceId);

private slots:
    void onHeartbeatCheck();
    void onDeviceLost(const QString& deviceId);

private:
    DeviceManager();
    ~DeviceManager();

    void attemptReconnect(const QString& deviceId);
    void updateHeartbeat(const QString& deviceId);

private:
    struct DeviceInfo {
        QObject* device;           // ICamera*, ILight*, 或 IPLC*
        QString deviceType;        // "Camera", "Light", "PLC"
        RetryPolicy retryPolicy;
        int failedAttempts;
        QDateTime lastHeartbeat;
        bool isOnline;
    };

    QMap<QString, DeviceInfo> devices_;
    QTimer* heartbeatTimer_;
    QMutex devicesMutex_;
};


// ============================================================
// ICamera接口增强（添加健康检查）
// ============================================================
// 注意：此处仅展示新增接口，完整定义见第5章
class ICameraEnhanced : public ICamera {
    Q_OBJECT

public:
    // 新增：健康检查
    virtual bool isHealthy() const = 0;
    virtual int getHeartbeatInterval() const { return 1000; }  // ms

signals:
    void deviceLost();         // 设备丢失
    void deviceRecovered();    // 设备恢复
    void heartbeatTimeout();   // 心跳超时
};


// ============================================================
// 设备枚举器（热插拔支持）
// ============================================================
class DeviceEnumerator : public QObject {
    Q_OBJECT

public:
    explicit DeviceEnumerator(QObject* parent = nullptr);
    ~DeviceEnumerator() override;

    // 启动/停止监听
    void startMonitoring();
    void stopMonitoring();

    // 枚举当前设备
    QStringList enumerateCameras() const;
    QStringList enumeratePLCs() const;

signals:
    void deviceArrived(const QString& deviceId, const QString& deviceType);
    void deviceRemoved(const QString& deviceId);

protected:
#ifdef _WIN32
    bool nativeEvent(const QByteArray& eventType,
                    void* message,
                    long* result) override;
#endif

private:
    void setupPlatformMonitoring();
    void handleDeviceChange();

private:
    struct Impl;  // PIMPL模式隐藏平台相关实现
    std::unique_ptr<Impl> impl_;
};
```

---

### 7.5 多线程基础设施

```cpp
// ============================================================
// 线程亲和性辅助类
// ============================================================
class ThreadAffinityHelper {
public:
    // 绑定线程到指定CPU核心
    static bool setAffinity(std::thread& thread, int coreId);
    static bool setAffinity(QThread& thread, int coreId);

    // 设置线程优先级
    enum Priority {
        Idle,
        Lowest,
        Low,
        Normal,
        High,
        Highest,
        TimeCritical
    };

    static bool setPriority(std::thread& thread, Priority priority);
    static bool setPriority(QThread& thread, Priority priority);

    // 获取CPU核心数
    static int getCoreCount();
    static int getPhysicalCoreCount();  // 排除超线程

    // 检查当前线程的亲和性
    static int getCurrentAffinity();

private:
    static int mapPriorityToNative(Priority priority);
};


// ============================================================
// 处理线程池
// ============================================================
class ProcessingThreadPool {
public:
    static ProcessingThreadPool& instance();

    // 初始化线程池
    void initialize(int threadCount = -1);
    void shutdown();

    // 提交任务
    std::future<InspectionResult> submit(
        std::function<InspectionResult()> task);

    // 提交带优先级的任务
    enum TaskPriority { Low, Normal, High };
    std::future<InspectionResult> submit(
        std::function<InspectionResult()> task,
        TaskPriority priority);

    // 线程池状态
    int getThreadCount() const { return static_cast<int>(workers_.size()); }
    int getQueueSize() const;
    bool isBusy() const;

    // 性能设置
    void setHighPriority();
    void setNormalPriority();

signals:
    void taskCompleted();
    void queueSizeChanged(int size);

private:
    ProcessingThreadPool();
    ~ProcessingThreadPool();

    void workerThread(int workerId);

private:
    struct Task {
        std::function<void()> func;
        TaskPriority priority;
        int id;

        bool operator<(const Task& other) const {
            return priority < other.priority;  // 高优先级在前
        }
    };

    std::vector<std::thread> workers_;
    std::priority_queue<Task> taskQueue_;
    std::mutex queueMutex_;
    std::condition_variable condition_;
    std::atomic<bool> stopFlag_{false};
    std::atomic<int> nextTaskId_{0};
};


// ============================================================
// 采集线程（专用线程）
// ============================================================
class GrabThread : public QThread {
    Q_OBJECT

public:
    explicit GrabThread(ICamera* camera, QObject* parent = nullptr);
    ~GrabThread() override;

    void start();
    void stop();

    // 获取采集的图像
    ImageData::Ptr getNextImage(int timeoutMs = 1000);

    // 统计信息
    int getFrameRate() const { return frameRate_; }
    int getDroppedFrameCount() const { return droppedFrames_; }

signals:
    void imageGrabbed(ImageData::Ptr image);
    void grabError(const QString& error);
    void frameRateChanged(int fps);

protected:
    void run() override;

private:
    void setupThreadAffinity();
    void updateFrameRate();

private:
    ICamera* camera_;
    std::atomic<bool> stopFlag_{false};

    // 无锁队列
    static constexpr size_t QUEUE_SIZE = 100;
    std::array<ImageData::Ptr, QUEUE_SIZE> imageQueue_;
    std::atomic<size_t> writeIndex_{0};
    std::atomic<size_t> readIndex_{0};

    // 统计
    std::atomic<int> frameRate_{0};
    std::atomic<int> droppedFrames_{0};
    std::chrono::steady_clock::time_point lastFrameTime_;
};


// ============================================================
// 实时性保证辅助类
// ============================================================
class RealTimeHelper {
public:
    // 锁定进程工作集（避免swap）
    static bool lockMemory();
    static bool unlockMemory();

    // 预分配内存（避免运行时分配）
    static void preallocateImageMemory(int count, int width, int height, int type);

    // 禁用后台任务
    static void disableBackgroundTasks();
    static void enableBackgroundTasks();

    // 设置进程优先级
    static bool setProcessPriority(ThreadAffinityHelper::Priority priority);
};
```

---

### 7.6 图像加速基础设施

```cpp
// ============================================================
// SIMD加速工具类
// ============================================================
class SIMDHelper {
public:
    // 检测CPU支持的SIMD指令集
    static bool supportsSSE2();
    static bool supportsAVX();
    static bool supportsAVX2();
    static bool supportsAVX512();

    // 获取最佳对齐字节数
    static size_t getOptimalAlignment();

    // SIMD加速的图像处理函数
    static void threshold_AVX2(const uint8_t* src, uint8_t* dst,
                              int width, int height,
                              uint8_t threshold);

    static void add_AVX2(const uint8_t* src1, const uint8_t* src2,
                        uint8_t* dst, int width, int height);

    static void multiply_AVX2(const uint8_t* src, uint8_t* dst,
                             int width, int height, float factor);

    static void convertGray_AVX2(const uint8_t* srcRGB, uint8_t* dstGray,
                                int width, int height);

    // 性能对比（用于自动选择最优实现）
    static bool shouldUseSIMD(int width, int height);
};


// ============================================================
// GPU加速引擎
// ============================================================
class GPUAccelerator {
public:
    static GPUAccelerator& instance();

    // 初始化GPU
    bool initialize();
    void shutdown();
    bool isInitialized() const { return initialized_; }

    // GPU设备信息
    struct DeviceInfo {
        QString name;
        size_t totalMemory;
        size_t freeMemory;
        int computeCapability;
        bool supportsCUDA;
        bool supportsTensorRT;
    };
    DeviceInfo getDeviceInfo() const;

    // CUDA加速的图像处理
    bool gaussianBlur_CUDA(ImageData::Ptr input, ImageData::Ptr output,
                          int kernelSize, double sigma);

    bool threshold_CUDA(ImageData::Ptr input, ImageData::Ptr output,
                       uint8_t threshold);

    bool resize_CUDA(ImageData::Ptr input, ImageData::Ptr output,
                    int newWidth, int newHeight);

    // TensorRT推理加速
    bool inferTensorRT(ImageData::Ptr input,
                      const QString& modelPath,
                      std::vector<float>& output);

    // 性能统计
    double getLastKernelTime() const { return lastKernelTimeMs_; }

signals:
    void initialized();
    void errorOccurred(const QString& error);

private:
    GPUAccelerator();
    ~GPUAccelerator();

    void* cudaContext_;
    void* tensorRTEngine_;
    bool initialized_;
    double lastKernelTimeMs_;
};


// ============================================================
// TensorRT推理引擎
// ============================================================
class TensorRTEngine {
public:
    TensorRTEngine();
    ~TensorRTEngine();

    // 加载模型
    bool loadModel(const QString& onnxPath);
    bool loadSerializedEngine(const QString& enginePath);

    // 保存序列化引擎（加速下次加载）
    bool saveSerializedEngine(const QString& enginePath);

    // 推理
    bool infer(const std::vector<float>& input,
              std::vector<float>& output);

    bool inferImage(ImageData::Ptr image,
                   std::vector<float>& output);

    // 批量推理（提高吞吐量）
    bool inferBatch(const std::vector<ImageData::Ptr>& images,
                   std::vector<std::vector<float>>& outputs);

    // 模型信息
    struct ModelInfo {
        QString inputName;
        QString outputName;
        std::vector<int> inputShape;   // [batch, channels, height, width]
        std::vector<int> outputShape;
        size_t maxBatchSize;
    };
    ModelInfo getModelInfo() const;

    // 性能配置
    void setMaxBatchSize(int batchSize);
    void setWorkspaceSize(size_t sizeInMB);
    void setPrecisionMode(const QString& mode);  // "fp32", "fp16", "int8"

private:
    void* engine_;
    void* context_;
    void* cudaStream_;

    ModelInfo modelInfo_;
    bool isLoaded_;
};


// ============================================================
// OpenCL加速引擎（跨平台GPU加速）
// ============================================================
class OpenCLAccelerator {
public:
    static OpenCLAccelerator& instance();

    bool initialize();
    void shutdown();
    bool isInitialized() const { return initialized_; }

    // 设备信息
    struct DeviceInfo {
        QString platform;
        QString deviceName;
        QString version;
        size_t maxWorkGroupSize;
        size_t globalMemSize;
        size_t localMemSize;
    };
    QList<DeviceInfo> getAvailableDevices() const;
    void selectDevice(int deviceIndex);

    // OpenCL加速的图像处理
    bool convolve_OpenCL(ImageData::Ptr input, ImageData::Ptr output,
                        const cv::Mat& kernel);

    bool morphology_OpenCL(ImageData::Ptr input, ImageData::Ptr output,
                          int operation, const cv::Mat& kernel);

    bool remap_OpenCL(ImageData::Ptr input, ImageData::Ptr output,
                     const cv::Mat& mapX, const cv::Mat& mapY);

private:
    OpenCLAccelerator();
    ~OpenCLAccelerator();

    void* context_;
    void* commandQueue_;
    void* program_;
    bool initialized_;
};


// ============================================================
// 加速策略选择器（自动选择最优加速方案）
// ============================================================
class AccelerationStrategySelector {
public:
    enum Strategy {
        CPU_Serial,        // CPU串行
        CPU_SIMD,          // CPU SIMD（AVX2）
        GPU_CUDA,          // GPU CUDA加速
        GPU_OpenCL,        // GPU OpenCL加速
        GPU_TensorRT       // TensorRT推理加速
    };

    static Strategy selectBestStrategy(const QString& operationType,
                                       int imageWidth, int imageHeight);

    // 基于性能测试自动选择
    static Strategy benchmarkAndSelect(const QString& operationType,
                                      ImageData::Ptr testImage);

    // 获取策略名称
    static QString getStrategyName(Strategy strategy);

private:
    struct BenchmarkResult {
        Strategy strategy;
        double avgTimeMs;
        bool successful;
    };

    static BenchmarkResult benchmark(Strategy strategy,
                                    const QString& operationType,
                                    ImageData::Ptr testImage);
};
```

---

## 8. 加速技术应用示例

### 8.1 零拷贝图像传输

```cpp
// 示例：从相机采集到UI显示的零拷贝流程
void MainWindow::onImageGrabbed(ImageData::Ptr image) {
    // 1. 相机采集的图像已经是对齐内存
    // 2. 处理流程使用零拷贝传递
    ToolResult result;
    visionTool->process(image, result);  // 内部使用 image->mat() 零拷贝访问

    // 3. 显示到UI（零拷贝转换为QImage）
    imageDisplayWidget->setImage(image);  // 内部调用 image->toQImage()，零拷贝
}
```

### 8.2 SIMD加速应用

```cpp
// 示例：灰度转换工具使用AVX2加速
bool GrayTool::process(const ImageData::Ptr& input, ToolResult& output) {
    if (!input || input->mat().empty()) {
        return false;
    }

    // 确保内存对齐
    if (!input->isMemoryAligned()) {
        LOG_WARNING("输入图像内存未对齐，性能可能下降");
    }

    // 从内存池分配输出图像
    output.outputImage = ImageMemoryPool::instance().allocate(
        input->width(), input->height(), CV_8UC1);

    // 使用SIMD加速转换
    if (SIMDHelper::supportsAVX2() && input->isMemoryAligned()) {
        SIMDHelper::convertGray_AVX2(
            input->mat().data,
            output.outputImage->mat().data,
            input->width(),
            input->height()
        );
    } else {
        // 降级到OpenCV实现
        cv::cvtColor(input->mat(), output.outputImage->mat(), cv::COLOR_BGR2GRAY);
    }

    return true;
}
```

### 8.3 GPU加速应用

```cpp
// 示例：AI检测工具使用TensorRT加速
bool AIDetectionTool::process(const ImageData::Ptr& input, ToolResult& output) {
    PERF_TIMER("AIDetectionTool::process");

    if (!tensorRTEngine_->isLoaded()) {
        return false;
    }

    // 推理
    std::vector<float> inferenceOutput;
    if (!tensorRTEngine_->inferImage(input, inferenceOutput)) {
        return false;
    }

    // 解析结果
    parseDetectionResults(inferenceOutput, output);
    return true;
}
```

### 8.4 并行流水线应用

```cpp
// 示例：高频检测的并行流水线
class DetectionPipeline {
public:
    void start() {
        // 采集线程
        grabThread_ = new GrabThread(camera_);
        grabThread_->start();

        // 处理线程池
        for (int i = 0; i < 4; ++i) {
            processingThreads_.push_back(std::thread([this]() {
                while (!stopFlag_) {
                    ImageData::Ptr image;
                    if (imageQueue_.pop(image)) {
                        processImage(image);
                    }
                }
            }));

            // 绑定CPU核心
            ThreadAffinityHelper::setAffinity(processingThreads_.back(), i + 1);
        }

        // 结果写入线程
        AsyncResultWriter::instance().start();
    }

private:
    void processImage(ImageData::Ptr image) {
        PERF_TIMER("ProcessImage");

        InspectionResult result;
        result.timestamp = QDateTime::currentDateTime();

        // 执行检测流程
        for (auto* tool : recipe_->steps()) {
            ToolResult toolResult;
            if (!tool->process(image, toolResult)) {
                result.ok = false;
                break;
            }
            result.stepResults.append(toolResult);
        }

        // 异步写入结果
        AsyncResultWriter::instance().enqueue(result);
    }

    GrabThread* grabThread_;
    LockFreeQueue<ImageData::Ptr> imageQueue_;
    std::vector<std::thread> processingThreads_;
    std::atomic<bool> stopFlag_{false};
};
```

---

## 9. 类关系总结

### 8.1 依赖关系

```
MainWindow
    ├─> RecipeManager
    ├─> TaskScheduler
    │       └─> PipelineExecutor
    │               └─> VisionTool (多个)
    ├─> SimpleModeWidget
    │       ├─> StepListWidget
    │       ├─> ImageDisplayWidget
    │       └─> SimpleParamPanel
    └─> ProfessionalModeWidget
            ├─> ProjectTreeWidget
            ├─> ToolboxWidget
            ├─> PropertyPanel
            └─> StepNavigator

Recipe
    ├─> VisionTool[] (步骤列表)
    ├─> CameraConfig
    └─> JudgmentRules

VisionTool (抽象)
    ├─> GrayTool
    ├─> FindCircleTool
    ├─> AIDetectionTool
    └─> ... (其他工具)

ICamera (抽象)
    ├─> GenICamCamera
    └─> SimulatedCamera

IPLC (抽象)
    ├─> ModbusPLC
    └─> EthernetIPPLC
```

### 8.2 继承关系

```
QObject
    ├─> VisionTool
    │       ├─> GrayTool
    │       ├─> FindCircleTool
    │       └─> ...
    │
    ├─> ICamera
    │       ├─> GenICamCamera
    │       └─> SimulatedCamera
    │
    ├─> IPLC
    │       ├─> ModbusPLC
    │       └─> ...
    │
    ├─> RecipeManager
    ├─> TaskScheduler
    └─> ...

QWidget
    ├─> MainWindow (继承QMainWindow)
    ├─> SimpleModeWidget
    ├─> ProfessionalModeWidget
    ├─> StepListWidget (继承QListWidget)
    ├─> PropertyPanel (继承QScrollArea)
    └─> ...
```

---

## 10. 设计模式应用

| 模式 | 应用场景 | 类 |
|------|---------|-----|
| **单例模式** | 全局唯一实例 | RecipeManager, ToolFactory, Logger, CalibrationManager, DeviceManager, ProcessingThreadPool, ImageMemoryPool, PerformanceMonitor, GPUAccelerator, OpenCLAccelerator |
| **工厂模式** | 创建工具对象 | ToolFactory |
| **策略模式** | 不同算法实现 | VisionTool子类, IResultLogger子类 (ProductionLogger, DebugLogger), AccelerationStrategySelector |
| **观察者模式** | UI更新通知 | Qt信号槽机制 |
| **命令模式** | 撤销/重做 | RecipeVersionControl |
| **适配器模式** | 硬件接口适配 | ICamera子类 |
| **外观模式** | 简化复杂接口 | RecipeManager, CalibrationManager, GPUAccelerator, OpenCLAccelerator |
| **PIMPL** | 隐藏实现细节 | GenICamCamera::Impl, DeviceEnumerator::Impl |
| **对象池模式** | 重用对象避免分配 | ImageMemoryPool |
| **RAII模式** | 资源自动管理 | ScopedPerformanceTimer, ImageData::Ptr (shared_ptr) |
| **线程池模式** | 任务并发执行 | ProcessingThreadPool |
| **生产者-消费者模式** | 异步数据处理 | ResultQueue + AsyncResultWriter, GrabThread + 处理线程池, LockFreeQueue |
| **重试模式** | 失败自动重试 | DeviceManager + RetryPolicy |
| **解释器模式** | 脚本/表达式执行 | LuaScriptEngine, JavaScriptEngine, AdvancedExpressionParser |
| **模板方法模式** | 算法框架 | AlignedAllocator (STL分配器接口) |
| **零拷贝模式** | 避免数据复制 | ImageData::toQImage(), ImageData::fromAlignedMemory() |
| **缓存模式** | 提升渲染性能 | FlowNodeItem::cachedPixmap_ |

---

**文档状态**: ✅ 已完成
**下一步**: 编写交互流程图设计
