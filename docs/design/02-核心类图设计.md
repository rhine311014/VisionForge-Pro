# VisionForge Pro - 核心类图设计

## 文档信息

- **文档版本**: v1.1
- **创建日期**: 2025-12-14
- **最后更新**: 2025-12-14 (v1.1 - 新增架构增强模块类图)
- **设计者**: VisionForge Team

---

## 1. 整体类图概览

```
┌─────────────────────────────────────────────────────────────┐
│                       类图层次结构                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  UI层                    业务层                算法层        │
│  ┌──────────┐         ┌──────────┐         ┌──────────┐    │
│  │MainWindow│────────>│ Recipe   │────────>│VisionTool│    │
│  │          │         │ Manager  │         │          │    │
│  └──────────┘         └──────────┘         └──────────┘    │
│       │                    │                     │         │
│       ├─SimpleMode         ├─TaskScheduler       ├─GrayTool│
│       └─ProMode            └─ResultJudge         └─BlurTool│
│                                                             │
│  HAL层                   基础设施层                          │
│  ┌──────────┐         ┌──────────┐                         │
│  │ICamera   │         │MemPool   │                         │
│  │ILight    │         │Logger    │                         │
│  │IPLC      │         │Config    │                         │
│  └──────────┘         └──────────┘                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. UI层类图

### 2.1 主窗口及模式管理

```cpp
// ============================================================
// 主窗口类 - 应用程序入口
// ============================================================
class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    explicit MainWindow(QWidget* parent = nullptr);
    ~MainWindow() override;

    void loadRecipe(const QString& filePath);
    void saveRecipe(const QString& filePath);

public slots:
    void onSwitchMode(UIMode mode);
    void onRunClicked();
    void onStopClicked();

private:
    void setupUI();
    void createMenuBar();
    void createToolBar();
    void createStatusBar();

private:
    // 模式管理
    UIModeManager* modeManager_;

    // UI模式
    SimpleModeWidget* simpleMode_;
    ProfessionalModeWidget* proMode_;
    QStackedWidget* modeStack_;

    // 核心组件
    RecipeManager* recipeManager_;
    TaskScheduler* taskScheduler_;
    ImageDisplayWidget* imageDisplay_;

    // 状态
    QLabel* statusLabel_;
    QProgressBar* progressBar_;
};


// ============================================================
// UI模式管理器
// ============================================================
class UIModeManager : public QObject {
    Q_OBJECT

public:
    enum UIMode { Simple, Professional };

    explicit UIModeManager(QObject* parent = nullptr);

    UIMode currentMode() const { return currentMode_; }
    void switchMode(UIMode mode);

signals:
    void modeChanged(UIMode newMode);
    void modeWillChange(UIMode oldMode, UIMode newMode);

private:
    void saveState();
    void restoreState();

private:
    UIMode currentMode_;
    QSettings* settings_;
};
```

### 2.2 简单模式UI

```cpp
// ============================================================
// 简单模式主界面
// ============================================================
class SimpleModeWidget : public QWidget {
    Q_OBJECT

public:
    explicit SimpleModeWidget(QWidget* parent = nullptr);

    void setRecipe(Recipe* recipe);
    void updateCurrentStep(int stepIndex);

signals:
    void stepSelected(int stepIndex);
    void toolAdded(const QString& toolType);
    void paramChanged(int stepIndex, const QJsonObject& params);

private slots:
    void onAddStepClicked();
    void onStepItemClicked(int index);

private:
    void setupLayout();

private:
    // 核心组件
    StepListWidget* stepList_;          // 左侧步骤列表
    ImageDisplayWidget* imageDisplay_;  // 中间图像显示
    SimpleParamPanel* paramPanel_;      // 右侧参数面板

    // 工具选择器
    QuickToolSelector* toolSelector_;

    // 数据
    Recipe* currentRecipe_;
};


// ============================================================
// 步骤列表组件
// ============================================================
class StepListWidget : public QListWidget {
    Q_OBJECT

public:
    explicit StepListWidget(QWidget* parent = nullptr);

    void addStep(VisionTool* tool);
    void removeStep(int index);
    void setStepEnabled(int index, bool enabled);
    void setCurrentStep(int index);

signals:
    void stepClicked(int index);
    void stepMoved(int fromIndex, int toIndex);
    void stepEnabledChanged(int index, bool enabled);

protected:
    void dropEvent(QDropEvent* event) override;
    void dragEnterEvent(QDragEnterEvent* event) override;

private:
    // 自定义Item委托（绘制步骤项）
    StepItemDelegate* delegate_;
};


// ============================================================
// 步骤项委托 - 自定义绘制
// ============================================================
class StepItemDelegate : public QStyledItemDelegate {
    Q_OBJECT

public:
    explicit StepItemDelegate(QObject* parent = nullptr);

    void paint(QPainter* painter,
               const QStyleOptionViewItem& option,
               const QModelIndex& index) const override;

    QSize sizeHint(const QStyleOptionViewItem& option,
                   const QModelIndex& index) const override;

private:
    void drawStepIcon(QPainter* painter, const QRect& rect,
                      const QString& toolType) const;
    void drawStepStatus(QPainter* painter, const QRect& rect,
                        bool enabled, bool hasError) const;
};


// ============================================================
// 简化参数面板
// ============================================================
class SimpleParamPanel : public QScrollArea {
    Q_OBJECT

public:
    explicit SimpleParamPanel(QWidget* parent = nullptr);

    void setTool(VisionTool* tool);
    void clear();

signals:
    void paramChanged(const QJsonObject& params);

private:
    void createParamWidgets(VisionTool* tool);
    void createSliderParam(const QString& name,
                          double min, double max, double value);
    void createComboParam(const QString& name,
                         const QStringList& options, int current);

private:
    QWidget* contentWidget_;
    QFormLayout* layout_;
    VisionTool* currentTool_;

    // 参数控件映射
    QMap<QString, QWidget*> paramWidgets_;
};


// ============================================================
// 快速工具选择器对话框
// ============================================================
class QuickToolSelector : public QDialog {
    Q_OBJECT

public:
    explicit QuickToolSelector(QWidget* parent = nullptr);

    QString selectedToolType() const;

signals:
    void toolSelected(const QString& toolType);

private:
    void createToolButtons();
    void onToolButtonClicked(const QString& toolType);

private:
    QGridLayout* buttonLayout_;
    QMap<QString, QPushButton*> toolButtons_;
    QString selectedType_;
};
```

### 2.3 专业模式UI

```cpp
// ============================================================
// 专业模式主界面
// ============================================================
class ProfessionalModeWidget : public QWidget {
    Q_OBJECT

public:
    explicit ProfessionalModeWidget(QWidget* parent = nullptr);

    void setProject(Project* project);

signals:
    void recipeSelected(Recipe* recipe);
    void stepSelected(int stepIndex);

private:
    void setupLayout();

private:
    // 左侧
    ProjectTreeWidget* projectTree_;   // 项目树
    ToolboxWidget* toolbox_;           // 工具箱

    // 中间
    QTabWidget* workspaceTab_;         // 多Tab工作区
    ImageDisplayWidget* imageView_;    // 图像Tab
    FlowChartWidget* flowChart_;       // 流程Tab
    DataGridWidget* dataGrid_;         // 数据Tab
    LogViewerWidget* logViewer_;       // 日志Tab

    // 右侧
    PropertyPanel* propertyPanel_;     // 属性面板

    // 底部
    StepNavigator* stepNavigator_;     // 步骤导航条
};


// ============================================================
// 项目树组件
// ============================================================
class ProjectTreeWidget : public QTreeWidget {
    Q_OBJECT

public:
    explicit ProjectTreeWidget(QWidget* parent = nullptr);

    void setProject(Project* project);
    void addRecipe(Recipe* recipe);
    void removeRecipe(const QString& recipeId);

signals:
    void recipeSelected(Recipe* recipe);
    void taskSelected(Task* task);

private:
    void createContextMenu();

private:
    Project* currentProject_;
    QMenu* contextMenu_;
};


// ============================================================
// 工具箱组件（可拖拽）
// ============================================================
class ToolboxWidget : public QWidget {
    Q_OBJECT

public:
    explicit ToolboxWidget(QWidget* parent = nullptr);

    void addToolCategory(const QString& category,
                        const QStringList& tools);

signals:
    void toolDragged(const QString& toolType);

private:
    void createToolItems();

private:
    QVBoxLayout* layout_;
    QMap<QString, QListWidget*> categoryLists_;
};


// ============================================================
// 完整属性面板（分组、可折叠）
// ============================================================
class PropertyPanel : public QScrollArea {
    Q_OBJECT

public:
    explicit PropertyPanel(QWidget* parent = nullptr);

    void setTool(VisionTool* tool);
    void clear();

signals:
    void paramChanged(const QJsonObject& params);

private:
    void createBasicGroup(VisionTool* tool);
    void createAdvancedGroup(VisionTool* tool);
    void createDebugGroup(VisionTool* tool);

private:
    QWidget* contentWidget_;
    QVBoxLayout* layout_;

    // 分组面板
    QGroupBox* basicGroup_;
    QGroupBox* advancedGroup_;
    QGroupBox* debugGroup_;

    VisionTool* currentTool_;
};


// ============================================================
// 步骤导航条（快速跳转）
// ============================================================
class StepNavigator : public QWidget {
    Q_OBJECT

public:
    explicit StepNavigator(QWidget* parent = nullptr);

    void setSteps(const QList<VisionTool*>& steps);
    void setCurrentStep(int index);

signals:
    void stepClicked(int index);

private:
    void createStepButtons();

private:
    QHBoxLayout* layout_;
    QList<QPushButton*> stepButtons_;
    int currentStep_;
};
```

---

## 3. 业务逻辑层类图

### 3.1 配方管理

```cpp
// ============================================================
// 配方类 - 核心数据模型
// ============================================================
class Recipe : public QObject {
    Q_OBJECT

public:
    struct Metadata {
        QString name;
        int version;
        QDateTime createdTime;
        QDateTime modifiedTime;
        QString author;
    };

    explicit Recipe(QObject* parent = nullptr);
    ~Recipe() override;

    // 元数据
    const Metadata& metadata() const { return metadata_; }
    void setMetadata(const Metadata& meta) { metadata_ = meta; }

    // 步骤管理
    void addStep(VisionTool* tool);
    void insertStep(int index, VisionTool* tool);
    void removeStep(int index);
    void moveStep(int fromIndex, int toIndex);
    int stepCount() const { return steps_.size(); }
    VisionTool* step(int index) const;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);

    // 保存/加载
    bool save(const QString& filePath);
    bool load(const QString& filePath);

signals:
    void stepAdded(int index);
    void stepRemoved(int index);
    void stepMoved(int fromIndex, int toIndex);
    void metadataChanged();

private:
    Metadata metadata_;
    QList<VisionTool*> steps_;
    CameraConfig* cameraConfig_;
    JudgmentRules* judgmentRules_;
};


// ============================================================
// 配方管理器
// ============================================================
class RecipeManager : public QObject {
    Q_OBJECT

public:
    static RecipeManager& instance();

    Recipe* createRecipe(const QString& name);
    Recipe* openRecipe(const QString& filePath);
    bool saveRecipe(Recipe* recipe, const QString& filePath);
    void closeRecipe(Recipe* recipe);

    Recipe* currentRecipe() const { return currentRecipe_; }
    void setCurrentRecipe(Recipe* recipe);

    // 版本控制
    RecipeVersion* getVersion(Recipe* recipe, int version);
    void createSnapshot(Recipe* recipe, const QString& changeLog);
    bool rollback(Recipe* recipe, int targetVersion);

signals:
    void recipeOpened(Recipe* recipe);
    void recipeClosed(Recipe* recipe);
    void currentRecipeChanged(Recipe* recipe);

private:
    RecipeManager();
    ~RecipeManager();

private:
    Recipe* currentRecipe_;
    QMap<QString, Recipe*> loadedRecipes_;
    RecipeVersionControl* versionControl_;
};


// ============================================================
// 配方版本控制
// ============================================================
class RecipeVersionControl : public QObject {
    Q_OBJECT

public:
    struct Version {
        int versionNumber;
        QDateTime timestamp;
        QString author;
        QString changeLog;
        QJsonObject recipeSnapshot;
    };

    explicit RecipeVersionControl(QObject* parent = nullptr);

    void addVersion(const QString& recipeId, const Version& version);
    QList<Version> getVersionHistory(const QString& recipeId) const;
    Version getVersion(const QString& recipeId, int version) const;

    // 对比两个版本
    QJsonObject diff(const QString& recipeId, int v1, int v2) const;

private:
    // recipeId -> version list
    QMap<QString, QList<Version>> versionHistory_;
};
```

### 3.2 任务调度

```cpp
// ============================================================
// 任务调度器
// ============================================================
class TaskScheduler : public QObject {
    Q_OBJECT

public:
    enum RunMode {
        SingleRun,      // 单次运行
        Continuous,     // 连续运行
        Triggered       // 外部触发
    };

    explicit TaskScheduler(QObject* parent = nullptr);
    ~TaskScheduler() override;

    void setRecipe(Recipe* recipe);
    void setRunMode(RunMode mode);

    void start();
    void stop();
    void pause();
    void resume();

    bool isRunning() const { return isRunning_; }

signals:
    void started();
    void stopped();
    void stepStarted(int stepIndex);
    void stepFinished(int stepIndex, bool success);
    void resultReady(const InspectionResult& result);
    void errorOccurred(const QString& error);

private slots:
    void runPipeline();
    void onStepFinished(bool success);

private:
    Recipe* recipe_;
    RunMode runMode_;
    bool isRunning_;
    bool isPaused_;

    // 执行引擎
    PipelineExecutor* executor_;

    // 统计
    int runCount_;
    int okCount_;
    int ngCount_;
};


// ============================================================
// 流程执行引擎
// ============================================================
class PipelineExecutor : public QObject {
    Q_OBJECT

public:
    explicit PipelineExecutor(QObject* parent = nullptr);

    void setSteps(const QList<VisionTool*>& steps);
    bool execute(ImageData::Ptr input, InspectionResult& output);

    // 调试模式（单步执行）
    void setDebugMode(bool enabled);
    bool stepInto();  // 执行下一步
    ImageData::Ptr getCurrentStepResult() const;

signals:
    void stepExecuted(int stepIndex, qint64 elapsedMs);
    void pipelineFinished(bool success);

private:
    void executeStep(int index);

private:
    QList<VisionTool*> steps_;
    int currentStep_;
    bool debugMode_;

    // 中间结果缓存
    QVector<ImageData::Ptr> intermediateResults_;

    // 性能监控
    PerformanceMonitor* perfMonitor_;
};


// ============================================================
// 检测结果
// ============================================================
struct InspectionResult {
    bool ok;                       // OK/NG判定
    QDateTime timestamp;           // 时间戳
    qint64 totalTime;              // 总耗时(ms)

    // 步骤结果
    struct StepResult {
        QString toolType;
        bool success;
        qint64 elapsedTime;
        QJsonObject data;          // 结果数据
    };
    QList<StepResult> stepResults;

    // 图像
    ImageData::Ptr inputImage;     // 输入图像
    ImageData::Ptr resultImage;    // 结果图像（带标注）

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};
```

### 3.3 结果判定

```cpp
// ============================================================
// 判定规则引擎
// ============================================================
class JudgmentEngine : public QObject {
    Q_OBJECT

public:
    explicit JudgmentEngine(QObject* parent = nullptr);

    void setRules(const JudgmentRules& rules);
    bool evaluate(const InspectionResult& result) const;

private:
    bool evaluateExpression(const QString& expr,
                           const QJsonObject& data) const;

private:
    JudgmentRules rules_;
    ExpressionParser* parser_;
};


// ============================================================
// 判定规则
// ============================================================
struct JudgmentRules {
    QString okCondition;           // OK条件表达式
    QString ngCondition;           // NG条件表达式

    // 输出映射
    struct OutputMapping {
        QString condition;
        int outputPort;            // DO端口号
        bool value;                // 输出值
    };
    QList<OutputMapping> outputs;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 表达式解析器（简单实现）
// ============================================================
class ExpressionParser {
public:
    bool parse(const QString& expression, const QJsonObject& context);

private:
    QVariant evaluate(const QString& expr);
};
```

---

## 4. 算法服务层类图

### 4.1 视觉工具基类

```cpp
// ============================================================
// 视觉工具抽象基类
// ============================================================
class VisionTool : public QObject {
    Q_OBJECT

public:
    enum ToolType {
        // 图像源
        Camera, File, Video,

        // 预处理
        Gray, Blur, Binary, ROI, ColorConvert,

        // 定位检测
        TemplateMatch, FindCircle, FindLine, FindEdge,
        BlobAnalysis, AIDetection,

        // 测量计算
        MeasureDistance, MeasureAngle, MeasureArea,
        CalcCenter, CalcOrientation,

        // 判定输出
        RangeJudge, LogicOperation, PLCOutput, SaveImage
    };

    explicit VisionTool(QObject* parent = nullptr);
    virtual ~VisionTool() = default;

    // ========== 核心接口 ==========
    virtual ToolType toolType() const = 0;
    virtual QString toolName() const = 0;
    virtual QIcon toolIcon() const = 0;

    // 处理接口
    virtual bool process(const ImageData::Ptr& input,
                        ToolResult& output) = 0;

    // 参数接口
    virtual QWidget* createParamWidget() = 0;
    virtual QJsonObject serializeParams() const = 0;
    virtual void deserializeParams(const QJsonObject& json) = 0;

    // 调试接口
    virtual ImageData::Ptr getDebugImage() const { return debugImage_; }
    virtual QString getStatusText() const { return statusText_; }

    // ========== 属性 ==========
    bool isEnabled() const { return enabled_; }
    void setEnabled(bool enabled);

    QString displayName() const { return displayName_; }
    void setDisplayName(const QString& name);

signals:
    void paramChanged();
    void processingStarted();
    void processingFinished(bool success, qint64 elapsedMs);
    void debugImageUpdated();
    void statusTextChanged(const QString& text);

protected:
    void setDebugImage(const ImageData::Ptr& image);
    void setStatusText(const QString& text);

protected:
    bool enabled_;
    QString displayName_;
    ImageData::Ptr debugImage_;
    QString statusText_;
};


// ============================================================
// 工具结果
// ============================================================
struct ToolResult {
    bool success;                  // 是否成功
    QString errorMessage;          // 错误消息
    QJsonObject data;              // 结果数据
    ImageData::Ptr outputImage;    // 输出图像

    // 便捷方法
    template<typename T>
    T getValue(const QString& key, const T& defaultValue = T()) const {
        return data.value(key).toVariant().value<T>();
    }

    void setValue(const QString& key, const QVariant& value) {
        data[key] = QJsonValue::fromVariant(value);
    }
};
```

### 4.2 具体工具实现示例

```cpp
// ============================================================
// 灰度转换工具
// ============================================================
class GrayTool : public VisionTool {
    Q_OBJECT

public:
    enum ConvertMode {
        Average,      // 平均法
        Weighted,     // 加权法
        Desaturation, // 去饱和法
        SingleChannel // 单通道
    };

    explicit GrayTool(QObject* parent = nullptr);

    ToolType toolType() const override { return Gray; }
    QString toolName() const override { return tr("灰度转换"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // 参数设置
    void setConvertMode(ConvertMode mode) { convertMode_ = mode; }
    ConvertMode convertMode() const { return convertMode_; }

private:
    ConvertMode convertMode_;
};


// ============================================================
// 找圆工具
// ============================================================
class FindCircleTool : public VisionTool {
    Q_OBJECT

public:
    struct Params {
        double minRadius;          // 最小半径
        double maxRadius;          // 最大半径
        int edgeThreshold;         // 边缘强度
        int minEdgePoints;         // 最小边缘点数
        bool useROI;               // 是否使用ROI
        cv::Rect roi;              // ROI区域
    };

    explicit FindCircleTool(QObject* parent = nullptr);

    ToolType toolType() const override { return FindCircle; }
    QString toolName() const override { return tr("找圆"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // 参数访问
    Params& params() { return params_; }
    const Params& params() const { return params_; }

private:
    Params params_;
    cv::Vec3f lastFoundCircle_;  // 上次找到的圆(x, y, r)
};


// ============================================================
// AI检测工具
// ============================================================
class AIDetectionTool : public VisionTool {
    Q_OBJECT

public:
    explicit AIDetectionTool(QObject* parent = nullptr);
    ~AIDetectionTool() override;

    ToolType toolType() const override { return AIDetection; }
    QString toolName() const override { return tr("AI检测"); }
    QIcon toolIcon() const override;

    bool process(const ImageData::Ptr& input,
                ToolResult& output) override;

    QWidget* createParamWidget() override;
    QJsonObject serializeParams() const override;
    void deserializeParams(const QJsonObject& json) override;

    // AI模型管理
    bool loadModel(const QString& modelPath);
    void unloadModel();
    bool isModelLoaded() const { return inferenceEngine_ != nullptr; }

    // 参数设置
    void setConfidenceThreshold(float threshold);
    void setNMSThreshold(float threshold);

private:
    QString modelPath_;
    float confidenceThreshold_;
    float nmsThreshold_;

    // AI推理引擎
    AIInferenceEngine* inferenceEngine_;
};
```

### 4.3 工具工厂

```cpp
// ============================================================
// 工具工厂（单例）
// ============================================================
class ToolFactory {
public:
    static ToolFactory& instance();

    // 创建工具
    VisionTool* createTool(VisionTool::ToolType type);
    VisionTool* createTool(const QString& typeName);

    // 注册自定义工具
    void registerTool(const QString& typeName,
                     std::function<VisionTool*()> creator);

    // 获取所有工具类型
    QList<VisionTool::ToolType> availableToolTypes() const;
    QStringList availableToolNames() const;

    // 工具信息
    struct ToolInfo {
        VisionTool::ToolType type;
        QString name;
        QString category;      // 分类
        QString description;   // 描述
        QIcon icon;
    };
    ToolInfo getToolInfo(VisionTool::ToolType type) const;

private:
    ToolFactory();
    ~ToolFactory();

    void registerBuiltInTools();

private:
    QMap<VisionTool::ToolType, std::function<VisionTool*()>> creators_;
    QMap<VisionTool::ToolType, ToolInfo> toolInfos_;
};
```

---

## 5. 硬件抽象层(HAL)类图

### 5.1 相机接口

```cpp
// ============================================================
// 相机抽象接口
// ============================================================
class ICamera : public QObject {
    Q_OBJECT

public:
    enum TriggerMode {
        Continuous,    // 连续采集
        Software,      // 软件触发
        Hardware       // 硬件触发
    };

    struct Config {
        int width;
        int height;
        int offsetX;
        int offsetY;
        double exposure;       // 曝光时间(μs)
        double gain;           // 增益(dB)
        TriggerMode triggerMode;
    };

    virtual ~ICamera() = default;

    // ========== 设备管理 ==========
    virtual bool open() = 0;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;

    virtual QString deviceName() const = 0;
    virtual QString serialNumber() const = 0;

    // ========== 采集控制 ==========
    virtual bool startGrabbing() = 0;
    virtual void stopGrabbing() = 0;
    virtual bool isGrabbing() const = 0;

    virtual ImageData::Ptr grabImage(int timeoutMs = 1000) = 0;
    virtual bool trigger() = 0;  // 软触发

    // ========== 参数配置 ==========
    virtual void setConfig(const Config& config) = 0;
    virtual Config getConfig() const = 0;

    virtual void setExposure(double exposure) = 0;
    virtual double getExposure() const = 0;

    virtual void setGain(double gain) = 0;
    virtual double getGain() const = 0;

    virtual void setTriggerMode(TriggerMode mode) = 0;
    virtual TriggerMode getTriggerMode() const = 0;

signals:
    void imageGrabbed(ImageData::Ptr image);
    void errorOccurred(const QString& error);

protected:
    ICamera(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// GenICam相机实现
// ============================================================
class GenICamCamera : public ICamera {
    Q_OBJECT

public:
    explicit GenICamCamera(const QString& deviceId,
                          QObject* parent = nullptr);
    ~GenICamCamera() override;

    bool open() override;
    void close() override;
    bool isOpen() const override;

    QString deviceName() const override;
    QString serialNumber() const override;

    bool startGrabbing() override;
    void stopGrabbing() override;
    bool isGrabbing() const override;

    ImageData::Ptr grabImage(int timeoutMs = 1000) override;
    bool trigger() override;

    void setConfig(const Config& config) override;
    Config getConfig() const override;

    void setExposure(double exposure) override;
    double getExposure() const override;

    void setGain(double gain) override;
    double getGain() const override;

    void setTriggerMode(TriggerMode mode) override;
    TriggerMode getTriggerMode() const override;

private:
    class Impl;  // PIMPL模式隐藏GenICam SDK细节
    std::unique_ptr<Impl> impl_;
};


// ============================================================
// 模拟相机（用于测试）
// ============================================================
class SimulatedCamera : public ICamera {
    Q_OBJECT

public:
    explicit SimulatedCamera(QObject* parent = nullptr);

    void setImageSource(const QString& imagePath);  // 设置测试图像
    void setImageSequence(const QStringList& imagePaths);

    // ... 实现ICamera接口
};
```

### 5.2 光源接口

```cpp
// ============================================================
// 光源抽象接口
// ============================================================
class ILight : public QObject {
    Q_OBJECT

public:
    virtual ~ILight() = default;

    virtual bool open() = 0;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;

    // 亮度控制 (0-255)
    virtual void setBrightness(int channel, int value) = 0;
    virtual int getBrightness(int channel) const = 0;

    // 开关
    virtual void turnOn(int channel) = 0;
    virtual void turnOff(int channel) = 0;
    virtual void turnOnAll() = 0;
    virtual void turnOffAll() = 0;

signals:
    void errorOccurred(const QString& error);

protected:
    ILight(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// 串口光源控制器
// ============================================================
class SerialLightController : public ILight {
    Q_OBJECT

public:
    explicit SerialLightController(const QString& portName,
                                  QObject* parent = nullptr);
    ~SerialLightController() override;

    // ... 实现ILight接口

private:
    QSerialPort* serialPort_;
    QString portName_;
};
```

### 5.3 PLC接口

```cpp
// ============================================================
// PLC抽象接口
// ============================================================
class IPLC : public QObject {
    Q_OBJECT

public:
    virtual ~IPLC() = default;

    virtual bool connect() = 0;
    virtual void disconnect() = 0;
    virtual bool isConnected() const = 0;

    // 数字IO
    virtual bool readDI(int address) = 0;
    virtual void writeDO(int address, bool value) = 0;

    // 寄存器读写
    virtual quint16 readRegister(int address) = 0;
    virtual void writeRegister(int address, quint16 value) = 0;

signals:
    void connected();
    void disconnected();
    void errorOccurred(const QString& error);

protected:
    IPLC(QObject* parent = nullptr) : QObject(parent) {}
};


// ============================================================
// Modbus PLC实现
// ============================================================
class ModbusPLC : public IPLC {
    Q_OBJECT

public:
    explicit ModbusPLC(const QString& ip, int port,
                      QObject* parent = nullptr);
    ~ModbusPLC() override;

    // ... 实现IPLC接口

private:
    QModbusTcpClient* modbusClient_;
    QString ipAddress_;
    int port_;
};
```

---

## 6. 基础设施层类图

### 6.1 图像数据管理

```cpp
// ============================================================
// 图像数据
// ============================================================
class ImageData {
public:
    using Ptr = std::shared_ptr<ImageData>;

    ImageData();
    explicit ImageData(const cv::Mat& mat);
    ~ImageData();

    // OpenCV矩阵
    cv::Mat& mat() { return mat_; }
    const cv::Mat& mat() const { return mat_; }

    // GPU数据（可选）
    void* gpuPtr() const { return gpuPtr_; }
    void allocateGPU();
    void uploadToGPU();
    void downloadFromGPU();

    // 元数据
    size_t timestamp() const { return timestamp_; }
    void setTimestamp(size_t ts) { timestamp_ = ts; }

    int width() const { return mat_.cols; }
    int height() const { return mat_.rows; }
    int channels() const { return mat_.channels(); }

    // 浅拷贝
    Ptr clone() const;

    // 禁止拷贝构造和赋值
    ImageData(const ImageData&) = delete;
    ImageData& operator=(const ImageData&) = delete;

private:
    cv::Mat mat_;
    void* gpuPtr_;
    size_t timestamp_;
};


// ============================================================
// 图像内存池
// ============================================================
class ImageMemoryPool {
public:
    static ImageMemoryPool& instance();

    ImageData::Ptr allocate(int width, int height, int type);
    void release(ImageData::Ptr image);

    void clear();  // 清空池
    size_t size() const;  // 池中对象数量

private:
    ImageMemoryPool();
    ~ImageMemoryPool();

    struct PoolKey {
        int width;
        int height;
        int type;

        bool operator<(const PoolKey& other) const;
    };

    QMap<PoolKey, QList<ImageData::Ptr>> pool_;
    QMutex mutex_;
};
```

### 6.2 日志系统

```cpp
// ============================================================
// 日志系统
// ============================================================
class Logger {
public:
    enum Level {
        Debug, Info, Warning, Error, Critical
    };

    static Logger& instance();

    void log(Level level, const QString& message,
            const QString& file = "", int line = 0);

    void setLogLevel(Level level);
    void setLogFile(const QString& filePath);
    void enableConsoleOutput(bool enabled);

    // 便捷宏
    #define LOG_DEBUG(msg) \
        Logger::instance().log(Logger::Debug, msg, __FILE__, __LINE__)
    #define LOG_INFO(msg) \
        Logger::instance().log(Logger::Info, msg, __FILE__, __LINE__)
    #define LOG_WARNING(msg) \
        Logger::instance().log(Logger::Warning, msg, __FILE__, __LINE__)
    #define LOG_ERROR(msg) \
        Logger::instance().log(Logger::Error, msg, __FILE__, __LINE__)

private:
    Logger();
    ~Logger();

    void writeToFile(const QString& formattedMessage);

private:
    Level logLevel_;
    QString logFilePath_;
    bool consoleOutput_;
    QMutex mutex_;
    QFile* logFile_;
};
```

### 6.3 配置管理

```cpp
// ============================================================
// 配置管理器
// ============================================================
class ConfigManager {
public:
    static ConfigManager& instance();

    // 读取配置
    QVariant getValue(const QString& key,
                     const QVariant& defaultValue = QVariant()) const;

    // 写入配置
    void setValue(const QString& key, const QVariant& value);

    // 保存/加载
    bool save();
    bool load();

    // 配置文件路径
    QString configFilePath() const;
    void setConfigFilePath(const QString& path);

private:
    ConfigManager();
    ~ConfigManager();

private:
    QString configPath_;
    QSettings* settings_;
};
```

---

## 7. 架构增强模块类图

### 7.1 标定与坐标系管理

```cpp
// ============================================================
// 坐标系枚举
// ============================================================
enum CoordinateSystem {
    ImageCS,       // 图像坐标系 (pixel)
    CameraCS,      // 相机坐标系 (mm)
    WorldCS,       // 世界坐标系 (mm)
    RobotCS        // 机械臂坐标系 (mm)
};


// ============================================================
// 坐标变换结构
// ============================================================
struct CoordinateTransform {
    cv::Mat homography;        // 2D单应性矩阵 (3x3)
    cv::Mat rotationMatrix;    // 3D旋转矩阵 (3x3)
    cv::Mat translationVec;    // 3D平移向量 (3x1)
    double scaleX;             // X轴缩放比例 (mm/pixel)
    double scaleY;             // Y轴缩放比例 (mm/pixel)

    // 2D坐标转换
    cv::Point2d transform(const cv::Point2d& srcPoint) const;

    // 3D坐标转换
    cv::Point3d transform3D(const cv::Point3d& srcPoint) const;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 标定管理器（单例）
// ============================================================
class CalibrationManager : public QObject {
    Q_OBJECT

public:
    static CalibrationManager& instance();

    // ========== 标定方法 ==========
    // 9点标定
    bool calibrate9Point(const std::vector<cv::Point2d>& imagePoints,
                        const std::vector<cv::Point2d>& worldPoints);

    // N点标定
    bool calibrateNPoint(const std::vector<cv::Point2d>& imagePoints,
                        const std::vector<cv::Point2d>& worldPoints);

    // 棋盘格标定
    bool calibrateChessboard(const std::vector<cv::Mat>& images,
                            const cv::Size& patternSize,
                            double squareSize);

    // 圆点标定板
    bool calibrateCircleGrid(const std::vector<cv::Mat>& images,
                            const cv::Size& patternSize,
                            double circleSpacing);

    // ========== 坐标变换 ==========
    CoordinateTransform getTransform(CoordinateSystem from,
                                     CoordinateSystem to) const;

    cv::Point2d transformPoint(const cv::Point2d& pt,
                              CoordinateSystem from,
                              CoordinateSystem to) const;

    std::vector<cv::Point2d> transformPoints(
        const std::vector<cv::Point2d>& points,
        CoordinateSystem from,
        CoordinateSystem to) const;

    // ========== 标定精度 ==========
    double getReprojectionError() const;
    double getPixelToMM() const;  // 像素到毫米的转换比例

    // ========== 持久化 ==========
    bool saveCalibration(const QString& filePath);
    bool loadCalibration(const QString& filePath);

    // ========== 标定状态 ==========
    bool isCalibrated(CoordinateSystem from, CoordinateSystem to) const;
    void clearCalibration();

signals:
    void calibrationCompleted(bool success, double error);
    void calibrationDataChanged();

private:
    CalibrationManager();
    ~CalibrationManager();

    bool computeHomography(const std::vector<cv::Point2d>& srcPoints,
                          const std::vector<cv::Point2d>& dstPoints,
                          cv::Mat& homography);

private:
    // 存储各坐标系之间的变换矩阵
    QMap<QPair<CoordinateSystem, CoordinateSystem>, CoordinateTransform> transforms_;

    // 相机内参矩阵
    cv::Mat cameraMatrix_;
    cv::Mat distCoeffs_;

    // 标定精度
    double reprojectionError_;

    // 是否已标定
    bool isCalibrated_;
};


// ============================================================
// ImageData增强（添加坐标系支持）
// ============================================================
// 注意：此处仅展示新增成员，完整定义见第6章
class ImageDataEnhanced : public ImageData {
public:
    // 新增：坐标系信息
    CoordinateSystem coordinateSystem_ = ImageCS;
    CoordinateTransform transform_;

    // 带坐标系的点转换
    cv::Point2d toWorldCoordinate(const cv::Point2d& imagePoint) const {
        if (coordinateSystem_ == ImageCS) {
            return transform_.transform(imagePoint);
        }
        return imagePoint;
    }

    cv::Point2d toImageCoordinate(const cv::Point2d& worldPoint) const {
        // 需要逆变换
        cv::Mat invHomography = transform_.homography.inv();
        cv::Mat pt = (cv::Mat_<double>(3, 1) << worldPoint.x, worldPoint.y, 1.0);
        cv::Mat result = invHomography * pt;
        return cv::Point2d(result.at<double>(0) / result.at<double>(2),
                          result.at<double>(1) / result.at<double>(2));
    }
};
```

---

### 7.2 高频数据持久化

```cpp
// ============================================================
// 结果队列（无锁环形缓冲区）
// ============================================================
class ResultQueue {
public:
    static constexpr size_t QUEUE_SIZE = 10000;

    ResultQueue();
    ~ResultQueue();

    // 生产者接口
    bool push(const InspectionResult& result);

    // 消费者接口
    bool pop(InspectionResult& result);

    // 队列状态
    size_t size() const;
    bool isEmpty() const;
    bool isFull() const;

    // 清空队列
    void clear();

private:
    std::array<InspectionResult, QUEUE_SIZE> buffer_;
    std::atomic<size_t> writeIndex_{0};
    std::atomic<size_t> readIndex_{0};
};


// ============================================================
// 异步结果写入器（后台线程）
// ============================================================
class AsyncResultWriter : public QThread {
    Q_OBJECT

public:
    static AsyncResultWriter& instance();

    // 入队检测结果
    void enqueue(const InspectionResult& result);

    // 启动/停止写入线程
    void start();
    void stop();

    // 暂停/恢复（用于实时模式）
    void pause();
    void resume();

    // 立即刷新所有待写入数据
    void flush();

    // 统计信息
    size_t getPendingCount() const { return queue_.size(); }
    size_t getTotalWritten() const { return totalWritten_; }

signals:
    void batchWritten(int count, qint64 elapsedMs);
    void queueOverflow(int droppedCount);
    void errorOccurred(const QString& error);

protected:
    void run() override;

private:
    AsyncResultWriter();
    ~AsyncResultWriter();

    void writeBatch(const std::vector<InspectionResult>& batch);
    bool writeSingleResult(const InspectionResult& result);

private:
    ResultQueue queue_;
    std::atomic<bool> stopFlag_{false};
    std::atomic<bool> pauseFlag_{false};
    std::atomic<size_t> totalWritten_{0};

    // 批量写入配置
    static constexpr int BATCH_SIZE = 100;
    static constexpr int BATCH_TIMEOUT_MS = 500;

    QSqlDatabase db_;
};


// ============================================================
// 分层日志接口
// ============================================================
class IResultLogger {
public:
    virtual ~IResultLogger() = default;
    virtual void logResult(const InspectionResult& result) = 0;
};


// ============================================================
// 生产模式日志（精简）
// ============================================================
class ProductionLogger : public IResultLogger {
public:
    void logResult(const InspectionResult& result) override {
        // 仅记录：时间戳、OK/NG、总耗时
        QJsonObject log;
        log["timestamp"] = result.timestamp.toString(Qt::ISODate);
        log["ok"] = result.ok;
        log["totalTime"] = result.totalTime;

        // 写入轻量级日志文件
        writeToLog(log);
    }

private:
    void writeToLog(const QJsonObject& log);
};


// ============================================================
// 调试模式日志（完整）
// ============================================================
class DebugLogger : public IResultLogger {
public:
    void logResult(const InspectionResult& result) override {
        // 记录完整信息：所有步骤、中间结果、图像
        QJsonObject log = result.toJson();

        // 保存中间图像
        for (int i = 0; i < result.stepResults.size(); ++i) {
            if (result.stepResults[i].success) {
                QString imagePath = QString("debug/step%1_%2.png")
                    .arg(i)
                    .arg(result.timestamp.toMSecsSinceEpoch());
                // cv::imwrite(imagePath, ...);
            }
        }

        writeToLog(log);
    }

private:
    void writeToLog(const QJsonObject& log);
};
```

---

### 7.3 逻辑控制增强

```cpp
// ============================================================
// Lua脚本引擎
// ============================================================
class LuaScriptEngine : public QObject {
    Q_OBJECT

public:
    explicit LuaScriptEngine(QObject* parent = nullptr);
    ~LuaScriptEngine() override;

    // 执行脚本
    bool executeScript(const QString& script,
                      const InspectionResult& result,
                      bool& ok);

    // 注册自定义函数
    void registerFunction(const QString& name,
                         std::function<QVariant(const QVariantList&)> func);

    // 获取脚本变量
    QVariant getVariable(const QString& name) const;

    // 设置脚本变量
    void setVariable(const QString& name, const QVariant& value);

    // 获取错误信息
    QString lastError() const { return lastError_; }

signals:
    void scriptExecuted(bool success);
    void errorOccurred(const QString& error);

private:
    void injectResultData(const InspectionResult& result);
    void extractOutputData(bool& ok);

private:
    struct lua_State* L_;
    QString lastError_;
};


// ============================================================
// JavaScript脚本引擎（基于Qt QJSEngine）
// ============================================================
class JavaScriptEngine : public QObject {
    Q_OBJECT

public:
    explicit JavaScriptEngine(QObject* parent = nullptr);
    ~JavaScriptEngine() override;

    // 执行脚本
    bool executeScript(const QString& script,
                      const InspectionResult& result,
                      bool& ok);

    // 注册Qt对象到脚本环境
    void registerObject(const QString& name, QObject* object);

    // 注册全局函数
    Q_INVOKABLE void setStepParam(int stepIndex,
                                  const QString& paramName,
                                  const QVariant& value);

    // 获取错误信息
    QString lastError() const { return lastError_; }

signals:
    void scriptExecuted(bool success);
    void errorOccurred(const QString& error);

private:
    QJSValue convertResultToJS(const InspectionResult& result);
    void extractOutputData(bool& ok);

private:
    QJSEngine* engine_;
    QString lastError_;
};


// ============================================================
// 高级表达式解析器
// ============================================================
class AdvancedExpressionParser {
public:
    AdvancedExpressionParser();
    ~AdvancedExpressionParser();

    // 计算表达式
    bool evaluate(const QString& expression,
                 const QJsonObject& context,
                 QVariant& result);

    // 支持的运算符
    // 算术: +, -, *, /, %, ^
    // 比较: ==, !=, >, <, >=, <=
    // 逻辑: &&, ||, !
    // 函数: abs(), sqrt(), min(), max(), avg(), sum()

    // 注册自定义函数
    void registerFunction(const QString& name,
                         std::function<double(const std::vector<double>&)> func);

    // 获取错误信息
    QString lastError() const { return lastError_; }

private:
    enum TokenType {
        Number, Identifier, Operator, Function,
        LeftParen, RightParen, Comma, EndOfExpr
    };

    struct Token {
        TokenType type;
        QString value;
        double numValue;
    };

    struct ASTNode {
        enum Type { NumberNode, VariableNode, BinaryOpNode, UnaryOpNode, FunctionNode };

        Type type;
        QString name;           // 用于变量名、函数名
        double value;           // 用于数字常量
        QString op;             // 用于运算符
        std::vector<ASTNode*> children;

        ~ASTNode() {
            for (auto* child : children) {
                delete child;
            }
        }
    };

    // 词法分析
    std::vector<Token> tokenize(const QString& expr);

    // 语法分析（递归下降）
    ASTNode* parseExpression(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseLogicalOr(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseLogicalAnd(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseComparison(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseTerm(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parseFactor(const std::vector<Token>& tokens, size_t& pos);
    ASTNode* parsePrimary(const std::vector<Token>& tokens, size_t& pos);

    // 求值
    QVariant evaluateNode(ASTNode* node, const QJsonObject& context);

private:
    QString lastError_;
    QMap<QString, std::function<double(const std::vector<double>&)>> customFunctions_;
};
```

---

### 7.4 HAL设备管理

```cpp
// ============================================================
// 重试策略
// ============================================================
struct RetryPolicy {
    int maxRetries = 3;           // 最大重试次数
    int retryInterval = 1000;     // 重试间隔(ms)
    bool exponentialBackoff = true; // 指数退避

    int getRetryDelay(int attemptCount) const {
        if (!exponentialBackoff) {
            return retryInterval;
        }
        return retryInterval * static_cast<int>(std::pow(2, attemptCount - 1));
    }

    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 设备管理器（单例）
// ============================================================
class DeviceManager : public QObject {
    Q_OBJECT

public:
    static DeviceManager& instance();

    // ========== 设备注册 ==========
    void registerDevice(const QString& deviceId, ICamera* camera);
    void registerDevice(const QString& deviceId, ILight* light);
    void registerDevice(const QString& deviceId, IPLC* plc);

    void unregisterDevice(const QString& deviceId);

    // ========== 健康检查 ==========
    void startMonitoring();
    void stopMonitoring();

    bool isDeviceOnline(const QString& deviceId) const;
    QDateTime getLastHeartbeat(const QString& deviceId) const;

    // ========== 重连策略 ==========
    void setRetryPolicy(const QString& deviceId, const RetryPolicy& policy);
    RetryPolicy getRetryPolicy(const QString& deviceId) const;

    // ========== 设备信息 ==========
    QStringList getAllDevices() const;
    QObject* getDevice(const QString& deviceId) const;

signals:
    void deviceStatusChanged(const QString& deviceId, bool online);
    void deviceReconnecting(const QString& deviceId, int attemptCount);
    void deviceReconnected(const QString& deviceId);
    void deviceReconnectFailed(const QString& deviceId);

private slots:
    void onHeartbeatCheck();
    void onDeviceLost(const QString& deviceId);

private:
    DeviceManager();
    ~DeviceManager();

    void attemptReconnect(const QString& deviceId);
    void updateHeartbeat(const QString& deviceId);

private:
    struct DeviceInfo {
        QObject* device;           // ICamera*, ILight*, 或 IPLC*
        QString deviceType;        // "Camera", "Light", "PLC"
        RetryPolicy retryPolicy;
        int failedAttempts;
        QDateTime lastHeartbeat;
        bool isOnline;
    };

    QMap<QString, DeviceInfo> devices_;
    QTimer* heartbeatTimer_;
    QMutex devicesMutex_;
};


// ============================================================
// ICamera接口增强（添加健康检查）
// ============================================================
// 注意：此处仅展示新增接口，完整定义见第5章
class ICameraEnhanced : public ICamera {
    Q_OBJECT

public:
    // 新增：健康检查
    virtual bool isHealthy() const = 0;
    virtual int getHeartbeatInterval() const { return 1000; }  // ms

signals:
    void deviceLost();         // 设备丢失
    void deviceRecovered();    // 设备恢复
    void heartbeatTimeout();   // 心跳超时
};


// ============================================================
// 设备枚举器（热插拔支持）
// ============================================================
class DeviceEnumerator : public QObject {
    Q_OBJECT

public:
    explicit DeviceEnumerator(QObject* parent = nullptr);
    ~DeviceEnumerator() override;

    // 启动/停止监听
    void startMonitoring();
    void stopMonitoring();

    // 枚举当前设备
    QStringList enumerateCameras() const;
    QStringList enumeratePLCs() const;

signals:
    void deviceArrived(const QString& deviceId, const QString& deviceType);
    void deviceRemoved(const QString& deviceId);

protected:
#ifdef _WIN32
    bool nativeEvent(const QByteArray& eventType,
                    void* message,
                    long* result) override;
#endif

private:
    void setupPlatformMonitoring();
    void handleDeviceChange();

private:
    struct Impl;  // PIMPL模式隐藏平台相关实现
    std::unique_ptr<Impl> impl_;
};
```

---

### 7.5 多线程基础设施

```cpp
// ============================================================
// 线程亲和性辅助类
// ============================================================
class ThreadAffinityHelper {
public:
    // 绑定线程到指定CPU核心
    static bool setAffinity(std::thread& thread, int coreId);
    static bool setAffinity(QThread& thread, int coreId);

    // 设置线程优先级
    enum Priority {
        Idle,
        Lowest,
        Low,
        Normal,
        High,
        Highest,
        TimeCritical
    };

    static bool setPriority(std::thread& thread, Priority priority);
    static bool setPriority(QThread& thread, Priority priority);

    // 获取CPU核心数
    static int getCoreCount();
    static int getPhysicalCoreCount();  // 排除超线程

    // 检查当前线程的亲和性
    static int getCurrentAffinity();

private:
    static int mapPriorityToNative(Priority priority);
};


// ============================================================
// 处理线程池
// ============================================================
class ProcessingThreadPool {
public:
    static ProcessingThreadPool& instance();

    // 初始化线程池
    void initialize(int threadCount = -1);
    void shutdown();

    // 提交任务
    std::future<InspectionResult> submit(
        std::function<InspectionResult()> task);

    // 提交带优先级的任务
    enum TaskPriority { Low, Normal, High };
    std::future<InspectionResult> submit(
        std::function<InspectionResult()> task,
        TaskPriority priority);

    // 线程池状态
    int getThreadCount() const { return static_cast<int>(workers_.size()); }
    int getQueueSize() const;
    bool isBusy() const;

    // 性能设置
    void setHighPriority();
    void setNormalPriority();

signals:
    void taskCompleted();
    void queueSizeChanged(int size);

private:
    ProcessingThreadPool();
    ~ProcessingThreadPool();

    void workerThread(int workerId);

private:
    struct Task {
        std::function<void()> func;
        TaskPriority priority;
        int id;

        bool operator<(const Task& other) const {
            return priority < other.priority;  // 高优先级在前
        }
    };

    std::vector<std::thread> workers_;
    std::priority_queue<Task> taskQueue_;
    std::mutex queueMutex_;
    std::condition_variable condition_;
    std::atomic<bool> stopFlag_{false};
    std::atomic<int> nextTaskId_{0};
};


// ============================================================
// 采集线程（专用线程）
// ============================================================
class GrabThread : public QThread {
    Q_OBJECT

public:
    explicit GrabThread(ICamera* camera, QObject* parent = nullptr);
    ~GrabThread() override;

    void start();
    void stop();

    // 获取采集的图像
    ImageData::Ptr getNextImage(int timeoutMs = 1000);

    // 统计信息
    int getFrameRate() const { return frameRate_; }
    int getDroppedFrameCount() const { return droppedFrames_; }

signals:
    void imageGrabbed(ImageData::Ptr image);
    void grabError(const QString& error);
    void frameRateChanged(int fps);

protected:
    void run() override;

private:
    void setupThreadAffinity();
    void updateFrameRate();

private:
    ICamera* camera_;
    std::atomic<bool> stopFlag_{false};

    // 无锁队列
    static constexpr size_t QUEUE_SIZE = 100;
    std::array<ImageData::Ptr, QUEUE_SIZE> imageQueue_;
    std::atomic<size_t> writeIndex_{0};
    std::atomic<size_t> readIndex_{0};

    // 统计
    std::atomic<int> frameRate_{0};
    std::atomic<int> droppedFrames_{0};
    std::chrono::steady_clock::time_point lastFrameTime_;
};


// ============================================================
// 实时性保证辅助类
// ============================================================
class RealTimeHelper {
public:
    // 锁定进程工作集（避免swap）
    static bool lockMemory();
    static bool unlockMemory();

    // 预分配内存（避免运行时分配）
    static void preallocateImageMemory(int count, int width, int height, int type);

    // 禁用后台任务
    static void disableBackgroundTasks();
    static void enableBackgroundTasks();

    // 设置进程优先级
    static bool setProcessPriority(ThreadAffinityHelper::Priority priority);
};
```

---

## 8. 类关系总结

### 8.1 依赖关系

```
MainWindow
    ├─> RecipeManager
    ├─> TaskScheduler
    │       └─> PipelineExecutor
    │               └─> VisionTool (多个)
    ├─> SimpleModeWidget
    │       ├─> StepListWidget
    │       ├─> ImageDisplayWidget
    │       └─> SimpleParamPanel
    └─> ProfessionalModeWidget
            ├─> ProjectTreeWidget
            ├─> ToolboxWidget
            ├─> PropertyPanel
            └─> StepNavigator

Recipe
    ├─> VisionTool[] (步骤列表)
    ├─> CameraConfig
    └─> JudgmentRules

VisionTool (抽象)
    ├─> GrayTool
    ├─> FindCircleTool
    ├─> AIDetectionTool
    └─> ... (其他工具)

ICamera (抽象)
    ├─> GenICamCamera
    └─> SimulatedCamera

IPLC (抽象)
    ├─> ModbusPLC
    └─> EthernetIPPLC
```

### 8.2 继承关系

```
QObject
    ├─> VisionTool
    │       ├─> GrayTool
    │       ├─> FindCircleTool
    │       └─> ...
    │
    ├─> ICamera
    │       ├─> GenICamCamera
    │       └─> SimulatedCamera
    │
    ├─> IPLC
    │       ├─> ModbusPLC
    │       └─> ...
    │
    ├─> RecipeManager
    ├─> TaskScheduler
    └─> ...

QWidget
    ├─> MainWindow (继承QMainWindow)
    ├─> SimpleModeWidget
    ├─> ProfessionalModeWidget
    ├─> StepListWidget (继承QListWidget)
    ├─> PropertyPanel (继承QScrollArea)
    └─> ...
```

---

## 9. 设计模式应用

| 模式 | 应用场景 | 类 |
|------|---------|-----|
| **单例模式** | 全局唯一实例 | RecipeManager, ToolFactory, Logger, CalibrationManager, DeviceManager, ProcessingThreadPool |
| **工厂模式** | 创建工具对象 | ToolFactory |
| **策略模式** | 不同算法实现 | VisionTool子类, IResultLogger子类 (ProductionLogger, DebugLogger) |
| **观察者模式** | UI更新通知 | Qt信号槽机制 |
| **命令模式** | 撤销/重做 | RecipeVersionControl |
| **适配器模式** | 硬件接口适配 | ICamera子类 |
| **外观模式** | 简化复杂接口 | RecipeManager, CalibrationManager |
| **PIMPL** | 隐藏实现细节 | GenICamCamera::Impl, DeviceEnumerator::Impl |
| **线程池模式** | 任务并发执行 | ProcessingThreadPool |
| **生产者-消费者模式** | 异步数据处理 | ResultQueue + AsyncResultWriter, GrabThread + 处理线程池 |
| **重试模式** | 失败自动重试 | DeviceManager + RetryPolicy |
| **解释器模式** | 脚本/表达式执行 | LuaScriptEngine, JavaScriptEngine, AdvancedExpressionParser |

---

**文档状态**: ✅ 已完成
**下一步**: 编写交互流程图设计
