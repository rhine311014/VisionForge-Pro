# VisionForge Pro - 数据结构设计

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2025-12-14
- **设计者**: VisionForge Team

---

## 1. 数据结构总览

```
VisionForge Pro 数据模型：

Project (项目)
  └─> Recipe[] (配方列表)
        ├─> Metadata (元数据)
        ├─> CameraConfig (相机配置)
        ├─> Step[] (步骤列表)
        │     └─> ToolParams (工具参数)
        ├─> JudgmentRules (判定规则)
        └─> Statistics (统计数据)

InspectionResult (检测结果)
  ├─> StepResult[] (步骤结果)
  ├─> ImageData (图像数据)
  └─> Judgment (OK/NG判定)
```

---

## 2. 配方(Recipe)数据结构

### 2.1 配方JSON格式

```json
{
  "metadata": {
    "name": "螺丝孔检测",
    "version": 5,
    "uuid": "550e8400-e29b-41d4-a716-446655440000",
    "createdTime": "2025-12-01T10:00:00Z",
    "modifiedTime": "2025-12-14T14:30:00Z",
    "author": "张工",
    "description": "检测螺丝孔位置和数量",
    "tags": ["3C电子", "组装检测"]
  },

  "cameraConfig": {
    "deviceType": "GenICam",
    "deviceId": "Basler-acA1920-192.168.1.10",
    "resolution": {
      "width": 1920,
      "height": 1080
    },
    "offset": {
      "x": 0,
      "y": 0
    },
    "exposure": 5000.0,
    "gain": 2.5,
    "triggerMode": "Software",
    "pixelFormat": "Mono8"
  },

  "steps": [
    {
      "id": "step-001",
      "type": "Camera",
      "enabled": true,
      "displayName": "相机采集",
      "params": {
        "triggerSource": "Camera"
      }
    },
    {
      "id": "step-002",
      "type": "Gray",
      "enabled": true,
      "displayName": "灰度转换",
      "params": {
        "convertMode": "Weighted"
      }
    },
    {
      "id": "step-003",
      "type": "Blur",
      "enabled": true,
      "displayName": "高斯滤波",
      "params": {
        "kernelSize": 5,
        "sigma": 1.5
      }
    },
    {
      "id": "step-004",
      "type": "FindCircle",
      "enabled": true,
      "displayName": "找圆",
      "params": {
        "minRadius": 50.0,
        "maxRadius": 200.0,
        "edgeThreshold": 30,
        "minEdgePoints": 50,
        "useROI": true,
        "roi": {
          "x": 100,
          "y": 100,
          "width": 800,
          "height": 600
        }
      }
    },
    {
      "id": "step-005",
      "type": "MeasureDistance",
      "enabled": true,
      "displayName": "测量距离",
      "params": {
        "point1": "step-004.circle[0].center",
        "point2": "step-004.circle[1].center",
        "unit": "mm",
        "calibration": 0.12
      }
    },
    {
      "id": "step-006",
      "type": "RangeJudge",
      "enabled": true,
      "displayName": "范围判定",
      "params": {
        "inputValue": "step-005.distance",
        "minValue": 95.0,
        "maxValue": 105.0,
        "condition": "InRange"
      }
    }
  ],

  "judgmentRules": {
    "okCondition": "step-006.result == true && step-004.count >= 2",
    "ngCondition": "!okCondition",
    "outputs": [
      {
        "condition": "okCondition",
        "outputType": "PLC_DO",
        "address": 1,
        "value": true
      },
      {
        "condition": "ngCondition",
        "outputType": "PLC_DO",
        "address": 2,
        "value": true
      }
    ]
  },

  "statistics": {
    "enabled": true,
    "saveImages": {
      "saveOK": false,
      "saveNG": true,
      "savePath": "D:/VisionData/NG/"
    },
    "dataLogging": {
      "enabled": true,
      "logPath": "D:/VisionData/Logs/",
      "fields": ["timestamp", "result", "distance", "count"]
    }
  }
}
```

### 2.2 C++数据结构

```cpp
// ============================================================
// 配方元数据
// ============================================================
struct RecipeMetadata {
    QString name;                  // 配方名称
    int version;                   // 版本号
    QUuid uuid;                    // 唯一标识符
    QDateTime createdTime;         // 创建时间
    QDateTime modifiedTime;        // 修改时间
    QString author;                // 作者
    QString description;           // 描述
    QStringList tags;              // 标签

    // 序列化
    QJsonObject toJson() const {
        QJsonObject json;
        json["name"] = name;
        json["version"] = version;
        json["uuid"] = uuid.toString();
        json["createdTime"] = createdTime.toString(Qt::ISODate);
        json["modifiedTime"] = modifiedTime.toString(Qt::ISODate);
        json["author"] = author;
        json["description"] = description;
        json["tags"] = QJsonArray::fromStringList(tags);
        return json;
    }

    bool fromJson(const QJsonObject& json) {
        name = json["name"].toString();
        version = json["version"].toInt();
        uuid = QUuid::fromString(json["uuid"].toString());
        createdTime = QDateTime::fromString(json["createdTime"].toString(), Qt::ISODate);
        modifiedTime = QDateTime::fromString(json["modifiedTime"].toString(), Qt::ISODate);
        author = json["author"].toString();
        description = json["description"].toString();

        QJsonArray tagsArray = json["tags"].toArray();
        tags.clear();
        for (const auto& tag : tagsArray) {
            tags.append(tag.toString());
        }
        return true;
    }
};


// ============================================================
// 相机配置
// ============================================================
struct CameraConfig {
    QString deviceType;            // 设备类型: "GenICam", "File", "Video"
    QString deviceId;              // 设备ID

    struct {
        int width;
        int height;
    } resolution;

    struct {
        int x;
        int y;
    } offset;

    double exposure;               // 曝光时间 (μs)
    double gain;                   // 增益 (dB)
    QString triggerMode;           // "Continuous", "Software", "Hardware"
    QString pixelFormat;           // "Mono8", "Mono12", "RGB8", "BayerRG8"

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 步骤配置
// ============================================================
struct StepConfig {
    QString id;                    // 步骤唯一ID (如 "step-001")
    QString type;                  // 工具类型 (如 "FindCircle")
    bool enabled;                  // 是否启用
    QString displayName;           // 显示名称
    QJsonObject params;            // 参数 (动态，不同工具不同)

    // 序列化
    QJsonObject toJson() const {
        QJsonObject json;
        json["id"] = id;
        json["type"] = type;
        json["enabled"] = enabled;
        json["displayName"] = displayName;
        json["params"] = params;
        return json;
    }

    bool fromJson(const QJsonObject& json) {
        id = json["id"].toString();
        type = json["type"].toString();
        enabled = json["enabled"].toBool();
        displayName = json["displayName"].toString();
        params = json["params"].toObject();
        return true;
    }
};


// ============================================================
// 判定规则
// ============================================================
struct JudgmentRules {
    QString okCondition;           // OK条件表达式
    QString ngCondition;           // NG条件表达式

    struct OutputMapping {
        QString condition;         // 条件表达式
        QString outputType;        // "PLC_DO", "Serial", "TCP"
        int address;               // 输出地址
        QVariant value;            // 输出值

        QJsonObject toJson() const {
            QJsonObject json;
            json["condition"] = condition;
            json["outputType"] = outputType;
            json["address"] = address;
            json["value"] = QJsonValue::fromVariant(value);
            return json;
        }

        bool fromJson(const QJsonObject& json) {
            condition = json["condition"].toString();
            outputType = json["outputType"].toString();
            address = json["address"].toInt();
            value = json["value"].toVariant();
            return true;
        }
    };

    QList<OutputMapping> outputs;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 统计配置
// ============================================================
struct StatisticsConfig {
    bool enabled;

    struct {
        bool saveOK;
        bool saveNG;
        QString savePath;
    } saveImages;

    struct {
        bool enabled;
        QString logPath;
        QStringList fields;
    } dataLogging;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};
```

---

## 3. 检测结果数据结构

### 3.1 结果JSON格式

```json
{
  "timestamp": "2025-12-14T15:30:45.123Z",
  "recipeId": "550e8400-e29b-41d4-a716-446655440000",
  "recipeName": "螺丝孔检测",
  "recipeVersion": 5,

  "result": {
    "ok": true,
    "totalTime": 23.5,
    "cycleCount": 12345
  },

  "stepResults": [
    {
      "stepId": "step-001",
      "stepName": "相机采集",
      "success": true,
      "elapsedTime": 2.1,
      "data": {
        "imageWidth": 1920,
        "imageHeight": 1080,
        "imageFormat": "Mono8"
      }
    },
    {
      "stepId": "step-004",
      "stepName": "找圆",
      "success": true,
      "elapsedTime": 5.8,
      "data": {
        "count": 3,
        "circles": [
          {
            "center": {"x": 250.5, "y": 180.2},
            "radius": 75.3
          },
          {
            "center": {"x": 450.1, "y": 182.8},
            "radius": 74.8
          },
          {
            "center": {"x": 650.3, "y": 181.5},
            "radius": 75.1
          }
        ]
      }
    },
    {
      "stepId": "step-005",
      "stepName": "测量距离",
      "success": true,
      "elapsedTime": 0.5,
      "data": {
        "distance": 99.5,
        "unit": "mm"
      }
    },
    {
      "stepId": "step-006",
      "stepName": "范围判定",
      "success": true,
      "elapsedTime": 0.1,
      "data": {
        "result": true,
        "value": 99.5,
        "min": 95.0,
        "max": 105.0
      }
    }
  ],

  "images": {
    "input": "data:image/png;base64,iVBORw0KGgoAAAANSU...",
    "result": "data:image/png;base64,iVBORw0KGgoAAAANSU..."
  },

  "plcOutputs": [
    {
      "address": 1,
      "value": true,
      "timestamp": "2025-12-14T15:30:45.150Z"
    }
  ]
}
```

### 3.2 C++数据结构

```cpp
// ============================================================
// 检测结果
// ============================================================
struct InspectionResult {
    QDateTime timestamp;           // 时间戳
    QUuid recipeId;                // 配方ID
    QString recipeName;            // 配方名称
    int recipeVersion;             // 配方版本

    struct {
        bool ok;                   // OK/NG
        double totalTime;          // 总耗时(ms)
        quint64 cycleCount;        // 循环次数
    } result;

    struct StepResult {
        QString stepId;
        QString stepName;
        bool success;
        double elapsedTime;        // 耗时(ms)
        QJsonObject data;          // 步骤结果数据

        QJsonObject toJson() const {
            QJsonObject json;
            json["stepId"] = stepId;
            json["stepName"] = stepName;
            json["success"] = success;
            json["elapsedTime"] = elapsedTime;
            json["data"] = data;
            return json;
        }

        bool fromJson(const QJsonObject& json) {
            stepId = json["stepId"].toString();
            stepName = json["stepName"].toString();
            success = json["success"].toBool();
            elapsedTime = json["elapsedTime"].toDouble();
            data = json["data"].toObject();
            return true;
        }
    };
    QList<StepResult> stepResults;

    struct {
        QByteArray input;          // Base64编码的输入图像
        QByteArray result;         // Base64编码的结果图像
    } images;

    struct PLCOutput {
        int address;
        QVariant value;
        QDateTime timestamp;

        QJsonObject toJson() const {
            QJsonObject json;
            json["address"] = address;
            json["value"] = QJsonValue::fromVariant(value);
            json["timestamp"] = timestamp.toString(Qt::ISODate);
            return json;
        }
    };
    QList<PLCOutput> plcOutputs;

    // 序列化
    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);

    // 保存到文件
    bool saveToFile(const QString& filePath) const;
    bool loadFromFile(const QString& filePath);
};
```

---

## 4. 工具参数数据结构

### 4.1 通用工具参数

```cpp
// ============================================================
// 找圆工具参数
// ============================================================
struct FindCircleParams {
    double minRadius;              // 最小半径
    double maxRadius;              // 最大半径
    int edgeThreshold;             // 边缘强度阈值
    int minEdgePoints;             // 最小边缘点数
    bool useROI;                   // 是否使用ROI
    cv::Rect roi;                  // ROI区域

    QJsonObject toJson() const {
        QJsonObject json;
        json["minRadius"] = minRadius;
        json["maxRadius"] = maxRadius;
        json["edgeThreshold"] = edgeThreshold;
        json["minEdgePoints"] = minEdgePoints;
        json["useROI"] = useROI;

        if (useROI) {
            QJsonObject roiObj;
            roiObj["x"] = roi.x;
            roiObj["y"] = roi.y;
            roiObj["width"] = roi.width;
            roiObj["height"] = roi.height;
            json["roi"] = roiObj;
        }

        return json;
    }

    bool fromJson(const QJsonObject& json) {
        minRadius = json["minRadius"].toDouble();
        maxRadius = json["maxRadius"].toDouble();
        edgeThreshold = json["edgeThreshold"].toInt();
        minEdgePoints = json["minEdgePoints"].toInt();
        useROI = json["useROI"].toBool();

        if (useROI && json.contains("roi")) {
            QJsonObject roiObj = json["roi"].toObject();
            roi.x = roiObj["x"].toInt();
            roi.y = roiObj["y"].toInt();
            roi.width = roiObj["width"].toInt();
            roi.height = roiObj["height"].toInt();
        }

        return true;
    }
};


// ============================================================
// AI检测工具参数
// ============================================================
struct AIDetectionParams {
    QString modelPath;             // 模型文件路径
    QString modelType;             // 模型类型: "YOLO", "Classify", "Segment"
    float confidenceThreshold;     // 置信度阈值 (0.0-1.0)
    float nmsThreshold;            // NMS阈值 (0.0-1.0)
    int maxDetections;             // 最大检测数量
    QStringList classList;         // 类别列表
    bool useGPU;                   // 是否使用GPU

    struct {
        int inputWidth;
        int inputHeight;
    } inputSize;

    QJsonObject toJson() const;
    bool fromJson(const QJsonObject& json);
};


// ============================================================
// 测量工具参数
// ============================================================
struct MeasureDistanceParams {
    QString point1;                // 点1表达式 (如 "step-004.circle[0].center")
    QString point2;                // 点2表达式
    QString unit;                  // 单位: "px", "mm", "inch"
    double calibration;            // 标定系数 (px to mm)

    QJsonObject toJson() const {
        QJsonObject json;
        json["point1"] = point1;
        json["point2"] = point2;
        json["unit"] = unit;
        json["calibration"] = calibration;
        return json;
    }

    bool fromJson(const QJsonObject& json) {
        point1 = json["point1"].toString();
        point2 = json["point2"].toString();
        unit = json["unit"].toString();
        calibration = json["calibration"].toDouble();
        return true;
    }
};
```

### 4.2 参数验证器

```cpp
// ============================================================
// 参数验证器接口
// ============================================================
class IParamValidator {
public:
    virtual ~IParamValidator() = default;

    struct ValidationResult {
        bool valid;
        QString errorMessage;
        QVariant suggestedValue;   // 建议值
    };

    virtual ValidationResult validate(const QString& paramName,
                                     const QVariant& value) const = 0;
};


// ============================================================
// 范围验证器
// ============================================================
class RangeValidator : public IParamValidator {
public:
    RangeValidator(double min, double max)
        : minValue_(min), maxValue_(max) {}

    ValidationResult validate(const QString& paramName,
                             const QVariant& value) const override {
        double val = value.toDouble();

        if (val < minValue_ || val > maxValue_) {
            ValidationResult result;
            result.valid = false;
            result.errorMessage = QString("%1 必须在 [%2, %3] 范围内")
                .arg(paramName).arg(minValue_).arg(maxValue_);
            result.suggestedValue = qBound(minValue_, val, maxValue_);
            return result;
        }

        return {true, "", value};
    }

private:
    double minValue_;
    double maxValue_;
};


// ============================================================
// 枚举验证器
// ============================================================
class EnumValidator : public IParamValidator {
public:
    EnumValidator(const QStringList& validValues)
        : validValues_(validValues) {}

    ValidationResult validate(const QString& paramName,
                             const QVariant& value) const override {
        QString val = value.toString();

        if (!validValues_.contains(val)) {
            ValidationResult result;
            result.valid = false;
            result.errorMessage = QString("%1 必须是以下之一: %2")
                .arg(paramName).arg(validValues_.join(", "));
            result.suggestedValue = validValues_.first();
            return result;
        }

        return {true, "", value};
    }

private:
    QStringList validValues_;
};
```

---

## 5. 图像数据结构

### 5.1 图像数据类

```cpp
// ============================================================
// 图像数据（零拷贝设计）
// ============================================================
class ImageData {
public:
    using Ptr = std::shared_ptr<ImageData>;

    ImageData();
    explicit ImageData(const cv::Mat& mat);
    ~ImageData();

    // OpenCV矩阵
    cv::Mat& mat() { return mat_; }
    const cv::Mat& mat() const { return mat_; }

    // GPU数据（可选）
    void* gpuPtr() const { return gpuPtr_; }
    bool hasGPUData() const { return gpuPtr_ != nullptr; }

    void allocateGPU();
    void uploadToGPU();
    void downloadFromGPU();
    void releaseGPU();

    // 元数据
    size_t timestamp() const { return timestamp_; }
    void setTimestamp(size_t ts) { timestamp_ = ts; }

    QString source() const { return source_; }
    void setSource(const QString& src) { source_ = src; }

    // 图像属性
    int width() const { return mat_.cols; }
    int height() const { return mat_.rows; }
    int channels() const { return mat_.channels(); }
    int depth() const { return mat_.depth(); }
    size_t sizeInBytes() const { return mat_.total() * mat_.elemSize(); }

    // 浅拷贝（共享数据）
    Ptr clone() const;

    // 深拷贝（独立数据）
    Ptr deepClone() const;

    // 禁止拷贝构造和赋值
    ImageData(const ImageData&) = delete;
    ImageData& operator=(const ImageData&) = delete;

private:
    cv::Mat mat_;                  // OpenCV矩阵
    void* gpuPtr_;                 // GPU内存指针 (CUDA)
    size_t timestamp_;             // 时间戳 (ms)
    QString source_;               // 来源标识

    friend class ImageMemoryPool;
};


// ============================================================
// 图像内存池（对象池模式）
// ============================================================
class ImageMemoryPool {
public:
    static ImageMemoryPool& instance();

    // 分配图像
    ImageData::Ptr allocate(int width, int height, int type);
    ImageData::Ptr allocate(const cv::Size& size, int type);

    // 释放图像（归还池）
    void release(ImageData::Ptr image);

    // 池管理
    void clear();                  // 清空池
    void shrink();                 // 收缩池（释放多余内存）
    size_t size() const;           // 池中对象数量
    size_t capacity() const;       // 池容量

    // 统计信息
    struct Statistics {
        size_t allocCount;         // 总分配次数
        size_t hitCount;           // 命中次数（复用）
        size_t missCount;          // 未命中次数（新建）
        size_t totalMemory;        // 总内存占用(字节)

        double hitRate() const {
            return allocCount > 0 ?
                static_cast<double>(hitCount) / allocCount : 0.0;
        }
    };
    Statistics statistics() const;

private:
    ImageMemoryPool();
    ~ImageMemoryPool();

    struct PoolKey {
        int width;
        int height;
        int type;

        bool operator<(const PoolKey& other) const {
            if (width != other.width) return width < other.width;
            if (height != other.height) return height < other.height;
            return type < other.type;
        }
    };

    QMap<PoolKey, QList<ImageData::Ptr>> pool_;
    QMutex mutex_;
    Statistics stats_;
};
```

---

## 6. 项目/配方组织结构

### 6.1 项目文件结构

```
ProjectName/
├── ProjectName.vfproj          (项目文件 - JSON)
├── recipes/                    (配方目录)
│   ├── Recipe1.vfrcp
│   ├── Recipe2.vfrcp
│   └── Recipe3.vfrcp
├── images/                     (图像资源)
│   ├── template1.png
│   └── template2.png
├── models/                     (AI模型)
│   ├── defect_detect.onnx
│   └── classify.onnx
├── logs/                       (日志)
│   ├── 2025-12-14.log
│   └── errors.log
└── data/                       (检测数据)
    ├── results_20251214.db    (SQLite数据库)
    └── ng_images/             (NG图像)
        ├── 20251214_150045.png
        └── 20251214_150123.png
```

### 6.2 项目文件格式

```json
{
  "project": {
    "name": "3C电子检测项目",
    "version": "1.0.0",
    "createdTime": "2025-12-01T10:00:00Z",
    "modifiedTime": "2025-12-14T15:30:00Z",
    "author": "张工",
    "description": "手机组装检测方案"
  },

  "recipes": [
    {
      "id": "recipe-螺丝孔检测",
      "name": "螺丝孔检测",
      "filePath": "recipes/螺丝孔检测.vfrcp",
      "enabled": true,
      "order": 1
    },
    {
      "id": "recipe-屏幕划痕",
      "name": "屏幕划痕检测",
      "filePath": "recipes/屏幕划痕.vfrcp",
      "enabled": true,
      "order": 2
    }
  ],

  "settings": {
    "defaultRecipe": "recipe-螺丝孔检测",
    "autoSaveInterval": 300,
    "logLevel": "Info"
  }
}
```

---

## 7. 数据库设计

### 7.1 SQLite Schema

```sql
-- 检测结果表
CREATE TABLE inspection_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT NOT NULL,
    recipe_id TEXT NOT NULL,
    recipe_name TEXT,
    recipe_version INTEGER,
    result TEXT NOT NULL,  -- 'OK' or 'NG'
    total_time REAL,       -- 总耗时(ms)
    cycle_count INTEGER,   -- 循环次数
    data TEXT              -- JSON格式的详细数据
);

-- 步骤结果表
CREATE TABLE step_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    inspection_id INTEGER NOT NULL,
    step_id TEXT NOT NULL,
    step_name TEXT,
    success INTEGER NOT NULL,  -- 0/1
    elapsed_time REAL,         -- 耗时(ms)
    data TEXT,                 -- JSON格式的结果数据
    FOREIGN KEY (inspection_id) REFERENCES inspection_results(id)
);

-- 统计表（按小时汇总）
CREATE TABLE statistics_hourly (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hour TEXT NOT NULL,        -- '2025-12-14 15:00'
    recipe_id TEXT NOT NULL,
    total_count INTEGER,
    ok_count INTEGER,
    ng_count INTEGER,
    avg_time REAL,             -- 平均耗时
    max_time REAL,             -- 最大耗时
    min_time REAL              -- 最小耗时
);

-- 索引
CREATE INDEX idx_results_timestamp ON inspection_results(timestamp);
CREATE INDEX idx_results_recipe ON inspection_results(recipe_id);
CREATE INDEX idx_step_results_inspection ON step_results(inspection_id);
CREATE INDEX idx_statistics_hour ON statistics_hourly(hour);
```

### 7.2 数据访问层

```cpp
// ============================================================
// 数据库访问类
// ============================================================
class DatabaseManager {
public:
    static DatabaseManager& instance();

    bool open(const QString& dbPath);
    void close();
    bool isOpen() const;

    // 写入检测结果
    bool insertResult(const InspectionResult& result);

    // 查询检测结果
    QList<InspectionResult> queryResults(
        const QDateTime& startTime,
        const QDateTime& endTime,
        const QString& recipeId = QString()
    );

    // 统计查询
    struct Statistics {
        int totalCount;
        int okCount;
        int ngCount;
        double avgTime;
        double maxTime;
        double minTime;

        double ngRate() const {
            return totalCount > 0 ?
                static_cast<double>(ngCount) / totalCount * 100.0 : 0.0;
        }
    };

    Statistics getStatistics(
        const QDateTime& startTime,
        const QDateTime& endTime,
        const QString& recipeId = QString()
    );

    // 清理旧数据
    bool deleteOldResults(int daysToKeep);

private:
    DatabaseManager();
    ~DatabaseManager();

    QSqlDatabase db_;
};
```

---

## 8. 配置文件数据结构

### 8.1 全局配置文件

```json
{
  "application": {
    "language": "zh_CN",
    "theme": "Light",
    "lastOpenProject": "D:/Projects/3C电子检测/3C电子检测.vfproj",
    "recentProjects": [
      "D:/Projects/3C电子检测/3C电子检测.vfproj",
      "D:/Projects/锂电池检测/锂电池检测.vfproj"
    ]
  },

  "ui": {
    "mode": "Simple",
    "windowGeometry": {
      "width": 1920,
      "height": 1080,
      "x": 0,
      "y": 0
    },
    "splitterStates": {
      "simple": [300, 1100, 520],
      "professional": [300, 1200, 420]
    }
  },

  "performance": {
    "useGPU": true,
    "gpuDevice": 0,
    "maxMemoryPool": 512,
    "threadPoolSize": 4
  },

  "logging": {
    "level": "Info",
    "filePath": "D:/VisionForge/logs/",
    "maxFileSize": 10485760,
    "maxFiles": 10
  },

  "network": {
    "autoDiscoverCameras": true,
    "discoveryTimeout": 5000,
    "plc": {
      "ip": "192.168.1.100",
      "port": 502,
      "protocol": "Modbus TCP"
    }
  }
}
```

---

## 9. 数据验证与约束

### 9.1 数据验证规则

```cpp
// ============================================================
// 配方验证器
// ============================================================
class RecipeValidator {
public:
    struct ValidationError {
        QString field;
        QString message;
        QString suggestion;
    };

    static QList<ValidationError> validate(const Recipe* recipe) {
        QList<ValidationError> errors;

        // 1. 检查元数据
        if (recipe->metadata().name.isEmpty()) {
            errors.append({"metadata.name", "配方名称不能为空", "请输入配方名称"});
        }

        // 2. 检查步骤
        if (recipe->stepCount() == 0) {
            errors.append({"steps", "至少需要一个步骤", "添加图像源步骤"});
        }

        // 3. 检查是否有图像源
        bool hasImageSource = false;
        for (int i = 0; i < recipe->stepCount(); ++i) {
            VisionTool* tool = recipe->step(i);
            if (isImageSourceTool(tool)) {
                hasImageSource = true;
                break;
            }
        }
        if (!hasImageSource) {
            errors.append({"steps", "缺少图像源", "添加相机或文件输入步骤"});
        }

        // 4. 检查步骤间连接
        // ...

        return errors;
    }

private:
    static bool isImageSourceTool(const VisionTool* tool);
};
```

### 9.2 数据完整性约束

| 字段 | 约束 | 验证规则 |
|------|------|---------|
| Recipe.metadata.name | NOT NULL, LENGTH > 0 | 1-100字符 |
| Recipe.metadata.version | >= 1 | 正整数 |
| CameraConfig.resolution.width | 64-8192 | 16的倍数 |
| CameraConfig.exposure | 10-1000000 | 微秒 |
| FindCircleParams.minRadius | > 0 | 像素 |
| AIDetectionParams.confidenceThreshold | 0.0-1.0 | 浮点数 |

---

## 10. 数据迁移与兼容性

### 10.1 版本兼容策略

```cpp
// ============================================================
// 配方文件版本管理
// ============================================================
class RecipeFileVersion {
public:
    static constexpr int CURRENT_VERSION = 1;

    // 加载配方时检查版本
    static Recipe* load(const QString& filePath) {
        QFile file(filePath);
        if (!file.open(QIODevice::ReadOnly)) {
            return nullptr;
        }

        QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
        QJsonObject json = doc.object();

        int fileVersion = json["fileVersion"].toInt(0);

        // 版本迁移
        if (fileVersion < CURRENT_VERSION) {
            json = migrate(json, fileVersion, CURRENT_VERSION);
        }

        Recipe* recipe = new Recipe();
        recipe->fromJson(json);
        return recipe;
    }

private:
    static QJsonObject migrate(QJsonObject json, int from, int to) {
        for (int ver = from; ver < to; ++ver) {
            json = migrateVersion(json, ver, ver + 1);
        }
        return json;
    }

    static QJsonObject migrateVersion(QJsonObject json, int from, int to) {
        if (from == 0 && to == 1) {
            // v0 -> v1 迁移逻辑
            // 例如：添加新字段、重命名字段等
            if (!json.contains("metadata")) {
                QJsonObject meta;
                meta["name"] = json["name"].toString();
                json["metadata"] = meta;
                json.remove("name");
            }
        }
        json["fileVersion"] = to;
        return json;
    }
};
```

---

**文档状态**: ✅ 已完成
**下一步**: 编写UI组件详细设计
