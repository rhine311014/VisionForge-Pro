# VisionForge Pro - 整体架构设计文档

## 文档信息

- **项目名称**: VisionForge Pro
- **文档版本**: v1.0
- **创建日期**: 2025-12-14
- **最后更新**: 2025-12-14 (v1.1 - 新增关键架构增强模块)
- **设计者**: VisionForge Team

---

## 1. 项目概述

### 1.1 项目目标

VisionForge Pro 是一款通用工业视觉检测平台，目标是：

- **极致易用性**: 5分钟快速上手（类Keyence体验）
- **算法先进性**: 集成最新AI技术 + 传统CV算法
- **性能极限**: 典型场景 <10ms，简单场景 <3ms
- **开放生态**: 支持二次开发和插件扩展

### 1.2 核心设计理念

```
设计哲学：
┌─────────────────────────────────────────────────────┐
│  "简单的事情简单做，复杂的事情也能做"                │
│                                                     │
│  新手模式：向导式，隐藏复杂性                        │
│     ↕                                               │
│  专家模式：完整功能，深度定制                        │
└─────────────────────────────────────────────────────┘
```

---

## 2. 六层架构设计

### 2.1 架构总览

```
┌──────────────────────────────────────────────────────────────┐
│                    应用层 (Presentation)                      │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ 简单模式UI          专业模式UI         配置向导         │  │
│  │ (SimpleMode)       (ProMode)          (Wizard)         │  │
│  └────────────────────────────────────────────────────────┘  │
├──────────────────────────────────────────────────────────────┤
│                   业务逻辑层 (Business)                       │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ 配方管理    任务调度    结果判定    故障诊断   权限管理  │  │
│  │ (Recipe)   (Schedule)  (Judge)     (Diag)     (Auth)   │  │
│  └────────────────────────────────────────────────────────┘  │
├──────────────────────────────────────────────────────────────┤
│                   算法服务层 (Algorithm)                      │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ 传统CV服务   AI推理服务   流程执行引擎   性能监控       │  │
│  │ (CVService) (AIService)   (Pipeline)    (Monitor)      │  │
│  └────────────────────────────────────────────────────────┘  │
├──────────────────────────────────────────────────────────────┤
│                  设备抽象层 (HAL - Hardware)                  │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ ICamera      ILight      IPLC       IMotion            │  │
│  │ (相机接口)   (光源接口)  (PLC接口)  (运动控制)          │  │
│  └────────────────────────────────────────────────────────┘  │
├──────────────────────────────────────────────────────────────┤
│                 基础设施层 (Infrastructure)                   │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ 内存池     日志系统    配置管理    线程池    通信框架   │  │
│  │ (MemPool) (Logger)    (Config)   (Thread)  (Comm)     │  │
│  └────────────────────────────────────────────────────────┘  │
├──────────────────────────────────────────────────────────────┤
│                  数据持久层 (Persistence)                     │
│  ┌────────────────────────────────────────────────────────┐  │
│  │ 配方数据库   审计日志    图像存储    统计数据           │  │
│  │ (RecipeDB) (AuditLog)  (ImageStore) (Statistics)      │  │
│  └────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────┘
```

### 2.2 层级职责定义

| 层级 | 职责 | 技术栈 |
|------|------|--------|
| **应用层** | UI交互、用户体验、界面渲染 | Qt 6.5 Widgets + QGraphicsView |
| **业务逻辑层** | 配方管理、任务编排、业务规则 | C++ 标准库 + Qt Core |
| **算法服务层** | 图像处理、AI推理、算法执行 | OpenCV 4.x + ONNX Runtime + TensorRT |
| **设备抽象层** | 硬件接口、驱动封装、模拟设备 | GenICam + 厂商SDK |
| **基础设施层** | 通用组件、系统服务、工具库 | Qt Core + Boost (可选) |
| **数据持久层** | 数据存储、日志记录、配置持久化 | SQLite + JSON + Protocol Buffers |

---

## 3. 核心模块设计

### 3.1 双模式UI架构

```
┌─────────────────────────────────────────────────────────────┐
│              MainWindow (主窗口控制器)                       │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  模式选择器: [简单模式 ▼]                              │  │
│  └───────────────────────────────────────────────────────┘  │
│                         │                                    │
│         ┌───────────────┴───────────────┐                   │
│         │                               │                   │
│    ┌────▼────────┐               ┌──────▼─────────┐         │
│    │ SimpleMode  │               │  ProfessionalMode│        │
│    │  Widget     │               │     Widget      │        │
│    └─────────────┘               └────────────────┘         │
│         │                               │                   │
│         │  共享组件                      │                   │
│         ├──────────────┬────────────────┤                   │
│         │              │                │                   │
│    ┌────▼────┐   ┌─────▼─────┐   ┌─────▼─────┐             │
│    │ImageView│   │StepList   │   │ParamPanel │             │
│    │图像显示  │   │步骤列表   │   │参数面板   │             │
│    └─────────┘   └───────────┘   └───────────┘             │
└─────────────────────────────────────────────────────────────┘
```

#### 3.1.1 简单模式 (SimpleMode)

**设计目标**: 5分钟上手，隐藏复杂性

**核心组件**:
- **StepListWidget**: 左侧步骤列表（单列、大图标）
- **ImageDisplayWidget**: 中间图像显示（大画面）
- **SimpleParamPanel**: 右侧简化参数面板（仅核心参数）
- **QuickToolSelector**: 工具选择器（图标式对话框）

**布局方式**:
```
┌───────────┬──────────────────┬───────────┐
│  步骤列表  │   图像显示区      │ 参数面板   │
│  (15%)    │     (55%)        │  (30%)    │
└───────────┴──────────────────┴───────────┘
```

#### 3.1.2 专业模式 (ProfessionalMode)

**设计目标**: 完整功能，深度定制

**核心组件**:
- **ProjectTreeWidget**: 左上项目树（多任务管理）
- **ToolboxWidget**: 左下工具箱（可拖拽）
- **TabbedWorkspace**: 中间多Tab工作区（图像/流程/数据/日志）
- **PropertyPanel**: 右侧完整属性面板（分组、可折叠）
- **StepNavigator**: 底部步骤导航条（快速跳转）

**布局方式**:
```
┌──────────┬────────────────────────────┬──────────┐
│ 项目树   │    工作区 (多Tab切换)       │  属性面板 │
│  (15%)   │  [图像|流程|数据|日志]      │  (25%)   │
│──────────│            (60%)           │          │
│ 工具箱   │                            │          │
│          │                            │          │
└──────────┴────────────────────────────┴──────────┘
```

### 3.2 模式切换机制

```cpp
// 伪代码
class ModeManager {
public:
    enum Mode { Simple, Professional };

    void switchMode(Mode mode) {
        // 1. 保存当前模式状态
        saveCurrentState();

        // 2. 切换UI布局
        if (mode == Simple) {
            showSimpleMode();
            hideAdvancedFeatures();
        } else {
            showProfessionalMode();
            showAdvancedFeatures();
        }

        // 3. 恢复数据（配方、步骤等保持一致）
        restoreData();
    }

private:
    // 核心数据层不变，只是UI表现形式不同
    SharedDataModel* dataModel;
};
```

---

## 4. 数据流架构

### 4.1 图像处理管道

```
┌────────┐     ┌────────┐     ┌────────┐     ┌────────┐
│ 相机   │────>│ 内存池 │────>│ 算法   │────>│ 结果   │
│ 采集   │     │ 缓冲   │     │ 处理   │     │ 输出   │
└────────┘     └────────┘     └────────┘     └────────┘
    │              │              │              │
    └──────────────┴──────────────┴──────────────┘
                   │
              性能监控 (每步耗时统计)
```

### 4.2 零拷贝机制

```cpp
// 图像数据在整个管道中使用共享指针，避免拷贝
class ImageData {
public:
    using Ptr = std::shared_ptr<ImageData>;

    cv::Mat mat;              // OpenCV矩阵（浅拷贝）
    void* devicePtr;          // GPU内存指针
    size_t timestamp;         // 时间戳

    // 禁止拷贝构造
    ImageData(const ImageData&) = delete;
    ImageData& operator=(const ImageData&) = delete;
};

// 步骤间传递使用智能指针
ImageData::Ptr image = std::make_shared<ImageData>();
step1->process(image);  // 输入
step2->process(image);  // 同一块内存，零拷贝
```

---

## 5. 配方（Recipe）架构

### 5.1 配方数据模型

```
Recipe (配方)
  ├─ Metadata (元数据)
  │   ├─ name: string
  │   ├─ version: int
  │   ├─ createdTime: timestamp
  │   ├─ modifiedTime: timestamp
  │   └─ author: string
  │
  ├─ CameraConfig (相机配置)
  │   ├─ deviceName: string
  │   ├─ resolution: Size
  │   ├─ exposure: double
  │   ├─ gain: double
  │   └─ triggerMode: enum
  │
  ├─ StepList (步骤列表)
  │   └─ Step[] (步骤数组)
  │       ├─ id: UUID
  │       ├─ type: enum (Gray/Blur/FindCircle...)
  │       ├─ enabled: bool
  │       ├─ params: JSON (步骤参数)
  │       └─ connections: {inputFrom, outputTo}
  │
  └─ JudgmentRules (判定规则)
      ├─ okCondition: Expression
      ├─ ngCondition: Expression
      └─ outputMapping: {OK→DO1, NG→DO2}
```

### 5.2 配方版本控制

```
RecipeVersionControl
  ├─ currentVersion: int
  ├─ versionHistory[]
  │   ├─ version: int
  │   ├─ timestamp: datetime
  │   ├─ author: string
  │   ├─ changeLog: string
  │   └─ recipeSnapshot: Recipe
  │
  ├─ diff(v1, v2) → Changes[]
  ├─ rollback(targetVersion)
  └─ export() → .vfproj 文件
```

---

## 6. 算法工具（Tool）架构

### 6.1 工具基类设计

```cpp
// 所有算法工具的抽象基类
class VisionTool : public QObject {
    Q_OBJECT

public:
    virtual ~VisionTool() = default;

    // 核心接口
    virtual bool process(const ImageData::Ptr& input,
                        ToolResult& output) = 0;

    virtual QString getToolName() const = 0;
    virtual QIcon getToolIcon() const = 0;
    virtual QWidget* getParamWidget() = 0;

    // 参数序列化
    virtual QJsonObject serializeParams() const = 0;
    virtual void deserializeParams(const QJsonObject& json) = 0;

    // 调试支持
    virtual ImageData::Ptr getDebugImage() const = 0;
    virtual QString getStatusText() const = 0;

signals:
    void paramChanged();
    void processingFinished(bool success);
    void debugImageUpdated();
};
```

### 6.2 工具分类

| 类别 | 工具示例 | 实现类 |
|------|---------|--------|
| **图像源** | 相机、文件、视频 | CameraTool, FileTool |
| **预处理** | 灰度、滤波、ROI | GrayTool, BlurTool, ROITool |
| **定位** | 模板匹配、找圆、边缘 | MatchTool, FindCircleTool |
| **AI检测** | YOLO、分类、分割 | YOLOTool, ClassifyTool |
| **测量** | 距离、角度、面积 | MeasureTool, CalcTool |
| **判定** | 范围判定、逻辑运算 | JudgeTool, LogicTool |
| **输出** | PLC通信、保存图像 | PLCTool, SaveTool |

---

## 7. 性能优化策略

### 7.1 内存管理

```cpp
// 预分配内存池（避免运行时malloc）
class ImageMemoryPool {
public:
    static ImageMemoryPool& instance();

    ImageData::Ptr allocate(const cv::Size& size, int type) {
        // 从池中分配或复用已有内存
        return pool_.get(size, type);
    }

    void release(ImageData::Ptr image) {
        // 归还池中，不真正释放
        pool_.put(image);
    }

private:
    MemoryPool pool_;
};
```

### 7.2 多线程流水线

```
线程模型：
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│ 线程1    │    │ 线程2    │    │ 线程3    │    │ 线程4    │
│ 图像采集 │───>│ 预处理   │───>│ 算法检测 │───>│ 结果输出 │
└──────────┘    └──────────┘    └──────────┘    └──────────┘
     │               │               │               │
     └───────────────┴───────────────┴───────────────┘
                      │
                 无锁队列通信
```

### 7.3 GPU加速策略

| 场景 | CPU实现 | GPU加速 | 性能提升 |
|------|---------|---------|---------|
| 图像滤波 | OpenCV CPU | CUDA滤波核 | 5-10x |
| AI推理 | ONNX Runtime CPU | TensorRT GPU | 10-50x |
| 几何变换 | OpenCV | OpenCL/CUDA | 3-8x |

---

## 8. 扩展性设计

### 8.1 插件系统架构（Phase 2）

```
PluginManager
  ├─ loadPlugin(path) → IVisionPlugin*
  ├─ unloadPlugin(pluginId)
  ├─ listPlugins() → PluginInfo[]
  └─ validatePlugin(plugin) → bool (安全检查)

IVisionPlugin 接口
  ├─ getPluginInfo() → {name, version, author}
  ├─ initialize(context)
  ├─ createTool() → VisionTool*
  └─ cleanup()
```

### 8.2 二次开发SDK

提供的API层级：
1. **Level 1**: 使用现有工具组合（配置文件）
2. **Level 2**: 编写自定义工具（继承VisionTool）
3. **Level 3**: 深度集成（访问底层HAL）

---

## 9. 非功能性需求

### 9.1 性能指标

| 指标 | 目标值 | 测试方法 |
|------|--------|---------|
| 界面响应时间 | <50ms | 点击到显示的延迟 |
| 图像显示帧率 | >30 FPS | 连续采集显示流畅度 |
| 典型检测耗时 | <10ms | 8-10个步骤的完整流程 |
| 简单检测耗时 | <3ms | 2-3个步骤的基础检测 |
| 配方加载时间 | <1s | 从文件加载到可运行 |
| 内存占用 | <500MB | 空载 + 1个任务运行 |

### 9.2 稳定性指标

| 指标 | 目标值 |
|------|--------|
| 连续运行时长 | >72小时不崩溃 |
| 内存泄漏率 | <1MB/小时 |
| 崩溃率 | <0.01% (每10,000次操作) |

### 9.3 兼容性

| 维度 | 支持范围 |
|------|---------|
| 操作系统 | Windows 10/11 LTSC, Ubuntu 20.04+ |
| 分辨率 | 1366x768 ~ 4K (自适应缩放) |
| 相机接口 | GenICam (GigE/USB3) |
| CPU架构 | x64 (Phase 1), ARM64 (Phase 2) |

---

## 10. 安全与合规

### 10.1 用户权限系统

```
UserRole
  ├─ Operator (操作员)
  │   ├─ 运行配方
  │   ├─ 查看结果
  │   └─ ✗ 不能修改配方
  │
  ├─ Engineer (工程师)
  │   ├─ 修改配方
  │   ├─ 创建新任务
  │   └─ 查看日志
  │
  └─ Administrator (管理员)
      ├─ 用户管理
      ├─ 系统配置
      └─ 审计日志查看
```

### 10.2 审计日志

记录内容：
- 用户登录/登出
- 配方修改（修改前后对比）
- 系统参数变更
- 关键错误事件

格式：符合 ISO 8601 时间戳 + JSON结构化数据

---

## 11. 开发路线图

### Phase 1: MVP (9个月)

| 月份 | 里程碑 | 交付物 |
|------|--------|--------|
| M1-M3 | 技术验证 | 基础框架 + HAL + 单相机Demo |
| M4-M6 | Alpha版 | 简单模式 + 8-10个工具 + 业务逻辑层 |
| M7-M9 | Beta版 | 专业模式 + 故障诊断 + 1个行业模板 |

### Phase 2: 增强版 (+6个月)

- 多相机同步
- AI模型集成（TensorRT）
- 3个行业模板
- 高级统计分析

### Phase 3: 生态版 (+6个月)

- 插件SDK
- 插件市场
- 云端协同
- 移动端监控

---

## 12. 关键架构增强模块

### 12.1 全局标定与坐标系管理

#### 12.1.1 设计目标

在工业视觉检测中，相机坐标系、世界坐标系、机械坐标系之间的转换是核心功能。VisionForge Pro需要提供完善的标定与坐标系管理能力。

#### 12.1.2 标定方式支持

```
CalibrationManager
  ├─ 9点标定 (Nine-Point Calibration)
  │   └─ 适用场景：平面物体，简单映射
  │
  ├─ 棋盘格标定 (Chessboard Calibration)
  │   └─ 适用场景：精确内参标定，畸变校正
  │
  ├─ 圆点标定板 (Circle Grid Calibration)
  │   └─ 适用场景：高精度亚像素定位
  │
  └─ N点标定 (N-Point Calibration)
      └─ 适用场景：任意点数，最小二乘拟合
```

#### 12.1.3 坐标系架构

```cpp
// 坐标系类型
enum CoordinateSystem {
    ImageCS,       // 图像坐标系 (pixel)
    CameraCS,      // 相机坐标系 (mm)
    WorldCS,       // 世界坐标系 (mm)
    RobotCS        // 机械臂坐标系 (mm)
};

// 坐标变换矩阵
struct CoordinateTransform {
    cv::Mat homography;        // 2D单应性矩阵 (3x3)
    cv::Mat rotationMatrix;    // 3D旋转矩阵 (3x3)
    cv::Mat translationVec;    // 3D平移向量 (3x1)
    double scaleX, scaleY;     // XY缩放比例 (mm/pixel)

    // 坐标转换方法
    cv::Point2d transform(const cv::Point2d& srcPoint) const;
    cv::Point3d transform3D(const cv::Point3d& srcPoint) const;
};

// CalibrationManager 单例
class CalibrationManager {
public:
    // 执行标定
    bool calibrate9Point(const std::vector<cv::Point2d>& imagePoints,
                        const std::vector<cv::Point2d>& worldPoints);

    bool calibrateChessboard(const std::vector<cv::Mat>& images,
                            const cv::Size& patternSize,
                            double squareSize);

    // 获取变换矩阵
    CoordinateTransform getTransform(CoordinateSystem from,
                                     CoordinateSystem to) const;

    // 应用变换
    cv::Point2d transformPoint(const cv::Point2d& pt,
                              CoordinateSystem from,
                              CoordinateSystem to) const;

    // 保存/加载标定文件
    bool saveCalibration(const QString& filePath);
    bool loadCalibration(const QString& filePath);

    // 标定精度评估
    double getReprojectionError() const;
};
```

#### 12.1.4 ImageData增强

为支持空间信息，ImageData需要添加坐标系关联：

```cpp
class ImageData {
public:
    // ... 原有成员 ...

    // 新增：坐标系信息
    CoordinateSystem coordinateSystem_;
    CoordinateTransform transform_;

    // 带坐标系的点转换
    cv::Point2d toWorldCoordinate(const cv::Point2d& imagePoint) const {
        return transform_.transform(imagePoint);
    }
};
```

---

### 12.2 高频数据持久化性能优化

#### 12.2.1 性能瓶颈分析

典型工业场景中，检测频率可能达到**100次/秒**，如果每次检测都实时写入数据库：
- SQLite同步写入：~10-50ms/次 → **严重瓶颈！**
- 磁盘IO成为限制因素

#### 12.2.2 异步批量写入架构

```
检测流程                  数据持久化流程
┌──────────┐             ┌──────────────┐
│ 检测完成  │────────────>│ ResultQueue  │
│          │  内存入队    │ (无锁队列)   │
└──────────┘             └──────┬───────┘
                                │
                                │ 后台线程批量取出
                                ▼
                         ┌──────────────┐
                         │ BatchWriter  │
                         │ (累积100条或  │
                         │  500ms超时)  │
                         └──────┬───────┘
                                │
                                │ 批量事务写入
                                ▼
                         ┌──────────────┐
                         │  SQLite DB   │
                         └──────────────┘
```

#### 12.2.3 实现方案

```cpp
// 结果队列（无锁环形缓冲区）
class ResultQueue {
public:
    static constexpr size_t QUEUE_SIZE = 10000;

    bool push(const InspectionResult& result);  // 生产者
    bool pop(InspectionResult& result);         // 消费者

    size_t size() const;
    bool isEmpty() const;
    bool isFull() const;

private:
    std::array<InspectionResult, QUEUE_SIZE> buffer_;
    std::atomic<size_t> writeIndex_{0};
    std::atomic<size_t> readIndex_{0};
};

// 批量写入器
class AsyncResultWriter : public QThread {
    Q_OBJECT
public:
    static AsyncResultWriter& instance();

    void enqueue(const InspectionResult& result) {
        queue_.push(result);
    }

protected:
    void run() override {
        while (!stopFlag_) {
            // 1. 累积结果
            std::vector<InspectionResult> batch;
            batch.reserve(100);

            auto startTime = std::chrono::steady_clock::now();
            while (batch.size() < 100) {
                InspectionResult result;
                if (queue_.pop(result)) {
                    batch.push_back(result);
                }

                // 超时检查（500ms）
                auto elapsed = std::chrono::steady_clock::now() - startTime;
                if (elapsed > std::chrono::milliseconds(500)) {
                    break;
                }
            }

            // 2. 批量写入数据库
            if (!batch.empty()) {
                writeBatch(batch);
            }

            QThread::msleep(10);  // 避免空转
        }
    }

private:
    void writeBatch(const std::vector<InspectionResult>& batch) {
        QSqlDatabase db = QSqlDatabase::database();
        db.transaction();  // 开启事务

        for (const auto& result : batch) {
            // INSERT INTO ...
        }

        db.commit();  // 批量提交
    }

private:
    ResultQueue queue_;
    std::atomic<bool> stopFlag_{false};
};
```

#### 12.2.4 分层日志策略

```cpp
// 生产模式：仅记录关键信息
class ProductionLogger {
public:
    void logResult(const InspectionResult& result) {
        // 仅记录：时间戳、OK/NG、总耗时
        // 不记录中间步骤、不记录调试信息
    }
};

// 调试模式：记录完整信息
class DebugLogger {
public:
    void logResult(const InspectionResult& result) {
        // 记录：所有步骤详情、中间图像、参数快照
    }
};
```

---

### 12.3 增强的逻辑控制系统

#### 12.3.1 现有表达式引擎的局限

当前设计的`ExpressionParser`仅支持简单的布尔表达式，例如：
```
"step1.diameter > 50 && step2.area < 1000"
```

但工业现场常需要复杂逻辑：
- **条件分支**："如果找到圆，则测量直径；否则跳过后续步骤"
- **循环处理**："对检测到的所有Blob逐个判定"
- **动态参数**："根据第一次检测结果动态调整第二次检测的ROI"

#### 12.3.2 嵌入式脚本引擎

集成轻量级脚本引擎（选择Lua或JavaScript）：

**方案A: Lua引擎**
```cpp
#include <lua.hpp>

class LuaScriptEngine {
public:
    bool executeScript(const QString& script,
                      const InspectionResult& result,
                      bool& ok) {
        lua_State* L = luaL_newstate();
        luaL_openlibs(L);

        // 注入结果数据到Lua环境
        lua_newtable(L);
        for (int i = 0; i < result.stepResults.size(); ++i) {
            lua_pushinteger(L, i + 1);
            // ... 填充step数据
            lua_settable(L, -3);
        }
        lua_setglobal(L, "result");

        // 执行脚本
        int ret = luaL_dostring(L, script.toUtf8().constData());
        if (ret == LUA_OK) {
            lua_getglobal(L, "ok");
            ok = lua_toboolean(L, -1);
            lua_close(L);
            return true;
        }

        lua_close(L);
        return false;
    }
};
```

**Lua脚本示例**：
```lua
-- 复杂判定逻辑
if result[1].circleFound then
    diameter = result[1].diameter
    if diameter > 50 and diameter < 60 then
        ok = true
    else
        ok = false
    end
else
    -- 未找到圆，检查plan B
    if result[2].blobCount > 5 then
        ok = true
    else
        ok = false
    end
end
```

**方案B: JavaScript引擎 (Qt内置 QJSEngine)**
```cpp
#include <QJSEngine>

class JavaScriptEngine {
public:
    bool executeScript(const QString& script,
                      const InspectionResult& result,
                      bool& ok) {
        QJSEngine engine;

        // 注入result对象
        QJSValue resultObj = engine.newObject();
        for (int i = 0; i < result.stepResults.size(); ++i) {
            QJSValue step = engine.newObject();
            step.setProperty("toolType", result.stepResults[i].toolType);
            step.setProperty("success", result.stepResults[i].success);
            // ... 其他属性
            resultObj.setProperty(i, step);
        }
        engine.globalObject().setProperty("result", resultObj);

        // 执行脚本
        QJSValue ret = engine.evaluate(script);
        if (!ret.isError()) {
            ok = engine.globalObject().property("ok").toBool();
            return true;
        }

        return false;
    }
};
```

**JavaScript脚本示例**：
```javascript
// 动态参数绑定
if (result[0].circleFound) {
    // 找到圆后，使用圆心作为下一步的ROI中心
    var cx = result[0].centerX;
    var cy = result[0].centerY;

    // 设置step2的ROI（需要引擎支持反向修改配方参数）
    setStepParam(2, "roi", {x: cx - 50, y: cy - 50, w: 100, h: 100});
}
```

#### 12.3.3 高级表达式计算器

如果不使用脚本引擎，增强现有的`ExpressionParser`：

```cpp
class AdvancedExpressionParser {
public:
    // 支持的运算符
    // 算术: +, -, *, /, %, ^
    // 比较: ==, !=, >, <, >=, <=
    // 逻辑: &&, ||, !
    // 函数: abs(), sqrt(), min(), max(), avg()

    bool evaluate(const QString& expression,
                 const QJsonObject& context,
                 QVariant& result);

private:
    // 词法分析
    QList<Token> tokenize(const QString& expr);

    // 语法分析（递归下降）
    ASTNode* parse(const QList<Token>& tokens);

    // 求值
    QVariant evaluate(ASTNode* node, const QJsonObject& context);
};
```

**示例表达式**：
```
"avg(step1.area, step2.area, step3.area) > 500 &&
 abs(step1.angle - step2.angle) < 5"
```

---

### 12.4 HAL异常恢复机制

#### 12.4.1 设备状态监控

```cpp
class ICamera {
    // ... 原有接口 ...

    // 新增：健康检查
    virtual bool isHealthy() const = 0;
    virtual int getHeartbeatInterval() const { return 1000; }  // ms

    // 新增：异常通知
signals:
    void deviceLost();         // 设备丢失
    void deviceRecovered();    // 设备恢复
    void heartbeatTimeout();   // 心跳超时
};
```

#### 12.4.2 自动重连策略

```cpp
// 重试策略配置
struct RetryPolicy {
    int maxRetries = 3;           // 最大重试次数
    int retryInterval = 1000;     // 重试间隔(ms)
    bool exponentialBackoff = true; // 指数退避

    int getRetryDelay(int attemptCount) const {
        if (!exponentialBackoff) {
            return retryInterval;
        }
        return retryInterval * std::pow(2, attemptCount - 1);
    }
};

// 设备管理器
class DeviceManager : public QObject {
    Q_OBJECT
public:
    static DeviceManager& instance();

    // 注册设备
    void registerDevice(const QString& deviceId, ICamera* camera);
    void registerDevice(const QString& deviceId, IPLC* plc);

    // 健康检查线程
    void startMonitoring();
    void stopMonitoring();

    // 设置重连策略
    void setRetryPolicy(const QString& deviceId, const RetryPolicy& policy);

signals:
    void deviceStatusChanged(const QString& deviceId, bool online);

private slots:
    void onHeartbeatCheck();
    void onDeviceLost(const QString& deviceId);

private:
    void attemptReconnect(const QString& deviceId);

private:
    struct DeviceInfo {
        QObject* device;           // ICamera* 或 IPLC*
        RetryPolicy retryPolicy;
        int failedAttempts;
        QDateTime lastHeartbeat;
        bool isOnline;
    };

    QMap<QString, DeviceInfo> devices_;
    QTimer* heartbeatTimer_;
};
```

#### 12.4.3 心跳监控线程

```cpp
void DeviceManager::onHeartbeatCheck() {
    auto now = QDateTime::currentDateTime();

    for (auto it = devices_.begin(); it != devices_.end(); ++it) {
        const QString& deviceId = it.key();
        DeviceInfo& info = it.value();

        // 检查心跳超时
        qint64 elapsed = info.lastHeartbeat.msecsTo(now);
        ICamera* camera = qobject_cast<ICamera*>(info.device);

        if (camera) {
            if (elapsed > camera->getHeartbeatInterval() * 2) {
                // 心跳超时
                if (info.isOnline) {
                    info.isOnline = false;
                    emit deviceStatusChanged(deviceId, false);
                    onDeviceLost(deviceId);
                }
            } else {
                // 心跳正常
                if (!info.isOnline) {
                    info.isOnline = true;
                    info.failedAttempts = 0;
                    emit deviceStatusChanged(deviceId, true);
                }
            }
        }
    }
}

void DeviceManager::attemptReconnect(const QString& deviceId) {
    DeviceInfo& info = devices_[deviceId];

    if (info.failedAttempts >= info.retryPolicy.maxRetries) {
        LOG_ERROR(QString("设备 %1 重连失败，已达最大重试次数").arg(deviceId));
        return;
    }

    info.failedAttempts++;
    int delay = info.retryPolicy.getRetryDelay(info.failedAttempts);

    LOG_INFO(QString("设备 %1 尝试重连 (%2/%3)，延迟 %4ms")
        .arg(deviceId)
        .arg(info.failedAttempts)
        .arg(info.retryPolicy.maxRetries)
        .arg(delay));

    QTimer::singleShot(delay, this, [this, deviceId]() {
        ICamera* camera = qobject_cast<ICamera*>(devices_[deviceId].device);
        if (camera) {
            if (camera->open()) {
                LOG_INFO(QString("设备 %1 重连成功").arg(deviceId));
                devices_[deviceId].isOnline = true;
                devices_[deviceId].failedAttempts = 0;
                emit deviceStatusChanged(deviceId, true);
            } else {
                attemptReconnect(deviceId);  // 递归重试
            }
        }
    });
}
```

#### 12.4.4 热插拔支持

```cpp
// 设备枚举器（监听USB/GigE设备变化）
class DeviceEnumerator : public QObject {
    Q_OBJECT
public:
    void startMonitoring();

signals:
    void deviceArrived(const QString& deviceId);
    void deviceRemoved(const QString& deviceId);

private:
    // Windows: 监听WM_DEVICECHANGE消息
    // Linux: 监听udev事件
};
```

---

### 12.5 UI与核心逻辑深度解耦

#### 12.5.1 问题场景

当前设计中，用户可以在检测运行时修改参数：
```
用户界面                    执行引擎
  │                           │
  ├─ 修改step2.threshold ─────> recipe.step(2).params.threshold = 新值
  │                           │
  │                           ├─ step1.process() ✓
  │                           ├─ step2.process()  ← 使用了新值！❌
  │                           └─ step3.process()
```

**风险**：运行中的检测使用了修改后的参数，导致结果不一致。

#### 12.5.2 参数快照机制

```cpp
class PipelineExecutor {
public:
    bool execute(ImageData::Ptr input, InspectionResult& output) {
        // 1. 执行前深拷贝所有步骤参数
        QList<QJsonObject> paramSnapshot;
        for (auto* tool : steps_) {
            paramSnapshot.append(tool->serializeParams());
        }

        // 2. 执行流程（使用快照参数）
        for (int i = 0; i < steps_.size(); ++i) {
            VisionTool* tool = steps_[i];

            // 临时应用快照参数
            QJsonObject originalParams = tool->serializeParams();
            tool->deserializeParams(paramSnapshot[i]);

            // 执行
            ToolResult result;
            tool->process(input, result);

            // 恢复原参数（可选，取决于设计）
            // tool->deserializeParams(originalParams);
        }

        return true;
    }
};
```

#### 12.5.3 版本号机制

```cpp
class Recipe {
public:
    // 每次修改参数时递增版本号
    void setStepParam(int stepIndex, const QJsonObject& params) {
        steps_[stepIndex]->deserializeParams(params);
        ++paramVersion_;
        emit paramsModified(paramVersion_);
    }

    int getParamVersion() const { return paramVersion_; }

private:
    std::atomic<int> paramVersion_{0};
};

class PipelineExecutor {
public:
    bool execute(ImageData::Ptr input, InspectionResult& output) {
        int currentVersion = recipe_->getParamVersion();

        // 检查版本是否变化
        if (currentVersion != cachedVersion_) {
            LOG_WARNING("参数已变化，重新缓存快照");
            updateParamSnapshot();
            cachedVersion_ = currentVersion;
        }

        // 使用缓存的快照执行
        executeWithSnapshot(input, output);
        return true;
    }

private:
    void updateParamSnapshot() {
        paramSnapshot_.clear();
        for (auto* tool : steps_) {
            paramSnapshot_.append(tool->serializeParams());
        }
    }

private:
    int cachedVersion_{-1};
    QList<QJsonObject> paramSnapshot_;
};
```

#### 12.5.4 UI锁定机制

```cpp
class TaskScheduler {
public:
    void start() {
        isRunning_ = true;
        emit recipeLockedForRunning(true);  // 通知UI锁定配方
        runPipeline();
    }

    void stop() {
        isRunning_ = false;
        emit recipeLockedForRunning(false);  // 通知UI解锁
    }

signals:
    void recipeLockedForRunning(bool locked);
};

// UI响应
void SimpleParamPanel::onRecipeLocked(bool locked) {
    // 运行时禁用所有参数控件
    setEnabled(!locked);

    if (locked) {
        statusLabel_->setText("运行中，参数已锁定");
    }
}
```

---

### 12.6 多线程模型详细设计

#### 12.6.1 线程架构

```
┌────────────────────────────────────────────────────────┐
│                    主线程 (UI Thread)                   │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Qt事件循环、UI渲染、用户交互                     │  │
│  └──────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────┘
         │
         ├─> Signal/Slot 跨线程通信
         ▼
┌────────────────────────────────────────────────────────┐
│                 采集线程 (Grab Thread)                  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  相机图像采集、硬件触发响应                       │  │
│  │  CPU亲和性: Core 0                                │  │
│  └──────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────┘
         │
         ├─> 无锁队列 (Lock-Free Queue)
         ▼
┌────────────────────────────────────────────────────────┐
│            处理线程池 (Processing Thread Pool)          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐            │
│  │ Worker 1 │  │ Worker 2 │  │ Worker 3 │  ...       │
│  │ Core 1   │  │ Core 2   │  │ Core 3   │            │
│  └──────────┘  └──────────┘  └──────────┘            │
│  执行图像处理算法、AI推理                              │
└────────────────────────────────────────────────────────┘
         │
         ├─> 无锁队列
         ▼
┌────────────────────────────────────────────────────────┐
│               IO线程 (Background IO Thread)             │
│  ┌──────────────────────────────────────────────────┐  │
│  │  数据库写入、日志记录、图像保存                   │  │
│  │  低优先级，避免影响实时性                         │  │
│  └──────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────┘
```

#### 12.6.2 CPU核心绑定 (Core Affinity)

```cpp
#include <thread>
#include <pthread.h>  // Linux
#include <windows.h>  // Windows

class ThreadAffinityHelper {
public:
    // 绑定线程到指定CPU核心
    static bool setAffinity(std::thread& thread, int coreId) {
#ifdef _WIN32
        DWORD_PTR mask = 1ULL << coreId;
        DWORD_PTR result = SetThreadAffinityMask(thread.native_handle(), mask);
        return result != 0;
#else
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        CPU_SET(coreId, &cpuset);
        return pthread_setaffinity_np(thread.native_handle(),
                                      sizeof(cpu_set_t), &cpuset) == 0;
#endif
    }

    // 设置线程优先级
    static bool setPriority(std::thread& thread, int priority) {
#ifdef _WIN32
        // priority: THREAD_PRIORITY_TIME_CRITICAL, THREAD_PRIORITY_HIGHEST, etc.
        return SetThreadPriority(thread.native_handle(), priority);
#else
        struct sched_param param;
        param.sched_priority = priority;
        return pthread_setschedparam(thread.native_handle(),
                                     SCHED_FIFO, &param) == 0;
#endif
    }
};
```

#### 12.6.3 处理线程池实现

```cpp
class ProcessingThreadPool {
public:
    static ProcessingThreadPool& instance();

    void initialize(int threadCount = -1) {
        if (threadCount < 0) {
            threadCount = std::thread::hardware_concurrency() - 2;  // 预留UI和采集线程
        }

        for (int i = 0; i < threadCount; ++i) {
            workers_.emplace_back([this, i]() {
                workerThread(i);
            });

            // 绑定到物理核心（避开超线程）
            ThreadAffinityHelper::setAffinity(workers_.back(), i + 1);
            ThreadAffinityHelper::setPriority(workers_.back(),
                                             THREAD_PRIORITY_HIGHEST);
        }
    }

    // 提交任务
    std::future<InspectionResult> submit(
        std::function<InspectionResult()> task) {

        auto packagedTask = std::make_shared<std::packaged_task<InspectionResult()>>(task);
        auto future = packagedTask->get_future();

        {
            std::unique_lock<std::mutex> lock(queueMutex_);
            taskQueue_.emplace([packagedTask]() { (*packagedTask)(); });
        }
        condition_.notify_one();

        return future;
    }

private:
    void workerThread(int workerId) {
        while (!stopFlag_) {
            std::function<void()> task;

            {
                std::unique_lock<std::mutex> lock(queueMutex_);
                condition_.wait(lock, [this] {
                    return stopFlag_ || !taskQueue_.empty();
                });

                if (stopFlag_ && taskQueue_.empty()) {
                    return;
                }

                task = std::move(taskQueue_.front());
                taskQueue_.pop();
            }

            task();  // 执行任务
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> taskQueue_;
    std::mutex queueMutex_;
    std::condition_variable condition_;
    std::atomic<bool> stopFlag_{false};
};
```

#### 12.6.4 避免线程抖动

```cpp
// 采集线程专用CPU核心（避免上下文切换）
class GrabThread : public QThread {
public:
    void run() override {
        // 绑定到Core 0
        ThreadAffinityHelper::setAffinity(*reinterpret_cast<std::thread*>(this), 0);
        ThreadAffinityHelper::setPriority(*reinterpret_cast<std::thread*>(this),
                                         THREAD_PRIORITY_TIME_CRITICAL);

        while (!stopFlag_) {
            ImageData::Ptr image = camera_->grabImage(1000);
            if (image) {
                imageQueue_.push(image);  // 无锁队列
            }
        }
    }
};

// 处理线程独占CPU核心（1, 2, 3, ...）
// IO线程低优先级（允许被抢占）
```

#### 12.6.5 实时性保证

```cpp
class TaskScheduler {
public:
    void setRealTimeMode(bool enabled) {
        if (enabled) {
            // 1. 禁用所有非关键线程
            AsyncResultWriter::instance().pause();

            // 2. 提升处理线程优先级
            ProcessingThreadPool::instance().setHighPriority();

            // 3. 预热内存池（避免运行时分配）
            ImageMemoryPool::instance().preallocate(10);

            // 4. 锁定内存（避免swap）
#ifdef _WIN32
            SetProcessWorkingSetSize(GetCurrentProcess(),
                                    (SIZE_T)-1, (SIZE_T)-1);
#endif
        }
    }
};
```

---

## 13. 风险评估

| 风险 | 等级 | 缓解措施 |
|------|------|---------|
| Qt 6性能问题 | 中 | 提前性能测试，必要时降级Qt 5 |
| GenICam覆盖不足 | 中 | 预留私有驱动接口 |
| AI推理性能不达标 | 高 | 早期验证TensorRT，准备降级方案 |
| 团队规模不足 | 高 | 精简MVP范围，聚焦核心功能 |
| 第三方库许可证 | 中 | 法务审查，避免GPL污染 |

---

## 14. 术语表

| 术语 | 英文 | 说明 |
|------|------|------|
| 配方 | Recipe | 完整的检测任务配置（相机+步骤+判定） |
| 步骤 | Step | 单个图像处理工具的实例 |
| 工具 | Tool | 算法功能的抽象（如找圆、测距） |
| HAL | Hardware Abstraction Layer | 硬件抽象层 |
| ROI | Region of Interest | 感兴趣区域 |
| PLC | Programmable Logic Controller | 可编程逻辑控制器 |
| GenICam | Generic Interface for Cameras | 通用相机接口标准 |

---

## 15. 参考资料

- Qt 6 Documentation: https://doc.qt.io/qt-6/
- OpenCV 4 Documentation: https://docs.opencv.org/4.x/
- ONNX Runtime: https://onnxruntime.ai/docs/
- GenICam Standard: https://www.emva.org/standards-technology/genicam/

---

**文档状态**: ✅ 已完成
**审核状态**: 待审核
**下一步**: 编写详细类图设计
