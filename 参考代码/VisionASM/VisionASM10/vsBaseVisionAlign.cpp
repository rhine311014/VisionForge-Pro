// svVisionASM.cpp: implementation of the scVisionASM class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VisionASM.h"
#include "vsBaseVisionAlign.h"
#include "vsAlignToolDef.h"
#include "LightController.h"

#include "vsSerialComm.h"
#include "vsSocketComm.h"
#include "DlgSearchFailWarning.h"
#include "DlgManualSearch.h"
#include "DlgManualSearchCalib.h"
#include "svTimer.h"

#include "VisionASMDlg.h"
#include "DlgVisionView2.h"
#include "svVDB.h"
#include <algorithm>
#include <fstream>
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


CRITICAL_SECTION                vcBaseVisionAlign::m_gManualSearchSection;



//加载模板线程
DWORD WINAPI vcBaseVisionAlign::InitSearchToolRepositoryThread(LPVOID lpParam)
{
	CInitSearchToolThreadParam* pThreadParam = (CInitSearchToolThreadParam*)lpParam;
	CString strPatternDir;					//模板根目录路径
	CBaseSearchTool* pBaseSearchTool;		//声明工具
	for (int i=0;i<pThreadParam->m_nCandidateModelsNum;i++)
	{
		if (!pThreadParam->m_vbSearchToolChanged.at(i))
		{
			continue;
		}
		strPatternDir.Format(_T("\\Pos%d_M%d"),pThreadParam->m_nPosIndex, i);
		strPatternDir = pThreadParam->m_strPatternsDir + strPatternDir;

		// 从XML文件中获取定位工具类型
		CSearchToolType cSearchToolType = CBaseSearchTool::GetSearchToolTypeFromFile(strPatternDir);
		// 根据定位工具类型创建定位工具
		pBaseSearchTool = NULL;
		pThreadParam->SetSearchToolInitResult(pThreadParam->m_pBaseVisionAlign->CreateSearchTool(cSearchToolType, &pBaseSearchTool),i);
		if (!pThreadParam->GetSearchToolInitResult(i))
		{
			continue;
		}

		// 加载定位模板
		if ((NULL == pBaseSearchTool) || (FALSE == pBaseSearchTool->LoadModelFromFile(strPatternDir)))
		{
			if (pBaseSearchTool!=NULL)
			{
				delete pBaseSearchTool;
				pBaseSearchTool = NULL;
			}
			pThreadParam->SetSearchToolInitResult(false ,i);
			continue;
		}
		pThreadParam->SetSearchToolInitResult(true ,i);
		pThreadParam->m_vpAlnSearchToolRepo[i] = pBaseSearchTool;
	}
	pThreadParam->SetIsInitTimeOut(false);//当前线程运行完成，未超时
	return 0;
}

//保存模板线程
DWORD WINAPI vcBaseVisionAlign::SaveSearchToolRepositoryThread(LPVOID lpParam)
{
	CSaveSearchToolRepositoryThreadParam* pThreadParam = (CSaveSearchToolRepositoryThreadParam*)lpParam;
	CString strPatternDir;					//模板根目录路径
	CBaseSearchTool* pBaseSearchTool;		//声明工具

	if(pThreadParam ==NULL)
	{
		return 0;
	}
	for (int i=0;i<pThreadParam->m_vpSearchTool.size();i++)
	{
		// 判断工具是否被修改改变，初始化状态都是未改变
		if(!pThreadParam->m_vbSearchToolChanged[i])
		{
			continue;
		}
		strPatternDir.Format(_T("\\Pos%d_M%d"), pThreadParam->m_nPosIndex, i);
		strPatternDir = pThreadParam->m_strPatternsDir + strPatternDir;
		pBaseSearchTool = pThreadParam->m_vpSearchTool[i];//获取工具
		// 保存定位模板
		if ((NULL != pBaseSearchTool))
		{
			bool btmp = true;
			btmp = pBaseSearchTool->SaveModelToFile(strPatternDir);
			pThreadParam->SetSearchToolSaveResult(btmp,i);
			btmp = pThreadParam->GetAllSearchToolSaveResult() && btmp;
			pThreadParam->SetAllSearchToolSaveResult(btmp);
		}
		else
		{
			RemoveDirectoryPro(strPatternDir);
			/* pThreadParam->m_vbOK[i] = CBaseSearchTool::SaveSearchToolTypeToFile(strPatternDir);
			pThreadParam->m_bAllOK = pThreadParam->m_bAllOK &&pThreadParam->m_vbOK[i];*/
		}
	}
	pThreadParam->SetIsSaveTimeOut(false);//当前线程运行完成，未超时
	return 0;
}

void VCRemoveFile(CString strFilePath)
{
	CFileStatus fs;
	CFile::GetStatus(strFilePath,fs);
	if (fs.m_size > 50000000)//1048576)
	{
		::DeleteFile(strFilePath);
	}
}

BOOL CImageFormatTransfer::Read(CString strFilePath, scImageGray& image,CImageType eImageType/* = eBmp*/)
{
	switch(eImageType)
	{
	case eBmp:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.GetImage(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	case eJpeg:
		{
			scJpeg cJpeg;
			return cJpeg.Read(strFilePath,image);
		}
		break;
	case ePng:
		{
			scPng cPng;
			return cPng.Read(strFilePath,image);
		}
		break;
	default:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.GetImage(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	}
	return TRUE;
}

BOOL CImageFormatTransfer::Read(CString strFilePath, scImageRGB& image,CImageType eImageType /*= eBmp*/)
{
	switch(eImageType)
	{
	case eBmp:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.GetImage(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	case eJpeg:
		{
			scJpeg cJpeg;
			return cJpeg.Read(strFilePath,image);
		}
		break;
	case ePng:
		{
			scPng cPng;
			return cPng.Read(strFilePath,image);
		}
		break;
	default:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.GetImage(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	}
	return TRUE;
}

BOOL CImageFormatTransfer::Read(CString strFilePath, cpImage& image,CImageType eImageType /*= eBmp*/)
{
	switch(eImageType)
	{
	case eBmp:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.GetImage(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	case eJpeg:
		{
			scJpeg cJpeg;
			return cJpeg.Read(strFilePath,image);
		}
		break;
	case ePng:
		{
			scPng cPng;
			return cPng.Read(strFilePath,image);
		}
		break;
	default:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.GetImage(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	}
	return TRUE;
}

BOOL CImageFormatTransfer::Write(CString strFilePath, const scImageGray& image,CImageType eImageType/* = eBmp*/,int nQuality /*= 100*/)
{
	switch(eImageType)
	{
	case eBmp:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.Write(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	case eJpeg:
		{
			scJpeg cJpeg;
			return cJpeg.Write(strFilePath,image,nQuality);
		}
		break;
	case ePng:
		{
			scPng cPng;
			return cPng.Write(strFilePath,image);
		}
		break;
	default:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.Write(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	}
	return TRUE;
}

BOOL CImageFormatTransfer::Write(CString strFilePath, const scImageRGB& image,CImageType eImageType/* = eBmp*/,int nQuality /*= 100*/)
{
	switch(eImageType)
	{
	case eBmp:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.Write(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	case eJpeg:
		{
			scJpeg cJpeg;
			return cJpeg.Write(strFilePath,image,nQuality);
		}
		break;
	case ePng:
		{
			scPng cPng;
			return cPng.Write(strFilePath,image);
		}
		break;
	default:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.Write(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	}
	return TRUE;
}

BOOL CImageFormatTransfer::Write(CString strFilePath, cpImage& image,CImageType eImageType/* = eBmp*/,int nQuality/* = 100*/)
{
	switch(eImageType)
	{
	case eBmp:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.Write(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	case eJpeg:
		{
			scJpeg cJpeg;
			return cJpeg.Write(strFilePath,image,nQuality);
		}
		break;
	case ePng:
		{
			scPng cPng;
			return cPng.Write(strFilePath,image);
		}
		break;
	default:
		{
			scDIB cDib;
			HStatus hStatus;
			hStatus = cDib.Init(image);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
			hStatus = cDib.Write(strFilePath);
			if (!IsSuccess(hStatus))
			{
				return false;
			}
		}
		break;
	}
	return TRUE;
}
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CShareCommInfoArray	vcBaseVisionAlign::m_ShareCommInfoArray;

vcBaseVisionAlign::vcBaseVisionAlign()
{
	m_bEnableSingleFrameShowMode = FALSE;
	//m_bIsMutiTarget=FALSE;
	m_pMainWnd =  NULL;
	m_pMainRunWnd = NULL;
	m_pMainFrameWnd = NULL;

	m_strEXEDir = _T("");

	m_pPlatformInfo = NULL;
	m_pVisionASMConfig = NULL;	
	m_psaSysInfoStrings = NULL;
	m_pDlgSearchToolInfo = NULL;

	m_pPlatformInfo = new SysPlatformInfo;
	m_pVisionASMConfig = new CVisionASMConfig;
	m_pDlgSearchToolInfo = new DlgSearchToolInfo;

	m_nYear = -1;
	m_nMonth = -1;
	m_nDay = -1;
	m_nHour = -1;
	m_bExitCheckRemoveFolderThread = FALSE;

	m_vpCamera.clear();
	m_vpCamOwner.clear();
	//	m_vpHideSearchGUIObject.clear();
	m_vpSearchObject.clear();
	m_vpSaveImageObject.clear();
	m_vpCameraExposureObject.clear();
	m_vImageInput.clear();
	m_vImageSearch.clear();
	m_vpGuiDisplay.clear();
	m_vbCameraLiveGrab.clear();               
	m_vbImageProcessFinished.clear();  

	m_vbSearchSucceed.clear();   
	m_vbSearchFinished.clear();
	m_vSeachResults.clear();

	m_vPTCameraIsOnLine.clear();

	//光源切换
	m_vbExitLightCtrlThread.clear();
	m_vpLightCtrlThread.clear();  
	m_vbLightCtrlSuspended.clear();
	m_vpLightCtrlObject.clear();
	m_vvnChannelIndex.clear();
	m_vvnIntensity.clear();
	m_vbLightCtrlStart.clear();
	m_vbLightCtrlEnd.clear();
	m_vbLightCtrSucceed.clear();
	m_vstrLightCtrlInfo.clear();

	m_bTagetLightFinish = FALSE;

	m_vImageTemp1.clear();
	m_vImageTemp2.clear();

	m_vbShareSrcCamTransferFinished.clear();

	//	m_vpSingleCamAlignCamPltfmAxisPos.clear();

	m_bValidCalibSearchTool   = FALSE;     
	m_bValidTargetSearchTool  = FALSE;   
	//	m_bValidBenchSearchTool   = FALSE;     
	m_bValidObjectSearchTool  = FALSE;    
	m_bValidVirtualSearchTool = FALSE;   
	m_bValidCalibTargetSearchTool  = FALSE; 
	m_bValidInspectSearchTool = FALSE;
	m_bIsAutoCalibrating = FALSE;

	m_bIsRepositoryInitAlnObjectSearch = FALSE;
	m_bIsRepositoryInitAlnTargetSearch = FALSE;
	m_bIsRepositoryInitAlnVirtualObjectSearch = FALSE;
	m_bIsRepositoryInitAlnCalibTargetSearch = FALSE;	
	m_bIsRepositoryInitAlnInspectSearch = FALSE;


	m_bValidAlignerTool       = FALSE;
	m_bTargetMarkSearchSucceed = FALSE;
	m_nCheckTargetDistanceIndex = 0;
	m_nCheckObjectDistanceIndex = 0;

	m_bObjectMarkSearchSucceed=FALSE;
	m_bCurThreadWorkFinished  = TRUE;


	//lzk 0409
	//	m_bAllObjectPosSearchSuccess=FALSE;
	//	m_bAllTargetPosSearchSuccess=FALSE;

	// PB 2013.05.29
	m_bSuspendWorkThread = FALSE;

	m_pComm = NULL;
	m_bValidComm = FALSE;
	m_CommStatus = eCommErr;

	m_bStatusBar = FALSE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");

	m_pAlignerTool = NULL;
	//	m_smSearchMode = eNoSearch;
	//	m_searchAllResultStatus = eSARSResultOK; // iyo

	m_bExitWorkThread = FALSE;
	m_pWorkThread = NULL;
	m_bStopNow = FALSE;

	m_bExitManualSearchThread = FALSE;
	m_pManualSearchThread = NULL;
	m_nManualSearchMarkMode = eNoSearch;
	m_nManualTargetSearchIndex = -1;
	m_nManualObjectSearchIndex = -1;

	m_nMutiTargetCurIndex=0;
	//m_bAutoCalibrateSucceed = FALSE;
	m_bGetAutoCalibrateBaseAxisSucceed = FALSE;
	//	m_bExitHideSearchGuiThread = FALSE;  
	//	m_pHideSearchGuiThread = NULL;    
	//	m_bHideSearchResultGui = FALSE;

	// 获取当前EXE文件夹的路径
	CString strEXEDir;
	GetModuleFileName(NULL, strEXEDir.GetBuffer(MAX_PATH), MAX_PATH);    
	strEXEDir.ReleaseBuffer();
	m_strEXEDir = strEXEDir.Left(strEXEDir.ReverseFind('\\'));   

	m_strDataRecord						= _T("");
	m_strAlignProcessData				= _T("");                    
	m_strCommunicationData				= _T("");
	m_strCommunicationSimpleData		= _T("");
	m_strCommunicationSimpleShowData	= _T("");
	m_strWarningInfoFilePath			= _T("");
	m_strProductSizeData				= _T("");
	m_strProductdistanceData			= _T("");
	// 	m_strTargetSizeData					= _T("");
	// 	m_strObjectSizeData					= _T("");

	m_strCalibrateProcessPath1			= _T("");
	m_strCalibrateProcessPath1			= _T("");
	m_strCalibrateProcessPath2			= _T("");
	m_strCalibrateProcessPath3			= _T("");
	m_strCalibrateProcessPath4			= _T("");
	m_strCalibrateProcessPath5			= _T("");


	InitializeCriticalSection(&m_csResource);
	InitializeCriticalSection(&m_csResourceComm);
	InitializeCriticalSection(&m_csResourceCommName);	//zzc 通信指令
	InitializeCriticalSection(&m_csResourceWarning);	//zzc 报警信息

	InitializeCriticalSection(&m_csBendInspectResultLine);	
	InitializeCriticalSection(&m_csAlignerProcessInfoLine);	

	m_mapCmdNameValue.clear();
	InitializeCriticalSection(&m_csAlignerPrecision);
	InitializeCriticalSection(&m_csAlignerMaxTime);
	InitializeCriticalSection(&m_csAlignerOffset);
	//	InitializeCriticalSection(&m_csSearchShutter);
	InitializeCriticalSection(&m_csAlignCheckInfo);
	// 	InitializeCriticalSection(&m_csResourceObject);
	// 	RegisterObject(this);
	// 
	// 	// 设置相机连接/掉线回调函数
	// 	vcGrab::SetUserBusCameraArrivalCallback(NULL, CameraArrivalCallback);
	// 	vcGrab::SetUserBusCameraRemovalCallback(NULL, CameraRemovalCallback);
	//m_bObjectAndTargetPosInited = FALSE;
	m_bObjectSearchTest = FALSE;
	m_bCalibSearchTest = FALSE;
	m_bTargetSearchTest = FALSE;

	m_pSystempOptionConfig = NULL;

	m_phPosEvent = NULL;

	m_bAutoAlign = FALSE;
	m_nAlignTime = 0;	

	m_bCmdParamAxisPosEanble = FALSE;
	m_bExecuteProductManage = FALSE;

	m_pBenchMarkPickInfo = NULL;
	for (int i=0;i<CALIBMOVEPOSNUM;i++)
	{
		CMarkImagePos * markpos = new CMarkImagePos();
		m_vpMarkImagePos.push_back(markpos);

	}


	m_pVisionAlignOther = NULL;
	m_bSearchWithInspect = FALSE;

	m_vBoardPosForTarFixOffset.clear();
	m_bIsFirstCalibPos = FALSE;
	m_vDmCodeCalibBoardPos.clear();
	m_nAlignType = -1;
	m_nOffsetIndex = 0;
	m_pSystemStatusInfo = NULL;
	m_bCheckRemoveFolderThreadSuspend = TRUE;
	/*m_bAllObjectPosSearchSuccess =  FALSE;
	m_bAllTargetPosSearchSuccess =  FALSE;*/
	m_bIsExecuteFixTargetCheck = FALSE;
	m_bIsExecuteSizeCheck = FALSE;
	m_nExecuteCheckTimes = 0;
	m_bIsSetShutterInMain = FALSE;
	// 	////GYM-标定日志记录
	// 	ImageCoordinate1.clear();
	// 	ImageCoordinate2.clear();
	// 	ImageCoordinate3.clear();
	// 	ImageCoordinate4.clear();
	// 	PlatformCoordinate1.clear();
	// 	PlatformCoordinate2.clear();
	// 	PlatformCoordinate3.clear();
	// 	PlatformCoordinate4.clear();
	// 	CorrelationMoveAxisAngle.clear();
	// 	////GYM-标定日志记录
	//	CalibrateMoveRangeXYPD = sc2Vector(0,0);
	//	AnalysisResultXYPD.clear();

	m_pAlignerTypeInfo = NULL;//lzk 
	m_pAlignerTypeInfo = new AlignerTypeInfo;//lzk


	m_StrSearchErrorInfo = _T(""); 

	m_bExecuteGitCommit = TRUE;
	m_strProductID = _T("");
	m_strProductSTATION = _T("");
	m_strInspectStation = _T("");

	m_bNeedUpdateAddrTime = FALSE;

	m_dLastLy = 0.0;
	m_dLastRy = 0.0;
	m_bisFirstAlign = TRUE;

	m_bFaalBendProcess = FALSE;
}

vcBaseVisionAlign::~vcBaseVisionAlign()
{
	// 停止所有相机的采集
	FreezeAllCameras();

	// 释放所有相机及回调对象
	int i=0;
	for (i=0; i<m_vpCamera.size(); i++)
	{
		DestroyCamera(i);
		UninitCamera(i);
	}

	for (i=0; i<GetPosNum(); i++)
	{
		UninitPos(i);
	}

	//释放所有光源控制器对象
	for (i=0; i < m_vpLightCtrlObject.size(); i++)
	{
		delete m_vpLightCtrlObject.at(i);
		m_vpLightCtrlObject.at(i) = NULL;
	}

	// 释放通信信息
	DeleteCommInfo();

	// 释放平台绝对位置
	//	DeletePlatformAxisPos();

	// 释放相机平台绝对位置
	//	DeleteCameraPlatformAxisPos();

	// 释放平台信息
	DeletePlatformInfo();

	// 释放中间平台信息
	DeleteMidPlatformInfo();

	// 释放相机平台信息
	DeleteCameraPlatformInfo();

	// 释放标定后信息
	//	DeleteCalibratedInfo();

	//	// 释放系统平台信息
	//	DeleteSysPlatformInfo();
	//// 
	//// 	// 释放中间平台信息
	//// 	DeleteMidPlatformInfo();
	//
	//	// 释放定位工具信息
	//	DeleteDlgSearchToolInfo();
	//
	//	// 释放m_pVisionASMConfig指向的内存
	//	DeleteVisionASMConfig();


	// 	for (i=0; i<m_vpGuiLineSegBenchPointPosX.size(); i++)
	// 	{
	// 		if (m_vpGuiLineSegBenchPointPosX.at(i))
	// 		{
	// 			delete m_vpGuiLineSegBenchPointPosX.at(i);
	// 			m_vpGuiLineSegBenchPointPosX.at(i) = NULL;
	// 		}
	// 	}

	// 	for (i=0; i<m_vpGuiLineSegBenchPointPosY.size(); i++)
	// 	{
	// 		if (m_vpGuiLineSegBenchPointPosY.at(i))
	// 		{
	// 			delete m_vpGuiLineSegBenchPointPosY.at(i);
	// 			m_vpGuiLineSegBenchPointPosY.at(i) = NULL;
	// 		}
	// 	}

	for(i = 0; i<m_vpmpCalibMarkImagePos.size();i++)
	{
		if (m_vpmpCalibMarkImagePos.at(i) != NULL)
		{
			delete m_vpmpCalibMarkImagePos.at(i);
			m_vpmpCalibMarkImagePos.at(i) = NULL;
		}
	}
	m_vpmpCalibMarkImagePos.clear();

	for(i = 0; i<m_vvpMarkImagePos.size();i++)
	{
		for(int j = 0; j<m_vvpMarkImagePos.at(i).size();j++)
		{
			if (m_vvpMarkImagePos.at(i).at(j) != NULL)
			{
				delete m_vvpMarkImagePos.at(i).at(j);
				m_vvpMarkImagePos.at(i).at(j) = NULL;
			}
		}
		m_vvpMarkImagePos.at(i).clear();
	}
	m_vvpMarkImagePos.clear();

	UnInitTargetPlatformAxisPos();
	UnInitObjectPlatformAxisPos();
	UnInitObjectCamAxisPos();
	UnInitObjectCamAxisPlatformAxisPos();
	UnInitTargetCamAxisPos();
	UnInitTargetCamAxisPlatformAxisPos();
	UnInitCrossBenchTargetPlatformAxisPos();

	// 释放串口通信
	UninitComm();

	// 释放所有标定用定位工具
	//	UnInitCalibTargetSearchTools(); 

	// 释放所有对位时目标定位工具
	//	UnInitAlnTargetSearchTools();

	// 释放所有对位时实时对象定位工具
	//	UnInitAlnObjectSearchTools();

	// 销毁目标定位工具库
	//	UninitAlnTargetSearchToolRepository();

	// 销毁对象定位工具库
	//	UninitAlnObjectSearchToolRepository();

	// 释放所有对位时虚拟对象定位工具
	//	UnInitAlnVirtualSearchTools();

	// 释放对位工具
	UnInitAlignTool();

	// 	// 取消对象注册
	// 	UnRegisterObject(this);

	for (i=0; i<m_vcsResource.size(); i++)
	{
		DeleteCriticalSection(&m_vcsResource.at(i));
	}

	// 	for (i=0; i<m_vcsResourceProc.size(); i++)
	// 	{
	// 		DeleteCriticalSection(&m_vcsResourceProc.at(i));
	// 	}

	DeleteCriticalSection(&m_csResource);
	DeleteCriticalSection(&m_csResourceComm);
	DeleteCriticalSection(&m_csResourceCommName);	//zzc 通信指令
	DeleteCriticalSection(&m_csResourceWarning);	//zzc 报警信息

	DeleteCriticalSection(&m_csBendInspectResultLine);	
	DeleteCriticalSection(&m_csAlignerProcessInfoLine);

	DeleteCriticalSection(&m_csAlignerPrecision);
	DeleteCriticalSection(&m_csAlignerMaxTime);
	DeleteCriticalSection(&m_csAlignerOffset);
	//	DeleteCriticalSection(&m_csSearchShutter);
	DeleteCriticalSection(&m_csAlignCheckInfo);

	if (m_phPosEvent != NULL)
	{
		delete[] m_phPosEvent;
		m_phPosEvent = NULL;
	}

	//	DeleteCriticalSection(&m_csResourceObject);

	for (i=0;i<m_vpMarkImagePos.size();i++)
	{
		if (m_vpMarkImagePos.at(i)!=NULL)
		{
			delete m_vpMarkImagePos.at(i);
			m_vpMarkImagePos.at(i)=NULL;
		}
	}

	// 释放系统平台信息
	DeleteSysPlatformInfo();
	// 
	// 	// 释放中间平台信息
	// 	DeleteMidPlatformInfo();

	// 释放定位工具信息
	DeleteDlgSearchToolInfo();
	//lzk
	DeleteAlignerTypeInfo();

	if (NULL !=m_pVisionASMConfig)
	{
		m_pVisionASMConfig->DeleteTree();
	}

	// 释放m_pVisionASMConfig指向的内存
	DeleteVisionASMConfig();
}

//光源切换线程
UINT vcBaseVisionAlign::LightCtrlThread(LPVOID pParam)
{
	CLightCtrlObject* pLightCtrlObject = (CLightCtrlObject*)pParam;
	if (pLightCtrlObject == NULL)
	{
		return 0;
	}
	vcBaseVisionAlign* pBaseVisionASM = (vcBaseVisionAlign*) pLightCtrlObject->m_pOwner;
	if (pBaseVisionASM ==  NULL)
	{
		return 0;
	}
	int nLightCtrlIndex = pLightCtrlObject->m_nLightCtrlIndex;

	pBaseVisionASM->LightCtrlProcess(nLightCtrlIndex);

	return 0;
}

//光源切换处理
void vcBaseVisionAlign::LightCtrlProcess(int nLightCtrlIndex)
{
	while(FALSE == m_vbExitLightCtrlThread[nLightCtrlIndex])
	{
		m_vbLightCtrlSuspended[nLightCtrlIndex] = m_bSuspendWorkThread;
		if(m_vbLightCtrlSuspended[nLightCtrlIndex])
		{
			Sleep(2);
			continue;
		}

		//光源切换开始处理
		if (TRUE == m_vbLightCtrlStart[nLightCtrlIndex])
		{
			m_vbLightCtrlStart[nLightCtrlIndex] = FALSE;

			if (!CLightController::GetInstance().SetMultiChannelIntensityValue(nLightCtrlIndex, m_vvnChannelIndex[nLightCtrlIndex],m_vvnIntensity[nLightCtrlIndex]))
			{
				//失败
				m_vbLightCtrSucceed[nLightCtrlIndex] = FALSE;
			}
			else
			{
				//成功
				m_vbLightCtrSucceed[nLightCtrlIndex] = TRUE;
			}

			//失败后重新切换
			int nSum = 0;
			if (1 && FALSE == m_vbLightCtrSucceed[nLightCtrlIndex])
			{
				for (nSum=0;nSum<3;++nSum)//3次
				{
					if (CLightController::GetInstance().SetMultiChannelIntensityValue(nLightCtrlIndex, m_vvnChannelIndex[nLightCtrlIndex],m_vvnIntensity[nLightCtrlIndex]))
					{
						//重切成功后赋值成功
						m_vbLightCtrSucceed[nLightCtrlIndex] = TRUE;
						break;
					}
				}
			}

			 //日志记录
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strInfo,strTemp;
				strInfo.Format(_T("控制器%d切换%s："),nLightCtrlIndex+1,m_vbLightCtrSucceed[nLightCtrlIndex]?_T("OK"):_T("NG"));
				for (int j = 0; j <  m_vvnChannelIndex[nLightCtrlIndex].size(); ++j)
				{
					strTemp.Format(_T("CH%d(%d);"),m_vvnChannelIndex[nLightCtrlIndex].at(j) +1,m_vvnIntensity[nLightCtrlIndex].at(j));
					strInfo += strTemp;
				}
				strTemp.Format(_T("\n进行重切次数：%d\n"),nSum);
				strInfo += strTemp;
				m_vstrLightCtrlInfo[nLightCtrlIndex] = strInfo;
			}

			m_vbLightCtrlEnd[nLightCtrlIndex] = TRUE;
		}

		Sleep(5);
	}
}

void vcBaseVisionAlign::DestroyWorkThread()
{

}

void vcBaseVisionAlign::SetPlatformInfo(CPlatformInfo*	pPlatformInfo)
{
	if ((NULL == pPlatformInfo)||(NULL == m_pVisionASMConfig))
	{
		return;
	}

	DeletePlatformInfo();
	m_pVisionASMConfig->m_pPlatformInfo = new CPlatformXYDInfo;

	CPlatformXYDInfo* pNewPlatformInfo = (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo;;
	CPlatformXYDInfo* pOldPlatformInfo = (CPlatformXYDInfo*)pPlatformInfo;	

	pNewPlatformInfo->m_nPlatformXCoordType = pOldPlatformInfo->m_nPlatformXCoordType;
	pNewPlatformInfo->m_nPlatformYCoordType = pOldPlatformInfo->m_nPlatformYCoordType;
	pNewPlatformInfo->m_nPlatformDCoordType = pOldPlatformInfo->m_nPlatformDCoordType;
	pNewPlatformInfo->m_nPlatformDDriveType = pOldPlatformInfo->m_nPlatformDDriveType;
	pNewPlatformInfo->m_nPlatformDDriveLineType = pOldPlatformInfo->m_nPlatformDDriveLineType;
	pNewPlatformInfo->m_dPlatformRotationLength = pOldPlatformInfo->m_dPlatformRotationLength;    

	m_pVisionASMConfig->m_pPlatformInfo = pNewPlatformInfo;

}
// 获取平台信息	
CPlatformInfo* vcBaseVisionAlign::GetPlatformInfo()
{
	if (NULL == m_pVisionASMConfig)
	{
		return NULL;
	}

	return m_pVisionASMConfig->m_pPlatformInfo;
}

// 设置相机平台信息
void vcBaseVisionAlign::SetCamPlatformInfo(CCamPlatformInfo* camPlatformInfo)
{
	if ((NULL == camPlatformInfo)||(NULL == m_pVisionASMConfig))
	{
		return;
	}

	DeleteCameraPlatformInfo();
	m_pVisionASMConfig->m_pCamPlatformInfo = new CCamPlatformInfo(*camPlatformInfo);
}

// 获取相机平台信息	
CCamPlatformInfo* vcBaseVisionAlign::GetCamPlatformInfo()
{
	if (NULL == m_pVisionASMConfig)
	{
		return NULL;
	}

	return m_pVisionASMConfig->m_pCamPlatformInfo;
}

// 日志
void vcBaseVisionAlign::VisionAlignLogRecord(CString strPathFileName, CString strLog, BOOL bLogTimeEnable/* = TRUE*/)
{
	if (1)
	{
		// 清空较大的日志文件
		VCRemoveFile(strPathFileName);

		SYSTEMTIME sys; 
		GetLocalTime( &sys ); 
		CString t;
		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);

		CString strTemp = "";
		if (bLogTimeEnable)
		{
			strTemp += t;
		}

		strTemp += strLog;
		strTemp += "\n";
		FILE *stream;

		CString strPath;
		
		strPath = strPathFileName;

		if (strPathFileName == "D:\\TimeLog.txt")
		{
			CString tempstr;
			tempstr.Format(_T("D:\\TimeLog_WorkStation%d.txt"),m_pPlatformInfo->m_nPlatformIndex);
			strPath = tempstr;
		}
		if (strPathFileName == "D:\\SuspendWorkthreadLog.txt")
		{
			CString tempstr;
			tempstr.Format(_T("D:\\SuspendWorkthreadLog_WorkStation%d.txt"),m_pPlatformInfo->m_nPlatformIndex);
			strPath = tempstr;
		}


		stream = fopen(strPath, _T("a+t"));
		if (stream != NULL)
		{
			fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
			fclose(stream);	
		}

		// 		CFileStatus fs;
		// 		CFile::GetStatus(strPath,fs);
		// 		if (fs.m_size > 5000000)//1048576)
		// 		{
		// 			::DeleteFile(strPath);
		// 		}
	}
}



void vcBaseVisionAlign::VisionAlignLogRecordCsv(CString strPathFileName, CString strLog, BOOL bLogTimeEnable /*= TRUE*/)
{
	if (1)
	{
		// 清空较大的日志文件
		VCRemoveFile(strPathFileName);

		SYSTEMTIME sys; 
		GetLocalTime( &sys ); 
		CString t;
		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);

		CString strTemp = "";
		 fstream _file;
		_file.open(strPathFileName,ios::in);
		if (!_file)
		{
			strTemp = "时间,X方向移动量,Y方向移动量,正体偏差\n";
		}

		if (bLogTimeEnable)
		{
			strTemp += t;
		}

		strTemp += strLog;
		strTemp += "\n";

		FILE *stream;

		CString strPath;
		strPath = strPathFileName;
		stream = fopen(strPath, _T("a+t"));
		if (stream != NULL)
		{
			fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
			fclose(stream);	
		}

		// 		CFileStatus fs;
		// 		CFile::GetStatus(strPath,fs);
		// 		if (fs.m_size > 5000000)//1048576)
		// 		{
		// 			::DeleteFile(strPath);
		// 		}
	}

}

// S0：加载/保存视觉对位处理所有信息（含初始化数据）
BOOL vcBaseVisionAlign::LoadVisionASMConfig()
{
	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pDlgSearchToolInfo)
	{
		return FALSE;
	}

	//lzk
	if (NULL == m_pAlignerTypeInfo)
	{
		return FALSE;
	}

	if (_T("") == m_pPlatformInfo->m_strPlatformDetailSavePath)
	{
		return FALSE;
	}
	///////////////////////////////////////////////////////////////////////////
	// 	// 获取当前EXE文件夹的路径
	CString strEXEDir, strTemp;
	GetModuleFileName(NULL, strEXEDir.GetBuffer(MAX_PATH), MAX_PATH);    
	strEXEDir.ReleaseBuffer();

	m_strEXEDir = strEXEDir.Left(strEXEDir.ReverseFind('\\'));   

	///////////////////////////////////////////////////////////////////////////
	// 查看相关配置文件夹是否存在
	CString strDir;
	CFileFind findFile;
	BOOL IsFild, IsDir;

	// 查看平台信息文件夹是否存在（例如VSConfig文件夹）
	// 查看平台信息文件夹是否存在（例如Platform1文件夹）
	IsFild = FALSE;
	IsDir = FALSE;

	strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath; //Bin\VSConfig\WS0
	IsFild = findFile.FindFile(strDir);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}	
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strDir/*, NULL*/))// 创建文件夹
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_PLATFORM_DIR_XXX_FAILED), strDir);
			AfxMessageBox(str);

			return FALSE;
		}
	}	


	// 1. VSLog文件夹
	// 查看系统数据记录文件夹是否存在（VSLog文件夹）
	IsFild = FALSE;
	IsDir = FALSE;

	strDir = m_strEXEDir + _T("\\VSLog");
	IsFild = findFile.FindFile(strDir);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}	
	if (!IsDir)
	{
		if (!CreateDirectory(strDir, NULL))// 创建VSLog文件夹
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strDir);
			AfxMessageBox(str);

			return FALSE;
		}	
	}

	// 2. VSLog\WS0
	// 查看系统数据记录文件夹中的Platform1是否存在（DataRecord\\Platform1文件夹）
	IsDir = FALSE;
	IsFild = FALSE;

	CString strDRecord;  
	//m_strDataRecord = m_strEXEDir + _T("\\VSLog") + m_pPlatformInfo->m_strPlatformDetailSavePath.Mid(m_pPlatformInfo->m_strPlatformDetailSavePath.ReverseFind('\\'));
	strDRecord.Format(_T("\\WS%d"),m_pPlatformInfo->m_nPlatformIndex + 1);
	m_strDataRecord = m_strEXEDir + _T("\\VSLog") + strDRecord;
	IsFild = findFile.FindFile(m_strDataRecord); // Bin\VSLog\WS0
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}	
	if (!IsDir)
	{
		if (!CreateDirectory(m_strDataRecord, NULL))// 创建DataRecord\\Platform1文件夹
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), m_strDataRecord);
			AfxMessageBox(str);

			return FALSE;
		}
	}	

	// 3. VSLog\WS0\VDB
	//建立VDB文件夹
	// 查看系统数据记录文件夹中的Platform1是否存在（DataRecord\\Platform1文件夹）
	IsDir = FALSE;
	IsFild = FALSE;

	CString strVDBPath = m_strDataRecord + _T("\\VDB文件");
	IsFild = findFile.FindFile(strVDBPath); // Bin\VSLog\WS0\VBD文件
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}	
	if (!IsDir)
	{
		if (!CreateDirectory(strVDBPath, NULL))// 创建DataRecord\\Platform1文件夹
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	//VDB文件OK文件夹
	CString strVDBPath_OK = m_strDataRecord + _T("\\VDB文件\\OK");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strVDBPath_OK);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strVDBPath_OK/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath_OK);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	//VDB文件NG文件夹
	CString strVDBPath_NG = m_strDataRecord + _T("\\VDB文件\\NG");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strVDBPath_NG);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strVDBPath_NG/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath_NG);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	// 3. VSLog\WS0\Image文件
	// 查看系统数据记录文件夹中的Platform1是否存在（DataRecord\\Platform1文件夹）
	IsDir = FALSE;
	IsFild = FALSE;

	CString strImagePath = m_strDataRecord + _T("\\Image文件");
	IsFild = findFile.FindFile(strImagePath); // Bin\VSLog\WS0\Image文件
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}	
	if (!IsDir)
	{
		if (!CreateDirectory(strImagePath, NULL))// 创建DataRecord\\Platform1文件夹
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strImagePath);
			AfxMessageBox(str);

			return FALSE;
		}
	}




	// 4. VSLog\WS0\AlignProcess(对位流程相关)
	IsDir = FALSE;
	IsFild = FALSE;

	CString strAlignProcess = m_strDataRecord + _T("\\AlignProcess");
	IsFild = findFile.FindFile(strAlignProcess);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strAlignProcess/*, NULL*/))// 创建..\Bin\VSLog\WS0\AlignProcess文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strAlignProcess);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	// 5. VSLog\WS0\AlignTool（对位工具相关）
	IsDir = FALSE;
	IsFild = FALSE;

	CString strAlignTool = m_strDataRecord + _T("\\AlignTool");
	IsFild = findFile.FindFile(strAlignTool);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strAlignTool/*, NULL*/))// 创建..\Bin\VSLog\WS0\AlignTool文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strAlignTool);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	///////////////////////////////////////////////////////////////////////////

	//二维码保存路径
	m_stUploadData.strSavePath = m_strDataRecord;
	m_pVisionASMConfig->m_strConfigPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\WorkStationConfig.xml");

	// 检查平台详细配置XML文件是否存在
	BOOL bXMLFound = m_XMLConfigator.Load(m_pVisionASMConfig->m_strConfigPath);

	BOOL bXMLContentValid = FALSE;
	if (TRUE == bXMLFound)
	{
		bXMLContentValid = m_XMLConfigator.FindElem(_T("WorkStationConfig"));   
	}

	if((FALSE == bXMLFound) || (FALSE == bXMLContentValid)) 
	{
		// 1. 对位平台信息
		DeletePlatformInfo();

		if (ePlatformXYD != m_pPlatformInfo->m_ePlatformType)
		{
			return FALSE;
		}
		m_pVisionASMConfig->m_pPlatformInfo = new CPlatformXYDInfo;	  


		// 2. 中间对位平台信息
		DeleteMidPlatformInfo();
		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		switch(sysPlatformInfo.m_eMidPlatformType)
		{
		case ePlatformXYD:
			{
				m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo;
			}
			break;
		case ePlatformXY1Y2:
			{
				m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXY1Y2Info;
			}
			break;
		case ePlatformX1X2Y:
			{
				m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformX1X2YInfo;
			}
			break;
		default:
			{
				m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo;
			}
			break;
		}



		// 3. 相机平台信息	
		DeleteCameraPlatformInfo();
		int i;
		m_pVisionASMConfig->m_pCamPlatformInfo = new CCamPlatformInfo;
		m_pVisionASMConfig->m_pCamPlatformInfo->SetCamNumPlatformType(m_pPlatformInfo->m_nPositionNum, m_pPlatformInfo->m_eCamPlatformType);

		switch(m_pPlatformInfo->m_eCamPlatformType)
		{
		case eCamPlatformSepFix:
			break;
		case eCamPlatformSepX:
			{
				for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
				{
					m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectX(i, eDirectPositive);				
				}		
			}
			break;
		case eCamPlatformSepXY:
			{
				for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
				{
					m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectX(i, eDirectPositive);
					m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectY(i, eDirectPositive);
				}	
			}
			break;
		case eCamPlatformShareX:
			break;
		default:
			{
				return FALSE;
			}
			break;
		}	


		// 4. 串口通信信息：串口或网口
		DeleteCommInfo();
		switch(m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
		{
		case eSerial:
			{
				m_pVisionASMConfig->m_pCommParam = new vcSerialCommInfo;
			}
			break;
		case eSocket:
			{
				m_pVisionASMConfig->m_pCommParam = new vcSocketCommInfo;
			}
			break;
		default:
			{
				return FALSE; 
			}
			break;
		}

		//通信选项信息
		CCommOptionInfo commOptionInfo;
		SetCommOptionInfo(commOptionInfo);

		int nNum = m_pPlatformInfo->m_nPositionNum;
		CPosInfo posInfo;
		CameraParam cameraParam;
		ImageRoi imageRoi;
		for (i=0; i<nNum; i++)
		{
			m_pVisionASMConfig->m_vPosInfo.push_back(posInfo);
			m_pVisionASMConfig->m_vImageRoi.push_back(imageRoi);
		}

		for (int j=0;j<m_pPlatformInfo->m_nCamNum;j++)
		{
			m_pVisionASMConfig->m_vCameraParam.push_back(cameraParam);
		} 
	}
	else
	{
		if (ePlatformXYD!=m_pPlatformInfo->m_ePlatformType)
		{
			return FALSE;
		}	


		m_XMLConfigator.EnterElem();  //1级目录打开

		// 1. 对位平台信息		
		DeletePlatformInfo();
		m_pVisionASMConfig->m_pPlatformInfo = new CPlatformXYDInfo;

		CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pPlatformInfo); 

		if(TRUE == m_XMLConfigator.FindElem(_T("PlatInfo")))
		{
			m_XMLConfigator.EnterElem();//2级目录打开

			int iCoordDirect = 1;

			// X轴方向					
			if(TRUE == m_XMLConfigator.FindElem(_T("XCType")))
			{
				m_XMLConfigator.GetElemData(iCoordDirect);
				platformXYDInfo->m_nPlatformXCoordType = (PlatformAxisDirectType)iCoordDirect; 
			}

			// Y轴方向
			if(TRUE == m_XMLConfigator.FindElem(_T("YCType")))
			{
				m_XMLConfigator.GetElemData(iCoordDirect);
				platformXYDInfo->m_nPlatformYCoordType = (PlatformAxisDirectType)iCoordDirect; 
			}

			// D轴方向
			if(TRUE == m_XMLConfigator.FindElem(_T("DCType")))
			{
				m_XMLConfigator.GetElemData(iCoordDirect);
				platformXYDInfo->m_nPlatformDCoordType = (PlatformAxisDirectType)iCoordDirect; 
			}

			// DD马达驱动方式
			if(TRUE == m_XMLConfigator.FindElem(_T("DDType")))
			{
				m_XMLConfigator.GetElemData(iCoordDirect);
				platformXYDInfo->m_nPlatformDDriveType = (PlatformDDriveType)iCoordDirect; 
			}

			// DD马达直线驱动方式
			if(TRUE == m_XMLConfigator.FindElem(_T("DDLineType")))
			{
				m_XMLConfigator.GetElemData(iCoordDirect);
				platformXYDInfo->m_nPlatformDDriveLineType = (PlatformDDriveLineType)iCoordDirect; 
			}

			// 平台旋转中心至电机轴中心的距离
			if(TRUE == m_XMLConfigator.FindElem(_T("RLength")))
			{
				m_XMLConfigator.GetElemData(platformXYDInfo->m_dPlatformRotationLength);				 
			}

			m_pVisionASMConfig->m_pPlatformInfo = platformXYDInfo;					

			m_XMLConfigator.LeaveElem(); 	//2级目录关闭				
		}

		// 2. 中间对位平台信息
		DeleteMidPlatformInfo();
		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		switch(sysPlatformInfo.m_eMidPlatformType)
		{
		case ePlatformXYD:
			{
				m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo;
				CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

				if(TRUE == m_XMLConfigator.FindElem(_T("PlatXYDInfo")))
				{
					m_XMLConfigator.EnterElem();//2级目录打开

					int iCoordDirect = 1;


					// X轴方向					
					if(TRUE == m_XMLConfigator.FindElem(_T("XCType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformXCoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// Y轴方向
					if(TRUE == m_XMLConfigator.FindElem(_T("YCType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformYCoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// D轴方向
					if(TRUE == m_XMLConfigator.FindElem(_T("DCType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformDCoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// DD马达驱动方式
					if(TRUE == m_XMLConfigator.FindElem(_T("DDType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformDDriveType = (PlatformDDriveType)iCoordDirect; 
					}

					// DD马达直线驱动方式
					if(TRUE == m_XMLConfigator.FindElem(_T("DDLineType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformDDriveLineType = (PlatformDDriveLineType)iCoordDirect; 
					}

					// 平台旋转中心至电机轴中心的距离
					if(TRUE == m_XMLConfigator.FindElem(_T("RLength")))
					{
						m_XMLConfigator.GetElemData(platformXYDInfo->m_dPlatformRotationLength);				 
					}

					m_pVisionASMConfig->m_pMidPlatformInfo = platformXYDInfo;					

					m_XMLConfigator.LeaveElem(); 	//2级目录关闭				
				}
			}
			break;

		case ePlatformXY1Y2:
			{
				m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXY1Y2Info;
				CPlatformXY1Y2Info* platformXY1Y2Info = (CPlatformXY1Y2Info*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

				if(TRUE == m_XMLConfigator.FindElem(_T("PlatXY1Y2Info")))
				{
					m_XMLConfigator.EnterElem();

					int iCoordDirect = 0;

					// SliderType(类型1、类型2)					
					if(TRUE == m_XMLConfigator.FindElem(_T("SliderType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXY1Y2Info->m_nPlatformUVWSliderType = (PlatformUVWSliderType)iCoordDirect; 
					}

					// X轴坐标方向					
					if(TRUE == m_XMLConfigator.FindElem(_T("XCType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXY1Y2Info->m_nPlatformXCoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// Y1轴坐标方向
					if(TRUE == m_XMLConfigator.FindElem(_T("Y1CType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXY1Y2Info->m_nPlatformY1CoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// Y2轴坐标方向
					if(TRUE == m_XMLConfigator.FindElem(_T("Y2CType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXY1Y2Info->m_nPlatformY2CoordType = (PlatformAxisDirectType)iCoordDirect; 
					}		

					// X/Y1/Y2轴位置
					if(TRUE == m_XMLConfigator.FindElem(_T("XPosX")))
					{
						m_XMLConfigator.GetElemData(platformXY1Y2Info->m_XPos.m_dPosX);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("XPosY")))
					{
						m_XMLConfigator.GetElemData(platformXY1Y2Info->m_XPos.m_dPosY);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("Y1PosX")))
					{
						m_XMLConfigator.GetElemData(platformXY1Y2Info->m_Y1Pos.m_dPosX);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("Y1PosY")))
					{
						m_XMLConfigator.GetElemData(platformXY1Y2Info->m_Y1Pos.m_dPosY);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("Y2PosX")))
					{
						m_XMLConfigator.GetElemData(platformXY1Y2Info->m_Y2Pos.m_dPosX);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("Y2PosY")))
					{
						m_XMLConfigator.GetElemData(platformXY1Y2Info->m_Y2Pos.m_dPosY);				 
					}

					m_pVisionASMConfig->m_pMidPlatformInfo = platformXY1Y2Info;

					m_XMLConfigator.LeaveElem(); 		

				}
			}
			break;

		case ePlatformX1X2Y:
			{
				m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformX1X2YInfo;
				CPlatformX1X2YInfo* platformX1X2YInfo = (CPlatformX1X2YInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

				if(TRUE == m_XMLConfigator.FindElem(_T("PlatX1X2YInfo")))
				{
					m_XMLConfigator.EnterElem();

					int iCoordDirect = 0;

					// SliderType(类型1、类型2)					
					if(TRUE == m_XMLConfigator.FindElem(_T("SliderType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformX1X2YInfo->m_nPlatformUVWSliderType = (PlatformUVWSliderType)iCoordDirect; 
					}

					// X1轴坐标方向					
					if(TRUE == m_XMLConfigator.FindElem(_T("X1CType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformX1X2YInfo->m_nPlatformX1CoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// X2轴坐标方向
					if(TRUE == m_XMLConfigator.FindElem(_T("X2CType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformX1X2YInfo->m_nPlatformX2CoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// Y轴坐标方向
					if(TRUE == m_XMLConfigator.FindElem(_T("YCType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformX1X2YInfo->m_nPlatformYCoordType = (PlatformAxisDirectType)iCoordDirect; 
					}		

					// X1/X2/Y轴的位置
					if(TRUE == m_XMLConfigator.FindElem(_T("X1PosX")))
					{
						m_XMLConfigator.GetElemData(platformX1X2YInfo->m_X1Pos.m_dPosX);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("X1PosY")))
					{
						m_XMLConfigator.GetElemData(platformX1X2YInfo->m_X1Pos.m_dPosY);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("X2PosX")))
					{
						m_XMLConfigator.GetElemData(platformX1X2YInfo->m_X2Pos.m_dPosX);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("X2PosY")))
					{
						m_XMLConfigator.GetElemData(platformX1X2YInfo->m_X2Pos.m_dPosY);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("YPosX")))
					{
						m_XMLConfigator.GetElemData(platformX1X2YInfo->m_YPos.m_dPosX);				 
					}

					if(TRUE == m_XMLConfigator.FindElem(_T("YPosY")))
					{
						m_XMLConfigator.GetElemData(platformX1X2YInfo->m_YPos.m_dPosY);				 
					}

					m_pVisionASMConfig->m_pMidPlatformInfo = platformX1X2YInfo;					

					m_XMLConfigator.LeaveElem(); 		

				}
			}
			break;

		default:
			{
				m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo;
				CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

				if(TRUE == m_XMLConfigator.FindElem(_T("PlatXYDInfo")))
				{
					m_XMLConfigator.EnterElem();//2级目录打开

					int iCoordDirect = 1;


					// X轴方向					
					if(TRUE == m_XMLConfigator.FindElem(_T("XCType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformXCoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// Y轴方向
					if(TRUE == m_XMLConfigator.FindElem(_T("YCType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformYCoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// D轴方向
					if(TRUE == m_XMLConfigator.FindElem(_T("DCType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformDCoordType = (PlatformAxisDirectType)iCoordDirect; 
					}

					// DD马达驱动方式
					if(TRUE == m_XMLConfigator.FindElem(_T("DDType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformDDriveType = (PlatformDDriveType)iCoordDirect; 
					}

					// DD马达直线驱动方式
					if(TRUE == m_XMLConfigator.FindElem(_T("DDLineType")))
					{
						m_XMLConfigator.GetElemData(iCoordDirect);
						platformXYDInfo->m_nPlatformDDriveLineType = (PlatformDDriveLineType)iCoordDirect; 
					}

					// 平台旋转中心至电机轴中心的距离
					if(TRUE == m_XMLConfigator.FindElem(_T("RLength")))
					{
						m_XMLConfigator.GetElemData(platformXYDInfo->m_dPlatformRotationLength);				 
					}

					m_pVisionASMConfig->m_pMidPlatformInfo = platformXYDInfo;					

					m_XMLConfigator.LeaveElem(); 	//2级目录关闭				
				}
			}
			break;
		}

		// 3. 相机平台信息
		DeleteCameraPlatformInfo();
		int i=0;
		m_pVisionASMConfig->m_pCamPlatformInfo = new CCamPlatformInfo;
		m_pVisionASMConfig->m_pCamPlatformInfo->SetCamNumPlatformType(m_pPlatformInfo->m_nPositionNum, m_pPlatformInfo->m_eCamPlatformType);
		if(TRUE == m_XMLConfigator.FindElem(_T("CamPlatInfo")))
		{
			m_XMLConfigator.EnterElem();//2级目录打开

			CString strInfo;
			for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
			{
				// 相机轴
				strInfo.Format(_T("CamPlatInfo%d"),i);
				if(TRUE == m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.EnterElem();    //3级目录打开     

					int iCamDirect = 1;	                    

					switch(m_pPlatformInfo->m_eCamPlatformType)
					{
					case eCamPlatformSepFix:
						break;
					case eCamPlatformSepX:
						{
							// 相机平台X轴方向
							if (m_XMLConfigator.FindElem(_T("CamXCType")))
							{
								m_XMLConfigator.GetElemData(iCamDirect);
							}
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectX(i, (PlatformAxisDirectType)(iCamDirect));
						}
						break;
					case eCamPlatformSepXY:
						{
							// 相机平台X轴方向
							if (m_XMLConfigator.FindElem(_T("CamXCType")))
							{
								m_XMLConfigator.GetElemData(iCamDirect);
							}
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectX(i, (PlatformAxisDirectType)(iCamDirect));

							// 相机平台Y轴方向
							if (m_XMLConfigator.FindElem(_T("CamYCType")))
							{
								m_XMLConfigator.GetElemData(iCamDirect);
							}					
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectY(i, (PlatformAxisDirectType)(iCamDirect));

						}
						break;
					case eCamPlatformShareX:
						break;
					default:
						{
							return FALSE;
						}
						break;
					}	

					m_XMLConfigator.LeaveElem();//3级目录关闭
				}

				// 相机轴所在平台轴
				strInfo.Format(_T("CamPlatAxisInfo%d"),i);
				if(TRUE == m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.EnterElem();    //3级目录打开     

					int iCamDirect = 1;	                    

					switch(m_pPlatformInfo->m_eCamPlatformType)
					{
					case eCamPlatformSepFix:
						break;
					case eCamPlatformSepX:
						{
							// 相机平台X轴方向
							if (m_XMLConfigator.FindElem(_T("CamPXCType")))
							{
								m_XMLConfigator.GetElemData(iCamDirect);
							}
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectX(i, (PlatformAxisDirectType)(iCamDirect));
						}
						break;
					case eCamPlatformSepXY:
						{
							// 相机平台X轴方向
							if (m_XMLConfigator.FindElem(_T("CamPXCType")))
							{
								m_XMLConfigator.GetElemData(iCamDirect);
							}
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectX(i, (PlatformAxisDirectType)(iCamDirect));

							// 相机平台Y轴方向
							if (m_XMLConfigator.FindElem(_T("CamPYCType")))
							{
								m_XMLConfigator.GetElemData(iCamDirect);
							}					
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectY(i, (PlatformAxisDirectType)(iCamDirect));

						}
						break;
					case eCamPlatformShareX:
						break;
					default:
						{
							return FALSE;
						}
						break;
					}	

					m_XMLConfigator.LeaveElem();//3级目录关闭
				}

			}

			m_XMLConfigator.LeaveElem();//2级目录关闭
		}
		else
		{
			// 相机轴
			switch(m_pPlatformInfo->m_eCamPlatformType)
			{
			case eCamPlatformSepFix:
				break;
			case eCamPlatformSepX:
				{
					for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
					{
						m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectX(i, eDirectPositive);				
					}		
				}
				break;
			case eCamPlatformSepXY:
				{
					for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
					{
						m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectX(i, eDirectPositive);
						m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectY(i, eDirectPositive);
					}	
				}
				break;
			case eCamPlatformShareX:
				break;
			default:
				{
					return FALSE;
				}
				break;
			}	

			// 相机轴所在平台轴
			switch(m_pPlatformInfo->m_eCamPlatformType)
			{
			case eCamPlatformSepFix:
				break;
			case eCamPlatformSepX:
				{
					for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
					{
						m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectX(i, eDirectPositive);				
					}		
				}
				break;
			case eCamPlatformSepXY:
				{
					for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
					{
						m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectX(i, eDirectPositive);
						m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectY(i, eDirectPositive);
					}	
				}
				break;
			case eCamPlatformShareX:
				break;
			default:
				{
					return FALSE;
				}
				break;
			}	

		}

		// 4. 串口通信信息：串口或网口
		DeleteCommInfo();
		if(TRUE == m_XMLConfigator.FindElem(_T("CommParamInfo")))
		{
			m_XMLConfigator.EnterElem();
			m_pVisionASMConfig->m_CommParamInfo.LoadModelFromFile(m_XMLConfigator);

			switch(m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
			{
			case eSerial:
				{
					m_pVisionASMConfig->m_pCommParam = new vcSerialCommInfo;
					vcSerialCommInfo* serialCommInfo = (vcSerialCommInfo*)m_pVisionASMConfig->m_pCommParam;

					int iValue = 0;

					if(TRUE == m_XMLConfigator.FindElem(_T("SerialCommInfo")))
					{
						m_XMLConfigator.EnterElem(); //2级目录打开

						// 串口号，从0开始
						if (m_XMLConfigator.FindElem(_T("ComPort")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_uiComPort = iValue;
						}

						// 波特率
						if (m_XMLConfigator.FindElem(_T("BaudRate")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_uiBaudRate = iValue;
						}

						// 奇偶校验
						if (m_XMLConfigator.FindElem(_T("Parity")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_Parity = (SerialParity)iValue;
						}

						// 停止位
						if (m_XMLConfigator.FindElem(_T("StopBits")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_StopBits = (SerialStopBits)iValue;
						}

						// 数据位
						if (m_XMLConfigator.FindElem(_T("ByteSize")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_uiDataBits = iValue;
						}

						// 通信终止符
						if (m_XMLConfigator.FindElem(_T("CommEnd")))
						{
							serialCommInfo->m_strCommStop = m_XMLConfigator.GetElemData();
						}

						// 通信终止符
						if (m_XMLConfigator.FindElem(_T("CmdEnd")))
						{
							serialCommInfo->m_strCmdStop = m_XMLConfigator.GetElemData();
						}

						// 寄存器首地址				
						if (m_XMLConfigator.FindElem(_T("RegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_lRegAddress = iValue;
						}

						if (m_XMLConfigator.FindElem(_T("TempRegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_lTempRegAddress = iValue;
						}

						// 单次最大写寄存器数量
						if (m_XMLConfigator.FindElem(_T("WriteRegMaxNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_lWriteRegMaxNum = iValue;
						}

						// 单次最大读寄存器数量
						if (m_XMLConfigator.FindElem(_T("ReadRegMaxNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_lReadRegMaxNum = iValue;
						}

						m_pVisionASMConfig->m_pCommParam = serialCommInfo;

						m_XMLConfigator.LeaveElem();    //2级目录关闭                 

					}

				}
				break;
			case eSocket:
				{
					m_pVisionASMConfig->m_pCommParam = new vcSocketCommInfo;

					vcSocketCommInfo* socketCommInfo = (vcSocketCommInfo*)m_pVisionASMConfig->m_pCommParam;

					int iValue = 0;

					if(TRUE == m_XMLConfigator.FindElem(_T("SocketCommInfo")))
					{
						m_XMLConfigator.EnterElem(); //2级目录打开

						// Socket类型，服务端或客户端
						if (m_XMLConfigator.FindElem(_T("SocketType")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_socketType = (SocketType)iValue;
						}

						// IP地址 （安登奎）
						if (m_XMLConfigator.FindElem(_T("IP")))
						{
							CString strData = m_XMLConfigator.GetElemData();
							int nIdx = strData.Find('.');
							CString strValue = strData.Left(nIdx);
							strData = strData.Mid(nIdx+1);
							socketCommInfo->m_byAddr[0] = (unsigned char)_ttoi(strValue);
							nIdx = strData.Find('.');
							strValue = strData.Left(nIdx);
							strData = strData.Mid(nIdx+1);
							socketCommInfo->m_byAddr[1] = (unsigned char)_ttoi(strValue);
							nIdx = strData.Find('.');
							strValue = strData.Left(nIdx);
							strData = strData.Mid(nIdx+1);
							socketCommInfo->m_byAddr[2] = (unsigned char)_ttoi(strValue);
							socketCommInfo->m_byAddr[3] = (unsigned char)_ttoi(strData);
						}

						// 端口				
						if (m_XMLConfigator.FindElem(_T("IPPort")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_uiPort = iValue;
						}

						// 服务端监听个数
						if (m_XMLConfigator.FindElem(_T("ListenNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_uiListenNum = iValue;
						}

						// 通信终止符
						if (m_XMLConfigator.FindElem(_T("CommEnd")))
						{
							socketCommInfo->m_strCommStop = m_XMLConfigator.GetElemData();
						}

						// 通信终止符
						if (m_XMLConfigator.FindElem(_T("CmdEnd")))
						{
							socketCommInfo->m_strCmdStop = m_XMLConfigator.GetElemData();
						}

						// 寄存器首地址				
						if (m_XMLConfigator.FindElem(_T("RegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lRegAddress = iValue;
						}

						if (m_XMLConfigator.FindElem(_T("TempRegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lTempRegAddress = iValue;
						}

						// 单次最大写寄存器数量
						if (m_XMLConfigator.FindElem(_T("WriteRegMaxNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lWriteRegMaxNum = iValue;
						}

						// 单次最大读寄存器数量
						if (m_XMLConfigator.FindElem(_T("ReadRegMaxNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lReadRegMaxNum = iValue;
						}
						double dValue =0;

						if (m_XMLConfigator.FindElem(_T("WZRegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lWZRegAddress = iValue;
						}

						// ID寄存器地址
						if (m_XMLConfigator.FindElem(_T("RegAddress3")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lRegAddress3 = iValue;
						}

						if (m_XMLConfigator.FindElem(_T("EnableIDRaed")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_bEnableIDRaed = (BOOL)iValue;
						}

						if (m_XMLConfigator.FindElem(_T("IDLength")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_nIDLength = iValue;
						}

						//m_bIDInvert
						if (m_XMLConfigator.FindElem(_T("IDInvert")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_bIDInvert = (BOOL)iValue;
						}
							
						if (m_XMLConfigator.FindElem(_T("m_szGetName")))
						{
							socketCommInfo->m_szGetName = m_XMLConfigator.GetElemData();
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZW")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZW = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZR")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZR = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZY1")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZY1 = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZY2")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZY2 = dValue;
						}


						if (m_XMLConfigator.FindElem(_T("m_dWZY3")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZY3 = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZZ1")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZZ1 = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZZ2")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZZ2 = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZZ3")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZZ3 = dValue;
						}

						m_pVisionASMConfig->m_pCommParam = socketCommInfo;		

						m_XMLConfigator.LeaveElem(); //2级目录关闭
					}

				}
				break;
			default:
				{
					return FALSE; 
				}
				break;
			}

			m_XMLConfigator.LeaveElem();
		}
		else
		{
			switch(m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
			{
			case eSerial:
				{
					m_pVisionASMConfig->m_pCommParam = new vcSerialCommInfo;
				}
				break;
			case eSocket:
				{
					m_pVisionASMConfig->m_pCommParam = new vcSocketCommInfo;
				}
				break;
			default:
				{
					return FALSE; 
				}
				break;
			}
		}

		// 5. 通信选项信息
		CCommOptionInfo commOptionInfo;
		if (m_XMLConfigator.FindElem(_T("CommOptionInfo")))
		{
			m_XMLConfigator.EnterElem();

			if (m_XMLConfigator.FindElem(_T("UsePlatformComm")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				commOptionInfo.m_bUsePlatformComm = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("CommDelay")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				commOptionInfo.m_nCommDelay = k;
			}

			if (m_XMLConfigator.FindElem(_T("CommTimeout")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				commOptionInfo.m_nCommTimeOut = k;
			}

			if (m_XMLConfigator.FindElem(_T("CommReSendTimes")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				commOptionInfo.m_nCommReSendTimes = k;
			}

			if (m_XMLConfigator.FindElem(_T("CommXUnitExp")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				commOptionInfo.m_nCommXUnitExp = k;
			}

			if (m_XMLConfigator.FindElem(_T("CommYUnitExp")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				commOptionInfo.m_nCommYUnitExp = k;
			}

			if (m_XMLConfigator.FindElem(_T("CommDUnitExp")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				commOptionInfo.m_nCommDUnitExp = k;
			}

			if (m_XMLConfigator.FindElem(_T("CommDataLenType")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				commOptionInfo.m_nCommDataLenType = k;
			}

			m_XMLConfigator.LeaveElem();
		}  
		SetCommOptionInfo(commOptionInfo);


		// 6. 相机信息：以序列号采集	
		CString strInfo;
		double dValue;
		m_pVisionASMConfig->m_vCameraParam.resize(m_pPlatformInfo->m_nCamNum);
		if(TRUE == m_XMLConfigator.FindElem(_T("CamParam")))
		{
			m_XMLConfigator.EnterElem(); //2级目录打开

			for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
			{
				CameraParam cameraParam;
				strInfo.Format(_T("CamParam%d"),i);

				if(TRUE == m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.EnterElem();//3级目录打开

					// 相机DeviceID
					if(m_XMLConfigator.FindElem(_T("DeviceID")))
					{
						CString strID = _T("");
						strID = m_XMLConfigator.GetElemData();
						cameraParam.m_strDeviceID = strID;
					}

					// 相机序列号
					if (m_XMLConfigator.FindElem(_T("SN")))
					{
						m_XMLConfigator.GetElemData(dValue);
						cameraParam.m_lSerialNum = (unsigned long)dValue;
					}

					// 相机视频模式
					if (m_XMLConfigator.FindElem(_T("Mode")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_nVideoMode);				 
					}

					// 相机宽
					if (m_XMLConfigator.FindElem(_T("W")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_nRawWidth);				 
					}

					// 相机高
					if (m_XMLConfigator.FindElem(_T("H")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_nRawHeight);				 
					}

					// 自定义起始X
					if (m_XMLConfigator.FindElem(_T("X")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_nCustemStartX);				 
					}

					// 自定义起始Y
					if (m_XMLConfigator.FindElem(_T("Y")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_nCustemStartY);				 
					}

					// 自定义宽
					if (m_XMLConfigator.FindElem(_T("W")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_nCustemWidth);				 
					}

					// 自定义高
					if (m_XMLConfigator.FindElem(_T("H")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_nCustemHeight);				 
					}

					// 白平衡
					if (m_XMLConfigator.FindElem(_T("WhiteBalanceRatioR")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_dWhiteBalanceRatioR);				 
					}

					if (m_XMLConfigator.FindElem(_T("WhiteBalanceRatioG")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_dWhiteBalanceRatioG);				 
					}

					if (m_XMLConfigator.FindElem(_T("WhiteBalanceRatioB")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_dWhiteBalanceRatioB);				 
					}

					// 帧率
					if (m_XMLConfigator.FindElem(_T("FrameRate")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_dFrameRate);				 
					}

					// 曝光时间
					if (m_XMLConfigator.FindElem(_T("Shutter")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_dShutter);				 
					}

					// 增益
					if (m_XMLConfigator.FindElem(_T("Gain")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_dGain);				 
					}		

					// GammaEnable
					if (m_XMLConfigator.FindElem(_T("GammaEnable")))
					{
						int nVal = 0;
						m_XMLConfigator.GetElemData(nVal);
						cameraParam.m_bGammaEnable = (bool)nVal;
					}

					// Gamma
					if (m_XMLConfigator.FindElem(_T("Gamma")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_dGamma);				 
					}

					//共享相机类型
					if(m_XMLConfigator.FindElem(_T("ShareCamType")))
					{	
						int nData=0;
						m_XMLConfigator.GetElemData(nData);	
						cameraParam.m_eShareCamType=(CShareCamType)nData;
					}

					if(m_XMLConfigator.FindElem(_T("ShareCamNum")))
					{
						m_XMLConfigator.GetElemData(cameraParam.m_nShareCamNum);	
					}
					cameraParam.m_vShareCamInfo.resize(cameraParam.m_nShareCamNum);
					for (int g=0;g<cameraParam.m_nShareCamNum;g++)
					{
						strInfo.Format(_T("ShareCam%d"),g);
						if(m_XMLConfigator.FindElem(strInfo))
						{
							m_XMLConfigator.EnterElem();
							if(m_XMLConfigator.FindElem(_T("SharePlatformIndex")))
							{
								m_XMLConfigator.GetElemData(cameraParam.m_vShareCamInfo.at(g).m_nPlatformIndex);
							}
							if(m_XMLConfigator.FindElem(_T("ShareCameraIndex")))
							{
								m_XMLConfigator.GetElemData(cameraParam.m_vShareCamInfo.at(g).m_nCamIndex);
							}
							m_XMLConfigator.LeaveElem();
						}

					}

					m_XMLConfigator.LeaveElem();  //3级目录关闭

					m_pVisionASMConfig->m_vCameraParam.at(i) = cameraParam;
				}				

			}

			m_XMLConfigator.LeaveElem(); //2级目录关闭
		}

		// 7. 位置信息
		CPosInfo posInfo;
		m_pVisionASMConfig->m_vPosInfo.resize(m_pPlatformInfo->m_nPositionNum);
		if(TRUE == m_XMLConfigator.FindElem(_T("PosInfo")))
		{
			m_XMLConfigator.EnterElem(); //2级目录打开

			for (int i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
			{
				strInfo.Format(_T("PosInfo%d"),i);

				if(TRUE == m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.EnterElem();//3级目录打开

					// 位置信息是否有效
					if(m_XMLConfigator.FindElem(_T("PosEnable")))
					{
						m_XMLConfigator.GetElemData(posInfo.m_bPosEnable);
					}

					// 相机索引
					if (m_XMLConfigator.FindElem(_T("CamIndex")))
					{
						m_XMLConfigator.GetElemData(posInfo.m_nCamIndex);
					}

					m_XMLConfigator.LeaveElem();  //3级目录关闭

					m_pVisionASMConfig->m_vPosInfo.at(i) = posInfo;
				}
			}
			m_XMLConfigator.LeaveElem(); //2级目录关闭
		}


		// 8. 图像显示参数	
		ImageRoi imageROI;
		int nNum = m_pPlatformInfo->m_nPositionNum;
		m_pVisionASMConfig->m_vImageRoi.resize(nNum);
		if(TRUE == m_XMLConfigator.FindElem(_T("CamDisp")))
		{
			m_XMLConfigator.EnterElem();  //2级目录打开

			for (i=0; i<nNum; i++)
			{
				strInfo.Format(_T("CamDisp%d"),i);

				if(TRUE == m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.EnterElem(); //3级目录打开

					// 水平镜像
					if (m_XMLConfigator.FindElem(_T("MH")))
					{
						m_XMLConfigator.GetElemData(imageROI.m_bMirrorHoriz);				 
					}

					// 垂直镜像
					if (m_XMLConfigator.FindElem(_T("MV")))
					{
						m_XMLConfigator.GetElemData(imageROI.m_bMirrorVert);				 
					}


					// 旋转
					if (m_XMLConfigator.FindElem(_T("R")))
					{
						m_XMLConfigator.GetElemData(imageROI.m_nRotation);				 
					}					


					// GammaCorrectionEnable
					if (m_XMLConfigator.FindElem(_T("GammaCorrectionEnable")))
					{
						m_XMLConfigator.GetElemData(imageROI.m_bGammaCorrectionEnable);				 
					}			
					else
					{
						imageROI.m_bGammaCorrectionEnable = FALSE;
					}

					// Gamma
					if (m_XMLConfigator.FindElem(_T("Gamma")))
					{
						m_XMLConfigator.GetElemData(imageROI.m_dGamma);				 
					}			
					else
					{
						imageROI.m_dGamma = 1.0;
					}

					// 十字中心是否可见
					if (m_XMLConfigator.FindElem(_T("CrossVisible")))
					{
						m_XMLConfigator.GetElemData(imageROI.m_bCrossVisible);				 
					}			


					// 十字中心X
					if (m_XMLConfigator.FindElem(_T("CrossX")))
					{
						m_XMLConfigator.GetElemData(imageROI.m_dCrossX);				 
					}			


					// 十字中心Y
					if (m_XMLConfigator.FindElem(_T("CrossY")))
					{
						m_XMLConfigator.GetElemData(imageROI.m_dCrossY);				 
					}			


					m_XMLConfigator.LeaveElem(); //3级目录关闭

					m_pVisionASMConfig->m_vImageRoi.at(i) = imageROI;
				}				

			}

			m_XMLConfigator.LeaveElem(); //2级目录关闭
		}	

		// 9. 中间数据记录
		if (m_XMLConfigator.FindElem(_T("LogParam")))
		{
			m_XMLConfigator.EnterElem(); //2级目录打开

			if(m_XMLConfigator.FindElem(_T("ASEnabled")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo);
			}

			if(m_XMLConfigator.FindElem(_T("CommEnabled")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bCommunication);
			}

			if(m_XMLConfigator.FindElem(_T("AlignToolLog")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignToolLog);
			}



			if(m_XMLConfigator.FindElem(_T("ImageName")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bImageName);
			}

			if(m_XMLConfigator.FindElem(_T("SaveNGImage")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage);
			}

			if(m_XMLConfigator.FindElem(_T("SaveFailedImageNum")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum);
			}

			if(m_XMLConfigator.FindElem(_T("SaveAllImage")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage);
			}

			if(m_XMLConfigator.FindElem(_T("SaveAllImageNum")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum);
			}

			if(m_XMLConfigator.FindElem(_T("SaveAllImageType")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType);
			}

			if(m_XMLConfigator.FindElem(_T("ImageFormat")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_eImageFormat = (CImageType)nValue;
			}

			if(m_XMLConfigator.FindElem(_T("ImageQuality")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_nImageQuility = nValue;
			}


			if(m_XMLConfigator.FindElem(_T("SaveVDBFile")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile = (BOOL)nValue;
			}

			if(m_XMLConfigator.FindElem(_T("VDBNameByID")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_bVDBNameByID = (BOOL)nValue;
			}
			if(m_XMLConfigator.FindElem(_T("VDBImageQuality")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_nVDBImageQuility = nValue;
			}

			if(m_XMLConfigator.FindElem(_T("SaveVDBMaxNums")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums);
			}
			if(m_XMLConfigator.FindElem(_T("SaveObjectSnapVDBFile")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_bSaveObjectSnapVDBFile = (BOOL)nValue;
			}
			if(m_XMLConfigator.FindElem(_T("SaveTargetSnapVDBFile")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_bSaveTargetSnapVDBFile = (BOOL)nValue;
			}

			//m_bSaveProcessSnapVDBFile
			if(m_XMLConfigator.FindElem(_T("SaveProcessSnapVDBFile")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_bSaveProcessSnapVDBFile = (BOOL)nValue;
			}

			////m_bSaveInsepectResultVDBFile
			if(m_XMLConfigator.FindElem(_T("SaveInsepectResultVDBFile")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_bSaveInsepectResultVDBFile = (BOOL)nValue;
			}

			if(m_XMLConfigator.FindElem(_T("GuitextWeight")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_GuitextWeight = nValue;
			}
			if(m_XMLConfigator.FindElem(_T("GuiLineWidth")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_GuiLineWidth = nValue;
			}

			if(m_XMLConfigator.FindElem(_T("VBDImageType")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_nVBDImageType = nValue;
			}
			if(m_XMLConfigator.FindElem(_T("VBDImageType")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_nVBDImageType = nValue;
			}


			if(m_XMLConfigator.FindElem(_T("EnableCustomLogPath")))
			{
				int nValue =0;
				m_XMLConfigator.GetElemData(nValue);
				m_pVisionASMConfig->m_DataRecord.m_bCustomLogPath = (BOOL)nValue;
			}

			if(m_XMLConfigator.FindElem(_T("bDataRecordTime")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime);
			}

			if(m_XMLConfigator.FindElem(_T("nDataRecordTimeNum")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nDataRecordTimeNum);
			}

			if(m_XMLConfigator.FindElem(_T("StartHourRecordByDay")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nStartHourRecordByDay);
			}

			if(m_XMLConfigator.FindElem(_T("dDiskSpaceMaxUsePercent")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_dDiskSpaceMaxUsePercent);
			}

			if(m_XMLConfigator.FindElem(_T("strDataRecordPath")))
			{
				m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath = m_XMLConfigator.GetElemData();

				// 禁止自定义日志路径为C盘，为C盘时，强制设置为D盘
				if(m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath.Left(2)==_T("C:"))
				{
					CString strTmp;
					strTmp.Format(_T("D:\\VSLog\\WS%d"),m_pPlatformInfo->m_nPlatformIndex+1);
					m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath = strTmp;
				}
			}


			// 			if(m_XMLConfigator.FindElem(_T("UseThreadSaveImageMode")))
			// 			{
			// 				int nValue =0;
			// 				m_XMLConfigator.GetElemData(nValue);
			// 				m_pVisionASMConfig->m_DataRecord.m_bThreadSaveImageMode = (BOOL)nValue;
			// 			}






			if(m_XMLConfigator.FindElem(_T("APEnabled")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision);
			}

			if(m_XMLConfigator.FindElem(_T("ATEnabled")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerTime);
			}

			if(m_XMLConfigator.FindElem(_T("MergeEnabled")))
			{
				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bDataMerged);
			}

			// 			if(m_XMLConfigator.FindElem(_T("LogEnabled")))
			// 			{
			// 				m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bSysDataRecord);
			// 			}

			// 			if(m_XMLConfigator.FindElem(_T("AllImgDir")))
			// 			{

			m_XMLConfigator.LeaveElem(); //2级目录关闭
		}    

		// 10. 对位方式记录信息
		if (m_XMLConfigator.FindElem(_T("AlignerTypeInfo")))
		{
			m_XMLConfigator.EnterElem();
			//2Vs2
			m_XMLConfigator.FindElem(_T("Aligner2Vs2TypeInfo"));
			m_XMLConfigator.EnterElem();
			vector<Aligner2Vs2TypeInfo>::iterator iterAligner2Vs2;
			iterAligner2Vs2 = m_pAlignerTypeInfo->m_vAligner2Vs2TypeInfo.begin();
			for(;iterAligner2Vs2 != m_pAlignerTypeInfo->m_vAligner2Vs2TypeInfo.end();iterAligner2Vs2++)
			{
				if(m_XMLConfigator.FindElem(iterAligner2Vs2->m_strAlignerName))
				{
					iterAligner2Vs2->m_bOpenAligner = _ttoi(m_XMLConfigator.GetElemData());
				}
			}
			m_XMLConfigator.LeaveElem();
			//3Vs3
			m_XMLConfigator.FindElem(_T("Aligner3Vs3TypeInfo"));
			m_XMLConfigator.EnterElem();
			vector<Aligner3Vs3TypeInfo>::iterator iterAligner3Vs3;
			iterAligner3Vs3 = m_pAlignerTypeInfo->m_vAligner3Vs3TypeInfo.begin();
			for(;iterAligner3Vs3 != m_pAlignerTypeInfo->m_vAligner3Vs3TypeInfo.end();iterAligner3Vs3++)
			{
				if(m_XMLConfigator.FindElem(iterAligner3Vs3->m_strAlignerName))
				{
					iterAligner3Vs3->m_bOpenAligner = _ttoi(m_XMLConfigator.GetElemData());
				}
			}
			m_XMLConfigator.LeaveElem();
			//4Vs4
			m_XMLConfigator.FindElem(_T("Aligner4Vs4TypeInfo"));
			m_XMLConfigator.EnterElem();
			vector<Aligner4Vs4TypeInfo>::iterator iterAligner4Vs4;
			iterAligner4Vs4 = m_pAlignerTypeInfo->m_vAligner4Vs4TypeInfo.begin();
			for(;iterAligner4Vs4 != m_pAlignerTypeInfo->m_vAligner4Vs4TypeInfo.end();iterAligner4Vs4++)
			{
				if(m_XMLConfigator.FindElem(iterAligner4Vs4->m_strAlignerName))
				{
					iterAligner4Vs4->m_bOpenAligner = _ttoi(m_XMLConfigator.GetElemData());
				}
			}
			m_XMLConfigator.LeaveElem();
			m_XMLConfigator.LeaveElem();
		}    

		// 11. 定位工具记录
		if (m_XMLConfigator.FindElem(_T("SearchToolParam")))
		{
			m_XMLConfigator.EnterElem();    //进入二级目录

			int nSearchToolNum = 0;
			map<pair<int,CString>,BOOL>::iterator iterDlg;
			iterDlg = m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.begin();
			for(;iterDlg!=m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.end();iterDlg++)
			{
				if(m_XMLConfigator.FindElem(iterDlg->first.second))
				{
					m_XMLConfigator.GetElemData(iterDlg->second);
					if(iterDlg->second)
					{
						nSearchToolNum++;
					}
				}
			}

			if(nSearchToolNum == 0)  //若加载时，定位工具都为FALSE，则设置第一个为TRUE
			{
				m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.begin()->second = TRUE;
			}

			m_XMLConfigator.LeaveElem();    //离开二级目录
		}

		// 12. 平台数据记录
		if (m_XMLConfigator.FindElem(_T("PlatformOptionInfo")))
		{
			m_XMLConfigator.EnterElem();
			CPlatformOptionInfo optionInfo;
			if (m_XMLConfigator.FindElem(_T("SearchWithDistanceInspect")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSearchWithDistanceInspect = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("SendInsDistanceInSearchResult")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSendInsDistanceInSearchResult = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("OffsetPicturePath")))
			{
				optionInfo.m_strOffsetPicturePath = m_XMLConfigator.GetElemData();
			}

			if (m_XMLConfigator.FindElem(_T("EnableDmCodeCalib")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableDmCodeCalib = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("TargetInfoCommunicationModeInDifferentPC")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_nTarInfoCommModeInDiffPC = k;
			}

			if (m_XMLConfigator.FindElem(_T("EnableAlignAfterSearch")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableAlignAfterSearch = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("SendMulAlignResult")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSendMulAlignResult = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("RecordCamFixMarkPos")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bRecordCamFixMarkPos = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("ObjectSearchExProduct")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bObjectSearchExProduct = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("TargetSearchExProduct")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bTargetSearchExProduct = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("AlignExProduct")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bAlignExProduct = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("SaveCalibData")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSaveCalibData = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("AutoCopyCalibData")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bAutoCopyCalibData = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("bAutoCopyCalibDataExProduct")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bAutoCopyCalibDataExProduct = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("SendAreaInspectSubResult")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSendAreaInspectSubResult = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("OffsetMaxX")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dOffsetMaxX = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("OffsetMaxY")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dOffsetMaxY = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("OffsetMaxD")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dOffsetMaxD = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("OffsetMaxXLowerLimit")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dOffsetMaxX_LowerLimit = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("OffsetMaxYLowerLimit")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dOffsetMaxY_LowerLimit = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("OffsetMaxDLowerLimit")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dOffsetMaxD_LowerLimit = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("AxisMoveMaxX")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dAxisMoveMaxX = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("AxisMoveMaxY")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dAxisMoveMaxY = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("AxisMoveMaxD")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dAxisMoveMaxD = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("AxisMoveMaxXLowerLimit")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dAxisMoveMaxX_LowerLimit = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("AxisMoveMaxYLowerLimit")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dAxisMoveMaxY_LowerLimit = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("AxisMoveMaxDLowerLimit")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dAxisMoveMaxD_LowerLimit = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("OmitRePickObjectEnable")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bOmitRePickObjectEnable = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("RePickOffsetMaxX")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dRePickOffsetMaxX = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("RePickOffsetMaxY")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dRePickOffsetMaxY = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("OmitRePickObjectEnable_MM")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bOmitRePickObjectEnable_MM = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("RePickOffsetMaxX_MM")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dRePickOffsetMaxX_MM = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("RePickOffsetMaxY_MM")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dRePickOffsetMaxY_MM = dVal;
			}

			//////////////////////////////////////////////////////////////////////////
			if (m_XMLConfigator.FindElem(_T("EnableCalibrateCheckByAxisMoveOption")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableCalibrateCheckByAxisMoveOption = (BOOL)k;
				// 暂时每次载入都将“启用轴移动拍照检查”不启用
				optionInfo.m_bEnableCalibrateCheckByAxisMoveOption = FALSE;
			}
			if (m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeX")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dCalibrateCheckAxisMoveRangeX = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeY")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dCalibrateCheckAxisMoveRangeY = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeD")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dCalibrateCheckAxisMoveRangeD = dVal;
			}
			//////////////////////////////////////////////////////////////////////////

			if (m_XMLConfigator.FindElem(_T("OffSetShowParam")))	// Level2
			{
				m_XMLConfigator.EnterElem();

				if(m_XMLConfigator.FindElem(_T("ShowOffsetTips")))	// Level3
				{
					int k=0;
					m_XMLConfigator.GetElemData(k);
					optionInfo.m_OffsetShowParam.m_bShowOffsetTips = (BOOL)k;
				}

				if(m_XMLConfigator.FindElem(_T("SetOffsetTip")))	// Level3
				{
					int k=0;
					m_XMLConfigator.GetElemData(k);
					optionInfo.m_OffsetShowParam.m_bSetOffsetTip = (BOOL)k;
				}

				m_XMLConfigator.LeaveElem();
			}

			if (m_XMLConfigator.FindElem(_T("TargetAutoCalibAlignMode")))
			{
				int k = 0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_eTarAutoCalibAlignMode = (TargetAutoCalibAlignMode)k;
			}

			if (m_XMLConfigator.FindElem(_T("ReadWriteAxisPosWithCmd")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bReadWriteAxisPosWithCmd = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("EnableMutiTarget")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableMutiTarget = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("TargetUseFixedVirtualCoordinates")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bTargetUseFixedVirtualCoordinates = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("CalibrateChangeXDirection")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bCalibrateChangeXDirection = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("CalibrateChangeYDirection")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bCalibrateChangeYDirection = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("CalibrateChangeDDirection")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bCalibrateChangeDDirection = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("EnableCalibrateCheckBySize")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableCalibrateCheckBySize = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("EnableRelevanceCheckBySize")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableRelevanceCheckBySize = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("EnableCalibrateCheckByFixedTargetAligner")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableCalibrateCheckByFixedTargetAligner = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("CalibSendRelativePos")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bCalibSendRelativePos = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("EnableMultiMarkMode")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableMultiMarkMode = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("EnableAlignOffsetMarkByAera")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableAlignOffsetMarkByAera = (BOOL)k;
			}


			if (m_XMLConfigator.FindElem(_T("EnableTargetAndObjectPositionVirtualMode")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableTargetAndObjectPositionVirtualMode = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("LastPickSetting")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bLastPickSetting = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("EnablePickPosUpdate")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnablePickPosUpdate = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("EnablePickSendRelativateAxis")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnablePickSendRelativateAxis = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("FAALAlignOneTimeTargetSeachSnap")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bFAALAlignOneTimeTargetSeachSnap = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ObjMulSearchPosXYPD")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bObjMulSearchPosXYPD = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("TargetAngleMulAlignerXYPD")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bTargetAngleMulAlignerXYPD = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("AskStagePosEachMove")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bAskStagePosEachMove = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("AlignOneTime")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bAlignOneTime = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("TargetPosSame")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bTargetPosSame = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ObjectPosSame")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bObjectPosSame = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("SaveAlignPos")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSaveAlignPos = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("EnableSearchCindidate")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableSearchCindidate = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("EnableSearchTimes")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSearchTimes = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("SearchTimes")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_nSearchTimes = k;
			}
			if (m_XMLConfigator.FindElem(_T("SearchDelayTime")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_nSearchDelayTime = k;
			}
			if (m_XMLConfigator.FindElem(_T("EnableSearchShutter")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableSearchShutter = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ManualAfTarSearchFail")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bManualAfTarSearchFail = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ManualAfObjSearchFail")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bManualAfObjSearchFail = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("AlignFinishClearSnapStatus")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bAlignFinishClearSnapStatus = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ExeObjectCheckModeWhenAlign")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bExeObjectCheckModeWhenAlign = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ExeTargetCheckModeWhenAlign")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bExeTargetCheckModeWhenAlign = (BOOL)k;
			}
			//m_bEnablePhotoLightCtrl
			if (m_XMLConfigator.FindElem(_T("EnablePhotoLightCtrl")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnablePhotoLightCtrl = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("EnableAlignBenchCenter")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableAlignBenchCenter = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("SetVisionManualSearchToPLC")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSetVisionManualSearchToPLC = (BOOL)k;
			}
			
			//BOOL m_bSetVisionManualSearchToPLC2;
			if (m_XMLConfigator.FindElem(_T("SetVisionManualSearchToPLC2")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bSetVisionManualSearchToPLC2 = (BOOL)k;
			}
			//int m_nVisionManualSearchToPlcAddre;
			if (m_XMLConfigator.FindElem(_T("VisionManualSearchToPlcAddre")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_nVisionManualSearchToPlcAddre = k;
			}


			if (m_XMLConfigator.FindElem(_T("VisionOnLineStatus")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bVisionOnLineStatus = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("EnableCommMultiCalibExtension")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableCommMultiCalibExtension = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ManualAfTarSearchFailShowButton")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bManualAfTarSearchFailShowButton = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ManualAfTarSearchFailShowButton")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bManualAfTarSearchFailShowButton = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ManualAfObjSearchFailShowButton")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bManualAfObjSearchFailShowButton = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("ShowFWEL")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bShowFWEL = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("ShowBend")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bShowBend = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("bTargetSeachSnapEverytime")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bTargetSeachSnapEverytime = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("nBendFIsAlignFinished")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_nBendFIsAlignFinished = k;
			}

			if (m_XMLConfigator.FindElem(_T("ShowEightShapeAlign")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bShowEightShapeAlign = (BOOL)k;
			}

			if (m_XMLConfigator.FindElem(_T("bEnableAngleCorrect")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_bEnableAngleCorrect = (BOOL)k;
			}
			if (m_XMLConfigator.FindElem(_T("NumberOfInspectResults")))
			{
				int nVal = 0;
				m_XMLConfigator.GetElemData(nVal);
				optionInfo.m_nNumberOfInspectResults = nVal;
			}
			if (m_XMLConfigator.FindElem(_T("dAngleCorrect")))
			{
				double dVal = 0.0;
				m_XMLConfigator.GetElemData(dVal);
				optionInfo.m_dAngleCorrect = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("FCHBSaveCSVHead")))
			{
				CString dVal=m_XMLConfigator.GetElemData();
				
				optionInfo.m_sFCHBSaveCSVHead = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("StepID")))
			{
				CString dVal=m_XMLConfigator.GetElemData();

				optionInfo.m_StepID = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("FoamSize")))
			{
				CString dVal=m_XMLConfigator.GetElemData();

				optionInfo.m_FoamSize = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("BendingR")))
			{
				CString dVal=m_XMLConfigator.GetElemData();

				optionInfo.m_BendingR = dVal;
			}

			if (m_XMLConfigator.FindElem(_T("FieldCount")))
			{
				CString dVal=m_XMLConfigator.GetElemData();

				optionInfo.m_FieldCount = dVal;
			}
			if (m_XMLConfigator.FindElem(_T("Production")))
			{
				CString dVal=m_XMLConfigator.GetElemData();

				optionInfo.m_Production = dVal;
			}


			if(TRUE == m_XMLConfigator.FindElem(_T("vnMulRegTriggerSet")))
			{
				m_XMLConfigator.EnterElem();
				{
					int nSize = 1;
					if (m_XMLConfigator.FindElem(_T("nSize")))
					{
						int k=0;
						m_XMLConfigator.GetElemData(k);
						nSize = k;
					}

					optionInfo.m_vnMulRegTriggerSet.resize(nSize);
					for (int it=0;it<nSize;it++)
					{
						strInfo.Format(_T("MulRegParam%d"),it+1);
						if(TRUE == m_XMLConfigator.FindElem(strInfo))
						{
							m_XMLConfigator.EnterElem(); 
							{
								optionInfo.m_vnMulRegTriggerSet[it].LoadModelFromFile(m_XMLConfigator);
							}
							m_XMLConfigator.LeaveElem();
						}
					}
				}
				m_XMLConfigator.LeaveElem();
			}
			SetPlatformOptionInfo(optionInfo);
			m_XMLConfigator.LeaveElem();
		}    	

		// 13. 平台布局配置
		if (m_XMLConfigator.FindElem(_T("PlatformLayoutInfo")))
		{
			m_XMLConfigator.EnterElem();
			CPlatformLayoutInfo layoutInfo;
			if (m_XMLConfigator.FindElem(_T("ViewDisplayLayout")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				layoutInfo.m_nViewLayoutType = k;
			}
			else
			{
				layoutInfo.m_nViewLayoutType = 0;
			}


			if (m_XMLConfigator.FindElem(_T("ViewVisionRunWidth")))
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				layoutInfo.m_nViewVisionRunWidth = k;
			}
			else
			{
				layoutInfo.m_nViewVisionRunWidth = 440;
			}
			SetPlatformLayoutInfo(layoutInfo);
			m_XMLConfigator.LeaveElem();
		}

		// 14. 权限管理
		if (TRUE == m_XMLConfigator.FindElem(_T("AuthorizeManagement")))
		{
			m_XMLConfigator.EnterElem(); 
			{
				m_pVisionASMConfig->LoadFromXML(m_XMLConfigator,m_pVisionASMConfig->m_cTreeAuthorizeManagement.children);
			}
			m_XMLConfigator.LeaveElem();
		}

		// 15. 定义指令流程
		if(TRUE == m_XMLConfigator.FindElem(_T("KeyenceCodeParam")))
		{
			m_XMLConfigator.EnterElem();
			{
				for (int it=0;it<MaxCodeNums;it++)
				{
					CString strInfo = _T("");
					strInfo.Format(_T("CodeParam%d"),it+1);

					if(TRUE == m_XMLConfigator.FindElem(strInfo))
					{
						m_XMLConfigator.EnterElem();
						{
							m_pVisionASMConfig->m_vKeyenceCodeParam.at(it).LoadModelFromFile(m_XMLConfigator);
						}
						m_XMLConfigator.LeaveElem();
					}

				}
			}
			m_XMLConfigator.LeaveElem();
		}

		m_XMLConfigator.LeaveElem(); // 退出全部访问   	

	}

	UpdateDataRecordTxtAddr();
	///////////////////////////////////////////////////////////////////////////

	if (!bXMLFound || !bXMLContentValid)
	{
		// 若平台详细配置XML文件不存在或者配置文件内容无效，则仅根据管理员配置的系统平台信息初始化m_pVisionASMConfig
		CString strErrInfo;
		if (!bXMLFound && !bXMLContentValid)
		{
			strErrInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_LOAD_XML_FILE_AND_INFO_FAILE);//.Format(_T("加载工位配置文件和信息失败！！！\n请选择“否”，然后退出系统，备份软件整个文件夹！\n如果选择“是”，则创建新的工位配置文件，重新设置参数。"));
		}
		else if (!bXMLFound)
		{
			strErrInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_LOAD_XML_FILE_FAILE);//.Format(_T("加载工位配置文件失败！！！\n请选择“否”，然后退出系统，备份软件整个文件夹！\n如果选择“是”，则创建新的工位配置文件，重新设置参数。"));
		}
		else if (!bXMLContentValid)
		{
			strErrInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_LOAD_XML_INFO_FAILE);//.Format(_T("加载工位配置信息失败！！！\n请选择“否”，然后退出系统，备份软件整个文件夹！\n如果选择“是”，则创建新的工位配置文件，重新设置参数。"));
		}
		else
		{
			strErrInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_LOAD_XML_INFO_FAILE);//.Format(_T("加载工位配置文件及信息失败！！！\n请选择“否”，然后退出系统，备份软件整个文件夹！\n如果选择“是”，则创建新的工位配置文件，重新设置参数。"));
		}

		int nMBReturn = AfxMessageBox(strErrInfo, MB_YESNO | MB_SYSTEMMODAL);
		if (nMBReturn == IDNO)
		{
			exit(0);
		}
	}


	// 按照更新后的m_pVisionASMConfig，保存配置文件
	SaveVisionASMConfig();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveVisionASMConfig()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pDlgSearchToolInfo)
	{
		return FALSE;
	}

	if (NULL == m_pAlignerTypeInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	// WorkStationConfig.xml
	// 根据当前m_pVisionASMConfig，重新写配置文件
	CString strXMLAddr = m_pVisionASMConfig->m_strConfigPath;	

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T("")); // 必须首先将m_XMLConfigator的内容清空
	m_XMLConfigator.ResetDocElemPos();

	BOOL bok1 = m_XMLConfigator.AddElem(_T("WorkStationConfig"));
	BOOL bok2 = m_XMLConfigator.EnterElem(); //1级目录打开

	/////////////////////////////////////////////////////////////
	// 1. 对位平台信息	
	if (ePlatformXYD == m_pPlatformInfo->m_ePlatformType)
	{
		CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pPlatformInfo); 

		m_XMLConfigator.AddElem(_T("PlatInfo"));				
		m_XMLConfigator.EnterElem(); //2级目录打开				

		// 平台类型
		m_XMLConfigator.AddElem(_T("PlatType"));
		m_XMLConfigator.SetElemData(platformXYDInfo->GetPlatformType());

		// X轴方向					
		m_XMLConfigator.AddElem(_T("XCType"));				
		m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformXCoordType);	

		// Y轴方向
		m_XMLConfigator.AddElem(_T("YCType"));					
		m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformYCoordType);				

		// D轴方向
		m_XMLConfigator.AddElem(_T("DCType"));				
		m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDCoordType);					 

		// DD马达驱动方式
		m_XMLConfigator.AddElem(_T("DDType"));					
		m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveType);					

		// DD马达直线驱动方式
		m_XMLConfigator.AddElem(_T("DDLineType"));					
		m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveLineType);

		// 平台旋转中心至电机轴中心的距离
		m_XMLConfigator.AddElem(_T("RLength"));					
		m_XMLConfigator.SetElemData(platformXYDInfo->m_dPlatformRotationLength);		

		m_XMLConfigator.LeaveElem(); 	//2级目录关闭				 
	}
	else
	{
		return FALSE;
	}	

	// 2. 中间对位平台信息
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	switch(sysPlatformInfo.m_eMidPlatformType)
	{
	case ePlatformXYD:
		{
			if (m_pVisionASMConfig->m_pMidPlatformInfo != NULL && ePlatformXYD == m_pVisionASMConfig->m_pMidPlatformInfo->GetPlatformType())
			{
				CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

				m_XMLConfigator.AddElem(_T("PlatXYDInfo"));				
				m_XMLConfigator.EnterElem(); //2级目录打开				

				// 平台类型
				m_XMLConfigator.AddElem(_T("PlatType"));
				m_XMLConfigator.SetElemData(platformXYDInfo->GetPlatformType());

				// X轴方向					
				m_XMLConfigator.AddElem(_T("XCType"));				
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformXCoordType);	

				// Y轴方向
				m_XMLConfigator.AddElem(_T("YCType"));					
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformYCoordType);				

				// D轴方向
				m_XMLConfigator.AddElem(_T("DCType"));				
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDCoordType);					 

				// DD马达驱动方式
				m_XMLConfigator.AddElem(_T("DDType"));					
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveType);					

				// DD马达直线驱动方式
				m_XMLConfigator.AddElem(_T("DDLineType"));					
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveLineType);

				// 平台旋转中心至电机轴中心的距离
				m_XMLConfigator.AddElem(_T("RLength"));					
				m_XMLConfigator.SetElemData(platformXYDInfo->m_dPlatformRotationLength);		

				m_XMLConfigator.LeaveElem(); 	//2级目录关闭				 
			}
			else
			{
				return FALSE;
			}	
		}
		break;

	case ePlatformXY1Y2:
		{
			if (m_pVisionASMConfig->m_pMidPlatformInfo != NULL && ePlatformXY1Y2 == m_pVisionASMConfig->m_pMidPlatformInfo->GetPlatformType())
			{
				CPlatformXY1Y2Info* platformXY1Y2Info = (CPlatformXY1Y2Info*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

				m_XMLConfigator.AddElem(_T("PlatXY1Y2Info"));			
				m_XMLConfigator.EnterElem();		

				// 平台类型
				m_XMLConfigator.AddElem(_T("PlatType"));
				m_XMLConfigator.SetElemData(sysPlatformInfo.m_eMidPlatformType);

				// SliderType(类型1、类型2)					
				m_XMLConfigator.AddElem(_T("SliderType"));
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_nPlatformUVWSliderType);

				// X轴坐标方向					
				m_XMLConfigator.AddElem(_T("XCType"));
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_nPlatformXCoordType);

				// Y1轴坐标方向
				m_XMLConfigator.AddElem(_T("Y1CType"));
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_nPlatformY1CoordType);	

				// Y2轴坐标方向
				m_XMLConfigator.AddElem(_T("Y2CType"));	
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_nPlatformY2CoordType);

				// X/Y1/Y2轴位置
				m_XMLConfigator.AddElem(_T("XPosX"));	
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_XPos.m_dPosX);				 

				m_XMLConfigator.AddElem(_T("XPosY"));		
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_XPos.m_dPosY);			 

				m_XMLConfigator.AddElem(_T("Y1PosX"));	
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_Y1Pos.m_dPosX);		 

				m_XMLConfigator.AddElem(_T("Y1PosY"));	
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_Y1Pos.m_dPosY);		 

				m_XMLConfigator.AddElem(_T("Y2PosX"));		
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_Y2Pos.m_dPosX);				 

				m_XMLConfigator.AddElem(_T("Y2PosY"));
				m_XMLConfigator.SetElemData(platformXY1Y2Info->m_Y2Pos.m_dPosY);		 


				m_XMLConfigator.LeaveElem(); 	
			}
			else
			{
				return FALSE;
			}
		}
		break;

	case ePlatformX1X2Y:
		{
			if (m_pVisionASMConfig->m_pMidPlatformInfo != NULL && ePlatformX1X2Y == m_pVisionASMConfig->m_pMidPlatformInfo->GetPlatformType())
			{
				CPlatformX1X2YInfo* platformX1X2YInfo = (CPlatformX1X2YInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

				m_XMLConfigator.AddElem(_T("PlatX1X2YInfo"));			
				m_XMLConfigator.EnterElem();		

				// 平台类型
				m_XMLConfigator.AddElem(_T("PlatType"));
				m_XMLConfigator.SetElemData(sysPlatformInfo.m_eMidPlatformType);

				// SliderType(类型1、类型2)					
				m_XMLConfigator.AddElem(_T("SliderType"));
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_nPlatformUVWSliderType);

				// X1轴坐标方向					
				m_XMLConfigator.AddElem(_T("X1CType"));	
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_nPlatformX1CoordType);	 

				// X2轴坐标方向
				m_XMLConfigator.AddElem(_T("X2CType"));	
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_nPlatformX2CoordType);

				// Y轴坐标方向
				m_XMLConfigator.AddElem(_T("YCType"));	
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_nPlatformYCoordType);					

				// X1/X2/Y轴的位置
				m_XMLConfigator.AddElem(_T("X1PosX"));	
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_X1Pos.m_dPosX);	 

				m_XMLConfigator.AddElem(_T("X1PosY"));	
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_X1Pos.m_dPosY);				 

				m_XMLConfigator.AddElem(_T("X2PosX"));		
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_X2Pos.m_dPosX);				 

				m_XMLConfigator.AddElem(_T("X2PosY"));		
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_X2Pos.m_dPosY);				 

				m_XMLConfigator.AddElem(_T("YPosX"));	
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_YPos.m_dPosX);				 

				m_XMLConfigator.AddElem(_T("YPosY"));	
				m_XMLConfigator.SetElemData(platformX1X2YInfo->m_YPos.m_dPosY);	 

				m_XMLConfigator.LeaveElem(); 	
			}
			else
			{
				return FALSE;
			}
		}
		break;

	default:
		{
			if (m_pVisionASMConfig->m_pMidPlatformInfo != NULL && ePlatformXYD == m_pVisionASMConfig->m_pMidPlatformInfo->GetPlatformType())
			{
				CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

				m_XMLConfigator.AddElem(_T("PlatXYDInfo"));				
				m_XMLConfigator.EnterElem(); //2级目录打开				

				// 平台类型
				m_XMLConfigator.AddElem(_T("PlatType"));
				m_XMLConfigator.SetElemData(platformXYDInfo->GetPlatformType());

				// X轴方向					
				m_XMLConfigator.AddElem(_T("XCType"));				
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformXCoordType);	

				// Y轴方向
				m_XMLConfigator.AddElem(_T("YCType"));					
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformYCoordType);				

				// D轴方向
				m_XMLConfigator.AddElem(_T("DCType"));				
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDCoordType);					 

				// DD马达驱动方式
				m_XMLConfigator.AddElem(_T("DDType"));					
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveType);					

				// DD马达直线驱动方式
				m_XMLConfigator.AddElem(_T("DDLineType"));					
				m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveLineType);

				// 平台旋转中心至电机轴中心的距离
				m_XMLConfigator.AddElem(_T("RLength"));					
				m_XMLConfigator.SetElemData(platformXYDInfo->m_dPlatformRotationLength);		

				m_XMLConfigator.LeaveElem(); 	//2级目录关闭				 
			}
			else
			{
				return FALSE;
			}	
		}
		break;
	}

	/////////////////////////////////////////////////////////////
	// 3. 相机平台信息
	int i=0;

	if(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamNum()!=m_pPlatformInfo->m_nPositionNum)
		return FALSE;

	if(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformType()!=m_pPlatformInfo->m_eCamPlatformType)
		return FALSE;

	m_XMLConfigator.AddElem(_T("CamPlatInfo"));	
	m_XMLConfigator.EnterElem();	//2级目录打开

	// 	// 相机个数	
	// 	m_XMLConfigator.AddElem(_T("CamNum"));
	// 	m_XMLConfigator.SetElemData(m_pPlatformInfo->m_nPositionNum);
	// 
	// 	// 相机拍照位置
	// 	if (1 == m_pPlatformInfo->m_nCamNum)
	// 	{		
	// 		m_XMLConfigator.FindElem(_T("PosNum"));
	// 		m_XMLConfigator.SetElemData(m_pPlatformInfo->m_nPositionNum);
	// 	}
	// 
	// 	// 安装方式
	// 	m_XMLConfigator.AddElem(_T("CamFixType"));
	// 	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformType());	

	CString strInfo;
	for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
	{
		// 相机轴
		strInfo.Format(_T("CamPlatInfo%d"),i);
		m_XMLConfigator.AddElem(strInfo);	

		m_XMLConfigator.EnterElem();     //3级目录打开 
		switch(m_pPlatformInfo->m_eCamPlatformType)
		{
		case eCamPlatformSepFix:
			break;
		case eCamPlatformSepX:
			{
				// 相机平台X轴方向
				m_XMLConfigator.AddElem(_T("CamXCType"));		
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamDirectX(i));
			}
			break;
		case eCamPlatformSepXY:
			{
				// 相机平台X轴方向
				m_XMLConfigator.AddElem(_T("CamXCType"));		
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamDirectX(i));


				// 相机平台Y轴方向
				m_XMLConfigator.AddElem(_T("CamYCType"));				
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamDirectY(i));
			}
			break;
		case eCamPlatformShareX:
			break;
		default:
			{
				return FALSE;
			}
			break;
		}	
		m_XMLConfigator.LeaveElem();	//3级目录关闭	


		// 相机轴所在平台轴
		strInfo.Format(_T("CamPlatAxisInfo%d"),i);
		m_XMLConfigator.AddElem(strInfo);

		m_XMLConfigator.EnterElem();     //3级目录打开 
		switch(m_pPlatformInfo->m_eCamPlatformType)
		{
		case eCamPlatformSepFix:
			break;
		case eCamPlatformSepX:
			{
				// 相机平台X轴方向
				m_XMLConfigator.AddElem(_T("CamPXCType"));		
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformAxisDirectX(i));
			}
			break;
		case eCamPlatformSepXY:
			{
				// 相机平台X轴方向
				m_XMLConfigator.AddElem(_T("CamPXCType"));		
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformAxisDirectX(i));


				// 相机平台Y轴方向
				m_XMLConfigator.AddElem(_T("CamPYCType"));				
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformAxisDirectY(i));
			}
			break;
		case eCamPlatformShareX:
			break;
		default:
			{
				return FALSE;
			}
			break;
		}	
		m_XMLConfigator.LeaveElem();	//3级目录关闭	

	}
	m_XMLConfigator.LeaveElem();//退出相机平台信息  //2级目录关闭

	/////////////////////////////////////////////////////////////
	// 4. 串口通信信息：串口或网口
	if (m_pVisionASMConfig->m_pCommParam->GetCommType()!=m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
	{
		return FALSE;
	}

	m_XMLConfigator.AddElem(_T("CommParamInfo"));
	m_XMLConfigator.EnterElem(); 
	{
		m_pVisionASMConfig->m_CommParamInfo.SaveModelToFile(m_XMLConfigator);
		switch(m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
		{
		case eSerial:
			{	
				vcSerialCommInfo* serialCommInfo = (vcSerialCommInfo*)m_pVisionASMConfig->m_pCommParam;

				m_XMLConfigator.AddElem(_T("SerialCommInfo"));		
				m_XMLConfigator.EnterElem(); //2级目录打开

				// 串口号，从0开始
				m_XMLConfigator.AddElem(_T("ComPort"));			
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_uiComPort);	

				// 波特率
				m_XMLConfigator.AddElem(_T("BaudRate"));			
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_uiBaudRate);		

				// 奇偶校验
				m_XMLConfigator.AddElem(_T("Parity"));			
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_Parity);

				// 停止位
				m_XMLConfigator.AddElem(_T("StopBits"));			
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_StopBits);

				// 数据位
				m_XMLConfigator.AddElem(_T("ByteSize"));			
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_uiDataBits);

				// 通信终止符
				m_XMLConfigator.AddElem(_T("CommEnd"));
				m_XMLConfigator.SetElemData(serialCommInfo->m_strCommStop); 			

				// 通信终止符
				m_XMLConfigator.AddElem(_T("CmdEnd"));			
				m_XMLConfigator.SetElemData(serialCommInfo->m_strCmdStop);

				// 寄存器首地址				
				m_XMLConfigator.AddElem(_T("RegAddress"));		
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_lRegAddress);

				m_XMLConfigator.AddElem(_T("TempRegAddress"));		
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_lTempRegAddress);


				// 单次最大写寄存器数量
				m_XMLConfigator.AddElem(_T("WriteRegMaxNum"));	
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_lWriteRegMaxNum);	

				// 单次最大读寄存器数量
				m_XMLConfigator.AddElem(_T("ReadRegMaxNum"));
				m_XMLConfigator.SetElemData((int)serialCommInfo->m_lReadRegMaxNum);	

				m_XMLConfigator.LeaveElem();  //2级目录关闭              

			}
			break;
		case eSocket:
			{			
				vcSocketCommInfo* socketCommInfo = (vcSocketCommInfo*)m_pVisionASMConfig->m_pCommParam;

				m_XMLConfigator.AddElem(_T("SocketCommInfo"));		
				m_XMLConfigator.EnterElem(); //2级目录打开

				// Socket类型，服务端或客户端
				m_XMLConfigator.AddElem(_T("SocketType"));		
				m_XMLConfigator.SetElemData(socketCommInfo->m_socketType);

				// IP地址 （安登奎）
				CString strInfo;
				if (!m_XMLConfigator.FindElem(_T("IP")))
				{
					m_XMLConfigator.AddElem("IP");
				}
				strInfo.Format(_T("%d.%d.%d.%d"), (int)socketCommInfo->m_byAddr[0], (int)socketCommInfo->m_byAddr[1],
					(int)socketCommInfo->m_byAddr[2], (int)socketCommInfo->m_byAddr[3]);
				m_XMLConfigator.SetElemData(strInfo);

				// 端口				
				m_XMLConfigator.AddElem(_T("IPPort"));		
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_uiPort);

				// 服务端监听个数
				m_XMLConfigator.AddElem(_T("ListenNum"));				
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_uiListenNum);

				// 通信终止符
				m_XMLConfigator.AddElem(_T("CommEnd"));				
				m_XMLConfigator.SetElemData(socketCommInfo->m_strCommStop);

				// 通信终止符
				m_XMLConfigator.AddElem(_T("CmdEnd"));				
				m_XMLConfigator.SetElemData(socketCommInfo->m_strCmdStop);

				// 寄存器首地址				
				m_XMLConfigator.AddElem(_T("RegAddress"));		
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_lRegAddress);

				m_XMLConfigator.AddElem(_T("TempRegAddress"));		
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_lTempRegAddress);

				// 单次最大写寄存器数量
				m_XMLConfigator.AddElem(_T("WriteRegMaxNum"));	
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_lWriteRegMaxNum);	

				// 单次最大读寄存器数量
				m_XMLConfigator.AddElem(_T("ReadRegMaxNum"));
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_lReadRegMaxNum);	

				if (!m_XMLConfigator.FindElem(_T("WZRegAddress")))
				{
					m_XMLConfigator.AddElem(_T("WZRegAddress"));
				}		
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_lWZRegAddress);

				if (!m_XMLConfigator.FindElem(_T("RegAddress3")))
				{
					m_XMLConfigator.AddElem(_T("RegAddress3"));
				}		
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_lRegAddress3);

				if (!m_XMLConfigator.FindElem(_T("EnableIDRaed")))
				{
					m_XMLConfigator.AddElem(_T("EnableIDRaed"));
				}		
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_bEnableIDRaed);

				if (!m_XMLConfigator.FindElem(_T("IDLength")))
				{
					m_XMLConfigator.AddElem(_T("IDLength"));
				}		
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_nIDLength);

				if (!m_XMLConfigator.FindElem(_T("IDInvert")))
				{
					m_XMLConfigator.AddElem(_T("IDInvert"));
				}		
				m_XMLConfigator.SetElemData((int)socketCommInfo->m_bIDInvert);

				if (!m_XMLConfigator.FindElem(_T("m_szGetName")))
				{
					m_XMLConfigator.AddElem(_T("m_szGetName"));
				}
				m_XMLConfigator.SetElemData(socketCommInfo->m_szGetName);


				if (!m_XMLConfigator.FindElem(_T("m_dWZW")))
				{
					m_XMLConfigator.AddElem(_T("m_dWZW"));
				}		
				m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZW);


				if (!m_XMLConfigator.FindElem(_T("m_dWZR")))
				{
					m_XMLConfigator.AddElem(_T("m_dWZR"));
				}		
				m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZR);
				if (!m_XMLConfigator.FindElem(_T("m_dWZY1")))
				{
					m_XMLConfigator.AddElem(_T("m_dWZY1"));
				}		
				m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZY1);
				if (!m_XMLConfigator.FindElem(_T("m_dWZY2")))
				{
					m_XMLConfigator.AddElem(_T("m_dWZY2"));
				}		
				m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZY2);
				if (!m_XMLConfigator.FindElem(_T("m_dWZY3")))
				{
					m_XMLConfigator.AddElem(_T("m_dWZY3"));
				}		
				m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZY3);

				if (!m_XMLConfigator.FindElem(_T("m_dWZZ1")))
				{
					m_XMLConfigator.AddElem(_T("m_dWZZ1"));
				}		
				m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZZ1);
				if (!m_XMLConfigator.FindElem(_T("m_dWZZ2")))
				{
					m_XMLConfigator.AddElem(_T("m_dWZZ2"));
				}		
				m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZZ2);
				if (!m_XMLConfigator.FindElem(_T("m_dWZZ3")))
				{
					m_XMLConfigator.AddElem(_T("m_dWZZ3"));
				}		
				m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZZ3);

				m_XMLConfigator.LeaveElem();	//2级目录关闭

			}
			break;
		default:
			{
				return FALSE; 
			}
			break;
		}
	}
	m_XMLConfigator.LeaveElem();


	// 5. 通信选项信息
	if (FALSE == m_XMLConfigator.FindElem(_T("CommOptionInfo")))
	{
		m_XMLConfigator.AddElem(_T("CommOptionInfo"));
	}
	m_XMLConfigator.EnterElem();

	CCommOptionInfo commOptionInfo;
	GetCommOptionInfoXML(commOptionInfo);

	if (FALSE == m_XMLConfigator.FindElem(_T("UsePlatformComm")))
	{
		m_XMLConfigator.AddElem(_T("UsePlatformComm"));
	}
	m_XMLConfigator.SetElemData((int)commOptionInfo.m_bUsePlatformComm);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommDelay")))
	{
		m_XMLConfigator.AddElem(_T("CommDelay"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommDelay);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommTimeout")))
	{
		m_XMLConfigator.AddElem(_T("CommTimeout"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommTimeOut);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommReSendTimes")))
	{
		m_XMLConfigator.AddElem(_T("CommReSendTimes"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommReSendTimes);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommXUnitExp")))
	{
		m_XMLConfigator.AddElem(_T("CommXUnitExp"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommXUnitExp);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommYUnitExp")))
	{
		m_XMLConfigator.AddElem(_T("CommYUnitExp"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommYUnitExp);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommDUnitExp")))
	{
		m_XMLConfigator.AddElem(_T("CommDUnitExp"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommDUnitExp);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommDataLenType")))
	{
		m_XMLConfigator.AddElem(_T("CommDataLenType"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommDataLenType);
	m_XMLConfigator.LeaveElem();


	// 6. 相机信息：以序列号采集
	m_XMLConfigator.AddElem(_T("CamParam"));
	m_XMLConfigator.EnterElem();  //2级目录打开

	for (i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{
		CameraParam cameraParam;
		strInfo.Format(_T("CamParam%d"),i);

		GetCameraParam(i,cameraParam);

		m_XMLConfigator.AddElem(strInfo);		
		m_XMLConfigator.EnterElem();  //3级目录打开

		// 相机DeviceID
		if(FALSE == m_XMLConfigator.FindElem(_T("DeviceID")))
		{
			m_XMLConfigator.AddElem(_T("DeviceID"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_strDeviceID);	

		// 相机序列号
		m_XMLConfigator.AddElem(_T("SN"));		
		m_XMLConfigator.SetElemData((int)cameraParam.m_lSerialNum);		

		// 相机视频模式
		m_XMLConfigator.AddElem(_T("Mode"));		
		m_XMLConfigator.SetElemData(cameraParam.m_nVideoMode);	 

		// 相机宽
		m_XMLConfigator.AddElem(_T("Width"));		
		m_XMLConfigator.SetElemData(cameraParam.m_nRawWidth);				 

		// 相机高
		m_XMLConfigator.AddElem(_T("Height"));		
		m_XMLConfigator.SetElemData(cameraParam.m_nRawHeight);				 

		// 自定义起始X
		m_XMLConfigator.AddElem(_T("X"));		
		m_XMLConfigator.SetElemData(cameraParam.m_nCustemStartX);				 

		// 自定义起始Y
		m_XMLConfigator.AddElem(_T("Y"));		
		m_XMLConfigator.SetElemData(cameraParam.m_nCustemStartY);				 

		// 自定义宽
		m_XMLConfigator.AddElem(_T("W"));		
		m_XMLConfigator.SetElemData(cameraParam.m_nCustemWidth);				 

		// 自定义高
		m_XMLConfigator.AddElem(_T("H"));		
		m_XMLConfigator.SetElemData(cameraParam.m_nCustemHeight);	

		// 帧率
		m_XMLConfigator.AddElem(_T("FrameRate"));		
		m_XMLConfigator.SetElemData(cameraParam.m_dFrameRate);				 

		// 白平衡
		m_XMLConfigator.AddElem(_T("WhiteBalanceRatioR"));		
		m_XMLConfigator.SetElemData(cameraParam.m_dWhiteBalanceRatioR);	
		m_XMLConfigator.AddElem(_T("WhiteBalanceRatioG"));		
		m_XMLConfigator.SetElemData(cameraParam.m_dWhiteBalanceRatioG);	
		m_XMLConfigator.AddElem(_T("WhiteBalanceRatioB"));		
		m_XMLConfigator.SetElemData(cameraParam.m_dWhiteBalanceRatioB);	

		// 曝光时间
		m_XMLConfigator.AddElem(_T("Shutter"));		
		m_XMLConfigator.SetElemData(cameraParam.m_dShutter);				 

		// 增益
		m_XMLConfigator.AddElem(_T("Gain"));		
		m_XMLConfigator.SetElemData(cameraParam.m_dGain);		 

		// GammaEnable
		m_XMLConfigator.AddElem(_T("GammaEnable"));		
		m_XMLConfigator.SetElemData(cameraParam.m_bGammaEnable);	

		// Gamma
		m_XMLConfigator.AddElem(_T("Gamma"));		
		m_XMLConfigator.SetElemData(cameraParam.m_dGamma);	

		//共享相机类型
		if(FALSE == m_XMLConfigator.FindElem(_T("ShareCamType")))
		{
			m_XMLConfigator.AddElem(_T("ShareCamType"));
		}
		m_XMLConfigator.SetElemData((int)cameraParam.m_eShareCamType);

		//共享相机数目
		if(FALSE == m_XMLConfigator.FindElem(_T("ShareCamNum")))
		{
			m_XMLConfigator.AddElem(_T("ShareCamNum"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nShareCamNum);

		for (int g=0;g<cameraParam.m_nShareCamNum;g++)
		{
			strInfo.Format(_T("ShareCam%d"),g);
			if(FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}
			m_XMLConfigator.EnterElem();
			if(FALSE == m_XMLConfigator.FindElem(_T("SharePlatformIndex")))
			{
				m_XMLConfigator.AddElem(_T("SharePlatformIndex"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_vShareCamInfo.at(g).m_nPlatformIndex);

			if(FALSE == m_XMLConfigator.FindElem(_T("ShareCameraIndex")))
			{
				m_XMLConfigator.AddElem(_T("ShareCameraIndex"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_vShareCamInfo.at(g).m_nCamIndex);
			m_XMLConfigator.LeaveElem();
		}

		m_XMLConfigator.LeaveElem();  //3级目录关闭
	}
	m_XMLConfigator.LeaveElem();  //2级目录关闭


	// 7. 位置信息：
	CPosInfo posInfo;
	m_XMLConfigator.AddElem(_T("PosInfo"));
	m_XMLConfigator.EnterElem();  //2级目录打开

	for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
	{
		strInfo.Format(_T("PosInfo%d"),i);

		posInfo = m_pVisionASMConfig->m_vPosInfo.at(i);

		m_XMLConfigator.AddElem(strInfo);		
		m_XMLConfigator.EnterElem();  //3级目录打开

		// 位置信息是否有效
		if(FALSE == m_XMLConfigator.FindElem(_T("PosEnable")))
		{
			m_XMLConfigator.AddElem(_T("PosEnable"));
		}
		m_XMLConfigator.SetElemData(posInfo.m_bPosEnable);	

		// 相机索引
		m_XMLConfigator.AddElem(_T("CamIndex"));		
		m_XMLConfigator.SetElemData(posInfo.m_nCamIndex);		

		m_XMLConfigator.LeaveElem();  //3级目录关闭
	}
	m_XMLConfigator.LeaveElem();  //2级目录关闭


	// 8. 图像显示参数	
	ImageRoi imageROI;
	m_XMLConfigator.AddElem(_T("CamDisp"));

	m_XMLConfigator.EnterElem();  //2级目录打开
	int nNum = m_pPlatformInfo->m_nPositionNum;
	for (i=0; i<nNum; i++)
	{
		strInfo.Format(_T("CamDisp%d"),i);

		imageROI = m_pVisionASMConfig->m_vImageRoi.at(i);

		m_XMLConfigator.AddElem(strInfo);			
		m_XMLConfigator.EnterElem();  //3级目录打开

		// 水平镜像
		m_XMLConfigator.AddElem(_T("MH"));				
		m_XMLConfigator.SetElemData(imageROI.m_bMirrorHoriz); 

		// 垂直镜像
		m_XMLConfigator.AddElem(_T("MV"));			
		m_XMLConfigator.SetElemData(imageROI.m_bMirrorVert);				 

		// 旋转
		m_XMLConfigator.AddElem(_T("R"));				
		m_XMLConfigator.SetElemData(imageROI.m_nRotation);

		// GammaCorrectionEnable
		m_XMLConfigator.AddElem(_T("GammaCorrectionEnable"));			 
		m_XMLConfigator.SetElemData(imageROI.m_bGammaCorrectionEnable);

		// Gamma
		m_XMLConfigator.AddElem(_T("Gamma"));				 
		m_XMLConfigator.SetElemData(imageROI.m_dGamma);

		// 十字中心是否可见
		if (FALSE == m_XMLConfigator.FindElem(_T("CrossVisible")))
		{
			m_XMLConfigator.AddElem(_T("CrossVisible"));
		}	
		m_XMLConfigator.SetElemData(imageROI.m_bCrossVisible);	

		// 十字中心X
		if (FALSE == m_XMLConfigator.FindElem(_T("CrossX")))
		{
			m_XMLConfigator.AddElem(_T("CrossX"));
		}	
		m_XMLConfigator.SetElemData(imageROI.m_dCrossX);	

		// 十字中心Y
		if (FALSE == m_XMLConfigator.FindElem(_T("CrossY")))
		{
			m_XMLConfigator.AddElem(_T("CrossY"));
		}
		m_XMLConfigator.SetElemData(imageROI.m_dCrossY);	


		m_XMLConfigator.LeaveElem();	//3级目录关闭

	}
	m_XMLConfigator.LeaveElem();  //2级目录关闭

	// 9. 中间数据记录
	m_XMLConfigator.AddElem(_T("LogParam"));
	m_XMLConfigator.EnterElem();  //2级目录打开

	m_XMLConfigator.AddElem(_T("ASEnabled"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo);

	m_XMLConfigator.AddElem(_T("CommEnabled"));		
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bCommunication);

	m_XMLConfigator.AddElem(_T("AlignToolLog"));		
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignToolLog);


	m_XMLConfigator.AddElem(_T("ImageName"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bImageName);	 

	m_XMLConfigator.AddElem(_T("SaveNGImage"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage);	 

	m_XMLConfigator.AddElem(_T("SaveFailedImageNum"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum);	 


	m_XMLConfigator.AddElem(_T("SaveAllImage"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage);	

	m_XMLConfigator.AddElem(_T("SaveAllImageNum"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum);	

	m_XMLConfigator.AddElem(_T("SaveAllImageType"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType);	


	m_XMLConfigator.AddElem(_T("ImageFormat"));		 
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_eImageFormat);

	m_XMLConfigator.AddElem(_T("ImageQuality"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nImageQuility);


	m_XMLConfigator.AddElem(_T("SaveVDBFile"));		 
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile);

	m_XMLConfigator.AddElem(_T("VDBNameByID"));		 
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bVDBNameByID);
	m_XMLConfigator.AddElem(_T("VDBImageQuality"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nVDBImageQuility);

	m_XMLConfigator.AddElem(_T("SaveVDBMaxNums"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums);

	m_XMLConfigator.AddElem(_T("SaveObjectSnapVDBFile"));		 
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveObjectSnapVDBFile);
	m_XMLConfigator.AddElem(_T("SaveTargetSnapVDBFile"));		 
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveTargetSnapVDBFile);
	m_XMLConfigator.AddElem(_T("SaveProcessSnapVDBFile"));		 
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveProcessSnapVDBFile);
	//m_bSaveInsepectResultVDBFile/
	m_XMLConfigator.AddElem(_T("SaveInsepectResultVDBFile"));		 
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveInsepectResultVDBFile);

	m_XMLConfigator.AddElem(_T("GuitextWeight"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_GuitextWeight);
	m_XMLConfigator.AddElem(_T("GuiLineWidth"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_GuiLineWidth);

	m_XMLConfigator.AddElem(_T("VBDImageType"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nVBDImageType);



	m_XMLConfigator.AddElem(_T("EnableCustomLogPath"));		 
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bCustomLogPath);

	m_XMLConfigator.AddElem(_T("bDataRecordTime"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime);	

	m_XMLConfigator.AddElem(_T("nDataRecordTimeNum"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nDataRecordTimeNum);

	m_XMLConfigator.AddElem(_T("StartHourRecordByDay"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nStartHourRecordByDay);

	m_XMLConfigator.AddElem(_T("dDiskSpaceMaxUsePercent"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_dDiskSpaceMaxUsePercent);

	m_XMLConfigator.AddElem(_T("strDataRecordPath"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath);


	// 	m_XMLConfigator.AddElem(_T("UseThreadSaveImageMode"));		 
	// 	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bThreadSaveImageMode);


	m_XMLConfigator.AddElem(_T("APEnabled"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision);	 

	m_XMLConfigator.AddElem(_T("ATEnabled"));		 
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerTime);	 

	m_XMLConfigator.AddElem(_T("MergeEnabled"));		
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bDataMerged);


	// 	m_XMLConfigator.AddElem(_T("AllImgDir"));		 
	// 	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_strSaveAllImgDataAddr);

	// 	m_XMLConfigator.AddElem(_T("LogEnabled"));	 
	// 	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bSysDataRecord);	 

	m_XMLConfigator.LeaveElem(); //退出中间数据记录   //2级目录关闭 

	// 10. 对位方式记录信息
	m_XMLConfigator.AddElem(_T("AlignerTypeInfo"));
	m_XMLConfigator.EnterElem();
	{
		//2vs2
		if (FALSE == m_XMLConfigator.FindElem(_T("Aligner2Vs2TypeInfo")))
		{
			m_XMLConfigator.AddElem(_T("Aligner2Vs2TypeInfo"));
		}
		m_XMLConfigator.EnterElem();
		vector<Aligner2Vs2TypeInfo>::iterator iterAligner2Vs2;
		for (iterAligner2Vs2 = m_pAlignerTypeInfo->m_vAligner2Vs2TypeInfo.begin();iterAligner2Vs2 != m_pAlignerTypeInfo->m_vAligner2Vs2TypeInfo.end();iterAligner2Vs2++)
		{
			if (FALSE == m_XMLConfigator.FindElem(iterAligner2Vs2->m_strAlignerName))
			{
				m_XMLConfigator.AddElem(iterAligner2Vs2->m_strAlignerName);
			}
			m_XMLConfigator.SetElemData(iterAligner2Vs2->m_bOpenAligner);	
		}
		m_XMLConfigator.LeaveElem();
		//3vs3
		if (FALSE == m_XMLConfigator.FindElem(_T("Aligner3Vs3TypeInfo")))
		{
			m_XMLConfigator.AddElem(_T("Aligner3Vs3TypeInfo"));
		}
		m_XMLConfigator.EnterElem();
		vector<Aligner3Vs3TypeInfo>::iterator iterAligner3Vs3;
		for (iterAligner3Vs3 = m_pAlignerTypeInfo->m_vAligner3Vs3TypeInfo.begin();iterAligner3Vs3 != m_pAlignerTypeInfo->m_vAligner3Vs3TypeInfo.end();iterAligner3Vs3++)
		{
			if (FALSE == m_XMLConfigator.FindElem(iterAligner3Vs3->m_strAlignerName))
			{
				m_XMLConfigator.AddElem(iterAligner3Vs3->m_strAlignerName);
			}
			m_XMLConfigator.SetElemData(iterAligner3Vs3->m_bOpenAligner);	
		}
		m_XMLConfigator.LeaveElem();
		//4vs4
		if (FALSE == m_XMLConfigator.FindElem(_T("Aligner4Vs4TypeInfo")))
		{
			m_XMLConfigator.AddElem(_T("Aligner4Vs4TypeInfo"));
		}
		m_XMLConfigator.EnterElem();
		vector<Aligner4Vs4TypeInfo>::iterator iterAligner4Vs4;
		for (iterAligner4Vs4 = m_pAlignerTypeInfo->m_vAligner4Vs4TypeInfo.begin();iterAligner4Vs4 != m_pAlignerTypeInfo->m_vAligner4Vs4TypeInfo.end();iterAligner4Vs4++)
		{
			if (FALSE == m_XMLConfigator.FindElem(iterAligner4Vs4->m_strAlignerName))
			{
				m_XMLConfigator.AddElem(iterAligner4Vs4->m_strAlignerName);
			}
			m_XMLConfigator.SetElemData(iterAligner4Vs4->m_bOpenAligner);	
		}
		m_XMLConfigator.LeaveElem();
	}
	m_XMLConfigator.LeaveElem();


	// 11. 定位工具记录
	m_XMLConfigator.AddElem(_T("SearchToolParam"));
	m_XMLConfigator.EnterElem();

	map<pair<int,CString>,BOOL>::iterator iterDlg;
	vector<map<pair<int,int>,BOOL>>::iterator iterSys;

	iterSys = m_pPlatformInfo->m_vmapSysSearchToolInfo.begin();

	for (;iterSys != m_pPlatformInfo->m_vmapSysSearchToolInfo.end();iterSys++)
	{
		if ((*iterSys).begin()->second)
		{
			for (iterDlg = m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.begin();iterDlg != m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.end();iterDlg++)
			{
				if ((*iterSys).begin()->first.first == iterDlg->first.first)
				{
					m_XMLConfigator.AddElem(iterDlg->first.second);	 
					m_XMLConfigator.SetElemData(iterDlg->second);
					break;
				}
			}
		}
	}
	m_XMLConfigator.LeaveElem();    //退出定位工具记录


	// 12. 平台数据记录
	m_XMLConfigator.AddElem(_T("PlatformOptionInfo"));
	m_XMLConfigator.EnterElem();

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (FALSE == m_XMLConfigator.FindElem(_T("SearchWithDistanceInspect")))
	{
		m_XMLConfigator.AddElem(_T("SearchWithDistanceInspect"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSearchWithDistanceInspect);

	if (FALSE == m_XMLConfigator.FindElem(_T("SendInsDistanceInSearchResult")))
	{
		m_XMLConfigator.AddElem(_T("SendInsDistanceInSearchResult"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSendInsDistanceInSearchResult);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetPicturePath")))
	{
		m_XMLConfigator.AddElem(_T("OffsetPicturePath"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_strOffsetPicturePath);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableDmCodeCalib")))
	{
		m_XMLConfigator.AddElem(_T("EnableDmCodeCalib"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableDmCodeCalib);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetInfoCommunicationModeInDifferentPC")))
	{
		m_XMLConfigator.AddElem(_T("TargetInfoCommunicationModeInDifferentPC"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nTarInfoCommModeInDiffPC);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableAlignAfterSearch")))
	{
		m_XMLConfigator.AddElem(_T("EnableAlignAfterSearch"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableAlignAfterSearch);

	if (FALSE == m_XMLConfigator.FindElem(_T("SendMulAlignResult")))
	{
		m_XMLConfigator.AddElem(_T("SendMulAlignResult"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSendMulAlignResult);

	if (FALSE == m_XMLConfigator.FindElem(_T("RecordCamFixMarkPos")))
	{
		m_XMLConfigator.AddElem(_T("RecordCamFixMarkPos"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bRecordCamFixMarkPos);

	if (FALSE == m_XMLConfigator.FindElem(_T("ObjectSearchExProduct")))
	{
		m_XMLConfigator.AddElem(_T("ObjectSearchExProduct"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bObjectSearchExProduct);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetSearchExProduct")))
	{
		m_XMLConfigator.AddElem(_T("TargetSearchExProduct"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetSearchExProduct);

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignExProduct")))
	{
		m_XMLConfigator.AddElem(_T("AlignExProduct"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAlignExProduct);

	if (FALSE == m_XMLConfigator.FindElem(_T("SaveCalibData")))
	{
		m_XMLConfigator.AddElem(_T("SaveCalibData"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSaveCalibData);

	if (FALSE == m_XMLConfigator.FindElem(_T("AutoCopyCalibData")))
	{
		m_XMLConfigator.AddElem(_T("AutoCopyCalibData"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAutoCopyCalibData);

	if (FALSE == m_XMLConfigator.FindElem(_T("bAutoCopyCalibDataExProduct")))
	{
		m_XMLConfigator.AddElem(_T("bAutoCopyCalibDataExProduct"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAutoCopyCalibDataExProduct);

	if (FALSE == m_XMLConfigator.FindElem(_T("SendAreaInspectSubResult")))
	{
		m_XMLConfigator.AddElem(_T("SendAreaInspectSubResult"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSendAreaInspectSubResult);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxX")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxX"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxX);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxY")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxY"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxY);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxD")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxD"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxD);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxXLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxXLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxX_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxYLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxYLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxY_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxDLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxDLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxD_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxX")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxX"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxX);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxY")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxY"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxY);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxD")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxD"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxD);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxXLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxXLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxX_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxYLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxYLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxY_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxDLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxDLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxD_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("OmitRePickObjectEnable")))
	{
		m_XMLConfigator.AddElem(_T("OmitRePickObjectEnable"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bOmitRePickObjectEnable);

	if (FALSE == m_XMLConfigator.FindElem(_T("RePickOffsetMaxX")))
	{
		m_XMLConfigator.AddElem(_T("RePickOffsetMaxX"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dRePickOffsetMaxX);

	if (FALSE == m_XMLConfigator.FindElem(_T("RePickOffsetMaxY")))
	{
		m_XMLConfigator.AddElem(_T("RePickOffsetMaxY"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dRePickOffsetMaxY);

	if (FALSE == m_XMLConfigator.FindElem(_T("OmitRePickObjectEnable_MM")))
	{
		m_XMLConfigator.AddElem(_T("OmitRePickObjectEnable_MM"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bOmitRePickObjectEnable_MM);

	if (FALSE == m_XMLConfigator.FindElem(_T("RePickOffsetMaxX_MM")))
	{
		m_XMLConfigator.AddElem(_T("RePickOffsetMaxX_MM"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dRePickOffsetMaxX_MM);

	if (FALSE == m_XMLConfigator.FindElem(_T("RePickOffsetMaxY_MM")))
	{
		m_XMLConfigator.AddElem(_T("RePickOffsetMaxY_MM"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dRePickOffsetMaxY_MM);

	//////////////////////////////////////////////////////////////////////////
	if (FALSE == m_XMLConfigator.FindElem(_T("EnableCalibrateCheckByAxisMoveOption")))
	{
		m_XMLConfigator.AddElem(_T("EnableCalibrateCheckByAxisMoveOption"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableCalibrateCheckByAxisMoveOption);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeX")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateCheckAxisMoveRangeX"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dCalibrateCheckAxisMoveRangeX);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeY")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateCheckAxisMoveRangeY"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dCalibrateCheckAxisMoveRangeY);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeD")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateCheckAxisMoveRangeD"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dCalibrateCheckAxisMoveRangeD);
	//////////////////////////////////////////////////////////////////////////

	if (FALSE == m_XMLConfigator.FindElem(_T("OffSetShowParam")))	//Level2
	{
		m_XMLConfigator.AddElem(_T("OffSetShowParam"));
	}
	m_XMLConfigator.EnterElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("ShowOffsetTips")))//Level3
	{
		m_XMLConfigator.AddElem(_T("ShowOffsetTips"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_OffsetShowParam.m_bShowOffsetTips);

	if (FALSE == m_XMLConfigator.FindElem(_T("SetOffsetTip")))//Level3
	{
		m_XMLConfigator.AddElem(_T("SetOffsetTip"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_OffsetShowParam.m_bSetOffsetTip);

	m_XMLConfigator.LeaveElem();



	if (FALSE == m_XMLConfigator.FindElem(_T("TargetAutoCalibAlignMode")))
	{
		m_XMLConfigator.AddElem(_T("TargetAutoCalibAlignMode"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_eTarAutoCalibAlignMode);

	if (FALSE == m_XMLConfigator.FindElem(_T("ReadWriteAxisPosWithCmd")))
	{
		m_XMLConfigator.AddElem(_T("ReadWriteAxisPosWithCmd"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bReadWriteAxisPosWithCmd);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableMutiTarget")))
	{
		m_XMLConfigator.AddElem(_T("EnableMutiTarget"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableMutiTarget);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetUseFixedVirtualCoordinates")))
	{
		m_XMLConfigator.AddElem(_T("TargetUseFixedVirtualCoordinates"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetUseFixedVirtualCoordinates);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateChangeXDirection")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateChangeXDirection"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibrateChangeXDirection);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateChangeYDirection")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateChangeYDirection"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibrateChangeYDirection);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateChangeDDirection")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateChangeDDirection"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibrateChangeDDirection);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableCalibrateCheckBySize")))
	{
		m_XMLConfigator.AddElem(_T("EnableCalibrateCheckBySize"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableCalibrateCheckBySize);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableRelevanceCheckBySize")))
	{
		m_XMLConfigator.AddElem(_T("EnableRelevanceCheckBySize"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableRelevanceCheckBySize);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableCalibrateCheckByFixedTargetAligner")))
	{
		m_XMLConfigator.AddElem(_T("EnableCalibrateCheckByFixedTargetAligner"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableCalibrateCheckByFixedTargetAligner);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibSendRelativePos")))
	{
		m_XMLConfigator.AddElem(_T("CalibSendRelativePos"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibSendRelativePos);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableMultiMarkMode")))
	{
		m_XMLConfigator.AddElem(_T("EnableMultiMarkMode"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableMultiMarkMode);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableAlignOffsetMarkByAera")))
	{
		m_XMLConfigator.AddElem(_T("EnableAlignOffsetMarkByAera"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableAlignOffsetMarkByAera);


	if (FALSE == m_XMLConfigator.FindElem(_T("EnableTargetAndObjectPositionVirtualMode")))
	{
		m_XMLConfigator.AddElem(_T("EnableTargetAndObjectPositionVirtualMode"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableTargetAndObjectPositionVirtualMode);

	if (FALSE == m_XMLConfigator.FindElem(_T("LastPickSetting")))
	{
		m_XMLConfigator.AddElem(_T("LastPickSetting"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bLastPickSetting);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnablePickPosUpdate")))
	{
		m_XMLConfigator.AddElem(_T("EnablePickPosUpdate"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnablePickPosUpdate);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnablePickSendRelativateAxis")))
	{
		m_XMLConfigator.AddElem(_T("EnablePickSendRelativateAxis"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnablePickSendRelativateAxis);

	if (FALSE == m_XMLConfigator.FindElem(_T("FAALAlignOneTimeTargetSeachSnap")))
	{
		m_XMLConfigator.AddElem(_T("FAALAlignOneTimeTargetSeachSnap"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bFAALAlignOneTimeTargetSeachSnap);

	if (FALSE == m_XMLConfigator.FindElem(_T("ObjMulSearchPosXYPD")))
	{
		m_XMLConfigator.AddElem(_T("ObjMulSearchPosXYPD"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bObjMulSearchPosXYPD);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetAngleMulAlignerXYPD")))
	{
		m_XMLConfigator.AddElem(_T("TargetAngleMulAlignerXYPD"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetAngleMulAlignerXYPD);


	if (FALSE == m_XMLConfigator.FindElem(_T("AskStagePosEachMove")))
	{
		m_XMLConfigator.AddElem(_T("AskStagePosEachMove"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAskStagePosEachMove);

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignOneTime")))
	{
		m_XMLConfigator.AddElem(_T("AlignOneTime"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAlignOneTime);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetPosSame")))
	{
		m_XMLConfigator.AddElem(_T("TargetPosSame"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetPosSame);

	if (FALSE == m_XMLConfigator.FindElem(_T("ObjectPosSame")))
	{
		m_XMLConfigator.AddElem(_T("ObjectPosSame"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bObjectPosSame);

	if (FALSE == m_XMLConfigator.FindElem(_T("SaveAlignPos")))
	{
		m_XMLConfigator.AddElem(_T("SaveAlignPos"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSaveAlignPos);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableSearchCindidate")))
	{
		m_XMLConfigator.AddElem(_T("EnableSearchCindidate"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableSearchCindidate);


	if (FALSE == m_XMLConfigator.FindElem(_T("EnableSearchTimes")))
	{
		m_XMLConfigator.AddElem(_T("EnableSearchTimes"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSearchTimes);

	if (FALSE == m_XMLConfigator.FindElem(_T("SearchTimes")))
	{
		m_XMLConfigator.AddElem(_T("SearchTimes"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nSearchTimes);
	if (FALSE == m_XMLConfigator.FindElem(_T("SearchDelayTime")))
	{
		m_XMLConfigator.AddElem(_T("SearchDelayTime"));
	}							 
	m_XMLConfigator.SetElemData(optionInfo.m_nSearchDelayTime);
	if (FALSE == m_XMLConfigator.FindElem(_T("EnableSearchShutter")))
	{
		m_XMLConfigator.AddElem(_T("EnableSearchShutter"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableSearchShutter);


	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfTarSearchFail")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfTarSearchFail"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfTarSearchFail);

	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfObjSearchFail")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfObjSearchFail"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfObjSearchFail);

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignFinishClearSnapStatus")))
	{
		m_XMLConfigator.AddElem(_T("AlignFinishClearSnapStatus"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAlignFinishClearSnapStatus);

	if (FALSE == m_XMLConfigator.FindElem(_T("ExeObjectCheckModeWhenAlign")))
	{
		m_XMLConfigator.AddElem(_T("ExeObjectCheckModeWhenAlign"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bExeObjectCheckModeWhenAlign);

	if (FALSE == m_XMLConfigator.FindElem(_T("ExeTargetCheckModeWhenAlign")))
	{
		m_XMLConfigator.AddElem(_T("ExeTargetCheckModeWhenAlign"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bExeTargetCheckModeWhenAlign);

	//m_bEnablePhotoLightCtrl
	if (FALSE == m_XMLConfigator.FindElem(_T("EnablePhotoLightCtrl")))
	{
		m_XMLConfigator.AddElem(_T("EnablePhotoLightCtrl"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnablePhotoLightCtrl);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableAlignBenchCenter")))
	{
		m_XMLConfigator.AddElem(_T("EnableAlignBenchCenter"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableAlignBenchCenter);

	if (FALSE == m_XMLConfigator.FindElem(_T("SetVisionManualSearchToPLC")))
	{
		m_XMLConfigator.AddElem(_T("SetVisionManualSearchToPLC"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSetVisionManualSearchToPLC);

	//BOOL m_bSetVisionManualSearchToPLC2;
	if (FALSE == m_XMLConfigator.FindElem(_T("SetVisionManualSearchToPLC2")))
	{
		m_XMLConfigator.AddElem(_T("SetVisionManualSearchToPLC2"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSetVisionManualSearchToPLC2);
	//int m_nVisionManualSearchToPlcAddre;
	if (FALSE == m_XMLConfigator.FindElem(_T("VisionManualSearchToPlcAddre")))
	{
		m_XMLConfigator.AddElem(_T("VisionManualSearchToPlcAddre"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nVisionManualSearchToPlcAddre);

	if (FALSE == m_XMLConfigator.FindElem(_T("VisionOnLineStatus")))
	{
		m_XMLConfigator.AddElem(_T("VisionOnLineStatus"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bVisionOnLineStatus);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableCommMultiCalibExtension")))
	{
		m_XMLConfigator.AddElem(_T("EnableCommMultiCalibExtension"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableCommMultiCalibExtension);

	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfTarSearchFailShowButton")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfTarSearchFailShowButton"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfTarSearchFailShowButton);

	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfTarSearchFailShowButton")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfTarSearchFailShowButton"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfTarSearchFailShowButton);

	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfObjSearchFailShowButton")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfObjSearchFailShowButton"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfObjSearchFailShowButton);

	if (FALSE == m_XMLConfigator.FindElem(_T("ShowFWEL")))
	{
		m_XMLConfigator.AddElem(_T("ShowFWEL"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bShowFWEL);

	if (FALSE == m_XMLConfigator.FindElem(_T("ShowBend")))
	{
		m_XMLConfigator.AddElem(_T("ShowBend"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bShowBend);


	if (FALSE == m_XMLConfigator.FindElem(_T("bTargetSeachSnapEverytime")))
	{
		m_XMLConfigator.AddElem(_T("bTargetSeachSnapEverytime"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetSeachSnapEverytime);

	if (FALSE == m_XMLConfigator.FindElem(_T("nBendFIsAlignFinished")))
	{
		m_XMLConfigator.AddElem(_T("nBendFIsAlignFinished"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nBendFIsAlignFinished);

	if (FALSE == m_XMLConfigator.FindElem(_T("ShowEightShapeAlign")))
	{
		m_XMLConfigator.AddElem(_T("ShowEightShapeAlign"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bShowEightShapeAlign);

	if (FALSE == m_XMLConfigator.FindElem(_T("bEnableAngleCorrect")))
	{
		m_XMLConfigator.AddElem(_T("bEnableAngleCorrect"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableAngleCorrect);

	if (FALSE == m_XMLConfigator.FindElem(_T("NumberOfInspectResults")))
	{
		m_XMLConfigator.AddElem(_T("NumberOfInspectResults"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nNumberOfInspectResults);

	if (FALSE == m_XMLConfigator.FindElem(_T("dAngleCorrect")))
	{
		m_XMLConfigator.AddElem(_T("dAngleCorrect"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAngleCorrect);

	if (FALSE == m_XMLConfigator.FindElem(_T("FCHBSaveCSVHead")))
	{
		m_XMLConfigator.AddElem(_T("FCHBSaveCSVHead"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_sFCHBSaveCSVHead);

	if (FALSE == m_XMLConfigator.FindElem(_T("StepID")))
	{
		m_XMLConfigator.AddElem(_T("StepID"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_StepID);

	if (FALSE == m_XMLConfigator.FindElem(_T("FoamSize")))
	{
		m_XMLConfigator.AddElem(_T("FoamSize"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_FoamSize);

	if (FALSE == m_XMLConfigator.FindElem(_T("BendingR")))
	{
		m_XMLConfigator.AddElem(_T("BendingR"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_BendingR);



	if (FALSE == m_XMLConfigator.FindElem(_T("FieldCount")))
	{
		m_XMLConfigator.AddElem(_T("FieldCount"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_FieldCount);

	if (FALSE == m_XMLConfigator.FindElem(_T("Production")))
	{
		m_XMLConfigator.AddElem(_T("Production"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_Production);


	if (FALSE == m_XMLConfigator.FindElem(_T("vnMulRegTriggerSet")))
	{
		m_XMLConfigator.AddElem(_T("vnMulRegTriggerSet"));
	}
	// vnMulRegTriggerSet
	m_XMLConfigator.EnterElem(); 
	{
		int nSize = optionInfo.m_vnMulRegTriggerSet.size();
		if (FALSE == m_XMLConfigator.FindElem(_T("nSize")))
		{
			m_XMLConfigator.AddElem(_T("nSize"));
		}
		m_XMLConfigator.SetElemData(nSize);

		for (int it=0;it<nSize;it++)
		{
			strInfo.Format(_T("MulRegParam%d"),it+1);
			if (FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}

			m_XMLConfigator.EnterElem(); 
			{
				optionInfo.m_vnMulRegTriggerSet[it].SaveModelToFile(m_XMLConfigator);
			}
			m_XMLConfigator.LeaveElem();
		}

	}
	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();

	// 13. 平台布局配置
	if (FALSE == m_XMLConfigator.FindElem(_T("PlatformLayoutInfo")))
	{
		m_XMLConfigator.AddElem(_T("PlatformLayoutInfo"));
	}
	m_XMLConfigator.EnterElem();

	CPlatformLayoutInfo layoutInfo;
	GetPlatformLayoutInfo(layoutInfo);

	if (FALSE == m_XMLConfigator.FindElem(_T("ViewDisplayLayout")))
	{
		m_XMLConfigator.AddElem(_T("ViewDisplayLayout"));
	}
	m_XMLConfigator.SetElemData((int)layoutInfo.m_nViewLayoutType);


	if (FALSE == m_XMLConfigator.FindElem(_T("ViewVisionRunWidth")))
	{
		m_XMLConfigator.AddElem(_T("ViewVisionRunWidth"));
	}
	m_XMLConfigator.SetElemData((int)layoutInfo.m_nViewVisionRunWidth);

	m_XMLConfigator.LeaveElem();

	// 14. 权限管理
	if (FALSE == m_XMLConfigator.FindElem(_T("AuthorizeManagement")))
	{
		m_XMLConfigator.AddElem(_T("AuthorizeManagement"));
	}
	m_XMLConfigator.EnterElem();
	{
		m_pVisionASMConfig->SaveToXML(m_XMLConfigator,m_pVisionASMConfig->m_cTreeAuthorizeManagement.children);
	}
	m_XMLConfigator.LeaveElem();

	// 15. 定义指令流程
	if (FALSE == m_XMLConfigator.FindElem(_T("KeyenceCodeParam")))
	{
		m_XMLConfigator.AddElem(_T("KeyenceCodeParam"));
	}
	m_XMLConfigator.EnterElem(); 
	{
		for (int it=0;it<MaxCodeNums;it++)
		{
			strInfo.Format(_T("CodeParam%d"),it+1);
			m_XMLConfigator.AddElem(strInfo);
			m_XMLConfigator.EnterElem(); 
			{
				m_pVisionASMConfig->m_vKeyenceCodeParam.at(it).SaveModelToFile(m_XMLConfigator)	;
			}
			m_XMLConfigator.LeaveElem();
		}
	}
	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem(); //退出全部访问  //1级目录关闭


	// 	// 查看系统记录所有图像数据时，其设定的存储文件夹是否存在
	// 	if (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage)
	// 	{
	// 		CString strAllImage = m_pVisionASMConfig->m_DataRecord.m_strSaveAllImgDataAddr;
	// 
	// 		CFileFind findFile;
	// 		BOOL IsDir = FALSE;
	// 		BOOL IsFild = findFile.FindFile(strAllImage);
	// 		while (IsFild)
	// 		{
	// 			IsFild = findFile.FindNextFile();
	// 			IsDir = findFile.IsDirectory();
	// 			if(IsDir) break;
	// 		}	
	// 		if (!IsDir)
	// 		{
	// 			if (!CreateDirectory(strAllImage, NULL))// 创建文件夹
	// 			{
	// 				CString str;
	// 				str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_IMAGE_SAVE_DIR_XXX_FAILED), strAllImage);
	// 				AfxMessageBox(str);
	// 
	// 				return FALSE;
	// 			}
	// 		}
	// 	}

	/////////////////////////////////////////////////////////////	 
	// 保存到XML文件中
	BOOL bRet = m_XMLConfigator.Save(m_pVisionASMConfig->m_strConfigPath);

	// 加载配置文件
	//	AlignXmlLog(_T("SaveVisionASMConfig"), _T("Save:")+m_pVisionASMConfig->m_strConfigPath, bRet);

	if (FALSE == bRet)
	{
		return FALSE;
	}     


	return TRUE;
}

// S1：加载/保存平台信息（平台类型及平台坐标系类型）
BOOL vcBaseVisionAlign::LoadPlatformInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadPlatformInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 释放对位平台占用内存
	DeletePlatformInfo();

	// 对位平台信息	
	m_pVisionASMConfig->m_pPlatformInfo = new CPlatformXYDInfo;

	CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pPlatformInfo); 

	if(TRUE == m_XMLConfigator.FindElem(_T("PlatInfo")))
	{
		m_XMLConfigator.EnterElem();

		int iCoordDirect = 1;
		int iValue;

		// 判断配置文件中的平台类型与实际类型是否相符
		if(TRUE == m_XMLConfigator.FindElem(_T("PlatType")))
		{
			m_XMLConfigator.GetElemData(iValue);

			if (iValue!=ePlatformXYD)
			{
				DeletePlatformInfo();
				return FALSE;
			}
		}
		else
		{
			DeletePlatformInfo();
			return FALSE;
		}					

		// X轴方向					
		if(TRUE == m_XMLConfigator.FindElem(_T("XCType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformXCoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			DeletePlatformInfo();
			return FALSE;
		}

		// Y轴方向
		if(TRUE == m_XMLConfigator.FindElem(_T("YCType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformYCoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			DeletePlatformInfo();
			return FALSE;
		}

		// D轴方向
		if(TRUE == m_XMLConfigator.FindElem(_T("DCType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformDCoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			DeletePlatformInfo();
			return FALSE;
		}

		// DD马达驱动方式
		if(TRUE == m_XMLConfigator.FindElem(_T("DDType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformDDriveType = (PlatformDDriveType)iCoordDirect; 
		}
		else
		{
			DeletePlatformInfo();
			return FALSE;
		}

		// DD马达直线驱动方式
		if(TRUE == m_XMLConfigator.FindElem(_T("DDLineType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformDDriveLineType = (PlatformDDriveLineType)iCoordDirect; 
		}

		// 平台旋转中心至电机轴中心的距离
		if(TRUE == m_XMLConfigator.FindElem(_T("RLength")))
		{
			m_XMLConfigator.GetElemData(platformXYDInfo->m_dPlatformRotationLength);				 
		}
		else
		{   
			DeletePlatformInfo();
			return FALSE;
		}

		m_pVisionASMConfig->m_pPlatformInfo = platformXYDInfo;					

		m_XMLConfigator.LeaveElem(); 					
	}
	else
	{
		DeletePlatformInfo();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SavePlatformInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig->m_pPlatformInfo)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));	

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SavePlatformInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();	

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SavePlatformInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}

	m_XMLConfigator.EnterElem();

	// 对位平台信息		
	CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pPlatformInfo); 

	if(FALSE == m_XMLConfigator.FindElem(_T("PlatInfo")))
	{
		m_XMLConfigator.AddElem(_T("PlatInfo"));
	}
	m_XMLConfigator.EnterElem();				

	// 平台类型
	if(FALSE == m_XMLConfigator.FindElem(_T("PlatType")))
	{
		m_XMLConfigator.AddElem(_T("PlatType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->GetPlatformType());

	// X轴方向					
	if(FALSE == m_XMLConfigator.FindElem(_T("XCType")))
	{
		m_XMLConfigator.AddElem(_T("XCType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformXCoordType);	

	// Y轴方向
	if(FALSE == m_XMLConfigator.FindElem(_T("YCType")))
	{
		m_XMLConfigator.AddElem(_T("YCType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformYCoordType);				

	// D轴方向
	if(FALSE == m_XMLConfigator.FindElem(_T("DCType")))
	{
		m_XMLConfigator.AddElem(_T("DCType"));
	}		
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDCoordType);					 

	// DD马达驱动方式
	if(FALSE == m_XMLConfigator.FindElem(_T("DDType")))
	{
		m_XMLConfigator.AddElem(_T("DDType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveType);	

	// DD马达直线驱动方式
	if(FALSE == m_XMLConfigator.FindElem(_T("DDLineType")))
	{
		m_XMLConfigator.AddElem(_T("DDLineType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveLineType);


	// 平台旋转中心至电机轴中心的距离
	if(FALSE == m_XMLConfigator.FindElem(_T("RLength")))
	{
		m_XMLConfigator.AddElem(_T("RLength"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_dPlatformRotationLength);		

	m_XMLConfigator.LeaveElem(); 

	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);
	AlignXmlLog(_T("SavePlatformInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);

	return bOK;
}

// S2：加载/保存平台信息（平台类型及平台坐标系类型）
BOOL vcBaseVisionAlign::LoadMidPlatformInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	BOOL bSuccess = FALSE;
	switch(m_pPlatformInfo->m_eMidPlatformType)
	{
	case ePlatformXYD:
		{
			bSuccess = LoadMidPlatformXYDInfo();
		}
		break;
		// 	case ePlatformXYPD:
		// 		{
		// 			bSuccess = LoadMidPlatformXYPDInfo();
		// 		}
		// 		break;
		// 	case ePlatformXD:
		// 		{
		// 			bSuccess = LoadMidPlatformXDInfo();
		// 		}
		// 		break;
		// 	case ePlatformXY:
		// 		{
		// 			bSuccess = LoadMidPlatformXYInfo();
		// 		}
		// 		break;
		// 	case ePlatformX:
		// 		{
		// 			bSuccess = LoadMidPlatformXInfo();
		// 		}
		// 		break;
		// 	case ePlatformXDPY:
		// 		{
		// 			bSuccess = LoadMidPlatformXDPYInfo();
		// 		}
		// 		break;
		// 	case ePlatformXDPY1:
		// 		{
		// 			bSuccess = LoadMidPlatformXDPY1Info();
		// 		}
		// 		break;
		// 	case ePlatformYD:
		// 		{
		// 			bSuccess = LoadMidPlatformYDInfo();
		// 		}
		// 		break;
	case ePlatformXY1Y2:
		{
			bSuccess = LoadMidPlatformXY1Y2Info();
		}
		break;
	case ePlatformX1X2Y:
		{
			bSuccess = LoadMidPlatformX1X2YInfo();
		}
		break;//ylq
	default:
		{
			bSuccess = LoadMidPlatformXYDInfo();
		}
	}

	return bSuccess;
}

BOOL vcBaseVisionAlign::SaveMidPlatformInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	BOOL bSuccess = FALSE;
	switch(m_pPlatformInfo->m_eMidPlatformType)
	{
	case ePlatformXYD:
		{
			bSuccess = SaveMidPlatformXYDInfo();
		}
		break;
		// 	case ePlatformXYPD:
		// 		{
		// 			bSuccess = SaveMidPlatformXYPDInfo();
		// 		}
		// 		break;
		// 	case ePlatformXD:
		// 		{
		// 			bSuccess = SaveMidPlatformXDInfo();
		// 		}
		// 		break;
		// 	case ePlatformXY:
		// 		{
		// 			bSuccess = SaveMidPlatformXYInfo();
		// 		}
		// 		break;
		// 	case ePlatformX:
		// 		{
		// 			bSuccess = SaveMidPlatformXInfo();
		// 		}
		// 		break;
		// 	case ePlatformXDPY:
		// 		{
		// 			bSuccess = SaveMidPlatformXDPYInfo();
		// 		}
		// 		break;
		// 	case ePlatformXDPY1:
		// 		{
		// 			bSuccess = SaveMidPlatformXDPY1Info();
		// 		}
		// 		break;
		// 	case ePlatformYD:
		// 		{
		// 			bSuccess = SaveMidPlatformYDInfo();
		// 		}
		// 		break;
	case ePlatformXY1Y2:
		{
			bSuccess = SaveMidPlatformXY1Y2Info();
		}
		break;
	case ePlatformX1X2Y:
		{
			bSuccess = SaveMidPlatformX1X2YInfo();
		}
	default:
		{
			bSuccess = SaveMidPlatformXYDInfo();
		}
	}

	return bSuccess;
}

BOOL vcBaseVisionAlign::LoadMidPlatformXYDInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadMidPlatformXYDInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 释放对位平台占用内存
	DeleteMidPlatformInfo();

	// 对位平台信息	
	m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo;

	CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

	if(TRUE == m_XMLConfigator.FindElem(_T("PlatXYDInfo")))
	{
		m_XMLConfigator.EnterElem();

		int iCoordDirect = 1;
		int iValue;

		// 判断配置文件中的平台类型与实际类型是否相符
		if(TRUE == m_XMLConfigator.FindElem(_T("PlatType")))
		{
			m_XMLConfigator.GetElemData(iValue);

			// 			if (iValue!=ePlatformXYD)
			// 			{
			// 				//DeleteMidPlatformInfo();
			// 				return FALSE;
			// 			}
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}					

		// X轴方向					
		if(TRUE == m_XMLConfigator.FindElem(_T("XCType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformXCoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// Y轴方向
		if(TRUE == m_XMLConfigator.FindElem(_T("YCType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformYCoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// D轴方向
		if(TRUE == m_XMLConfigator.FindElem(_T("DCType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformDCoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// DD马达驱动方式
		if(TRUE == m_XMLConfigator.FindElem(_T("DDType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformDDriveType = (PlatformDDriveType)iCoordDirect; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// DD马达直线驱动方式
		if(TRUE == m_XMLConfigator.FindElem(_T("DDLineType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXYDInfo->m_nPlatformDDriveLineType = (PlatformDDriveLineType)iCoordDirect; 
		}

		// 平台旋转中心至电机轴中心的距离
		if(TRUE == m_XMLConfigator.FindElem(_T("RLength")))
		{
			m_XMLConfigator.GetElemData(platformXYDInfo->m_dPlatformRotationLength);				 
		}
		else
		{   
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		m_XMLConfigator.LeaveElem(); 					
	}
	else
	{
		//DeleteMidPlatformInfo();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveMidPlatformXYDInfo() 
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig->m_pMidPlatformInfo)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));	

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveMidPlatformXYDInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();	

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SaveMidPlatformXYDInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}

	m_XMLConfigator.EnterElem();

	// 对位平台信息		
	CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

	if(FALSE == m_XMLConfigator.FindElem(_T("PlatXYDInfo")))
	{
		m_XMLConfigator.AddElem(_T("PlatXYDInfo"));
	}
	m_XMLConfigator.EnterElem();				

	// 平台类型
	if(FALSE == m_XMLConfigator.FindElem(_T("PlatType")))
	{
		m_XMLConfigator.AddElem(_T("PlatType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->GetPlatformType());

	// X轴方向					
	if(FALSE == m_XMLConfigator.FindElem(_T("XCType")))
	{
		m_XMLConfigator.AddElem(_T("XCType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformXCoordType);	

	// Y轴方向
	if(FALSE == m_XMLConfigator.FindElem(_T("YCType")))
	{
		m_XMLConfigator.AddElem(_T("YCType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformYCoordType);				

	// D轴方向
	if(FALSE == m_XMLConfigator.FindElem(_T("DCType")))
	{
		m_XMLConfigator.AddElem(_T("DCType"));
	}		
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDCoordType);					 

	// DD马达驱动方式
	if(FALSE == m_XMLConfigator.FindElem(_T("DDType")))
	{
		m_XMLConfigator.AddElem(_T("DDType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveType);	

	// DD马达直线驱动方式
	if(FALSE == m_XMLConfigator.FindElem(_T("DDLineType")))
	{
		m_XMLConfigator.AddElem(_T("DDLineType"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_nPlatformDDriveLineType);

	// 平台旋转中心至电机轴中心的距离
	if(FALSE == m_XMLConfigator.FindElem(_T("RLength")))
	{
		m_XMLConfigator.AddElem(_T("RLength"));
	}
	m_XMLConfigator.SetElemData(platformXYDInfo->m_dPlatformRotationLength);		

	m_XMLConfigator.LeaveElem(); 

	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveMidPlatformXYDInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadMidPlatformXY1Y2Info()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadMidPlatformXY1Y2Info"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 释放对位平台占用内存
	DeleteMidPlatformInfo();

	// 对位平台信息	
	m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXY1Y2Info;

	CPlatformXY1Y2Info* platformXY1Y2Info = (CPlatformXY1Y2Info*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

	if(TRUE == m_XMLConfigator.FindElem(_T("PlatXY1Y2Info")))
	{
		m_XMLConfigator.EnterElem();

		int iCoordDirect = 0;
		int iValue;

		// 判断配置文件中的平台类型与实际类型是否相符
		if(TRUE == m_XMLConfigator.FindElem(_T("PlatType")))
		{
			m_XMLConfigator.GetElemData(iValue);

			if (iValue!=ePlatformXY1Y2)
			{
				//DeleteMidPlatformInfo();
				return FALSE;
			}
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}	

		// SliderType(类型1、类型2)					
		if(TRUE == m_XMLConfigator.FindElem(_T("SliderType")))
		{
			m_XMLConfigator.GetElemData(iValue);
			platformXY1Y2Info->m_nPlatformUVWSliderType = (PlatformUVWSliderType)iValue; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}


		// X轴坐标方向					
		if(TRUE == m_XMLConfigator.FindElem(_T("XCType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXY1Y2Info->m_nPlatformXCoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// Y1轴坐标方向
		if(TRUE == m_XMLConfigator.FindElem(_T("Y1CType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXY1Y2Info->m_nPlatformY1CoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			//DeletePlatformInfo();
			return FALSE;
		}

		// Y2轴坐标方向
		if(TRUE == m_XMLConfigator.FindElem(_T("Y2CType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformXY1Y2Info->m_nPlatformY2CoordType = (PlatformAxisDirectType)iCoordDirect; 
		}		
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// X/Y1/Y2轴位置
		if(TRUE == m_XMLConfigator.FindElem(_T("XPosX")))
		{
			m_XMLConfigator.GetElemData(platformXY1Y2Info->m_XPos.m_dPosX);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("XPosY")))
		{
			m_XMLConfigator.GetElemData(platformXY1Y2Info->m_XPos.m_dPosY);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("Y1PosX")))
		{
			m_XMLConfigator.GetElemData(platformXY1Y2Info->m_Y1Pos.m_dPosX);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("Y1PosY")))
		{
			m_XMLConfigator.GetElemData(platformXY1Y2Info->m_Y1Pos.m_dPosY);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("Y2PosX")))
		{
			m_XMLConfigator.GetElemData(platformXY1Y2Info->m_Y2Pos.m_dPosX);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("Y2PosY")))
		{
			m_XMLConfigator.GetElemData(platformXY1Y2Info->m_Y2Pos.m_dPosY);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		m_XMLConfigator.LeaveElem(); 
	}
	else
	{
		//DeleteMidPlatformInfo();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveMidPlatformXY1Y2Info() 
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig->m_pMidPlatformInfo)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));	

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveMidPlatformXY1Y2Info"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();	

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SaveMidPlatformXY1Y2Info"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}	
	m_XMLConfigator.EnterElem();

	// 对位平台信息		
	CPlatformXY1Y2Info* platformXY1Y2Info = (CPlatformXY1Y2Info*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

	if(FALSE == m_XMLConfigator.FindElem(_T("PlatXY1Y2Info")))
	{
		m_XMLConfigator.AddElem(_T("PlatXY1Y2Info"));
	}
	m_XMLConfigator.EnterElem();		

	// 平台类型
	if(FALSE == m_XMLConfigator.FindElem(_T("PlatType")))
	{
		m_XMLConfigator.AddElem(_T("PlatType"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->GetPlatformType());

	// SliderType（类型1、类型2）					
	if(FALSE == m_XMLConfigator.FindElem(_T("SliderType")))
	{
		m_XMLConfigator.AddElem(_T("SliderType"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_nPlatformUVWSliderType);

	// X轴坐标方向					
	if(FALSE == m_XMLConfigator.FindElem(_T("XCType")))
	{
		m_XMLConfigator.AddElem(_T("XCType"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_nPlatformXCoordType);

	// Y1轴坐标方向
	if(FALSE == m_XMLConfigator.FindElem(_T("Y1CType")))
	{
		m_XMLConfigator.AddElem(_T("Y1CType"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_nPlatformY1CoordType);	

	// Y2轴坐标方向
	if(FALSE == m_XMLConfigator.FindElem(_T("Y2CType")))
	{
		m_XMLConfigator.AddElem(_T("Y2CType"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_nPlatformY2CoordType);

	// X/Y1/Y2轴位置
	if(FALSE == m_XMLConfigator.FindElem(_T("XPosX")))
	{
		m_XMLConfigator.AddElem(_T("XPosX"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_XPos.m_dPosX);				 

	if(FALSE == m_XMLConfigator.FindElem(_T("XPosY")))
	{
		m_XMLConfigator.AddElem(_T("XPosY"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_XPos.m_dPosY);			 

	if(FALSE == m_XMLConfigator.FindElem(_T("Y1PosX")))
	{
		m_XMLConfigator.AddElem(_T("Y1PosX"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_Y1Pos.m_dPosX);		 

	if(FALSE == m_XMLConfigator.FindElem(_T("Y1PosY")))
	{
		m_XMLConfigator.AddElem(_T("Y1PosY"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_Y1Pos.m_dPosY);		 

	if(FALSE == m_XMLConfigator.FindElem(_T("Y2PosX")))
	{
		m_XMLConfigator.AddElem(_T("Y2PosX"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_Y2Pos.m_dPosX);				 

	if (FALSE == m_XMLConfigator.FindElem(_T("Y2PosY")))
	{
		m_XMLConfigator.AddElem(_T("Y2PosY"));
	}
	m_XMLConfigator.SetElemData(platformXY1Y2Info->m_Y2Pos.m_dPosY);													

	m_XMLConfigator.LeaveElem(); 

	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveMidPlatformXY1Y2Info"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadMidPlatformX1X2YInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadMidPlatformX1X2YInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 释放对位平台占用内存
	DeleteMidPlatformInfo();

	// 对位平台信息	
	m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformX1X2YInfo;

	CPlatformX1X2YInfo* platformX1X2YInfo = (CPlatformX1X2YInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

	if(TRUE == m_XMLConfigator.FindElem(_T("PlatX1X2YInfo")))
	{
		m_XMLConfigator.EnterElem();

		int iCoordDirect = 0;
		int iValue;

		// 判断配置文件中的平台类型与实际类型是否相符
		if(TRUE == m_XMLConfigator.FindElem(_T("PlatType")))
		{
			m_XMLConfigator.GetElemData(iValue);

			if (iValue!=ePlatformX1X2Y)
			{
				//DeleteMidPlatformInfo();
				return FALSE;
			}
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}			

		// SliderType(类型1、类型2)					
		if(TRUE == m_XMLConfigator.FindElem(_T("SliderType")))
		{
			m_XMLConfigator.GetElemData(iValue);
			platformX1X2YInfo->m_nPlatformUVWSliderType = (PlatformUVWSliderType)iValue; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// X1轴坐标方向					
		if(TRUE == m_XMLConfigator.FindElem(_T("X1CType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformX1X2YInfo->m_nPlatformX1CoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// X2轴坐标方向
		if(TRUE == m_XMLConfigator.FindElem(_T("X2CType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformX1X2YInfo->m_nPlatformX2CoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// Y轴坐标方向
		if(TRUE == m_XMLConfigator.FindElem(_T("YCType")))
		{
			m_XMLConfigator.GetElemData(iCoordDirect);
			platformX1X2YInfo->m_nPlatformYCoordType = (PlatformAxisDirectType)iCoordDirect; 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		// X1/X2/Y轴的位置
		if(TRUE == m_XMLConfigator.FindElem(_T("X1PosX")))
		{
			m_XMLConfigator.GetElemData(platformX1X2YInfo->m_X1Pos.m_dPosX);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("X1PosY")))
		{
			m_XMLConfigator.GetElemData(platformX1X2YInfo->m_X1Pos.m_dPosY);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("X2PosX")))
		{
			m_XMLConfigator.GetElemData(platformX1X2YInfo->m_X2Pos.m_dPosX);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("X2PosY")))
		{
			m_XMLConfigator.GetElemData(platformX1X2YInfo->m_X2Pos.m_dPosY);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("YPosX")))
		{
			m_XMLConfigator.GetElemData(platformX1X2YInfo->m_YPos.m_dPosX);				 
		}
		else
		{
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("YPosY")))
		{
			m_XMLConfigator.GetElemData(platformX1X2YInfo->m_YPos.m_dPosY);				 
		}
		else
		{	
			//DeleteMidPlatformInfo();
			return FALSE;
		}

		m_XMLConfigator.LeaveElem(); 
	}
	else
	{
		//DeleteMidPlatformInfo();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveMidPlatformX1X2YInfo()	
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig->m_pMidPlatformInfo)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));	

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveMidPlatformX1X2YInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();	

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SaveMidPlatformX1X2YInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}	
	m_XMLConfigator.EnterElem();

	// 对位平台信息		
	CPlatformX1X2YInfo* platformX1X2YInfo = (CPlatformX1X2YInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo); 

	if(FALSE == m_XMLConfigator.FindElem(_T("PlatX1X2YInfo")))
	{
		m_XMLConfigator.AddElem(_T("PlatX1X2YInfo"));
	}	
	m_XMLConfigator.EnterElem();		

	// 平台类型
	if (FALSE == m_XMLConfigator.FindElem(_T("PlatType")))
	{
		m_XMLConfigator.AddElem(_T("PlatType"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->GetPlatformType());

	// SliderType(类型1、类型2)					
	if(FALSE == m_XMLConfigator.FindElem(_T("SliderType")))
	{
		m_XMLConfigator.AddElem(_T("SliderType"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_nPlatformUVWSliderType);	

	// X1轴坐标方向					
	if(FALSE == m_XMLConfigator.FindElem(_T("X1CType")))
	{
		m_XMLConfigator.AddElem(_T("X1CType"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_nPlatformX1CoordType);	

	// X2轴坐标方向
	if(FALSE == m_XMLConfigator.FindElem(_T("X2CType")))
	{
		m_XMLConfigator.AddElem(_T("X2CType"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_nPlatformX2CoordType);

	// Y轴坐标方向
	if (FALSE == m_XMLConfigator.FindElem(_T("YCType")))
	{
		m_XMLConfigator.AddElem(_T("YCType"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_nPlatformYCoordType);

	// X1/X2/Y轴的位置
	if(FALSE == m_XMLConfigator.FindElem(_T("X1PosX")))
	{
		m_XMLConfigator.AddElem(_T("X1PosX"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_X1Pos.m_dPosX);				 

	if (FALSE ==	m_XMLConfigator.FindElem(_T("X1PosY")))
	{
		m_XMLConfigator.AddElem(_T("X1PosY"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_X1Pos.m_dPosY);				 

	if(FALSE == m_XMLConfigator.FindElem(_T("X2PosX")))
	{
		m_XMLConfigator.AddElem(_T("X2PosX"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_X2Pos.m_dPosX);				 

	if(FALSE == m_XMLConfigator.FindElem(_T("X2PosY")))
	{
		m_XMLConfigator.AddElem(_T("X2PosY"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_X2Pos.m_dPosY);				 

	if(FALSE == m_XMLConfigator.FindElem(_T("YPosX")))
	{
		m_XMLConfigator.AddElem(_T("YPosX"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_YPos.m_dPosX);				 

	if(FALSE == m_XMLConfigator.FindElem(_T("YPosY")))
	{
		m_XMLConfigator.AddElem(_T("YPosY"));
	}
	m_XMLConfigator.SetElemData(platformX1X2YInfo->m_YPos.m_dPosY);			 

	m_XMLConfigator.LeaveElem(); 

	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveMidPlatformX1X2YInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadCamPlatformInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}


	CString strInfo = _T("");
	CString strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadCamPlatformInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 相机平台信息	
	if(TRUE == m_XMLConfigator.FindElem(_T("CamPlatInfo")))
	{
		DeleteCameraPlatformInfo();

		m_pVisionASMConfig->m_pCamPlatformInfo = new CCamPlatformInfo;

		m_XMLConfigator.EnterElem();			

		// 		// 判断配置文件中的相机个数与实际个数是否相符		
		// 		if(TRUE == m_XMLConfigator.FindElem(_T("CamNum")))
		// 		{
		// 			m_XMLConfigator.GetElemData(iValue1);
		// 			if (iValue1!=m_pPlatformInfo->m_nPositionNum)
		// 			{
		// 				DeleteCameraPlatformInfo();		
		// 				return FALSE;
		// 			}				
		// 		}
		// 		else
		// 		{
		// 			DeleteCameraPlatformInfo();		
		// 			return FALSE;
		// 		}
		// 
		// 		// 判断配置文件中的安装方式与实际安装方式是否相符
		// 		if(TRUE == m_XMLConfigator.FindElem(_T("CamFixType")))
		// 		{
		// 			m_XMLConfigator.GetElemData(iValue2);
		// 
		// 			if (iValue2!=m_pPlatformInfo->m_eCamPlatformType)
		// 			{
		// 				DeleteCameraPlatformInfo();			
		// 				return FALSE;
		// 			}	
		// 		}
		// 		else
		// 		{
		// 			DeleteCameraPlatformInfo();		
		// 			return FALSE;		
		// 		}

		m_pVisionASMConfig->m_pCamPlatformInfo->SetCamNumPlatformType(m_pPlatformInfo->m_nPositionNum,m_pPlatformInfo->m_eCamPlatformType);		

		for (int i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
		{
			// 相机轴
			strInfo.Format(_T("CamPlatInfo%d"),i);
			if(TRUE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.EnterElem();         

				int iCamDirect = 0;

				switch(m_pPlatformInfo->m_eCamPlatformType)
				{
				case eCamPlatformSepFix:
					break;
				case eCamPlatformSepX:
					{
						// 相机平台X轴方向
						if (m_XMLConfigator.FindElem(_T("CamXCType")))
						{
							m_XMLConfigator.GetElemData(iCamDirect);
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectX(i, (PlatformAxisDirectType)(iCamDirect));
						}
						else
						{
							DeleteCameraPlatformInfo();		
							return FALSE;	
						}

					}
					break;
				case eCamPlatformSepXY:
					{
						// 相机平台X轴方向
						if (m_XMLConfigator.FindElem(_T("CamXCType")))
						{
							m_XMLConfigator.GetElemData(iCamDirect);
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectX(i, (PlatformAxisDirectType)(iCamDirect));
						}
						else
						{
							DeleteCameraPlatformInfo();		
							return FALSE;	
						}

						// 相机平台Y轴方向
						if (m_XMLConfigator.FindElem(_T("CamYCType")))
						{
							m_XMLConfigator.GetElemData(iCamDirect);
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamDirectY(i, (PlatformAxisDirectType)(iCamDirect));
						}
						else
						{
							DeleteCameraPlatformInfo();		
							return FALSE;	
						}					
					}
					break;
				case eCamPlatformShareX:
					break;
				default:
					{
						DeleteCameraPlatformInfo();	
						return FALSE;
					}
					break;
				}		

				m_XMLConfigator.LeaveElem();
			}
			else
			{		
				DeleteCameraPlatformInfo();	
				return FALSE;
			}

			// 相机所在平台轴
			strInfo.Format(_T("CamPlatAxisInfo%d"),i);
			if(TRUE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.EnterElem();         

				int iCamDirect = 0;

				switch(m_pPlatformInfo->m_eCamPlatformType)
				{
				case eCamPlatformSepFix:
					break;
				case eCamPlatformSepX:
					{
						// 相机平台X轴方向
						if (m_XMLConfigator.FindElem(_T("CamPXCType")))
						{
							m_XMLConfigator.GetElemData(iCamDirect);
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectX(i, (PlatformAxisDirectType)(iCamDirect));
						}
						else
						{
							DeleteCameraPlatformInfo();		
							return FALSE;	
						}

					}
					break;
				case eCamPlatformSepXY:
					{
						// 相机平台X轴方向
						if (m_XMLConfigator.FindElem(_T("CamPXCType")))
						{
							m_XMLConfigator.GetElemData(iCamDirect);
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectX(i, (PlatformAxisDirectType)(iCamDirect));
						}
						else
						{
							DeleteCameraPlatformInfo();		
							return FALSE;	
						}

						// 相机平台Y轴方向
						if (m_XMLConfigator.FindElem(_T("CamPYCType")))
						{
							m_XMLConfigator.GetElemData(iCamDirect);
							m_pVisionASMConfig->m_pCamPlatformInfo->SetCamPlatformAxisDirectY(i, (PlatformAxisDirectType)(iCamDirect));
						}
						else
						{
							DeleteCameraPlatformInfo();		
							return FALSE;	
						}					
					}
					break;
				case eCamPlatformShareX:
					break;
				default:
					DeleteCameraPlatformInfo();	
					return FALSE;
					break;
				}		

				m_XMLConfigator.LeaveElem();
			}
			else
			{		
				DeleteCameraPlatformInfo();	
				return FALSE;
			}

		}

		m_XMLConfigator.LeaveElem();
	}
	else
	{
		m_XMLConfigator.LeaveElem();
		return FALSE;		
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveCamPlatformInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig->m_pCamPlatformInfo)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));	

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveCamPlatformInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SaveCamPlatformInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}


	m_XMLConfigator.EnterElem();
	if(FALSE == m_XMLConfigator.FindElem(_T("CamPlatInfo")))
	{
		m_XMLConfigator.AddElem(_T("CamPlatInfo"));
	}
	m_XMLConfigator.EnterElem();	

	// 	// 相机个数	
	// 	if(FALSE == m_XMLConfigator.FindElem(_T("CamNum")))
	// 	{
	// 		m_XMLConfigator.AddElem(_T("CamNum"));
	// 	}
	// 	m_XMLConfigator.SetElemData(m_pPlatformInfo->m_nPositionNum);

	// 	// 相机拍照位置
	// 	if (1 == m_pPlatformInfo->m_nCamNum)
	// 	{		
	// 		if(FALSE == m_XMLConfigator.FindElem(_T("PosNum")))
	// 		{
	// 			m_XMLConfigator.AddElem(_T("PosNum"));
	// 		}
	// 		m_XMLConfigator.SetElemData(m_pPlatformInfo->m_nPositionNum);
	// 	}
	// 
	// 	// 安装方式
	// 	if(FALSE == m_XMLConfigator.FindElem(_T("CamFixType")))
	// 	{
	// 		m_XMLConfigator.AddElem(_T("CamFixType"));
	// 	}
	// 	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformType());

	for (int i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
	{
		// 相机轴
		strInfo.Format(_T("CamPlatInfo%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();      

		switch(m_pPlatformInfo->m_eCamPlatformType)
		{
		case eCamPlatformSepFix:
			break;
		case eCamPlatformSepX:
			{
				// 相机平台X轴方向
				if(FALSE == m_XMLConfigator.FindElem(_T("CamXCType")))
				{
					m_XMLConfigator.AddElem(_T("CamXCType"));
				}
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamDirectX(i));
			}
			break;
		case eCamPlatformSepXY:
			{
				// 相机平台X轴方向
				if(FALSE == m_XMLConfigator.FindElem(_T("CamXCType")))
				{
					m_XMLConfigator.AddElem(_T("CamXCType"));
				}
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamDirectX(i));


				// 相机平台Y轴方向
				if(FALSE == m_XMLConfigator.FindElem(_T("CamYCType")))
				{
					m_XMLConfigator.AddElem(_T("CamYCType"));
				}
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamDirectY(i));
			}
			break;
		case eCamPlatformShareX:
			break;
		default:
			{
				return FALSE;
			}
			break;
		}	
		m_XMLConfigator.LeaveElem();	

		// 相机轴所在平台轴
		strInfo.Format(_T("CamPlatAxisInfo%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();      

		switch(m_pPlatformInfo->m_eCamPlatformType)
		{
		case eCamPlatformSepFix:
			break;
		case eCamPlatformSepX:
			{
				// 相机平台X轴方向
				if(FALSE == m_XMLConfigator.FindElem(_T("CamPXCType")))
				{
					m_XMLConfigator.AddElem(_T("CamPXCType"));
				}
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformAxisDirectX(i));
			}
			break;
		case eCamPlatformSepXY:
			{
				// 相机平台X轴方向
				if(FALSE == m_XMLConfigator.FindElem(_T("CamPXCType")))
				{
					m_XMLConfigator.AddElem(_T("CamPXCType"));
				}
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformAxisDirectX(i));


				// 相机平台Y轴方向
				if(FALSE == m_XMLConfigator.FindElem(_T("CamPYCType")))
				{
					m_XMLConfigator.AddElem(_T("CamPYCType"));
				}
				m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformAxisDirectY(i));
			}
			break;
		case eCamPlatformShareX:
			break;
		default:
			{
				return FALSE;
			}
			break;
		}	

		m_XMLConfigator.LeaveElem();					
	}

	m_XMLConfigator.LeaveElem();//退出相机平台信息      

	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);

	AlignXmlLog(_T("SaveCamPlatformInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);

	return bOK;
}

BOOL vcBaseVisionAlign::LoadCommInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadCommInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	if(TRUE == m_XMLConfigator.FindElem(_T("CommParamInfo")))
	{
		m_XMLConfigator.EnterElem();
		m_pVisionASMConfig->m_CommParamInfo.LoadModelFromFile(m_XMLConfigator);

		DeleteCommInfo(); // 清理当前通信信息

		{
			// 串口通信信息：串口或网口
			switch(m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
			{
			case eSerial:
				{	
					m_pVisionASMConfig->m_pCommParam = new vcSerialCommInfo;
					vcSerialCommInfo* serialCommInfo = (vcSerialCommInfo*)m_pVisionASMConfig->m_pCommParam;

					int iValue = 0;

					if(TRUE == m_XMLConfigator.FindElem(_T("SerialCommInfo")))
					{
						m_XMLConfigator.EnterElem();

						// 串口号，从0开始
						if (m_XMLConfigator.FindElem(_T("ComPort")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_uiComPort = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 波特率
						if (m_XMLConfigator.FindElem(_T("BaudRate")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_uiBaudRate = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 奇偶校验
						if (m_XMLConfigator.FindElem(_T("Parity")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_Parity = (SerialParity)iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 停止位
						if (m_XMLConfigator.FindElem(_T("StopBits")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_StopBits = (SerialStopBits)iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 数据位
						if (m_XMLConfigator.FindElem(_T("ByteSize")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_uiDataBits = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 通信终止符
						if (m_XMLConfigator.FindElem(_T("CommEnd")))
						{
							serialCommInfo->m_strCommStop = m_XMLConfigator.GetElemData();
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 通信终止符
						if (m_XMLConfigator.FindElem(_T("CmdEnd")))
						{
							serialCommInfo->m_strCmdStop = m_XMLConfigator.GetElemData();
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 寄存器首地址
						if (m_XMLConfigator.FindElem(_T("RegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_lRegAddress = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}


						if (m_XMLConfigator.FindElem(_T("TempRegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_lTempRegAddress = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}


						if (m_XMLConfigator.FindElem(_T("WriteRegMaxNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_lWriteRegMaxNum = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}



						if (m_XMLConfigator.FindElem(_T("ReadRegMaxNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							serialCommInfo->m_lReadRegMaxNum = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}



						m_pVisionASMConfig->m_pCommParam = serialCommInfo;

						m_XMLConfigator.LeaveElem();                     

					}
					else
					{
						m_XMLConfigator.LeaveElem();
						return FALSE;
					}

				}
				break;
			case eSocket:
				{	
					m_pVisionASMConfig->m_pCommParam = new vcSocketCommInfo;
					vcSocketCommInfo* socketCommInfo = (vcSocketCommInfo*)m_pVisionASMConfig->m_pCommParam;

					int iValue = 0;

					if(TRUE == m_XMLConfigator.FindElem(_T("SocketCommInfo")))
					{
						m_XMLConfigator.EnterElem();

						// Socket类型，服务端或客户端
						if (m_XMLConfigator.FindElem(_T("SocketType")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_socketType = (SocketType)iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// IP地址 （安登奎）
						if (m_XMLConfigator.FindElem(_T("IP")))
						{
							CString strData = m_XMLConfigator.GetElemData();
							int nIdx = strData.Find('.');
							CString strValue = strData.Left(nIdx);
							strData = strData.Mid(nIdx+1);
							socketCommInfo->m_byAddr[0] = (unsigned char)_ttoi(strValue);
							nIdx = strData.Find('.');
							strValue = strData.Left(nIdx);
							strData = strData.Mid(nIdx+1);
							socketCommInfo->m_byAddr[1] = (unsigned char)_ttoi(strValue);
							nIdx = strData.Find('.');
							strValue = strData.Left(nIdx);
							strData = strData.Mid(nIdx+1);
							socketCommInfo->m_byAddr[2] = (unsigned char)_ttoi(strValue);
							socketCommInfo->m_byAddr[3] = (unsigned char)_ttoi(strData);
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 端口				
						if (m_XMLConfigator.FindElem(_T("IPPort")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_uiPort = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 服务端监听个数
						if (m_XMLConfigator.FindElem(_T("ListenNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_uiListenNum = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 通信终止符
						if (m_XMLConfigator.FindElem(_T("CommEnd")))
						{
							socketCommInfo->m_strCommStop = m_XMLConfigator.GetElemData();
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 通信终止符
						if (m_XMLConfigator.FindElem(_T("CmdEnd")))
						{
							socketCommInfo->m_strCmdStop = m_XMLConfigator.GetElemData();
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 寄存器首地址
						if (m_XMLConfigator.FindElem(_T("RegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lRegAddress = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						if (m_XMLConfigator.FindElem(_T("TempRegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lTempRegAddress = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}

						// 单次最大写寄存器数量
						if (m_XMLConfigator.FindElem(_T("WriteRegMaxNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lWriteRegMaxNum = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}
						// 单次最大读寄存器数量
						if (m_XMLConfigator.FindElem(_T("ReadRegMaxNum")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lReadRegMaxNum = iValue;
						}
						else
						{
							m_XMLConfigator.LeaveElem();
							return FALSE;
						}
						double dValue = 0;
						if (m_XMLConfigator.FindElem(_T("WZRegAddress")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lWZRegAddress = iValue;
						}

						// ID寄存器地址
						if (m_XMLConfigator.FindElem(_T("RegAddress3")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_lRegAddress3 = iValue;
						}

						if (m_XMLConfigator.FindElem(_T("EnableIDRaed")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_bEnableIDRaed = (BOOL)iValue;
						}

						if (m_XMLConfigator.FindElem(_T("IDLength")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_nIDLength = iValue;
						}

						//m_bIDInvert
						if (m_XMLConfigator.FindElem(_T("IDInvert")))
						{
							m_XMLConfigator.GetElemData(iValue);
							socketCommInfo->m_bIDInvert = (BOOL)iValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_szGetName")))
						{
							
							socketCommInfo->m_szGetName = m_XMLConfigator.GetElemData();
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZW")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZW = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZR")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZR = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZY1")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZY1 = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZY2")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZY2 = dValue;
						}


						if (m_XMLConfigator.FindElem(_T("m_dWZY3")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZY3 = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZZ1")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZZ1 = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZZ2")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZZ2 = dValue;
						}

						if (m_XMLConfigator.FindElem(_T("m_dWZZ3")))
						{
							m_XMLConfigator.GetElemData(dValue);
							socketCommInfo->m_dWZZ3 = dValue;
						}

						m_pVisionASMConfig->m_pCommParam = socketCommInfo;		

						m_XMLConfigator.LeaveElem();
					}
					else
					{
						m_XMLConfigator.LeaveElem();
						return FALSE;
					}

				}
				break;
			default:
				{
					return FALSE; 
				}
				break;
			}	
		}
		m_XMLConfigator.LeaveElem();
	}




	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveCommInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig->m_pCommParam)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveCommInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(!m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SaveCommInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}

	if (m_pVisionASMConfig->m_pCommParam->GetCommType()!=m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
	{
		return FALSE;
	}

	m_XMLConfigator.EnterElem();


	if (FALSE == m_XMLConfigator.FindElem(_T("CommParamInfo")))
	{
		m_XMLConfigator.AddElem(_T("CommParamInfo"));
	}

	m_XMLConfigator.EnterElem(); 

	m_pVisionASMConfig->m_CommParamInfo.SaveModelToFile(m_XMLConfigator);
	// 串口通信信息：串口或网口
	switch(m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
	{
	case eSerial:
		{	
			vcSerialCommInfo* serialCommInfo = (vcSerialCommInfo*)m_pVisionASMConfig->m_pCommParam;

			if (!m_XMLConfigator.FindElem(_T("SerialCommInfo")))
			{
				m_XMLConfigator.AddElem(_T("SerialCommInfo"));
			}		
			m_XMLConfigator.EnterElem();			

			// 通信类型（串口）
			if (!m_XMLConfigator.FindElem(_T("CommType")))
			{
				m_XMLConfigator.AddElem(_T("CommType"));
			}		
			m_XMLConfigator.SetElemData(serialCommInfo->GetCommType());

			// 串口号，从0开始
			if (!m_XMLConfigator.FindElem(_T("ComPort")))
			{
				m_XMLConfigator.AddElem(_T("ComPort"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_uiComPort);					

			// 波特率
			if (!m_XMLConfigator.FindElem(_T("BaudRate")))
			{
				m_XMLConfigator.AddElem(_T("BaudRate"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_uiBaudRate);			

			// 奇偶校验
			if (!m_XMLConfigator.FindElem(_T("Parity")))
			{
				m_XMLConfigator.AddElem(_T("Parity"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_Parity);

			// 停止位
			if (!m_XMLConfigator.FindElem(_T("StopBits")))
			{
				m_XMLConfigator.AddElem(_T("StopBits"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_StopBits);

			// 数据位
			if (!m_XMLConfigator.FindElem(_T("ByteSize")))
			{
				m_XMLConfigator.AddElem(_T("ByteSize"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_uiDataBits);

			// 通信终止符
			if (!m_XMLConfigator.FindElem(_T("CommEnd")))
			{
				m_XMLConfigator.AddElem(_T("CommEnd"));
			}		
			m_XMLConfigator.SetElemData(serialCommInfo->m_strCommStop); 			

			// 命令终止符
			if (!m_XMLConfigator.FindElem(_T("CmdEnd")))
			{
				m_XMLConfigator.AddElem(_T("CmdEnd"));
			}		
			m_XMLConfigator.SetElemData(serialCommInfo->m_strCmdStop);

			// 寄存器首地址				
			if (!m_XMLConfigator.FindElem(_T("RegAddress")))
			{
				m_XMLConfigator.AddElem(_T("RegAddress"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_lRegAddress);


			if (!m_XMLConfigator.FindElem(_T("TempRegAddress")))
			{
				m_XMLConfigator.AddElem(_T("TempRegAddress"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_lTempRegAddress);


			if (!m_XMLConfigator.FindElem(_T("WriteRegMaxNum")))
			{
				m_XMLConfigator.AddElem(_T("WriteRegMaxNum"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_lWriteRegMaxNum);

			if (!m_XMLConfigator.FindElem(_T("ReadRegMaxNum")))
			{
				m_XMLConfigator.AddElem(_T("ReadRegMaxNum"));
			}		
			m_XMLConfigator.SetElemData((int)serialCommInfo->m_lReadRegMaxNum);



			m_XMLConfigator.LeaveElem();                     

		}
		break;
	case eSocket:
		{			
			vcSocketCommInfo* socketCommInfo = (vcSocketCommInfo*)m_pVisionASMConfig->m_pCommParam;

			if (!m_XMLConfigator.FindElem(_T("SocketCommInfo")))
			{
				m_XMLConfigator.AddElem(_T("SocketCommInfo"));
			}		
			m_XMLConfigator.EnterElem();

			// 通信类型（网口）
			if (!m_XMLConfigator.FindElem(_T("CommType")))
			{
				m_XMLConfigator.AddElem(_T("CommType"));
			}		
			m_XMLConfigator.SetElemData(socketCommInfo->GetCommType());

			// Socket类型，服务端或客户端
			if (!m_XMLConfigator.FindElem(_T("SocketType")))
			{
				m_XMLConfigator.AddElem(_T("SocketType"));
			}		
			m_XMLConfigator.SetElemData(socketCommInfo->m_socketType);

			// IP地址
			CString strInfo;
			if (!m_XMLConfigator.FindElem(_T("IP")))
			{
				m_XMLConfigator.AddElem("IP");
			}
			strInfo.Format(_T("%d.%d.%d.%d"), (int)socketCommInfo->m_byAddr[0], (int)socketCommInfo->m_byAddr[1],
				(int)socketCommInfo->m_byAddr[2], (int)socketCommInfo->m_byAddr[3]);
			m_XMLConfigator.SetElemData(strInfo);

			// 端口				
			if (!m_XMLConfigator.FindElem(_T("IPPort")))
			{
				m_XMLConfigator.AddElem(_T("IPPort"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_uiPort);

			// 服务端监听个数
			if (!m_XMLConfigator.FindElem(_T("ListenNum")))
			{
				m_XMLConfigator.AddElem(_T("ListenNum"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_uiListenNum);

			// 通信终止符
			if (!m_XMLConfigator.FindElem(_T("CommEnd")))
			{
				m_XMLConfigator.AddElem(_T("CommEnd"));
			}		
			m_XMLConfigator.SetElemData(socketCommInfo->m_strCommStop);

			// 命令终止符
			if (!m_XMLConfigator.FindElem(_T("CmdEnd")))
			{
				m_XMLConfigator.AddElem(_T("CmdEnd"));
			}		
			m_XMLConfigator.SetElemData(socketCommInfo->m_strCmdStop);

			// 寄存器首地址				
			if (!m_XMLConfigator.FindElem(_T("RegAddress")))
			{
				m_XMLConfigator.AddElem(_T("RegAddress"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_lRegAddress);

			if (!m_XMLConfigator.FindElem(_T("TempRegAddress")))
			{
				m_XMLConfigator.AddElem(_T("TempRegAddress"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_lTempRegAddress);



			if (!m_XMLConfigator.FindElem(_T("WriteRegMaxNum")))
			{
				m_XMLConfigator.AddElem(_T("WriteRegMaxNum"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_lWriteRegMaxNum);

			if (!m_XMLConfigator.FindElem(_T("ReadRegMaxNum")))
			{
				m_XMLConfigator.AddElem(_T("ReadRegMaxNum"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_lReadRegMaxNum);

			if (!m_XMLConfigator.FindElem(_T("WZRegAddress")))
			{
				m_XMLConfigator.AddElem(_T("WZRegAddress"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_lWZRegAddress);

			if (!m_XMLConfigator.FindElem(_T("RegAddress3")))
			{
				m_XMLConfigator.AddElem(_T("RegAddress3"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_lRegAddress3);

			if (!m_XMLConfigator.FindElem(_T("EnableIDRaed")))
			{
				m_XMLConfigator.AddElem(_T("EnableIDRaed"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_bEnableIDRaed);

			if (!m_XMLConfigator.FindElem(_T("IDLength")))
			{
				m_XMLConfigator.AddElem(_T("IDLength"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_nIDLength);

			if (!m_XMLConfigator.FindElem(_T("IDInvert")))
			{
				m_XMLConfigator.AddElem(_T("IDInvert"));
			}		
			m_XMLConfigator.SetElemData((int)socketCommInfo->m_bIDInvert);

			if (!m_XMLConfigator.FindElem(_T("m_szGetName")))
			{
				m_XMLConfigator.AddElem(_T("m_szGetName"));
			}		
			m_XMLConfigator.SetElemData(socketCommInfo->m_szGetName);

			if (!m_XMLConfigator.FindElem(_T("m_dWZW")))
			{
				m_XMLConfigator.AddElem(_T("m_dWZW"));
			}		
			m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZW);
			if (!m_XMLConfigator.FindElem(_T("m_dWZR")))
			{
				m_XMLConfigator.AddElem(_T("m_dWZR"));
			}		
			m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZR);
			if (!m_XMLConfigator.FindElem(_T("m_dWZY1")))
			{
				m_XMLConfigator.AddElem(_T("m_dWZY1"));
			}		
			m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZY1);
			if (!m_XMLConfigator.FindElem(_T("m_dWZY2")))
			{
				m_XMLConfigator.AddElem(_T("m_dWZY2"));
			}		
			m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZY2);
			if (!m_XMLConfigator.FindElem(_T("m_dWZY3")))
			{
				m_XMLConfigator.AddElem(_T("m_dWZY3"));
			}		
			m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZY3);

			if (!m_XMLConfigator.FindElem(_T("m_dWZZ1")))
			{
				m_XMLConfigator.AddElem(_T("m_dWZZ1"));
			}		
			m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZZ1);
			if (!m_XMLConfigator.FindElem(_T("m_dWZZ2")))
			{
				m_XMLConfigator.AddElem(_T("m_dWZZ2"));
			}		
			m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZZ2);
			if (!m_XMLConfigator.FindElem(_T("m_dWZZ3")))
			{
				m_XMLConfigator.AddElem(_T("m_dWZZ3"));
			}		
			m_XMLConfigator.SetElemData((double)socketCommInfo->m_dWZZ3);

			m_XMLConfigator.LeaveElem();	

		}
		break;
	default:
		{
			return FALSE; 
		}
		break;
	}

	m_XMLConfigator.LeaveElem();  // LeaveElem CommParamInfo
	m_XMLConfigator.LeaveElem();


	BOOL bOK = m_XMLConfigator.Save(strPlatformXMLAdrr);
	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp += _T("SaveCommInfo_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);
	AlignXmlLog(_T("SaveCommInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadCommOptionInfo()
{
	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strCommXMLAdrr; 

	strInfo             = _T("");
	strCommXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strCommXMLAdrr);
	AlignXmlLog(_T("LoadCommOptionInfo"), _T("Load:")+strCommXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (m_XMLConfigator.FindElem(_T("CommOptionInfo")))
	{
		m_XMLConfigator.EnterElem();
		CCommOptionInfo commOptionInfo;
		if (m_XMLConfigator.FindElem(_T("UsePlatformComm")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			commOptionInfo.m_bUsePlatformComm = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("CommDelay")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			commOptionInfo.m_nCommDelay = k;
		}
		if (m_XMLConfigator.FindElem(_T("CommTimeout")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			commOptionInfo.m_nCommTimeOut = k;
		}
		if (m_XMLConfigator.FindElem(_T("CommReSendTimes")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			commOptionInfo.m_nCommReSendTimes = k;
		}
		if (m_XMLConfigator.FindElem(_T("CommXUnitExp")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			commOptionInfo.m_nCommXUnitExp = k;
		}
		if (m_XMLConfigator.FindElem(_T("CommYUnitExp")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			commOptionInfo.m_nCommYUnitExp = k;
		}
		if (m_XMLConfigator.FindElem(_T("CommDUnitExp")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			commOptionInfo.m_nCommDUnitExp = k;
		}

		if (m_XMLConfigator.FindElem(_T("CommDataLenType")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			commOptionInfo.m_nCommDataLenType = k;
		}

		SetCommOptionInfo(commOptionInfo);
		m_XMLConfigator.LeaveElem();
	}    	

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveCommOptionInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}


	CString strInfo;
	CString strCommXMLAdrr; 

	strInfo             = _T("");
	strCommXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strCommXMLAdrr);
	AlignXmlLog(_T("SaveCommOptionInfo"), _T("Load:")+strCommXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
	{
		AlignXmlLog(_T("SaveCommOptionInfo"),_T("Find:WorkStationConfig"),FALSE);
		return FALSE;
	}
	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (FALSE == m_XMLConfigator.FindElem(_T("CommOptionInfo")))
	{
		m_XMLConfigator.AddElem(_T("CommOptionInfo"));
	}
	m_XMLConfigator.EnterElem();

	CCommOptionInfo commOptionInfo;
	GetCommOptionInfoXML(commOptionInfo);
	if (FALSE == m_XMLConfigator.FindElem(_T("UsePlatformComm")))
	{
		m_XMLConfigator.AddElem(_T("UsePlatformComm"));
	}
	m_XMLConfigator.SetElemData((int)commOptionInfo.m_bUsePlatformComm);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommDelay")))
	{
		m_XMLConfigator.AddElem(_T("CommDelay"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommDelay);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommTimeout")))
	{
		m_XMLConfigator.AddElem(_T("CommTimeout"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommTimeOut);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommReSendTimes")))
	{
		m_XMLConfigator.AddElem(_T("CommReSendTimes"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommReSendTimes);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommXUnitExp")))
	{
		m_XMLConfigator.AddElem(_T("CommXUnitExp"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommXUnitExp);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommYUnitExp")))
	{
		m_XMLConfigator.AddElem(_T("CommYUnitExp"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommYUnitExp);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommDUnitExp")))
	{
		m_XMLConfigator.AddElem(_T("CommDUnitExp"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommDUnitExp);

	if (FALSE == m_XMLConfigator.FindElem(_T("CommDataLenType")))
	{
		m_XMLConfigator.AddElem(_T("CommDataLenType"));
	}
	m_XMLConfigator.SetElemData(commOptionInfo.m_nCommDataLenType);


	m_XMLConfigator.LeaveElem();
	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strCommXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SaveCommOptionInfo_Save:")+strCommXMLAdrr;
	ExecuteGitCommit(strTmp);
	AlignXmlLog(_T("SaveCommOptionInfo"), _T("Save:")+strCommXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadCameraInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadCameraInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 相机信息：以序列号采集

	std::vector<CameraParam> vCameraParam;
	double dValue;

	if(TRUE == m_XMLConfigator.FindElem(_T("CamParam")))
	{
		m_XMLConfigator.EnterElem();

		int i=0;
		for (i=0; i<m_pPlatformInfo->m_nCamNum; i++)
		{
			CameraParam cameraParam;
			strInfo.Format(_T("CamParam%d"),i);

			if(TRUE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.EnterElem();

				// 相机序列号
				if (m_XMLConfigator.FindElem(_T("SN")))
				{
					m_XMLConfigator.GetElemData(dValue);
					cameraParam.m_lSerialNum = (unsigned long)dValue;
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机DeviceID
				if(m_XMLConfigator.FindElem(_T("DeviceID")))
				{
					CString strID = _T("");
					strID = m_XMLConfigator.GetElemData();
					cameraParam.m_strDeviceID = strID;
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机视频模式
				if (m_XMLConfigator.FindElem(_T("Mode")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nVideoMode);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机宽
				if (m_XMLConfigator.FindElem(_T("Width")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nRawWidth);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机高
				if (m_XMLConfigator.FindElem(_T("Height")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nRawHeight);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 自定义起始X
				if (m_XMLConfigator.FindElem(_T("X")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nCustemStartX);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 自定义起始Y
				if (m_XMLConfigator.FindElem(_T("Y")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nCustemStartY);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 自定义宽
				if (m_XMLConfigator.FindElem(_T("W")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nCustemWidth);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 自定义高
				if (m_XMLConfigator.FindElem(_T("H")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nCustemHeight);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 白平衡
				if (m_XMLConfigator.FindElem(_T("WhiteBalanceRatioR")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dWhiteBalanceRatioR);				 
				}
				else
				{
					cameraParam.m_dWhiteBalanceRatioR = 1000.0;
				}

				if (m_XMLConfigator.FindElem(_T("WhiteBalanceRatioG")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dWhiteBalanceRatioG);				 
				}
				else
				{
					cameraParam.m_dWhiteBalanceRatioG = 1000.0;
				}

				if (m_XMLConfigator.FindElem(_T("WhiteBalanceRatioB")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dWhiteBalanceRatioB);				 
				}
				else
				{
					cameraParam.m_dWhiteBalanceRatioB = 1000.0;
				}

				// 帧率
				if (m_XMLConfigator.FindElem(_T("FrameRate")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dFrameRate);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 曝光时间
				if (m_XMLConfigator.FindElem(_T("Shutter")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dShutter);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 关联曝光时间
				if (m_XMLConfigator.FindElem(_T("CalibTargetShutter")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dCalibTargetShutter);				 
				}

				// 增益
				if (m_XMLConfigator.FindElem(_T("Gain")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dGain);				 
				}		
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// GammaEnable
				if (m_XMLConfigator.FindElem(_T("GammaEnable")))
				{
					int nVal = 0;
					m_XMLConfigator.GetElemData(nVal);				 
					cameraParam.m_bGammaEnable = (bool)nVal;
				}		


				// Gamma
				if (m_XMLConfigator.FindElem(_T("Gamma")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dGamma);				 
				}

				//共享相机类型
				if(m_XMLConfigator.FindElem(_T("ShareCamType")))
				{	
					int nData=0;
					m_XMLConfigator.GetElemData(nData);	
					cameraParam.m_eShareCamType=(CShareCamType)nData;
				}

				if(m_XMLConfigator.FindElem(_T("ShareCamNum")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nShareCamNum);	
				}

				cameraParam.m_vShareCamInfo.resize(cameraParam.m_nShareCamNum);
				for (int g=0;g<cameraParam.m_nShareCamNum;g++)
				{
					strInfo.Format(_T("ShareCam%d"),g);
					if(m_XMLConfigator.FindElem(strInfo))
					{
						m_XMLConfigator.EnterElem();
						if(m_XMLConfigator.FindElem(_T("SharePlatformIndex")))
						{
							m_XMLConfigator.GetElemData(cameraParam.m_vShareCamInfo.at(g).m_nPlatformIndex);
						}
						if(m_XMLConfigator.FindElem(_T("ShareCameraIndex")))
						{
							m_XMLConfigator.GetElemData(cameraParam.m_vShareCamInfo.at(g).m_nCamIndex);
						}
						m_XMLConfigator.LeaveElem();
					}

				}

				m_XMLConfigator.LeaveElem();

				vCameraParam.push_back(cameraParam);
			}
			else
			{
				return FALSE;
			}			
		}

		for (i=0; i<m_pPlatformInfo->m_nCamNum; i++)
		{
			m_pVisionASMConfig->m_vCameraParam.at(i) = vCameraParam.at(i);
		}		

	}
	else
	{
		m_XMLConfigator.LeaveElem();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveCameraInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveCameraInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SaveCameraInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}

	m_XMLConfigator.EnterElem();

	// 相机信息：以序列号采集


	if(FALSE == m_XMLConfigator.FindElem(_T("CamParam")))
	{
		m_XMLConfigator.AddElem(_T("CamParam"));
	}
	m_XMLConfigator.EnterElem();

	for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{
		CameraParam cameraParam;;
		strInfo.Format(_T("CamParam%d"),i);

		GetCameraParam(i,cameraParam);

		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();

		// 相机DeviceID
		if(FALSE == m_XMLConfigator.FindElem(_T("DeviceID")))
		{
			m_XMLConfigator.AddElem(_T("DeviceID"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_strDeviceID);	

		// 相机序列号
		if(FALSE == m_XMLConfigator.FindElem(_T("SN")))
		{
			m_XMLConfigator.AddElem(_T("SN"));
		}
		m_XMLConfigator.SetElemData((int)cameraParam.m_lSerialNum);		

		// 相机视频模式
		if(FALSE == m_XMLConfigator.FindElem(_T("Mode")))
		{
			m_XMLConfigator.AddElem(_T("Mode"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nVideoMode);	 

		// 相机宽
		if(FALSE == m_XMLConfigator.FindElem(_T("Width")))
		{
			m_XMLConfigator.AddElem(_T("Width"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nRawWidth);				 

		// 相机高
		if(FALSE == m_XMLConfigator.FindElem(_T("Height")))
		{
			m_XMLConfigator.AddElem(_T("Height"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nRawHeight);				 

		// 自定义起始X
		if(FALSE == m_XMLConfigator.FindElem(_T("X")))
		{
			m_XMLConfigator.AddElem(_T("X"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nCustemStartX);				 

		// 自定义起始Y
		if(FALSE == m_XMLConfigator.FindElem(_T("Y")))
		{
			m_XMLConfigator.AddElem(_T("Y"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nCustemStartY);				 

		// 自定义宽
		if(FALSE == m_XMLConfigator.FindElem(_T("W")))
		{
			m_XMLConfigator.AddElem(_T("W"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nCustemWidth);				 

		// 自定义高
		if(FALSE == m_XMLConfigator.FindElem(_T("H")))
		{
			m_XMLConfigator.AddElem(_T("H"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nCustemHeight);				 

		// 白平衡
		if(FALSE == m_XMLConfigator.FindElem(_T("WhiteBalanceRatioR")))
		{
			m_XMLConfigator.AddElem(_T("WhiteBalanceRatioR"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_dWhiteBalanceRatioR);
		if(FALSE == m_XMLConfigator.FindElem(_T("WhiteBalanceRatioG")))
		{
			m_XMLConfigator.AddElem(_T("WhiteBalanceRatioG"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_dWhiteBalanceRatioG);
		if(FALSE == m_XMLConfigator.FindElem(_T("WhiteBalanceRatioB")))
		{
			m_XMLConfigator.AddElem(_T("WhiteBalanceRatioB"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_dWhiteBalanceRatioB);

		// 帧率
		if(FALSE == m_XMLConfigator.FindElem(_T("FrameRate")))
		{
			m_XMLConfigator.AddElem(_T("FrameRate"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_dFrameRate);				 

		// 曝光时间
		if(FALSE == m_XMLConfigator.FindElem(_T("Shutter")))
		{
			m_XMLConfigator.AddElem(_T("Shutter"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_dShutter);				 

		// 关联曝光时间
		if(FALSE == m_XMLConfigator.FindElem(_T("CalibTargetShutter")))
		{
			m_XMLConfigator.AddElem(_T("CalibTargetShutter"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_dCalibTargetShutter);

		// 增益
		if(FALSE == m_XMLConfigator.FindElem(_T("Gain")))
		{
			m_XMLConfigator.AddElem(_T("Gain"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_dGain);

		// GammaEnable
		if(FALSE == m_XMLConfigator.FindElem(_T("GammaEnable")))
		{
			m_XMLConfigator.AddElem(_T("GammaEnable"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_bGammaEnable);

		// Gamma
		if(FALSE == m_XMLConfigator.FindElem(_T("Gamma")))
		{
			m_XMLConfigator.AddElem(_T("Gamma"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_dGamma);

		//共享相机类型
		if(FALSE == m_XMLConfigator.FindElem(_T("ShareCamType")))
		{
			m_XMLConfigator.AddElem(_T("ShareCamType"));
		}
		m_XMLConfigator.SetElemData((int)cameraParam.m_eShareCamType);

		//共享相机数目
		if(FALSE == m_XMLConfigator.FindElem(_T("ShareCamNum")))
		{
			m_XMLConfigator.AddElem(_T("ShareCamNum"));
		}
		m_XMLConfigator.SetElemData(cameraParam.m_nShareCamNum);

		for (int g=0;g<cameraParam.m_nShareCamNum;g++)
		{
			strInfo.Format(_T("ShareCam%d"),g);
			if(FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}
			m_XMLConfigator.EnterElem();
			if(FALSE == m_XMLConfigator.FindElem(_T("SharePlatformIndex")))
			{
				m_XMLConfigator.AddElem(_T("SharePlatformIndex"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_vShareCamInfo.at(g).m_nPlatformIndex);

			if(FALSE == m_XMLConfigator.FindElem(_T("ShareCameraIndex")))
			{
				m_XMLConfigator.AddElem(_T("ShareCameraIndex"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_vShareCamInfo.at(g).m_nCamIndex);
			m_XMLConfigator.LeaveElem();
		}



		m_XMLConfigator.LeaveElem();
	}

	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);
	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp += _T("SaveCameraInfo"), _T("Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);
	AlignXmlLog(_T("SaveCameraInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);

	return bOK;	
}

BOOL vcBaseVisionAlign::LoadPosInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadPosInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 位置信息：以序列号采集
	CPosInfo posInfo;
	std::vector<CPosInfo> vPosInfo;
	int	nData;

	if(TRUE == m_XMLConfigator.FindElem(_T("PosInfo")))
	{
		m_XMLConfigator.EnterElem();

		int i=0;
		for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
		{
			strInfo.Format(_T("PosInfo%d"),i);

			if(TRUE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.EnterElem();

				// 位置是否有效
				if (m_XMLConfigator.FindElem(_T("PosEnable")))
				{
					m_XMLConfigator.GetElemData(nData);
					posInfo.m_bPosEnable = (BOOL)nData;
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机索引
				if(m_XMLConfigator.FindElem(_T("CamIndex")))
				{
					m_XMLConfigator.GetElemData(nData);
					posInfo.m_bPosEnable = nData;
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				m_XMLConfigator.LeaveElem();

				vPosInfo.push_back(posInfo);
			}
			else
			{
				return FALSE;
			}			
		}

		for (i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
		{
			m_pVisionASMConfig->m_vPosInfo.at(i) = vPosInfo.at(i);
		}		

	}
	else
	{
		m_XMLConfigator.LeaveElem();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SavePosInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SavePosInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SavePosInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}

	m_XMLConfigator.EnterElem();

	// 位置信息
	CPosInfo posInfo;

	if(FALSE == m_XMLConfigator.FindElem(_T("PosInfo")))
	{
		m_XMLConfigator.AddElem(_T("PosInfo"));
	}
	m_XMLConfigator.EnterElem();

	for (int i=0; i<m_pPlatformInfo->m_nPositionNum; i++)
	{
		strInfo.Format(_T("PosInfo%d"),i);

		posInfo = m_pVisionASMConfig->m_vPosInfo.at(i);

		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();

		// 位置是否有效
		if(FALSE == m_XMLConfigator.FindElem(_T("PosEnable")))
		{
			m_XMLConfigator.AddElem(_T("PosEnable"));
		}
		m_XMLConfigator.SetElemData(posInfo.m_bPosEnable);	

		// 相机索引
		if(FALSE == m_XMLConfigator.FindElem(_T("CamIndex")))
		{
			m_XMLConfigator.AddElem(_T("CamIndex"));
		}
		m_XMLConfigator.SetElemData(posInfo.m_nCamIndex);		

		m_XMLConfigator.LeaveElem();
	}

	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SavePosInfo_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SavePosInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;	
}

BOOL vcBaseVisionAlign::LoadImageRoiInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadImageRoiInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 图像显示参数	
	ImageRoi imageROI;
	std::vector<ImageRoi> vImageROI;

	//	int nNum = (1==m_pPlatformInfo->m_nCamNum)? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nNum = m_pPlatformInfo->m_nPositionNum;
	m_pVisionASMConfig->m_vImageRoi.resize(nNum);
	vImageROI.resize(nNum);

	if(TRUE == m_XMLConfigator.FindElem(_T("CamDisp")))
	{
		m_XMLConfigator.EnterElem();

		int i=0;
		for (i=0; i<nNum; i++)
		{
			strInfo.Format(_T("CamDisp%d"),i);

			if(TRUE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.EnterElem();

				// 水平镜像
				if (m_XMLConfigator.FindElem(_T("MH")))
				{
					m_XMLConfigator.GetElemData(imageROI.m_bMirrorHoriz);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 垂直镜像
				if (m_XMLConfigator.FindElem(_T("MV")))
				{
					m_XMLConfigator.GetElemData(imageROI.m_bMirrorVert);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}				

				// 旋转
				if (m_XMLConfigator.FindElem(_T("R")))
				{
					m_XMLConfigator.GetElemData(imageROI.m_nRotation);				 
				}			
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// GammaCorrectionEnable
				if (m_XMLConfigator.FindElem(_T("GammaCorrectionEnable")))
				{
					m_XMLConfigator.GetElemData(imageROI.m_bGammaCorrectionEnable);				 
				}			
				else
				{
					imageROI.m_bGammaCorrectionEnable = FALSE;
				}

				// Gamma
				if (m_XMLConfigator.FindElem(_T("Gamma")))
				{
					m_XMLConfigator.GetElemData(imageROI.m_dGamma);				 
				}			
				else
				{
					imageROI.m_dGamma = 1.0;
				}

				// 十字中心是否可见
				if (m_XMLConfigator.FindElem(_T("CrossVisible")))
				{
					m_XMLConfigator.GetElemData(imageROI.m_bCrossVisible);				 
				}			
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 十字中心X
				if (m_XMLConfigator.FindElem(_T("CrossX")))
				{
					m_XMLConfigator.GetElemData(imageROI.m_dCrossX);				 
				}			
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 十字中心Y
				if (m_XMLConfigator.FindElem(_T("CrossY")))
				{
					m_XMLConfigator.GetElemData(imageROI.m_dCrossY);				 
				}			
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				m_XMLConfigator.LeaveElem();
			}
			else
			{
				m_XMLConfigator.LeaveElem();
				return FALSE;
			}

			vImageROI.at(i) = imageROI;
		}

		for (i=0; i<nNum; i++)
		{
			m_pVisionASMConfig->m_vImageRoi.at(i) = vImageROI.at(i);
		}

		m_XMLConfigator.LeaveElem();
	}	
	else
	{
		m_XMLConfigator.LeaveElem();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveImageRoiInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveImageRoiInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SaveImageRoiInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}

	m_XMLConfigator.EnterElem();

	// 图像显示参数	
	ImageRoi imageROI;

	if(FALSE == m_XMLConfigator.FindElem(_T("CamDisp")))
	{
		m_XMLConfigator.AddElem(_T("CamDisp"));
	}
	m_XMLConfigator.EnterElem();

	//	int nNum = (1==m_pPlatformInfo->m_nCamNum)? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nNum = m_pPlatformInfo->m_nPositionNum;
	for (int i=0; i<nNum; i++)
	{
		strInfo.Format(_T("CamDisp%d"),i);

		imageROI = m_pVisionASMConfig->m_vImageRoi.at(i);

		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();

		// 水平镜像
		if(FALSE == m_XMLConfigator.FindElem(_T("MH")))
		{
			m_XMLConfigator.AddElem(_T("MH"));
		}
		m_XMLConfigator.SetElemData(imageROI.m_bMirrorHoriz); 

		// 垂直镜像
		if(FALSE == m_XMLConfigator.FindElem(_T("MV")))
		{
			m_XMLConfigator.AddElem(_T("MV"));
		}
		m_XMLConfigator.SetElemData(imageROI.m_bMirrorVert);				 

		// 旋转
		if(FALSE == m_XMLConfigator.FindElem(_T("R")))
		{
			m_XMLConfigator.AddElem(_T("R"));
		}
		m_XMLConfigator.SetElemData(imageROI.m_nRotation);	

		// GammaCorrectionEnable
		if (FALSE == m_XMLConfigator.FindElem(_T("GammaCorrectionEnable")))
		{
			m_XMLConfigator.AddElem(_T("GammaCorrectionEnable"));			 
		}			
		m_XMLConfigator.SetElemData(imageROI.m_bGammaCorrectionEnable);

		// Gamma
		if (FALSE == m_XMLConfigator.FindElem(_T("Gamma")))
		{
			m_XMLConfigator.AddElem(_T("Gamma"));				 
		}			
		m_XMLConfigator.SetElemData(imageROI.m_dGamma);

		// 十字中心是否可见
		if (FALSE == m_XMLConfigator.FindElem(_T("CrossVisible")))
		{
			m_XMLConfigator.AddElem(_T("CrossVisible"));
		}	
		m_XMLConfigator.SetElemData(imageROI.m_bCrossVisible);	

		// 十字中心X
		if (FALSE == m_XMLConfigator.FindElem(_T("CrossX")))
		{
			m_XMLConfigator.AddElem(_T("CrossX"));
		}	
		m_XMLConfigator.SetElemData(imageROI.m_dCrossX);	

		// 十字中心Y
		if (FALSE == m_XMLConfigator.FindElem(_T("CrossY")))
		{
			m_XMLConfigator.AddElem(_T("CrossY"));
		}
		m_XMLConfigator.SetElemData(imageROI.m_dCrossY);	

		m_XMLConfigator.LeaveElem();		
	}

	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();

	BOOL bOK = m_XMLConfigator.Save(strPlatformXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SaveImageRoiInfo_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SaveImageRoiInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadDataRecordInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadDataRecordInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (m_XMLConfigator.FindElem(_T("LogParam")))
	{
		m_XMLConfigator.EnterElem();

		if(m_XMLConfigator.FindElem(_T("ASEnabled")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo);
		}

		if(m_XMLConfigator.FindElem(_T("CommEnabled")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bCommunication);
		}

		if(m_XMLConfigator.FindElem(_T("AlignToolLog")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignToolLog);
		}

		if(m_XMLConfigator.FindElem(_T("ImageName")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bImageName);
		}

		if(m_XMLConfigator.FindElem(_T("SaveNGImage")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage);
		}

		if(m_XMLConfigator.FindElem(_T("SaveFailedImageNum")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum);
		}


		if(m_XMLConfigator.FindElem(_T("SaveAllImage")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage);
		}

		if(m_XMLConfigator.FindElem(_T("SaveAllImageNum")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum);
		}

		if(m_XMLConfigator.FindElem(_T("SaveAllImageType")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType);
		}

		if(m_XMLConfigator.FindElem(_T("ImageFormat")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_eImageFormat = (CImageType)nValue;
		}

		if(m_XMLConfigator.FindElem(_T("ImageQuality")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_nImageQuility = nValue;
		}
		if(m_XMLConfigator.FindElem(_T("VDBNameByID")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_bVDBNameByID = (BOOL)nValue;
		}
		if(m_XMLConfigator.FindElem(_T("VDBImageQuality")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_nVDBImageQuility = nValue;
		}
		if(m_XMLConfigator.FindElem(_T("SaveVDBFile")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile = (BOOL)nValue;
		}

		if(m_XMLConfigator.FindElem(_T("SaveVDBMaxNums")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums);
		}

		if(m_XMLConfigator.FindElem(_T("SaveObjectSnapVDBFile")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_bSaveObjectSnapVDBFile = (BOOL)nValue;
		}
		if(m_XMLConfigator.FindElem(_T("SaveTargetSnapVDBFile")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_bSaveTargetSnapVDBFile = (BOOL)nValue;
		}

		

		if(m_XMLConfigator.FindElem(_T("SaveProcessSnapVDBFile")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_bSaveProcessSnapVDBFile = (BOOL)nValue;
		}

		//m_bSaveInsepectResultVDBFile
		if(m_XMLConfigator.FindElem(_T("SaveInsepectResultVDBFile")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_bSaveInsepectResultVDBFile = (BOOL)nValue;
		}

		if(m_XMLConfigator.FindElem(_T("GuitextWeight")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_GuitextWeight = nValue;
		}
		if(m_XMLConfigator.FindElem(_T("GuiLineWidth")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_GuiLineWidth = nValue;
		}

		if(m_XMLConfigator.FindElem(_T("VBDImageType")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_nVBDImageType = nValue;
		}



		if(m_XMLConfigator.FindElem(_T("EnableCustomLogPath")))
		{
			int nValue =0;
			m_XMLConfigator.GetElemData(nValue);
			m_pVisionASMConfig->m_DataRecord.m_bCustomLogPath = (BOOL)nValue;
		}

		if(m_XMLConfigator.FindElem(_T("bDataRecordTime")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime);
		}

		if(m_XMLConfigator.FindElem(_T("nDataRecordTimeNum")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_nDataRecordTimeNum);
		}

		if(m_XMLConfigator.FindElem(_T("dDiskSpaceMaxUsePercent")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_dDiskSpaceMaxUsePercent);
		}

		if(m_XMLConfigator.FindElem(_T("strDataRecordPath")))
		{
			m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath = m_XMLConfigator.GetElemData();
			// 禁止自定义日志路径为C盘，为C盘时，强制设置为D盘
			if(m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath.Left(2)==_T("C:"))
			{
				CString strTmp;
				strTmp.Format(_T("D:\\VSLog\\WS%d"),m_pPlatformInfo->m_nPlatformIndex+1);
				m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath = strTmp;
			}
		}



		// 		if(m_XMLConfigator.FindElem(_T("UseThreadSaveImageMode")))
		// 		{
		// 			int nValue =0;
		// 			m_XMLConfigator.GetElemData(nValue);
		// 			m_pVisionASMConfig->m_DataRecord.m_bThreadSaveImageMode = (BOOL)nValue;
		// 		}





		if(m_XMLConfigator.FindElem(_T("APEnabled")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision);
		}

		if(m_XMLConfigator.FindElem(_T("ATEnabled")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerTime);
		}

		if(m_XMLConfigator.FindElem(_T("MergeEnabled")))
		{
			m_XMLConfigator.GetElemData(m_pVisionASMConfig->m_DataRecord.m_bDataMerged);
		}


		// 		if(m_XMLConfigator.FindElem(_T("LogEnabled")))
		// 		{

		m_XMLConfigator.LeaveElem();
	}    	    
	else
	{
		m_XMLConfigator.LeaveElem();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
	{
		// 删除时间文件结构，更新m_strDataRecord、m_strAlignProcessData和m_strCommunicationData的具体路径
		UpdateDataRecordTxtAddr();

		// 挂起删除文件夹线程
		if (m_bCheckRemoveFolderThreadSuspend == FALSE)
		{
			m_pCheckRemoveFolderThread->SuspendThread();
			m_bCheckRemoveFolderThreadSuspend = TRUE;
		}

	}
	else
	{
		// 增加时间文件结构，更新m_strDataRecord、m_strAlignProcessData和m_strCommunicationData的具体路径
		UpdateDataRecordTxtAddrTime();

		// 恢复删除文件夹线程
		if (m_bCheckRemoveFolderThreadSuspend == TRUE)
		{
			m_pCheckRemoveFolderThread->ResumeThread();
			m_bCheckRemoveFolderThreadSuspend = FALSE;
		}

	}

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveDataRecordInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));	

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveDataRecordInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();	

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))	
	{
		//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
		AlignXmlLog(_T("SaveDataRecordInfo"), _T("Find:WorkStationConfig"), FALSE);
		return FALSE;
	}

	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if(FALSE == m_XMLConfigator.FindElem(_T("LogParam")))
	{
		m_XMLConfigator.AddElem(_T("LogParam"));
	}
	m_XMLConfigator.EnterElem();


	if(FALSE == m_XMLConfigator.FindElem(_T("ASEnabled")))
	{
		m_XMLConfigator.AddElem(_T("ASEnabled"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo);	 

	if(FALSE == m_XMLConfigator.FindElem(_T("CommEnabled")))
	{
		m_XMLConfigator.AddElem(_T("CommEnabled"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bCommunication);	

	if(FALSE == m_XMLConfigator.FindElem(_T("AlignToolLog")))
	{
		m_XMLConfigator.AddElem(_T("AlignToolLog"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignToolLog);	


	if(FALSE == m_XMLConfigator.FindElem(_T("ImageName")))
	{
		m_XMLConfigator.AddElem(_T("ImageName"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bImageName);	 

	if(FALSE == m_XMLConfigator.FindElem(_T("SaveNGImage")))
	{
		m_XMLConfigator.AddElem(_T("SaveNGImage"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage);	 

	if(FALSE == m_XMLConfigator.FindElem(_T("SaveFailedImageNum")))
	{
		m_XMLConfigator.AddElem(_T("SaveFailedImageNum"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum);


	if(FALSE == m_XMLConfigator.FindElem(_T("SaveAllImage")))
	{
		m_XMLConfigator.AddElem(_T("SaveAllImage"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage);	 


	if(FALSE == m_XMLConfigator.FindElem(_T("SaveAllImageNum")))
	{
		m_XMLConfigator.AddElem(_T("SaveAllImageNum"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum);


	if(FALSE == m_XMLConfigator.FindElem(_T("SaveAllImageType")))
	{
		m_XMLConfigator.AddElem(_T("SaveAllImageType"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType);	 



	if(FALSE == m_XMLConfigator.FindElem(_T("ImageFormat")))
	{
		m_XMLConfigator.AddElem(_T("ImageFormat"));
	}
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_eImageFormat);

	if(FALSE == m_XMLConfigator.FindElem(_T("ImageQuality")))
	{
		m_XMLConfigator.AddElem(_T("ImageQuality"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nImageQuility);


	if(FALSE == m_XMLConfigator.FindElem(_T("SaveVDBFile")))
	{
		m_XMLConfigator.AddElem(_T("SaveVDBFile"));
	}
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile);

	if(FALSE == m_XMLConfigator.FindElem(_T("VDBNameByID")))
	{
		m_XMLConfigator.AddElem(_T("VDBNameByID"));
	}
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bVDBNameByID);

	if(FALSE == m_XMLConfigator.FindElem(_T("VDBImageQuality")))
	{
		m_XMLConfigator.AddElem(_T("VDBImageQuality"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nVDBImageQuility);

	if(FALSE == m_XMLConfigator.FindElem(_T("SaveVDBMaxNums")))
	{
		m_XMLConfigator.AddElem(_T("SaveVDBMaxNums"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums);

	if(FALSE == m_XMLConfigator.FindElem(_T("SaveTargetSnapVDBFile")))
	{
		m_XMLConfigator.AddElem(_T("SaveTargetSnapVDBFile"));
	}
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveTargetSnapVDBFile);
	if(FALSE == m_XMLConfigator.FindElem(_T("SaveProcessSnapVDBFile")))
	{
		m_XMLConfigator.AddElem(_T("SaveProcessSnapVDBFile"));
	}
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveProcessSnapVDBFile);

	//m_bSaveInsepectResultVDBFile
	if(FALSE == m_XMLConfigator.FindElem(_T("SaveInsepectResultVDBFile")))
	{
		m_XMLConfigator.AddElem(_T("SaveInsepectResultVDBFile"));
	}
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveInsepectResultVDBFile);

	if(FALSE == m_XMLConfigator.FindElem(_T("SaveObjectSnapVDBFile")))
	{
		m_XMLConfigator.AddElem(_T("SaveObjectSnapVDBFile"));
	}
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bSaveObjectSnapVDBFile);


	if(FALSE == m_XMLConfigator.FindElem(_T("GuitextWeight")))
	{
		m_XMLConfigator.AddElem(_T("GuitextWeight"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_GuitextWeight);
	if(FALSE == m_XMLConfigator.FindElem(_T("GuiLineWidth")))
	{
		m_XMLConfigator.AddElem(_T("GuiLineWidth"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_GuiLineWidth);

	if(FALSE == m_XMLConfigator.FindElem(_T("VBDImageType")))
	{
		m_XMLConfigator.AddElem(_T("VBDImageType"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nVBDImageType);


	if(FALSE == m_XMLConfigator.FindElem(_T("EnableCustomLogPath")))
	{
		m_XMLConfigator.AddElem(_T("EnableCustomLogPath"));
	}
	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bCustomLogPath);

	if(FALSE == m_XMLConfigator.FindElem(_T("bDataRecordTime")))
	{
		m_XMLConfigator.AddElem(_T("bDataRecordTime"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime);


	if(FALSE == m_XMLConfigator.FindElem(_T("nDataRecordTimeNum")))
	{
		m_XMLConfigator.AddElem(_T("nDataRecordTimeNum"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nDataRecordTimeNum);

	if(FALSE == m_XMLConfigator.FindElem(_T("StartHourRecordByDay")))
	{
		m_XMLConfigator.AddElem(_T("StartHourRecordByDay"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_nStartHourRecordByDay);

	if(FALSE == m_XMLConfigator.FindElem(_T("dDiskSpaceMaxUsePercent")))
	{
		m_XMLConfigator.AddElem(_T("dDiskSpaceMaxUsePercent"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_dDiskSpaceMaxUsePercent);


	if(FALSE == m_XMLConfigator.FindElem(_T("strDataRecordPath")))
	{
		m_XMLConfigator.AddElem(_T("strDataRecordPath"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath);


	// 	if(FALSE == m_XMLConfigator.FindElem(_T("UseThreadSaveImageMode")))
	// 	{
	// 		m_XMLConfigator.AddElem(_T("UseThreadSaveImageMode"));
	// 	}
	// 	m_XMLConfigator.SetElemData((int)m_pVisionASMConfig->m_DataRecord.m_bThreadSaveImageMode);









	if(FALSE == m_XMLConfigator.FindElem(_T("APEnabled")))
	{
		m_XMLConfigator.AddElem(_T("APEnabled"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision);	 


	if(FALSE == m_XMLConfigator.FindElem(_T("ATEnabled")))
	{
		m_XMLConfigator.AddElem(_T("ATEnabled"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bAlignerTime);	 


	if(FALSE == m_XMLConfigator.FindElem(_T("MergeEnabled")))
	{
		m_XMLConfigator.AddElem(_T("MergeEnabled"));
	}
	m_XMLConfigator.SetElemData(m_pVisionASMConfig->m_DataRecord.m_bDataMerged);

	// 	if(FALSE == m_XMLConfigator.FindElem(_T("AllImgDir")))
	// 	{

	m_XMLConfigator.LeaveElem(); //退出中间数据记录

	m_XMLConfigator.LeaveElem();

	BOOL bOK = m_XMLConfigator.Save(strPlatformXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SaveDataRecordInfo_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SaveDataRecordInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadAlignerTypeInfo()
{
	if (NULL == m_pAlignerTypeInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadAlignerTypeInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (m_XMLConfigator.FindElem(_T("AlignerTypeInfo")))
	{
		m_XMLConfigator.EnterElem();
		//2Vs2
		m_XMLConfigator.FindElem(_T("Aligner2Vs2TypeInfo"));
		m_XMLConfigator.EnterElem();
		vector<Aligner2Vs2TypeInfo>::iterator iterAligner2Vs2;
		iterAligner2Vs2 = m_pAlignerTypeInfo->m_vAligner2Vs2TypeInfo.begin();
		for(;iterAligner2Vs2 != m_pAlignerTypeInfo->m_vAligner2Vs2TypeInfo.end();iterAligner2Vs2++)
		{
			if(m_XMLConfigator.FindElem(iterAligner2Vs2->m_strAlignerName))
			{
				iterAligner2Vs2->m_bOpenAligner = _ttoi(m_XMLConfigator.GetElemData());
			}
		}
		m_XMLConfigator.LeaveElem();
		//3Vs3
		m_XMLConfigator.FindElem(_T("Aligner3Vs3TypeInfo"));
		m_XMLConfigator.EnterElem();
		vector<Aligner3Vs3TypeInfo>::iterator iterAligner3Vs3;
		iterAligner3Vs3 = m_pAlignerTypeInfo->m_vAligner3Vs3TypeInfo.begin();
		for(;iterAligner3Vs3 != m_pAlignerTypeInfo->m_vAligner3Vs3TypeInfo.end();iterAligner3Vs3++)
		{
			if(m_XMLConfigator.FindElem(iterAligner3Vs3->m_strAlignerName))
			{
				iterAligner3Vs3->m_bOpenAligner = _ttoi(m_XMLConfigator.GetElemData());
			}
		}
		m_XMLConfigator.LeaveElem();
		//4Vs4
		m_XMLConfigator.FindElem(_T("Aligner4Vs4TypeInfo"));
		m_XMLConfigator.EnterElem();
		vector<Aligner4Vs4TypeInfo>::iterator iterAligner4Vs4;
		iterAligner4Vs4 = m_pAlignerTypeInfo->m_vAligner4Vs4TypeInfo.begin();
		for(;iterAligner4Vs4 != m_pAlignerTypeInfo->m_vAligner4Vs4TypeInfo.end();iterAligner4Vs4++)
		{
			if(m_XMLConfigator.FindElem(iterAligner4Vs4->m_strAlignerName))
			{
				iterAligner4Vs4->m_bOpenAligner = _ttoi(m_XMLConfigator.GetElemData());
			}
		}
		m_XMLConfigator.LeaveElem();

		m_XMLConfigator.LeaveElem();

	}    	    
	else
	{
		m_XMLConfigator.LeaveElem();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	//// 更新数据记录的位置
	UpdateDataRecordTxtAddr();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveAlignerTypeInfo()
{
	if (NULL == m_pAlignerTypeInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}


	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveAlignerTypeInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
	{
		AlignXmlLog(_T("SaveAlignerTypeInfo"),_T("Find:WorkStationConfig"),FALSE);
		return FALSE;
	}
	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerTypeInfo")))
	{
		m_XMLConfigator.AddElem(_T("AlignerTypeInfo"));
	}
	m_XMLConfigator.EnterElem();
	{
		//2vs2
		if (FALSE == m_XMLConfigator.FindElem(_T("Aligner2Vs2TypeInfo")))
		{
			m_XMLConfigator.AddElem(_T("Aligner2Vs2TypeInfo"));
		}
		m_XMLConfigator.EnterElem();
		vector<Aligner2Vs2TypeInfo>::iterator iterAligner2Vs2;
		for (iterAligner2Vs2 = m_pAlignerTypeInfo->m_vAligner2Vs2TypeInfo.begin();iterAligner2Vs2 != m_pAlignerTypeInfo->m_vAligner2Vs2TypeInfo.end();iterAligner2Vs2++)
		{
			if (FALSE == m_XMLConfigator.FindElem(iterAligner2Vs2->m_strAlignerName))
			{
				m_XMLConfigator.AddElem(iterAligner2Vs2->m_strAlignerName);
			}
			m_XMLConfigator.SetElemData(iterAligner2Vs2->m_bOpenAligner);	
		}
		m_XMLConfigator.LeaveElem();
		//3vs3
		if (FALSE == m_XMLConfigator.FindElem(_T("Aligner3Vs3TypeInfo")))
		{
			m_XMLConfigator.AddElem(_T("Aligner3Vs3TypeInfo"));
		}
		m_XMLConfigator.EnterElem();
		vector<Aligner3Vs3TypeInfo>::iterator iterAligner3Vs3;
		for (iterAligner3Vs3 = m_pAlignerTypeInfo->m_vAligner3Vs3TypeInfo.begin();iterAligner3Vs3 != m_pAlignerTypeInfo->m_vAligner3Vs3TypeInfo.end();iterAligner3Vs3++)
		{
			if (FALSE == m_XMLConfigator.FindElem(iterAligner3Vs3->m_strAlignerName))
			{
				m_XMLConfigator.AddElem(iterAligner3Vs3->m_strAlignerName);
			}
			m_XMLConfigator.SetElemData(iterAligner3Vs3->m_bOpenAligner);	
		}
		m_XMLConfigator.LeaveElem();
		//4vs4
		if (FALSE == m_XMLConfigator.FindElem(_T("Aligner4Vs4TypeInfo")))
		{
			m_XMLConfigator.AddElem(_T("Aligner4Vs4TypeInfo"));
		}
		m_XMLConfigator.EnterElem();
		vector<Aligner4Vs4TypeInfo>::iterator iterAligner4Vs4;
		for (iterAligner4Vs4 = m_pAlignerTypeInfo->m_vAligner4Vs4TypeInfo.begin();iterAligner4Vs4 != m_pAlignerTypeInfo->m_vAligner4Vs4TypeInfo.end();iterAligner4Vs4++)
		{
			if (FALSE == m_XMLConfigator.FindElem(iterAligner4Vs4->m_strAlignerName))
			{
				m_XMLConfigator.AddElem(iterAligner4Vs4->m_strAlignerName);
			}
			m_XMLConfigator.SetElemData(iterAligner4Vs4->m_bOpenAligner);	
		}
		m_XMLConfigator.LeaveElem();
	}
	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();
	//// 更新数据记录的位置
	//UpdateDataRecordTxtAddr();
	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SaveAlignerTypeInfo_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SaveAlignerTypeInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadSearchToolDataInfo()
{
	if (NULL == m_pDlgSearchToolInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadSearchToolDataInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (m_XMLConfigator.FindElem(_T("SearchToolParam")))
	{
		m_XMLConfigator.EnterElem();

		map<pair<int,CString>,BOOL>::iterator iterDlg;
		iterDlg = m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.begin();
		for(;iterDlg != m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.end();iterDlg++)
		{
			if(m_XMLConfigator.FindElem(iterDlg->first.second))
			{
				m_XMLConfigator.GetElemData(iterDlg->second);
			}
		}

		m_XMLConfigator.LeaveElem();
	}    	    
	else
	{
		m_XMLConfigator.LeaveElem();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	//// 更新数据记录的位置
	UpdateDataRecordTxtAddr();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveSearchToolDataInfo()
{
	if (NULL == m_pDlgSearchToolInfo)
	{
		return FALSE;
	}

	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}


	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveSearchToolDataInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
	{
		AlignXmlLog(_T("SaveSearchToolDataInfo"),_T("Find:WorkStationConfig"),FALSE);
		return FALSE;
	}
	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (FALSE == m_XMLConfigator.FindElem(_T("SearchToolParam")))
	{
		m_XMLConfigator.AddElem(_T("SearchToolParam"));
	}
	m_XMLConfigator.EnterElem();

	vector<map<pair<int,int>,BOOL>>::iterator iterSys;

	map<pair<int,CString>,BOOL>::iterator iterDlg;

	iterSys = m_pPlatformInfo->m_vmapSysSearchToolInfo.begin();


	for (;iterSys != m_pPlatformInfo->m_vmapSysSearchToolInfo.end();iterSys++)
	{
		if ((*iterSys).begin()->second)
		{
			for (iterDlg = m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.begin();iterDlg != m_pDlgSearchToolInfo->m_mapDlgSearchToolInfo.end();iterDlg++)
			{
				if ((*iterSys).begin()->first.first == iterDlg->first.first)
				{
					if (FALSE == m_XMLConfigator.FindElem(iterDlg->first.second))
					{
						m_XMLConfigator.AddElem(iterDlg->first.second);
					}
					m_XMLConfigator.SetElemData(iterDlg->second);
					break;
				}

			}
		}
	}

	m_XMLConfigator.LeaveElem();


	m_XMLConfigator.LeaveElem();

	//// 更新数据记录的位置
	//UpdateDataRecordTxtAddr();
	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SaveSearchToolDataInfo_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SaveSearchToolDataInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadPlatformOptionInfo()
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadPlatformOptionInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (m_XMLConfigator.FindElem(_T("PlatformOptionInfo")))
	{
		m_XMLConfigator.EnterElem();
		CPlatformOptionInfo optionInfo;
		if (m_XMLConfigator.FindElem(_T("SearchWithDistanceInspect")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSearchWithDistanceInspect = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("SendInsDistanceInSearchResult")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSendInsDistanceInSearchResult = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("OffsetPicturePath")))
		{
			optionInfo.m_strOffsetPicturePath = m_XMLConfigator.GetElemData();
		}
		if (m_XMLConfigator.FindElem(_T("EnableDmCodeCalib")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableDmCodeCalib = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("TargetInfoCommunicationModeInDifferentPC")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_nTarInfoCommModeInDiffPC = k;
		}
		if (m_XMLConfigator.FindElem(_T("EnableAlignAfterSearch")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableAlignAfterSearch = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("SendMulAlignResult")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSendMulAlignResult = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("RecordCamFixMarkPos")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bRecordCamFixMarkPos = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("ObjectSearchExProduct")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bObjectSearchExProduct = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("TargetSearchExProduct")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bTargetSearchExProduct = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("AlignExProduct")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bAlignExProduct = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("SaveCalibData")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSaveCalibData = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("AutoCopyCalibData")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bAutoCopyCalibData = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("bAutoCopyCalibDataExProduct")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bAutoCopyCalibDataExProduct = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("SendAreaInspectSubResult")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSendAreaInspectSubResult = (BOOL)k;
		}


		if (m_XMLConfigator.FindElem(_T("OffsetMaxX")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dOffsetMaxX = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("OffsetMaxY")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dOffsetMaxY = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("OffsetMaxD")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dOffsetMaxD = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("OffsetMaxXLowerLimit")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dOffsetMaxX_LowerLimit = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("OffsetMaxYLowerLimit")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dOffsetMaxY_LowerLimit = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("OffsetMaxDLowerLimit")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dOffsetMaxD_LowerLimit = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("AxisMoveMaxX")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dAxisMoveMaxX = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("AxisMoveMaxY")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dAxisMoveMaxY = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("AxisMoveMaxD")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dAxisMoveMaxD = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("AxisMoveMaxXLowerLimit")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dAxisMoveMaxX_LowerLimit = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("AxisMoveMaxYLowerLimit")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dAxisMoveMaxY_LowerLimit = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("AxisMoveMaxDLowerLimit")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dAxisMoveMaxD_LowerLimit = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("OmitRePickObjectEnable")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bOmitRePickObjectEnable = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("RePickOffsetMaxX")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dRePickOffsetMaxX = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("RePickOffsetMaxY")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dRePickOffsetMaxY = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("OmitRePickObjectEnable_MM")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bOmitRePickObjectEnable_MM = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("RePickOffsetMaxX_MM")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dRePickOffsetMaxX_MM = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("RePickOffsetMaxY_MM")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dRePickOffsetMaxY_MM = dVal;
		}

		//////////////////////////////////////////////////////////////////////////
		if (m_XMLConfigator.FindElem(_T("EnableCalibrateCheckByAxisMoveOption")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableCalibrateCheckByAxisMoveOption = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeX")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dCalibrateCheckAxisMoveRangeX = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeY")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dCalibrateCheckAxisMoveRangeY = dVal;
		}


		if (m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeD")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dCalibrateCheckAxisMoveRangeD = dVal;
		}
		//////////////////////////////////////////////////////////////////////////


		if (m_XMLConfigator.FindElem(_T("OffSetShowParam")))
		{
			m_XMLConfigator.EnterElem();

			if(m_XMLConfigator.FindElem(_T("ShowOffsetTips")))	// Level3
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_OffsetShowParam.m_bShowOffsetTips = (BOOL)k;
			}

			if(m_XMLConfigator.FindElem(_T("SetOffsetTip")))	// Level3
			{
				int k=0;
				m_XMLConfigator.GetElemData(k);
				optionInfo.m_OffsetShowParam.m_bSetOffsetTip = (BOOL)k;
			}

			m_XMLConfigator.LeaveElem();
		}

		if (m_XMLConfigator.FindElem(_T("TargetAutoCalibAlignMode")))
		{
			int k = 0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_eTarAutoCalibAlignMode = (TargetAutoCalibAlignMode)k;
		}

		if (m_XMLConfigator.FindElem(_T("ReadWriteAxisPosWithCmd")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bReadWriteAxisPosWithCmd = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("EnableMutiTarget")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableMutiTarget = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("TargetUseFixedVirtualCoordinates")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bTargetUseFixedVirtualCoordinates = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("CalibrateChangeXDirection")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bCalibrateChangeXDirection = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("CalibrateChangeYDirection")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bCalibrateChangeYDirection = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("CalibrateChangeDDirection")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bCalibrateChangeDDirection = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("EnableCalibrateCheckBySize")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableCalibrateCheckBySize = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("EnableRelevanceCheckBySize")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableRelevanceCheckBySize = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("EnableCalibrateCheckByFixedTargetAligner")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableCalibrateCheckByFixedTargetAligner = (BOOL)k;
		}

		//if (m_XMLConfigator.FindElem(_T("CalibSendAbsPos")))
		//{
		//	int k=0;
		//	m_XMLConfigator.GetElemData(k);
		//	optionInfo.m_bCalibSendAbsPos = (BOOL)k;
		//}

		if (m_XMLConfigator.FindElem(_T("CalibSendRelativePos")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bCalibSendRelativePos = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("EnableMultiMarkMode")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableMultiMarkMode = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("EnableAlignOffsetMarkByAera")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableAlignOffsetMarkByAera = (BOOL)k;
		}

		//if (m_XMLConfigator.FindElem(_T("InspectEnable")))
		//{
		//	int k=0;
		//	m_XMLConfigator.GetElemData(k);
		//	optionInfo.m_bInspectEnable = (BOOL)k;
		//}

		if (m_XMLConfigator.FindElem(_T("EnableTargetAndObjectPositionVirtualMode")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableTargetAndObjectPositionVirtualMode = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("LastPickSetting")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bLastPickSetting = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("EnablePickPosUpdate")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnablePickPosUpdate = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("EnablePickSendRelativateAxis")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnablePickSendRelativateAxis = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("FAALAlignOneTimeTargetSeachSnap")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bFAALAlignOneTimeTargetSeachSnap = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ObjMulSearchPosXYPD")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bObjMulSearchPosXYPD = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("TargetAngleMulAlignerXYPD")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bTargetAngleMulAlignerXYPD = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("AskStagePosEachMove")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bAskStagePosEachMove = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("AlignOneTime")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bAlignOneTime = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("TargetPosSame")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bTargetPosSame = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ObjectPosSame")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bObjectPosSame = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("SaveAlignPos")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSaveAlignPos = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("EnableSearchCindidate")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableSearchCindidate = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("EnableSearchTimes")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSearchTimes = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("SearchTimes")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_nSearchTimes = k;
		}
		if (m_XMLConfigator.FindElem(_T("SearchDelayTime")))
		{
			int k=0;	   
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_nSearchDelayTime = k;
		}
		if (m_XMLConfigator.FindElem(_T("EnableSearchShutter")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableSearchShutter = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ManualAfTarSearchFail")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bManualAfTarSearchFail = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ManualAfObjSearchFail")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bManualAfObjSearchFail = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("AlignFinishClearSnapStatus")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bAlignFinishClearSnapStatus = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("ExeObjectCheckModeWhenAlign")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bExeObjectCheckModeWhenAlign = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ExeTargetCheckModeWhenAlign")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bExeTargetCheckModeWhenAlign = (BOOL)k;
		}

		//m_bEnablePhotoLightCtrl
		if (m_XMLConfigator.FindElem(_T("EnablePhotoLightCtrl")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnablePhotoLightCtrl = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("EnableAlignBenchCenter")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableAlignBenchCenter = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("SetVisionManualSearchToPLC")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSetVisionManualSearchToPLC = (BOOL)k;
		}

		//BOOL m_bSetVisionManualSearchToPLC2;
		if (m_XMLConfigator.FindElem(_T("SetVisionManualSearchToPLC2")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bSetVisionManualSearchToPLC2 = (BOOL)k;
		}
		//int m_nVisionManualSearchToPlcAddre;
		if (m_XMLConfigator.FindElem(_T("VisionManualSearchToPlcAddre")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_nVisionManualSearchToPlcAddre = k;
		}

		if (m_XMLConfigator.FindElem(_T("VisionOnLineStatus")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bVisionOnLineStatus = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("EnableCommMultiCalibExtension")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableCommMultiCalibExtension = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ManualAfTarSearchFailShowButton")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bManualAfTarSearchFailShowButton = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ManualAfTarSearchFailShowButton")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bManualAfTarSearchFailShowButton = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ManualAfObjSearchFailShowButton")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bManualAfObjSearchFailShowButton = (BOOL)k;
		}
		
		if (m_XMLConfigator.FindElem(_T("ShowFWEL")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bShowFWEL = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("ShowBend")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bShowBend = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("bTargetSeachSnapEverytime")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bTargetSeachSnapEverytime = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("nBendFIsAlignFinished")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_nBendFIsAlignFinished = k;
		}

		if (m_XMLConfigator.FindElem(_T("ShowEightShapeAlign")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bShowEightShapeAlign = (BOOL)k;
		}

		if (m_XMLConfigator.FindElem(_T("bEnableAngleCorrect")))
		{
			int k=0;
			m_XMLConfigator.GetElemData(k);
			optionInfo.m_bEnableAngleCorrect = (BOOL)k;
		}
		if (m_XMLConfigator.FindElem(_T("NumberOfInspectResults")))
		{
			int nVal = 0;
			m_XMLConfigator.GetElemData(nVal);
			optionInfo.m_nNumberOfInspectResults = nVal;
		}
		if (m_XMLConfigator.FindElem(_T("dAngleCorrect")))
		{
			double dVal = 0.0;
			m_XMLConfigator.GetElemData(dVal);
			optionInfo.m_dAngleCorrect = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("FCHBSaveCSVHead")))
		{
			CString dVal=m_XMLConfigator.GetElemData();

			optionInfo.m_sFCHBSaveCSVHead = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("StepID")))
		{
			CString dVal=m_XMLConfigator.GetElemData();

			optionInfo.m_StepID = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("FoamSize")))
		{
			CString dVal=m_XMLConfigator.GetElemData();

			optionInfo.m_FoamSize = dVal;
		}
		if (m_XMLConfigator.FindElem(_T("BendingR")))
		{
			CString dVal=m_XMLConfigator.GetElemData();

			optionInfo.m_BendingR = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("FieldCount")))
		{
			CString dVal=m_XMLConfigator.GetElemData();

			optionInfo.m_FieldCount = dVal;
		}

		if (m_XMLConfigator.FindElem(_T("Production")))
		{
			CString dVal=m_XMLConfigator.GetElemData();

			optionInfo.m_Production = dVal;
		}

		if(TRUE == m_XMLConfigator.FindElem(_T("vnMulRegTriggerSet")))
		{
			m_XMLConfigator.EnterElem();
			{
				int nSize = 1;
				if (m_XMLConfigator.FindElem(_T("nSize")))
				{
					int k=0;
					m_XMLConfigator.GetElemData(k);
					nSize = k;
				}

				optionInfo.m_vnMulRegTriggerSet.resize(nSize);
				for (int it=0;it<nSize;it++)
				{
					strInfo.Format(_T("MulRegParam%d"),it+1);
					if(TRUE == m_XMLConfigator.FindElem(strInfo))
					{
						m_XMLConfigator.EnterElem(); 
						{
							optionInfo.m_vnMulRegTriggerSet[it].LoadModelFromFile(m_XMLConfigator);
						}
						m_XMLConfigator.LeaveElem();
					}
				}
			}
			m_XMLConfigator.LeaveElem();
		}

		SetPlatformOptionInfo(optionInfo);



		m_XMLConfigator.LeaveElem();
	}    	

	m_XMLConfigator.LeaveElem();

	//// 更新数据记录的位置
	UpdateDataRecordTxtAddr();

	return TRUE;
}

BOOL vcBaseVisionAlign::SavePlatformOptionInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}


	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SavePlatformOptionInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
	{
		AlignXmlLog(_T("SavePlatformOptionInfo"),_T("Find:WorkStationConfig"),FALSE);
		return FALSE;
	}
	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (FALSE == m_XMLConfigator.FindElem(_T("PlatformOptionInfo")))
	{
		m_XMLConfigator.AddElem(_T("PlatformOptionInfo"));
	}
	m_XMLConfigator.EnterElem();

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (FALSE == m_XMLConfigator.FindElem(_T("SearchWithDistanceInspect")))
	{
		m_XMLConfigator.AddElem(_T("SearchWithDistanceInspect"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSearchWithDistanceInspect);

	if (FALSE == m_XMLConfigator.FindElem(_T("SendInsDistanceInSearchResult")))
	{
		m_XMLConfigator.AddElem(_T("SendInsDistanceInSearchResult"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSendInsDistanceInSearchResult);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetPicturePath")))
	{
		m_XMLConfigator.AddElem(_T("OffsetPicturePath"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_strOffsetPicturePath);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableDmCodeCalib")))
	{
		m_XMLConfigator.AddElem(_T("EnableDmCodeCalib"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableDmCodeCalib);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetInfoCommunicationModeInDifferentPC")))
	{
		m_XMLConfigator.AddElem(_T("TargetInfoCommunicationModeInDifferentPC"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nTarInfoCommModeInDiffPC);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableAlignAfterSearch")))
	{
		m_XMLConfigator.AddElem(_T("EnableAlignAfterSearch"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableAlignAfterSearch);

	if (FALSE == m_XMLConfigator.FindElem(_T("SendMulAlignResult")))
	{
		m_XMLConfigator.AddElem(_T("SendMulAlignResult"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSendMulAlignResult);

	if (FALSE == m_XMLConfigator.FindElem(_T("RecordCamFixMarkPos")))
	{
		m_XMLConfigator.AddElem(_T("RecordCamFixMarkPos"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bRecordCamFixMarkPos);

	if (FALSE == m_XMLConfigator.FindElem(_T("ObjectSearchExProduct")))
	{
		m_XMLConfigator.AddElem(_T("ObjectSearchExProduct"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bObjectSearchExProduct);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetSearchExProduct")))
	{
		m_XMLConfigator.AddElem(_T("TargetSearchExProduct"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetSearchExProduct);

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignExProduct")))
	{
		m_XMLConfigator.AddElem(_T("AlignExProduct"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAlignExProduct);

	if (FALSE == m_XMLConfigator.FindElem(_T("SaveCalibData")))
	{
		m_XMLConfigator.AddElem(_T("SaveCalibData"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSaveCalibData);

	if (FALSE == m_XMLConfigator.FindElem(_T("AutoCopyCalibData")))
	{
		m_XMLConfigator.AddElem(_T("AutoCopyCalibData"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAutoCopyCalibData);

	if (FALSE == m_XMLConfigator.FindElem(_T("bAutoCopyCalibDataExProduct")))
	{
		m_XMLConfigator.AddElem(_T("bAutoCopyCalibDataExProduct"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAutoCopyCalibDataExProduct);

	if (FALSE == m_XMLConfigator.FindElem(_T("SendAreaInspectSubResult")))
	{
		m_XMLConfigator.AddElem(_T("SendAreaInspectSubResult"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSendAreaInspectSubResult);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxX")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxX"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxX);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxY")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxY"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxY);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxD")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxD"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxD);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxXLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxXLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxX_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxYLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxYLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxY_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("OffsetMaxDLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("OffsetMaxDLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dOffsetMaxD_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxX")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxX"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxX);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxY")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxY"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxY);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxD")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxD"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxD);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxXLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxXLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxX_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxYLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxYLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxY_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("AxisMoveMaxDLowerLimit")))
	{
		m_XMLConfigator.AddElem(_T("AxisMoveMaxDLowerLimit"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAxisMoveMaxD_LowerLimit);

	if (FALSE == m_XMLConfigator.FindElem(_T("OmitRePickObjectEnable")))
	{
		m_XMLConfigator.AddElem(_T("OmitRePickObjectEnable"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bOmitRePickObjectEnable);

	if (FALSE == m_XMLConfigator.FindElem(_T("RePickOffsetMaxX")))
	{
		m_XMLConfigator.AddElem(_T("RePickOffsetMaxX"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dRePickOffsetMaxX);

	if (FALSE == m_XMLConfigator.FindElem(_T("RePickOffsetMaxY")))
	{
		m_XMLConfigator.AddElem(_T("RePickOffsetMaxY"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dRePickOffsetMaxY);

	if (FALSE == m_XMLConfigator.FindElem(_T("OmitRePickObjectEnable_MM")))
	{
		m_XMLConfigator.AddElem(_T("OmitRePickObjectEnable_MM"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bOmitRePickObjectEnable_MM);

	if (FALSE == m_XMLConfigator.FindElem(_T("RePickOffsetMaxX_MM")))
	{
		m_XMLConfigator.AddElem(_T("RePickOffsetMaxX_MM"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dRePickOffsetMaxX_MM);

	if (FALSE == m_XMLConfigator.FindElem(_T("RePickOffsetMaxY_MM")))
	{
		m_XMLConfigator.AddElem(_T("RePickOffsetMaxY_MM"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dRePickOffsetMaxY_MM);


	//////////////////////////////////////////////////////////////////////////
	if (FALSE == m_XMLConfigator.FindElem(_T("EnableCalibrateCheckByAxisMoveOption")))
	{
		m_XMLConfigator.AddElem(_T("EnableCalibrateCheckByAxisMoveOption"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableCalibrateCheckByAxisMoveOption);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeX")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateCheckAxisMoveRangeX"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dCalibrateCheckAxisMoveRangeX);


	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeY")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateCheckAxisMoveRangeY"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dCalibrateCheckAxisMoveRangeY);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateCheckAxisMoveRangeD")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateCheckAxisMoveRangeD"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dCalibrateCheckAxisMoveRangeD);
	//////////////////////////////////////////////////////////////////////////


	if (FALSE == m_XMLConfigator.FindElem(_T("OffSetShowParam")))	//Level2
	{
		m_XMLConfigator.AddElem(_T("OffSetShowParam"));
	}
	m_XMLConfigator.EnterElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("ShowOffsetTips")))//Level3
	{
		m_XMLConfigator.AddElem(_T("ShowOffsetTips"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_OffsetShowParam.m_bShowOffsetTips);

	if (FALSE == m_XMLConfigator.FindElem(_T("SetOffsetTip")))//Level3
	{
		m_XMLConfigator.AddElem(_T("SetOffsetTip"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_OffsetShowParam.m_bSetOffsetTip);

	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetAutoCalibAlignMode")))
	{
		m_XMLConfigator.AddElem(_T("TargetAutoCalibAlignMode"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_eTarAutoCalibAlignMode);

	if (FALSE == m_XMLConfigator.FindElem(_T("ReadWriteAxisPosWithCmd")))
	{
		m_XMLConfigator.AddElem(_T("ReadWriteAxisPosWithCmd"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bReadWriteAxisPosWithCmd);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableMutiTarget")))
	{
		m_XMLConfigator.AddElem(_T("EnableMutiTarget"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableMutiTarget);


	if (FALSE == m_XMLConfigator.FindElem(_T("TargetUseFixedVirtualCoordinates")))
	{
		m_XMLConfigator.AddElem(_T("TargetUseFixedVirtualCoordinates"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetUseFixedVirtualCoordinates);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateChangeXDirection")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateChangeXDirection"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibrateChangeXDirection);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateChangeYDirection")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateChangeYDirection"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibrateChangeYDirection);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibrateChangeDDirection")))
	{
		m_XMLConfigator.AddElem(_T("CalibrateChangeDDirection"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibrateChangeDDirection);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableCalibrateCheckBySize")))
	{
		m_XMLConfigator.AddElem(_T("EnableCalibrateCheckBySize"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableCalibrateCheckBySize);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableRelevanceCheckBySize")))
	{
		m_XMLConfigator.AddElem(_T("EnableRelevanceCheckBySize"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableRelevanceCheckBySize);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableCalibrateCheckByFixedTargetAligner")))
	{
		m_XMLConfigator.AddElem(_T("EnableCalibrateCheckByFixedTargetAligner"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableCalibrateCheckByFixedTargetAligner);

	//if (FALSE == m_XMLConfigator.FindElem(_T("CalibSendAbsPos")))
	//{
	//	m_XMLConfigator.AddElem(_T("CalibSendAbsPos"));
	//}
	//m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibSendAbsPos);

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibSendRelativePos")))
	{
		m_XMLConfigator.AddElem(_T("CalibSendRelativePos"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bCalibSendRelativePos);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableMultiMarkMode")))
	{
		m_XMLConfigator.AddElem(_T("EnableMultiMarkMode"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableMultiMarkMode);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableAlignOffsetMarkByAera")))
	{
		m_XMLConfigator.AddElem(_T("EnableAlignOffsetMarkByAera"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableAlignOffsetMarkByAera);

	//if (FALSE == m_XMLConfigator.FindElem(_T("InspectEnable")))
	//{
	//	m_XMLConfigator.AddElem(_T("InspectEnable"));
	//}
	//m_XMLConfigator.SetElemData((int)optionInfo.m_bInspectEnable);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableTargetAndObjectPositionVirtualMode")))
	{
		m_XMLConfigator.AddElem(_T("EnableTargetAndObjectPositionVirtualMode"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableTargetAndObjectPositionVirtualMode);


	if (FALSE == m_XMLConfigator.FindElem(_T("LastPickSetting")))
	{
		m_XMLConfigator.AddElem(_T("LastPickSetting"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bLastPickSetting);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnablePickPosUpdate")))
	{
		m_XMLConfigator.AddElem(_T("EnablePickPosUpdate"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnablePickPosUpdate);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnablePickSendRelativateAxis")))
	{
		m_XMLConfigator.AddElem(_T("EnablePickSendRelativateAxis"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnablePickSendRelativateAxis);

	if (FALSE == m_XMLConfigator.FindElem(_T("FAALAlignOneTimeTargetSeachSnap")))
	{
		m_XMLConfigator.AddElem(_T("FAALAlignOneTimeTargetSeachSnap"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bFAALAlignOneTimeTargetSeachSnap);

	if (FALSE == m_XMLConfigator.FindElem(_T("ObjMulSearchPosXYPD")))
	{
		m_XMLConfigator.AddElem(_T("ObjMulSearchPosXYPD"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bObjMulSearchPosXYPD);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetAngleMulAlignerXYPD")))
	{
		m_XMLConfigator.AddElem(_T("TargetAngleMulAlignerXYPD"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetAngleMulAlignerXYPD);


	if (FALSE == m_XMLConfigator.FindElem(_T("AskStagePosEachMove")))
	{
		m_XMLConfigator.AddElem(_T("AskStagePosEachMove"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAskStagePosEachMove);

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignOneTime")))
	{
		m_XMLConfigator.AddElem(_T("AlignOneTime"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAlignOneTime);

	if (FALSE == m_XMLConfigator.FindElem(_T("TargetPosSame")))
	{
		m_XMLConfigator.AddElem(_T("TargetPosSame"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetPosSame);

	if (FALSE == m_XMLConfigator.FindElem(_T("ObjectPosSame")))
	{
		m_XMLConfigator.AddElem(_T("ObjectPosSame"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bObjectPosSame);

	if (FALSE == m_XMLConfigator.FindElem(_T("SaveAlignPos")))
	{
		m_XMLConfigator.AddElem(_T("SaveAlignPos"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSaveAlignPos);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableSearchCindidate")))
	{
		m_XMLConfigator.AddElem(_T("EnableSearchCindidate"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableSearchCindidate);


	if (FALSE == m_XMLConfigator.FindElem(_T("EnableSearchTimes")))
	{
		m_XMLConfigator.AddElem(_T("EnableSearchTimes"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSearchTimes);

	if (FALSE == m_XMLConfigator.FindElem(_T("SearchTimes")))
	{
		m_XMLConfigator.AddElem(_T("SearchTimes"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nSearchTimes);
	if (FALSE == m_XMLConfigator.FindElem(_T("SearchDelayTime")))
	{
		m_XMLConfigator.AddElem(_T("SearchDelayTime"));
	}							 
	m_XMLConfigator.SetElemData(optionInfo.m_nSearchDelayTime);
	if (FALSE == m_XMLConfigator.FindElem(_T("EnableSearchShutter")))
	{
		m_XMLConfigator.AddElem(_T("EnableSearchShutter"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableSearchShutter);


	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfTarSearchFail")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfTarSearchFail"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfTarSearchFail);

	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfObjSearchFail")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfObjSearchFail"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfObjSearchFail);

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignFinishClearSnapStatus")))
	{
		m_XMLConfigator.AddElem(_T("AlignFinishClearSnapStatus"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bAlignFinishClearSnapStatus);

	if (FALSE == m_XMLConfigator.FindElem(_T("ExeObjectCheckModeWhenAlign")))
	{
		m_XMLConfigator.AddElem(_T("ExeObjectCheckModeWhenAlign"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bExeObjectCheckModeWhenAlign);

	if (FALSE == m_XMLConfigator.FindElem(_T("ExeTargetCheckModeWhenAlign")))
	{
		m_XMLConfigator.AddElem(_T("ExeTargetCheckModeWhenAlign"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bExeTargetCheckModeWhenAlign);

	//m_bEnablePhotoLightCtrl
	if (FALSE == m_XMLConfigator.FindElem(_T("EnablePhotoLightCtrl")))
	{
		m_XMLConfigator.AddElem(_T("EnablePhotoLightCtrl"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnablePhotoLightCtrl);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableAlignBenchCenter")))
	{
		m_XMLConfigator.AddElem(_T("EnableAlignBenchCenter"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableAlignBenchCenter);

	if (FALSE == m_XMLConfigator.FindElem(_T("SetVisionManualSearchToPLC")))
	{
		m_XMLConfigator.AddElem(_T("SetVisionManualSearchToPLC"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSetVisionManualSearchToPLC);

	//BOOL m_bSetVisionManualSearchToPLC2;
	if (FALSE == m_XMLConfigator.FindElem(_T("SetVisionManualSearchToPLC2")))
	{
		m_XMLConfigator.AddElem(_T("SetVisionManualSearchToPLC2"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bSetVisionManualSearchToPLC2);
	//int m_nVisionManualSearchToPlcAddre;
	if (FALSE == m_XMLConfigator.FindElem(_T("VisionManualSearchToPlcAddre")))
	{
		m_XMLConfigator.AddElem(_T("VisionManualSearchToPlcAddre"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nVisionManualSearchToPlcAddre);

	if (FALSE == m_XMLConfigator.FindElem(_T("VisionOnLineStatus")))
	{
		m_XMLConfigator.AddElem(_T("VisionOnLineStatus"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bVisionOnLineStatus);

	if (FALSE == m_XMLConfigator.FindElem(_T("EnableCommMultiCalibExtension")))
	{
		m_XMLConfigator.AddElem(_T("EnableCommMultiCalibExtension"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableCommMultiCalibExtension);

	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfTarSearchFailShowButton")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfTarSearchFailShowButton"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfTarSearchFailShowButton);

	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfTarSearchFailShowButton")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfTarSearchFailShowButton"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfTarSearchFailShowButton);

	if (FALSE == m_XMLConfigator.FindElem(_T("ManualAfObjSearchFailShowButton")))
	{
		m_XMLConfigator.AddElem(_T("ManualAfObjSearchFailShowButton"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bManualAfObjSearchFailShowButton);


	if (FALSE == m_XMLConfigator.FindElem(_T("ShowFWEL")))
	{
		m_XMLConfigator.AddElem(_T("ShowFWEL"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bShowFWEL);


	if (FALSE == m_XMLConfigator.FindElem(_T("ShowBend")))
	{
		m_XMLConfigator.AddElem(_T("ShowBend"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bShowBend);

	if (FALSE == m_XMLConfigator.FindElem(_T("bTargetSeachSnapEverytime")))
	{
		m_XMLConfigator.AddElem(_T("bTargetSeachSnapEverytime"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bTargetSeachSnapEverytime);

	if (FALSE == m_XMLConfigator.FindElem(_T("nBendFIsAlignFinished")))
	{
		m_XMLConfigator.AddElem(_T("nBendFIsAlignFinished"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nBendFIsAlignFinished);

	if (FALSE == m_XMLConfigator.FindElem(_T("ShowEightShapeAlign")))
	{
		m_XMLConfigator.AddElem(_T("ShowEightShapeAlign"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bShowEightShapeAlign);

	if (FALSE == m_XMLConfigator.FindElem(_T("bEnableAngleCorrect")))
	{
		m_XMLConfigator.AddElem(_T("bEnableAngleCorrect"));
	}
	m_XMLConfigator.SetElemData((int)optionInfo.m_bEnableAngleCorrect);

	if (FALSE == m_XMLConfigator.FindElem(_T("NumberOfInspectResults")))
	{
		m_XMLConfigator.AddElem(_T("NumberOfInspectResults"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_nNumberOfInspectResults);

	if (FALSE == m_XMLConfigator.FindElem(_T("dAngleCorrect")))
	{
		m_XMLConfigator.AddElem(_T("dAngleCorrect"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_dAngleCorrect);

	if (FALSE == m_XMLConfigator.FindElem(_T("FCHBSaveCSVHead")))
	{
		m_XMLConfigator.AddElem(_T("FCHBSaveCSVHead"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_sFCHBSaveCSVHead);
	if (FALSE == m_XMLConfigator.FindElem(_T("StepID")))
	{
		m_XMLConfigator.AddElem(_T("StepID"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_StepID);

	if (FALSE == m_XMLConfigator.FindElem(_T("FoamSize")))
	{
		m_XMLConfigator.AddElem(_T("FoamSize"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_FoamSize);

	if (FALSE == m_XMLConfigator.FindElem(_T("BendingR")))
	{
		m_XMLConfigator.AddElem(_T("BendingR"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_BendingR);

	if (FALSE == m_XMLConfigator.FindElem(_T("FieldCount")))
	{
		m_XMLConfigator.AddElem(_T("FieldCount"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_FieldCount);

	if (FALSE == m_XMLConfigator.FindElem(_T("Production")))
	{
		m_XMLConfigator.AddElem(_T("Production"));
	}
	m_XMLConfigator.SetElemData(optionInfo.m_Production);

	if (FALSE == m_XMLConfigator.FindElem(_T("vnMulRegTriggerSet")))
	{
		m_XMLConfigator.AddElem(_T("vnMulRegTriggerSet"));
	}
	// vnMulRegTriggerSet
	m_XMLConfigator.EnterElem(); 
	{
		int nSize = optionInfo.m_vnMulRegTriggerSet.size();
		if (FALSE == m_XMLConfigator.FindElem(_T("nSize")))
		{
			m_XMLConfigator.AddElem(_T("nSize"));
		}
		m_XMLConfigator.SetElemData(nSize);

		for (int it=0;it<nSize;it++)
		{
			strInfo.Format(_T("MulRegParam%d"),it+1);
			if (FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}
			m_XMLConfigator.EnterElem(); 
			{
				optionInfo.m_vnMulRegTriggerSet[it].SaveModelToFile(m_XMLConfigator);
			}
			m_XMLConfigator.LeaveElem();
		}

	}
	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();
	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SavePlatformOptionInfo_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);
	AlignXmlLog(_T("SavePlatformOptionInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadPlatformLayoutInfo()
{
	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator cXMLConfigator;
	cXMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = cXMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadPlatformOptionInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	cXMLConfigator.ResetDocElemPos();

	if(FALSE == cXMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	cXMLConfigator.EnterElem();

	// 中间数据记录
	if (cXMLConfigator.FindElem(_T("PlatformLayoutInfo")))
	{
		cXMLConfigator.EnterElem();
		CPlatformLayoutInfo layoutInfo;

		if (cXMLConfigator.FindElem(_T("ViewDisplayLayout")))
		{
			int k=0;
			cXMLConfigator.GetElemData(k);
			layoutInfo.m_nViewLayoutType = k;
		}
		else
		{
			layoutInfo.m_nViewLayoutType = 0;
		}


		if (cXMLConfigator.FindElem(_T("ViewVisionRunWidth")))
		{
			int k=0;
			cXMLConfigator.GetElemData(k);
			layoutInfo.m_nViewVisionRunWidth = k;
		}
		else
		{
			layoutInfo.m_nViewVisionRunWidth = 440;
		}

		SetPlatformLayoutInfo(layoutInfo);
		cXMLConfigator.LeaveElem();
	}
	cXMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SavePlatformLayoutInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}


	CString strInfo;
	CString strPlatformXMLAdrr; 
	CPlatformLayoutInfo layoutInfo;
	GetPlatformLayoutInfo(layoutInfo);

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator cXMLConfigator;
	cXMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = cXMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SavePlatformLayoutInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	cXMLConfigator.ResetDocElemPos();

	if(FALSE == cXMLConfigator.FindElem(_T("WorkStationConfig")))
	{
		AlignXmlLog(_T("SavePlatformLayoutInfo"),_T("Find:WorkStationConfig"),FALSE);
		return FALSE;
	}
	cXMLConfigator.EnterElem();

	// 中间数据记录
	if (FALSE == cXMLConfigator.FindElem(_T("PlatformLayoutInfo")))
	{
		cXMLConfigator.AddElem(_T("PlatformLayoutInfo"));
	}
	cXMLConfigator.EnterElem();



	if (FALSE == cXMLConfigator.FindElem(_T("ViewDisplayLayout")))
	{
		cXMLConfigator.AddElem(_T("ViewDisplayLayout"));
	}
	cXMLConfigator.SetElemData((int)layoutInfo.m_nViewLayoutType);


	if (FALSE == cXMLConfigator.FindElem(_T("ViewVisionRunWidth")))
	{
		cXMLConfigator.AddElem(_T("ViewVisionRunWidth"));
	}
	cXMLConfigator.SetElemData((int)layoutInfo.m_nViewVisionRunWidth);

	cXMLConfigator.LeaveElem();
	cXMLConfigator.LeaveElem();

	BOOL bOK= cXMLConfigator.Save(strPlatformXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SavePlatformLayoutInfo_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SavePlatformLayoutInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);

	return bOK;
}

BOOL vcBaseVisionAlign::LoadAuthorizeManagement()
{
	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strCommXMLAdrr; 

	strInfo             = _T("");
	strCommXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strCommXMLAdrr);
	AlignXmlLog(_T("LoadAuthorizeManagement"), _T("Load:")+strCommXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (m_XMLConfigator.FindElem(_T("AuthorizeManagement")))
	{
		m_XMLConfigator.EnterElem();

		m_pVisionASMConfig->LoadFromXML(m_XMLConfigator,m_pVisionASMConfig->m_cTreeAuthorizeManagement.children);

		m_XMLConfigator.LeaveElem();
	}    	

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveAuthorizeManagement()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}


	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("SaveAuthorizeManagement"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
	{
		AlignXmlLog(_T("SaveAuthorizeManagement"),_T("Find:WorkStationConfig"),FALSE);
		return FALSE;
	}
	m_XMLConfigator.EnterElem();
	{
		// 中间数据记录
		if (FALSE == m_XMLConfigator.FindElem(_T("AuthorizeManagement")))
		{
			m_XMLConfigator.AddElem(_T("AuthorizeManagement"));
		}
		m_XMLConfigator.EnterElem();

		m_pVisionASMConfig->SaveToXML(m_XMLConfigator,m_pVisionASMConfig->m_cTreeAuthorizeManagement.children);

		m_XMLConfigator.LeaveElem();
	}
	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SaveAuthorizeManagement_Save:")+strPlatformXMLAdrr;
	ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SaveAuthorizeManagement"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadJobCameraInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 	if(FALSE == m_XMLConfigator.Load(strPlatformXMLAdrr))
	// 		return FALSE;

	// 加载配置文件
	///////////////////////////////
	CString strPath;
	int nIndex;
	nIndex=m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CString strProductIndex;
	strProductIndex.Format(_T("%03d"), nIndex+1);
	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\Jobs\\") + strProductIndex + _T("\\Camera.xml");

	//vcXMLConfigurator m_XMLConfigator;
	//m_XMLConfigator.SetDoc(_T(""));
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPath);
	AlignXmlLog(_T("SaveCameraInfo"), _T("Load:")+strPath, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	/////////////////////////////////
	//BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadCameraInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	//if(FALSE == m_XMLConfigator.FindElem(_T("WorkStationConfig")))
	//	return FALSE;

	//m_XMLConfigator.EnterElem();

	if (!m_XMLConfigator.FindElem(_T("JobConfig")))	// (Root)
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 1级目录


	// 相机信息：以序列号采集
	CameraParam cameraParam;
	std::vector<CameraParam> vCameraParam;
	double dValue;

	if(TRUE == m_XMLConfigator.FindElem(_T("CamParam")))
	{
		m_XMLConfigator.EnterElem();

		int i=0;
		for (i=0; i<m_pPlatformInfo->m_nCamNum; i++)
		{
			strInfo.Format(_T("CamParam%d"),i);

			if(TRUE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.EnterElem();

				// 相机序列号
				if (m_XMLConfigator.FindElem(_T("SN")))
				{
					m_XMLConfigator.GetElemData(dValue);
					cameraParam.m_lSerialNum = (unsigned long)dValue;
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机DeviceID
				if(m_XMLConfigator.FindElem(_T("DeviceID")))
				{
					CString strID = _T("");
					strID = m_XMLConfigator.GetElemData();
					cameraParam.m_strDeviceID = strID;
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机视频模式
				if (m_XMLConfigator.FindElem(_T("Mode")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nVideoMode);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机宽
				if (m_XMLConfigator.FindElem(_T("Width")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nRawWidth);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 相机高
				if (m_XMLConfigator.FindElem(_T("Height")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nRawHeight);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 自定义起始X
				if (m_XMLConfigator.FindElem(_T("X")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nCustemStartX);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 自定义起始Y
				if (m_XMLConfigator.FindElem(_T("Y")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nCustemStartY);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 自定义宽
				if (m_XMLConfigator.FindElem(_T("W")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nCustemWidth);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 自定义高
				if (m_XMLConfigator.FindElem(_T("H")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nCustemHeight);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 帧率
				if (m_XMLConfigator.FindElem(_T("FrameRate")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dFrameRate);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 曝光时间
				if (m_XMLConfigator.FindElem(_T("Shutter")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dShutter);				 
				}
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// 关联曝光时间
				if (m_XMLConfigator.FindElem(_T("CalibTargetShutter")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dCalibTargetShutter);				 
				}

				// 增益
				if (m_XMLConfigator.FindElem(_T("Gain")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dGain);				 
				}		
				else
				{
					m_XMLConfigator.LeaveElem();
					return FALSE;
				}

				// GammaEnable
				if (m_XMLConfigator.FindElem(_T("GammaEnable")))
				{
					int nVal = 0;
					m_XMLConfigator.GetElemData(nVal);				 
					cameraParam.m_bGammaEnable = (bool)nVal;
				}		


				// Gamma
				if (m_XMLConfigator.FindElem(_T("Gamma")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_dGamma);				 
				}


				//共享相机类型
				if(m_XMLConfigator.FindElem(_T("ShareCamType")))
				{	
					int nData=0;
					m_XMLConfigator.GetElemData(nData);	
					cameraParam.m_eShareCamType=(CShareCamType)nData;
				}

				if(m_XMLConfigator.FindElem(_T("ShareCamNum")))
				{
					m_XMLConfigator.GetElemData(cameraParam.m_nShareCamNum);	
				}

				cameraParam.m_vShareCamInfo.resize(cameraParam.m_nShareCamNum);
				for (int g=0;g<cameraParam.m_nShareCamNum;g++)
				{
					strInfo.Format(_T("ShareCam%d"),g);
					if(m_XMLConfigator.FindElem(strInfo))
					{
						m_XMLConfigator.EnterElem();
						if(m_XMLConfigator.FindElem(_T("SharePlatformIndex")))
						{
							m_XMLConfigator.GetElemData(cameraParam.m_vShareCamInfo.at(g).m_nPlatformIndex);
						}
						if(m_XMLConfigator.FindElem(_T("ShareCameraIndex")))
						{
							m_XMLConfigator.GetElemData(cameraParam.m_vShareCamInfo.at(g).m_nCamIndex);
						}
						m_XMLConfigator.LeaveElem();
					}

				}

				m_XMLConfigator.LeaveElem();

				vCameraParam.push_back(cameraParam);
			}
			else
			{
				return FALSE;
			}			
		}

		for (i=0; i<m_pPlatformInfo->m_nCamNum; i++)
		{
			m_pVisionASMConfig->m_vCameraParam.at(i) = vCameraParam.at(i);
		}		

	}
	else
	{
		m_XMLConfigator.LeaveElem();
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveJobCameraInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CString strInfo;
	//CString strPlatformXMLAdrr; 
	CString strPath;
	//strInfo             = _T("");
	int nIndex;
	nIndex=m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CString strProductIndex;
	strProductIndex.Format(_T("%03d"), nIndex+1);
	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\Jobs\\") + strProductIndex + _T("\\Camera.xml");

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	//	m_XMLConfigator.Load(strPlatformXMLAdrr);

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPath);
	//AlignXmlLog(_T("SaveCameraInfo"), _T("Load:")+strPath, bLoadResult);
	//if (!bLoadResult)
	//	{
	//	return FALSE;
	//	}

	//m_XMLConfigator.ResetDocElemPos();


	//if (!m_XMLConfigator.FindElem(_T("JobConfig")))	// (Root)
	//	{
	//	return FALSE;
	//	}
	//m_XMLConfigator.EnterElem();  // 1级目录


	// 相机信息：以序列号采集
	CameraParam cameraParam;;
	{
		if(FALSE == m_XMLConfigator.FindElem(_T("CamParam")))
		{
			m_XMLConfigator.AddElem(_T("CamParam"));
		}
		m_XMLConfigator.EnterElem();

		for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
		{
			strInfo.Format(_T("CamParam%d"),i);

			GetCameraParam(i,cameraParam);

			if(FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}
			m_XMLConfigator.EnterElem();

			// 相机DeviceID
			if(FALSE == m_XMLConfigator.FindElem(_T("DeviceID")))
			{
				m_XMLConfigator.AddElem(_T("DeviceID"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_strDeviceID);	

			// 相机序列号
			if(FALSE == m_XMLConfigator.FindElem(_T("SN")))
			{
				m_XMLConfigator.AddElem(_T("SN"));
			}
			m_XMLConfigator.SetElemData((int)cameraParam.m_lSerialNum);		

			// 相机视频模式
			if(FALSE == m_XMLConfigator.FindElem(_T("Mode")))
			{
				m_XMLConfigator.AddElem(_T("Mode"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_nVideoMode);	 

			// 相机宽
			if(FALSE == m_XMLConfigator.FindElem(_T("Width")))
			{
				m_XMLConfigator.AddElem(_T("Width"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_nRawWidth);				 

			// 相机高
			if(FALSE == m_XMLConfigator.FindElem(_T("Height")))
			{
				m_XMLConfigator.AddElem(_T("Height"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_nRawHeight);				 

			// 自定义起始X
			if(FALSE == m_XMLConfigator.FindElem(_T("X")))
			{
				m_XMLConfigator.AddElem(_T("X"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_nCustemStartX);				 

			// 自定义起始Y
			if(FALSE == m_XMLConfigator.FindElem(_T("Y")))
			{
				m_XMLConfigator.AddElem(_T("Y"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_nCustemStartY);				 

			// 自定义宽
			if(FALSE == m_XMLConfigator.FindElem(_T("W")))
			{
				m_XMLConfigator.AddElem(_T("W"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_nCustemWidth);				 

			// 自定义高
			if(FALSE == m_XMLConfigator.FindElem(_T("H")))
			{
				m_XMLConfigator.AddElem(_T("H"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_nCustemHeight);				 

			// 帧率
			if(FALSE == m_XMLConfigator.FindElem(_T("FrameRate")))
			{
				m_XMLConfigator.AddElem(_T("FrameRate"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_dFrameRate);				 

			// 曝光时间
			if(FALSE == m_XMLConfigator.FindElem(_T("Shutter")))
			{
				m_XMLConfigator.AddElem(_T("Shutter"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_dShutter);				 

			// 关联曝光时间
			if(FALSE == m_XMLConfigator.FindElem(_T("CalibTargetShutter")))
			{
				m_XMLConfigator.AddElem(_T("CalibTargetShutter"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_dCalibTargetShutter);

			// 增益
			if(FALSE == m_XMLConfigator.FindElem(_T("Gain")))
			{
				m_XMLConfigator.AddElem(_T("Gain"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_dGain);


			// GammaEnable
			if(FALSE == m_XMLConfigator.FindElem(_T("GammaEnable")))
			{
				m_XMLConfigator.AddElem(_T("GammaEnable"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_bGammaEnable);

			// Gamma
			if(FALSE == m_XMLConfigator.FindElem(_T("Gamma")))
			{
				m_XMLConfigator.AddElem(_T("Gamma"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_dGamma);


			//共享相机类型
			if(FALSE == m_XMLConfigator.FindElem(_T("ShareCamType")))
			{
				m_XMLConfigator.AddElem(_T("ShareCamType"));
			}
			m_XMLConfigator.SetElemData((int)cameraParam.m_eShareCamType);

			//共享相机数目
			if(FALSE == m_XMLConfigator.FindElem(_T("ShareCamNum")))
			{
				m_XMLConfigator.AddElem(_T("ShareCamNum"));
			}
			m_XMLConfigator.SetElemData(cameraParam.m_nShareCamNum);

			for (int g=0;g<cameraParam.m_nShareCamNum;g++)
			{
				strInfo.Format(_T("ShareCam%d"),g);
				if(FALSE == m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.AddElem(strInfo);
				}
				m_XMLConfigator.EnterElem();
				if(FALSE == m_XMLConfigator.FindElem(_T("SharePlatformIndex")))
				{
					m_XMLConfigator.AddElem(_T("SharePlatformIndex"));
				}
				m_XMLConfigator.SetElemData(cameraParam.m_vShareCamInfo.at(g).m_nPlatformIndex);

				if(FALSE == m_XMLConfigator.FindElem(_T("ShareCameraIndex")))
				{
					m_XMLConfigator.AddElem(_T("ShareCameraIndex"));
				}
				m_XMLConfigator.SetElemData(cameraParam.m_vShareCamInfo.at(g).m_nCamIndex);
				m_XMLConfigator.LeaveElem();
			}



			m_XMLConfigator.LeaveElem();
		}

		//m_XMLConfigator.LeaveElem();

		m_XMLConfigator.LeaveElem();

	}
	BOOL bOK= m_XMLConfigator.Save(strPath);
	//BOOL bOK= m_XMLConfigator.Save(strPath);

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("SaveCameraInfo"), _T("Save:")+strPath;
	ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SaveCameraInfo"), _T("Save:")+strPath, bOK);

	return bOK;	
}

CWnd* vcBaseVisionAlign::GetMainFrameWnd()
{
	return m_pMainFrameWnd;
}
BOOL vcBaseVisionAlign::LoadCalibMoveImagePosInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}
	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));


	// 加载配置文件
	///////////////////////////////
	CString strPath;
	int nIndex;
	nIndex=m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	CString strProductIndex;
	strProductIndex.Format(_T("%03d"), nIndex+1);
	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\JobCalibs\\") + strProductIndex + _T("\\CalibMoveImagePos.xml");


	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPath);
	AlignXmlLog(_T("CalibMoveImagePosInfo"), _T("Load:")+strPath, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	strInfo.Format(_T("CalibMoveImagePos"));
	if(!m_XMLConfigator.FindElem(strInfo))
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();
	std::vector<CMarkImagePos*> vpMarkImagePos;
	CMarkImagePos* pMarkImagePos = NULL;
	int nData = 0;
	double dVal = 0.0;
	for (int i=0;i<8;i++)
	{
		for (int k=0;k<vpMarkImagePos.size();k++)
		{
			if (vpMarkImagePos.at(k)!=NULL)
			{
				delete vpMarkImagePos.at(k);
				vpMarkImagePos.at(k) = NULL;
			}
		}
		vpMarkImagePos.clear();

		strInfo.Format(_T("Pos%d"),i);
		if(!m_XMLConfigator.FindElem(strInfo))
		{
			continue;
		}
		m_XMLConfigator.EnterElem();
		strInfo.Format(_T("Count"));
		if (!m_XMLConfigator.FindElem(strInfo))
		{
			continue;
		}
		m_XMLConfigator.GetElemData(nData);
		BOOL bSuceess = TRUE;
		for (int j=0;j<nData;j++)
		{
			strInfo.Format(_T("MovePos%d"),j);
			if (!m_XMLConfigator.FindElem(strInfo))
			{
				bSuceess = FALSE;
				break;
			}
			m_XMLConfigator.EnterElem();
			CCoordPos imgPos;
			if (!m_XMLConfigator.FindElem(_T("X")))
			{
				bSuceess = FALSE;
				break;
			}
			m_XMLConfigator.GetElemData(dVal);
			imgPos.m_dPosX = dVal;

			if (!m_XMLConfigator.FindElem(_T("Y")))
			{
				bSuceess = FALSE;
				break;
			}
			m_XMLConfigator.GetElemData(dVal);
			imgPos.m_dPosY = dVal;

			pMarkImagePos = new CMarkImagePos;
			pMarkImagePos->SetMarkImagePosNum(1);
			pMarkImagePos->SetMarkImagePos(0,TRUE,imgPos);
			vpMarkImagePos.push_back(pMarkImagePos);
			m_XMLConfigator.LeaveElem();
		}
		if (!bSuceess)
		{

		}
		else
		{
			m_pAlignerTool->SetCalibPlatformMoveSearchResult(vpMarkImagePos,i);
		}
		m_XMLConfigator.LeaveElem();
	}
	for (int k=0;k<vpMarkImagePos.size();k++)
	{
		if (vpMarkImagePos.at(k)!=NULL)
		{
			delete vpMarkImagePos.at(k);
			vpMarkImagePos.at(k) = NULL;
		}
	}
	vpMarkImagePos.clear();
	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveCalibMoveImagePosInfo()
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}

	CString strInfo;
	CString strPath;
	int nIndex;
	nIndex=m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	CString strProductIndex;
	strProductIndex.Format(_T("%03d"), nIndex+1);
	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\JobCalibs\\") + strProductIndex + _T("\\CalibMoveImagePos.xml");

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPath);
	std::vector<CCoordPos> imageResult;
	int nNum = 0;
	strInfo.Format(_T("CalibMoveImagePos"));
	if (!m_XMLConfigator.FindElem(strInfo))
	{
		m_XMLConfigator.AddElem(strInfo);
	}

	m_XMLConfigator.EnterElem();
	for (int i=0;i<8;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if (!m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}	
		m_XMLConfigator.EnterElem();
		m_pAlignerTool->GetCalibPlatformMoveSearchResult(i,nNum,imageResult);
		strInfo.Format(_T("Count"));
		if (!m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.SetElemData(nNum);
		for (int j=0;j<nNum;j++)
		{
			strInfo.Format(_T("MovePos%d"),j);
			if (!m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}			
			m_XMLConfigator.EnterElem();

			if (!m_XMLConfigator.FindElem(_T("X")))
			{
				m_XMLConfigator.AddElem(_T("X"));
			}
			m_XMLConfigator.SetElemData(imageResult.at(j).GetPosX());
			if (!m_XMLConfigator.FindElem(_T("Y")))
			{
				m_XMLConfigator.AddElem(_T("Y"));
			}
			m_XMLConfigator.SetElemData(imageResult.at(j).GetPosY());

			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();

	}
	m_XMLConfigator.LeaveElem();
	BOOL bOK= m_XMLConfigator.Save(strPath);
	AlignXmlLog(_T("CalibMoveImagePosInfo"), _T("Save:")+strPath, bOK);

	return bOK;	
}

BOOL vcBaseVisionAlign::LoadImageIndexInfo()
{

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\ImageIndexInfo.xml");
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	// 加载配置文件
	BOOL bLoadResult = FALSE;	
	bLoadResult = m_XMLConfigator.Load(strPlatformXMLAdrr);
	AlignXmlLog(_T("LoadImageIndexInfo"), _T("Load:")+strPlatformXMLAdrr, bLoadResult);
	if (!bLoadResult)
	{
		return FALSE;
	}

	m_XMLConfigator.ResetDocElemPos();

	if(FALSE == m_XMLConfigator.FindElem(_T("LoadImageIndexInfo")))
		return FALSE;

	m_XMLConfigator.EnterElem();

	// 中间数据记录
	int nPosNum = GetPosNum();

	if (m_XMLConfigator.FindElem(_T("CalibSearchImageFailIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveCalibSearchImageFailIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerTargetSearchImageFailIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerTargetSearchImageFailIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerObjectSearchImageFailIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerObjectSearchImageFailIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerVirtualSearchImageFailIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerVirtualSearchImageFailIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerCalibTargetSearchImageFailIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerInspectSearchImageFailIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerInspectSearchImageFailIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}

	if (m_XMLConfigator.FindElem(_T("CalibSearchImageIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveCalibSearchImageIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerTargetSearchImageIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerTargetSearchImageIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerObjectSearchImageIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerObjectSearchImageIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerVirtualSearchImageIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerVirtualSearchImageIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerCalibTargetSearchImageIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerCalibTargetSearchImageIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}
	if (m_XMLConfigator.FindElem(_T("AlignerInspectSearchImageIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerInspectSearchImageIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}

	if (m_XMLConfigator.FindElem(_T("AlignerCalibSearchVDBFileIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerCalibSearchVDBFileIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}

	if (m_XMLConfigator.FindElem(_T("AlignerTargetSearchVDBFileIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerTargetSearchVDBFileIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}

	if (m_XMLConfigator.FindElem(_T("AlignerObjectSearchVDBFileIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerObjectSearchVDBFileIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}

	if (m_XMLConfigator.FindElem(_T("AlignerVirtualSearchVDBFileIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerVirtualSearchVDBFileIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}

	if (m_XMLConfigator.FindElem(_T("AlignerInspectSearchVDBFileIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerInspectSearchVDBFileIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}

	if (m_XMLConfigator.FindElem(_T("AlignerCalibTargetSearchVDBFileIndex")))
	{
		m_XMLConfigator.EnterElem();
		for (int i=0;i<nPosNum;i++)
		{
			strInfo.Format(_T("Pos%d"),i);
			if(m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.GetElemData(m_vSaveAlignerCalibTargetSearchVDBFileIndex.at(i));	
			}					
		} 
		m_XMLConfigator.LeaveElem();
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveImageIndexInfo()		//存储存图序号信息
{

	CString strInfo;
	CString strPlatformXMLAdrr; 

	strInfo             = _T("");
	strPlatformXMLAdrr  = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\ImageIndexInfo.xml");
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	m_XMLConfigator.ResetDocElemPos();
	int nPosNum = GetPosNum();
	if(FALSE == m_XMLConfigator.FindElem(_T("LoadImageIndexInfo")))
	{
		m_XMLConfigator.AddElem(_T("LoadImageIndexInfo"));
	}
	m_XMLConfigator.EnterElem();

	// 中间数据记录
	if (FALSE == m_XMLConfigator.FindElem(_T("CalibSearchImageFailIndex")))
	{
		m_XMLConfigator.AddElem(_T("CalibSearchImageFailIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveCalibSearchImageFailIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerTargetSearchImageFailIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerTargetSearchImageFailIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerTargetSearchImageFailIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerObjectSearchImageFailIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerObjectSearchImageFailIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerObjectSearchImageFailIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerVirtualSearchImageFailIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerVirtualSearchImageFailIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerVirtualSearchImageFailIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerCalibTargetSearchImageFailIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerCalibTargetSearchImageFailIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerInspectSearchImageFailIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerInspectSearchImageFailIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerInspectSearchImageFailIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("CalibSearchImageIndex")))
	{
		m_XMLConfigator.AddElem(_T("CalibSearchImageIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveCalibSearchImageIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerTargetSearchImageIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerTargetSearchImageIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerTargetSearchImageIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerObjectSearchImageIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerObjectSearchImageIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerObjectSearchImageIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerVirtualSearchImageIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerVirtualSearchImageIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerVirtualSearchImageIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerCalibTargetSearchImageIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerCalibTargetSearchImageIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerCalibTargetSearchImageIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerInspectSearchImageIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerInspectSearchImageIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerInspectSearchImageIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerCalibSearchVDBFileIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerCalibSearchVDBFileIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerCalibSearchVDBFileIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerTargetSearchVDBFileIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerTargetSearchVDBFileIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerTargetSearchVDBFileIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerObjectSearchVDBFileIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerObjectSearchVDBFileIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerObjectSearchVDBFileIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();


	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerVirtualSearchVDBFileIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerVirtualSearchVDBFileIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerVirtualSearchVDBFileIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerInspectSearchVDBFileIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerInspectSearchVDBFileIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerInspectSearchVDBFileIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	if (FALSE == m_XMLConfigator.FindElem(_T("AlignerCalibTargetSearchVDBFileIndex")))
	{
		m_XMLConfigator.AddElem(_T("AlignerCalibTargetSearchVDBFileIndex"));
	}
	m_XMLConfigator.EnterElem();
	for (int i=0;i<nPosNum;i++)
	{
		strInfo.Format(_T("Pos%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo,m_vSaveAlignerCalibTargetSearchVDBFileIndex.at(i));
		}					
	} 
	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();

	BOOL bOK= m_XMLConfigator.Save(strPlatformXMLAdrr);

	//CString strTmp = _T("");
	//strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	//strTmp +=  _T("SaveImageIndexInfo_Save:")+strPlatformXMLAdrr;
	//ExecuteGitCommit(strTmp);

	AlignXmlLog(_T("SaveImageIndexInfo"), _T("Save:")+strPlatformXMLAdrr, bOK);
	return bOK;
}

BOOL vcBaseVisionAlign::LoadTargetPosInfo(int nIndex)
{
	ASSERT(nIndex >= 0);
	ASSERT(m_pVisionASMConfig != NULL);
	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
	ASSERT(m_pPlatformInfo != NULL);

	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
	{
		return FALSE;
	}
	if (m_pVisionASMConfig == NULL)
	{
		return FALSE;
	}
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	CString strInfo;
	double dValue = 0;
	int i = 0, j = 0, nData = 0;
	CCoordPos pos;
	CPlatformXYDAxisPos		*pPlatformAxisPos = NULL;
	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;

	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
	strName.Format(_T("%03d"),nIndex+1);
	if (strName.IsEmpty())	// 产品名称为空，不合法
	{
		return FALSE;
	}

	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\Jobs\\") + strName + _T("\\SearchData.xml");

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	if (!m_XMLConfigator.Load(strDir))
	{
		return FALSE;
	}

	if (!m_XMLConfigator.FindElem(_T("SearchData")))// (Root)
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();

	//兼容之前结构  // 

	if (FALSE == m_pPlatformInfo->m_bEnableMultiCalibExtension)
	{
		// 
		for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
		{
			strInfo.Format(_T("TargetResult%d"),i);
			if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
			{
				m_XMLConfigator.EnterElem();
				if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
				{
					m_XMLConfigator.EnterElem();
					CPlatformXYDAxisPos AxisPos;
					if (m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
					}
					if (m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
					}
					if (m_XMLConfigator.FindElem(_T("PosD")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
					}

					if (m_vpTargetPlatformAxisPos.at(i) != NULL)
					{
						delete m_vpTargetPlatformAxisPos.at(i);
						m_vpTargetPlatformAxisPos.at(i)=NULL;

						m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos(AxisPos);
					}
					else
					{
						m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos(AxisPos);
					}

					m_XMLConfigator.LeaveElem();
				}
				if (m_XMLConfigator.FindElem(_T("CamAxisPos")))  // (Level-2) 相机轴位置
				{
					m_XMLConfigator.EnterElem();
					CPlatformXYAxisPos AxisPos;
					if (m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
					}
					if (m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
					}

					if (m_vpTargetCamAxisPos.at(i) != NULL)
					{
						delete m_vpTargetCamAxisPos.at(i);
						m_vpTargetCamAxisPos.at(i)=NULL;

						m_vpTargetCamAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
					}
					else
					{
						m_vpTargetCamAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
					}

					m_XMLConfigator.LeaveElem();
				}
				if (m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))  // (Level-2) 相机轴位置
				{
					m_XMLConfigator.EnterElem();
					CPlatformXYAxisPos AxisPos;
					if (m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
					}
					if (m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
					}

					if (m_vpTargetCamAxisPlatformAxisPos.at(i) != NULL)
					{
						delete m_vpTargetCamAxisPlatformAxisPos.at(i);
						m_vpTargetCamAxisPlatformAxisPos.at(i)=NULL;

						m_vpTargetCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
					}
					else
					{
						m_vpTargetCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
					}

					m_XMLConfigator.LeaveElem();
				}
				if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
				{
					m_XMLConfigator.EnterElem();

					nData = 0;
					if (m_XMLConfigator.FindElem(_T("Valid")))
					{
						m_XMLConfigator.GetElemData(nData);
					}
					if (m_XMLConfigator.FindElem(_T("ImageX")))
					{
						m_XMLConfigator.GetElemData(pos.m_dPosX);
					}
					if (m_XMLConfigator.FindElem(_T("ImageY")))
					{
						m_XMLConfigator.GetElemData(pos.m_dPosY);
					}
					if (m_XMLConfigator.FindElem(_T("ImageD")))
					{
						m_XMLConfigator.GetElemData(pos.m_dAngle);
					}

					int nAuxiliaryIndex = 0;
					for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
					{
						CString strAuxiliary;
						strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
						if (m_XMLConfigator.FindElem(strAuxiliary))
						{
							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
						}
						strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
						if (m_XMLConfigator.FindElem(strAuxiliary))
						{
							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
						}
						strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
						if (m_XMLConfigator.FindElem(strAuxiliary))
						{
							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
						}
					}

					if (m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
					{
						m_XMLConfigator.GetElemData(pos.m_dLineAngle1);
					}

					if (m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
					{
						m_XMLConfigator.GetElemData(pos.m_dLineAngle2);
					}

					m_mpTargetMarkImagePos.SetMarkImagePos(i, nData, pos);

					m_XMLConfigator.LeaveElem();
				}


				m_XMLConfigator.LeaveElem();
			}
		}
	}
	else
	{
		int nNums = 1;
		if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
		{
			nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
		}

		for (int it =0;it < nNums;it++)
		{
			strInfo.Format(_T("ProducetMultiExTarget%d"),it);
			if(m_XMLConfigator.FindElem(strInfo))//  扩展序号节点
			{
				m_XMLConfigator.EnterElem();

				for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
				{
					strInfo.Format(_T("TargetResult%d"),i);
					if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
					{
						m_XMLConfigator.EnterElem();
						if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
						{
							m_XMLConfigator.EnterElem();

							if (it<m_vvpTargetPlatformAxisPosMultiEx.size())
							{
								CPlatformXYDAxisPos AxisPos;
								if (m_XMLConfigator.FindElem(_T("PosX")))
								{
									m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
								}
								if (m_XMLConfigator.FindElem(_T("PosY")))
								{
									m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
								}
								if (m_XMLConfigator.FindElem(_T("PosD")))
								{
									m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
								}

								if (m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i) != NULL)
								{
									delete m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i);
									m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i)=NULL;

									m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYDAxisPos(AxisPos);
								}
								else
								{
									m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYDAxisPos(AxisPos);
								}
							}


							m_XMLConfigator.LeaveElem();
						}
						if (m_XMLConfigator.FindElem(_T("CamAxisPos")))  // (Level-2) 相机轴位置
						{
							m_XMLConfigator.EnterElem();
							CPlatformXYAxisPos AxisPos;
							if (it<m_vvpTargetCamAxisPosMultiEx.size())
							{
								if (m_XMLConfigator.FindElem(_T("PosX")))
								{
									m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
								}
								if (m_XMLConfigator.FindElem(_T("PosY")))
								{
									m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
								}

								if (m_vvpTargetCamAxisPosMultiEx.at(it).at(i) != NULL)
								{
									delete m_vvpTargetCamAxisPosMultiEx.at(it).at(i) ;
									m_vvpTargetCamAxisPosMultiEx.at(it).at(i) =NULL;

									m_vvpTargetCamAxisPosMultiEx.at(it).at(i)  = new CPlatformXYAxisPos(AxisPos);
								}
								else
								{
									m_vvpTargetCamAxisPosMultiEx.at(it).at(i)  = new CPlatformXYAxisPos(AxisPos);
								}
							}


							m_XMLConfigator.LeaveElem();
						}
						if (m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))  // (Level-2) 相机轴位置
						{
							m_XMLConfigator.EnterElem();
							if (it<m_vvpTargetCamAxisPlatformAxisPosMultiEx.size())
							{
								CPlatformXYAxisPos AxisPos;
								if (m_XMLConfigator.FindElem(_T("PosX")))
								{
									m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
								}
								if (m_XMLConfigator.FindElem(_T("PosY")))
								{
									m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
								}

								if (m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i) != NULL)
								{
									delete m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i);
									m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i)=NULL;

									m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
								}
								else
								{
									m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
								}
							}


							m_XMLConfigator.LeaveElem();
						}
						if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
						{
							m_XMLConfigator.EnterElem();

							nData = 0;
							if (m_XMLConfigator.FindElem(_T("Valid")))
							{
								m_XMLConfigator.GetElemData(nData);
							}
							if (m_XMLConfigator.FindElem(_T("ImageX")))
							{
								m_XMLConfigator.GetElemData(pos.m_dPosX);
							}
							if (m_XMLConfigator.FindElem(_T("ImageY")))
							{
								m_XMLConfigator.GetElemData(pos.m_dPosY);
							}
							if (m_XMLConfigator.FindElem(_T("ImageD")))
							{
								m_XMLConfigator.GetElemData(pos.m_dAngle);
							}

							int nAuxiliaryIndex = 0;
							for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
							{
								CString strAuxiliary;
								strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
								}
								strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
								}
								strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
								}
							}

							if (m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
							{
								m_XMLConfigator.GetElemData(pos.m_dLineAngle1);
							}

							if (m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
							{
								m_XMLConfigator.GetElemData(pos.m_dLineAngle2);
							}

							if (it < m_vmpTargetMarkImagePosMultiEx.size())
							{
								m_vmpTargetMarkImagePosMultiEx.at(it).SetMarkImagePos(i, nData, pos);
							}


							m_XMLConfigator.LeaveElem();
						}


						m_XMLConfigator.LeaveElem();
					}
				}


				m_XMLConfigator.LeaveElem();
			}
		}
	}

	//多目标定位储存目标结果
	if (1)
	{
		for(int j=0;j<MUTITARGETMAXNUM;j++)
		{
			strInfo.Format(_T("MutiTargetResult%d"),j);
			if (m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.EnterElem();
				for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
				{
					strInfo.Format(_T("TargetResult%d"),i);
					if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
					{
						m_XMLConfigator.EnterElem();
						if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
						{
							m_XMLConfigator.EnterElem();
							CPlatformXYDAxisPos AxisPos;
							if (m_XMLConfigator.FindElem(_T("PosX")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
							}
							if (m_XMLConfigator.FindElem(_T("PosY")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
							}
							if (m_XMLConfigator.FindElem(_T("PosD")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
							}

							if (m_vpMutiTargetPlatformAxisPos.at(j).at(i) != NULL)
							{
								delete m_vpMutiTargetPlatformAxisPos.at(j).at(i);
								m_vpMutiTargetPlatformAxisPos.at(j).at(i)=NULL;

								m_vpMutiTargetPlatformAxisPos.at(j).at(i) = new CPlatformXYDAxisPos(AxisPos);
							}
							else
							{
								m_vpMutiTargetPlatformAxisPos.at(j).at(i) = new CPlatformXYDAxisPos(AxisPos);
							}

							m_XMLConfigator.LeaveElem();
						}

						if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
						{
							m_XMLConfigator.EnterElem();

							nData = 0;
							if (m_XMLConfigator.FindElem(_T("Valid")))
							{
								m_XMLConfigator.GetElemData(nData);
							}
							if (m_XMLConfigator.FindElem(_T("ImageX")))
							{
								m_XMLConfigator.GetElemData(pos.m_dPosX);
							}
							if (m_XMLConfigator.FindElem(_T("ImageY")))
							{
								m_XMLConfigator.GetElemData(pos.m_dPosY);
							}
							if (m_XMLConfigator.FindElem(_T("ImageD")))
							{
								m_XMLConfigator.GetElemData(pos.m_dAngle);
							}

							int nAuxiliaryIndex = 0;
							for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
							{
								CString strAuxiliary;
								strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
								}
								strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
								}
								strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
								}
							}

							m_vMutiTargetMarkImagePos.at(j).SetMarkImagePos(i, nData, pos);

							m_XMLConfigator.LeaveElem();
						}


						m_XMLConfigator.LeaveElem();
					}
				}

				int nData=0;
				if (m_XMLConfigator.FindElem(_T("TargetResultOK")))// (Level-1) 搜索结果
				{
					m_XMLConfigator.GetElemData(nData);
				}
				m_vbMutiTargetMarkOK.at(j)=(BOOL)nData;
				m_XMLConfigator.LeaveElem();
			}


		}
	}





	m_XMLConfigator.LeaveElem();


	return TRUE;
}

BOOL vcBaseVisionAlign::SaveTargetPosInfo(int nIndex)
{
	CString strInfo2;
	strInfo2.Format("SaveTargetPosInfo- Enter");
	VisionAlignLogRecord(m_strAlignProcessData, strInfo2);

	ASSERT(nIndex >= 0);
	ASSERT(m_pVisionASMConfig != NULL);
	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
	ASSERT(m_pPlatformInfo != NULL);

	// 	if (m_searchAllResultStatus == eSARSResultNG1 ||m_searchAllResultStatus == eSARSResultNGMore)
	// 	{
	// 		return TRUE;
	// 	}
	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
	{
		return FALSE;
	}
	if (m_pVisionASMConfig == NULL)
	{
		return FALSE;
	}
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	CString strInfo;
	double dValue = 0;
	int i = 0, j = 0, nData = 0;
	CCoordPos pos;
	CPlatformXYDAxisPos		*pPlatformAxisPos = NULL;
	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;
	CPlatformXYAxisPos		*pTargetCamAxisPos = NULL;
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
	strName.Format(_T("%03d"),nIndex+1);
	if (strName.IsEmpty())	// 产品名称为空，不合法
	{
		return FALSE;
	}

	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\Jobs\\") + strName + _T("\\SearchData.xml");

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	m_XMLConfigator.Load(strDir);


	m_XMLConfigator.ResetDocElemPos();


	if(!m_XMLConfigator.FindElem(_T("SearchData")))	// (Root)
	{
		m_XMLConfigator.AddElem(_T("SearchData"));
	}
	m_XMLConfigator.EnterElem();

	// // 兼容之前保存结构
	for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
	{
		strInfo.Format("SaveTargetPosInfo-1- %d",i);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		strInfo.Format(_T("TargetResult%d"),i);
		if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();

		if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
		{
			m_XMLConfigator.AddElem(_T("PlatAxisPos"));
		}
		m_XMLConfigator.EnterElem();

		if (i < m_vpTargetPlatformAxisPos.size() && m_vpTargetPlatformAxisPos.at(i) != NULL)
		{
			pPlatformAxisPos = (CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i);

			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

			if(!m_XMLConfigator.FindElem(_T("PosD")))
			{
				m_XMLConfigator.AddElem(_T("PosD"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);

		}
		else
		{
			CPlatformXYDAxisPos AxisPos;
			pPlatformAxisPos = &AxisPos;

			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

			if(!m_XMLConfigator.FindElem(_T("PosD")))
			{
				m_XMLConfigator.AddElem(_T("PosD"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
		}
		m_XMLConfigator.LeaveElem();


		if(!m_XMLConfigator.FindElem(_T("CamAxisPos")))	// (Level-2) 相机轴位置信息
		{
			m_XMLConfigator.AddElem(_T("CamAxisPos"));
		}

		CString strInfo;
		strInfo.Format("SaveTargetPosInfo--m_vpTargetCamAxisPos.at(%d):%f,%f",i,((CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(i))->m_dPosX,((CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(i))->m_dPosY);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);

		m_XMLConfigator.EnterElem();

		if(m_vpTargetCamAxisPos.at(i) != NULL && i < m_vpTargetCamAxisPos.size())
		{ 
			pTargetCamAxisPos = (CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(i);
			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
		}
		else
		{
			CPlatformXYAxisPos axisPos;
			pTargetCamAxisPos = &axisPos;
			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
		}
		m_XMLConfigator.LeaveElem();

		if(!m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))	// (Level-2) 相机轴位置信息
		{
			m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));
		}
		m_XMLConfigator.EnterElem();

		if(m_vpTargetCamAxisPlatformAxisPos.at(i) != NULL && i < m_vpTargetCamAxisPlatformAxisPos.size())
		{ 
			pTargetCamAxisPos = (CPlatformXYAxisPos*)m_vpTargetCamAxisPlatformAxisPos.at(i);
			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
		}
		else
		{
			CPlatformXYAxisPos axisPos;
			pTargetCamAxisPos = &axisPos;
			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
		}
		m_XMLConfigator.LeaveElem();


		if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
		{
			m_XMLConfigator.AddElem(_T("ImagePos"));
		}	
		m_XMLConfigator.EnterElem();

		if(!m_XMLConfigator.FindElem(_T("Valid")))
		{
			m_XMLConfigator.AddElem(_T("Valid"));
		}
		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetIsMarkImagePosOK(i));

		if(!m_XMLConfigator.FindElem(_T("ImageX")))
		{
			m_XMLConfigator.AddElem(_T("ImageX"));
		}
		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dPosX);

		if(!m_XMLConfigator.FindElem(_T("ImageY")))
		{
			m_XMLConfigator.AddElem(_T("ImageY"));
		}
		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dPosY);

		if(!m_XMLConfigator.FindElem(_T("ImageD")))
		{
			m_XMLConfigator.AddElem(_T("ImageD"));
		}		
		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dAngle);

		int nAuxiliaryIndex = 0;
		for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
		{
			CString strAuxiliary;
			strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
			if (!m_XMLConfigator.FindElem(strAuxiliary))
			{
				m_XMLConfigator.AddElem(strAuxiliary);
			}
			m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));

			strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
			if (!m_XMLConfigator.FindElem(strAuxiliary))
			{
				m_XMLConfigator.AddElem(strAuxiliary);
			}
			m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));

			strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
			if (!m_XMLConfigator.FindElem(strAuxiliary))
			{
				m_XMLConfigator.AddElem(strAuxiliary);
			}
			m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
		}

		if(!m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
		{
			m_XMLConfigator.AddElem(_T("ImageLineAngle1"));
		}		
		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dLineAngle1);

		if(!m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
		{
			m_XMLConfigator.AddElem(_T("ImageLineAngle2"));
		}		
		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dLineAngle2);

		m_XMLConfigator.LeaveElem();


		m_XMLConfigator.LeaveElem();
	}
	// 单产品扩展//
	int nNums = 1;
	if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
	{
		nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
	}
	for (int it=0;it < nNums;it++)
	{
		strInfo.Format(_T("ProducetMultiExTarget%d"),it);
		if(!m_XMLConfigator.FindElem(strInfo))//  扩展序号节点
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();


		for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
		{
			strInfo.Format(_T("TargetResult%d"),i);
			if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
			{
				m_XMLConfigator.AddElem(strInfo);
			}
			m_XMLConfigator.EnterElem();

			if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
			{
				m_XMLConfigator.AddElem(_T("PlatAxisPos"));
			}
			m_XMLConfigator.EnterElem();

			if (it<m_vvpTargetPlatformAxisPosMultiEx.size())
			{
				if (i < m_vvpTargetPlatformAxisPosMultiEx.at(it).size() && m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i) != NULL)
				{
					pPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i));

					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

					if(!m_XMLConfigator.FindElem(_T("PosD")))
					{
						m_XMLConfigator.AddElem(_T("PosD"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);

				}
				else
				{
					CPlatformXYDAxisPos AxisPos;
					pPlatformAxisPos = &AxisPos;

					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

					if(!m_XMLConfigator.FindElem(_T("PosD")))
					{
						m_XMLConfigator.AddElem(_T("PosD"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
				}
			}

			m_XMLConfigator.LeaveElem();

			if(!m_XMLConfigator.FindElem(_T("CamAxisPos")))	// (Level-2) 相机轴位置信息
			{
				m_XMLConfigator.AddElem(_T("CamAxisPos"));
			}

			m_XMLConfigator.EnterElem();
			if (it<m_vvpTargetCamAxisPosMultiEx.size())
			{
				if(m_vvpTargetCamAxisPosMultiEx.at(it).at(i) != NULL && i < m_vvpTargetCamAxisPosMultiEx.at(it).size())
				{ 
					pTargetCamAxisPos = (CPlatformXYAxisPos*)m_vvpTargetCamAxisPosMultiEx.at(it).at(i);
					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
				}
				else
				{
					CPlatformXYAxisPos axisPos;
					pTargetCamAxisPos = &axisPos;
					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
				}
			}

			m_XMLConfigator.LeaveElem();
			if(!m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))	// (Level-2) 相机轴位置信息
			{
				m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));
			}
			m_XMLConfigator.EnterElem();
			if (it<m_vvpTargetCamAxisPlatformAxisPosMultiEx.size())
			{
				if(m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i) != NULL && i < m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).size())
				{ 
					pTargetCamAxisPos = (CPlatformXYAxisPos*)m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i);
					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
				}
				else
				{
					CPlatformXYAxisPos axisPos;
					pTargetCamAxisPos = &axisPos;
					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
				}
			}

			m_XMLConfigator.LeaveElem();

			if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
			{
				m_XMLConfigator.AddElem(_T("ImagePos"));
			}	
			m_XMLConfigator.EnterElem();

			if (it < m_vmpTargetMarkImagePosMultiEx.size())
			{
				if(!m_XMLConfigator.FindElem(_T("Valid")))
				{
					m_XMLConfigator.AddElem(_T("Valid"));
				}
				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetIsMarkImagePosOK(i));

				if(!m_XMLConfigator.FindElem(_T("ImageX")))
				{
					m_XMLConfigator.AddElem(_T("ImageX"));
				}
				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dPosX);

				if(!m_XMLConfigator.FindElem(_T("ImageY")))
				{
					m_XMLConfigator.AddElem(_T("ImageY"));
				}
				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dPosY);

				if(!m_XMLConfigator.FindElem(_T("ImageD")))
				{
					m_XMLConfigator.AddElem(_T("ImageD"));
				}		
				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dAngle);

				int nAuxiliaryIndex = 0;
				for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
				{
					CString strAuxiliary;
					strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));

					strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));

					strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
				}

				if(!m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
				{
					m_XMLConfigator.AddElem(_T("ImageLineAngle1"));
				}		
				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dLineAngle1);

				if(!m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
				{
					m_XMLConfigator.AddElem(_T("ImageLineAngle2"));
				}		
				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dLineAngle2);
			}



			m_XMLConfigator.LeaveElem();


			m_XMLConfigator.LeaveElem();
		}

		m_XMLConfigator.LeaveElem();
	}
	if (optionInfo.m_bEnableMutiTarget)
	{
		for(int j=0;j<MUTITARGETMAXNUM;j++)
		{
			strInfo.Format(_T("MutiTargetResult%d"),j);
			if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
			{
				m_XMLConfigator.AddElem(strInfo);
			}
			m_XMLConfigator.EnterElem();
			for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
			{
				strInfo.Format(_T("TargetResult%d"),i);
				if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
				{
					m_XMLConfigator.AddElem(strInfo);
				}
				m_XMLConfigator.EnterElem();

				if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
				{
					m_XMLConfigator.AddElem(_T("PlatAxisPos"));
				}
				m_XMLConfigator.EnterElem();

				if (i < m_vpMutiTargetPlatformAxisPos.at(j).size() && m_vpMutiTargetPlatformAxisPos.at(j).at(i) != NULL)
				{
					pPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vpMutiTargetPlatformAxisPos.at(j).at(i));

					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

					if(!m_XMLConfigator.FindElem(_T("PosD")))
					{
						m_XMLConfigator.AddElem(_T("PosD"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);

				}
				else
				{
					CPlatformXYDAxisPos AxisPos;
					pPlatformAxisPos = &AxisPos;

					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

					if(!m_XMLConfigator.FindElem(_T("PosD")))
					{
						m_XMLConfigator.AddElem(_T("PosD"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
				}
				m_XMLConfigator.LeaveElem();

				if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
				{
					m_XMLConfigator.AddElem(_T("ImagePos"));
				}	
				m_XMLConfigator.EnterElem();

				if(!m_XMLConfigator.FindElem(_T("Valid")))
				{
					m_XMLConfigator.AddElem(_T("Valid"));
				}
				m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetIsMarkImagePosOK(i));

				if(!m_XMLConfigator.FindElem(_T("ImageX")))
				{
					m_XMLConfigator.AddElem(_T("ImageX"));
				}
				m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_dPosX);

				if(!m_XMLConfigator.FindElem(_T("ImageY")))
				{
					m_XMLConfigator.AddElem(_T("ImageY"));
				}
				m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_dPosY);

				if(!m_XMLConfigator.FindElem(_T("ImageD")))
				{
					m_XMLConfigator.AddElem(_T("ImageD"));
				}		
				m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_dAngle);

				int nAuxiliaryIndex = 0;
				for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
				{
					CString strAuxiliary;
					strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));

					strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));

					strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
				}

				m_XMLConfigator.LeaveElem();


				m_XMLConfigator.LeaveElem();
			}
			if(!m_XMLConfigator.FindElem(_T("TargetResultOK")))
			{
				m_XMLConfigator.AddElem(_T("TargetResultOK"));
			}
			m_XMLConfigator.SetElemData(m_vbMutiTargetMarkOK.at(j));
			m_XMLConfigator.LeaveElem();
		}
	}


	m_XMLConfigator.LeaveElem();

	return m_XMLConfigator.Save(strDir);
}

BOOL vcBaseVisionAlign::LoadObjectPosInfo(int nIndex)
{
	ASSERT(nIndex >= 0);
	ASSERT(m_pVisionASMConfig != NULL);
	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
	ASSERT(m_pPlatformInfo != NULL);

	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
	{
		return FALSE;
	}
	if (m_pVisionASMConfig == NULL)
	{
		return FALSE;
	}
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	CString strInfo;
	double dValue = 0;
	int i = 0, j = 0, nData = 0;
	CCoordPos pos;
	CPlatformXYDAxisPos		*pPlatformAxisPos = NULL;
	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;

	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
	strName.Format(_T("%03d"),nIndex+1);
	if (strName.IsEmpty())	// 产品名称为空，不合法
	{
		return FALSE;
	}

	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\Jobs\\") + strName + _T("\\SearchData.xml");

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	if (!m_XMLConfigator.Load(strDir))
	{
		return FALSE;
	}

	if (!m_XMLConfigator.FindElem(_T("SearchData")))// (Root)
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();

	if (FALSE==m_pPlatformInfo->m_bEnableMultiCalibExtension)
	{
		//兼容之前结构
		// 
		for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
		{
			strInfo.Format(_T("ObjectResult%d"),i);
			if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
			{
				m_XMLConfigator.EnterElem();
				if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
				{
					m_XMLConfigator.EnterElem();
					CPlatformXYDAxisPos AxisPos;
					if (m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
					}
					if (m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
					}
					if (m_XMLConfigator.FindElem(_T("PosD")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
					}

					if (m_vpObjectPlatformAxisPos.at(i) != NULL)
					{
						delete m_vpObjectPlatformAxisPos.at(i);
						m_vpObjectPlatformAxisPos.at(i)=NULL;

						m_vpObjectPlatformAxisPos.at(i) = new CPlatformXYDAxisPos(AxisPos);
					}
					else
					{
						m_vpObjectPlatformAxisPos.at(i) = new CPlatformXYDAxisPos(AxisPos);
					}

					m_XMLConfigator.LeaveElem();
				}
				if (m_XMLConfigator.FindElem(_T("CamAxisPos")))  // (Level-2) 轴位置
				{
					m_XMLConfigator.EnterElem();
					CPlatformXYAxisPos AxisPos;
					if (m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
					}
					if (m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
					}

					if (m_vpObjectCamAxisPos.at(i) != NULL)
					{
						delete m_vpObjectCamAxisPos.at(i);
						m_vpObjectCamAxisPos.at(i)=NULL;

						m_vpObjectCamAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
					}
					else
					{
						m_vpObjectCamAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
					}

					m_XMLConfigator.LeaveElem();
				}

				if (m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))  // (Level-2) 轴位置
				{
					m_XMLConfigator.EnterElem();
					CPlatformXYAxisPos AxisPos;
					if (m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
					}
					if (m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
					}

					if (m_vpObjectCamAxisPlatformAxisPos.at(i) != NULL)
					{
						delete m_vpObjectCamAxisPlatformAxisPos.at(i);
						m_vpObjectCamAxisPlatformAxisPos.at(i)=NULL;

						m_vpObjectCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
					}
					else
					{
						m_vpObjectCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
					}

					m_XMLConfigator.LeaveElem();
				}


				if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
				{
					m_XMLConfigator.EnterElem();

					nData = 0;
					if (m_XMLConfigator.FindElem(_T("Valid")))
					{
						m_XMLConfigator.GetElemData(nData);
					}
					if (m_XMLConfigator.FindElem(_T("ImageX")))
					{
						m_XMLConfigator.GetElemData(pos.m_dPosX);
					}
					if (m_XMLConfigator.FindElem(_T("ImageY")))
					{
						m_XMLConfigator.GetElemData(pos.m_dPosY);
					}
					if (m_XMLConfigator.FindElem(_T("ImageD")))
					{
						m_XMLConfigator.GetElemData(pos.m_dAngle);
					}

					int nAuxiliaryIndex = 0;
					for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
					{
						CString strAuxiliary;
						strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
						if (m_XMLConfigator.FindElem(strAuxiliary))
						{
							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
						}
						strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
						if (m_XMLConfigator.FindElem(strAuxiliary))
						{
							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
						}
						strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
						if (m_XMLConfigator.FindElem(strAuxiliary))
						{
							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
						}
					}

					if (m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
					{
						m_XMLConfigator.GetElemData(pos.m_dLineAngle1);
					}

					if (m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
					{
						m_XMLConfigator.GetElemData(pos.m_dLineAngle2);
					}

					m_mpObjectMarkImagePos.SetMarkImagePos(i, nData, pos);

					m_XMLConfigator.LeaveElem();
				}


				m_XMLConfigator.LeaveElem();
			}
		}
	}
	else
	{
		int nNums = 1;
		if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
		{
			nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
		}

		for (int it =0;it < nNums;it++)
		{
			strInfo.Format(_T("ProducetMultiExObject%d"),it);
			if(m_XMLConfigator.FindElem(strInfo))//  扩展序号节点
			{
				m_XMLConfigator.EnterElem();

				for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
				{
					strInfo.Format(_T("ObjectResult%d"),i);
					if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
					{
						m_XMLConfigator.EnterElem();
						if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
						{
							m_XMLConfigator.EnterElem();
							CPlatformXYDAxisPos AxisPos;
							if (m_XMLConfigator.FindElem(_T("PosX")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
							}
							if (m_XMLConfigator.FindElem(_T("PosY")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
							}
							if (m_XMLConfigator.FindElem(_T("PosD")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
							}
							if (it < m_vvpObjectPlatformAxisPosMultiEx.size())
							{
								if (m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i) != NULL)
								{
									delete m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i);
									m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i)=NULL;

									m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYDAxisPos(AxisPos);
								}
								else
								{
									m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYDAxisPos(AxisPos);
								}
							}


							m_XMLConfigator.LeaveElem();
						}
						if (m_XMLConfigator.FindElem(_T("CamAxisPos")))  // (Level-2) 轴位置
						{
							m_XMLConfigator.EnterElem();
							CPlatformXYAxisPos AxisPos;
							if (m_XMLConfigator.FindElem(_T("PosX")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
							}
							if (m_XMLConfigator.FindElem(_T("PosY")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
							}

							if (m_vvpObjectCamAxisPosMultiEx.at(it).at(i) != NULL)
							{
								delete m_vvpObjectCamAxisPosMultiEx.at(it).at(i);
								m_vvpObjectCamAxisPosMultiEx.at(it).at(i)=NULL;

								m_vvpObjectCamAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
							}
							else
							{
								m_vvpObjectCamAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
							}

							m_XMLConfigator.LeaveElem();
						}
						if (m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))  // (Level-2) 轴位置
						{
							m_XMLConfigator.EnterElem();
							CPlatformXYAxisPos AxisPos;
							if (m_XMLConfigator.FindElem(_T("PosX")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
							}
							if (m_XMLConfigator.FindElem(_T("PosY")))
							{
								m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
							}

							if (m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i) != NULL)
							{
								delete m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i);
								m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i)=NULL;

								m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
							}
							else
							{
								m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
							}

							m_XMLConfigator.LeaveElem();
						}


						if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
						{
							m_XMLConfigator.EnterElem();

							nData = 0;
							if (m_XMLConfigator.FindElem(_T("Valid")))
							{
								m_XMLConfigator.GetElemData(nData);
							}
							if (m_XMLConfigator.FindElem(_T("ImageX")))
							{
								m_XMLConfigator.GetElemData(pos.m_dPosX);
							}
							if (m_XMLConfigator.FindElem(_T("ImageY")))
							{
								m_XMLConfigator.GetElemData(pos.m_dPosY);
							}
							if (m_XMLConfigator.FindElem(_T("ImageD")))
							{
								m_XMLConfigator.GetElemData(pos.m_dAngle);
							}

							int nAuxiliaryIndex = 0;
							for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
							{
								CString strAuxiliary;
								strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
								}
								strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
								}
								strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
								if (m_XMLConfigator.FindElem(strAuxiliary))
								{
									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
								}
							}

							if (m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
							{
								m_XMLConfigator.GetElemData(pos.m_dLineAngle1);
							}

							if (m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
							{
								m_XMLConfigator.GetElemData(pos.m_dLineAngle2);
							}
							if (it < m_vmpObjectMarkImagePos_MultiEX.size())
							{
								m_vmpObjectMarkImagePos_MultiEX.at(it).SetMarkImagePos(i, nData, pos);
							}


							m_XMLConfigator.LeaveElem();
						}


						m_XMLConfigator.LeaveElem();
					}
				}

				m_XMLConfigator.LeaveElem();
			}
		}
	}

	m_XMLConfigator.LeaveElem();


	return TRUE;
}

BOOL vcBaseVisionAlign::SaveObjectPosInfo(int nIndex)
{
	ASSERT(nIndex >= 0);
	ASSERT(m_pVisionASMConfig != NULL);
	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
	ASSERT(m_pPlatformInfo != NULL);

	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
	{
		return FALSE;
	}
	if (m_pVisionASMConfig == NULL)
	{
		return FALSE;
	}
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	CString strInfo;
	double dValue = 0;
	int i = 0, j = 0, nData = 0;
	CCoordPos pos;
	CPlatformXYDAxisPos		*pPlatformAxisPos = NULL;
	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;
	CPlatformXYAxisPos		*pCamAxisPos   = NULL;
	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
	strName.Format(_T("%03d"),nIndex+1);
	if (strName.IsEmpty())	// 产品名称为空，不合法
	{
		return FALSE;
	}

	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\Jobs\\") + strName + _T("\\SearchData.xml");

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	m_XMLConfigator.Load(strDir);


	m_XMLConfigator.ResetDocElemPos();


	if(!m_XMLConfigator.FindElem(_T("SearchData")))	// (Root)
	{
		m_XMLConfigator.AddElem(_T("SearchData"));
	}
	m_XMLConfigator.EnterElem();

	// 
	for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
	{
		strInfo.Format(_T("ObjectResult%d"),i);
		if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();

		if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
		{
			m_XMLConfigator.AddElem(_T("PlatAxisPos"));
		}
		m_XMLConfigator.EnterElem();

		if (i < m_vpObjectPlatformAxisPos.size() && m_vpObjectPlatformAxisPos.at(i) != NULL)
		{
			pPlatformAxisPos = (CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(i);

			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

			if(!m_XMLConfigator.FindElem(_T("PosD")))
			{
				m_XMLConfigator.AddElem(_T("PosD"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);

		}
		else
		{
			CPlatformXYDAxisPos AxisPos;
			pPlatformAxisPos = &AxisPos;

			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

			if(!m_XMLConfigator.FindElem(_T("PosD")))
			{
				m_XMLConfigator.AddElem(_T("PosD"));
			}
			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
		}
		m_XMLConfigator.LeaveElem();


		if(!m_XMLConfigator.FindElem(_T("CamAxisPos")))	// (Level-2) 相机轴位置信息
		{
			m_XMLConfigator.AddElem(_T("CamAxisPos"));
		}
		m_XMLConfigator.EnterElem();

		if(m_vpObjectCamAxisPos.at(i) != NULL && i < m_vpObjectCamAxisPos.size())
		{ 
			pCamAxisPos = (CPlatformXYAxisPos*)m_vpObjectCamAxisPos.at(i);
			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
		}
		else
		{
			CPlatformXYAxisPos axisPos;
			pCamAxisPos = &axisPos;
			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
		}
		m_XMLConfigator.LeaveElem();


		if(!m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))	// (Level-2) 相机轴位置信息
		{
			m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));
		}
		m_XMLConfigator.EnterElem();

		if(m_vpObjectCamAxisPlatformAxisPos.at(i) != NULL && i < m_vpObjectCamAxisPlatformAxisPos.size())
		{ 
			pCamAxisPos = (CPlatformXYAxisPos*)m_vpObjectCamAxisPlatformAxisPos.at(i);
			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
		}
		else
		{
			CPlatformXYAxisPos axisPos;
			pCamAxisPos = &axisPos;
			if(!m_XMLConfigator.FindElem(_T("PosX")))
			{
				m_XMLConfigator.AddElem(_T("PosX"));
			}
			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);

			if(!m_XMLConfigator.FindElem(_T("PosY")))
			{
				m_XMLConfigator.AddElem(_T("PosY"));
			}
			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
		}
		m_XMLConfigator.LeaveElem();


		if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
		{
			m_XMLConfigator.AddElem(_T("ImagePos"));
		}	
		m_XMLConfigator.EnterElem();

		if(!m_XMLConfigator.FindElem(_T("Valid")))
		{
			m_XMLConfigator.AddElem(_T("Valid"));
		}
		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetIsMarkImagePosOK(i));

		if(!m_XMLConfigator.FindElem(_T("ImageX")))
		{
			m_XMLConfigator.AddElem(_T("ImageX"));
		}
		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dPosX);

		if(!m_XMLConfigator.FindElem(_T("ImageY")))
		{
			m_XMLConfigator.AddElem(_T("ImageY"));
		}
		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dPosY);

		if(!m_XMLConfigator.FindElem(_T("ImageD")))
		{
			m_XMLConfigator.AddElem(_T("ImageD"));
		}		
		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dAngle);

		int nAuxiliaryIndex = 0;
		for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
		{
			CString strAuxiliary;
			strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
			if (!m_XMLConfigator.FindElem(strAuxiliary))
			{
				m_XMLConfigator.AddElem(strAuxiliary);
			}
			m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));

			strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
			if (!m_XMLConfigator.FindElem(strAuxiliary))
			{
				m_XMLConfigator.AddElem(strAuxiliary);
			}
			m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));

			strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
			if (!m_XMLConfigator.FindElem(strAuxiliary))
			{
				m_XMLConfigator.AddElem(strAuxiliary);
			}
			m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
		}

		if(!m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
		{
			m_XMLConfigator.AddElem(_T("ImageLineAngle1"));
		}		
		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dLineAngle1);

		if(!m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
		{
			m_XMLConfigator.AddElem(_T("ImageLineAngle2"));
		}		
		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dLineAngle2);

		m_XMLConfigator.LeaveElem();


		m_XMLConfigator.LeaveElem();
	}
	int nNums = 1;
	if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
	{
		nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
	}

	for (int it =0;it < nNums;it++)
	{
		strInfo.Format(_T("ProducetMultiExObject%d"),it);
		if(!m_XMLConfigator.FindElem(strInfo))//  扩展序号节点
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();

		for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
		{
			strInfo.Format(_T("ObjectResult%d"),i);
			if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
			{
				m_XMLConfigator.AddElem(strInfo);
			}
			m_XMLConfigator.EnterElem();

			if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
			{
				m_XMLConfigator.AddElem(_T("PlatAxisPos"));
			}
			m_XMLConfigator.EnterElem();

			if (it<m_vvpObjectPlatformAxisPosMultiEx.size())
			{
				if(i < m_vvpObjectPlatformAxisPosMultiEx.at(it).size() && m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i) != NULL)
				{
					pPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i));

					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

					if(!m_XMLConfigator.FindElem(_T("PosD")))
					{
						m_XMLConfigator.AddElem(_T("PosD"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);

				}
				else
				{
					CPlatformXYDAxisPos AxisPos;
					pPlatformAxisPos = &AxisPos;

					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);

					if(!m_XMLConfigator.FindElem(_T("PosD")))
					{
						m_XMLConfigator.AddElem(_T("PosD"));
					}
					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
				}
			}

			m_XMLConfigator.LeaveElem();

			if(!m_XMLConfigator.FindElem(_T("CamAxisPos")))	// (Level-2) 相机轴位置信息
			{
				m_XMLConfigator.AddElem(_T("CamAxisPos"));
			}
			m_XMLConfigator.EnterElem();
			if (it<m_vvpObjectCamAxisPosMultiEx.size())
			{
				if(m_vvpObjectCamAxisPosMultiEx.at(it).at(i) != NULL && i < m_vvpObjectCamAxisPosMultiEx.at(it).size())
				{ 
					pCamAxisPos = (CPlatformXYAxisPos*)m_vvpObjectCamAxisPosMultiEx.at(it).at(i);
					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
				}
				else
				{
					CPlatformXYAxisPos axisPos;
					pCamAxisPos = &axisPos;
					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
				}
			}

			m_XMLConfigator.LeaveElem();

			if(!m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))	// (Level-2) 相机轴位置信息
			{
				m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));
			}
			m_XMLConfigator.EnterElem();
			if (it<m_vvpObjectCamAxisPlatformAxisPosMultiEx.size())
			{
				if(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i) != NULL && i < m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).size())
				{ 
					pCamAxisPos = (CPlatformXYAxisPos*)m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i);
					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
				}
				else
				{
					CPlatformXYAxisPos axisPos;
					pCamAxisPos = &axisPos;
					if(!m_XMLConfigator.FindElem(_T("PosX")))
					{
						m_XMLConfigator.AddElem(_T("PosX"));
					}
					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);

					if(!m_XMLConfigator.FindElem(_T("PosY")))
					{
						m_XMLConfigator.AddElem(_T("PosY"));
					}
					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
				}
			}

			m_XMLConfigator.LeaveElem();


			if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
			{
				m_XMLConfigator.AddElem(_T("ImagePos"));
			}	
			m_XMLConfigator.EnterElem();

			if (it<m_vmpObjectMarkImagePos_MultiEX.size())
			{
				if(!m_XMLConfigator.FindElem(_T("Valid")))
				{
					m_XMLConfigator.AddElem(_T("Valid"));
				}
				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetIsMarkImagePosOK(i));

				if(!m_XMLConfigator.FindElem(_T("ImageX")))
				{
					m_XMLConfigator.AddElem(_T("ImageX"));
				}
				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dPosX);

				if(!m_XMLConfigator.FindElem(_T("ImageY")))
				{
					m_XMLConfigator.AddElem(_T("ImageY"));
				}
				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dPosY);

				if(!m_XMLConfigator.FindElem(_T("ImageD")))
				{
					m_XMLConfigator.AddElem(_T("ImageD"));
				}		
				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dAngle);

				int nAuxiliaryIndex = 0;
				for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
				{
					CString strAuxiliary;
					strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));

					strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));

					strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
					if (!m_XMLConfigator.FindElem(strAuxiliary))
					{
						m_XMLConfigator.AddElem(strAuxiliary);
					}
					m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
				}

				if(!m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
				{
					m_XMLConfigator.AddElem(_T("ImageLineAngle1"));
				}		
				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dLineAngle1);

				if(!m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
				{
					m_XMLConfigator.AddElem(_T("ImageLineAngle2"));
				}		
				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dLineAngle2);

				m_XMLConfigator.LeaveElem();
			}

			m_XMLConfigator.LeaveElem();
		}

		m_XMLConfigator.LeaveElem();

	}
	m_XMLConfigator.LeaveElem();

	return m_XMLConfigator.Save(strDir);
}

void vcBaseVisionAlign::LoadQRCodeOption()
{
	TCHAR szPath[MAX_PATH];
	GetModuleFileName(NULL, szPath, MAX_PATH);
	CString strPath = szPath;
	CString strOptionPath = szPath;
	strPath = strPath.Left(strPath.ReverseFind('\\'));
	strOptionPath = strPath;

	strOptionPath += _T("\\VSConfig\\Save2DCodeOption.ini");
	//判断配置文件是否存在
	if(!PathFileExists(strOptionPath))
	{
		SaveQRCodeOption();
	}

	char buff[MAX_PATH];
	int nDataSize = MAX_PATH;
	int nReadLen = 0;
	nReadLen = GetPrivateProfileString(_T("Parameter"),_T("strSavePath"),_T("D:\\"),buff,nDataSize,strOptionPath);
	buff[nReadLen] = 0;
	m_stUploadData.strSavePath.Empty();
	m_stUploadData.strSavePath = buff;

	nReadLen = GetPrivateProfileString(_T("Parameter"),_T("strUploadPath"),_T("D:\\"),buff,nDataSize,strOptionPath);
	buff[nReadLen] = 0;
	m_stUploadData.strUploadPath.Empty();
	m_stUploadData.strUploadPath = buff;

	nReadLen = GetPrivateProfileString(_T("Parameter"),_T("strWorkType"),_T("D:\\"),buff,nDataSize,strOptionPath);
	buff[nReadLen] = 0;
	m_stUploadData.strWorkType.Empty();
	m_stUploadData.strWorkType = buff;

	m_stUploadData.nTimeInterval = GetPrivateProfileInt(_T("Parameter"),_T("nTimeInterval"),0,strOptionPath);

}

void vcBaseVisionAlign::SaveQRCodeOption()
{
	TCHAR szPath[MAX_PATH];
	GetModuleFileName(NULL, szPath, MAX_PATH);
	CString strPath = szPath;
	CString strOptionPath = szPath;
	strPath = strPath.Left(strPath.ReverseFind('\\'));
	strOptionPath = strPath;

	strOptionPath += _T("\\VSConfig\\Save2DCodeOption.ini");

	::WritePrivateProfileString(_T("Parameter"),_T("strSavePath"),m_stUploadData.strSavePath,strOptionPath);
	::WritePrivateProfileString(_T("Parameter"),_T("strUploadPath"),m_stUploadData.strUploadPath,strOptionPath);
	::WritePrivateProfileString(_T("Parameter"),_T("strWorkType"),m_stUploadData.strWorkType,strOptionPath);
	CString str;
	str.Format(_T("%d"),m_stUploadData.nTimeInterval);
	::WritePrivateProfileString(_T("Parameter"),_T("nTimeInterval"),str,strOptionPath);
}

BOOL vcBaseVisionAlign::LoadTotalCalibDataInfo()
{
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	BOOL bLoad = m_XMLConfigator.Load(m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\JobCalibs\\JobCalibs.xml"));
	if (!bLoad)
	{
		return FALSE;
	}


	if (!m_XMLConfigator.FindElem(_T("JobCalibs")))	
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 1级目录

	if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-1) 平台类型
	{
		return FALSE;
	}
	int nData = 0;
	m_XMLConfigator.GetElemData(nData);
	if ( ((PlatformType)nData) != m_pPlatformInfo->m_ePlatformType )	// 平台类型检查
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("JobCalibNum")))	// (Level-1) 产品总数
	{
		return FALSE;
	}

	int nTotalCalibNum = 0;
	m_XMLConfigator.GetElemData(nTotalCalibNum);
	if (!m_XMLConfigator.FindElem(_T("CurIndex"))) // (Level-1) 当前产品索引，从0开始
	{
		return FALSE;
	}
	m_XMLConfigator.GetElemData(nData);
	m_pVisionASMConfig->m_TotalCalibData.SetCurCalibIndex(nData);


	// 加载产品名称列表
	if (!m_XMLConfigator.FindElem(_T("JobCalibList")))	// (Level-1) 产品名称列表
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem(); // 2级目录
	std::vector<CString> vstrNameList;
	CString strIndex;
	int i = 0;
	for (i=0; i<nTotalCalibNum; i++)
	{
		strIndex.Format(_T("JobCalib%d"), i+1);
		m_XMLConfigator.FindElem(strIndex); // (Level-2) 品种标识，从1开始，标识内容表示产品在大产品和小产品中的索引，从0开始，中间空格区分，只做提示用无其他用途
		//vstrNameList.push_back(m_XMLConfigator.GetAttribute(_T("Name")));
		vstrNameList.push_back(strIndex);
	}
	if (vstrNameList.size() != nTotalCalibNum)
	{
		return FALSE;
	}

	for (i=0; i<nTotalCalibNum; i++)
	{
		if (!LoadCalibDataInfo(i, vstrNameList.at(i)))	// 加载每个产品的详细信息
		{

			// 若平台详细配置XML文件不存在或者配置文件内容无效，则仅根据管理员配置的系统平台信息初始化m_pVisionASMConfig
			CString strErrInfo;
			strErrInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_STR_LOAD_PRODUCT_FAILE), m_pPlatformInfo->m_nPlatformIndex, i+1);
			int nMBReturn = AfxMessageBox(strErrInfo);

			CCalibData product(*m_pPlatformInfo);
			m_pVisionASMConfig->m_TotalCalibData.SetItemGrow(i, product);
			m_pVisionASMConfig->m_TotalCalibData.SetItemName(i,_T("------"));

			// 保存Job.xml
			SaveCalibDataInfo(i);
		}
	}
	m_XMLConfigator.LeaveElem(); // 2级目录



	if (!m_XMLConfigator.FindElem(_T("FaJobCalibList")))	// (Level-1) 大产品列表
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem(); // 2级目录

	if (!m_XMLConfigator.FindElem(_T("FaJobCalibNum"))) // (Level-2) 大产品总数
	{
		return FALSE;
	}
	int nTotalFaProductNum = 0;
	m_XMLConfigator.GetElemData(nTotalFaProductNum);

	for(i = 0; i<nTotalFaProductNum; i++)
	{
		strIndex.Format(_T("FaJobCalib%d"),i+1); // (Level-2) 大产品标识，从1开始
		if (!m_XMLConfigator.FindElem(strIndex))
		{
			return FALSE;
		}
		m_XMLConfigator.EnterElem(); // 3级目录

		if (!m_XMLConfigator.FindElem(_T("ChdJobCalibNum"))) // (Level-3) 大产品包含的小产品总数
		{
			return FALSE;
		}
		int nChdProductNum = 0;
		m_XMLConfigator.GetElemData(nChdProductNum);

		if (!m_XMLConfigator.FindElem(_T("CalibLastChdIndex"))) // (Level-3) 大产品最后一次使用的小产品索引，从0开始
		{
			return FALSE;
		}
		m_XMLConfigator.GetElemData(nData);
		m_pVisionASMConfig->m_TotalCalibData.AddCalibLastChdIndex(nData);



		if (!m_XMLConfigator.FindElem(_T("ChdJobCalibList"))) // (Level-3) 小品种产品列表
		{
			return FALSE;
		}
		m_XMLConfigator.EnterElem(); // 4级目录

		for(int j = 0;j<nChdProductNum; j++)
		{
			strIndex.Format(_T("ChdJobCalib%d"),j+1);
			m_XMLConfigator.FindElem(strIndex); // (Level-4) 小产品标识，从1开始
			m_XMLConfigator.GetElemData(nData); // 标识内容表示小产品在全部产品中索引，从0开始
			m_pVisionASMConfig->m_TotalCalibData.SetCalibIndex(i,j,nData);
		}
		m_XMLConfigator.LeaveElem(); // 4级目录

		if (!m_XMLConfigator.FindElem(_T("FaJobCalibName"))) // (Level-3) 大产品名称
		{
			return FALSE;
		}
		CString str = m_XMLConfigator.GetElemData();
		m_pVisionASMConfig->m_TotalCalibData.SetCalibNameFa(i,str);

		m_XMLConfigator.LeaveElem(); // 3级目录

	}

	m_XMLConfigator.LeaveElem(); // 2级目录

	m_XMLConfigator.LeaveElem(); // 1级目录

	//	m_pVisionASMConfig->m_TotalCalibData.RemoveInvalidItems();
	return TRUE;
}

BOOL vcBaseVisionAlign::SaveTotalCalibDataInfo(BOOL bSaveDetails)
{
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}

	// 保存所有产品信息
	int i=0;
	int nTotalCalibNum = m_pVisionASMConfig->m_TotalCalibData.GetCount();
	if (bSaveDetails)
	{
		for (i=0; i<nTotalCalibNum; i++)
		{
			if (!SaveCalibDataInfo(i))
			{
				continue;
			}
		}
	}


	// 保存Jobs.xml
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	m_XMLConfigator.AddElem(_T("JobCalibs"));
	m_XMLConfigator.EnterElem(); // 1级目录
	m_XMLConfigator.AddElem(_T("PlatType"), (int)m_pPlatformInfo->m_ePlatformType);
	m_XMLConfigator.AddElem(_T("JobCalibNum"), nTotalCalibNum);
	m_XMLConfigator.AddElem(_T("CurIndex"), m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()); // (Level-1) 当前产品索引，从0开始
	m_XMLConfigator.AddElem(_T("JobCalibList"));
	m_XMLConfigator.EnterElem(); // 2级目录
	CString strIndex;
	for (i=0; i<nTotalCalibNum; i++)
	{
		strIndex.Format(_T("JobCalib%d"), i+1);
		//m_XMLConfigator.AddElem(strIndex);
		//m_XMLConfigator.AddAttribute(_T("Name"), m_pVisionASMConfig->m_TotalCalibData.GetItemName(i));

		int nFaProductIndex, nChdProductIndex;
		m_pVisionASMConfig->m_TotalCalibData.GetDlgCalibIndex(i,nFaProductIndex, nChdProductIndex);
		CString str;
		str.Format(_T("%d %d"),nFaProductIndex, nChdProductIndex);
		m_XMLConfigator.AddElem(strIndex, str); // (Level-2) 品种标识，从1开始，标识内容表示产品在大产品和小产品中的索引，从0开始，中间空格区分，只做提示用无其他用途
	}
	m_XMLConfigator.LeaveElem(); // 2级目录

	m_XMLConfigator.AddElem(_T("FaJobCalibList"));
	m_XMLConfigator.EnterElem(); // 2级目录

	int nTotalProductNumFa = m_pVisionASMConfig->m_TotalCalibData.GetCalibCountFa();
	m_XMLConfigator.AddElem(_T("FaJobCalibNum"), nTotalProductNumFa); // (Level-2) 大产品总数

	for(i = 0; i<nTotalProductNumFa; i++)
	{
		strIndex.Format(_T("FaJobCalib%d"),i+1);
		m_XMLConfigator.AddElem(strIndex); // (Level-2) 大产品标识，从1开始
		m_XMLConfigator.EnterElem(); // 3级目录

		m_XMLConfigator.AddElem(_T("FaJobCalibName"),  m_pVisionASMConfig->m_TotalCalibData.GetCalibNameFa(i)); // (Level-3) 大产品名称
		int nChdProductNum = m_pVisionASMConfig->m_TotalCalibData.GetCalibCountChd(i);
		m_XMLConfigator.AddElem(_T("ChdJobCalibNum"), nChdProductNum); // (Level-3) 大产品包含的小产品总数
		m_XMLConfigator.AddElem(_T("CalibLastChdIndex"),  m_pVisionASMConfig->m_TotalCalibData.GetCalibLastChdIndex(i)); // (Level-3) 大产品最后一次使用的小产品索引，从0开始

		m_XMLConfigator.AddElem(_T("ChdJobCalibList")); // (Level-3) 小品种产品列表
		m_XMLConfigator.EnterElem(); // 4级目录
		for(int j = 0;j< nChdProductNum; j++)
		{
			strIndex.Format(_T("ChdJobCalib%d"), j+1); // (Level-4) 小产品标识，从1开始
			m_XMLConfigator.AddElem(strIndex, m_pVisionASMConfig->m_TotalCalibData.GetCalibIndex(i,j)); // 标识内容表示小产品在全部产品中索引，从0开始
		}
		m_XMLConfigator.LeaveElem(); // 4级目录

		m_XMLConfigator.LeaveElem(); // 3级目录
	}

	m_XMLConfigator.LeaveElem(); // 2级目录

	m_XMLConfigator.LeaveElem(); // 1级目录

	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
		+ _T("\\JobCalibs");

	// 创建产品保存文件夹
	DWORD dwAttributes = GetFileAttributes(strDir);
	if ((dwAttributes == 0xFFFFFFFF) || ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
	{	
		// 创建多级目录
		int nLen = 0;
		DWORD dwLevelXAttrib = 0;
		int nSlashIdx = strDir.Find('\\');
		CString strDirLevelX = _T("");
		CString strTemp = strDir;
		while (nSlashIdx != -1)
		{
			nLen = strDirLevelX.GetLength();
			nSlashIdx += (nLen == 0) ? 0 : (nLen + 1);
			strDirLevelX = strDir.Left(nSlashIdx);
			strTemp = strDir.Mid(nSlashIdx + 1);
			dwLevelXAttrib = GetFileAttributes(strDirLevelX);
			if ((dwLevelXAttrib == 0xFFFFFFFF) || ((dwLevelXAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0))
			{
				if (!CreateDirectory(strDirLevelX, NULL))
				{
					return FALSE;
				}
			}
			nSlashIdx = strTemp.Find('\\');
		}
		if (!CreateDirectory(strDir, NULL))
		{
			return FALSE;
		}
	}

	// 写入信息




	BOOL bSave = m_XMLConfigator.Save(m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\JobCalibs\\JobCalibs.xml"));
	if (!bSave)
	{
		return FALSE;
	}

	CString strTmp = _T("");
	strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
	strTmp +=  _T("_Save_JobCalibs.xml");
	ExecuteGitCommit(strTmp);

	// 验证是否保存成功
	if (!IsSaveTotalCalibDataInfoOK())
	{
		return FALSE;
	}

	return TRUE;
}  

BOOL vcBaseVisionAlign::LoadTotalProductDataInfo()
{
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	BOOL bLoad = m_XMLConfigator.Load(m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\Jobs\\Jobs.xml"));
	if (!bLoad)
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("Jobs")))	
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 1级目录
	if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-1) 平台类型
	{
		return FALSE;
	}
	int nData = 0;
	m_XMLConfigator.GetElemData(nData);
	if ( ((PlatformType)nData) != m_pPlatformInfo->m_ePlatformType )	// 平台类型检查
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("JobNum")))	// (Level-1) 产品总数
	{
		return FALSE;
	}
	int nTotalProductNum = 0;
	m_XMLConfigator.GetElemData(nTotalProductNum);
	if (!m_XMLConfigator.FindElem(_T("CurIndex"))) // (Level-1) 当前产品索引，从0开始
	{
		return FALSE;
	}
	m_XMLConfigator.GetElemData(nData);
	m_pVisionASMConfig->m_TotalProductData.SetCurProductIndex(nData);

	// 加载产品名称列表
	if (!m_XMLConfigator.FindElem(_T("JobList")))	// (Level-1) 产品名称列表
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 2级目录
	std::vector<CString> vstrNameList;
	CString strIndex;
	int i = 0;
	for (i=0; i<nTotalProductNum; i++)
	{
		strIndex.Format(_T("Job%d"), i+1);
		m_XMLConfigator.FindElem(strIndex); // (Level-2) 品种标识，从1开始，标识内容表示产品在大产品和小产品中的索引，从0开始，中间空格区分，只做提示用无其他用途
		//vstrNameList.push_back(m_XMLConfigator.GetAttribute(_T("Name")));
		vstrNameList.push_back(strIndex);
	}
	if (vstrNameList.size() != nTotalProductNum)
	{
		return FALSE;
	}

	for (i=0; i<nTotalProductNum; i++)
	{
		if (!LoadProductDataInfo(i, vstrNameList.at(i)))	// 加载每个产品的详细信息
		{
			CProductData product(*m_pPlatformInfo);
			m_pVisionASMConfig->m_TotalProductData.SetItemGrow(i, product);
			m_pVisionASMConfig->m_TotalProductData.SetItemName(i,_T("------"));

			// 保存Job.xml
			SaveProductDataInfo(i);
		}
	}
	m_XMLConfigator.LeaveElem(); // 2级目录


	if (!m_XMLConfigator.FindElem(_T("FaJobList")))	// (Level-1) 大产品列表
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem(); // 2级目录

	if (!m_XMLConfigator.FindElem(_T("FaJobNum"))) // (Level-2) 大产品总数
	{
		return FALSE;
	}
	int nTotalFaProductNum = 0;
	m_XMLConfigator.GetElemData(nTotalFaProductNum);

	for(i = 0; i<nTotalFaProductNum; i++)
	{
		strIndex.Format(_T("FaJob%d"),i+1); // (Level-2) 大产品标识，从1开始
		if (!m_XMLConfigator.FindElem(strIndex))
		{
			return FALSE;
		}
		m_XMLConfigator.EnterElem(); // 3级目录

		if (!m_XMLConfigator.FindElem(_T("ChdJobNum"))) // (Level-3) 大产品包含的小产品总数
		{
			return FALSE;
		}
		int nChdProductNum = 0;
		m_XMLConfigator.GetElemData(nChdProductNum);

		if (!m_XMLConfigator.FindElem(_T("LastChdIndex"))) // (Level-3) 大产品最后一次使用的小产品索引，从0开始
		{
			return FALSE;
		}
		m_XMLConfigator.GetElemData(nData);
		m_pVisionASMConfig->m_TotalProductData.AddLastChdIndex(nData);

		if (!m_XMLConfigator.FindElem(_T("ChdJobList"))) // (Level-3) 小品种产品列表
		{
			return FALSE;
		}
		m_XMLConfigator.EnterElem(); // 4级目录

		for(int j = 0;j<nChdProductNum; j++)
		{
			strIndex.Format(_T("ChdJob%d"),j+1);
			m_XMLConfigator.FindElem(strIndex); // (Level-4) 小产品标识，从1开始
			m_XMLConfigator.GetElemData(nData); // 标识内容表示小产品在全部产品中索引，从0开始
			m_pVisionASMConfig->m_TotalProductData.SetProductIndex(i,j,nData);
		}
		m_XMLConfigator.LeaveElem(); // 4级目录

		if (!m_XMLConfigator.FindElem(_T("FaJobName"))) // (Level-3) 大产品名称
		{
			return FALSE;
		}
		CString str = m_XMLConfigator.GetElemData();
		m_pVisionASMConfig->m_TotalProductData.SetProductNameFa(i,str); 

		m_XMLConfigator.LeaveElem(); // 3级目录

	}

	m_XMLConfigator.LeaveElem(); // 2级目录

	m_XMLConfigator.LeaveElem(); // 1级目录

	//	m_pVisionASMConfig->m_TotalProductData.RemoveInvalidItems();
	return TRUE;
}

BOOL vcBaseVisionAlign::SaveTotalProductDataInfo(BOOL bSaveDetails)
{
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}

	// 保存所有产品信息
	int i=0;
	int nTotalProductNum = m_pVisionASMConfig->m_TotalProductData.GetCount();
	if (bSaveDetails)
	{
		for (i=0; i<nTotalProductNum; i++)
		{
			if (!SaveProductDataInfo(i))
			{
				continue;
			}
		}
	}

	// 保存Jobs.xml
	{
		vcXMLConfigurator m_XMLConfigator;
		m_XMLConfigator.SetDoc(_T(""));
		m_XMLConfigator.AddElem(_T("Jobs"));
		m_XMLConfigator.EnterElem(); // 1级目录
		m_XMLConfigator.AddElem(_T("PlatType"), (int)m_pPlatformInfo->m_ePlatformType);
		m_XMLConfigator.AddElem(_T("JobNum"), nTotalProductNum);
		m_XMLConfigator.AddElem(_T("CurIndex"), m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex()); // (Level-1) 当前产品索引，从0开始
		m_XMLConfigator.AddElem(_T("JobList"));
		m_XMLConfigator.EnterElem(); // 2级目录
		CString strIndex;
		for (i=0; i<nTotalProductNum; i++)
		{
			strIndex.Format(_T("Job%d"), i+1);
			//m_XMLConfigator.AddElem(strIndex);
			//m_XMLConfigator.AddAttribute(_T("Name"), m_pVisionASMConfig->m_TotalProductData.GetItemName(i));

			int nFaProductIndex, nChdProductIndex;
			m_pVisionASMConfig->m_TotalProductData.GetDlgProductIndex(i,nFaProductIndex, nChdProductIndex);
			CString str;
			str.Format(_T("%d %d"),nFaProductIndex, nChdProductIndex);
			m_XMLConfigator.AddElem(strIndex, str); // (Level-2) 品种标识，从1开始，标识内容表示产品在大产品和小产品中的索引，从0开始，中间空格区分，只做提示用无其他用途
		}
		m_XMLConfigator.LeaveElem(); // 2级目录

		m_XMLConfigator.AddElem(_T("FaJobList"));
		m_XMLConfigator.EnterElem(); // 2级目录

		int nTotalProductNumFa = m_pVisionASMConfig->m_TotalProductData.GetProductCountFa();
		m_XMLConfigator.AddElem(_T("FaJobNum"), nTotalProductNumFa); // (Level-2) 大产品总数

		for(i = 0; i<nTotalProductNumFa; i++)
		{
			strIndex.Format(_T("FaJob%d"),i+1);
			m_XMLConfigator.AddElem(strIndex); // (Level-2) 大产品标识，从1开始
			m_XMLConfigator.EnterElem(); // 3级目录

			m_XMLConfigator.AddElem(_T("FaJobName"),  m_pVisionASMConfig->m_TotalProductData.GetProductNameFa(i)); // (Level-3) 大产品名称
			int nChdProductNum = m_pVisionASMConfig->m_TotalProductData.GetProductCountChd(i);
			m_XMLConfigator.AddElem(_T("ChdJobNum"), nChdProductNum); // (Level-3) 大产品包含的小产品总数
			m_XMLConfigator.AddElem(_T("LastChdIndex"),  m_pVisionASMConfig->m_TotalProductData.GetLastChdIndex(i)); // (Level-3) 大产品最后一次使用的小产品索引，从0开始

			m_XMLConfigator.AddElem(_T("ChdJobList")); // (Level-3) 小品种产品列表
			m_XMLConfigator.EnterElem(); // 4级目录
			for(int j = 0;j< nChdProductNum; j++)
			{
				strIndex.Format(_T("ChdJob%d"), j+1); // (Level-4) 小产品标识，从1开始
				m_XMLConfigator.AddElem(strIndex, m_pVisionASMConfig->m_TotalProductData.GetProductIndex(i,j)); // 标识内容表示小产品在全部产品中索引，从0开始
			}
			m_XMLConfigator.LeaveElem(); // 4级目录

			m_XMLConfigator.LeaveElem(); // 3级目录
		}

		m_XMLConfigator.LeaveElem(); // 2级目录

		m_XMLConfigator.LeaveElem(); // 1级目录

		CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
			+ _T("\\Jobs");

		// 创建产品保存文件夹
		DWORD dwAttributes = GetFileAttributes(strDir);
		if ((dwAttributes == 0xFFFFFFFF) || ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
		{	
			// 创建多级目录
			int nLen = 0;
			DWORD dwLevelXAttrib = 0;
			int nSlashIdx = strDir.Find('\\');
			CString strDirLevelX = _T("");
			CString strTemp = strDir;
			while (nSlashIdx != -1)
			{
				nLen = strDirLevelX.GetLength();
				nSlashIdx += (nLen == 0) ? 0 : (nLen + 1);
				strDirLevelX = strDir.Left(nSlashIdx);
				strTemp = strDir.Mid(nSlashIdx + 1);
				dwLevelXAttrib = GetFileAttributes(strDirLevelX);
				if ((dwLevelXAttrib == 0xFFFFFFFF) || ((dwLevelXAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0))
				{
					if (!CreateDirectory(strDirLevelX, NULL))
					{
						return FALSE;
					}
				}
				nSlashIdx = strTemp.Find('\\');
			}
			if (!CreateDirectory(strDir, NULL))
			{
				return FALSE;
			}
		}

		// 写入信息
		BOOL bSave = m_XMLConfigator.Save(m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\Jobs\\Jobs.xml"));
		if (!bSave)
		{
			return FALSE;
		}
		CString strTmp = _T("");
		strTmp.Format(_T("工位%d"),m_pPlatformInfo->m_nPlatformIndex+1);
		strTmp +=  _T("_Save_Jobs.xml");
		ExecuteGitCommit(strTmp);
	}

	// 验证是否保存成功
	if (!IsSaveTotalProductDataInfoOK())
	{
		return FALSE;
	}


	return TRUE;
}     

BOOL vcBaseVisionAlign::LoadCalibDataInfo(int nIndex, LPCTSTR lpszProductName)
{
	ASSERT(nIndex >= 0);
	ASSERT(m_pPlatformInfo != NULL);
	CString strProductName = lpszProductName;
	//	ASSERT(!strProductName.IsEmpty());

	if ((strProductName.IsEmpty()) || (nIndex < 0))
	{
		return FALSE;
	}
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	BOOL bLoad = FALSE;
	BSTR bstrName = NULL;
	int i = 0, j = 0, nData = 0, nPosNum = 0;
	double dValue = 0;
	CString strPath, strInfo;
	CCoordPos pos;
	CCalibData				 calibData(*m_pPlatformInfo);		// 标定信息
	CCalibrateParam			*pCalibrateParam = NULL;			// 显式释放内存
	CCalibratedInfo			*pCalibratedInfo = NULL;			// 显式释放内存
	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;		// 显式释放内存
	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;		// 显式释放内存
	CPlatformAxisPos		*pCamAxisPlatformAxisPos = NULL;	// 显式释放内存


	CString strProductIndex;
	strProductIndex.Format(_T("%03d"), nIndex+1);
	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\JobCalibs\\") + strProductIndex + _T("\\JobCalib.xml");

	bLoad = m_XMLConfigator.Load(strPath);
	if (!bLoad)
	{
		goto LoadFailed;
	}
	if (!m_XMLConfigator.FindElem(_T("JobCalibConfig")))	// (Root)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem();  // 1级目录

	if (!m_XMLConfigator.FindElem(_T("CalibIndex")))			// (Level-1)产品索引号 
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	calibData.SetCalibIndex(nData);

	if (!m_XMLConfigator.FindElem(_T("CalibCustomName")))		// (Level-1)产品自定义名称
	{
		goto LoadFailed;
	}
	calibData.SetCalibUserName(CString(m_XMLConfigator.GetElemData()));

	if (!m_XMLConfigator.FindElem(_T("CalibMarkPatternMode")))		// (Level)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	calibData.SetCalibMarkPatternMode((CalibMarkPatternMode)nData);

	if (!m_XMLConfigator.FindElem(_T("CalibHomographyDOF")))		// (Level)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	calibData.SetCalibHomographyDOF((HomographyDOF)nData);

	if (!m_XMLConfigator.FindElem(_T("WholeCalibCacuPos")))		// (Level)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	calibData.SetWholeCalibCacuPos(nData);

	if (!m_XMLConfigator.FindElem(_T("WholeCalibCacuPosEnable")))		// (Level)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	calibData.SetWholeCalibCacuPosEnable((BOOL)nData);


	///////////////////////////////////////////////////////////////////////////
	// 标定参数信息
	pCalibrateParam = new CCalibrateParam;
	if (!m_XMLConfigator.FindElem(_T("CalibParam")))	// (Level-1)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem();  //2级目录

	nPosNum = m_pPlatformInfo->m_nPositionNum;
	for (i=0; i<nPosNum; i++)
	{
		strInfo.Format(_T("CalibParam%d"),i);
		if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //3级目录

		// 标定模板数量
		if (m_XMLConfigator.FindElem(_T("CalibPatNum")))
		{
			m_XMLConfigator.GetElemData(pCalibrateParam->m_nCalibPatternNum);				 
		}

		// 标定模板ID
		CString strInfo;
		if (m_XMLConfigator.FindElem(_T("CalibPatID")))
		{
			m_XMLConfigator.EnterElem();//4级目录打开

			CString strID;
			for (j=0; j<pCalibrateParam->m_nCalibPatternNum; j++)
			{
				strInfo.Format(_T("ID%d"),j);

				if (m_XMLConfigator.FindElem(strInfo))
				{
					strID = m_XMLConfigator.GetElemData();
					pCalibrateParam->m_vstrCalibPatternIDS.push_back(strID);
				}
			}

			m_XMLConfigator.LeaveElem();//4级目录关闭
		}		   

		// 平台坐标系标定时各轴运动控制量		  
		if (m_XMLConfigator.FindElem(_T("PlatMove")))
		{
			m_XMLConfigator.EnterElem();//4级目录打开

			// DX
			if (m_XMLConfigator.FindElem(_T("DX")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dPosX);
			}

			// DY
			if (m_XMLConfigator.FindElem(_T("DY")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dPosY);
			}

			// DD
			if (m_XMLConfigator.FindElem(_T("DD")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dAngle);
			}  

			m_XMLConfigator.LeaveElem();//4级目录关闭
		}

		// 相机单独控制时，XY轴运动控制量
		if (m_XMLConfigator.FindElem(_T("CamMove")))
		{
			m_XMLConfigator.EnterElem();//4级目录打开

			// DX
			if (m_XMLConfigator.FindElem(_T("DX")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_dCameraCalibMovement.m_dPosX);
			}

			// DY
			if (m_XMLConfigator.FindElem(_T("DY")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_dCameraCalibMovement.m_dPosY);
			}	   			 

			m_XMLConfigator.LeaveElem();//4级目录关闭
		}      

		// 平台标定是否求精
		if (m_XMLConfigator.FindElem(_T("PlatCalibRefine")))
		{
			m_XMLConfigator.GetElemData(pCalibrateParam->m_bPlatformCalibrateRefine);
		}	

		if (m_XMLConfigator.FindElem(_T("PlatCalibRefineTime")))
		{
			m_XMLConfigator.GetElemData(pCalibrateParam->m_nPlatformCalibRefineTime);
		}

		if (m_XMLConfigator.FindElem(_T("PlatCalibRefineMoveD")))
		{
			m_XMLConfigator.GetElemData(pCalibrateParam->m_dPlatformCalibRefineMoveD);
		}

		// 搜索延时
		if (m_XMLConfigator.FindElem(_T("SearchDelayTime")))
		{
			m_XMLConfigator.GetElemData(pCalibrateParam->m_nSearchDelayTime);
		}

		if (m_XMLConfigator.FindElem(_T("DistorCorrParam")))
		{
			m_XMLConfigator.EnterElem();//4级目录打开

			// TileX
			if (m_XMLConfigator.FindElem(_T("TileX")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_dTileX);
			}

			// TileY
			if (m_XMLConfigator.FindElem(_T("TileY")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_dTileY);
			}	   		

			// EnableOutPoints
			if (m_XMLConfigator.FindElem(_T("EnableOutPoints")))
			{
				int i = 0;
				m_XMLConfigator.GetElemData(i);
				pCalibrateParam->m_bOutPoints = (bool)i;
			}

			// Thre
			if (m_XMLConfigator.FindElem(_T("Thre")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_iThre);
			}	  

			// IsEnableDisCor
			if (m_XMLConfigator.FindElem(_T("IsEnableDisCor")))
			{
				m_XMLConfigator.GetElemData(pCalibrateParam->m_nEnableDisCor);
			}

			m_XMLConfigator.LeaveElem();//4级目录关闭
		}

		if (m_XMLConfigator.FindElem(_T("CalibMarkPatternMode")))
		{
			int nData;
			m_XMLConfigator.GetElemData(nData);
			pCalibrateParam->m_eCalibMarkPatternMode = (CalibMarkPatternMode)nData;
		}
		else
		{
			pCalibrateParam->m_eCalibMarkPatternMode = eTraditionalCalib;
		}

		m_XMLConfigator.LeaveElem(); //3级目录关闭

		if (calibData.m_vpCalibrateParam.at(i) != NULL)
		{
			delete calibData.m_vpCalibrateParam.at(i);
			calibData.m_vpCalibrateParam.at(i) = NULL;
		}
		calibData.m_vpCalibrateParam.at(i) = new CCalibrateParam(*pCalibrateParam);
	}
	m_XMLConfigator.LeaveElem();  //2级目录关闭


	//////////////////////////////////////////////////////////////////////////
	// 标定后参数（与平台相关）
	pCalibratedInfo = new CCalibratedInfo(m_pPlatformInfo->m_ePlatformType, m_pPlatformInfo->m_eCamPlatformType);
	pCalibPlatformAxisPos = new CPlatformXYDAxisPos;

	if (!m_XMLConfigator.FindElem(_T("CalibedResult")))	// (Level-1)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem();  //2级目录

	nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nExPosNum = 0;
	if (m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE)
	{
		nExPosNum = nPosNum + nPosNum*m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
	}
	else
	{
		nExPosNum = nPosNum;
	}

	//for (i=0; i<nPosNum; i++)
	for (i=0; i<nExPosNum; i++)
	{
		strInfo.Format(_T("CalibedResult%d"),i);

		if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //3级目录	

		if (!m_XMLConfigator.FindElem(_T("Valid")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_bValid);

		//  标定时，图像坐标系到平台坐标系之间的变换矩阵
		if (!m_XMLConfigator.FindElem(_T("PlatTM")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //4级目录

		// A00
		m_XMLConfigator.FindElem(_T("A00"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(0,0,dValue);

		// A01
		m_XMLConfigator.FindElem(_T("A01"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(0,1,dValue);

		// A10
		m_XMLConfigator.FindElem(_T("A10"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(1,0,dValue);

		// A11
		m_XMLConfigator.FindElem(_T("A11"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(1,1,dValue);

		m_XMLConfigator.LeaveElem();  //4级目录


		//  标定时，图像坐标系到平台坐标系之间的变换矩阵H
		if (m_XMLConfigator.FindElem(_T("PlatTMH")))
		{
			m_XMLConfigator.EnterElem();

			double h[9];
			int j = 0;
			for(j = 0; j < 9; j++)
			{
				h[j] = 0.0;
				strInfo.Format(_T("h%d"),j);
				m_XMLConfigator.FindElem(strInfo);
				m_XMLConfigator.GetElemData(dValue);
				h[j] = dValue;						
			}
			pCalibratedInfo->SetPlatformTransferH(h);

			m_XMLConfigator.LeaveElem();
		}
		else
		{
			goto LoadFailed;
		}

		//  全局靶标标定时，图像坐标系到靶标坐标系之间的变换矩阵H1
		if (m_XMLConfigator.FindElem(_T("PlatTMH1")))
		{
			m_XMLConfigator.EnterElem();

			double h1[9];
			int j = 0;
			for(j = 0; j < 9; j++)
			{
				h1[j] = 0.0;
				strInfo.Format(_T("h1%d"),j);
				m_XMLConfigator.FindElem(strInfo);
				m_XMLConfigator.GetElemData(dValue);
				h1[j] = dValue;						
			}
			pCalibratedInfo->SetPlatformTransferH1(h1);

			m_XMLConfigator.LeaveElem();
		}

		//  全局靶标标定时，靶标坐标系到平台坐标系之间的变换矩阵H2
		if (m_XMLConfigator.FindElem(_T("PlatTMH2")))
		{
			m_XMLConfigator.EnterElem();

			double h2[9];
			int j = 0;
			for(j = 0; j < 9; j++)
			{
				h2[j] = 0.0;
				strInfo.Format(_T("h2%d"),j);
				m_XMLConfigator.FindElem(strInfo);
				m_XMLConfigator.GetElemData(dValue);
				h2[j] = dValue;						
			}
			pCalibratedInfo->SetPlatformTransferH2(h2);

			m_XMLConfigator.LeaveElem();
		}

		//  畸变校正结果
		if (m_XMLConfigator.FindElem(_T("DistorCorrResult")))
		{
			m_XMLConfigator.EnterElem();

			double p[15];
			int j = 0;
			for(j = 0; j < 15; j++)
			{
				p[j] = 0.0;
				strInfo.Format(_T("p%d"),j);
				m_XMLConfigator.FindElem(strInfo);
				m_XMLConfigator.GetElemData(dValue);
				p[j] = dValue;						
			}
			pCalibratedInfo->m_result.SetNonlinearProjectResult(p);

			strInfo.Format(_T("RMS"),j);
			m_XMLConfigator.FindElem(strInfo);
			m_XMLConfigator.GetElemData(dValue);
			pCalibratedInfo->m_result.SetRMS(dValue);

			m_XMLConfigator.LeaveElem();
		}

		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffset")))	// (Level-3)
		{
			//goto LoadFailed;
			pCalibratedInfo->m_cpRefineOffset.m_dPosX = 0;
			pCalibratedInfo->m_cpRefineOffset.m_dPosY = 0;
		}
		else
		{
			m_XMLConfigator.EnterElem();  //4级目录

			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				//goto LoadFailed;
				pCalibratedInfo->m_cpRefineOffset.m_dPosX = 0;
			}
			else
			{
				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_dPosX);
			}


			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				//goto LoadFailed;
				pCalibratedInfo->m_cpRefineOffset.m_dPosY = 0;
			}
			else
			{
				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_dPosY);		
			}

			//if (GetProductCalibTargetMarkPatternMode(nIndex) == eSinglePatternGuanlian4Point)
			// 			{
			// 				for (int m=0;m<4;m++)
			// 				{
			// 					CString str;
			// 					str.Format("AuxiliaryPosX-%d",m);
			// 					if (m_XMLConfigator.FindElem(str))
			// 					{
			// 						m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_vdAuxiliaryPosX[m]);
			// 					}
			// 					str.Format("AuxiliaryPosY-%d",m);
			// 					if (m_XMLConfigator.FindElem(str))
			// 					{
			// 						m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_vdAuxiliaryPosY[m]);
			// 					}
			// 				}
			// 			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}

		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffsetH1")))	// (Level-3)
		{
			//goto LoadFailed;
			pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX = 0;
			pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY = 0;
		}
		else
		{
			m_XMLConfigator.EnterElem();  //4级目录

			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				//goto LoadFailed;
				pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX = 0;
			}
			else
			{
				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX);
			}


			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				//goto LoadFailed;
				pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY = 0;
			}
			else
			{
				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY);		
			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}

		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffsetH2")))	// (Level-3)
		{
			//goto LoadFailed;
			pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX = 0;
			pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY = 0;
		}
		else
		{
			m_XMLConfigator.EnterElem();  //4级目录

			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				//goto LoadFailed;
				pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX = 0;
			}
			else
			{
				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX);
			}


			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				//goto LoadFailed;
				pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY = 0;
			}
			else
			{
				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY);		
			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}
		// 标定时，基准Mark在平台坐标系的坐标值和姿态
		if (!m_XMLConfigator.FindElem(_T("MarkPlatCoord")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //4级目录
		// MarkPltCoordX
		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPos.m_dPosX);
		// MarkPltCoordY
		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPos.m_dPosY);		
		m_XMLConfigator.LeaveElem();  //4级目录

		// 标定时，基准Mark在图像坐标系中的位置
		if (!m_XMLConfigator.FindElem(_T("MarkImgCoord")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();	  //4级目录	
		// MarkImgCoordX
		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPos.m_dPosX);
		// MarkImgCoordY
		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPos.m_dPosY);
		m_XMLConfigator.LeaveElem();  //4级目录


		// 标定时，基准Mark在平台坐标系的坐标值和姿态
		if (m_XMLConfigator.FindElem(_T("MarkPlatCoordBat")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();  //4级目录
			// MarkPltCoordX
			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPosBat.m_dPosX);
			// MarkPltCoordY
			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPosBat.m_dPosY);		
			m_XMLConfigator.LeaveElem();  //4级目录;
		}


		// 标定时，基准Mark在图像坐标系中的位置
		if (m_XMLConfigator.FindElem(_T("MarkImgCoordBat")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录	
			// MarkImgCoordX
			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPosBat.m_dPosX);
			// MarkImgCoordY
			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPosBat.m_dPosY);
			m_XMLConfigator.LeaveElem();  //4级目录;
		}

		if (m_XMLConfigator.FindElem(_T("ObjectMarkImgCoord")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录	
			if (m_vpMarkImagePos.size()<CALIBMOVEPOSNUM)
			{
				m_vpMarkImagePos.resize(CALIBMOVEPOSNUM);
			}
			for (int m=0;m<CALIBMOVEPOSNUM;m++)
			{
				// MarkImgCoordX
				CString strName;
				strName.Format("X%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX);
				}
				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX);
				// MarkImgCoordY
				strName.Format("Y%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY);
				}
				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY);
				CCoordPos pos;
				pos.m_dPosX = pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX;
				pos.m_dPosY = pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY;


				if (m_vpMarkImagePos.at(m)!=NULL)
				{
					delete m_vpMarkImagePos.at(m);
					m_vpMarkImagePos.at(m) = NULL;
				}							
				CMarkImagePos * markpos = new CMarkImagePos();
				markpos->SetMarkImagePosNum(1);
				markpos->SetMarkImagePos(0,TRUE,pos);
				m_vpMarkImagePos.at(m)=markpos;
			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}


		if (m_XMLConfigator.FindElem(_T("TargetMarkImgCoord")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录	
			for (int m=0;m<CALIBMOVEPOSNUM;m++)
			{
				// MarkImgCoordX
				CString strName;
				strName.Format("X%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosX);
				}
				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosX);
				// MarkImgCoordY
				strName.Format("Y%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosY);
				}
				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosY);
			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}

		///////////////////////////////////////////////////////////////////////////////////////////////////////

		//用靶标关联映射时，标定板上的Mark位置图像坐标
		if (m_XMLConfigator.FindElem(_T("CalibBoardMarkImgCoordPos")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录	
			for (int m=0;m<CALIBBOARDMARKPOSNUM;m++)
			{
				// MarkImgCoordX
				CString strName;
				strName.Format("X%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].m_dPosX);
				}
				// MarkImgCoordY
				strName.Format("Y%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].m_dPosY);
				}
			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}


		//用靶标关联映射时，标定板上的Mark位置物理坐标
		if (m_XMLConfigator.FindElem(_T("CalibBoardMarkBoardCoordPos")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录	
			for (int m=0;m<CALIBBOARDMARKPOSNUM;m++)
			{
				// MarkImgCoordX
				CString strName;
				strName.Format("X%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].m_dPosX);
				}
				// MarkImgCoordY
				strName.Format("Y%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].m_dPosY);
				}
			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}


		//用靶标关联映射时，标定板尺寸
		if (m_XMLConfigator.FindElem(_T("CalibBoardSize")))
		{
			m_XMLConfigator.EnterElem();//4级目录打开
			// SizeX
			double dSizeX = 1.0;
			double dSizeY = 1.0;
			CString strName;
			strName.Format("SizeX");
			if (m_XMLConfigator.FindElem(strName))
			{
				m_XMLConfigator.GetElemData(dSizeX);
			}

			// SizeY
			strName.Format("SizeY");
			if (m_XMLConfigator.FindElem(strName))
			{
				m_XMLConfigator.GetElemData(dSizeY);
			}

			pCalibratedInfo->m_vCalibBoardSize = sc2Vector(dSizeX, dSizeY);
			m_XMLConfigator.LeaveElem();//4级目录关闭
		}



		// 标定时，基准位置处平台各个轴的位置
		if (!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();	//4级目录	
		if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dPosX);
		if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dPosY);
		if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dAngle);
		pCalibratedInfo->SetPlatformAxisPos(pCalibPlatformAxisPos);
		m_XMLConfigator.LeaveElem();   //4级目录

		// 标定时，图像坐标系与平台坐标系之间的角度
		if (!m_XMLConfigator.FindElem(_T("Anlge")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_dImageToPlatformAnlge);
		// 标定时，相机坐标系到平台坐标系之间的变换矩阵
		if (!m_XMLConfigator.FindElem(_T("CamTM")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //4级目录
		// A00
		m_XMLConfigator.FindElem(_T("A00"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_CameraTranferMatrix.SetElement(0,0,dValue);
		// A01
		m_XMLConfigator.FindElem(_T("A01"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_CameraTranferMatrix.SetElement(0,1,dValue);
		// A10
		m_XMLConfigator.FindElem(_T("A10"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_CameraTranferMatrix.SetElement(1,0,dValue);
		// A11
		m_XMLConfigator.FindElem(_T("A11"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_CameraTranferMatrix.SetElement(1,1,dValue);
		m_XMLConfigator.LeaveElem();   //4级目录

		// 标定时，基准位置处相机平台各个轴的位置（XY）
		if (!m_XMLConfigator.FindElem(_T("CamPlatAxisPos")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //4级目录
		if (!m_XMLConfigator.FindElem(_T("CamPlatType")))
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		if (((CamPlatformType)nData) != m_pPlatformInfo->m_eCamPlatformType)
		{
			goto LoadFailed;
		}

		switch((CamPlatformType)nData)
		{
		case eCamPlatformSepFix:
			break;
		case eCamPlatformSepX:
			pCamPlatformAxisPos = new CPlatformXYAxisPos;				
			// X轴位置
			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
			pCalibratedInfo->SetCamPlatformAxisPos(pCamPlatformAxisPos);
			break;
		case eCamPlatformSepXY:
			pCamPlatformAxisPos = new CPlatformXYAxisPos;			
			// X轴位置
			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
			// Y轴位置
			if (m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);
			}
			pCalibratedInfo->SetCamPlatformAxisPos(pCamPlatformAxisPos);
			break;
		case eCamPlatformShareX:
		default:
			goto LoadFailed;
		}
		m_XMLConfigator.LeaveElem();	// Leave CamPlatformAxisPos //4级目录

		if(m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))
		{
			m_XMLConfigator.EnterElem();
			switch((CamPlatformType)nData)
			{
			case eCamPlatformSepFix:
				break;
			case eCamPlatformSepX:
				pCamAxisPlatformAxisPos = new CPlatformXYAxisPos;				
				// X轴位置
				if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
				{
					goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosX);
				pCalibratedInfo->SetCamAxisPlatformAxisPos(pCamAxisPlatformAxisPos);
				break;
			case eCamPlatformSepXY:
				pCamAxisPlatformAxisPos = new CPlatformXYAxisPos;			
				// X轴位置
				if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
				{
					goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosX);
				// Y轴位置
				if (m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosY);
				}
				//pCalibratedInfo->SetCamAxisPlatformAxisPos(pCamPlatformAxisPos);
				pCalibratedInfo->SetCamAxisPlatformAxisPos(pCamAxisPlatformAxisPos); // 修复加载相机平台轴错误的BUG
				break;
			case eCamPlatformShareX:
			default:
				break;
			}
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();	// Leave CH%d //3级目录
		if (calibData.m_vpCalibratedInfo.at(i) != NULL)
		{
			delete calibData.m_vpCalibratedInfo.at(i);
			calibData.m_vpCalibratedInfo.at(i) = NULL;
		}
		calibData.m_vpCalibratedInfo.at(i) = new CCalibratedInfo(*pCalibratedInfo);
		if (pCamPlatformAxisPos != NULL)
		{
			delete pCamPlatformAxisPos;
			pCamPlatformAxisPos = NULL;
		}
		if (pCamAxisPlatformAxisPos != NULL)
		{
			delete pCamAxisPlatformAxisPos;
			pCamAxisPlatformAxisPos = NULL;
		}
	}   
	m_XMLConfigator.LeaveElem(); //2级目录
	m_XMLConfigator.LeaveElem();  //1级目录
	if (calibData.IsValid())
	{
		m_pVisionASMConfig->m_TotalCalibData.SetItemGrow(nIndex, calibData);
	}
	else
	{
		goto LoadFailed;
	}

	if (pCalibrateParam != NULL)
	{
		delete pCalibrateParam;
		pCalibrateParam = NULL;
	}

	if (pCalibratedInfo != NULL)
	{
		delete pCalibratedInfo;
		pCalibratedInfo = NULL;
	}
	if (pCalibPlatformAxisPos != NULL)
	{
		delete pCalibPlatformAxisPos;
		pCalibPlatformAxisPos = NULL;
	}
	if (pCamPlatformAxisPos != NULL)
	{
		delete pCamPlatformAxisPos;
		pCamPlatformAxisPos = NULL;
	}
	if (pCamAxisPlatformAxisPos != NULL)
	{
		delete pCamAxisPlatformAxisPos;
		pCamAxisPlatformAxisPos = NULL;
	}
	return TRUE;

	// 加载失败的资源释放
LoadFailed:
	{
		if (pCalibrateParam != NULL)
		{
			delete pCalibrateParam;
			pCalibrateParam = NULL;
		}

		if (pCalibratedInfo != NULL)
		{
			delete pCalibratedInfo;
			pCalibratedInfo = NULL;
		}
		if (pCalibPlatformAxisPos != NULL)
		{
			delete pCalibPlatformAxisPos;
			pCalibPlatformAxisPos = NULL;
		}
		if (pCamPlatformAxisPos != NULL)
		{
			delete pCamPlatformAxisPos;
			pCamPlatformAxisPos = NULL;
		}
		if (pCamAxisPlatformAxisPos != NULL)
		{
			delete pCamAxisPlatformAxisPos;
			pCamAxisPlatformAxisPos = NULL;
		}
		return FALSE;
	}
}

BOOL vcBaseVisionAlign::SaveCalibDataInfo(int nIndex)
{
	ASSERT(nIndex >= 0);
	ASSERT(m_pVisionASMConfig != NULL);
	ASSERT(nIndex < m_pVisionASMConfig->m_TotalCalibData.GetCount());
	ASSERT(m_pPlatformInfo != NULL);

	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalCalibData.GetCount()))
	{
		return FALSE;
	}
	if (m_pVisionASMConfig == NULL)
	{
		return FALSE;
	}
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	CString strInfo;
	double dValue = 0;
	int i = 0, j = 0, nData = 0;
	CCoordPos pos;
	sc2Matrix mat;

	CCalibData				calibData = m_pVisionASMConfig->m_TotalCalibData.GetItem(nIndex);
	CCalibrateParam			*pCalibrateParam = NULL;			// 显式释放内存
	CCalibratedInfo			*pCalibratedInfo = NULL;
	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;

	if ((calibData.m_vpCalibrateParam.size() <= 0) || (calibData.m_vpCalibratedInfo.size() <= 0))
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	m_XMLConfigator.AddElem(_T("JobCalibConfig"));	// (Root)
	m_XMLConfigator.EnterElem();

	m_XMLConfigator.AddElem(_T("CalibIndex"), calibData.GetCalibIndex());
	m_XMLConfigator.AddElem(_T("CalibCustomName"), calibData.GetCalibUserName());
	m_XMLConfigator.AddElem(_T("CalibMarkPatternMode"), calibData.GetCalibMarkPatternMode());
	m_XMLConfigator.AddElem(_T("CalibHomographyDOF"), calibData.GetCalibHomographyDOF());
	m_XMLConfigator.AddElem(_T("WholeCalibCacuPos"), calibData.GetWholeCalibCacuPos());
	m_XMLConfigator.AddElem(_T("WholeCalibCacuPosEnable"), (int)calibData.GetWholeCalibCacuPosEnable());

	m_XMLConfigator.AddElem(_T("CalibParam"));	// (Level-1) 标定参数
	m_XMLConfigator.EnterElem(); // 进入2级目录
	nData = calibData.m_vpCalibrateParam.size();
	for (i=0; i<nData; i++)
	{	
		pCalibrateParam = calibData.m_vpCalibrateParam.at(i);
		if (pCalibrateParam == NULL)
		{
			continue;
		}

		strInfo.Format(_T("CalibParam%d"), i);
		m_XMLConfigator.AddElem(strInfo); // (Level-2)
		m_XMLConfigator.EnterElem();//4级目录打开

		// 标定模板数量
		m_XMLConfigator.AddElem(_T("CalibPatNum"));		
		m_XMLConfigator.SetElemData(pCalibrateParam->m_nCalibPatternNum);	

		// 标定模板ID
		m_XMLConfigator.AddElem(_T("CalibPatID"));		
		m_XMLConfigator.EnterElem();		//4级目录打开	
		CString strID;
		for (j=0; j<pCalibrateParam->m_nCalibPatternNum; j++)
		{
			strInfo.Format(_T("ID%d"),j);

			m_XMLConfigator.AddElem(strInfo);
			m_XMLConfigator.SetElemData(pCalibrateParam->m_vstrCalibPatternIDS[j]);	

		}			
		m_XMLConfigator.LeaveElem();  //4级目录关闭


		// 平台坐标系标定时各轴运动控制量		  
		m_XMLConfigator.AddElem(_T("PlatMove"));	
		m_XMLConfigator.EnterElem();  //4级目录打开

		// DX
		m_XMLConfigator.AddElem(_T("DX"));	
		m_XMLConfigator.SetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dPosX);

		// DY
		m_XMLConfigator.AddElem(_T("DY"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dPosY);				

		// DD
		m_XMLConfigator.AddElem(_T("DD"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dAngle);			

		m_XMLConfigator.LeaveElem();  //4级目录关闭


		// 相机单独控制时，XY轴运动控制量
		m_XMLConfigator.AddElem(_T("CamMove"));		
		m_XMLConfigator.EnterElem(); //4级目录打开

		// DX
		m_XMLConfigator.AddElem(_T("DX"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_dCameraCalibMovement.m_dPosX);				

		// DY
		m_XMLConfigator.AddElem(_T("DY"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_dCameraCalibMovement.m_dPosY);			

		m_XMLConfigator.LeaveElem(); //退出XY轴运动控制量  //4级目录关闭

		// 平台标定是否求精
		m_XMLConfigator.AddElem(_T("PlatCalibRefine"));
		m_XMLConfigator.SetElemData(pCalibrateParam->m_bPlatformCalibrateRefine);	 

		m_XMLConfigator.AddElem(_T("PlatCalibRefineTime"));
		m_XMLConfigator.SetElemData(pCalibrateParam->m_nPlatformCalibRefineTime);	 

		m_XMLConfigator.AddElem(_T("PlatCalibRefineMoveD"));
		m_XMLConfigator.SetElemData(pCalibrateParam->m_dPlatformCalibRefineMoveD);	

		// 搜索延时
		m_XMLConfigator.AddElem(_T("SearchDelayTime"));
		m_XMLConfigator.SetElemData(pCalibrateParam->m_nSearchDelayTime);	


		// 畸形校正相关参数
		m_XMLConfigator.AddElem(_T("DistorCorrParam"));		
		m_XMLConfigator.EnterElem(); //4级目录打开

		// TileX
		m_XMLConfigator.AddElem(_T("TileX"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_dTileX);				

		// TileY
		m_XMLConfigator.AddElem(_T("TileY"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_dTileY);		

		// EnableOutPoints
		m_XMLConfigator.AddElem(_T("EnableOutPoints"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_bOutPoints);				

		// Thre
		m_XMLConfigator.AddElem(_T("Thre"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_iThre);	

		// IsEnableDisCor
		m_XMLConfigator.AddElem(_T("IsEnableDisCor"));				
		m_XMLConfigator.SetElemData(pCalibrateParam->m_nEnableDisCor);	

		m_XMLConfigator.LeaveElem(); //退出XY轴运动控制量  //4级目录关闭



		m_XMLConfigator.AddElem(_T("CalibMarkPatternMode"));
		m_XMLConfigator.SetElemData((CalibMarkPatternMode)pCalibrateParam->m_eCalibMarkPatternMode);	

		m_XMLConfigator.LeaveElem(); //退出标定参数访问  //3级目录关闭	
	}
	m_XMLConfigator.LeaveElem(); // 关闭2级目录


	// 标定后参数（与平台相关）
	m_XMLConfigator.AddElem(_T("CalibedResult"));	// (Level-1)
	m_XMLConfigator.EnterElem();
	nData = calibData.m_vpCalibratedInfo.size();
	for (i=0; i<nData; i++)
	{
		strInfo.Format(_T("CalibedResult%d"), i);
		m_XMLConfigator.AddElem(strInfo); // (Level-2)
		m_XMLConfigator.EnterElem();

		pCalibratedInfo = calibData.m_vpCalibratedInfo.at(i);
		m_XMLConfigator.AddElem(_T("Valid"));	
		m_XMLConfigator.SetElemData(pCalibratedInfo->m_bValid);

		//  标定时，图像坐标系到平台坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("PlatTM"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		mat = pCalibratedInfo->GetPlatformTransferMatrix();
		m_XMLConfigator.AddElem(_T("A00"), mat.GetElement(0, 0));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A01"), mat.GetElement(0, 1));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A10"), mat.GetElement(1, 0));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A11"), mat.GetElement(1, 1));	// (Level-4)
		m_XMLConfigator.LeaveElem();

		//  标定时，图像坐标系到平台坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("PlatTMH"));	
		m_XMLConfigator.EnterElem();  //4级目录打开
		{
			int j = 0;
			for(j = 0; j < 9; j++)
			{
				strInfo.Format(_T("h%d"), j);				
				m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH[j]);			
			}
		}
		m_XMLConfigator.LeaveElem(); //4级目录关闭

		//  全局靶标标定时，图像坐标系到靶标坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("PlatTMH1"));	
		m_XMLConfigator.EnterElem();  //4级目录打开
		{
			int j = 0;
			for(j = 0; j < 9; j++)
			{
				strInfo.Format(_T("h1%d"), j);				
				m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH1[j]);			
			}
		}
		m_XMLConfigator.LeaveElem(); //4级目录关闭

		//  全局靶标标定时，靶标坐标系到平台坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("PlatTMH2"));	
		m_XMLConfigator.EnterElem();  //4级目录打开
		{
			int j = 0;
			for(j = 0; j < 9; j++)
			{
				strInfo.Format(_T("h2%d"), j);				
				m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH2[j]);			
			}
		}
		m_XMLConfigator.LeaveElem(); //4级目录关闭

		//  畸变校正图像结果
		m_XMLConfigator.AddElem(_T("DistorCorrResult"));	
		m_XMLConfigator.EnterElem();  //4级目录打开
		{
			int j = 0;
			double dResult[15];
			pCalibratedInfo->m_result.GetNonlinearProjectResult(dResult);
			double dRMS = pCalibratedInfo->m_result.GetRMS();
			for(j = 0; j < 15; j++)
			{
				strInfo.Format(_T("p%d"), j);				
				m_XMLConfigator.AddElem(strInfo, dResult[j]);			
			}
			strInfo.Format(_T("RMS"));
			m_XMLConfigator.AddElem(strInfo, dRMS);		
		}
		m_XMLConfigator.LeaveElem(); //4级目录关闭


		m_XMLConfigator.AddElem(_T("PlatRefineOffset"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffset();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 
		//	if (GetProductCalibTargetMarkPatternMode(nIndex) == eSinglePatternGuanlian4Point)
		// 		{
		// 			for (int m=0;m<4;m++)
		// 			{
		// 				CString str;
		// 				str.Format("AuxiliaryPosX-%d",m);
		// 				m_XMLConfigator.AddElem(str,pos.GetAuxiliaryPosX(m));
		// 
		// 				str.Format("AuxiliaryPosY-%d",m);
		// 				m_XMLConfigator.AddElem(str,pos.GetAuxiliaryPosY(m));
		// 			}
		// 		}
		m_XMLConfigator.LeaveElem();

		m_XMLConfigator.AddElem(_T("PlatRefineOffsetH1"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffsetH1();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 
		m_XMLConfigator.LeaveElem();

		m_XMLConfigator.AddElem(_T("PlatRefineOffsetH2"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffsetH2();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 
		m_XMLConfigator.LeaveElem();

		// 标定时，基准Mark在平台坐标系的坐标值和姿态
		m_XMLConfigator.AddElem(_T("MarkPlatCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPos();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkPltCoordX
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkPltCoordY
		m_XMLConfigator.LeaveElem();

		// 标定时，基准Mark在图像坐标系中的位置
		m_XMLConfigator.AddElem(_T("MarkImgCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkImgCoordPos();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkImgCoordX
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkImgCoordY
		m_XMLConfigator.LeaveElem();


		// 标定时，基准Mark在平台坐标系的坐标值和姿态
		m_XMLConfigator.AddElem(_T("MarkPlatCoordBat"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPosBat();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkPltCoordX
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkPltCoordY
		m_XMLConfigator.LeaveElem();

		// 标定时，基准Mark在图像坐标系中的位置
		m_XMLConfigator.AddElem(_T("MarkImgCoordBat"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkImgCoordPosBat();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkImgCoordX
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkImgCoordY
		m_XMLConfigator.LeaveElem();


		// 标定时，基准Mark在图像坐标系中的位置
		m_XMLConfigator.AddElem(_T("ObjectMarkImgCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (int m =0;m<CALIBMOVEPOSNUM;m++)
		{
			CString strName;
			strName.Format("X%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
			strName.Format("Y%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
		}
		m_XMLConfigator.LeaveElem();

		// 标定时，基准Mark在图像坐标系中的位置
		m_XMLConfigator.AddElem(_T("TargetMarkImgCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (int m =0;m<CALIBMOVEPOSNUM;m++)
		{
			CString strName;
			strName.Format("X%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
			strName.Format("Y%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
		}
		m_XMLConfigator.LeaveElem();


		//用靶标关联映射时，标定板上的Mark位置图像坐标
		m_XMLConfigator.AddElem(_T("CalibBoardMarkImgCoordPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (int m =0;m<CALIBBOARDMARKPOSNUM;m++)
		{
			CString strName;
			strName.Format("X%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
			strName.Format("Y%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
		}
		m_XMLConfigator.LeaveElem();	

		//用靶标关联映射时，标定板上的Mark位置物理坐标
		m_XMLConfigator.AddElem(_T("CalibBoardMarkBoardCoordPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (int m =0;m<CALIBBOARDMARKPOSNUM;m++)
		{
			CString strName;
			strName.Format("X%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
			strName.Format("Y%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
		}
		m_XMLConfigator.LeaveElem();

		//用靶标关联映射时，标定板尺寸
		m_XMLConfigator.AddElem(_T("CalibBoardSize"));
		m_XMLConfigator.EnterElem();  //4级目录打开
		// SizeX
		CString strName;
		strName.Format("SizeX");
		m_XMLConfigator.AddElem(strName);					 
		m_XMLConfigator.SetElemData(pCalibratedInfo->m_vCalibBoardSize.GetX());
		// SizeY
		strName.Format("SizeY");
		m_XMLConfigator.AddElem(strName);					  
		m_XMLConfigator.SetElemData(pCalibratedInfo->m_vCalibBoardSize.GetY());
		m_XMLConfigator.LeaveElem();  //4级目录关闭


		// 标定时，基准位置处平台各个轴的位置
		m_XMLConfigator.AddElem(_T("PlatAxisPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pCalibPlatformAxisPos = (CPlatformXYDAxisPos*)pCalibratedInfo->GetPlatformAxisPos();
		m_XMLConfigator.AddElem(_T("X"), pCalibPlatformAxisPos->m_dPosX);		// (Level-4) 
		m_XMLConfigator.AddElem(_T("Y"), pCalibPlatformAxisPos->m_dPosY);		// (Level-4) 
		m_XMLConfigator.AddElem(_T("D"), pCalibPlatformAxisPos->m_dAngle);		// (Level-4)
		m_XMLConfigator.LeaveElem();

		// 标定时，图像坐标系与平台坐标系之间的角度
		m_XMLConfigator.AddElem(_T("Anlge"), pCalibratedInfo->m_dImageToPlatformAnlge);	// (Level-3)

		// 标定时，相机坐标系到平台坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("CamTM"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		mat = pCalibratedInfo->GetCamPlatformTransferMatrix();
		m_XMLConfigator.AddElem(_T("A00"), mat.GetElement(0, 0));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A01"), mat.GetElement(0, 1));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A10"), mat.GetElement(1, 0));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A11"), mat.GetElement(1, 1));	// (Level-4)
		m_XMLConfigator.LeaveElem();

		// 标定时，基准位置处相机平台各个轴的位置（XY）
		m_XMLConfigator.AddElem(_T("CamPlatAxisPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		CamPlatformType eType = m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformType();
		m_XMLConfigator.AddElem(_T("CamPlatType"), (int)eType);	// (Level-4)
		pCamPlatformAxisPos = pCalibratedInfo->GetCamPlatformAxisPos();
		if (pCamPlatformAxisPos != NULL)
		{
			switch (eType)
			{
			case eCamPlatformSepFix:
				break;
			case eCamPlatformSepX:
				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
				break;
			case eCamPlatformSepXY:
				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
				m_XMLConfigator.AddElem(_T("Y"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);	// (Level-4)
				break;
			case eCamPlatformShareX:
			default:
				break;
			}		
		}
		m_XMLConfigator.LeaveElem();	// Leave CamPlatformAxisPos

		// 相机轴所在的平台轴位置
		m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();

		pCamPlatformAxisPos = pCalibratedInfo->GetCamAxisPlatformAxisPos();
		if (pCamPlatformAxisPos != NULL)
		{
			switch (eType)
			{
			case eCamPlatformSepFix:
				break;
			case eCamPlatformSepX:
				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
				break;
			case eCamPlatformSepXY:
				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
				m_XMLConfigator.AddElem(_T("Y"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);	// (Level-4)
				break;
			case eCamPlatformShareX:
			default:
				break;
			}		
		}
		m_XMLConfigator.LeaveElem();	// Leave CamPlatformAxisPos


		m_XMLConfigator.LeaveElem();	// Leave CH%d
	}
	m_XMLConfigator.LeaveElem();
	m_XMLConfigator.LeaveElem();

	CString strName = m_pVisionASMConfig->m_TotalCalibData.GetItemName(nIndex);
	strName.Format(_T("%03d"),nIndex+1);
	if (strName.IsEmpty())	// 产品名称为空，不合法
	{
		return FALSE;
	}
	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\JobCalibs\\") + strName;

	// 创建产品保存文件夹
	DWORD dwAttributes = GetFileAttributes(strDir);
	if ((dwAttributes == 0xFFFFFFFF) || ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
	{	
		// 创建多级目录
		int nLen = 0;
		DWORD dwLevelXAttrib = 0;
		int nSlashIdx = strDir.Find('\\');
		CString strDirLevelX = _T("");
		CString strTemp = strDir;
		while (nSlashIdx != -1)
		{
			nLen = strDirLevelX.GetLength();
			nSlashIdx += (nLen == 0) ? 0 : (nLen + 1);
			strDirLevelX = strDir.Left(nSlashIdx);
			strTemp = strDir.Mid(nSlashIdx + 1);
			dwLevelXAttrib = GetFileAttributes(strDirLevelX);
			if ((dwLevelXAttrib == 0xFFFFFFFF) || ((dwLevelXAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0))
			{
				if (!CreateDirectory(strDirLevelX, NULL))
				{
					return FALSE;
				}
			}
			nSlashIdx = strTemp.Find('\\');
		}
		if (!CreateDirectory(strDir, NULL))
		{
			return FALSE;
		}
	}

	return m_XMLConfigator.Save(strDir + _T("\\JobCalib.xml"));
}

BOOL vcBaseVisionAlign::LoadProductDataInfo(int nIndex, LPCTSTR lpszProductName)
{
	ASSERT(nIndex >= 0);
	ASSERT(m_pPlatformInfo != NULL);
	CString strProductName = lpszProductName;

	if ((strProductName.IsEmpty()) || (nIndex < 0))
	{
		return FALSE;
	}
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	BOOL bLoad = FALSE;
	BSTR bstrName = NULL;
	int i = 0, j = 0, nData = 0, nPosNum = 0;
	double dValue = 0;
	CString strPath, strInfo, strCheckInfo;
	CCoordPos pos;
	CProductData				product(*m_pPlatformInfo);
	CAlignerParam				*pAlignerParam = NULL;				// 不显式释放内存
	CBenchTargetMarkFixInfo		*pBenchTargetMarkFixInfo = NULL;	// 显式释放内存
	CBenchTargetMarkPickInfo	*pBenchTargetMarkPickInfo = NULL;	// 显式释放内存
	CPlatformXYDAxisPos			*pPlatformAxisPos = NULL;			// 显式释放内存
	CCalibratedInfo				*pCalibratedInfo = NULL;			// 不显式释放内存
	CPlatformXYDAxisPos			*pCalibPlatformAxisPos = NULL;		// 显式释放内存
	CPlatformAxisPos			*pCamPlatformAxisPos = NULL;		// 显式释放内存
	CPlatformAxisPos			*pCamAxisPlatformAxisPos = NULL;		// 显式释放内存
	vector<CAlignCheckInfo>		alignCheckInfo;						// 对位检测信息
	CProductSizeInfo			productSizeInfo;					// 产品尺寸信息		//20160510增加对角补偿
	CProductPositionVirtualInfo	productPositionVirtualInfo;					//lzk 0405 位置虚拟

	CRobotTeachInfo				robotTeachInfo;						// 机器示教信息
	CProductOffsetInfo			productOffsetInfo;					// 补偿设置（补偿的方向、X和Y补偿值对调）
	CWeldInfo					WeldInfo;							// 焊接机参数设置
	//	CPCBInfo					PCBInfo;							// PCB参数设置
	scDMCodeParam				dmCodeParam;
	CBendInfo					BendInfo;							// 折弯参数设置


	CString strProductIndex;
	strProductIndex.Format(_T("%03d"), nIndex+1);
	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\Jobs\\") + strProductIndex + _T("\\Job.xml");
	bLoad = m_XMLConfigator.Load(strPath);
	if (!bLoad)
	{
		goto LoadFailed;
	}
	if (!m_XMLConfigator.FindElem(_T("JobConfig")))	// (Root)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem();  // 1级目录

	if (!m_XMLConfigator.FindElem(_T("AlignParam")))	// (Level-1) 对位信息
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem();   // 2级目录

	pAlignerParam = new CAlignerParam();

	if (!m_XMLConfigator.FindElem(_T("AlignIndex")))			// (Level-2)产品索引号 
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetProductIndex(nData);

	if (!m_XMLConfigator.FindElem(_T("AlignCustomName")))		// (Level-2)产品自定义名称
	{
		goto LoadFailed;
	}
	pAlignerParam->SetProductUserName(CString(m_XMLConfigator.GetElemData()));



	if (!m_XMLConfigator.FindElem(_T("AlignMaxTime")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAlignerMaxTime(nData);

	if (!m_XMLConfigator.FindElem(_T("AlignPrecision")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem(); // 3级目录
	if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-3)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(pos.m_dPosX);
	if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-3)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(pos.m_dPosY);
	if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-3)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(pos.m_dAngle);
	pAlignerParam->SetAlignerPrecision(pos);
	m_XMLConfigator.LeaveElem();  // 3级目录


	if (!m_XMLConfigator.FindElem(_T("SearchDelayTime")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetSearchDelayTime(nData);


	if (!m_XMLConfigator.FindElem(_T("ObjectSearchDelayTime")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetObjectSearchDelayTime(nData);

	if (!m_XMLConfigator.FindElem(_T("ObjectSearchDelayTime2")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetObjectSearchDelayTime2(nData);

	if (!m_XMLConfigator.FindElem(_T("EnableObjectSearchDelayTime2")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetEnableObjectSearchDelayTime2((BOOL)nData);


	// 补偿设置（补偿的方向、X和Y补偿值对调）
	if (m_XMLConfigator.FindElem(_T("ProductOffsetInfo")))		// (Level-2)
	{
		m_XMLConfigator.EnterElem();

		if (!m_XMLConfigator.FindElem(_T("EnableProductOffsetXDirection")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productOffsetInfo.m_bEnableProductOffsetXDirection = (bool)nData;

		if (!m_XMLConfigator.FindElem(_T("EnableProductOffsetYDirection")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productOffsetInfo.m_bEnableProductOffsetYDirection = (bool)nData;

		if (!m_XMLConfigator.FindElem(_T("EnableProductOffsetDDirection")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productOffsetInfo.m_bEnableProductOffsetDDirection = (bool)nData;



		if (!m_XMLConfigator.FindElem(_T("EnableProductOffsetXSetting")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productOffsetInfo.m_bEnableProductOffsetXSetting = (bool)nData;

		if (!m_XMLConfigator.FindElem(_T("EnableProductOffsetYSetting")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productOffsetInfo.m_bEnableProductOffsetYSetting = (bool)nData;

		if (!m_XMLConfigator.FindElem(_T("EnableProductOffsetDSetting")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productOffsetInfo.m_bEnableProductOffsetDSetting = (bool)nData;

		pAlignerParam->SetProductOffsetInfo(productOffsetInfo);
		m_XMLConfigator.LeaveElem();
	}
	else
	{
		goto LoadFailed;

		// 		CProductOffsetInfo TempProductOffsetInfo;	
		// 		pAlignerParam->SetProductOffsetInfo(TempProductOffsetInfo);
	}

	// 补偿类型：平台补偿、Mark补偿
	if (!m_XMLConfigator.FindElem(_T("AlignOffsetCoordType")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAlignerOffsetCoordType((AlignerOffsetCoordType)nData);

	// 对位基础补偿值
	if (m_XMLConfigator.FindElem(_T("AlignBaseOffset")))		// (Level-2)
	{
		m_XMLConfigator.EnterElem();  // 3级目录
		if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dPosX);

		if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dPosY);

		if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dAngle);

		pAlignerParam->SetAlignerBaseOffset(pos);
		m_XMLConfigator.LeaveElem();  // 3级目录
	}
	else
	{
		goto LoadFailed;

		// 		CCoordPos TempPos;
		// 		pAlignerParam->SetAlignerBaseOffset(TempPos);
	}


	// 对位补偿值
	int nAlignOffsetNum = ALIGNOFFSETNUM;
	pAlignerParam->SetAlignerOffsetNum(nAlignOffsetNum);
	for(int nAlignOffsetIndex = 0; nAlignOffsetIndex < nAlignOffsetNum; nAlignOffsetIndex++)
	{
		CString strElem;
		strElem.Format(_T("AlignOffset%d"), nAlignOffsetIndex);
		if (m_XMLConfigator.FindElem(strElem))		// (Level-2)
		{
			m_XMLConfigator.EnterElem();

			if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosX);

			if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosY);

			if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dAngle);
			pAlignerParam->SetAlignerOffset(nAlignOffsetIndex,pos);


			CString strTip;			
			if (!m_XMLConfigator.FindElem(_T("Tip")))		// (Level-3)
			{
				strTip.Format(_T("---"));
			}
			strTip = m_XMLConfigator.GetElemData();			
			pAlignerParam->SetAlignerOffsetTip(nAlignOffsetIndex,strTip);

			m_XMLConfigator.LeaveElem();
		}
		else
		{
			goto LoadFailed;

			// 			CCoordPos TempPos;
			// 			pAlignerParam->SetAlignerOffset(nAlignOffsetIndex, TempPos);
			// 
			// 			CString strTip;	
			// 			strTip.Format(_T("---"));
			// 			pAlignerParam->SetAlignerOffsetTip(nAlignOffsetIndex,strTip);
		}
	}

	// 多次对位，目标补偿
	if (!m_XMLConfigator.FindElem(_T("EnableAlnTargetOffset")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->EnableAlnTargetOffset((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("EnableAlnSendTargetOffsetToPLC")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->EnableAlnSendTargetOffsetToPLC((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("AlnTargetOffsetX")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(dValue);
	pAlignerParam->SetAlnTargetOffsetX(dValue);

	if (!m_XMLConfigator.FindElem(_T("AlnTargetOffsetY")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(dValue);
	pAlignerParam->SetAlnTargetOffsetY(dValue);

	// 下料补偿
	int nAlignBenchOffsetNum = ALIGNBENCHOFFSETNUM;
	pAlignerParam->SetAlignerBenchOffsetNum(nAlignBenchOffsetNum);
	for(int nAlignBenchOffsetIndex = 0; nAlignBenchOffsetIndex < nAlignBenchOffsetNum; nAlignBenchOffsetIndex++)
	{
		CString strElem;
		strElem.Format(_T("AlignBenchOffset%d"), nAlignBenchOffsetIndex);
		if (m_XMLConfigator.FindElem(strElem))		// (Level-2)
		{
			m_XMLConfigator.EnterElem();

			if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosX);

			if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosY);

			if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dAngle);

			pAlignerParam->SetAlignerBenchOffset(nAlignBenchOffsetIndex,pos);
			m_XMLConfigator.LeaveElem();
		}
		else
		{
			goto LoadFailed;

			// 			CCoordPos TempPos;
			// 			pAlignerParam->SetAlignerBenchOffset(nAlignBenchOffsetIndex,TempPos);
		}

	}




	// 输入模式、检查模式
	if (!m_XMLConfigator.FindElem(_T("AlignCheckInfo")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem();

	if (!m_XMLConfigator.FindElem(_T("MultiCalibExtensionMaxNum")))		// (Level-3)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetMultiCalibExtensionMaxNum(nData);



	int nCheckInfoNums = pAlignerParam->GetMultiCalibExtensionMaxNum() + 1; // 算上本身1个 + 扩展的个数 为总的检查参数个数
	alignCheckInfo.resize(nCheckInfoNums);

	for (int it = 0 ;it < nCheckInfoNums; it++)
	{
		strCheckInfo.Format(_T("CheckInfo_%d"),it);
		if (m_XMLConfigator.FindElem((LPCTSTR)strCheckInfo))		// (Level-3)
		{
			m_XMLConfigator.EnterElem();

			if (!m_XMLConfigator.FindElem(_T("CheckTargetAndObjectDis")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			alignCheckInfo.at(it).m_bCheckTargetAndObjectDis = (BOOL)nData;

			if (!m_XMLConfigator.FindElem(_T("CheckMode")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			alignCheckInfo.at(it).m_nCheckMode = nData;




			if (!m_XMLConfigator.FindElem(_T("CheckTargetDis")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			alignCheckInfo.at(it).m_bCheckTargetDis = (BOOL)nData;

			if (!m_XMLConfigator.FindElem(_T("TargetDisThreshold")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetDisThreshold = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetDis0")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetDis0 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetDis1")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetDis1 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetDis2")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetDis2 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetDis3")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetDis3 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetDis4")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetDis4 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetDis5")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetDis5 = dValue;



			if (!m_XMLConfigator.FindElem(_T("CheckObjectDis")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			alignCheckInfo.at(it).m_bCheckObjectDis = (BOOL)nData;

			if (!m_XMLConfigator.FindElem(_T("ObjectDisThreshold")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectDisThreshold = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectDis0")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectDis0 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectDis1")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectDis1 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectDis2")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectDis2 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectDis3")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectDis3 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectDis4")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectDis4 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectDis5")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectDis5 = dValue;



			if (!m_XMLConfigator.FindElem(_T("CheckTargetAngle")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			alignCheckInfo.at(it).m_bCheckTargetAngle = (BOOL)nData;

			if (!m_XMLConfigator.FindElem(_T("TargetAngleThreshold")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetAngleThreshold = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetAngle0")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetAngle0 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetAngle1")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetAngle1 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetAngle2")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetAngle2 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetAngle3")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetAngle3 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetAngle4")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetAngle4 = dValue;

			if (!m_XMLConfigator.FindElem(_T("TargetAngle5")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dTargetAngle5 = dValue;




			if (!m_XMLConfigator.FindElem(_T("CheckObjectAngle")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			alignCheckInfo.at(it).m_bCheckObjectAngle = (BOOL)nData;

			if (!m_XMLConfigator.FindElem(_T("ObjectAngleThreshold")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectAngleThreshold = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectAngle0")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectAngle0 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectAngle1")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectAngle1 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectAngle2")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectAngle2 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectAngle3")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectAngle3 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectAngle4")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectAngle4 = dValue;

			if (!m_XMLConfigator.FindElem(_T("ObjectAngle5")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			alignCheckInfo.at(it).m_dObjectAngle5 = dValue;

			m_XMLConfigator.LeaveElem();
		}
		else
		{
			goto LoadFailed;
		}
	}

	pAlignerParam->SetAlignCheckInfo(alignCheckInfo);
	m_XMLConfigator.LeaveElem();



	// 对位模式
	if (!m_XMLConfigator.FindElem(_T("Aligner2Vs2Type")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAligner2Vs2Type((Aligner2Vs2Type)nData);

	if (!m_XMLConfigator.FindElem(_T("Aligner3Vs3Type")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAligner3Vs3Type((Aligner3Vs3Type)nData);

	if (!m_XMLConfigator.FindElem(_T("Aligner4Vs4Type")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAligner4Vs4Type((Aligner4Vs4Type)nData);

	if (!m_XMLConfigator.FindElem(_T("Aligner5Vs5Type")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAligner5Vs5Type((Aligner5Vs5Type)nData);

	if (!m_XMLConfigator.FindElem(_T("Aligner6Vs6Type")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAligner6Vs6Type((Aligner6Vs6Type)nData);

	// 圆孔对位
	if (!m_XMLConfigator.FindElem(_T("AlignerWeight")))
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(dValue);
	pAlignerParam->SetAlignerWeight(dValue);

	if(!m_XMLConfigator.FindElem(_T("AlignerCirclePos")))
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAlignerCirclePos(nData);


	if (!m_XMLConfigator.FindElem(_T("AlignerMoveType")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAlignerMoveType((AlignerMoveType)nData);

	if (!m_XMLConfigator.FindElem(_T("AlignAngleVectical")))
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetEnableAlignAngleVectical((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("AlignAngleVecticalMode")))
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAlignAngleVecticalMode(nData);

	if (!m_XMLConfigator.FindElem(_T("AlignAccordingToPickPlatformEnable")))
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetAlignAccordingToPickPlatformEnable((BOOL)nData);


	// 对位偏差方向设置
	if (!m_XMLConfigator.FindElem(_T("AlnOffsetReverseX")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->EnableAlnOffsetReverseX((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("AlnOffsetReverseY")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->EnableAlnOffsetReverseY((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("AlnOffsetReverseD")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->EnableAlnOffsetReverseD((BOOL)nData);


	// 目标对象分属不同控制器，目标固定补偿功能
	if (!m_XMLConfigator.FindElem(_T("EnableAlnTargetFixOffset")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->EnableAlnTargetFixOffset((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("TargetFixOffsetType")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetTargetOffsetType(nData);


	for(int nOffsetIndex = 0; nOffsetIndex < ALIGNOFFSETNUM; nOffsetIndex++)
	{
		CString strElem;
		strElem.Format(_T("AlnTargetFixOffset%d"), nOffsetIndex);
		if (m_XMLConfigator.FindElem(strElem))
		{
			m_XMLConfigator.EnterElem();
			if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosX);

			if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosY);

			if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dAngle);

			pAlignerParam->SetAlnTargetFixOffset(nOffsetIndex,pos);
			m_XMLConfigator.LeaveElem();
		}
		else
		{
			goto LoadFailed;

			// 			CCoordPos TempPos;
			// 			pAlignerParam->SetAlnTargetFixOffset(nOffsetIndex, TempPos);

		}
	}

	// 对角Mark补偿方式
	if (!m_XMLConfigator.FindElem(_T("PositionModeInfo")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetPositionModeInfo(nData);


	// 目标、对象产品尺寸虚拟，对角Mark补偿，设置产品尺寸
	if (m_XMLConfigator.FindElem(_T("ProductSizeInfo")))		// (Level-2)
	{
		m_XMLConfigator.EnterElem();
		if (!m_XMLConfigator.FindElem(_T("ObjectL1")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		productSizeInfo.m_dObjectL1 = dValue;


		if (!m_XMLConfigator.FindElem(_T("ObjectW1")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		productSizeInfo.m_dObjectW1 = dValue;


		if (!m_XMLConfigator.FindElem(_T("TargetL2")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		productSizeInfo.m_dTargetL2 = dValue;

		if (!m_XMLConfigator.FindElem(_T("TargetW2")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		productSizeInfo.m_dTargetW2 = dValue;

		if (!m_XMLConfigator.FindElem(_T("OffsetXYEnable")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productSizeInfo.m_bOffsetXYEnable = nData;

		if (!m_XMLConfigator.FindElem(_T("OffsetF1")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		productSizeInfo.m_dF1 = dValue;

		if (!m_XMLConfigator.FindElem(_T("OffsetF2")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		productSizeInfo.m_dF2 = dValue;

		pAlignerParam->SetProductSizeInfo(productSizeInfo);
		m_XMLConfigator.LeaveElem();
	}
	else
	{
		goto LoadFailed;

		// 		CProductSizeInfo TempProductSizeInfo;
		// 		pAlignerParam->SetProductSizeInfo(TempProductSizeInfo);
	}


	// 目标、对象产品尺寸虚拟功能
	if (m_XMLConfigator.FindElem(_T("ProductPositionVirtualInfo")))		// (Level-2)
	{
		m_XMLConfigator.EnterElem();
		if (!m_XMLConfigator.FindElem(_T("EnableObjectPositionVirtualMode")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productPositionVirtualInfo.m_bEnableObjectPositionVirtualMode = nData;


		if (!m_XMLConfigator.FindElem(_T("EnableTargetPositionVirtualMode")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		productPositionVirtualInfo.m_bEnableTargetPositionVirtualMode = nData;


		if (!m_XMLConfigator.FindElem(_T("ObjectPositionVirtualMode")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		productPositionVirtualInfo.m_nObjectPositionVirtualMode = dValue;


		if (!m_XMLConfigator.FindElem(_T("TargetPositionVirtualMode")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		productPositionVirtualInfo.m_nTargetPositionVirtualMode = dValue;

		pAlignerParam->SetProductPositionVirtualInfo(productPositionVirtualInfo);
		m_XMLConfigator.LeaveElem();
	}
	else
	{
		goto LoadFailed;

		// 		CProductPositionVirtualInfo	TempProductPositionVirtualInfo;
		// 		pAlignerParam->SetProductPositionVirtualInfo(TempProductPositionVirtualInfo);
	}


	// 专用焊接参数
	if (m_XMLConfigator.FindElem(_T("WeldInfo")))		// (Level-2)
	{
		m_XMLConfigator.EnterElem();

		// 0.是否启用焊接参数
		if (!m_XMLConfigator.FindElem(_T("EnableWeld")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		WeldInfo.m_bEnableWeld = nData;

		// 1. 运动量系数
		if (!m_XMLConfigator.FindElem(_T("MovementRatioX")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		WeldInfo.m_WeldMovementRatio.m_dPosX = dValue;

		if (!m_XMLConfigator.FindElem(_T("MovementRatioY")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		WeldInfo.m_WeldMovementRatio.m_dPosY = dValue;

		if (!m_XMLConfigator.FindElem(_T("MovementRatioD")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		WeldInfo.m_WeldMovementRatio.m_dAngle = dValue;



		// 2. 补偿系数
		if (!m_XMLConfigator.FindElem(_T("AmmendRatioX")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		WeldInfo.m_WeldAmmendMovementRatio.m_dPosX = dValue;

		if (!m_XMLConfigator.FindElem(_T("AmmendRatioY")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		WeldInfo.m_WeldAmmendMovementRatio.m_dPosY = dValue;

		// 3. 目标多次定位/目标一次定位/目标零次定位
		if (!m_XMLConfigator.FindElem(_T("WeldTargetSearchTimes")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		WeldInfo.m_nWeldTargetSearchTimes = nData;


		// 4. 对象基准/目标基准/无基准
		if (!m_XMLConfigator.FindElem(_T("WeldSearchBench")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		WeldInfo.m_nWeldSearchBench = nData;


		// 5. 角度以对象为基准/角度以目标为基准/角度无基准
		if (!m_XMLConfigator.FindElem(_T("WeldAngleBench")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		WeldInfo.m_nWeldAngleBench = nData;

		pAlignerParam->SetWeldInfo(WeldInfo);
		m_XMLConfigator.LeaveElem();
	}
	else
	{
		goto LoadFailed;

		// 		CWeldInfo TempWeldInfo;
		// 		pAlignerParam->SetWeldInfo(TempWeldInfo);
	}


	// 八字对位
	if (!m_XMLConfigator.FindElem(_T("EnableEightShapeAlign")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->EnableEightShapeAlign((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("EightShapeAlignMode")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetEightShapeAlignMode((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("EightShapeAngle")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(dValue);
	pAlignerParam->SetEightShapeAngle(dValue);


	// 折弯参数
	if (m_XMLConfigator.FindElem(_T("BendInfo")))		// (Level-2)
	{
		m_XMLConfigator.EnterElem();

		// 折弯对位参数
		if (m_XMLConfigator.FindElem(_T("AlignBendInfo")))
		{
			m_XMLConfigator.EnterElem();

			if (!m_XMLConfigator.FindElem(_T("EnableBendInspect")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendAlignInspect = nData;

			// 1
			if (!m_XMLConfigator.FindElem(_T("BendType")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendType = nData;

			if (!m_XMLConfigator.FindElem(_T("BendImageRadio")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_dBendImageRadio = dValue;

			if (!m_XMLConfigator.FindElem(_T("BendAlignDmCode")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendAlignDmCode = nData;
			// 2
			if (!m_XMLConfigator.FindElem(_T("BendDisOffset")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendDisOffset = nData;

			if (!m_XMLConfigator.FindElem(_T("BendTargetDisOffset")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_dBendTargetDisOffset = dValue;

			if (!m_XMLConfigator.FindElem(_T("BendObjectDisOffset")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_dBendObjectDisOffset = dValue;

			// 3
			if (!m_XMLConfigator.FindElem(_T("BendResultOffset")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendResultOffset = nData;

			if (!m_XMLConfigator.FindElem(_T("BendLeftDisOffsetX")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_scBendLeftDisOffset.SetX(dValue);

			if (!m_XMLConfigator.FindElem(_T("BendLeftDisOffsetY")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_scBendLeftDisOffset.SetY(dValue);

			if (!m_XMLConfigator.FindElem(_T("LeftDisOffset")))		// (Level-3)
			{
				//goto LoadFailed;
				dValue = 0;
			}
			else
			{
				m_XMLConfigator.GetElemData(dValue);
			}
			BendInfo.m_dLeftDisOffset = dValue;

			if (!m_XMLConfigator.FindElem(_T("BendRightDisOffsetX")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_scBendRightDisOffset.SetX(dValue);

			if (!m_XMLConfigator.FindElem(_T("BendRightDisOffsetY")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_scBendRightDisOffset.SetY(dValue);

			if (!m_XMLConfigator.FindElem(_T("RightDisOffset")))		// (Level-3)
			{
				//goto LoadFailed;
				dValue = 0;
			}
			else
			{
				m_XMLConfigator.GetElemData(dValue);
			}	
			BendInfo.m_dRightDisOffset = dValue;

			// 4
			if (!m_XMLConfigator.FindElem(_T("BendThreOffset")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendThreOffset = nData;		//  m_bEnableFbsLRY

			// 4
			if (!m_XMLConfigator.FindElem(_T("BendEnableFbsLRY")))		// (Level-3)
			{
				nData = FALSE;
			}
			else
			{
			   m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_bEnableFbsLRY = nData;		//  m_bEnableFbsLRY
				
			if (!m_XMLConfigator.FindElem(_T("BendStanderThreX")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_scBendStanderThre.SetX(dValue);

			if (!m_XMLConfigator.FindElem(_T("BendStanderThreY")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_scBendStanderThre.SetY(dValue);


			// 5
			if (!m_XMLConfigator.FindElem(_T("BendPressPara")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendPressPara = nData;

			//m_bBendPressParaWrite;
			nData = 0;
			if (m_XMLConfigator.FindElem(_T("BendPressParaWrite")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_bBendPressParaWrite = (BOOL)nData;

			//m_lBendPressParaWriteAddre;
			nData = 10000;
			if (m_XMLConfigator.FindElem(_T("BendPressParaWriteAddre")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_lBendPressParaWriteAddre = nData;

			if (!m_XMLConfigator.FindElem(_T("BendPressOKYmin")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_dBendPressOKYmin = dValue;

			if (!m_XMLConfigator.FindElem(_T("BendPressOKYmax")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_dBendPressOKYmax = dValue;


			if (!m_XMLConfigator.FindElem(_T("BendPressNGYmin")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_dBendPressNGYmin = dValue;

			if (!m_XMLConfigator.FindElem(_T("BendPressNGYmax")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_dBendPressNGYmax = dValue;

			// 6
			if (!m_XMLConfigator.FindElem(_T("BendLoadThre")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendLoadThre = nData;

			if (!m_XMLConfigator.FindElem(_T("BendLoadThreX")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_scBendLoadThre.SetX(dValue);

			if (!m_XMLConfigator.FindElem(_T("BendLoadThreY")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_scBendLoadThre.SetY(dValue);

			// 7
			if (!m_XMLConfigator.FindElem(_T("BendingInspect")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendingInspect = nData;


			// 8
			if (!m_XMLConfigator.FindElem(_T("BendingProductID")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendingProductID = nData;

			if (!m_XMLConfigator.FindElem(_T("BendInspectDmCode")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(nData);
			BendInfo.m_bBendInspectDmCode = nData;

			nData = 0;
			if (m_XMLConfigator.FindElem(_T("EnableReadWsInfo")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_bEnableReadWsInfo = (BOOL)nData;

			nData = 0;
			if (m_XMLConfigator.FindElem(_T("EnableReadInspectWsInfo")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_bEnableReadInspectWsInfo = (BOOL)nData;

			nData = 0;
			if (m_XMLConfigator.FindElem(_T("EnableReadStartTimeInfo")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_bEnableReadStartTimeInfo = (BOOL)nData;

			nData = 0;
			if (m_XMLConfigator.FindElem(_T("EnableReadEndTimeInfo")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_bEnableReadEndTimeInfo = (BOOL)nData;

			nData = 0;
			if (m_XMLConfigator.FindElem(_T("EnableReadProsessingTimeInfo")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_bEnableReadProsessingTimeInfo = (BOOL)nData;

			//BOOL m_bEnableUseMathCaluLRDis;
			nData = 0;
			if (m_XMLConfigator.FindElem(_T("EnableUseMathCaluLRDis")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
			}
			BendInfo.m_bEnableUseMathCaluLRDis = (BOOL)nData;

			if (m_XMLConfigator.FindElem(_T("BendingEnableMoveSnap")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
				BendInfo.m_bEnableMoveSnap = nData;
			}
			if (m_XMLConfigator.FindElem(_T("BendingPosIndexFisrt")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
				BendInfo.m_nPosIndexFisrt = nData;
			}


			if (m_XMLConfigator.FindElem(_T("EnableAxisMoveLimit")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
				BendInfo.m_bEnableAxisMoveLimit = nData;
			}

			if (m_XMLConfigator.FindElem(_T("AxisAllowMoveMaxX")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dAxisAllowMoveMaxX = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("AxisAllowMoveMaxY")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dAxisAllowMoveMaxY = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("AxisAllowMoveMaxD")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dAxisAllowMoveMaxD = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("BendInspectSnCodeInvert")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
				BendInfo.m_bBendInspectSnCodeInvert = nData;
			}
			if (m_XMLConfigator.FindElem(_T("BendInspectSnCodeLength")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
				BendInfo.m_bBendInspectSnCodeLength = nData;
			}
			if (m_XMLConfigator.FindElem(_T("BendInspectGetSnOnce")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
				BendInfo.m_bBendInspectGetSnOnce = nData;
			}

			if (m_XMLConfigator.FindElem(_T("strPlatformName1")))		// (Level-3)
			{				
				BendInfo.m_strPlatformName1 = m_XMLConfigator.GetElemData();
			}
			if (m_XMLConfigator.FindElem(_T("strPlatformName2")))		// (Level-3)
			{				
				BendInfo.m_strPlatformName2 = m_XMLConfigator.GetElemData();
			}
			if (m_XMLConfigator.FindElem(_T("EnableFbisTarObc")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(nData);
				BendInfo.m_bEnableFbisTarObc = (BOOL)nData;
			}

			//腾盛让加的 
			if (m_XMLConfigator.FindElem(_T("BendSendszGetName")))		// (Level-3)
			{
				
				BendInfo.m_dBendSendszGetName = m_XMLConfigator.GetElemData();
			}

			if (m_XMLConfigator.FindElem(_T("BendSendAdsorptionSite")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dBendSendAdsorptionSite = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("BendSendRAngle")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dBendSendRAngle = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("BendSendCompensateY1")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dBendSendCompensateY1 = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("BendSendCompensateY2")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dBendSendCompensateY2 = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("BendSendCompensateY3")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dBendSendCompensateY3 = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("BendSendCompensateZ1")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dBendSendCompensateZ1 = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("BendSendCompensateZ2")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dBendSendCompensateZ2 = dValue;
			}
			if (m_XMLConfigator.FindElem(_T("BendSendCompensateZ3")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_dBendSendCompensateZ3 = dValue;
			}

			m_XMLConfigator.LeaveElem();

		}
		else
		{
			goto LoadFailed;
		}

		// 折弯检测标准
		if (m_XMLConfigator.FindElem(_T("BendInspectBaseInfo")))
		{
			m_XMLConfigator.EnterElem();

			// BaseX
			if (!m_XMLConfigator.FindElem(_T("BaseLX")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLX[0] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseLXLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLX[1] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseLXHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLX[2] = dValue;



			// BaseY
			if (!m_XMLConfigator.FindElem(_T("BaseLY")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLY[0] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseLYLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLY[1] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseLYHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLY[2] = dValue;



			// BaseLDis
			if (!m_XMLConfigator.FindElem(_T("BaseLDis")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[0] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseLDisLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[1] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseLDisHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[2] = dValue;








			// BaseRX
			if (!m_XMLConfigator.FindElem(_T("BaseRX")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRX[0] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseRXLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRX[1] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseRXHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRX[2] = dValue;


			// BaseRY
			if (!m_XMLConfigator.FindElem(_T("BaseRY")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRY[0] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseRYLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRY[1] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseRYHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRY[2] = dValue;


			// BaseRDis
			if (!m_XMLConfigator.FindElem(_T("BaseRDis")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[0] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseRDisLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[1] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseRDisHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[2] = dValue;




			// BaseTargetDis
			if (!m_XMLConfigator.FindElem(_T("BaseTargetDis")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[0] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseTargetDisLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[1] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseTargetDisHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[2] = dValue;


			// BaseObjectDis
			if (!m_XMLConfigator.FindElem(_T("BaseObjectDis")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[0] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseObjectDisLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[1] = dValue;

			if (!m_XMLConfigator.FindElem(_T("BaseObjectDisHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[2] = dValue;

			// BaseSubtractX
			if (!m_XMLConfigator.FindElem(_T("BaseSubtractX")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[0] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseSubtractXLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[1] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseSubtractXHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[2] = dValue;


			// BaseSubtractY
			if (!m_XMLConfigator.FindElem(_T("BaseSubtractY")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[0] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseSubtractYLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[1] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseSubtractYHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[2] = dValue;

			//m_dDeltaY
			if (m_XMLConfigator.FindElem(_T("BaseDeltaY")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_BendInspectRangeInfo.m_dDeltaY[0] = dValue;
			}

			if (m_XMLConfigator.FindElem(_T("BaseDeltaYLow")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_BendInspectRangeInfo.m_dDeltaY[1] = dValue;
			}

			if (m_XMLConfigator.FindElem(_T("BaseDeltaYHigh")))		// (Level-3)
			{
				m_XMLConfigator.GetElemData(dValue);
				BendInfo.m_BendInspectRangeInfo.m_dDeltaY[2] = dValue;
			}
			

			m_XMLConfigator.LeaveElem();
		}
		else
		{
			goto LoadFailed;
		}

		// 圆孔检测标准
		if (m_XMLConfigator.FindElem(_T("CircleInspectBaseInfo")))
		{
			m_XMLConfigator.EnterElem();

			// BaseCircleRadius
			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadius")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[0] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadiusLow")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[1] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadiusHigh")))		// (Level-3)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dValue);
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[2] = dValue;




			// BaseCircleRadiusX
			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadiusX")))		// (Level-3)
			{
				dValue =0.1;
			}
			else
			{
			  m_XMLConfigator.GetElemData(dValue);
			}
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[0] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadiusLowX")))		// (Level-3)
			{
				dValue =0.1;
			}
			else
			{
				m_XMLConfigator.GetElemData(dValue);
			}
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[1] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadiusHighX")))		// (Level-3)
			{
				dValue =0.1;
			}
			else
			{
				m_XMLConfigator.GetElemData(dValue);
			}
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[2] = dValue;





			// BaseCircleRadiusY
			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadiusY")))		// (Level-3)
			{
				dValue =0.1;
			}
			else
			{
				m_XMLConfigator.GetElemData(dValue);
			}
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[0] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadiusLowY")))		// (Level-3)
			{
				dValue =0.1;
			}
			else
			{
				m_XMLConfigator.GetElemData(dValue);
			}
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[1] = dValue;


			if (!m_XMLConfigator.FindElem(_T("BaseCircleRadiusHighY")))		// (Level-3)
			{
				dValue =0.1;
			}
			else
			{
				m_XMLConfigator.GetElemData(dValue);
			}
			BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[2] = dValue;

			m_XMLConfigator.LeaveElem();
		}
		else
		{
			goto LoadFailed;
		}


		pAlignerParam->SetBendInfo(BendInfo);
		m_XMLConfigator.LeaveElem();
	}
	else
	{
		goto LoadFailed;

		// 		CBendInfo TempBendInfo;
		// 		pAlignerParam->SetBendInfo(TempBendInfo);
	}



	// 拾取功能
	if (m_XMLConfigator.FindElem(_T("BenchTargetMarkPickInfo")))		// (Level-2)
	{
		m_XMLConfigator.EnterElem();  
		int nPosNum = m_pPlatformInfo->m_nPositionNum;
		if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
		{
			nPosNum = m_pPlatformInfo->m_nPositionNum*(m_pPlatformInfo->m_nMultiCalibExtensionMaxNum+1);
		}
		nData = nPosNum;

		pBenchTargetMarkPickInfo = new CBenchTargetMarkPickInfo(nData, m_pPlatformInfo->m_ePlatformType);
		pBenchTargetMarkPickInfo->SetMarkNum(nData);
		if (!m_XMLConfigator.FindElem(_T("FiducialTargetImgCoord")))	// (Level-3)
		{
			goto LoadFailed;
		}

		// 1
		m_XMLConfigator.EnterElem();
		CString strIdx;
		for (i=0; i<nData; i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strIdx.Format(_T("Mark%d_%d"),m, i);
				if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
				{
					m_XMLConfigator.AddElem(strIdx);
					//goto LoadFailed;
				}

				m_XMLConfigator.EnterElem();
				if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-5)
				{
					m_XMLConfigator.AddElem(_T("X"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dPosX);

				if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-5)
				{
					m_XMLConfigator.AddElem(_T("Y"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dPosY);

				if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-5)
				{
					m_XMLConfigator.AddElem(_T("D"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dAngle);		

				pBenchTargetMarkPickInfo->SetMarkImageCoordPos(i, pos, m);
				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();

		// 2
		if (!m_XMLConfigator.FindElem(_T("FiducialTargetPlatCoord")))	// (Level-3)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		for (i=0; i<nData; i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strIdx.Format(_T("Mark%d_%d"),m,i);
				if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
				{
					m_XMLConfigator.AddElem(strIdx);
					//goto LoadFailed;
				}

				m_XMLConfigator.EnterElem();
				if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-5)
				{
					m_XMLConfigator.AddElem(_T("X"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dPosX);

				if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-5)
				{
					m_XMLConfigator.AddElem(_T("Y"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dPosY);

				if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-5)
				{
					m_XMLConfigator.AddElem(_T("D"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dAngle);

				pBenchTargetMarkPickInfo->SetMarkPlatformCoordPos(i, pos, m);
				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();

		// 3
		if (!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-3)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		pPlatformAxisPos = new CPlatformXYDAxisPos();
		for (i=0;i<nData;i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strIdx.Format("PlatAxisPos%d_%d",m,i);
				if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
				{
					m_XMLConfigator.AddElem(strIdx);
					//goto LoadFailed;
				}
				m_XMLConfigator.EnterElem();

				if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("PlatType"),0);
					//goto LoadFailed;
				}
				int temp=0;
				m_XMLConfigator.GetElemData(temp);

				if ( ((PlatformType)temp) != m_pPlatformInfo->m_ePlatformType )	// PlatformType check
				{
					goto LoadFailed;
				}

				if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("X"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dPosX);

				if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("Y"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dPosY);

				if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("D"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dAngle);

				pBenchTargetMarkPickInfo->SetFixPlatformPos(i,pPlatformAxisPos,m);

				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();	

		// 4
		if (!m_XMLConfigator.FindElem(_T("PickPlatAxisPos")))	// (Level-3)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		for (i=0;i<nData;i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strIdx.Format("PlatAxisPos%d_%d",m,i);
				if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
				{
					m_XMLConfigator.AddElem(strIdx);
					//goto LoadFailed;
				}
				m_XMLConfigator.EnterElem();

				if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("PlatType"),0);
					//goto LoadFailed;
				}
				int temp=0;
				m_XMLConfigator.GetElemData(temp);

				if ( ((PlatformType)temp) != m_pPlatformInfo->m_ePlatformType )	// PlatformType check
				{
					goto LoadFailed;
				}

				if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("X"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dPosX);

				if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("Y"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dPosY);

				if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("D"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dAngle);

				pBenchTargetMarkPickInfo->SetPickPlatformPos(i,pPlatformAxisPos,m);

				m_XMLConfigator.LeaveElem();
			}

		}
		m_XMLConfigator.LeaveElem();	

		// 5
		if (!m_XMLConfigator.FindElem(_T("BenchPickPlatformOffset")))	// (Level-3)
		{
			m_XMLConfigator.AddElem(_T("BenchPickPlatformOffset"));
		}

		m_XMLConfigator.EnterElem();
		for (i=0;i<nData;i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strIdx.Format("BenchPickPlatformOffset%d_%d",m,i);
				if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
				{
					m_XMLConfigator.AddElem(strIdx);
					//goto LoadFailed;
				}
				m_XMLConfigator.EnterElem();

				if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("X"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dPosX);

				if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("Y"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dPosY);

				if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-4)
				{
					m_XMLConfigator.AddElem(_T("D"),0);
					//goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(pos.m_dAngle);

				pBenchTargetMarkPickInfo->SetPickPlatformOffset(i,pos,m);

				m_XMLConfigator.LeaveElem();

			}
		}
		m_XMLConfigator.LeaveElem();	


		// 6
		if (!m_XMLConfigator.FindElem(_T("CamPlatAxisPos")))	// (Level-3) BenchFixCamPlatformPos
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		if (!m_XMLConfigator.FindElem(_T("CamPlatType")))	// (Level-4)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(nData);
		if ( ((CamPlatformType)nData) != m_pPlatformInfo->m_eCamPlatformType )	// PlatformType check
		{
			goto LoadFailed;
		}
		if (((CamPlatformType)nData != eCamPlatformSepFix) && ((CamPlatformType)nData != eCamPlatformUnknown))
		{
			pCamPlatformAxisPos = new CPlatformXYAxisPos();
			for (i=0; i<nData; i++)
			{
				strIdx.Format(_T("Pos%d"), i);
				if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
				{
					goto LoadFailed;
				}

				m_XMLConfigator.EnterElem();
				if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-5)
				{
					goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
				if ((CamPlatformType)nData == eCamPlatformSepXY)
				{
					if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-5)
					{
						goto LoadFailed;
					}
					m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);
				}
				pBenchTargetMarkPickInfo->SetFixCamPlatformPos(i, pCamPlatformAxisPos);
				m_XMLConfigator.LeaveElem();

			}

			if (pCamPlatformAxisPos != NULL)
			{
				delete pCamPlatformAxisPos;
				pCamPlatformAxisPos = NULL;
			}
		}
		m_XMLConfigator.LeaveElem();

		// 7
		if (!m_XMLConfigator.FindElem(_T("Valid")))	// (Level-3) IsValid
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		pBenchTargetMarkPickInfo->Validate((BOOL)nData);	


		pAlignerParam->SetBenchTargetMarkPickInfo(pBenchTargetMarkPickInfo);
		m_XMLConfigator.LeaveElem();

	}

	// 分区域补偿功能
	if (m_XMLConfigator.FindElem(_T("AlignOffsetByArea")))		// (level-2)
	{
		m_XMLConfigator.EnterElem();

		if (!m_XMLConfigator.FindElem(_T("Enable")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(nData);
		pAlignerParam->m_AlignOffsetByArea.m_bEnable = (BOOL)nData;


		if (!m_XMLConfigator.FindElem(_T("AreaRowNum")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(nData);
		pAlignerParam->m_AlignOffsetByArea.m_nAreaRow = nData;

		if (!m_XMLConfigator.FindElem(_T("AreaColNum")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(nData);
		pAlignerParam->m_AlignOffsetByArea.m_nAreaCol = nData;

		if (!m_XMLConfigator.FindElem(_T("SearchStartX")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(dValue);
		pAlignerParam->m_AlignOffsetByArea.m_dSearchStartX = dValue;

		if (!m_XMLConfigator.FindElem(_T("SearchStartY")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(dValue);
		pAlignerParam->m_AlignOffsetByArea.m_dSearchStartY = dValue;

		if (!m_XMLConfigator.FindElem(_T("SearchWidth")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(dValue);
		pAlignerParam->m_AlignOffsetByArea.m_dSearchWidth = dValue;

		if (!m_XMLConfigator.FindElem(_T("SearchHeight")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(dValue);
		pAlignerParam->m_AlignOffsetByArea.m_dSearchHeight = dValue;

		if (!m_XMLConfigator.FindElem(_T("SearchType")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.GetElemData(nData);
		pAlignerParam->m_AlignOffsetByArea.m_nSearchType = nData;

		m_XMLConfigator.LeaveElem();	//AlignOffsetByArea

	}

	//指令光源控制参数
	if (m_XMLConfigator.FindElem(_T("CMDLightCtrlInfo")))		// (level-2)
	{
		m_XMLConfigator.EnterElem();

		PhotoLightCtrlSet cObj;
		for (int i =0;i < cObj.m_nCmdSum;++i) //指令流程
		{
			CurCMDPhotoLightCtrlSet cChild;
			if (m_XMLConfigator.FindElem(cObj.m_vCmd[i]))
			{
				m_XMLConfigator.EnterElem();

				for (int j =0;j < 8;++j) //控制器
				{
					CString str;
					str.Format(_T("LightCtrl%d"),j+1);
					if (m_XMLConfigator.FindElem(str))
					{
						m_XMLConfigator.EnterElem();
						if (m_XMLConfigator.FindElem(_T("CtrlEnable"))) //是否启用
						{
							m_XMLConfigator.GetElemData(nData);
							cChild.m_vCmdLightCtrlEnable[j] = (BOOL)nData;
						}
						std::vector<BOOL> vChannelCtrlIndex;
						std::vector<BOOL> vChannelOnorOff;
						for (int k =0;k < 8;++k) //通道
						{
							nData = 0;
							str.Format(_T("Channel%d"),k+1); //通道启用
							if (m_XMLConfigator.FindElem(str))
							{
								m_XMLConfigator.GetElemData(nData);	
							}
							vChannelCtrlIndex.push_back((BOOL)nData);

							nData = 1;
							str.Format(_T("Channel%dOnOrOff"),k+1);//通道亮灭
							if (m_XMLConfigator.FindElem(str))
							{
								m_XMLConfigator.GetElemData(nData);
							}
							vChannelOnorOff.push_back((BOOL)nData);
						}
						cChild.m_vbChannelCtrlIndex[j] = vChannelCtrlIndex;
						cChild.m_vbChannelOnorOff[j] = vChannelOnorOff;

						m_XMLConfigator.LeaveElem();
					}
				}
				cObj.m_vCmdLightCtrlInfo[i] = cChild;

				m_XMLConfigator.LeaveElem();
			}
		}

		pAlignerParam->SetLightCtrlInfo(cObj);

		m_XMLConfigator.LeaveElem();	//CMDLightCtrlInfo
	}

	// 基准Mark修正
	if (!m_XMLConfigator.FindElem(_T("FiducialTargetDefineEnable")))		// (Level-2)基准校正启用|禁用
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);

	if ( ((BOOL)nData) != m_pPlatformInfo->m_bBenchMarkAmend )	// BenchTargetMarkFixEnable check
	{
		goto LoadFailed;
	}
	pAlignerParam->SetBenchTargetMarkFixEnable((BOOL)nData);
	if ((BOOL)nData)		// 如果启用了基准校正，加载基准校正信息
	{
		if (!m_XMLConfigator.FindElem(_T("FiducialTargetDefineInfo")))		// (Level-2)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();  
		if (!m_XMLConfigator.FindElem(_T("FiducialTargetNum")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);

		int nPosNum = m_pPlatformInfo->m_nPositionNum;
		if ( nData != nPosNum )
		{
			goto LoadFailed;
		}
		pBenchTargetMarkFixInfo = new CBenchTargetMarkFixInfo(nData, m_pPlatformInfo->m_ePlatformType);
		pBenchTargetMarkFixInfo->SetMarkNum(nData);


		// 1
		if (!m_XMLConfigator.FindElem(_T("FiducialTargetImgCoord")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();
		CString strIdx;
		for (i=0; i<nData; i++)
		{
			strIdx.Format(_T("Mark%d"), i);
			if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
			{
				goto LoadFailed;
			}

			m_XMLConfigator.EnterElem();
			if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-5)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosX);

			if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-5)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosY);

			if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-5)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dAngle);

			pBenchTargetMarkFixInfo->SetMarkImageCoordPos(i, pos);
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();


		// 2
		if (!m_XMLConfigator.FindElem(_T("FiducialTargetPlatCoord")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();
		for (i=0; i<nData; i++)
		{
			strIdx.Format(_T("Mark%d"), i);
			if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.EnterElem();
			if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-5)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosX);
			if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-5)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dPosY);
			if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-5)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pos.m_dAngle);
			pBenchTargetMarkFixInfo->SetMarkPlatformCoordPos(i, pos);
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();


		// 3
		if (!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();
		pPlatformAxisPos = new CPlatformXYDAxisPos();
		for (i=0;i<nData;i++)
		{
			strIdx.Format("PlatAxisPos%d",i);
			if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.EnterElem();

			if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-4)
			{
				goto LoadFailed;
			}
			int temp=0;
			m_XMLConfigator.GetElemData(temp);

			if ( ((PlatformType)temp) != m_pPlatformInfo->m_ePlatformType )	// PlatformType check
			{
				goto LoadFailed;
			}

			if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dPosX);

			if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dPosY);

			if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pPlatformAxisPos->m_dAngle);

			pBenchTargetMarkFixInfo->SetFixPlatformPos(i,pPlatformAxisPos);

			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();	


		// 4
		if (!m_XMLConfigator.FindElem(_T("CamPlatAxisPos")))	// (Level-3) BenchFixCamPlatformPos
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();
		if (!m_XMLConfigator.FindElem(_T("CamPlatType")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		if ( ((CamPlatformType)nData) != m_pPlatformInfo->m_eCamPlatformType )	// PlatformType check
		{
			goto LoadFailed;
		}
		if (((CamPlatformType)nData != eCamPlatformSepFix) && ((CamPlatformType)nData != eCamPlatformUnknown))
		{
			pCamPlatformAxisPos = new CPlatformXYAxisPos();
			for (i=0; i<nData; i++)
			{
				strIdx.Format(_T("Pos%d"), i);
				if (!m_XMLConfigator.FindElem(strIdx))		// (Level-4)
				{
					goto LoadFailed;
				}
				m_XMLConfigator.EnterElem();
				if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-5)
				{
					goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
				if ((CamPlatformType)nData == eCamPlatformSepXY)
				{
					if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-5)
					{
						goto LoadFailed;
					}
					m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);
				}
				pBenchTargetMarkFixInfo->SetFixCamPlatformPos(i, pCamPlatformAxisPos);
				m_XMLConfigator.LeaveElem();
			}

			if (pCamPlatformAxisPos != NULL)
			{
				delete pCamPlatformAxisPos;
				pCamPlatformAxisPos = NULL;
			}
		}
		m_XMLConfigator.LeaveElem();

		// 5
		if (!m_XMLConfigator.FindElem(_T("Valid")))	// (Level-3) IsValid
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		pBenchTargetMarkFixInfo->Validate((BOOL)nData);

		pAlignerParam->SetBenchTargetMarkFixInfo(pBenchTargetMarkFixInfo);
		m_XMLConfigator.LeaveElem();
	}


	// 目标模板
	if (!m_XMLConfigator.FindElem(_T("TargetType")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	// 特殊处理一下
	if ( ((AlignerTargetType)nData) != m_pPlatformInfo->m_eAlignerTargetType )	// TargetMarkType check
	{
		pAlignerParam->SetTargetMarkType(m_pPlatformInfo->m_eAlignerTargetType);
	}
	else
	{
		pAlignerParam->SetTargetMarkType((AlignerTargetType)nData);
	}


	if (!m_XMLConfigator.FindElem(_T("TargetPatNum")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetTargetMarkPatternNum(nData);


	if (!m_XMLConfigator.FindElem(_T("TargetCandidateEnable")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetTargetCandidateEnable((BOOL)nData);


	if (!m_XMLConfigator.FindElem(_T("TargetCandidateSync")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetTargetCandidateSyncEnable((BOOL)nData);


	int nTargetCandidateOffsetNum = TARGETCANDIDATENUM;
	//	pAlignerParam->SetAlignerOffsetNum(nTargetCandidateOffsetNum);
	pAlignerParam->SetTargetCandidateOffsetNum(nTargetCandidateOffsetNum);
	for(i = 0; i < nTargetCandidateOffsetNum; i++)
	{
		CString strElem;
		strElem.Format(_T("TargetCandidateOffset%d"), i);
		if (!m_XMLConfigator.FindElem(strElem))		// (Level-2)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dPosX);

		if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dPosY);

		if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dAngle);

		if (!m_XMLConfigator.FindElem(_T("Enable")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);

		pAlignerParam->SetTargetCandidateOffset(i, pos);
		pAlignerParam->SetTargetCandidateOffsetEnable(i, (BOOL)nData);
		m_XMLConfigator.LeaveElem();
	}


	// 对象模板
	if (!m_XMLConfigator.FindElem(_T("ObjectType")))	// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	// 特殊处理一下
	if ( ((AlignerObjectType)nData) != m_pPlatformInfo->m_eAlignerObjectType )
	{
		pAlignerParam->SetObjectMarkType(m_pPlatformInfo->m_eAlignerObjectType);
	}
	else
	{
		pAlignerParam->SetObjectMarkType((AlignerObjectType)nData);
	}

	if (!m_XMLConfigator.FindElem(_T("ObjectPatNum")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetObjectMarkPatternNum(nData);


	if (!m_XMLConfigator.FindElem(_T("ObjectCandidateEnable")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetObjectCandidateEnable((BOOL)nData);


	if (!m_XMLConfigator.FindElem(_T("ObjectCandidateSync")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetObjectCandidateSyncEnable((BOOL)nData);


	int nObjectCandidateOffsetNum = OBJECTCANDIDATENUM;
	//	pAlignerParam->SetAlignerOffsetNum(nObjectCandidateOffsetNum);
	pAlignerParam->SetObjectCandidateOffsetNum(nObjectCandidateOffsetNum);
	for(i = 0; i < nObjectCandidateOffsetNum; i++)
	{
		CString strElem;
		strElem.Format(_T("ObjectCandidateOffset%d"), i);
		if (!m_XMLConfigator.FindElem(strElem))		// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();
		if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dPosX);
		if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dPosY);
		if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pos.m_dAngle);
		if (!m_XMLConfigator.FindElem(_T("Enable")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);

		pAlignerParam->SetObjectCandidateOffset(i, pos);
		pAlignerParam->SetObjectCandidateOffsetEnable(i, (BOOL)nData);
		m_XMLConfigator.LeaveElem();
	}

	// 虚拟对象
	if (m_pPlatformInfo->m_eAlignerObjectType == eObjectVirtual)	// VirtualObjectMarkEnable check
	{
		if (!m_XMLConfigator.FindElem(_T("VObjectEnable")))		// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		pAlignerParam->SetVirtualObjectMarkEnable((BOOL)nData);

		if (m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE)
		{
			pAlignerParam->SetVirtualObjectMarkPatternNum(m_pPlatformInfo->m_nPositionNum + m_pPlatformInfo->m_nPositionNum*m_pPlatformInfo->m_nMultiCalibExtensionMaxNum);
		}
		else
		{
			pAlignerParam->SetVirtualObjectMarkPatternNum(m_pPlatformInfo->m_nPositionNum);
		}

		nData = pAlignerParam->GetVirtualObjectMarkPatternNum();
		if (m_XMLConfigator.FindElem(_T("VObjectOffset")))		// (Level-2)
		{
			m_XMLConfigator.EnterElem();
			CString strIdx1;
			for (j=0; j<nData; j++)
			{
				strIdx1.Format(_T("Offset%d"), j);
				if (m_XMLConfigator.FindElem(strIdx1))		// (Level-3)
				{
					m_XMLConfigator.EnterElem();
					if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-4)
					{
						goto LoadFailed;
					}
					m_XMLConfigator.GetElemData(pos.m_dPosX);

					if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-4)
					{
						goto LoadFailed;
					}
					m_XMLConfigator.GetElemData(pos.m_dPosY);

					if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-4)
					{
						goto LoadFailed;
					}
					m_XMLConfigator.GetElemData(pos.m_dAngle);

					pAlignerParam->SetVirtualObjectMarkOffset(j, pos);
					m_XMLConfigator.LeaveElem();
				}
			}
			m_XMLConfigator.LeaveElem();
		}
		else
		{
			goto LoadFailed;
		}
	}

	// 关联模板
	pAlignerParam->SetTargetObjectCamSeparateEnable(m_pPlatformInfo->m_bTargetObjectCamSeparate);
	pAlignerParam->SetTargetCalibUseBoardEnable(m_pPlatformInfo->m_bTargetCalibUseBoard);
	if (m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE || (m_pPlatformInfo->m_bTargetObjectCamSeparate == FALSE && m_pPlatformInfo->m_bTargetCalibUseBoard == TRUE))
	{		
		pAlignerParam->SetCalibTargetMarkPatternNum(m_pPlatformInfo->m_nPositionNum);

		if (!m_XMLConfigator.FindElem(_T("CalibTargetMarkEnable")))		// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		pAlignerParam->SetCalibTargetMarkEnable((BOOL)nData);

		if (!m_XMLConfigator.FindElem(_T("CalibTargetMarkPatternMode")))		// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		pAlignerParam->SetCalibTargetMarkPatternMode((CalibTargetMarkPatternMode)nData);

		if (!m_XMLConfigator.FindElem(_T("CalibTargetDMCodeOutLineEnable")))		// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		pAlignerParam->SetCalibTargetDMCodeOutLineEnable(nData);

		if (!m_XMLConfigator.FindElem(_T("CalibTargetDMCodeOutLinePercent")))		// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(dValue);
		pAlignerParam->SetCalibTargetDMCodeOutLinePercent(dValue);

	}

	// 检测模板
	pAlignerParam->SetSysPlatformInspectEnable(TRUE);
	pAlignerParam->SetInspectMarkPatternNum(m_pPlatformInfo->m_nPositionNum);

	if (!m_XMLConfigator.FindElem(_T("InspectCandidateEnable")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetInspectCandidateEnable((BOOL)nData);

	if (!m_XMLConfigator.FindElem(_T("InspectCandidateSyncEnable")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetInspectCandidateSyncEnable((BOOL)nData);


	if (!m_XMLConfigator.FindElem(_T("InspectSingleSearchEnable")))		// (Level-2)
	{
		nData = 0;
	}
	m_XMLConfigator.GetElemData(nData);
	pAlignerParam->SetInspectSingleSearchEnable((BOOL)nData);

	int nInspectCandidateOffsetNum = INSPECTCANDIDATENUM;
	for(i = 0; i < nInspectCandidateOffsetNum; i++)
	{
		CString strElem;
		strElem.Format(_T("InspectCandidateOffset%d"), i);
		if (!m_XMLConfigator.FindElem(strElem))		// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();

		if (!m_XMLConfigator.FindElem(_T("Enable")))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);

		pAlignerParam->SetInspectCandidateOffsetEnable(i, (BOOL)nData);
		m_XMLConfigator.LeaveElem();
	}


	// 模板曝光
	// Target
	if (m_XMLConfigator.FindElem(_T("AllTargetSearchShutter")))
	{
		m_XMLConfigator.EnterElem();

		for (int j = 0; j < TARGETCANDIDATENUM; j++)
		{
			strInfo.Format(_T("TargetShutterEnable%d"),j);

			if ( !m_XMLConfigator.FindElem(strInfo) )		// (Level-2)
			{
				goto LoadFailed;
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vbTargetSearchShutter[j].LoadModelFromFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}


		for (int i = 0; i < GetPosNum(); i++)
		{
			for (int j = 0; j < TARGETCANDIDATENUM; j++)
			{
				strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);

				if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
				{
					goto LoadFailed;
				}

				m_XMLConfigator.EnterElem();
				pAlignerParam->m_vvdTargetSearchShutter[i][j].LoadModelFromFile(m_XMLConfigator);
				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();
	}


	// Object
	if (m_XMLConfigator.FindElem(_T("AllObjectSearchShutter")))
	{
		m_XMLConfigator.EnterElem();

		for (int j = 0; j < OBJECTCANDIDATENUM; j++)
		{
			strInfo.Format(_T("ObjectShutterEnable%d"),j);

			if ( !m_XMLConfigator.FindElem(strInfo) )		// (Level-2)
			{
				goto LoadFailed;
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vbObjectSearchShutter[j].LoadModelFromFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}

		for (int i = 0; i < GetPosNum(); i++)
		{
			for (int j = 0; j < OBJECTCANDIDATENUM; j++)
			{
				strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);

				if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
				{
					goto LoadFailed;
				}

				m_XMLConfigator.EnterElem();
				pAlignerParam->m_vvdObjectSearchShutter[i][j].LoadModelFromFile(m_XMLConfigator);
				m_XMLConfigator.LeaveElem();

			}
		}
		m_XMLConfigator.LeaveElem();
	}

	// VirtualObject
	if (m_XMLConfigator.FindElem(_T("AllVirtualObjectSearchShutter")))
	{
		m_XMLConfigator.EnterElem();

		for (int j = 0; j < OBJECTCANDIDATENUM; j++)
		{
			strInfo.Format(_T("VirtualObjectShutterEnable%d"),j);

			if ( !m_XMLConfigator.FindElem(strInfo) )		// (Level-2)
			{
				goto LoadFailed;
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vbVirtualObjectSearchShutter[j].LoadModelFromFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}

		for (int i = 0; i < GetPosNum(); i++)
		{
			for (int j = 0; j < OBJECTCANDIDATENUM; j++)
			{
				strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);

				if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
				{
					goto LoadFailed;
				}

				m_XMLConfigator.EnterElem();
				pAlignerParam->m_vvdVirtualObjectSearchShutter[i][j].LoadModelFromFile(m_XMLConfigator);
				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();	
	}


	// CalibTarget
	if (m_XMLConfigator.FindElem(_T("AllCalibTargetSearchShutter")))
	{
		m_XMLConfigator.EnterElem();

		for (int j = 0; j < OBJECTCANDIDATENUM; j++)
		{
			strInfo.Format(_T("CalibTargetShutterEnable%d"),j);

			if ( !m_XMLConfigator.FindElem(strInfo) )		// (Level-2)
			{
				goto LoadFailed;
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vbCalibTargetSearchShutter[j].LoadModelFromFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}


		for (int i = 0; i < GetPosNum(); i++)
		{
			for (int j = 0; j < OBJECTCANDIDATENUM; j++)
			{
				strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);

				if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
				{
					goto LoadFailed;
				}

				m_XMLConfigator.EnterElem();
				pAlignerParam->m_vvdCalibTargetSearchShutter[i][j].LoadModelFromFile(m_XMLConfigator);
				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();
	}

	// Inspect
	if (m_XMLConfigator.FindElem(_T("AllInspectSearchShutter")))
	{
		m_XMLConfigator.EnterElem();

		for (int j = 0; j < INSPECTCANDIDATENUM; j++)
		{
			strInfo.Format(_T("InspectShutterEnable%d"),j);

			if ( !m_XMLConfigator.FindElem(strInfo) )		// (Level-2)
			{
				goto LoadFailed;
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vbInspectSearchShutter[j].LoadModelFromFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}

		for (int i = 0; i < GetPosNum(); i++)
		{
			for (int j = 0; j < INSPECTCANDIDATENUM; j++)
			{
				strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);

				if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
				{
					goto LoadFailed;
				}

				m_XMLConfigator.EnterElem();
				pAlignerParam->m_vvdInspectSearchShutter[i][j].LoadModelFromFile(m_XMLConfigator);
				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();
	}



	if (!m_XMLConfigator.FindElem(_T("TargetPosPatInfo")))		// (Level-2)
	{
		goto LoadFailed;
	}

	m_XMLConfigator.EnterElem();
	if (!m_XMLConfigator.FindElem(_T("PosNum")))		// (Level-3)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);	// (level-3)

	pAlignerParam->m_vTargetPosPatInfo.resize(nData);
	for (i=0; i<nData; i++)
	{
		CString strName;
		strName.Format(_T("PosPatInfo_%d"), i);
		if (!m_XMLConfigator.FindElem(strName))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();

		CPosPatInfo posPatInfo;
		if (!m_XMLConfigator.FindElem(_T("Index")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(posPatInfo.m_nIndex);
		if (!m_XMLConfigator.FindElem(_T("IsSelected")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(posPatInfo.m_bIsSelected);
		if (!m_XMLConfigator.FindElem(_T("PatternNum")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(posPatInfo.m_nPatNum);
		if (!m_XMLConfigator.FindElem(_T("PatSelected")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(posPatInfo.m_nPatSelected);
		if (!m_XMLConfigator.FindElem(_T("vShutter")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();
		double dShutter = 0;
		for (int k=0; k<posPatInfo.m_nPatNum; k++)
		{
			CString strName;
			strName.Format(_T("Shutter_%d"), k);
			if (!m_XMLConfigator.FindElem(strName))		// (Level-5)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dShutter);
			posPatInfo.m_vdShutter.push_back(dShutter);
		}
		m_XMLConfigator.LeaveElem();
		m_XMLConfigator.LeaveElem();

		pAlignerParam->m_vTargetPosPatInfo[i] = posPatInfo;

	}
	m_XMLConfigator.LeaveElem();




	if (!m_XMLConfigator.FindElem(_T("ObjectPosPatInfo")))		// (Level-2)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem();
	if (!m_XMLConfigator.FindElem(_T("PosNum")))		// (Level-3)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.GetElemData(nData);	// (level-3)

	pAlignerParam->m_vObjectPosPatInfo.resize(nData);
	for (i=0; i<nData; i++)
	{
		CString strName;
		strName.Format(_T("PosPatInfo_%d"), i);
		if (!m_XMLConfigator.FindElem(strName))		// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();

		CPosPatInfo posPatInfo;
		if (!m_XMLConfigator.FindElem(_T("Index")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(posPatInfo.m_nIndex);
		if (!m_XMLConfigator.FindElem(_T("IsSelected")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(posPatInfo.m_bIsSelected);
		if (!m_XMLConfigator.FindElem(_T("PatternNum")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(posPatInfo.m_nPatNum);
		if (!m_XMLConfigator.FindElem(_T("PatSelected")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(posPatInfo.m_nPatSelected);
		if (!m_XMLConfigator.FindElem(_T("vShutter")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();
		double dShutter = 0;
		for (int k=0; k<posPatInfo.m_nPatNum; k++)
		{
			CString strName;
			strName.Format(_T("Shutter_%d"), k);
			if (!m_XMLConfigator.FindElem(strName))		// (Level-5)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(dShutter);
			posPatInfo.m_vdShutter.push_back(dShutter);
		}
		m_XMLConfigator.LeaveElem();
		m_XMLConfigator.LeaveElem();

		pAlignerParam->m_vObjectPosPatInfo[i] = posPatInfo;
	}
	m_XMLConfigator.LeaveElem();


	m_XMLConfigator.LeaveElem();		// (Level-1) 对位信息




	if (product.m_pAlignerParam != NULL)
	{
		delete product.m_pAlignerParam;
		product.m_pAlignerParam = NULL;
	}
	if (pAlignerParam != NULL)
	{
		product.m_pAlignerParam = new CAlignerParam(*pAlignerParam);
	}

	// 二维码参数
	product.m_vDMcodeCalib.resize(GetPosNum());
	if (m_XMLConfigator.FindElem(_T("CalibDMcodeParam")))	// (Level-1)
	{
		m_XMLConfigator.EnterElem();  //2级目录
		{
			CString strName;
			for (i=0;i<GetPosNum();i++)
			{
				strName.Format(_T("DMcodeParam%d"),i);
				if (m_XMLConfigator.FindElem(strName))
				{
					m_XMLConfigator.EnterElem();  //2级目录

					strName.Format("SearchShutter");
					if (m_XMLConfigator.FindElem(strName))
					{

						double tmp;
						m_XMLConfigator.GetElemData(tmp);
						dmCodeParam.m_dShutter = tmp;	

					}

					strName.Format("ImageWidth");
					if (m_XMLConfigator.FindElem(strName))
					{

						double tmp;
						m_XMLConfigator.GetElemData(tmp);
						dmCodeParam.m_dImageWidth = tmp;	

					}

					strName.Format("ImageHeight");
					if (m_XMLConfigator.FindElem(strName))
					{

						double tmp;
						m_XMLConfigator.GetElemData(tmp);
						dmCodeParam.m_dImageHeight = tmp;	

					}

					strName.Format("CalibDMCodeSearchRect");
					if (m_XMLConfigator.FindElem(strName))
					{
						sc2Vector vPos;
						m_XMLConfigator.EnterElem();
						{
							strName.Format("OriginX");
							if (m_XMLConfigator.FindElem(strName))
							{
								int tmp;
								m_XMLConfigator.GetElemData(tmp);
								vPos.SetX(tmp);
							}
							strName.Format("OriginY");
							if (m_XMLConfigator.FindElem(strName))
							{
								int tmp;
								m_XMLConfigator.GetElemData(tmp);
								vPos.SetY(tmp);
							}
							dmCodeParam.m_DmCodeSearchRect.SetOrigion(vPos);
							strName.Format("SizeX");
							if (m_XMLConfigator.FindElem(strName))
							{
								int tmp;
								m_XMLConfigator.GetElemData(tmp);
								vPos.SetX(tmp);
							}
							strName.Format("SizeY");
							if (m_XMLConfigator.FindElem(strName))
							{
								int tmp;
								m_XMLConfigator.GetElemData(tmp);
								vPos.SetY(tmp);
							}
							dmCodeParam.m_DmCodeSearchRect.SetSize(vPos);
						}
						m_XMLConfigator.LeaveElem();
					}

					strName.Format("CalibCornersSearchRect");
					if (m_XMLConfigator.FindElem(strName))
					{
						sc2Vector vPos;
						m_XMLConfigator.EnterElem();
						{
							strName.Format("OriginX");
							if (m_XMLConfigator.FindElem(strName))
							{
								int tmp;
								m_XMLConfigator.GetElemData(tmp);
								vPos.SetX(tmp);
							}
							strName.Format("OriginY");
							if (m_XMLConfigator.FindElem(strName))
							{
								int tmp;
								m_XMLConfigator.GetElemData(tmp);
								vPos.SetY(tmp);
							}
							dmCodeParam.m_CornersSearchRect.SetOrigion(vPos);
							strName.Format("SizeX");
							if (m_XMLConfigator.FindElem(strName))
							{
								int tmp;
								m_XMLConfigator.GetElemData(tmp);
								vPos.SetX(tmp);
							}
							strName.Format("SizeY");
							if (m_XMLConfigator.FindElem(strName))
							{
								int tmp;
								m_XMLConfigator.GetElemData(tmp);
								vPos.SetY(tmp);
							}
							dmCodeParam.m_CornersSearchRect.SetSize(vPos);
						}
						m_XMLConfigator.LeaveElem();
					}

					strName.Format("CalibDMCodeGridSize");
					if (m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindCornerPara.m_dGridSize);
					}

					strName.Format("CalibDMCodeGridThre");
					if( m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindCornerPara.m_dGridThre);
					}

					strName.Format("CalibDMCodeOutputOutPoints");
					if(m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_FindCornerPara.m_bOutputOutPoints = (BOOL)k;

					}

					strName.Format("CalibDMCodeMaxNum");
					if( m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindDMCodePara.m_nMaxCodeNum);
					}

					strName.Format("CalibDMCodeMaxTime");
					if(m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindDMCodePara.m_nWaitingTime);
					}

					strName.Format("CalibDMCodeMirror");
					if( m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_FindDMCodePara.m_modeMirror = (MirrorMode)k;
					}

					strName.Format("DecodeMethod");
					if( m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_FindDMCodePara.m_methodDecode = (DecodeMethod)k;
					}

					strName.Format("AppMode");
					if( m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_FindDMCodePara.m_modeApp = (AppMode)k;
					}

					strName.Format("DiscreteFlag");
					if( m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_FindDMCodePara.m_flagDiscrete = (DiscreteFlag)k;
					}

					strName.Format("DistortionFlag");
					if( m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_FindDMCodePara.m_flagDistortion = (DistortionFlag)k;
					}

					strName.Format("PolarityMode");
					if( m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_FindDMCodePara.m_modePolarity = (PolarityMode)k;
					}

					strName.Format("RectangleFlag");
					if( m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_FindDMCodePara.m_flagRectangle = (RectangleFlag)k;
					}

					strName.Format("MinBarSize");
					if(m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindDMCodePara.m_nMinBarSize);
					}

					strName.Format("MaxBarSize");
					if(m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindDMCodePara.m_nMaxBarSize);
					}

					strName.Format("SampleLevel");
					if(m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindDMCodePara.m_nSampleLevel);
					}

					strName.Format("DebugFlag");
					if(m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindDMCodePara.m_nDebugFlag);
					}

					strName.Format("AdvanceParam");
					if(m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindDMCodePara.m_nAdvanceParam);
					}

					strName.Format("AdvanceParam2");
					if(m_XMLConfigator.FindElem(strName))
					{
						m_XMLConfigator.GetElemData(dmCodeParam.m_FindDMCodePara.m_nAdvanceParam2);
					}

					strName.Format("CalibDMCodeRecode");
					if(m_XMLConfigator.FindElem(strName))
					{
						int k = 0;
						m_XMLConfigator.GetElemData(k);
						dmCodeParam.m_bEnableReDecode = (BOOL)k;

					}


					m_XMLConfigator.LeaveElem();  //2级目录
				}
				product.m_vDMcodeCalib.at(i) = dmCodeParam;
			}

		}
		m_XMLConfigator.LeaveElem();  //2级目录
	}

	//////////////////////////////////////////////////////////////////////////
	// 机器人示教信息
	if (m_XMLConfigator.FindElem(_T("RobotTeachInfo")))	// (Level-1)
	{
		m_XMLConfigator.EnterElem();  //2级目录

		// 手动移动速度
		strInfo.Format(_T("MSpeed"));
		if (m_XMLConfigator.FindElem(strInfo))	// (Level-2)
		{
			m_XMLConfigator.GetElemData(robotTeachInfo.m_nMSpeed);
		}

		// 示教点信息
		RobotPos rpRobotPos;
		BOOL     bRobotPosValid = FALSE;
		for(i = 0; i < RobotTeachPosTotalMaxNum && i < robotTeachInfo.m_vrpRobotTeachPos.size(); i++)
		{
			strInfo.Format(_T("TeachPosInfo%d"),i);
			if (m_XMLConfigator.FindElem(strInfo))	// (Level-2)
			{
				m_XMLConfigator.EnterElem();  //3级目录

				strInfo.Format(_T("X"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(rpRobotPos.m_dPosX);
				}

				strInfo.Format(_T("Y"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(rpRobotPos.m_dPosY);
				}

				strInfo.Format(_T("R"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(rpRobotPos.m_dPosR);
				}

				strInfo.Format(_T("Z"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(rpRobotPos.m_dPosZ);
				}

				strInfo.Format(_T("A"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(rpRobotPos.m_dPosA);
				}

				strInfo.Format(_T("B"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(rpRobotPos.m_dPosB);
				}

				strInfo.Format(_T("CT"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(rpRobotPos.m_nCoordType);
				}

				bRobotPosValid = FALSE;
				strInfo.Format(_T("Valid"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(bRobotPosValid);
				}

				m_XMLConfigator.LeaveElem();  //3级目录
			}

			robotTeachInfo.m_vrpRobotTeachPos[i] = rpRobotPos;
			robotTeachInfo.m_vbRobotTearchPosValid[i] = bRobotPosValid;
		}

		// 整型常量信息
		int nTeachSGInt = 0;
		BOOL bTeachSGIntValid = FALSE;
		for(i = 0; i < RobotTeachSGIntMaxNum && i < robotTeachInfo.m_vnRobotTeachSGInt.size(); i++)
		{
			nTeachSGInt = 0;
			bTeachSGIntValid = FALSE;
			strInfo.Format(_T("TeachSGIntInfo%d"),i);
			if (m_XMLConfigator.FindElem(strInfo))	// (Level-2)
			{
				m_XMLConfigator.EnterElem();  //3级目录

				strInfo.Format(_T("Val"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(nTeachSGInt);
				}

				strInfo.Format(_T("Valid"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(bTeachSGIntValid);
				}

				m_XMLConfigator.LeaveElem();  //3级目录
			}

			robotTeachInfo.m_vnRobotTeachSGInt[i] = nTeachSGInt;
			robotTeachInfo.m_vbRobotTeachSGIntValid[i] = bTeachSGIntValid;
		}

		// 实数常量信息

		double dTeachSGReal = 0;
		BOOL bTeachSGRealValid = FALSE;
		for(i = 0; i < RobotTeachSGRealMaxNum && i < robotTeachInfo.m_vdRobotTeachSGReal.size(); i++)
		{
			dTeachSGReal = 0;
			bTeachSGRealValid = FALSE;
			strInfo.Format(_T("TeachSGRealInfo%d"),i);
			if (m_XMLConfigator.FindElem(strInfo))	// (Level-2)
			{
				m_XMLConfigator.EnterElem();  //3级目录

				strInfo.Format(_T("Val"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(dTeachSGReal);
				}

				strInfo.Format(_T("Valid"));
				if (m_XMLConfigator.FindElem(strInfo))
				{
					m_XMLConfigator.GetElemData(bTeachSGRealValid);
				}

				m_XMLConfigator.LeaveElem();  //3级目录
			}

			robotTeachInfo.m_vdRobotTeachSGReal[i] = dTeachSGReal;
			robotTeachInfo.m_vbRobotTeachSGRealValid[i] = bTeachSGRealValid;
		}

		m_XMLConfigator.LeaveElem();  //2级目录
	}
	product.m_RobotTeachInfo = robotTeachInfo;


	//////////////////////////////////////////////////////////////////////////
	// 标定后参数（与平台相关）
	pCalibratedInfo = new CCalibratedInfo(m_pPlatformInfo->m_ePlatformType, m_pPlatformInfo->m_eCamPlatformType);
	pCalibPlatformAxisPos = new CPlatformXYDAxisPos;

	if (!m_XMLConfigator.FindElem(_T("CalibedResult")))	// (Level-1)
	{
		goto LoadFailed;
	}
	m_XMLConfigator.EnterElem();  //2级目录

	nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nExPosNum = 0;
	if (m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE)
	{
		nExPosNum = nPosNum + nPosNum*m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
	}
	else
	{
		nExPosNum = nPosNum;
	}
	//for (i=0; i<nPosNum; i++)
	for (i=0; i<nExPosNum; i++)
	{
		strInfo.Format(_T("CalibedResult%d"),i);

		if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //3级目录

		if (m_XMLConfigator.FindElem(_T("Valid")))	// (Level-3)
		{
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_bValid);
		}

		//  1. 标定时，图像坐标系到平台坐标系之间的变换矩阵
		if (!m_XMLConfigator.FindElem(_T("PlatTM")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //4级目录

		// A00
		m_XMLConfigator.FindElem(_T("A00"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(0,0,dValue);

		// A01
		m_XMLConfigator.FindElem(_T("A01"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(0,1,dValue);

		// A10
		m_XMLConfigator.FindElem(_T("A10"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(1,0,dValue);

		// A11
		m_XMLConfigator.FindElem(_T("A11"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(1,1,dValue);

		m_XMLConfigator.LeaveElem();  //4级目录


		//  2. 标定时，图像坐标系到平台坐标系之间的变换矩阵H
		if (!m_XMLConfigator.FindElem(_T("PlatTMH")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		double h[9];
		for(j = 0; j < 9; j++)
		{
			h[j] = 0.0;
			strInfo.Format(_T("h%d"),j);
			m_XMLConfigator.FindElem(strInfo);
			m_XMLConfigator.GetElemData(dValue);
			h[j] = dValue;						
		}
		pCalibratedInfo->SetPlatformTransferH(h);
		m_XMLConfigator.LeaveElem();



		// 		//  标定时，图像坐标系到平台坐标系之间的变换矩阵H
		// 		if (m_XMLConfigator.FindElem(_T("PlatTMH")))
		// 		{
		// 			m_XMLConfigator.EnterElem();
		// 
		// 			double h[9];
		// 			int j = 0;
		// 			for(j = 0; j < 9; j++)
		// 			{
		// 				h[j] = 0.0;
		// 				strInfo.Format(_T("h%d"),j);
		// 				m_XMLConfigator.FindElem(strInfo);
		// 				m_XMLConfigator.GetElemData(dValue);
		// 				h[j] = dValue;						
		// 			}
		// 			pCalibratedInfo->SetPlatformTransferH(h);
		// 
		// 			m_XMLConfigator.LeaveElem();
		// 		}
		// 		else
		// 		{
		// 			goto LoadFailed;
		// 		}

		//  3. 全局靶标标定时，图像坐标系到靶标坐标系之间的变换矩阵H1
		if (!m_XMLConfigator.FindElem(_T("PlatTMH1")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		double h1[9];
		for(j = 0; j < 9; j++)
		{
			h1[j] = 0.0;
			strInfo.Format(_T("h1%d"),j);
			m_XMLConfigator.FindElem(strInfo);
			m_XMLConfigator.GetElemData(dValue);
			h1[j] = dValue;						
		}
		pCalibratedInfo->SetPlatformTransferH1(h1);
		m_XMLConfigator.LeaveElem();




		// 		//  全局靶标标定时，图像坐标系到靶标坐标系之间的变换矩阵H1
		// 		if (m_XMLConfigator.FindElem(_T("PlatTMH1")))
		// 		{
		// 			m_XMLConfigator.EnterElem();
		// 
		// 			double h1[9];
		// 			int j = 0;
		// 			for(j = 0; j < 9; j++)
		// 			{
		// 				h1[j] = 0.0;
		// 				strInfo.Format(_T("h1%d"),j);
		// 				m_XMLConfigator.FindElem(strInfo);
		// 				m_XMLConfigator.GetElemData(dValue);
		// 				h1[j] = dValue;						
		// 			}
		// 			pCalibratedInfo->SetPlatformTransferH1(h1);
		// 
		// 			m_XMLConfigator.LeaveElem();
		// 		}

		//  4. 全局靶标标定时，靶标坐标系到平台坐标系之间的变换矩阵H2
		if (!m_XMLConfigator.FindElem(_T("PlatTMH2")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		double h2[9];
		for(j = 0; j < 9; j++)
		{
			h2[j] = 0.0;
			strInfo.Format(_T("h2%d"),j);
			m_XMLConfigator.FindElem(strInfo);
			m_XMLConfigator.GetElemData(dValue);
			h2[j] = dValue;						
		}
		pCalibratedInfo->SetPlatformTransferH2(h2);
		m_XMLConfigator.LeaveElem();

		// 		//  4. 全局靶标标定时，靶标坐标系到平台坐标系之间的变换矩阵H2
		// 		if (m_XMLConfigator.FindElem(_T("PlatTMH2")))
		// 		{
		// 			m_XMLConfigator.EnterElem();
		// 
		// 			double h2[9];
		// 			int j = 0;
		// 			for(j = 0; j < 9; j++)
		// 			{
		// 				h2[j] = 0.0;
		// 				strInfo.Format(_T("h2%d"),j);
		// 				m_XMLConfigator.FindElem(strInfo);
		// 				m_XMLConfigator.GetElemData(dValue);
		// 				h2[j] = dValue;						
		// 			}
		// 			pCalibratedInfo->SetPlatformTransferH2(h2);
		// 
		// 			m_XMLConfigator.LeaveElem();
		// 		}

		//  5. 畸变校正结果
		if (!m_XMLConfigator.FindElem(_T("DistorCorrResult")))
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();
		double p[15];
		int j = 0;
		for(j = 0; j < 15; j++)
		{
			p[j] = 0.0;
			strInfo.Format(_T("p%d"),j);
			m_XMLConfigator.FindElem(strInfo);
			m_XMLConfigator.GetElemData(dValue);
			p[j] = dValue;						
		}
		pCalibratedInfo->m_result.SetNonlinearProjectResult(p);

		strInfo.Format(_T("RMS"),j);
		m_XMLConfigator.FindElem(strInfo);
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_result.SetRMS(dValue);
		m_XMLConfigator.LeaveElem();




		// 		//  5. 畸变校正结果
		// 		if (m_XMLConfigator.FindElem(_T("DistorCorrResult")))
		// 		{
		// 			m_XMLConfigator.EnterElem();
		// 
		// 			double p[15];
		// 			int j = 0;
		// 			for(j = 0; j < 15; j++)
		// 			{
		// 				p[j] = 0.0;
		// 				strInfo.Format(_T("p%d"),j);
		// 				m_XMLConfigator.FindElem(strInfo);
		// 				m_XMLConfigator.GetElemData(dValue);
		// 				p[j] = dValue;						
		// 			}
		// 			pCalibratedInfo->m_result.SetNonlinearProjectResult(p);
		// 
		// 			strInfo.Format(_T("RMS"),j);
		// 			m_XMLConfigator.FindElem(strInfo);
		// 			m_XMLConfigator.GetElemData(dValue);
		// 			pCalibratedInfo->m_result.SetRMS(dValue);
		// 
		// 			m_XMLConfigator.LeaveElem();
		// 		}

		// 6
		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffset")))	// (Level-3)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();  //4级目录

		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_dPosX);


		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_dPosY);		

		//if (GetProductCalibTargetMarkPatternMode(nIndex) == eSinglePatternGuanlian4Point)
		// 		{
		// 			for (int m=0;m<4;m++)
		// 			{
		// 				CString str;
		// 				str.Format("AuxiliaryPosX-%d",m);
		// 				if (m_XMLConfigator.FindElem(str))
		// 				{
		// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_vdAuxiliaryPosX[m]);
		// 				}
		// 				str.Format("AuxiliaryPosY-%d",m);
		// 				if (m_XMLConfigator.FindElem(str))
		// 				{
		// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_vdAuxiliaryPosY[m]);
		// 				}
		// 			}
		// 		}
		m_XMLConfigator.LeaveElem();  //4级目录


		// 		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffset")))	// (Level-3)
		// 		{
		// 			//goto LoadFailed;
		// 			pCalibratedInfo->m_cpRefineOffset.m_dPosX = 0;
		// 			pCalibratedInfo->m_cpRefineOffset.m_dPosY = 0;
		// 		}
		// 		else
		// 		{
		// 			m_XMLConfigator.EnterElem();  //4级目录
		// 
		// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		// 			{
		// 				//goto LoadFailed;
		// 				pCalibratedInfo->m_cpRefineOffset.m_dPosX = 0;
		// 			}
		// 			else
		// 			{
		// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_dPosX);
		// 			}
		// 
		// 
		// 			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		// 			{
		// 				//goto LoadFailed;
		// 				pCalibratedInfo->m_cpRefineOffset.m_dPosY = 0;
		// 			}
		// 			else
		// 			{
		// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_dPosY);		
		// 			}
		// 
		// 			//if (GetProductCalibTargetMarkPatternMode(nIndex) == eSinglePatternGuanlian4Point)
		// // 			{
		// // 				for (int m=0;m<4;m++)
		// // 				{
		// // 					CString str;
		// // 					str.Format("AuxiliaryPosX-%d",m);
		// // 					if (m_XMLConfigator.FindElem(str))
		// // 					{
		// // 						m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_vdAuxiliaryPosX[m]);
		// // 					}
		// // 					str.Format("AuxiliaryPosY-%d",m);
		// // 					if (m_XMLConfigator.FindElem(str))
		// // 					{
		// // 						m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_vdAuxiliaryPosY[m]);
		// // 					}
		// // 				}
		// // 			}
		// 
		// 			m_XMLConfigator.LeaveElem();  //4级目录
		// 		}

		// 7
		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffsetH1")))	// (Level-3)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();  //4级目录
		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX);


		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY);	
		m_XMLConfigator.LeaveElem();  //4级目录



		// 		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffsetH1")))	// (Level-3)
		// 		{
		// 			//goto LoadFailed;
		// 			pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX = 0;
		// 			pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY = 0;
		// 		}
		// 		else
		// 		{
		// 			m_XMLConfigator.EnterElem();  //4级目录
		// 
		// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		// 			{
		// 				//goto LoadFailed;
		// 				pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX = 0;
		// 			}
		// 			else
		// 			{
		// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX);
		// 			}
		// 
		// 
		// 			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		// 			{
		// 				//goto LoadFailed;
		// 				pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY = 0;
		// 			}
		// 			else
		// 			{
		// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY);		
		// 			}
		// 
		// 			m_XMLConfigator.LeaveElem();  //4级目录
		// 		}

		// 8
		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffsetH2")))	// (Level-3)
		{
			goto LoadFailed;
		}

		m_XMLConfigator.EnterElem();  //4级目录
		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX);

		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY);	
		m_XMLConfigator.LeaveElem();  //4级目录





		// 		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffsetH2")))	// (Level-3)
		// 		{
		// 			//goto LoadFailed;
		// 			pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX = 0;
		// 			pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY = 0;
		// 		}
		// 		else
		// 		{
		// 			m_XMLConfigator.EnterElem();  //4级目录
		// 
		// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		// 			{
		// 				//goto LoadFailed;
		// 				pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX = 0;
		// 			}
		// 			else
		// 			{
		// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX);
		// 			}
		// 
		// 
		// 			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		// 			{
		// 				//goto LoadFailed;
		// 				pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY = 0;
		// 			}
		// 			else
		// 			{
		// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY);		
		// 			}
		// 
		// 			m_XMLConfigator.LeaveElem();  //4级目录
		// 		}

		// 9. 标定时，基准Mark在平台坐标系的坐标值和姿态
		if (!m_XMLConfigator.FindElem(_T("MarkPlatCoord")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //4级目录
		// MarkPltCoordX
		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPos.m_dPosX);
		// MarkPltCoordY
		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPos.m_dPosY);		
		m_XMLConfigator.LeaveElem();  //4级目录

		// 10. 标定时，基准Mark在图像坐标系中的位置
		if (!m_XMLConfigator.FindElem(_T("MarkImgCoord")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();	  //4级目录	
		// MarkImgCoordX
		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPos.m_dPosX);
		// MarkImgCoordY
		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPos.m_dPosY);
		m_XMLConfigator.LeaveElem();  //4级目录

		// 11. 标定时，基准Mark在平台坐标系的坐标值和姿态
		if (m_XMLConfigator.FindElem(_T("MarkPlatCoordBat")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();  //4级目录
			// MarkPltCoordX
			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPosBat.m_dPosX);
			// MarkPltCoordY
			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPosBat.m_dPosY);		
			m_XMLConfigator.LeaveElem();  //4级目录;
		}


		// 12. 标定时，基准Mark在图像坐标系中的位置
		if (m_XMLConfigator.FindElem(_T("MarkImgCoordBat")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录	
			// MarkImgCoordX
			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPosBat.m_dPosX);
			// MarkImgCoordY
			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPosBat.m_dPosY);
			m_XMLConfigator.LeaveElem();  //4级目录;
		}

		// 13. 
		if (m_XMLConfigator.FindElem(_T("ObjectMarkImgCoord")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();
			if (m_vpMarkImagePos.size()<CALIBMOVEPOSNUM)
			{
				m_vpMarkImagePos.resize(CALIBMOVEPOSNUM);
			}
			for (int m=0;m<CALIBMOVEPOSNUM;m++)
			{
				// MarkImgCoordX
				CString strName;
				strName.Format("X%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX);
				}
				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX);
				// MarkImgCoordY
				strName.Format("Y%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY);
				}
				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY);
				CCoordPos pos;
				pos.m_dPosX = pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX;
				pos.m_dPosY = pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY;


				if (m_vpMarkImagePos.at(m)!=NULL)
				{
					delete m_vpMarkImagePos.at(m);
					m_vpMarkImagePos.at(m) = NULL;
				}							
				CMarkImagePos * markpos = new CMarkImagePos();	
				markpos->SetMarkImagePosNum(1);
				markpos->SetMarkImagePos(0,TRUE,pos);
				m_vpMarkImagePos.at(m)=markpos;
			}

			m_XMLConfigator.LeaveElem();  //4级目录

		}

		// 14. 
		if (m_XMLConfigator.FindElem(_T("TargetMarkImgCoord")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录	
			for (int m=0;m<CALIBMOVEPOSNUM;m++)
			{
				// MarkImgCoordX
				CString strName;
				strName.Format("X%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosX);
				}
				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosX);
				// MarkImgCoordY
				strName.Format("Y%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosY);
				}
				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosY);
			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}


		///////////////////////////////////////////////////////////////////////////////////////////////////////
		// 15. 用靶标关联映射时，标定板上的Mark位置图像坐标
		if (m_XMLConfigator.FindElem(_T("CalibBoardMarkImgCoordPos")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录
			for (int m=0;m<CALIBBOARDMARKPOSNUM;m++)
			{
				// MarkImgCoordX
				CString strName;
				strName.Format("X%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].m_dPosX);
				}
				// MarkImgCoordY
				strName.Format("Y%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].m_dPosY);
				}
			}

			m_XMLConfigator.LeaveElem();  //4级目录

		}


		// 16. 用靶标关联映射时，标定板上的Mark位置物理坐标
		if (m_XMLConfigator.FindElem(_T("CalibBoardMarkBoardCoordPos")))	// (Level-3)
		{
			m_XMLConfigator.EnterElem();	  //4级目录	
			for (int m=0;m<CALIBBOARDMARKPOSNUM;m++)
			{
				// MarkImgCoordX
				CString strName;
				strName.Format("X%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].m_dPosX);
				}
				// MarkImgCoordY
				strName.Format("Y%d",m);
				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].m_dPosY);
				}
			}

			m_XMLConfigator.LeaveElem();  //4级目录
		}

		// 17. 用靶标关联映射时，标定板尺寸
		if (m_XMLConfigator.FindElem(_T("CalibBoardSize")))
		{
			m_XMLConfigator.EnterElem();//4级目录打开
			// SizeX
			double dSizeX = 1.0;
			double dSizeY = 1.0;
			CString strName;
			strName.Format("SizeX");
			if (m_XMLConfigator.FindElem(strName))
			{
				m_XMLConfigator.GetElemData(dSizeX);
			}

			// SizeY
			strName.Format("SizeY");
			if (m_XMLConfigator.FindElem(strName))
			{
				m_XMLConfigator.GetElemData(dSizeY);
			}

			pCalibratedInfo->m_vCalibBoardSize = sc2Vector(dSizeX, dSizeY);
			m_XMLConfigator.LeaveElem();//4级目录关闭
		}



		// 18. 标定时，基准位置处平台各个轴的位置
		if (!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();	//4级目录	
		if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dPosX);
		if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dPosY);
		if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-4)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dAngle);
		pCalibratedInfo->SetPlatformAxisPos(pCalibPlatformAxisPos);
		m_XMLConfigator.LeaveElem();   //4级目录

		// 19. 标定时，图像坐标系与平台坐标系之间的角度
		if (!m_XMLConfigator.FindElem(_T("Anlge")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(pCalibratedInfo->m_dImageToPlatformAnlge);

		// 20. 标定时，相机坐标系到平台坐标系之间的变换矩阵
		if (!m_XMLConfigator.FindElem(_T("CamTM")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //4级目录
		// A00
		m_XMLConfigator.FindElem(_T("A00"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_CameraTranferMatrix.SetElement(0,0,dValue);
		// A01
		m_XMLConfigator.FindElem(_T("A01"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_CameraTranferMatrix.SetElement(0,1,dValue);
		// A10
		m_XMLConfigator.FindElem(_T("A10"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_CameraTranferMatrix.SetElement(1,0,dValue);
		// A11
		m_XMLConfigator.FindElem(_T("A11"));	// (Level-4)
		m_XMLConfigator.GetElemData(dValue);
		pCalibratedInfo->m_CameraTranferMatrix.SetElement(1,1,dValue);
		m_XMLConfigator.LeaveElem();   //4级目录

		// 21. 标定时，基准位置处相机平台各个轴的位置（XY）
		if (!m_XMLConfigator.FindElem(_T("CamPlatAxisPos")))	// (Level-3)
		{
			goto LoadFailed;
		}
		m_XMLConfigator.EnterElem();  //4级目录
		if (!m_XMLConfigator.FindElem(_T("CamPlatType")))
		{
			goto LoadFailed;
		}
		m_XMLConfigator.GetElemData(nData);
		if (((CamPlatformType)nData) != m_pPlatformInfo->m_eCamPlatformType)
		{
			goto LoadFailed;
		}

		switch((CamPlatformType)nData)
		{
		case eCamPlatformSepFix:
			break;
		case eCamPlatformSepX:
			pCamPlatformAxisPos = new CPlatformXYAxisPos;				
			// X轴位置
			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
			pCalibratedInfo->SetCamPlatformAxisPos(pCamPlatformAxisPos);
			break;
		case eCamPlatformSepXY:
			pCamPlatformAxisPos = new CPlatformXYAxisPos;			
			// X轴位置
			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
			{
				goto LoadFailed;
			}
			m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
			// Y轴位置
			if (m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
			{
				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);
			}
			pCalibratedInfo->SetCamPlatformAxisPos(pCamPlatformAxisPos);
			break;
		case eCamPlatformShareX:
			break;
		default:
			goto LoadFailed;
		}
		m_XMLConfigator.LeaveElem();	// Leave CamPlatformAxisPos //4级目录

		// 22.
		if(m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))
		{
			m_XMLConfigator.EnterElem();
			switch((CamPlatformType)nData)
			{
			case eCamPlatformSepFix:
				break;
			case eCamPlatformSepX:
				pCamAxisPlatformAxisPos = new CPlatformXYAxisPos;				
				// X轴位置
				if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
				{
					goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosX);
				pCalibratedInfo->SetCamAxisPlatformAxisPos(pCamAxisPlatformAxisPos);
				break;
			case eCamPlatformSepXY:
				pCamAxisPlatformAxisPos = new CPlatformXYAxisPos;			
				// X轴位置
				if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
				{
					goto LoadFailed;
				}
				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosX);
				// Y轴位置
				if (m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
				{
					m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosY);
				}
				pCalibratedInfo->SetCamAxisPlatformAxisPos(pCamAxisPlatformAxisPos);
				break;
			case eCamPlatformShareX:
			default:
				break;;
			}
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();	// Leave CH%d //3级目录

		if (product.m_vpCalibratedInfo.at(i) != NULL)
		{
			delete product.m_vpCalibratedInfo.at(i);
			product.m_vpCalibratedInfo.at(i) = NULL;
		}
		product.m_vpCalibratedInfo.at(i) = new CCalibratedInfo(*pCalibratedInfo);

		if (pCamPlatformAxisPos != NULL)
		{
			delete pCamPlatformAxisPos;
			pCamPlatformAxisPos = NULL;
		}

		if (pCamAxisPlatformAxisPos != NULL)
		{
			delete pCamAxisPlatformAxisPos;
			pCamAxisPlatformAxisPos = NULL;
		}
	}   
	m_XMLConfigator.LeaveElem(); //2级目录
	m_XMLConfigator.LeaveElem();  //1级目录

	if (product.IsValid())
	{
		m_pVisionASMConfig->m_TotalProductData.SetItemGrow(nIndex, product);
	}
	else
	{
		goto LoadFailed;
	}


	if (pAlignerParam != NULL)
	{
		delete pAlignerParam;
		pAlignerParam = NULL;
	}
	if (pBenchTargetMarkFixInfo != NULL)
	{
		delete pBenchTargetMarkFixInfo;
		pBenchTargetMarkFixInfo = NULL;
	}
	if (pBenchTargetMarkPickInfo != NULL)
	{
		delete pBenchTargetMarkPickInfo;
		pBenchTargetMarkPickInfo = NULL;
	}
	if (pPlatformAxisPos != NULL)
	{
		delete pPlatformAxisPos;
		pPlatformAxisPos = NULL;
	}
	if (pCalibratedInfo != NULL)
	{
		delete pCalibratedInfo;
		pCalibratedInfo = NULL;
	}
	if (pCalibPlatformAxisPos != NULL)
	{
		delete pCalibPlatformAxisPos;
		pCalibPlatformAxisPos = NULL;
	}
	if (pCamPlatformAxisPos != NULL)
	{
		delete pCamPlatformAxisPos;
		pCamPlatformAxisPos = NULL;
	}
	if (pCamAxisPlatformAxisPos != NULL)
	{
		delete pCamAxisPlatformAxisPos;
		pCamAxisPlatformAxisPos = NULL;
	}
	return TRUE;

	// 加载失败的资源释放
LoadFailed:
	{
		if (pAlignerParam != NULL)
		{
			delete pAlignerParam;
			pAlignerParam = NULL;
		}
		if (pBenchTargetMarkFixInfo != NULL)
		{
			delete pBenchTargetMarkFixInfo;
			pBenchTargetMarkFixInfo = NULL;
		}
		if (pBenchTargetMarkPickInfo != NULL)
		{
			delete pBenchTargetMarkPickInfo;
			pBenchTargetMarkPickInfo = NULL;
		}
		if (pPlatformAxisPos != NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
		if (pCalibratedInfo != NULL)
		{
			delete pCalibratedInfo;
			pCalibratedInfo = NULL;
		}
		if (pCalibPlatformAxisPos != NULL)
		{
			delete pCalibPlatformAxisPos;
			pCalibPlatformAxisPos = NULL;
		}
		if (pCamPlatformAxisPos != NULL)
		{
			delete pCamPlatformAxisPos;
			pCamPlatformAxisPos = NULL;
		}
		if (pCamAxisPlatformAxisPos != NULL)
		{
			delete pCamAxisPlatformAxisPos;
			pCamAxisPlatformAxisPos = NULL;
		}
		return FALSE;
	}
}

BOOL vcBaseVisionAlign::SaveProductDataInfo(int nIndex)
{
	ASSERT(nIndex >= 0);
	ASSERT(m_pVisionASMConfig != NULL);
	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
	ASSERT(m_pPlatformInfo != NULL);

	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
	{
		return FALSE;
	}
	if (m_pVisionASMConfig == NULL)
	{
		return FALSE;
	}
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	CString strInfo;
	double dValue = 0;
	int i = 0, j = 0, nData = 0;
	CCoordPos pos;
	sc2Matrix mat;
	CProductData				 product = m_pVisionASMConfig->m_TotalProductData.GetItem(nIndex);
	CAlignerParam				*pAlignerParam = product.m_pAlignerParam;
	CBenchTargetMarkFixInfo		*pBenchTargetMarkFixInfo	= NULL;
	CBenchTargetMarkPickInfo	*pBenchTargetMarkPickInfo	= NULL;
	CPlatformXYDAxisPos			*pPlatformAxisPos			= NULL;
	CCalibratedInfo				*pCalibratedInfo			= NULL;
	CPlatformXYDAxisPos			*pCalibPlatformAxisPos		= NULL;
	CPlatformAxisPos			*pCamPlatformAxisPos		= NULL;

	if ((pAlignerParam == NULL) || (product.m_vpCalibratedInfo.size() <= 0))
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));

	m_XMLConfigator.AddElem(_T("JobConfig"));	// (Root)
	m_XMLConfigator.EnterElem();

	m_XMLConfigator.AddElem(_T("AlignParam"));	// (Level-1) 对位信息
	m_XMLConfigator.EnterElem();
	m_XMLConfigator.AddElem(_T("AlignIndex"), pAlignerParam->GetProductIndex());			// (Level-2) 产品索引号
	m_XMLConfigator.AddElem(_T("AlignCustomName"), pAlignerParam->GetProductUserName());	// (Level-2) 产品用户自定义名称


	m_XMLConfigator.AddElem(_T("AlignMaxTime"), pAlignerParam->GetAlignerMaxTime());		// (Level-2) 
	m_XMLConfigator.AddElem(_T("AlignPrecision"));	// (Level-2) 
	m_XMLConfigator.EnterElem();
	pos = pAlignerParam->GetAlignerPrecision();
	m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-3) 
	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.AddElem(_T("SearchDelayTime"), pAlignerParam->GetSearchDelayTime());							// (Level-2) 
	m_XMLConfigator.AddElem(_T("ObjectSearchDelayTime"), pAlignerParam->GetObjectSearchDelayTime());				// (Level-2) 
	m_XMLConfigator.AddElem(_T("ObjectSearchDelayTime2"), pAlignerParam->GetObjectSearchDelayTime2());				// (Level-2) 
	m_XMLConfigator.AddElem(_T("EnableObjectSearchDelayTime2"), pAlignerParam->GetEnableObjectSearchDelayTime2());	// (Level-2)


	// 补偿设置（补偿的方向、X和Y补偿值对调）
	CProductOffsetInfo		productOffsetInfo;
	productOffsetInfo = pAlignerParam->GetProductOffsetInfo();
	m_XMLConfigator.AddElem(_T("ProductOffsetInfo"));																// (Level-2) 

	m_XMLConfigator.EnterElem();
	m_XMLConfigator.AddElem(_T("EnableProductOffsetXDirection"), productOffsetInfo.m_bEnableProductOffsetXDirection);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableProductOffsetYDirection"), productOffsetInfo.m_bEnableProductOffsetYDirection);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableProductOffsetDDirection"), productOffsetInfo.m_bEnableProductOffsetDDirection);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("EnableProductOffsetXSetting"), productOffsetInfo.m_bEnableProductOffsetXSetting);	// (Level-3)
	m_XMLConfigator.AddElem(_T("EnableProductOffsetYSetting"), productOffsetInfo.m_bEnableProductOffsetYSetting);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableProductOffsetDSetting"), productOffsetInfo.m_bEnableProductOffsetDSetting);	// (Level-3) 
	m_XMLConfigator.LeaveElem();

	// 补偿类型：平台补偿、Mark补偿
	m_XMLConfigator.AddElem(_T("AlignOffsetCoordType"), (int)pAlignerParam->GetAlignerOffsetCoordType());	// (Level-2) 

	// 对位基础补偿值
	m_XMLConfigator.AddElem(_T("AlignBaseOffset"));	// (Level-2) 
	m_XMLConfigator.EnterElem();
	pos = pAlignerParam->GetAlignerBaseOffset();
	m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-3) 
	m_XMLConfigator.LeaveElem();

	// 对位补偿值
	int nAlignOffsetNum = pAlignerParam->GetAlignerOffsetNum();
	for(int nAlignOffsetIndex = 0; nAlignOffsetIndex < nAlignOffsetNum; nAlignOffsetIndex++)
	{
		CString strElem;
		strElem.Format(_T("AlignOffset%d"), nAlignOffsetIndex);
		m_XMLConfigator.AddElem(strElem);	// (Level-2) 

		m_XMLConfigator.EnterElem();
		pos = pAlignerParam->GetAlignerOffset(nAlignOffsetIndex);	
		m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-3) 

		CString strTip = pAlignerParam->GetAlignerOffsetTip(nAlignOffsetIndex);
		m_XMLConfigator.AddElem(_T("Tip"),strTip);
		m_XMLConfigator.LeaveElem();
	}

	// 多次对位，目标补偿
	m_XMLConfigator.AddElem(_T("EnableAlnTargetOffset"), pAlignerParam->GetEnableAlnTargetOffset());					// (Level-2)
	m_XMLConfigator.AddElem(_T("EnableAlnSendTargetOffsetToPLC"), pAlignerParam->GetEnableAlnSendTargetOffsetToPLC());	// (Level-2)
	m_XMLConfigator.AddElem(_T("AlnTargetOffsetX"), pAlignerParam->GetAlnTargetOffsetX());								// (Level-2)
	m_XMLConfigator.AddElem(_T("AlnTargetOffsetY"), pAlignerParam->GetAlnTargetOffsetY());								// (Level-2)

	// 下料补偿
	int nAlignBenchOffsetNum = pAlignerParam->GetAlignerBenchOffsetNum();
	for(int nAlignBenchOffsetIndex = 0; nAlignBenchOffsetIndex < nAlignBenchOffsetNum; nAlignBenchOffsetIndex++)
	{
		CString strElem;
		pos = pAlignerParam->GetAlignerBenchOffset(nAlignBenchOffsetIndex);

		strElem.Format(_T("AlignBenchOffset%d"), nAlignBenchOffsetIndex);
		m_XMLConfigator.AddElem(strElem);	// (Level-2) 
		m_XMLConfigator.EnterElem();

		m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-3) 
		m_XMLConfigator.LeaveElem();

	}


	// 输入模式、检查模式
	vector<CAlignCheckInfo>		alignCheckInfo;
	alignCheckInfo = pAlignerParam->GetAlignCheckInfo();

	m_XMLConfigator.AddElem(_T("AlignCheckInfo"));	// (Level-2) 
	m_XMLConfigator.EnterElem();

	m_XMLConfigator.AddElem(_T("MultiCalibExtensionMaxNum"),(int)pAlignerParam->m_nMultiCalibExtensionMaxNum);

	CString strCheckInfo = _T("");
	for (int it =0; it < alignCheckInfo.size(); it++)
	{
		strCheckInfo.Format(_T("CheckInfo_%d"),it);
		m_XMLConfigator.AddElem((LPCTSTR)strCheckInfo);

		m_XMLConfigator.EnterElem();

		m_XMLConfigator.AddElem(_T("CheckTargetAndObjectDis"), (BOOL)alignCheckInfo.at(it).m_bCheckTargetAndObjectDis);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("CheckMode"), (int)alignCheckInfo.at(it).m_nCheckMode);	// (Level-3) 

		m_XMLConfigator.AddElem(_T("CheckTargetDis"), (BOOL)alignCheckInfo.at(it).m_bCheckTargetDis);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetDisThreshold"), alignCheckInfo.at(it).m_dTargetDisThreshold);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetDis0"), alignCheckInfo.at(it).m_dTargetDis0);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetDis1"), alignCheckInfo.at(it).m_dTargetDis1);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetDis2"), alignCheckInfo.at(it).m_dTargetDis2);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetDis3"), alignCheckInfo.at(it).m_dTargetDis3);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetDis4"), alignCheckInfo.at(it).m_dTargetDis4);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetDis5"), alignCheckInfo.at(it).m_dTargetDis5);	// (Level-3) 

		m_XMLConfigator.AddElem(_T("CheckObjectDis"), (int)alignCheckInfo.at(it).m_bCheckObjectDis);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectDisThreshold"), alignCheckInfo.at(it).m_dObjectDisThreshold);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectDis0"), alignCheckInfo.at(it).m_dObjectDis0);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectDis1"), alignCheckInfo.at(it).m_dObjectDis1);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectDis2"), alignCheckInfo.at(it).m_dObjectDis2);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectDis3"), alignCheckInfo.at(it).m_dObjectDis3);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectDis4"), alignCheckInfo.at(it).m_dObjectDis4);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectDis5"), alignCheckInfo.at(it).m_dObjectDis5);	// (Level-3) 

		m_XMLConfigator.AddElem(_T("CheckTargetAngle"), (BOOL)alignCheckInfo.at(it).m_bCheckTargetAngle);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetAngleThreshold"), alignCheckInfo.at(it).m_dTargetAngleThreshold);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetAngle0"), alignCheckInfo.at(it).m_dTargetAngle0);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetAngle1"), alignCheckInfo.at(it).m_dTargetAngle1);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetAngle2"), alignCheckInfo.at(it).m_dTargetAngle2);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetAngle3"), alignCheckInfo.at(it).m_dTargetAngle3);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetAngle4"), alignCheckInfo.at(it).m_dTargetAngle4);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("TargetAngle5"), alignCheckInfo.at(it).m_dTargetAngle5);	// (Level-3) 

		m_XMLConfigator.AddElem(_T("CheckObjectAngle"), (int)alignCheckInfo.at(it).m_bCheckObjectAngle);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectAngleThreshold"), alignCheckInfo.at(it).m_dObjectAngleThreshold);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectAngle0"), alignCheckInfo.at(it).m_dObjectAngle0);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectAngle1"), alignCheckInfo.at(it).m_dObjectAngle1);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectAngle2"), alignCheckInfo.at(it).m_dObjectAngle2);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectAngle3"), alignCheckInfo.at(it).m_dObjectAngle3);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectAngle4"), alignCheckInfo.at(it).m_dObjectAngle4);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("ObjectAngle5"), alignCheckInfo.at(it).m_dObjectAngle5);	// (Level-3) 

		m_XMLConfigator.LeaveElem();
	}
	m_XMLConfigator.LeaveElem();

	// 对位模式
	m_XMLConfigator.AddElem(_T("Aligner2Vs2Type"), (int)pAlignerParam->GetAligner2Vs2Type());				// (Level-2)
	m_XMLConfigator.AddElem(_T("Aligner3Vs3Type"), (int)pAlignerParam->GetAligner3Vs3Type());				// (Level-2) 
	m_XMLConfigator.AddElem(_T("Aligner4Vs4Type"), (int)pAlignerParam->GetAligner4Vs4Type());				// (Level-2) 
	m_XMLConfigator.AddElem(_T("Aligner5Vs5Type"), (int)pAlignerParam->GetAligner5Vs5Type());				// (Level-2) 
	m_XMLConfigator.AddElem(_T("Aligner6Vs6Type"), (int)pAlignerParam->GetAligner6Vs6Type());				// (Level-2) 

	// 圆孔对位
	m_XMLConfigator.AddElem(_T("AlignerWeight"), pAlignerParam->GetAlignerWeight());
	m_XMLConfigator.AddElem(_T("AlignerCirclePos"),pAlignerParam->GetAlignerCirclePos());

	m_XMLConfigator.AddElem(_T("AlignerMoveType"), (int)pAlignerParam->GetAlignerMoveType());				// (Level-2)
	m_XMLConfigator.AddElem(_T("AlignAngleVectical"),(int)pAlignerParam->GetEnableAlignAngleVectical());	// (Level-2)
	m_XMLConfigator.AddElem(_T("AlignAngleVecticalMode"),(int)pAlignerParam->GetAlignAngleVecticalMode());	// (Level-2)

	m_XMLConfigator.AddElem(_T("AlignAccordingToPickPlatformEnable"), pAlignerParam->GetAlignAccordingToPickPlatformEnable());

	// 对位偏差方向设置
	m_XMLConfigator.AddElem(_T("AlnOffsetReverseX"), pAlignerParam->GetEnableAlnOffsetReverseX());	// (Level-2)
	m_XMLConfigator.AddElem(_T("AlnOffsetReverseY"), pAlignerParam->GetEnableAlnOffsetReverseY());	// (Level-2)
	m_XMLConfigator.AddElem(_T("AlnOffsetReverseD"), pAlignerParam->GetEnableAlnOffsetReverseD());	// (Level-2)

	// 目标对象分属不同控制器，目标固定补偿功能
	m_XMLConfigator.AddElem(_T("EnableAlnTargetFixOffset"), pAlignerParam->GetEnableAlnTargetFixOffset());	// (Level-2)
	m_XMLConfigator.AddElem(_T("TargetFixOffsetType"), pAlignerParam->GetTargetOffsetType());	// (Level-2)
	for (i=0;i<ALIGNOFFSETNUM;i++)
	{
		CString strElem;
		strElem.Format(_T("AlnTargetFixOffset%d"), i);
		m_XMLConfigator.AddElem(strElem);	// (Level-2) 

		m_XMLConfigator.EnterElem();
		pos = pAlignerParam->GetAlnTargetFixOffset(i);
		m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-3) 
		m_XMLConfigator.LeaveElem();
	}

	// 对角Mark补偿方式
	m_XMLConfigator.AddElem(_T("PositionModeInfo"), pAlignerParam->GetPositionModeInfo());	// (Level-2)

	// 目标、对象产品尺寸虚拟，对角Mark补偿，设置产品尺寸
	CProductSizeInfo		productSizeInfo;
	productSizeInfo = pAlignerParam->GetProductSizeInfo();
	m_XMLConfigator.AddElem(_T("ProductSizeInfo"));	// (Level-2) 
	m_XMLConfigator.EnterElem();
	m_XMLConfigator.AddElem(_T("ObjectL1"), productSizeInfo.m_dObjectL1);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("ObjectW1"), productSizeInfo.m_dObjectW1);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("TargetL2"), productSizeInfo.m_dTargetL2);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("TargetW2"), productSizeInfo.m_dTargetW2);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("OffsetXYEnable"), productSizeInfo.m_bOffsetXYEnable);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("OffsetF1"), productSizeInfo.m_dF1);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("OffsetF2"), productSizeInfo.m_dF2);	// (Level-3) 
	m_XMLConfigator.LeaveElem();


	// 目标、对象产品尺寸虚拟功能
	CProductPositionVirtualInfo		productPositionVirtualInfo;
	productPositionVirtualInfo = pAlignerParam->GetProductPositionVirtualInfo();
	m_XMLConfigator.AddElem(_T("ProductPositionVirtualInfo"));	// (Level-2) 
	m_XMLConfigator.EnterElem();
	m_XMLConfigator.AddElem(_T("EnableObjectPositionVirtualMode"), productPositionVirtualInfo.m_bEnableObjectPositionVirtualMode);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableTargetPositionVirtualMode"), productPositionVirtualInfo.m_bEnableTargetPositionVirtualMode);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("ObjectPositionVirtualMode"), productPositionVirtualInfo.m_nObjectPositionVirtualMode);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("TargetPositionVirtualMode"), productPositionVirtualInfo.m_nTargetPositionVirtualMode);	// (Level-3) 
	m_XMLConfigator.LeaveElem();


	// 专用焊接参数
	CWeldInfo WeldInfo;
	WeldInfo = pAlignerParam->GetWeldInfo();
	m_XMLConfigator.AddElem(_T("WeldInfo"));	// (Level-2) 
	m_XMLConfigator.EnterElem();
	m_XMLConfigator.AddElem(_T("EnableWeld"),			WeldInfo.m_bEnableWeld);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("MovementRatioX"),		WeldInfo.m_WeldMovementRatio.m_dPosX);		// (Level-3) 
	m_XMLConfigator.AddElem(_T("MovementRatioY"),		WeldInfo.m_WeldMovementRatio.m_dPosY);		// (Level-3) 
	m_XMLConfigator.AddElem(_T("MovementRatioD"),		WeldInfo.m_WeldMovementRatio.m_dAngle);
	m_XMLConfigator.AddElem(_T("AmmendRatioX"),			WeldInfo.m_WeldAmmendMovementRatio.m_dPosX);		// (Level-3) 
	m_XMLConfigator.AddElem(_T("AmmendRatioY"),			WeldInfo.m_WeldAmmendMovementRatio.m_dPosY);		// (Level-3) 
	m_XMLConfigator.AddElem(_T("WeldTargetSearchTimes"),	WeldInfo.m_nWeldTargetSearchTimes);		// (Level-3) 
	m_XMLConfigator.AddElem(_T("WeldSearchBench"),			WeldInfo.m_nWeldSearchBench);			// (Level-3) 
	m_XMLConfigator.AddElem(_T("WeldAngleBench"),			WeldInfo.m_nWeldAngleBench);			// (Level-3) 
	m_XMLConfigator.LeaveElem();

	// 八字对位
	m_XMLConfigator.AddElem(_T("EnableEightShapeAlign"), pAlignerParam->GetEnableEightShapeAlign());	// (Level-2)
	m_XMLConfigator.AddElem(_T("EightShapeAlignMode"), pAlignerParam->GetEightShapeAlignMode());		// (Level-2)
	m_XMLConfigator.AddElem(_T("EightShapeAngle"), pAlignerParam->GetEightShapeAngle());				// (Level-2)


	// 折弯参数
	CBendInfo BendInfo;
	BendInfo = pAlignerParam->GetBendInfo();
	m_XMLConfigator.AddElem(_T("BendInfo"));
	m_XMLConfigator.EnterElem();

	// 折弯对位参数
	m_XMLConfigator.AddElem(_T("AlignBendInfo"));
	m_XMLConfigator.EnterElem();
	m_XMLConfigator.AddElem(_T("EnableBendInspect"),		BendInfo.m_bBendAlignInspect);					// (Level-3) 
	// 1
	m_XMLConfigator.AddElem(_T("BendType"),					BendInfo.m_bBendType);						// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendImageRadio"),			BendInfo.m_dBendImageRadio);				// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendAlignDmCode"),			BendInfo.m_bBendAlignDmCode);				// (Level-3) 
	// 2
	m_XMLConfigator.AddElem(_T("BendDisOffset"),			BendInfo.m_bBendDisOffset);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendTargetDisOffset"),		BendInfo.m_dBendTargetDisOffset);			// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendObjectDisOffset"),		BendInfo.m_dBendObjectDisOffset);			// (Level-3) 
	// 3
	m_XMLConfigator.AddElem(_T("BendResultOffset"),			BendInfo.m_bBendResultOffset);				// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendLeftDisOffsetX"),		BendInfo.m_scBendLeftDisOffset.GetX());		// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendLeftDisOffsetY"),		BendInfo.m_scBendLeftDisOffset.GetY());		// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendRightDisOffsetX"),		BendInfo.m_scBendRightDisOffset.GetX());	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendRightDisOffsetY"),		BendInfo.m_scBendRightDisOffset.GetY());	// (Level-3) 
	m_XMLConfigator.AddElem(_T("LeftDisOffset"),		BendInfo.m_dLeftDisOffset);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("RightDisOffset"),		BendInfo.m_dRightDisOffset);	// (Level-3) 
	// 4
	m_XMLConfigator.AddElem(_T("BendThreOffset"),			BendInfo.m_bBendThreOffset);				// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendStanderThreX"),			BendInfo.m_scBendStanderThre.GetX());		// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendStanderThreY"),			BendInfo.m_scBendStanderThre.GetY());		// (Level-3) 

	m_XMLConfigator.AddElem(_T("BendEnableFbsLRY"),			BendInfo.m_bEnableFbsLRY);				// (Level-3) 
	 
	// 5
	m_XMLConfigator.AddElem(_T("BendPressPara"),			BendInfo.m_bBendPressPara);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendPressParaWrite"),		BendInfo.m_bBendPressParaWrite);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendPressParaWriteAddre"),	BendInfo.m_lBendPressParaWriteAddre);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendPressOKYmin"),			BendInfo.m_dBendPressOKYmin);				// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendPressOKYmax"),			BendInfo.m_dBendPressOKYmax);				// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendPressNGYmin"),			BendInfo.m_dBendPressNGYmin);				// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendPressNGYmax"),			BendInfo.m_dBendPressNGYmax);				// (Level-3) 
	// 6
	m_XMLConfigator.AddElem(_T("BendLoadThre"),				BendInfo.m_bBendLoadThre);				// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendLoadThreX"),			BendInfo.m_scBendLoadThre.GetX());		// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendLoadThreY"),			BendInfo.m_scBendLoadThre.GetY());		// (Level-3) 
	// 7
	m_XMLConfigator.AddElem(_T("BendingInspect"),		BendInfo.m_bBendingInspect);					// (Level-3) 
	// 8
	m_XMLConfigator.AddElem(_T("BendingProductID"),		BendInfo.m_bBendingProductID);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendInspectDmCode"),		BendInfo.m_bBendInspectDmCode);				// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableReadWsInfo"),		BendInfo.m_bEnableReadWsInfo);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableReadInspectWsInfo"),		BendInfo.m_bEnableReadInspectWsInfo);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableReadStartTimeInfo"),		BendInfo.m_bEnableReadStartTimeInfo);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableReadEndTimeInfo"),		BendInfo.m_bEnableReadEndTimeInfo);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("EnableReadProsessingTimeInfo"),		BendInfo.m_bEnableReadProsessingTimeInfo);					// (Level-3) 

	//m_bEnableUseMathCaluLRDis
	m_XMLConfigator.AddElem(_T("EnableUseMathCaluLRDis"),		BendInfo.m_bEnableUseMathCaluLRDis);					// (Level-3) 

	m_XMLConfigator.AddElem(_T("BendingEnableMoveSnap"),		BendInfo.m_bEnableMoveSnap);					// (Level-3) 
	m_XMLConfigator.AddElem(_T("BendingPosIndexFisrt"),		BendInfo.m_nPosIndexFisrt);					// (Level-3) 

	m_XMLConfigator.AddElem(_T("EnableAxisMoveLimit"),			BendInfo.m_bEnableAxisMoveLimit);
	m_XMLConfigator.AddElem(_T("AxisAllowMoveMaxX"),			BendInfo.m_dAxisAllowMoveMaxX);
	m_XMLConfigator.AddElem(_T("AxisAllowMoveMaxY"),			BendInfo.m_dAxisAllowMoveMaxY);
	m_XMLConfigator.AddElem(_T("AxisAllowMoveMaxD"),			BendInfo.m_dAxisAllowMoveMaxD);

	m_XMLConfigator.AddElem(_T("BendInspectSnCodeLength"),			BendInfo.m_bBendInspectSnCodeLength);
	m_XMLConfigator.AddElem(_T("BendInspectSnCodeInvert"),			BendInfo.m_bBendInspectSnCodeInvert);
	m_XMLConfigator.AddElem(_T("BendInspectGetSnOnce"),			BendInfo.m_bBendInspectGetSnOnce);

	m_XMLConfigator.AddElem(_T("strPlatformName1"),			BendInfo.m_strPlatformName1);
	m_XMLConfigator.AddElem(_T("strPlatformName2"),			BendInfo.m_strPlatformName2);
	m_XMLConfigator.AddElem(_T("EnableFbisTarObc"),			(int)BendInfo.m_bEnableFbisTarObc);

	m_XMLConfigator.AddElem(_T("BendSendszGetName"),			BendInfo.m_dBendSendszGetName);
	m_XMLConfigator.AddElem(_T("BendSendAdsorptionSite"),			BendInfo.m_dBendSendAdsorptionSite);
	m_XMLConfigator.AddElem(_T("BendSendRAngle"),			BendInfo.m_dBendSendRAngle);
	m_XMLConfigator.AddElem(_T("BendSendCompensateY1"),			BendInfo.m_dBendSendCompensateY1);
	m_XMLConfigator.AddElem(_T("BendSendCompensateY2"),			BendInfo.m_dBendSendCompensateY2);
	m_XMLConfigator.AddElem(_T("BendSendCompensateY3"),			BendInfo.m_dBendSendCompensateY3);
	m_XMLConfigator.AddElem(_T("BendSendCompensateZ1"),			BendInfo.m_dBendSendCompensateZ1);
	m_XMLConfigator.AddElem(_T("BendSendCompensateZ2"),			BendInfo.m_dBendSendCompensateZ2);
	m_XMLConfigator.AddElem(_T("BendSendCompensateZ3"),			BendInfo.m_dBendSendCompensateZ3);


	m_XMLConfigator.LeaveElem();

	// 折弯检测标准
	m_XMLConfigator.AddElem(_T("BendInspectBaseInfo"));
	m_XMLConfigator.EnterElem();

	m_XMLConfigator.AddElem(_T("BaseLX"),				BendInfo.m_BendInspectRangeInfo.m_dRangeLX[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseLXLow"),			BendInfo.m_BendInspectRangeInfo.m_dRangeLX[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseLXHigh"),			BendInfo.m_BendInspectRangeInfo.m_dRangeLX[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseLY"),				BendInfo.m_BendInspectRangeInfo.m_dRangeLY[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseLYLow"),			BendInfo.m_BendInspectRangeInfo.m_dRangeLY[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseLYHigh"),			BendInfo.m_BendInspectRangeInfo.m_dRangeLY[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseLDis"),				BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseLDisLow"),			BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseLDisHigh"),			BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseRX"),				BendInfo.m_BendInspectRangeInfo.m_dRangeRX[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseRXLow"),			BendInfo.m_BendInspectRangeInfo.m_dRangeRX[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseRXHigh"),			BendInfo.m_BendInspectRangeInfo.m_dRangeRX[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseRY"),				BendInfo.m_BendInspectRangeInfo.m_dRangeRY[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseRYLow"),			BendInfo.m_BendInspectRangeInfo.m_dRangeRY[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseRYHigh"),			BendInfo.m_BendInspectRangeInfo.m_dRangeRY[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseRDis"),				BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseRDisLow"),			BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseRDisHigh"),			BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseTargetDis"),		BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseTargetDisLow"),		BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseTargetDisHigh"),	BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseObjectDis"),		BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseObjectDisLow"),		BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseObjectDisHigh"),	BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseSubtractX"),		BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseSubtractXLow"),		BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseSubtractXHigh"),	BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseSubtractY"),		BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseSubtractYLow"),		BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseSubtractYHigh"),	BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[2]);	// (Level-3) 

	//m_dDeltaY
	m_XMLConfigator.AddElem(_T("BaseDeltaY"),		BendInfo.m_BendInspectRangeInfo.m_dDeltaY[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseDeltaYLow"),		BendInfo.m_BendInspectRangeInfo.m_dDeltaY[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseDeltaYHigh"),	BendInfo.m_BendInspectRangeInfo.m_dDeltaY[2]);	// (Level-3) 
	m_XMLConfigator.LeaveElem();

	// 圆孔检测标准
	m_XMLConfigator.AddElem(_T("CircleInspectBaseInfo"));
	m_XMLConfigator.EnterElem();
	m_XMLConfigator.AddElem(_T("BaseCircleRadius"),		BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseCircleRadiusLow"),	BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseCircleRadiusHigh"),	BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[2]);	// (Level-3) 

	m_XMLConfigator.AddElem(_T("BaseCircleRadiusX"),		BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseCircleRadiusLowX"),	BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseCircleRadiusHighX"),	BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[2]);	// (Level-3)

	m_XMLConfigator.AddElem(_T("BaseCircleRadiusY"),		BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[0]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseCircleRadiusLowY"),	BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[1]);	// (Level-3) 
	m_XMLConfigator.AddElem(_T("BaseCircleRadiusHighY"),	BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[2]);	// (Level-3)
	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();


	// 拾取功能
	pBenchTargetMarkPickInfo = pAlignerParam->GetBenchTargetMarkPickInfo();

	if (pBenchTargetMarkPickInfo != NULL)
	{
		m_XMLConfigator.AddElem(_T("BenchTargetMarkPickInfo"));	// (Level-2) 
		m_XMLConfigator.EnterElem();

		nData = pBenchTargetMarkPickInfo->GetMarkNum();
		m_XMLConfigator.AddElem(_T("FiducialTargetNum"), nData);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("FiducialTargetImgCoord"));	// (Level-3) 

		m_XMLConfigator.EnterElem();
		for (i=0; i<nData; i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strInfo.Format(_T("Mark%d_%d"), m,i);
				m_XMLConfigator.AddElem(strInfo);	// (Level-4) 
				m_XMLConfigator.EnterElem();
				pos = pBenchTargetMarkPickInfo->GetMarkImageCoordPos(i,m);
				m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-5) 
				m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-5) 
				m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-5) 
				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();


		m_XMLConfigator.AddElem(_T("FiducialTargetPlatCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (i=0; i<nData; i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strInfo.Format(_T("Mark%d_%d"), m,i);
				m_XMLConfigator.AddElem(strInfo);	// (Level-4) 
				m_XMLConfigator.EnterElem();
				pos = pBenchTargetMarkPickInfo->GetMarkPlatformCoordPos(i,m);
				m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-5) 
				m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-5) 
				m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-5) 
				m_XMLConfigator.LeaveElem();
			}
		}
		m_XMLConfigator.LeaveElem();


		m_XMLConfigator.AddElem(_T("PlatAxisPos"));
		m_XMLConfigator.EnterElem();
		for (i=0;i<nData;i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strInfo.Format(_T("PlatAxisPos%d_%d"), m,i); 
				m_XMLConfigator.AddElem(strInfo);	// (Level-4) 
				m_XMLConfigator.EnterElem();
				pPlatformAxisPos = (CPlatformXYDAxisPos*)pBenchTargetMarkPickInfo->GetFixPlatformPos(i,m);
				if (pPlatformAxisPos == NULL)
				{
					pPlatformAxisPos = new CPlatformXYDAxisPos();
				}
				m_XMLConfigator.AddElem(_T("PlatType"), (int)pPlatformAxisPos->GetPlatformType());
				m_XMLConfigator.AddElem(_T("X"), pPlatformAxisPos->m_dPosX);		// (Level-4) 
				m_XMLConfigator.AddElem(_T("Y"), pPlatformAxisPos->m_dPosY);		// (Level-4) 
				m_XMLConfigator.AddElem(_T("D"), pPlatformAxisPos->m_dAngle);		// (Level-4)
				m_XMLConfigator.LeaveElem();

			}

		}
		m_XMLConfigator.LeaveElem();


		m_XMLConfigator.AddElem(_T("PickPlatAxisPos"));
		m_XMLConfigator.EnterElem();
		for (i=0;i<nData;i++)
		{
			for(int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strInfo.Format(_T("PlatAxisPos%d_%d"),m,i); 
				m_XMLConfigator.AddElem(strInfo);
				m_XMLConfigator.EnterElem();
				pPlatformAxisPos = (CPlatformXYDAxisPos*)pBenchTargetMarkPickInfo->GetPickPlatformPos(i,m);
				if (pPlatformAxisPos == NULL)
				{
					pPlatformAxisPos = new CPlatformXYDAxisPos();
				}
				m_XMLConfigator.AddElem(_T("PlatType"), (int)pPlatformAxisPos->GetPlatformType());	// (Level-4) 
				m_XMLConfigator.AddElem(_T("X"), pPlatformAxisPos->m_dPosX);		// (Level-4) 
				m_XMLConfigator.AddElem(_T("Y"), pPlatformAxisPos->m_dPosY);		// (Level-4) 
				m_XMLConfigator.AddElem(_T("D"), pPlatformAxisPos->m_dAngle);	// (Level-4)
				m_XMLConfigator.LeaveElem();

			}

		}
		m_XMLConfigator.LeaveElem();


		m_XMLConfigator.AddElem(_T("BenchPickPlatformOffset"));
		m_XMLConfigator.EnterElem();
		for (i=0;i<nData;i++)
		{
			for (int m=0;m<BENCH_FIX_POSNUM;m++)
			{
				strInfo.Format(_T("BenchPickPlatformOffset%d_%d"),m,i); 
				m_XMLConfigator.AddElem(strInfo);
				m_XMLConfigator.EnterElem();
				pos = pBenchTargetMarkPickInfo->GetPickPlatformOffset(i,m);

				m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);		// (Level-4) 
				m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);		// (Level-4) 
				m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);		// (Level-4)
				m_XMLConfigator.LeaveElem();
			}

		}
		m_XMLConfigator.LeaveElem();


		m_XMLConfigator.AddElem(_T("CamPlatAxisPos"));
		m_XMLConfigator.EnterElem();
		m_XMLConfigator.AddElem(_T("CamPlatType"), (int)m_pPlatformInfo->m_eCamPlatformType);
		if ((m_pPlatformInfo->m_eCamPlatformType != eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType != eCamPlatformUnknown))
		{
			for (i=0; i<nData; i++)
			{
				pCamPlatformAxisPos = pBenchTargetMarkPickInfo->GetFixCamPlatformPos(i);
				if (pCamPlatformAxisPos != NULL)
				{
					strInfo.Format(_T("Pos%d"), i); 
					m_XMLConfigator.AddElem(strInfo);	// (Level-4) 
					m_XMLConfigator.EnterElem();
					m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
					if (m_pPlatformInfo->m_eCamPlatformType == eCamPlatformSepXY)
					{
						m_XMLConfigator.AddElem(_T("Y"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);
					}
					m_XMLConfigator.LeaveElem();
				}
			}		
		}
		m_XMLConfigator.LeaveElem();	

		m_XMLConfigator.AddElem(_T("Valid"), pBenchTargetMarkPickInfo->IsValid());

		m_XMLConfigator.LeaveElem();	
	}

	// 分区域补偿功能
	m_XMLConfigator.AddElem(_T("AlignOffsetByArea"));			// (level-2)
	m_XMLConfigator.EnterElem();
	m_XMLConfigator.AddElem(_T("Enable"), pAlignerParam->m_AlignOffsetByArea.m_bEnable);
	m_XMLConfigator.AddElem(_T("AreaRowNum"), pAlignerParam->m_AlignOffsetByArea.m_nAreaRow);
	m_XMLConfigator.AddElem(_T("AreaColNum"), pAlignerParam->m_AlignOffsetByArea.m_nAreaCol);
	m_XMLConfigator.AddElem(_T("SearchStartX"), pAlignerParam->m_AlignOffsetByArea.m_dSearchStartX);
	m_XMLConfigator.AddElem(_T("SearchStartY"), pAlignerParam->m_AlignOffsetByArea.m_dSearchStartY);
	m_XMLConfigator.AddElem(_T("SearchWidth"), pAlignerParam->m_AlignOffsetByArea.m_dSearchWidth);
	m_XMLConfigator.AddElem(_T("SearchHeight"), pAlignerParam->m_AlignOffsetByArea.m_dSearchHeight);
	m_XMLConfigator.AddElem(_T("SearchType"), pAlignerParam->m_AlignOffsetByArea.m_nSearchType);
	m_XMLConfigator.LeaveElem();

	//指令光源控制参数
	PhotoLightCtrlSet cObj = pAlignerParam->GetLightCtrlInfo();
	m_XMLConfigator.AddElem(_T("CMDLightCtrlInfo"));			// (level-2)
	m_XMLConfigator.EnterElem();
	for (int i =0;i < cObj.m_nCmdSum;++i)//支持指令
	{
		CurCMDPhotoLightCtrlSet cChild = cObj.m_vCmdLightCtrlInfo[i];
		m_XMLConfigator.AddElem(cObj.m_vCmd[i]);
		m_XMLConfigator.EnterElem();
		for (int j =0;j < 8;++j) //控制器
		{
			CString str;
			str.Format(_T("LightCtrl%d"),j+1);
			m_XMLConfigator.AddElem(str);
			m_XMLConfigator.EnterElem();
			{
				m_XMLConfigator.AddElem(_T("CtrlEnable"),(int)(cChild.m_vCmdLightCtrlEnable[j]));
				std::vector<BOOL> vChannelCtrlIndex = cChild.m_vbChannelCtrlIndex[j];
				std::vector<BOOL> vChannelOnorOff = cChild.m_vbChannelOnorOff[j];
				for (int k =0;k < 8;++k) //通道
				{
					str.Format(_T("Channel%d"),k+1); //通道启用
					m_XMLConfigator.AddElem(str,(int)(vChannelCtrlIndex[k]));
					str.Format(_T("Channel%dOnOrOff"),k+1);//通道亮灭
					m_XMLConfigator.AddElem(str,(int)(vChannelOnorOff[k]));		
				}
			}
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();
	}
	m_XMLConfigator.LeaveElem();

	// 基准Mark修正
	m_XMLConfigator.AddElem(_T("FiducialTargetDefineEnable"), (int)pAlignerParam->GetBenchTargetMarkFixEnable());
	if (pAlignerParam->GetBenchTargetMarkFixEnable())	
	{
		m_XMLConfigator.AddElem(_T("FiducialTargetDefineInfo"));	// (Level-2) 
		m_XMLConfigator.EnterElem();
		pBenchTargetMarkFixInfo = pAlignerParam->GetBenchTargetMarkFixInfo();
		if (pBenchTargetMarkFixInfo == NULL)
		{
			return FALSE;
		}
		nData = pBenchTargetMarkFixInfo->GetMarkNum();
		m_XMLConfigator.AddElem(_T("FiducialTargetNum"), nData);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("FiducialTargetImgCoord"));	// (Level-3) 
		m_XMLConfigator.EnterElem();
		for (i=0; i<nData; i++)
		{
			strInfo.Format(_T("Mark%d"), i);
			m_XMLConfigator.AddElem(strInfo);	// (Level-4) 
			m_XMLConfigator.EnterElem();
			pos = pBenchTargetMarkFixInfo->GetMarkImageCoordPos(i);
			m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-5) 
			m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-5) 
			m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-5) 
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();
		m_XMLConfigator.AddElem(_T("FiducialTargetPlatCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (i=0; i<nData; i++)
		{
			strInfo.Format(_T("Mark%d"), i);
			m_XMLConfigator.AddElem(strInfo);	// (Level-4) 
			m_XMLConfigator.EnterElem();
			pos = pBenchTargetMarkFixInfo->GetMarkPlatformCoordPos(i);
			m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-5) 
			m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-5) 
			m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-5) 
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();
		m_XMLConfigator.AddElem(_T("PlatAxisPos"));
		m_XMLConfigator.EnterElem();
		//////////////////////////////////////////////////////////////////////////
		for (i=0;i<nData;i++)
		{
			strInfo.Format(_T("PlatAxisPos%d"), i); 
			m_XMLConfigator.AddElem(strInfo);	// (Level-4) 
			m_XMLConfigator.EnterElem();
			pPlatformAxisPos = (CPlatformXYDAxisPos*)pBenchTargetMarkFixInfo->GetFixPlatformPos(i);
			if (pPlatformAxisPos == NULL)
			{
				return FALSE;
			}
			m_XMLConfigator.AddElem(_T("PlatType"), (int)pPlatformAxisPos->GetPlatformType());	// (Level-4) 
			m_XMLConfigator.AddElem(_T("X"), pPlatformAxisPos->m_dPosX);		// (Level-4) 
			m_XMLConfigator.AddElem(_T("Y"), pPlatformAxisPos->m_dPosY);		// (Level-4) 
			m_XMLConfigator.AddElem(_T("D"), pPlatformAxisPos->m_dAngle);	// (Level-4)
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();
		//////////////////////////////////////////////////////////////////////////

		m_XMLConfigator.AddElem(_T("CamPlatAxisPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		m_XMLConfigator.AddElem(_T("CamPlatType"), (int)m_pPlatformInfo->m_eCamPlatformType); // (Level-4) 
		if ((m_pPlatformInfo->m_eCamPlatformType != eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType != eCamPlatformUnknown))
		{
			for (i=0; i<nData; i++)
			{
				pCamPlatformAxisPos = pBenchTargetMarkFixInfo->GetFixCamPlatformPos(i);
				if (pCamPlatformAxisPos != NULL)
				{
					strInfo.Format(_T("Pos%d"), i); 
					m_XMLConfigator.AddElem(strInfo);	// (Level-4) 
					m_XMLConfigator.EnterElem();
					m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-5) 
					if (m_pPlatformInfo->m_eCamPlatformType == eCamPlatformSepXY)
					{
						m_XMLConfigator.AddElem(_T("Y"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);	// (Level-5) 
					}
					m_XMLConfigator.LeaveElem();
				}
			}		
		}
		m_XMLConfigator.LeaveElem();	
		m_XMLConfigator.AddElem(_T("Valid"), pBenchTargetMarkFixInfo->IsValid());	// (Level-3)

		m_XMLConfigator.LeaveElem();
	}	

	// 目标模板
	m_XMLConfigator.AddElem(_T("TargetType"), (int)pAlignerParam->GetTargetMarkType());						// (Level-2) 
	m_XMLConfigator.AddElem(_T("TargetPatNum"), pAlignerParam->GetTargetMarkPatternNum());					// (Level-2) 
	m_XMLConfigator.AddElem(_T("TargetCandidateEnable"), (int)pAlignerParam->GetTargetCandidateEnable());	// (Level-2) 
	m_XMLConfigator.AddElem(_T("TargetCandidateSync"), (int)pAlignerParam->GetTargetCandidateSyncEnable());	// (Level-2) 
	int nTargetCandidateOffsetNum = pAlignerParam->GetTargetCandidateOffsetNum();
	for(i = 0; i < nTargetCandidateOffsetNum; i++)
	{
		CString strElem;
		strElem.Format(_T("TargetCandidateOffset%d"), i);
		m_XMLConfigator.AddElem(strElem);	// (Level-2) 

		m_XMLConfigator.EnterElem();
		pos = pAlignerParam->GetTargetCandidateOffset(i);
		m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("Enable"), (int)pAlignerParam->GetTargetCandidateOffsetEnable(i));	// (Level-3) 
		m_XMLConfigator.LeaveElem();
	}


	// 对象模板
	m_XMLConfigator.AddElem(_T("ObjectType"), (int)pAlignerParam->GetObjectMarkType());	// (Level-2) 
	m_XMLConfigator.AddElem(_T("ObjectPatNum"), pAlignerParam->GetObjectMarkPatternNum());	// (Level-2)
	m_XMLConfigator.AddElem(_T("ObjectCandidateEnable"), (int)pAlignerParam->GetObjectCandidateEnable());	// (Level-2) 
	m_XMLConfigator.AddElem(_T("ObjectCandidateSync"), (int)pAlignerParam->GetObjectCandidateSyncEnable());	// (Level-2) 
	int nObjectCandidateOffsetNum = pAlignerParam->GetObjectCandidateOffsetNum();
	for(i = 0; i < nObjectCandidateOffsetNum; i++)
	{
		CString strElem;
		strElem.Format(_T("ObjectCandidateOffset%d"), i);
		m_XMLConfigator.AddElem(strElem);	// (Level-2) 
		m_XMLConfigator.EnterElem();

		pos = pAlignerParam->GetObjectCandidateOffset(i);
		m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-3) 
		m_XMLConfigator.AddElem(_T("Enable"), (int)pAlignerParam->GetObjectCandidateOffsetEnable(i));	// (Level-3) 
		m_XMLConfigator.LeaveElem();
	}


	// 虚拟对象
	m_XMLConfigator.AddElem(_T("VObjectEnable"), pAlignerParam->GetVirtualObjectMarkEnable());	// (Level-2)
	if (m_pPlatformInfo->m_eAlignerObjectType == eObjectVirtual)
	{
		nData = pAlignerParam->GetVirtualObjectMarkPatternNum();
		m_XMLConfigator.AddElem(_T("VObjectPatNum"), nData);	// (Level-2)
		m_XMLConfigator.AddElem(_T("VObjectOffset"));	// (Level-2)
		m_XMLConfigator.EnterElem();
		for (j=0; j<nData; j++)
		{
			strInfo.Format(_T("Offset%d"), j);	// (Level-3)
			m_XMLConfigator.AddElem(strInfo);

			m_XMLConfigator.EnterElem();
			pos = pAlignerParam->GetVirtualObjectMarkOffset(j);
			m_XMLConfigator.AddElem(_T("X"), pos.m_dPosX);	// (Level-4) 
			m_XMLConfigator.AddElem(_T("Y"), pos.m_dPosY);	// (Level-4) 
			m_XMLConfigator.AddElem(_T("D"), pos.m_dAngle);	// (Level-4) 
			m_XMLConfigator.LeaveElem();
		}
		m_XMLConfigator.LeaveElem();
	}

	// 关联模板
	//	m_XMLConfigator.AddElem(_T("TargetObjectCamSeparateEnable"), pAlignerParam->GetTargetObjectCamSeparateEnable());		// (Level-2)
	m_XMLConfigator.AddElem(_T("CalibTargetMarkPatternNum"), pAlignerParam->GetCalibTargetMarkPatternNum());				// (Level-2)
	m_XMLConfigator.AddElem(_T("CalibTargetMarkEnable"), pAlignerParam->GetCalibTargetMarkEnable());						// (Level-2)
	m_XMLConfigator.AddElem(_T("CalibTargetMarkPatternMode"), pAlignerParam->GetCalibTargetMarkPatternMode());				// (Level-2)
	m_XMLConfigator.AddElem(_T("CalibTargetDMCodeOutLineEnable"), pAlignerParam->GetCalibTargetDMCodeOutLineEnable());		// (Level-2)
	m_XMLConfigator.AddElem(_T("CalibTargetDMCodeOutLinePercent"), pAlignerParam->GetCalibTargetDMCodeOutLinePercent());	// (Level-2)


	// 检测模板
	//	m_XMLConfigator.AddElem(_T("SysPlatformInspectEnable"), pAlignerParam->GetSysPlatformInspectEnable());	
	m_XMLConfigator.AddElem(_T("InspectCandidateEnable"), pAlignerParam->GetInspectCandidateEnable());
	m_XMLConfigator.AddElem(_T("InspectCandidateSyncEnable"), pAlignerParam->GetInspectCandidateSyncEnable());
	m_XMLConfigator.AddElem(_T("InspectSingleSearchEnable"), pAlignerParam->GetInspectSingleSearchEnable());
	//	m_XMLConfigator.AddElem(_T("InsepctMarkPatternNum"), pAlignerParam->GetInspectMarkPatternNum());

	int nInspectCandidateOffsetNum = pAlignerParam->GetInspectCandidateOffsetNum();
	for(i = 0; i < nInspectCandidateOffsetNum; i++)
	{
		CString strElem;
		strElem.Format(_T("InspectCandidateOffset%d"), i);
		m_XMLConfigator.AddElem(strElem);	// (Level-2) 
		m_XMLConfigator.EnterElem();
		m_XMLConfigator.AddElem(_T("Enable"), (int)pAlignerParam->GetInspectCandidateOffsetEnable(i));	// (Level-3) 
		m_XMLConfigator.LeaveElem();
	}



	// 模板曝光
	// Target
	m_XMLConfigator.AddElem(_T("AllTargetSearchShutter"));
	m_XMLConfigator.EnterElem();

	for (int j = 0; j < TARGETCANDIDATENUM; j++)
	{
		strInfo.Format(_T("TargetShutterEnable%d"),j);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}

		m_XMLConfigator.EnterElem();
		pAlignerParam->m_vbTargetSearchShutter[j].SaveModelToFile(m_XMLConfigator);
		m_XMLConfigator.LeaveElem();
	}

	for (int i = 0; i < GetPosNum(); i++)
	{	
		for (int j = 0; j < TARGETCANDIDATENUM; j++)
		{
			strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);
			if(FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vvdTargetSearchShutter[i][j].SaveModelToFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}
	}
	m_XMLConfigator.LeaveElem();


	// Object
	m_XMLConfigator.AddElem(_T("AllObjectSearchShutter"));
	m_XMLConfigator.EnterElem();

	for (int j = 0; j < OBJECTCANDIDATENUM; j++)
	{
		strInfo.Format(_T("ObjectShutterEnable%d"),j);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}

		m_XMLConfigator.EnterElem();
		pAlignerParam->m_vbObjectSearchShutter[j].SaveModelToFile(m_XMLConfigator);
		m_XMLConfigator.LeaveElem();
	}

	for (int i = 0; i < GetPosNum(); i++)
	{		
		for (int j = 0; j < OBJECTCANDIDATENUM; j++)
		{
			strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);
			if(FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vvdObjectSearchShutter[i][j].SaveModelToFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}

	}
	m_XMLConfigator.LeaveElem();


	// VirtualObject
	m_XMLConfigator.AddElem(_T("AllVirtualObjectSearchShutter"));
	m_XMLConfigator.EnterElem();

	for (int j = 0; j < OBJECTCANDIDATENUM; j++)
	{
		strInfo.Format(_T("VirtualObjectShutterEnable%d"),j);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}

		m_XMLConfigator.EnterElem();
		pAlignerParam->m_vbVirtualObjectSearchShutter[j].SaveModelToFile(m_XMLConfigator);
		m_XMLConfigator.LeaveElem();
	}

	for (int i = 0; i < GetPosNum(); i++)
	{		
		for (int j = 0; j < OBJECTCANDIDATENUM; j++)
		{
			strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);
			if(FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vvdVirtualObjectSearchShutter[i][j].SaveModelToFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}

	}
	m_XMLConfigator.LeaveElem();


	// CalibTarget
	m_XMLConfigator.AddElem(_T("AllCalibTargetSearchShutter"));
	m_XMLConfigator.EnterElem();

	for (int j = 0; j < OBJECTCANDIDATENUM; j++)
	{
		strInfo.Format(_T("CalibTargetShutterEnable%d"),j);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}

		m_XMLConfigator.EnterElem();
		pAlignerParam->m_vbCalibTargetSearchShutter[j].SaveModelToFile(m_XMLConfigator);
		m_XMLConfigator.LeaveElem();
	}

	for (int i = 0; i < GetPosNum(); i++)
	{	
		for (int j = 0; j < OBJECTCANDIDATENUM; j++)
		{
			strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);
			if(FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vvdCalibTargetSearchShutter[i][j].SaveModelToFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}
	}
	m_XMLConfigator.LeaveElem();


	// Inspect
	m_XMLConfigator.AddElem(_T("AllInspectSearchShutter"));
	m_XMLConfigator.EnterElem();

	for (int j = 0; j < INSPECTCANDIDATENUM; j++)
	{
		strInfo.Format(_T("InspectShutterEnable%d"),j);
		if(FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}
		m_XMLConfigator.EnterElem();
		pAlignerParam->m_vbInspectSearchShutter[j].SaveModelToFile(m_XMLConfigator);
		m_XMLConfigator.LeaveElem();
	}

	for (int i = 0; i < GetPosNum(); i++)
	{		
		for (int j = 0; j < INSPECTCANDIDATENUM; j++)
		{
			strInfo.Format(_T("PatIndex%d_CandIndex%d"), i, j);
			if(FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}

			m_XMLConfigator.EnterElem();
			pAlignerParam->m_vvdInspectSearchShutter[i][j].SaveModelToFile(m_XMLConfigator);
			m_XMLConfigator.LeaveElem();
		}

	}
	m_XMLConfigator.LeaveElem();



	m_XMLConfigator.AddElem(_T("TargetPosPatInfo"));	// (level-2)
	m_XMLConfigator.EnterElem();
	nData = pAlignerParam->m_vTargetPosPatInfo.size();
	m_XMLConfigator.AddElem(_T("PosNum"), nData);	// (level-3)
	for (i=0; i<nData; i++)
	{
		CString strName;
		strName.Format(_T("PosPatInfo_%d"), i);
		m_XMLConfigator.AddElem(strName);	// (Level-3)
		m_XMLConfigator.EnterElem();

		CPosPatInfo posPatInfo = pAlignerParam->m_vTargetPosPatInfo[i];
		m_XMLConfigator.AddElem(_T("Index"), posPatInfo.m_nIndex);		// (Level-4)
		m_XMLConfigator.AddElem(_T("IsSelected"), posPatInfo.m_bIsSelected);	// (Level-4)
		m_XMLConfigator.AddElem(_T("PatternNum"), posPatInfo.m_nPatNum);		// (Level-4)
		m_XMLConfigator.AddElem(_T("PatSelected"), posPatInfo.m_nPatSelected);	// (Level-4)

		m_XMLConfigator.AddElem(_T("vShutter"));		// (Level-4)
		m_XMLConfigator.EnterElem();
		for (int k=0; k<posPatInfo.m_nPatNum; k++)
		{
			strName.Format(_T("Shutter_%d"), k);
			m_XMLConfigator.AddElem(strName, posPatInfo.m_vdShutter[k]);	// (Level-5)
		}
		m_XMLConfigator.LeaveElem();

		m_XMLConfigator.LeaveElem();
	}
	m_XMLConfigator.LeaveElem();


	m_XMLConfigator.AddElem(_T("ObjectPosPatInfo"));	// (level-2)
	m_XMLConfigator.EnterElem();
	nData = pAlignerParam->m_vObjectPosPatInfo.size();
	m_XMLConfigator.AddElem(_T("PosNum"), nData);	// (level-3)
	for (i=0; i<nData; i++)
	{
		CString strName;
		strName.Format(_T("PosPatInfo_%d"), i);
		m_XMLConfigator.AddElem(strName);	// (Level-3)
		m_XMLConfigator.EnterElem();

		CPosPatInfo posPatInfo = pAlignerParam->m_vObjectPosPatInfo[i];
		m_XMLConfigator.AddElem(_T("Index"), posPatInfo.m_nIndex);		// (Level-4)
		m_XMLConfigator.AddElem(_T("IsSelected"), posPatInfo.m_bIsSelected);	// (Level-4)
		m_XMLConfigator.AddElem(_T("PatternNum"), posPatInfo.m_nPatNum);		// (Level-4)
		m_XMLConfigator.AddElem(_T("PatSelected"), posPatInfo.m_nPatSelected);	// (Level-4)

		m_XMLConfigator.AddElem(_T("vShutter"));		// (Level-4)
		m_XMLConfigator.EnterElem();
		for (int k=0; k<posPatInfo.m_nPatNum; k++)
		{
			strName.Format(_T("Shutter_%d"), k);
			m_XMLConfigator.AddElem(strName, posPatInfo.m_vdShutter[k]);	// (Level-5)
		}
		m_XMLConfigator.LeaveElem();

		m_XMLConfigator.LeaveElem();
	}
	m_XMLConfigator.LeaveElem();


	m_XMLConfigator.LeaveElem();			// (Level-1) 对位信息


	// 二维码参数
	if(FALSE == m_XMLConfigator.FindElem(_T("CalibDMcodeParam")))
	{
		m_XMLConfigator.AddElem(_T("CalibDMcodeParam"));
	}
	m_XMLConfigator.EnterElem();
	for (i=0;i<product.m_vDMcodeCalib.size();i++)
	{
		scDMCodeParam dmCodeParam = product.m_vDMcodeCalib.at(i);
		CString strName;
		strName.Format(_T("DMcodeParam%d"),i);
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.EnterElem();


		strName.Format("SearchShutter");
		m_XMLConfigator.AddElem(strName,dmCodeParam.m_dShutter);

		strName.Format("ImageWidth");
		m_XMLConfigator.AddElem(strName,dmCodeParam.m_dImageWidth);

		strName.Format("ImageHeight");
		m_XMLConfigator.AddElem(strName,dmCodeParam.m_dImageHeight);


		strName.Format("CalibDMCodeSearchRect");
		m_XMLConfigator.AddElem(strName);
		m_XMLConfigator.EnterElem();
		{
			strName.Format("OriginX");
			m_XMLConfigator.AddElem(strName,dmCodeParam.m_DmCodeSearchRect.GetOrigin().GetX());
			strName.Format("OriginY");
			m_XMLConfigator.AddElem(strName,dmCodeParam.m_DmCodeSearchRect.GetOrigin().GetY());
			strName.Format("SizeX");
			m_XMLConfigator.AddElem(strName,dmCodeParam.m_DmCodeSearchRect.GetWidth());
			strName.Format("SizeY");
			m_XMLConfigator.AddElem(strName,dmCodeParam.m_DmCodeSearchRect.GetHeight());
		}
		m_XMLConfigator.LeaveElem();

		strName.Format("CalibCornersSearchRect");
		m_XMLConfigator.AddElem(strName);
		m_XMLConfigator.EnterElem();
		{
			strName.Format("OriginX");
			m_XMLConfigator.AddElem(strName,dmCodeParam.m_CornersSearchRect.GetOrigin().GetX());
			strName.Format("OriginY");
			m_XMLConfigator.AddElem(strName,dmCodeParam.m_CornersSearchRect.GetOrigin().GetY());
			strName.Format("SizeX");
			m_XMLConfigator.AddElem(strName,dmCodeParam.m_CornersSearchRect.GetWidth());
			strName.Format("SizeY");
			m_XMLConfigator.AddElem(strName,dmCodeParam.m_CornersSearchRect.GetHeight());
		}
		m_XMLConfigator.LeaveElem();

		strName.Format("CalibDMCodeGridSize");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindCornerPara.m_dGridSize);

		strName.Format("CalibDMCodeGridThre");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindCornerPara.m_dGridThre);

		strName.Format("CalibDMCodeOutputOutPoints");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindCornerPara.m_bOutputOutPoints);

		strName.Format("CalibDMCodeMaxNum");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindDMCodePara.m_nMaxCodeNum);

		strName.Format("CalibDMCodeMaxTime");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindDMCodePara.m_nWaitingTime);

		strName.Format("CalibDMCodeMirror");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData((int)dmCodeParam.m_FindDMCodePara.m_modeMirror);

		strName.Format("DecodeMethod");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData((int)dmCodeParam.m_FindDMCodePara.m_methodDecode);

		strName.Format("AppMode");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData((int)dmCodeParam.m_FindDMCodePara.m_modeApp);

		strName.Format("DiscreteFlag");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData((int)dmCodeParam.m_FindDMCodePara.m_flagDiscrete);

		strName.Format("DistortionFlag");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData((int)dmCodeParam.m_FindDMCodePara.m_flagDistortion);

		strName.Format("PolarityMode");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData((int)dmCodeParam.m_FindDMCodePara.m_modePolarity);

		strName.Format("RectangleFlag");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData((int)dmCodeParam.m_FindDMCodePara.m_flagRectangle);

		strName.Format("MinBarSize");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindDMCodePara.m_nMinBarSize);

		strName.Format("MaxBarSize");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindDMCodePara.m_nMaxBarSize);

		strName.Format("SampleLevel");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindDMCodePara.m_nSampleLevel);

		strName.Format("DebugFlag");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindDMCodePara.m_nDebugFlag);

		strName.Format("AdvanceParam");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindDMCodePara.m_nAdvanceParam);

		strName.Format("AdvanceParam2");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_FindDMCodePara.m_nAdvanceParam2);


		strName.Format("CalibDMCodeRecode");
		if(FALSE == m_XMLConfigator.FindElem(strName))
		{
			m_XMLConfigator.AddElem(strName);
		}
		m_XMLConfigator.SetElemData(dmCodeParam.m_bEnableReDecode);

		m_XMLConfigator.LeaveElem();
	}
	m_XMLConfigator.LeaveElem();


	//////////////////////////////////////////////////////////////////////////
	// 机器人示教信息
	CRobotTeachInfo robotTeachInfo;
	robotTeachInfo = product.m_RobotTeachInfo;
	m_XMLConfigator.AddElem(_T("RobotTeachInfo"));	// (Level-1)
	m_XMLConfigator.EnterElem();  //2级目录

	// 手动移动速度
	strInfo.Format(_T("MSpeed"));
	m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_nMSpeed);// (Level-2)
	// 示教点信息
	for(i = 0; i < RobotTeachPosTotalMaxNum && i < robotTeachInfo.m_vrpRobotTeachPos.size(); i++)
	{
		strInfo.Format(_T("TeachPosInfo%d"),i);
		m_XMLConfigator.AddElem(strInfo);// (Level-2)

		m_XMLConfigator.EnterElem();  //3级目录
		strInfo.Format(_T("X"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vrpRobotTeachPos[i].m_dPosX);
		strInfo.Format(_T("Y"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vrpRobotTeachPos[i].m_dPosY);
		strInfo.Format(_T("R"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vrpRobotTeachPos[i].m_dPosR);
		strInfo.Format(_T("Z"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vrpRobotTeachPos[i].m_dPosZ);
		strInfo.Format(_T("A"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vrpRobotTeachPos[i].m_dPosA);
		strInfo.Format(_T("B"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vrpRobotTeachPos[i].m_dPosB);
		strInfo.Format(_T("CT"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vrpRobotTeachPos[i].m_nCoordType);
		strInfo.Format(_T("Valid"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vbRobotTearchPosValid[i]);

		m_XMLConfigator.LeaveElem();  //3级目录
	}

	// 整型常量信息
	for(i = 0; i < RobotTeachSGIntMaxNum && i < robotTeachInfo.m_vnRobotTeachSGInt.size(); i++)
	{
		strInfo.Format(_T("TeachSGIntInfo%d"),i);
		m_XMLConfigator.AddElem(strInfo);// (Level-2)

		m_XMLConfigator.EnterElem();  //3级目录

		strInfo.Format(_T("Val"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vnRobotTeachSGInt[i]);

		strInfo.Format(_T("Valid"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vbRobotTeachSGIntValid[i]);

		m_XMLConfigator.LeaveElem();  //3级目录	
	}

	// 实数常量信息
	for(i = 0; i < RobotTeachSGRealMaxNum && i < robotTeachInfo.m_vdRobotTeachSGReal.size(); i++)
	{
		strInfo.Format(_T("TeachSGRealInfo%d"),i);
		m_XMLConfigator.AddElem(strInfo);// (Level-2)

		m_XMLConfigator.EnterElem();  //3级目录

		strInfo.Format(_T("Val"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vdRobotTeachSGReal[i]);

		strInfo.Format(_T("Valid"));
		m_XMLConfigator.AddElem(strInfo, robotTeachInfo.m_vbRobotTeachSGRealValid[i]);

		m_XMLConfigator.LeaveElem();  //3级目录	
	}

	m_XMLConfigator.LeaveElem();  //2级目录
	//////////////////////////////////////////////////////////////////////////


	// 标定后参数（与平台相关）
	m_XMLConfigator.AddElem(_T("CalibedResult"));	// (Level-1)
	m_XMLConfigator.EnterElem();
	nData = product.m_vpCalibratedInfo.size();
	for (i=0; i<nData; i++)
	{
		pCalibratedInfo = product.m_vpCalibratedInfo.at(i);

		strInfo.Format(_T("CalibedResult%d"), i);
		m_XMLConfigator.AddElem(strInfo);

		m_XMLConfigator.EnterElem();
		m_XMLConfigator.AddElem(_T("Valid"));	
		m_XMLConfigator.SetElemData(pCalibratedInfo->m_bValid);

		//  1. 标定时，图像坐标系到平台坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("PlatTM"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		mat = pCalibratedInfo->GetPlatformTransferMatrix();
		m_XMLConfigator.AddElem(_T("A00"), mat.GetElement(0, 0));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A01"), mat.GetElement(0, 1));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A10"), mat.GetElement(1, 0));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A11"), mat.GetElement(1, 1));	// (Level-4)
		m_XMLConfigator.LeaveElem();

		//  2. 标定时，图像坐标系到平台坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("PlatTMH"));	
		m_XMLConfigator.EnterElem();  //4级目录打开
		for(j = 0; j < 9; j++)
		{
			strInfo.Format(_T("h%d"), j);				
			m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH[j]);			
		}
		m_XMLConfigator.LeaveElem(); //4级目录关闭

		// 3. 全局靶标标定时，图像坐标系到靶标坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("PlatTMH1"));	
		m_XMLConfigator.EnterElem();  //4级目录打开
		for(j = 0; j < 9; j++)
		{
			strInfo.Format(_T("h1%d"), j);				
			m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH1[j]);			
		}
		m_XMLConfigator.LeaveElem(); //4级目录关闭

		//  4. 全局靶标标定时，靶标坐标系到平台坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("PlatTMH2"));	
		m_XMLConfigator.EnterElem();  //4级目录打开
		for(j = 0; j < 9; j++)
		{
			strInfo.Format(_T("h2%d"), j);				
			m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH2[j]);			
		}
		m_XMLConfigator.LeaveElem(); //4级目录关闭


		// 5. 畸变校正结果
		m_XMLConfigator.AddElem(_T("DistorCorrResult"));
		m_XMLConfigator.EnterElem();
		double dResult[15];
		double dRms = pCalibratedInfo->m_result.GetRMS();
		pCalibratedInfo->m_result.GetNonlinearProjectResult(dResult);
		for(j = 0; j < 15; j++)
		{
			strInfo.Format(_T("p%d"), j);
			if (FALSE == m_XMLConfigator.FindElem(strInfo))
			{
				m_XMLConfigator.AddElem(strInfo);
			}				
			m_XMLConfigator.SetElemData(dResult[j]);					   
		}
		strInfo.Format(_T("RMS"));
		if (FALSE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.AddElem(strInfo);
		}				
		m_XMLConfigator.SetElemData(dRms);	
		m_XMLConfigator.LeaveElem();

		// 6
		m_XMLConfigator.AddElem(_T("PlatRefineOffset"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffset();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 

		// 		//	if (GetProductCalibTargetMarkPatternMode(nIndex) == eSinglePatternGuanlian4Point)
		// 		{
		// 			for (int m=0;m<4;m++)
		// 			{
		// 				CString str;
		// 				str.Format("AuxiliaryPosX-%d",m);
		// 				m_XMLConfigator.AddElem(str,pos.GetAuxiliaryPosX(m));	
		// 
		// 				str.Format("AuxiliaryPosY-%d",m);
		// 				m_XMLConfigator.AddElem(str,pos.GetAuxiliaryPosY(m));
		// 			}
		// 		}
		m_XMLConfigator.LeaveElem();

		// 7
		m_XMLConfigator.AddElem(_T("PlatRefineOffsetH1"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffsetH1();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 
		m_XMLConfigator.LeaveElem();

		// 8
		m_XMLConfigator.AddElem(_T("PlatRefineOffsetH2"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffsetH2();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 
		m_XMLConfigator.LeaveElem();

		// 9. 标定时，基准Mark在平台坐标系的坐标值和姿态
		m_XMLConfigator.AddElem(_T("MarkPlatCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPos();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkPltCoordX
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkPltCoordY
		m_XMLConfigator.LeaveElem();

		// 10. 标定时，基准Mark在图像坐标系中的位置
		m_XMLConfigator.AddElem(_T("MarkImgCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkImgCoordPos();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkImgCoordX
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkImgCoordY
		m_XMLConfigator.LeaveElem();

		// 11. 标定时，基准Mark在平台坐标系的坐标值和姿态
		m_XMLConfigator.AddElem(_T("MarkPlatCoordBat"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkPlatformCoordPosBat();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkPltCoordX
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkPltCoordY
		m_XMLConfigator.LeaveElem();

		// 12. 标定时，基准Mark在图像坐标系中的位置
		m_XMLConfigator.AddElem(_T("MarkImgCoordBat"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pos = pCalibratedInfo->GetMarkImgCoordPosBat();
		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkImgCoordX
		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkImgCoordY
		m_XMLConfigator.LeaveElem();


		// 13. 标定时，基准Mark在图像坐标系中的位置
		m_XMLConfigator.AddElem(_T("ObjectMarkImgCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (int m =0;m<CALIBMOVEPOSNUM;m++)
		{
			CString strName;
			strName.Format("X%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
			strName.Format("Y%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
		}
		m_XMLConfigator.LeaveElem();

		// 14. 标定时，基准Mark在图像坐标系中的位置
		m_XMLConfigator.AddElem(_T("TargetMarkImgCoord"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (int m =0;m<CALIBMOVEPOSNUM;m++)
		{
			CString strName;
			strName.Format("X%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
			strName.Format("Y%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
		}

		m_XMLConfigator.LeaveElem();



		//////////////////////////////////////////////////////////
		// 15. 用靶标关联映射时，标定板上的Mark位置图像坐标
		m_XMLConfigator.AddElem(_T("CalibBoardMarkImgCoordPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (int m =0;m<CALIBBOARDMARKPOSNUM;m++)
		{
			CString strName;
			strName.Format("X%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
			strName.Format("Y%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
		}
		m_XMLConfigator.LeaveElem();

		// 16. 用靶标关联映射时，标定板上的Mark位置物理坐标
		m_XMLConfigator.AddElem(_T("CalibBoardMarkBoardCoordPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		for (int m =0;m<CALIBBOARDMARKPOSNUM;m++)
		{
			CString strName;
			strName.Format("X%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
			strName.Format("Y%d",m);
			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
		}
		m_XMLConfigator.LeaveElem();

		// 17. 用靶标关联映射时，标定板尺寸
		m_XMLConfigator.AddElem(_T("CalibBoardSize"));
		m_XMLConfigator.EnterElem();  //4级目录打开
		// SizeX
		CString strName;
		strName.Format("SizeX");
		m_XMLConfigator.AddElem(strName);					 
		m_XMLConfigator.SetElemData(pCalibratedInfo->m_vCalibBoardSize.GetX());
		// SizeY
		strName.Format("SizeY");
		m_XMLConfigator.AddElem(strName);					  
		m_XMLConfigator.SetElemData(pCalibratedInfo->m_vCalibBoardSize.GetY());
		m_XMLConfigator.LeaveElem();  //4级目录关闭

		// 18. 标定时，基准位置处平台各个轴的位置
		m_XMLConfigator.AddElem(_T("PlatAxisPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pCalibPlatformAxisPos = (CPlatformXYDAxisPos*)pCalibratedInfo->GetPlatformAxisPos();
		m_XMLConfigator.AddElem(_T("X"), pCalibPlatformAxisPos->m_dPosX);		// (Level-4) 
		m_XMLConfigator.AddElem(_T("Y"), pCalibPlatformAxisPos->m_dPosY);		// (Level-4) 
		m_XMLConfigator.AddElem(_T("D"), pCalibPlatformAxisPos->m_dAngle);		// (Level-4)
		m_XMLConfigator.LeaveElem();

		// 19. 标定时，图像坐标系与平台坐标系之间的角度
		m_XMLConfigator.AddElem(_T("Anlge"), pCalibratedInfo->m_dImageToPlatformAnlge);	// (Level-3)

		// 20. 标定时，相机坐标系到平台坐标系之间的变换矩阵
		m_XMLConfigator.AddElem(_T("CamTM"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		mat = pCalibratedInfo->GetCamPlatformTransferMatrix();
		m_XMLConfigator.AddElem(_T("A00"), mat.GetElement(0, 0));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A01"), mat.GetElement(0, 1));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A10"), mat.GetElement(1, 0));	// (Level-4)
		m_XMLConfigator.AddElem(_T("A11"), mat.GetElement(1, 1));	// (Level-4)
		m_XMLConfigator.LeaveElem();

		// 21. 标定时，基准位置处相机平台各个轴的位置（XY）
		m_XMLConfigator.AddElem(_T("CamPlatAxisPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		CamPlatformType eType = m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformType();
		m_XMLConfigator.AddElem(_T("CamPlatType"), (int)eType);	// (Level-4)
		pCamPlatformAxisPos = pCalibratedInfo->GetCamPlatformAxisPos();
		if (pCamPlatformAxisPos != NULL)
		{
			switch (eType)
			{
			case eCamPlatformSepFix:
				break;
			case eCamPlatformSepX:
				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
				break;
			case eCamPlatformSepXY:
				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
				m_XMLConfigator.AddElem(_T("Y"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);	// (Level-4)
				break;
			case eCamPlatformShareX:
			default:
				break;
			}		
		}
		m_XMLConfigator.LeaveElem();

		// 22.
		m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));	// (Level-3)
		m_XMLConfigator.EnterElem();
		pCamPlatformAxisPos = pCalibratedInfo->GetCamAxisPlatformAxisPos();
		if (pCamPlatformAxisPos != NULL)
		{
			switch (eType)
			{
			case eCamPlatformSepFix:
				break;
			case eCamPlatformSepX:
				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
				break;
			case eCamPlatformSepXY:
				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
				m_XMLConfigator.AddElem(_T("Y"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);	// (Level-4)
				break;
			case eCamPlatformShareX:
			default:
				break;
			}		
		}
		m_XMLConfigator.LeaveElem();	// Leave CamPlatformAxisPos

		m_XMLConfigator.LeaveElem();	// Leave CH%d
	}
	m_XMLConfigator.LeaveElem();
	m_XMLConfigator.LeaveElem();


	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
	strName.Format(_T("%03d"),nIndex+1);
	if (strName.IsEmpty())	// 产品名称为空，不合法
	{
		return FALSE;
	}
	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\Jobs\\") + strName;

	// 创建产品保存文件夹
	DWORD dwAttributes = GetFileAttributes(strDir);
	if ((dwAttributes == 0xFFFFFFFF) || ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
	{	
		// 创建多级目录
		int nLen = 0;
		DWORD dwLevelXAttrib = 0;
		int nSlashIdx = strDir.Find('\\');
		CString strDirLevelX = _T("");
		CString strTemp = strDir;
		while (nSlashIdx != -1)
		{
			nLen = strDirLevelX.GetLength();
			nSlashIdx += (nLen == 0) ? 0 : (nLen + 1);
			strDirLevelX = strDir.Left(nSlashIdx);
			strTemp = strDir.Mid(nSlashIdx + 1);
			dwLevelXAttrib = GetFileAttributes(strDirLevelX);
			if ((dwLevelXAttrib == 0xFFFFFFFF) || ((dwLevelXAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0))
			{
				if (!CreateDirectory(strDirLevelX, NULL))
				{
					return FALSE;
				}
			}
			nSlashIdx = strTemp.Find('\\');
		}
		if (!CreateDirectory(strDir, NULL))
		{
			return FALSE;
		}
	}

	return m_XMLConfigator.Save(strDir + _T("\\Job.xml"));
}

BOOL vcBaseVisionAlign::LoadTotalProductDataInfoOld()
{
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	BOOL bLoad = m_XMLConfigator.Load(m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\Jobs\\Jobs.xml"));
	if (!bLoad)
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("Jobs")))	
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 1级目录
	if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-1) 平台类型
	{
		return FALSE;
	}
	int nData = 0;
	m_XMLConfigator.GetElemData(nData);
	if ( ((PlatformType)nData) != m_pPlatformInfo->m_ePlatformType )	// 平台类型检查
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("JobNum")))	// (Level-1) 产品总数
	{
		return FALSE;
	}
	int nTotalProductNum = 0;
	m_XMLConfigator.GetElemData(nTotalProductNum);
	if (!m_XMLConfigator.FindElem(_T("CurIndex"))) // (Level-1) 当前产品索引
	{
		return FALSE;
	}
	m_XMLConfigator.GetElemData(nData);
	m_pVisionASMConfig->m_TotalProductData.SetCurProductIndex(nData);

	// 加载产品名称列表
	if (!m_XMLConfigator.FindElem(_T("JobList")))	// (Level-1) 产品名称列表
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 2级目录
	std::vector<CString> vstrNameList;
	CString strIndex;
	int i = 0;
	for (i=0; i<nTotalProductNum; i++)
	{
		strIndex.Format(_T("Job%d"), i+1);
		m_XMLConfigator.FindElem(strIndex);
		//vstrNameList.push_back(m_XMLConfigator.GetAttribute(_T("Name")));
		vstrNameList.push_back(strIndex);
	}
	if (vstrNameList.size() != nTotalProductNum)
	{
		return FALSE;
	}

	for (i=0; i<nTotalProductNum; i++)
	{
		if (!LoadProductDataInfo(i, vstrNameList.at(i)))	// 加载每个产品的详细信息
		{
			CProductData product(*m_pPlatformInfo);
			m_pVisionASMConfig->m_TotalProductData.SetItemGrow(i, product);
			m_pVisionASMConfig->m_TotalProductData.SetItemName(i,_T("------"));
		}

		// 更新大小品种数组
		m_pVisionASMConfig->m_TotalProductData.SetProductIndex(i,0,i);

		// 更新大品种名字
		m_pVisionASMConfig->m_TotalProductData.SetProductNameFa(i,m_pVisionASMConfig->m_TotalProductData.GetItemName(i));

		// 初始化小品种名字
		m_pVisionASMConfig->m_TotalProductData.SetItemName(i,_T("------"));
	}

	// 保存新的Jobs.xml文件
	SaveTotalProductDataInfo(TRUE);

	//	m_pVisionASMConfig->m_TotalProductData.RemoveInvalidItems();
	return TRUE;
}

BOOL vcBaseVisionAlign::LoadTotalCalibDataInfoOld()
{
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	BOOL bLoad = m_XMLConfigator.Load(m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\JobCalibs\\JobCalibs.xml"));
	if (!bLoad)
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("JobCalibs")))	
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 1级目录
	if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-1) 平台类型
	{
		return FALSE;
	}
	int nData = 0;
	m_XMLConfigator.GetElemData(nData);
	if ( ((PlatformType)nData) != m_pPlatformInfo->m_ePlatformType )	// 平台类型检查
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("JobCalibNum")))	// (Level-1) 产品总数
	{
		return FALSE;
	}
	int nTotalCalibNum = 0;
	m_XMLConfigator.GetElemData(nTotalCalibNum);
	if (!m_XMLConfigator.FindElem(_T("CurIndex"))) // (Level-1) 当前产品索引
	{
		return FALSE;
	}
	m_XMLConfigator.GetElemData(nData);
	m_pVisionASMConfig->m_TotalCalibData.SetCurCalibIndex(nData);

	// 加载产品名称列表
	if (!m_XMLConfigator.FindElem(_T("JobCalibList")))	// (Level-1) 产品名称列表
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 2级目录
	std::vector<CString> vstrNameList;
	CString strIndex;
	int i = 0;
	for (i=0; i<nTotalCalibNum; i++)
	{
		strIndex.Format(_T("JobCalib%d"), i+1);
		m_XMLConfigator.FindElem(strIndex);
		//vstrNameList.push_back(m_XMLConfigator.GetAttribute(_T("Name")));
		vstrNameList.push_back(strIndex);
	}
	if (vstrNameList.size() != nTotalCalibNum)
	{
		return FALSE;
	}

	for (i=0; i<nTotalCalibNum; i++)
	{
		if (!LoadCalibDataInfo(i, vstrNameList.at(i)))	// 加载每个产品的详细信息
		{
			// 若平台详细配置XML文件不存在或者配置文件内容无效，则仅根据管理员配置的系统平台信息初始化m_pVisionASMConfig
			CString strErrInfo;
			strErrInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_STR_LOAD_PRODUCT_FAILE), m_pPlatformInfo->m_nPlatformIndex, i+1);
			int nMBReturn = AfxMessageBox(strErrInfo);

			CCalibData product(*m_pPlatformInfo);
			m_pVisionASMConfig->m_TotalCalibData.SetItemGrow(i, product);
			m_pVisionASMConfig->m_TotalCalibData.SetItemName(i,_T("------"));
		}

		// 更新大小品种数组
		m_pVisionASMConfig->m_TotalCalibData.SetCalibIndex(i,0,i);

		// 更新大品种名字
		m_pVisionASMConfig->m_TotalCalibData.SetCalibNameFa(i,m_pVisionASMConfig->m_TotalCalibData.GetItemName(i));

		// 初始化小品种的名字
		m_pVisionASMConfig->m_TotalCalibData.SetItemName(i,_T("------"));
	}

	// 保存Jobs.xml文档
	SaveTotalCalibDataInfo(TRUE);

	//	m_pVisionASMConfig->m_TotalCalibData.RemoveInvalidItems();
	return TRUE;
}


// 判断是否保存所有标定信息成功
BOOL vcBaseVisionAlign::IsSaveTotalCalibDataInfoOK()
{
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}
	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	BOOL bLoad = m_XMLConfigator.Load(m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\JobCalibs\\JobCalibs.xml"));
	if (!bLoad)
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("JobCalibs")))	
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 1级目录
	if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-1) 平台类型
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("JobCalibNum")))	// (Level-1) 产品总数
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("CurIndex"))) // (Level-1) 当前产品索引
	{
		return FALSE;
	}
	m_XMLConfigator.LeaveElem();  // 1级目录

	return TRUE;
}

BOOL vcBaseVisionAlign::IsSaveTotalProductDataInfoOK()
{
	if (m_pPlatformInfo == NULL)
	{
		return FALSE;
	}

	vcXMLConfigurator m_XMLConfigator;
	m_XMLConfigator.SetDoc(_T(""));
	BOOL bLoad = m_XMLConfigator.Load(m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\Jobs\\Jobs.xml"));
	if (!bLoad)
	{
		return FALSE;
	}
	if (!m_XMLConfigator.FindElem(_T("Jobs")))	
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();  // 1级目录
	if (!m_XMLConfigator.FindElem(_T("PlatType")))	// (Level-1) 平台类型
	{
		return FALSE;
	}	
	if (!m_XMLConfigator.FindElem(_T("JobNum")))	// (Level-1) 产品总数
	{
		return FALSE;
	}

	if (!m_XMLConfigator.FindElem(_T("CurIndex"))) // (Level-1) 当前产品索引
	{
		return FALSE;
	}

	m_XMLConfigator.LeaveElem();

	return TRUE;

}

// 释放平台信息占用的内存                  
void vcBaseVisionAlign::DeletePlatformInfo()
{
	if (m_pVisionASMConfig&&m_pVisionASMConfig->m_pPlatformInfo)
	{
		delete m_pVisionASMConfig->m_pPlatformInfo;		
		m_pVisionASMConfig->m_pPlatformInfo = NULL;
	}
}   

//释放定位工具信息占用的内存
void vcBaseVisionAlign::DeleteDlgSearchToolInfo()
{
	if (m_pDlgSearchToolInfo)
	{
		delete m_pDlgSearchToolInfo;
		m_pDlgSearchToolInfo = NULL;
	}
}

//lzk
void vcBaseVisionAlign::DeleteAlignerTypeInfo()
{
	if (m_pAlignerTypeInfo)
	{
		delete m_pAlignerTypeInfo;
		m_pAlignerTypeInfo = NULL;
	}
}

// 释放平台信息占用的内存                  
void vcBaseVisionAlign::DeleteMidPlatformInfo()
{
	if (m_pVisionASMConfig&&m_pVisionASMConfig->m_pMidPlatformInfo)
	{
		delete m_pVisionASMConfig->m_pMidPlatformInfo;		
		m_pVisionASMConfig->m_pMidPlatformInfo = NULL;
	}
} 

// 释放相机平台信息展占用的内存                   
void vcBaseVisionAlign::DeleteCameraPlatformInfo()   
{
	if (m_pVisionASMConfig)
	{	
		if (m_pVisionASMConfig->m_pCamPlatformInfo)
		{
			delete m_pVisionASMConfig->m_pCamPlatformInfo;
			m_pVisionASMConfig->m_pCamPlatformInfo = NULL;
		}
	}
}                     

// 释放通信信息占用的内存
void vcBaseVisionAlign::DeleteCommInfo()
{
	if (m_pVisionASMConfig&&m_pVisionASMConfig->m_pCommParam)
	{
		if (m_pVisionASMConfig->m_pCommParam->GetCommType() == eSocket)
		{
			vcSocketCommInfo* pSocketCommInfo =  (vcSocketCommInfo*)m_pVisionASMConfig->m_pCommParam;
			delete pSocketCommInfo;
		}
		else if (m_pVisionASMConfig->m_pCommParam->GetCommType() == eSerial)
		{
			vcSerialCommInfo* pSerialCommInfo =  (vcSerialCommInfo*)m_pVisionASMConfig->m_pCommParam;
			delete pSerialCommInfo;
		}
		else
		{
			delete	 m_pVisionASMConfig->m_pCommParam;
		}

		m_pVisionASMConfig->m_pCommParam = NULL;
	}
}                                

// 释放系统平台信息占用的内存
void vcBaseVisionAlign::DeleteSysPlatformInfo()
{
	if (m_pPlatformInfo)
	{
		delete m_pPlatformInfo;
		m_pPlatformInfo = NULL;
	}
}          

// 释放m_pVisionASMConfig所指向的内存                
void vcBaseVisionAlign::DeleteVisionASMConfig()
{
	if (m_pVisionASMConfig)
	{
		delete m_pVisionASMConfig;
		m_pVisionASMConfig = NULL;
	}
}          


//   设置系统的选项信息
void vcBaseVisionAlign::SetSystemOptionConfig(CSystemOptionConfig *pSystemOptionConfig)
{
	m_pSystempOptionConfig = pSystemOptionConfig;
}

// 设置/获取系统平台配置信息（管理员）
BOOL vcBaseVisionAlign::SetSysPlatformInfo(SysPlatformInfo platformInfo)
{
	if (NULL == m_pPlatformInfo)
	{	
		return FALSE;
	}

	*m_pPlatformInfo = platformInfo;

	return TRUE;
}

BOOL vcBaseVisionAlign::GetSysPlatformInfo(SysPlatformInfo& platformInfo)
{
	if (NULL == m_pPlatformInfo)
	{	   
		return FALSE;
	}

	platformInfo = *m_pPlatformInfo;

	return TRUE;
}

SysPlatformInfo& vcBaseVisionAlign::GetSysPlatformInfoEx() const
{
	ASSERT(m_pPlatformInfo != NULL);

	return *m_pPlatformInfo;
}

//////GYM-获取系统配置-获取相机信息
BOOL vcBaseVisionAlign::GetVSconfig(CVisionASMConfig *&vsConfig)
{
	if (NULL == m_pVisionASMConfig)
	{	   
		return FALSE;
	}

	vsConfig = m_pVisionASMConfig;

	return TRUE;
}

//设置/获取系统平台定位工具信息
void vcBaseVisionAlign::SetDlgSearchToolData(const DlgSearchToolInfo& searchToolData)
{
	if (NULL != m_pDlgSearchToolInfo)
	{
		*m_pDlgSearchToolInfo = searchToolData;
	}
}

DlgSearchToolInfo& vcBaseVisionAlign::GetDlgSearchToolData() const
{
	ASSERT(m_pDlgSearchToolInfo != NULL);

	return *m_pDlgSearchToolInfo;
}

//lzk
void vcBaseVisionAlign::SetAlignerTypeInfo(const AlignerTypeInfo& alignerTypeInfo)
{
	if (NULL != m_pAlignerTypeInfo)
	{
		*m_pAlignerTypeInfo = alignerTypeInfo;
	}
}
//lzk
AlignerTypeInfo& vcBaseVisionAlign::GetAlignerTypeInfo() const
{
	ASSERT(m_pAlignerTypeInfo != NULL);

	return *m_pAlignerTypeInfo;
}

// 设置/获取系统数据记录信息
void vcBaseVisionAlign::SetSysDataRecord( const SysDataRecord& data )
{
	ASSERT(m_pVisionASMConfig != NULL);
	m_pVisionASMConfig->m_DataRecord = data;
}


SysDataRecord& vcBaseVisionAlign::GetSysDataRecord() const
{
	ASSERT(m_pVisionASMConfig != NULL);
	return m_pVisionASMConfig->m_DataRecord;
}

void vcBaseVisionAlign::SetSysInfoStrings( CStringArray *pSysInfoStrings )
{
	m_psaSysInfoStrings = pSysInfoStrings;
}


void vcBaseVisionAlign::SetMutiTarget()
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	m_XYDCommProtocol.SetEnableCommMutiTarget(optionInfo.m_bEnableMutiTarget);
}


// 根据是否进行数据合并记录，更新数据记录文本的具体路径
BOOL vcBaseVisionAlign::UpdateDataRecordTxtAddr()
{
	// 判断视觉对位配置指针是否存在
	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	// 数据记录文件夹路径字符串
	CString strDataRecord,strDRecord;
	CString strTXTDataRecord;
	if (m_pVisionASMConfig->m_DataRecord.m_bCustomLogPath && m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath != _T(""))
	{
		strDataRecord = m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath;

		//TXT日志单独存储
		{
			strTXTDataRecord = m_strEXEDir + _T("\\VSLog"); // ..\Bin\VSLog文件夹
			strDRecord.Format(_T("\\WS%d"),m_pPlatformInfo->m_nPlatformIndex + 1);
			strTXTDataRecord = strTXTDataRecord + strDRecord;
		}
	}
	else
	{
		strDataRecord = m_strEXEDir + _T("\\VSLog"); // ..\Bin\VSLog文件夹
		//m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath = strDataRecord;
		//strDataRecord = strDataRecord + m_pPlatformInfo->m_strPlatformDetailSavePath.Mid(m_pPlatformInfo->m_strPlatformDetailSavePath.ReverseFind('\\')); // ..\Bin\VSLog\WS0文件夹
		strDRecord.Format(_T("\\WS%d"),m_pPlatformInfo->m_nPlatformIndex + 1);
		strDataRecord = strDataRecord + strDRecord;
		strTXTDataRecord = strDataRecord;
	}



	// 1. \Bin\VSLog\WS0文件夹
	CFileFind findFile;
	BOOL IsFild, IsDir;

	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strDataRecord);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strDataRecord/*, NULL*/))// 创建..\Bin\VSLog\WS0文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strDataRecord);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	// 更新数据记录文件夹
	m_strDataRecord = strDataRecord;

	// 2. VDB文件
	CString strVDBPath = m_strDataRecord + _T("\\VDB文件");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strVDBPath);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strVDBPath/*, NULL*/))// 创建..\Bin\VSLog\WS0\VDB文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	//VDB文件OK文件夹
	CString strVDBPath_OK = m_strDataRecord + _T("\\VDB文件\\OK");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strVDBPath_OK);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strVDBPath_OK/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath_OK);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	//VDB文件NG文件夹
	CString strVDBPath_NG = m_strDataRecord + _T("\\VDB文件\\NG");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strVDBPath_NG);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strVDBPath_NG/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath_NG);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	// 2. Image文件
	CString strImagePath = m_strDataRecord + _T("\\Image文件");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strImagePath);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strImagePath/*, NULL*/))// 创建..\Bin\VSLog\WS0\Image文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strImagePath);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	// 3. 对位过程
	CString strAlignProcess = m_strDataRecord + _T("\\AlignProcess");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strAlignProcess);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strAlignProcess/*, NULL*/))// 创建..\Bin\VSLog\WS0\AlignProcess文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strAlignProcess);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	// 给对位数据和通讯数据文本文档字符串变量赋值
	strAlignProcess = strTXTDataRecord + _T("\\AlignProcess");
	if (m_pVisionASMConfig->m_DataRecord.m_bDataMerged)
	{
		m_strAlignProcessData				= strAlignProcess + _T("\\CommuAndAlignData.txt");
		m_strCommunicationData				= strAlignProcess + _T("\\CommuAndAlignData.txt");
		m_strCommunicationSimpleData		= strAlignProcess + _T("\\CommunicationSimpleData.txt");
		m_strCommunicationSimpleShowData	= strAlignProcess + _T("\\CommunicationSimpleShowData.txt");
		m_strWarningInfoFilePath			= strAlignProcess + _T("\\WarningInfo.txt");
		m_strProductSizeData				= strAlignProcess + _T("\\ProductSize.txt");
		m_strProductdistanceData 			= strAlignProcess + _T("\\ProductdistanceData.csv");
	}
	else
	{
		m_strAlignProcessData				= strAlignProcess + _T("\\AlignProcessData.txt");
		m_strCommunicationData				= strAlignProcess + _T("\\CommunicationData.txt");
		m_strCommunicationSimpleData		= strAlignProcess + _T("\\CommunicationSimpleData.txt");
		m_strCommunicationSimpleShowData	= strAlignProcess + _T("\\CommunicationSimpleShowData.txt");
		m_strWarningInfoFilePath			= strAlignProcess + _T("\\WarningInfo.txt");
		m_strProductSizeData				= strAlignProcess + _T("\\ProductSize.txt");
		m_strProductdistanceData 			= strAlignProcess + _T("\\ProductdistanceData.csv");
	}

	// 4. 验证文件（标定结果验证等）
	CString strAlignTool = m_strDataRecord + _T("\\AlignTool");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strAlignTool);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strAlignTool/*, NULL*/))// 创建..\Bin\VSLog\WS0\AlignTool文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strAlignTool);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	m_strCalibrateProcessPath1 = strAlignTool + _T("\\CalibrateLog1.txt");
	m_strCalibrateProcessPath2 = strAlignTool + _T("\\CalibrateLog2.txt");
	m_strCalibrateProcessPath3 = strAlignTool + _T("\\CalibrateLog3.txt");
	m_strCalibrateProcessPath4 = strAlignTool + _T("\\CalibrateLog4.txt");
	m_strCalibrateProcessPath5 = strAlignTool + _T("\\CalibrateLog5.txt");

	m_stUploadData.strSavePath = m_strDataRecord;

	return TRUE;
}

CString vcBaseVisionAlign::GetWarningInfoFilePath()
{
	return m_strWarningInfoFilePath;
}

// 增加时间文件结构，更新m_strDataRecord、m_strAlignProcessData和m_strCommunicationData的具体路径
BOOL vcBaseVisionAlign::UpdateDataRecordTxtAddrTime()
{
	// 判断视觉对位配置指针是否存在
	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	// 获取当前日期
	CTime tCurrent = CTime::GetCurrentTime();

	// 获取当前日期对应的字符串
	CString strTemp;
	//strTemp.Format(_T("%04d-%02d-%02d-%02d-%02d"), tCurrent.GetYear(), tCurrent.GetMonth(), tCurrent.GetDay(),tCurrent.GetHour(), tCurrent.GetMinute());
	strTemp.Format(_T("%04d-%02d-%02d"), tCurrent.GetYear(), tCurrent.GetMonth(), tCurrent.GetDay());

	// 数据记录文件夹路径字符串
	CString strDataRecord,strDRecord;
	CString strTXTDataRecord;
	if (m_pVisionASMConfig->m_DataRecord.m_bCustomLogPath && m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath != _T(""))
	{
		strDataRecord = m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath;

		//TXT日志单独存储
		{
			strTXTDataRecord = m_strEXEDir + _T("\\VSLog"); // ..\Bin\VSLog文件夹
			strDRecord.Format(_T("\\WS%d"),m_pPlatformInfo->m_nPlatformIndex + 1);
			strTXTDataRecord = strTXTDataRecord + strDRecord;
		}
	}
	else
	{
		strDataRecord = m_strEXEDir + _T("\\VSLog"); // ..\Bin\VSLog文件夹
		//m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath = strDataRecord;
		//strDataRecord = m_pVisionASMConfig->m_DataRecord.m_strDataRecordTimeAddr; // E:\VSLog文件夹
		//strDataRecord = strDataRecord + m_pPlatformInfo->m_strPlatformDetailSavePath.Mid(m_pPlatformInfo->m_strPlatformDetailSavePath.ReverseFind('\\')); // E:\VSLog\WS0文件夹
		strDRecord.Format(_T("\\WS%d"),m_pPlatformInfo->m_nPlatformIndex + 1);
		strDataRecord = strDataRecord + strDRecord;
		strTXTDataRecord = strDataRecord;
	}

	strDataRecord = strDataRecord + _T("\\") + strTemp; // E:\VSLog\WS0\2018-02-23-00文件夹

	// 1. \Bin\VSLog\WS0文件夹
	CFileFind findFile;
	BOOL IsFild, IsDir;

	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strDataRecord);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strDataRecord/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strDataRecord);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	// 更新数据记录文件夹
	m_strDataRecord = strDataRecord;

	// 2. VDB文件
	CString strVDBPath = m_strDataRecord + _T("\\VDB文件");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strVDBPath);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strVDBPath/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	//VDB文件OK文件夹
	CString strVDBPath_OK = m_strDataRecord + _T("\\VDB文件\\OK");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strVDBPath_OK);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strVDBPath_OK/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath_OK);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	//VDB文件NG文件夹
	CString strVDBPath_NG = m_strDataRecord + _T("\\VDB文件\\NG");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strVDBPath_NG);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strVDBPath_NG/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strVDBPath_NG);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	// 2. Image文件
	CString strImagePath = m_strDataRecord + _T("\\Image文件");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strImagePath);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strImagePath/*, NULL*/))// 创建E:\VSLog\WS0\2018-02-23-00文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strImagePath);
			AfxMessageBox(str);

			return FALSE;
		}
	}


	// 3. 对位过程
	CString strAlignProcess = m_strDataRecord + _T("\\AlignProcess");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strAlignProcess);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strAlignProcess/*, NULL*/))// 创建..\Bin\VSLog\WS0\AlignProcess文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strAlignProcess);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	// 给对位数据和通讯数据文本文档字符串变量赋值
	strAlignProcess = strTXTDataRecord + _T("\\AlignProcess");
	if (m_pVisionASMConfig->m_DataRecord.m_bDataMerged)
	{
		m_strAlignProcessData				= strAlignProcess + _T("\\CommuAndAlignData.txt");
		m_strCommunicationData				= strAlignProcess + _T("\\CommuAndAlignData.txt");
		m_strCommunicationSimpleData		= strAlignProcess + _T("\\CommunicationSimpleData.txt");
		m_strCommunicationSimpleShowData	= strAlignProcess + _T("\\CommunicationSimpleShowData.txt");
		m_strWarningInfoFilePath			= strAlignProcess + _T("\\WarningInfo.txt");
		m_strProductSizeData				= strAlignProcess + _T("\\ProductSize.txt");
		m_strProductdistanceData 			= strAlignProcess + _T("\\ProductdistanceData.csv");
	}
	else
	{
		m_strAlignProcessData				= strAlignProcess + _T("\\AlignProcessData.txt");
		m_strCommunicationData				= strAlignProcess + _T("\\CommunicationData.txt");
		m_strCommunicationSimpleData		= strAlignProcess + _T("\\CommunicationSimpleData.txt");
		m_strCommunicationSimpleShowData	= strAlignProcess + _T("\\CommunicationSimpleShowData.txt");
		m_strWarningInfoFilePath			= strAlignProcess + _T("\\WarningInfo.txt");
		m_strProductSizeData				= strAlignProcess + _T("\\ProductSize.txt");
		m_strProductdistanceData 			= strAlignProcess + _T("\\ProductdistanceData.csv");
	}


	// 4. 验证文件（标定结果验证等）
	CString strAlignTool = m_strDataRecord + _T("\\AlignTool");
	IsDir = FALSE;
	IsFild = FALSE;
	IsFild = findFile.FindFile(strAlignTool);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	// 如果不存在则创建文件夹
	if (!IsDir)
	{
		if (!CreateDirectoryPro(strAlignTool/*, NULL*/))// 创建..\Bin\VSLog\WS0\AlignTool文件夹，父目录不要求一定存在
		{
			CString str;
			str.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_SYS_DATARECORD_DIR_XXX_FAILED), strAlignTool);
			AfxMessageBox(str);

			return FALSE;
		}
	}

	m_strCalibrateProcessPath1 = strAlignTool + _T("\\CalibrateLog1.txt");
	m_strCalibrateProcessPath2 = strAlignTool + _T("\\CalibrateLog2.txt");
	m_strCalibrateProcessPath3 = strAlignTool + _T("\\CalibrateLog3.txt");
	m_strCalibrateProcessPath4 = strAlignTool + _T("\\CalibrateLog4.txt");
	m_strCalibrateProcessPath5 = strAlignTool + _T("\\CalibrateLog5.txt");

	m_stUploadData.strSavePath = m_strDataRecord;
	m_bNeedUpdateAddrTime = FALSE;
	return TRUE;
}

// 检查并删除过时的时间记录文件夹
BOOL vcBaseVisionAlign::CheckRemoveFolder()
{
	CString strDataRecord,strDRecord;		// 存储日志文件的上级目录
	CString strCurrentDataRecordDir;		// 存储日志文件的当前目录
	std::vector<CString> vRecordDir;
	CTime tCurrent = CTime::GetCurrentTime();
	// Step1: 准备检测日志存储目录 - 为了避免多线程访问, 该路径将进行构造, 避免使用 m_strDataRecord
	{
		// 如果按天存图, 将日期根据时间修正到天
		if (1 == 1)
		{
			int nStartHour = m_pVisionASMConfig->m_DataRecord.m_nStartHourRecordByDay;
			CTimeSpan tsStartHour(0, nStartHour, 0, 0);
			CTime tRecord = tCurrent - tsStartHour;
			// 年-月-日
			strCurrentDataRecordDir.Format(_T("%04d-%02d-%02d"), tRecord.GetYear(), tRecord.GetMonth(), tRecord.GetDay());
		}
		else
		{
			// 年-月-日-小时-分钟
			strCurrentDataRecordDir.Format(_T("%04d-%02d-%02d-%02d-%02d"), tCurrent.GetYear(), tCurrent.GetMonth(), tCurrent.GetDay(), tCurrent.GetHour(),tCurrent.GetMinute());
		}
		// 数据记录文件夹路径字符串
		if (m_pVisionASMConfig->m_DataRecord.m_bCustomLogPath && m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath != _T(""))
		{
			strDataRecord = m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath;
		}
		else
		{
			strDataRecord = m_strEXEDir + _T("\\VSLog"); // ..\Bin\VSLog文件夹
			//strDataRecord = strDataRecord + m_pPlatformInfo->m_strPlatformDetailSavePath.Mid(m_pPlatformInfo->m_strPlatformDetailSavePath.ReverseFind('\\')); // E:\VSLog\WS0文件夹
			strDRecord.Format(_T("\\WS%d"),m_pPlatformInfo->m_nPlatformIndex + 1);
			strDataRecord = strDataRecord + strDRecord;
		}
	}
	// Step2: 检索目录 CFileFind 默认按照文件名称排序, 由小到大
	{
		if (1== 1)
		{
			// 年-月-日 2021-11-23
			CFileFind fileFind; 
			BOOL bFound = FALSE;
			bFound = fileFind.FindFile(strDataRecord + _T("\\*-*-*")); 
			while (bFound) 
			{ 
				bFound = fileFind.FindNextFile(); 
				if (!fileFind.IsDots() && fileFind.IsDirectory()) 
				{
					// 获取文件夹名称
					CString strFileName = fileFind.GetFileName();
					// 文件夹名称长度和时间间隔需符合规则
					if (strFileName.GetLength() == 10 && strFileName.Mid(4,1) == _T("-") && strFileName.Mid(7,1) == _T("-"))
					{
						// 获取年月日时
						int nYear = atoi(strFileName.Mid(0,4));
						int nMonth = atoi(strFileName.Mid(5,2));
						int nDay = atoi(strFileName.Mid(8,2));
						int nHour = m_pVisionASMConfig->m_DataRecord.m_nStartHourRecordByDay;
						// 文件夹命名必须规则，才算有效文件夹
						if (nYear>=0 && nMonth>0 && nMonth<=12 && nDay>0 && nDay<=31)
						{
							CTime tTime = CTime(nYear, nMonth, nDay, nHour, 0, 0);
							// 文件夹时间必须早于当前时间，才算有效文件夹
							if (tTime <= tCurrent)
							{
								vRecordDir.push_back(strFileName);
							}
						}
					}
				}
			} 
			fileFind.Close();
		}
		else
		{
			// 年-月-日-小时
			CFileFind fileFind; 
			BOOL bFound = FALSE;
			bFound = fileFind.FindFile(strDataRecord + _T("\\*-*-*-*-*")); 
			while (bFound) 
			{ 
				bFound = fileFind.FindNextFile(); 
				if (!fileFind.IsDots() && fileFind.IsDirectory()) 
				{
					// 获取文件夹名称
					CString strFileName = fileFind.GetFileName();



					// 文件夹名称长度和时间间隔需符合规则
					if (strFileName.GetLength() == 16 && strFileName.Mid(4,1) == _T("-") && strFileName.Mid(7,1) == _T("-") && strFileName.Mid(10,1) == _T("-")&&strFileName.Mid(13,1) == _T("-"))
					{
						// 获取年月日时
						int nYear = atoi(strFileName.Mid(0,4));
						int nMonth = atoi(strFileName.Mid(5,2));
						int nDay = atoi(strFileName.Mid(8,2));
						int nHour = atoi(strFileName.Mid(11,2));
						int nMinute = atoi(strFileName.Mid(14,2));
						// 文件夹命名必须规则，才算有效文件夹
						if (nYear>=0 && nMonth>0 && nMonth<=12 && nDay>0 && nDay<=31 && nHour>=0 && nHour<24)
						{
							CTime tTime = CTime(nYear, nMonth, nDay, nHour, nMinute, 0);
							// 文件夹时间必须早于当前时间，才算有效文件夹
							if (tTime <= tCurrent)
							{
								vRecordDir.push_back(strFileName);
							}
						}
					}
				}
			} 
			fileFind.Close();
		}
	}
	std::sort(vRecordDir.begin(),vRecordDir.end(),less<CString>());
	// 获取磁盘容量
	DWORD64 qwFreeBytes, qwFreeBytesToCaller, qwTotalBytes;  
	BOOL bResult = GetDiskFreeSpaceEx(strDataRecord, (PULARGE_INTEGER)&qwFreeBytesToCaller, (PULARGE_INTEGER)&qwTotalBytes, (PULARGE_INTEGER)&qwFreeBytes);  
	double dDiskSpaceUsePercent = 1 - (double)qwFreeBytesToCaller/(double)qwTotalBytes;
	// 通知WorkThread 建立新的目录
	if(vRecordDir.size() <= 0 || vRecordDir[vRecordDir.size() -1] != strCurrentDataRecordDir)
	{
		if (bResult)
		{
			m_bNeedUpdateAddrTime = TRUE;
		}
		return TRUE;
	}
	// Step3: 现根据磁盘判断
	{
		// 如果使用率大于设置阈值, 则移除第一个目录
		if (dDiskSpaceUsePercent > m_pVisionASMConfig->m_DataRecord.m_dDiskSpaceMaxUsePercent/100.0)
		{
			// 跳出循环前，新建当前时刻子文件夹
			// 该操作主要是，为了防止当只有一个当前文件夹被删除后磁盘比例未超过阈值，但是此时当前文件夹也丢失，造成无法正常存图
			// 当文件夹都被删除时或者当前时刻文件夹被删除才进行 各种保存路径的重新赋值以及文件夹创建；否则删除线程频繁的调用UpdateDataRecordTxtAddrTime导致主线程访问路径时崩溃

			if (vRecordDir.size()  > 1)
			{
				RemoveDirectoryPro(strDataRecord + _T("\\") + vRecordDir[0]);
				return TRUE;
			}
			if (vRecordDir.size() == 1 && vRecordDir[0] != strCurrentDataRecordDir)
			{
				RemoveDirectoryPro(strDataRecord + _T("\\") + vRecordDir[0]);
				return TRUE;
			}
			if (vRecordDir.size() == 1 && vRecordDir[0] == strCurrentDataRecordDir)
			{
				// 只清空不删除目录
				ClearDirectoryPro(strDataRecord + _T("\\") + vRecordDir[0] +  _T("\\VDB文件"));
				ClearDirectoryPro(strDataRecord + _T("\\") + vRecordDir[0] +  _T("\\AlignProcess"));
				ClearDirectoryPro(strDataRecord + _T("\\") + vRecordDir[0] +  _T("\\AlignTool"));
				ClearDirectoryPro(strDataRecord + _T("\\") + vRecordDir[0] +  _T("\\Image文件"));
				return TRUE;
			}
		}
	}
	// Step4: 根据文件数量判断
	{
		if (vRecordDir.size() > m_pVisionASMConfig->m_DataRecord.m_nDataRecordTimeNum)
		{
			RemoveDirectoryPro(strDataRecord + _T("\\") + vRecordDir[0]);
			return TRUE;
		}
	}
	
	return TRUE;
}


// 检查删除文件夹路径线程
UINT vcBaseVisionAlign::CheckRemoveFolderThread(LPVOID pParam)
{
	vcBaseVisionAlign* pOwner = (vcBaseVisionAlign*)pParam;
	if (pOwner != NULL)
	{
		while (!pOwner->m_bExitCheckRemoveFolderThread)
		{
			// 检查并删除过时的时间记录文件夹
			pOwner->CheckRemoveFolder();

			//// 每分钟检查删除一次
			//Sleep(60000);
			Sleep(1000);//sleep过久退出软件时会强制结束线程导致内存泄漏
		}
	}
	return 0;
}



// S7：初始化相机：根据相机相机信息(个数、序列号、帧数、曝光时间、增益等），初始化相机，设置相机回调函数，准备开始采集图像；
// S7.1：初始化图像对象：根据相机个数初始化用于接收数据的图像类对象；
// S8：初始化通信接口：根据通信接口信息（接口类型及相应的配置信息），初始化通信接口，准备开始接收通信指令信息；
// S9：初始化标定用的定位工具：；
// S10：初始化对位用的定位工具：；
// S11：初始化对位工具的标定功能：；
// S12：初始化对位工具的对位功能：；
// S13：创建平台的对位处理线程：；
// S13.1：

// 设置接收消息的主窗口（实例化对象后，或更换接收消息的窗口时，必须调用）
CWnd* vcBaseVisionAlign::SetMainWnd(CWnd* pMainWnd)
{
	if (NULL == pMainWnd)
	{
		return FALSE;
	}

	CWnd* pOldMainWnd = m_pMainWnd;

	m_pMainWnd = pMainWnd;

	return pOldMainWnd;
}

CWnd* vcBaseVisionAlign::GetMainWnd()
{
	return m_pMainWnd;
}

// 设置接收消息的主窗口（实例化对象后，或更换接收消息的窗口时，必须调用）
CWnd* vcBaseVisionAlign::SetMainRunWnd(CWnd* pMainWnd)
{
	if (NULL == pMainWnd)
	{
		return FALSE;
	}

	CWnd* pOldMainWnd = m_pMainRunWnd;

	m_pMainRunWnd = pMainWnd;

	return pOldMainWnd;
}
// 设置接收消息的主窗口（实例化对象后，或更换接收消息的窗口时，必须调用）
CWnd* vcBaseVisionAlign::SetMainFrameWnd(CWnd* pMainWnd)
{
	if (NULL == pMainWnd)
	{
		return FALSE;
	}

	CWnd* pOldMainWnd = m_pMainFrameWnd;

	m_pMainFrameWnd = pMainWnd;

	return pOldMainWnd;
}

CWnd* vcBaseVisionAlign::SetOperatingInfoShowWnd(CWnd* pInfoShowWnd)
{
	if (NULL == pInfoShowWnd)
	{
		return FALSE;
	}
	CWnd* pOldMainWnd = m_pOperatingInfoShowWnd;
	m_pOperatingInfoShowWnd = pInfoShowWnd;
	return pOldMainWnd;
}

// 初始化VisionASM所有工具
DWORD vcBaseVisionAlign::InitVisionASM()
{
	if ((NULL == m_pPlatformInfo)||(NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}	

	// 释放所有相机
	int i=0;
	for (i=0; i<m_vpCamera.size(); i++)
	{
		UninitCamera(i);
	}

	if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
	{
		// 删除时间文件结构，更新m_strDataRecord、m_strAlignProcessData和m_strCommunicationData的具体路径
		UpdateDataRecordTxtAddr();
	}
	else
	{
		// 增加时间文件结构，更新m_strDataRecord、m_strAlignProcessData和m_strCommunicationData的具体路径
		UpdateDataRecordTxtAddrTime();
	}

	// 1. 初始化相机: 根据相机相机信息(个数、序列号、帧数、曝光时间、增益等），初始化相机，设置相机回调函数，准备开始采集图像；
	CameraParam cameraParam;
	scPTGrab2* pPTGrab;
	CCameraCallbackObject* pcbCallbackObject = NULL; 
	CCameraCallbackObject* pcbCallbackObject1 = NULL; 
	cpImage imgInput;
	vcDisplayModule dmDisplayModule;
	scGuiDisplay* pGuiDisplay = NULL;
	BOOL bLiveGrab = FALSE;
	CSearchResult searchResult;

	m_vpCamera.clear();
	m_vpCamOwner.clear();
	//	m_vpHideSearchGUIObject.clear();
	m_vpSearchObject.clear();
	m_vpSaveImageObject.clear();
	m_vpCameraExposureObject.clear();
	m_vImageInput.clear();
	m_vImageSearch.clear();
	m_vpGuiDisplay.clear();
	m_vbCameraLiveGrab.clear();
	m_vbImageProcessFinished.clear();
	m_vImageTemp1.clear();
	m_vImageTemp2.clear();
	m_vbSearchSucceed.clear();
	m_vbSearchFinished.clear();
	m_vSeachResults.clear();
	m_vDmCodeCalibBoardPos.clear();

	m_vbShareSrcCamTransferFinished.clear();

	//光源切换
	m_vbExitLightCtrlThread.clear();

	//	int nPatternNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nPatternNum = m_pPlatformInfo->m_nPositionNum;

	m_vDmCodeCalibBoardPos.resize(nPatternNum);

	m_mpCalibMarkImagePos.SetMarkImagePosNum(nPatternNum); 
	m_mpTargetMarkImagePos.SetMarkImagePosNum(nPatternNum);
	m_mpFixTargetMarkImagePos.SetMarkImagePosNum(nPatternNum); 

	m_vMutiTargetMarkImagePos.resize(MUTITARGETMAXNUM);
	m_vbMutiTargetMarkOK.resize(MUTITARGETMAXNUM);

	for (int i=0;i<MUTITARGETMAXNUM;i++)
	{
		m_vMutiTargetMarkImagePos.at(i).SetMarkImagePosNum(nPatternNum);
		m_vbMutiTargetMarkOK.at(i)=FALSE;
	}
	m_mpBenchMarkImagePos.SetMarkImagePosNum(nPatternNum);       
	m_mpObjectMarkImagePos.SetMarkImagePosNum(nPatternNum); 
	m_mpFixObjectMarkImagePos.SetMarkImagePosNum(nPatternNum);  

	m_mpVirtualMarkImagePos.SetMarkImagePosNum(nPatternNum);  
	m_mpCalibTargetMarkImagePos.SetMarkImagePosNum(nPatternNum);
	m_mpInspectMarkImagePos.SetMarkImagePosNum(nPatternNum);
	m_mpTargetRotatedMarkImagePos.SetMarkImagePosNum(nPatternNum);

	m_mpCrossBenchMarkImagePos.SetMarkImagePosNum(nPatternNum);

	int nNums = 1;  // 原始产品 +单产品扩展数目;
	if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
	{
		nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
	}
	m_vmpObjectMarkImagePos_MultiEX.resize(nNums);
	m_vmpTargetMarkImagePosMultiEx.resize(nNums);
	for (int it =0;it < nNums;it++)
	{
		m_vmpObjectMarkImagePos_MultiEX.at(it).SetMarkImagePosNum(nPatternNum);
		m_vmpTargetMarkImagePosMultiEx.at(it).SetMarkImagePosNum(nPatternNum);
	}

	m_vvpObjectPlatformAxisPosMultiEx.resize(nNums);
	m_vvpTargetPlatformAxisPosMultiEx.resize(nNums);

	CMarkImagePos *pMarkImagePos;
	for(i = 0; i < CALIBSEPARATECAMMOVENUM;i++)
	{
		pMarkImagePos = new CMarkImagePos;
		pMarkImagePos->SetMarkImagePosNum(nPatternNum);
		m_vpmpCalibMarkImagePos.push_back(pMarkImagePos);
	}

	m_vpMutiTargetPlatformAxisPos.resize(MUTITARGETMAXNUM);

	m_vvpObjectCamAxisPosMultiEx.resize(nNums);
	m_vvpObjectCamAxisPlatformAxisPosMultiEx.resize(nNums);
	m_vvpTargetCamAxisPosMultiEx.resize(nNums);
	m_vvpTargetCamAxisPlatformAxisPosMultiEx.resize(nNums);

	m_vvpMarkImagePos.resize(nPatternNum);

	InitTargetPlatformAxisPos();
	InitObjectPlatformAxisPos();
	InitCrossBenchTargetPlatformAxisPos();
	InitObjectCamAxisPos();
	InitTargetCamAxisPos();
	InitObjectCamAxisPlatformAxisPos();
	InitTargetCamAxisPlatformAxisPos();

	//lzk 0409
	//	m_vbIsAllObjectPosSearchFinished.resize(nPatternNum/2,FALSE);
	//	m_vbIsAllTargetPosSearchFinished.resize(nPatternNum/2,FALSE);

	/*m_vbIsObjectPosSearchFinished.resize(nPatternNum/2,FALSE);
	m_vbIsTargetPosSearchFinished.resize(nPatternNum/2,FALSE);*/

	m_vbSearchSucceed.resize(nPatternNum, FALSE);
	m_vbSearchFinished.resize(nPatternNum, TRUE);
	m_vbImageProcessFinished.resize(nPatternNum, TRUE);
	m_vSeachResults.resize(nPatternNum, searchResult);		

	m_vImageTemp1.resize(nPatternNum, imgInput);
	m_vImageTemp2.resize(nPatternNum, imgInput);

	//	m_vDibTemp.resize(nPatternNum);
	m_vstrTemp.resize(nPatternNum);
	m_vImageSaveTemp.resize(nPatternNum);

	m_vbShareSrcCamTransferFinished.resize(m_pPlatformInfo->m_nCamNum,FALSE);

	m_vcsResource.resize(nPatternNum);

	m_vSaveCalibSearchImageFailIndex.resize(nPatternNum, 0);
	m_vSaveAlignerTargetSearchImageFailIndex.resize(nPatternNum, 0);
	m_vSaveAlignerObjectSearchImageFailIndex.resize(nPatternNum, 0);
	m_vSaveAlignerVirtualSearchImageFailIndex.resize(nPatternNum, 0);
	m_vSaveAlignerCalibTargetSearchImageFailIndex.resize(nPatternNum, 0);
	m_vSaveAlignerInspectSearchImageFailIndex.resize(nPatternNum, 0);

	m_vSaveCalibSearchImageIndex.resize(nPatternNum, 0);
	m_vSaveAlignerTargetSearchImageIndex.resize(nPatternNum, 0);
	m_vSaveAlignerObjectSearchImageIndex.resize(nPatternNum, 0);
	m_vSaveAlignerVirtualSearchImageIndex.resize(nPatternNum, 0);
	m_vSaveAlignerCalibTargetSearchImageIndex.resize(nPatternNum, 0);
	m_vSaveAlignerInspectSearchImageIndex.resize(nPatternNum, 0);
	m_vSaveAlignerCalibSearchVDBFileIndex.resize(nPatternNum, 0);
	m_vSaveAlignerTargetSearchVDBFileIndex.resize(nPatternNum, 0);
	m_vSaveAlignerObjectSearchVDBFileIndex.resize(nPatternNum, 0);
	m_vSaveAlignerVirtualSearchVDBFileIndex.resize(nPatternNum, 0);
	m_vSaveAlignerCalibTargetSearchVDBFileIndex.resize(nPatternNum, 0);
	m_vSaveAlignerInspectSearchVDBFileIndex.resize(nPatternNum, 0);

	LoadImageIndexInfo();

	// 隐藏搜索结果图形相关
	//	m_vbExitHideSearchGuiThread.resize(nPatternNum, FALSE);
	//	m_vbHideSearchResultGui.resize(nPatternNum, FALSE);
	//	m_vbHideSearchResultGuiEnd.resize(nPatternNum, TRUE);

	// 光源切换线程相关
	m_vbExitLightCtrlThread.resize(MAXLightControl, FALSE);
	m_vbLightCtrlSuspended.resize(MAXLightControl, FALSE);
	m_vbLightCtrlStart.resize(MAXLightControl, FALSE);
	m_vbLightCtrlEnd.resize(MAXLightControl, TRUE);
	m_vbLightCtrSucceed.resize(MAXLightControl, TRUE);
	std::vector<int> vnChannelIndex;
	std::vector<int> vnIntensity;
	m_vvnChannelIndex.resize(MAXLightControl,vnChannelIndex);
	m_vvnIntensity.resize(MAXLightControl, vnIntensity);
	m_vstrLightCtrlInfo.resize(MAXLightControl, _T(""));

	// 搜索线程相关
	m_vbExitSearchThread.resize(nPatternNum, FALSE);
	m_vbSearchStart.resize(nPatternNum, FALSE);
	m_vbSearchEnd.resize(nPatternNum, TRUE);
	m_vhSearchEndEvent.resize(nPatternNum,NULL);
	m_vbSearchThreadSuspended.resize(nPatternNum, FALSE);

	// 存图线程
	m_vbExitSaveImageThread.resize(nPatternNum, FALSE);
	m_vbSaveImageStart.resize(nPatternNum, FALSE);
	m_vbSaveImageFinish.resize(nPatternNum, FALSE);
	m_vhSaveImageEvent.resize(nPatternNum, FALSE);
	m_vSaveImage.resize(nPatternNum);
	m_vbSaveImageThreadSuspended.resize(nPatternNum, FALSE);

	// 相机曝光
	m_vbExitCameraExposureThread.resize(nPatternNum, 0);
	m_vbCameraExposureStart.resize(nPatternNum, FALSE);
	m_vbCameraExposureEnd.resize(nPatternNum,TRUE);
	m_vhCameraExposureEndEvent.resize(nPatternNum,NULL);
	m_vbCameraExposureThreadSuspended.resize(nPatternNum, FALSE);


	m_vnSnapSearchImageIndex.resize(nPatternNum, 0);
	m_vnSnapSearchImageStartIndex.resize(nPatternNum, 0);
	m_vbSnapSearchImageStart.resize(nPatternNum, FALSE);
	m_vbSnapSearchImageEnd.resize(nPatternNum, TRUE);
	m_vhSnapSearchImageEndEvent.resize(nPatternNum,NULL);
	m_boIsSnapImgSucceed = TRUE;		//  [5/8/2020 zzc]
	m_strSnapImgStatuString = _T("");	//  [5/8/2020 zzc]

	m_vsmSearchMode.resize(nPatternNum, eNoSearch);
	m_vnProcessType.resize(nPatternNum, 0);

	//	m_vcsResourceProc.resize(nPatternNum);


	m_vnCalibSearchStartPatIndex.resize(nPatternNum, -1);
	m_vnCalibSearchEndPatIndex.resize(nPatternNum, -1);
	m_vnCalibSearchSuccessPatIndex.resize(nPatternNum, -1);

	m_vnTargetSearchStartPatIndex.resize(nPatternNum, -1);
	m_vnTargetSearchEndPatIndex.resize(nPatternNum, -1);
	m_vnTargetSearchSuccessPatIndex.resize(nPatternNum, -1);
	m_vnTargetSearchResultNumber.resize(nPatternNum, -1);

	m_vnObjectSearchStartPatIndex.resize(nPatternNum, -1);
	m_vnObjectSearchEndPatIndex.resize(nPatternNum, -1);
	m_vnObjectSearchSuccessPatIndex.resize(nPatternNum, -1);
	m_vnObjectSearchResultNumber.resize(nPatternNum, -1);

	m_vnVirtualObjectSearchStartPatIndex.resize(nPatternNum, -1);
	m_vnVirtualObjectSearchEndPatIndex.resize(nPatternNum, -1);
	m_vnVirtualObjectSearchSuccessPatIndex.resize(nPatternNum, -1);

	m_vnCalibTargetSearchStartPatIndex.resize(nPatternNum, -1);
	m_vnCalibTargetSearchEndPatIndex.resize(nPatternNum, -1);
	m_vnCalibTargetSearchSuccessPatIndex.resize(nPatternNum, -1);

	// 检测
	m_vnInspectSearchStartPatIndex.resize(nPatternNum, -1);
	m_vnInspectSearchEndPatIndex.resize(nPatternNum, -1);
	m_vnInspectSearchSuccessPatIndex.resize(nPatternNum, -1);
	m_vnInspectSearchResultNumber.resize(nPatternNum, -1);

	// 	m_vdTargetSearchShutter.resize(8, 1);
	// 	m_vdObjectSearchShutter.resize(8, 1);
	// 	m_vdTarObjSepCalibSearchShutter.resize(8, 1);
	//	m_vdInspectSearchShutter.resize(8, 1);

	m_phPosEvent = new HANDLE[nPatternNum];

	// 	CHideSearchGUIObject* pHideSearchGuiObject = NULL;
	// 	CHideSearchGUIObject* pHideSearchGuiObject1 = NULL;

	CSearchObject* pSearchObject = NULL;
	CSaveImageObject* pSaveImageObject = NULL;


	DWORD dwReturn = 0;	
	m_vbShareCamTransferSame.resize(m_pPlatformInfo->m_nCamNum,FALSE);
	for (i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{	 
		// 1.1 创建相机，并设置相机回调函数
		if(GetCameraShareType(i)==eShareTar)
		{
			pPTGrab = NULL;
			pcbCallbackObject = NULL;
		}
		else
		{
			pPTGrab = new scPTGrab2();
			pcbCallbackObject = new CCameraCallbackObject;
			pcbCallbackObject->m_nCamIndex = i;
			pcbCallbackObject->m_pOwner = this;
		}

		//pPTGrab = scPTGrab2::CreateCamera();
		m_vpCamera.push_back(pPTGrab);


		m_vpCamOwner.push_back(pcbCallbackObject); 	
		PTStatus tmpPTStatus = ePTGrabOK;
		m_vPTCameraIsOnLine.push_back(tmpPTStatus);

		// 		if (m_pPlatformInfo->m_nCamNum==1)
		// 		{
		// 			pcbCallbackObject1 = new CCameraCallbackObject;
		// 			pcbCallbackObject1->m_nCamIndex = 1;
		// 			pcbCallbackObject1->m_pOwner = this;
		// 			m_vpCamOwner.push_back(pcbCallbackObject1);
		// 		}
		// 		
		// 		pHideSearchGuiObject = new CHideSearchGUIObject;
		// 		pHideSearchGuiObject->m_nCamIndex = i;
		// 		pHideSearchGuiObject->m_pOwner = this;
		// 		m_vpHideSearchGUIObject.push_back(pHideSearchGuiObject);
		// 		if (m_pPlatformInfo->m_nCamNum==1)
		// 		{
		// 			pHideSearchGuiObject1 = new CHideSearchGUIObject;
		// 			pHideSearchGuiObject1->m_nCamIndex = 1;
		// //			pHideSearchGuiObject1->m_nPatIndex = 0;
		// 			pHideSearchGuiObject1->m_pOwner = this;
		// 			m_vpHideSearchGUIObject.push_back(pHideSearchGuiObject1);
		// 		}
#ifdef READ_LOCAL_IMAGE
		m_vbCameraLiveGrab.push_back(TRUE);	
#else
		m_vbCameraLiveGrab.push_back(bLiveGrab);	
#endif
		if (GetCameraShareType(i) != eShareTar)
		{
			pPTGrab->SetOwner(m_vpCamOwner.at(i), GrabImageFinishedCallback);
		}

		// 1.2 对相机进行初始化，并添加对应的接收图像对象、图像显示控制指针
		if (FALSE == InitCamera(i))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_INIT_FAILED);	//_T("相机初始化失败")
			m_strStatusBarInfo2 = _T("");

			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			dwReturn |= INIT_CAMERA_FAILED | (0x00000001<<i); 

			continue;
		}

		// 1.3 设置相机的视频模式、帧率、曝光时间、增益等   
		if(FALSE == UpdateCameraStatus(i))
		{		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_STATUS_SET_FAILED);	//_T("相机状态设置失败")
			m_strStatusBarInfo2 = _T("");

			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			dwReturn |= INIT_CAMERA_PARAM_FAILED;
		}
		// 		else
		// 		{
		// 			SaveCameraInfo();
		// 		}
	}
	// 保存相机的视频模式、帧率、曝光时间、增益等 
	SaveCameraInfo();

	// 	// 隐藏搜索结果线程
	// 	for(i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
	// 	{		
	// 		pHideSearchGuiObject = new CHideSearchGUIObject;
	// 		pHideSearchGuiObject->m_nCamIndex = m_pVisionASMConfig->m_vPosInfo[i].m_nCamIndex;
	// 		pHideSearchGuiObject->m_pOwner = this;
	// 		m_vpHideSearchGUIObject.push_back(pHideSearchGuiObject);
	// 	}

	// 搜索线程
	for(i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
	{		
		pSearchObject = new CSearchObject;
		pSearchObject->m_nPosIndex = i;
		pSearchObject->m_nCamIndex = m_pVisionASMConfig->m_vPosInfo[i].m_nCamIndex;
		pSearchObject->m_pOwner = this;
		m_vpSearchObject.push_back(pSearchObject);
		m_vhSearchEndEvent[i] = CreateEvent(NULL,true,false,_T(""));

		m_vhSnapSearchImageEndEvent[i] = CreateEvent(NULL,true,false,_T(""));
	}

	// 存图线程
	for(i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
	{		
		pSaveImageObject = new CSaveImageObject;
		pSaveImageObject->m_nPosIndex = i;
		pSaveImageObject->m_nCamIndex = m_pVisionASMConfig->m_vPosInfo[i].m_nCamIndex;
		pSaveImageObject->m_pOwner = this;
		m_vpSaveImageObject.push_back(pSaveImageObject);
		m_vhSaveImageEvent[i] = CreateEvent(NULL,true,false,_T(""));
	}

	// 光源切换线程
	CLightCtrlObject* pLightCtrlObject = NULL;
	for(i = 0; i < MAXLightControl; i++)
	{		
		pLightCtrlObject = new CLightCtrlObject;
		pLightCtrlObject->m_nLightCtrlIndex = i;
		pLightCtrlObject->m_pOwner = this;
		m_vpLightCtrlObject.push_back(pLightCtrlObject);
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	// 相机曝光线程
	m_vvdTargetSearchShutter.resize(nPatternNum);
	for (int i = 0; i < m_vvdTargetSearchShutter.size(); i++)
	{
		m_vvdTargetSearchShutter[i].resize(TARGETCANDIDATENUM);
	}

	m_vvdObjectSearchShutter.resize(nPatternNum);
	for (int i = 0; i < m_vvdObjectSearchShutter.size(); i++)
	{
		m_vvdObjectSearchShutter[i].resize(OBJECTCANDIDATENUM);
	}

	m_vvdCalibTargetSearchShutter.resize(nPatternNum);
	for (int i = 0; i < m_vvdCalibTargetSearchShutter.size(); i++)
	{
		m_vvdCalibTargetSearchShutter[i].resize(OBJECTCANDIDATENUM);
	}

	m_vvdVirtualObjectSearchShutter.resize(nPatternNum);
	for (int i = 0; i < m_vvdVirtualObjectSearchShutter.size(); i++)
	{
		m_vvdVirtualObjectSearchShutter[i].resize(OBJECTCANDIDATENUM);
	}

	m_vvdInspectSearchShutter.resize(nPatternNum);
	for (int i = 0; i < m_vvdInspectSearchShutter.size(); i++)
	{
		m_vvdInspectSearchShutter[i].resize(INSPECTCANDIDATENUM);
	}


	m_vsmSearchCameraExposureType.resize(nPatternNum, eNoSearchCameraExposure);
	CCameraExposureObject* pCameraExposureObject = NULL;
	for(i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
	{		
		pCameraExposureObject = new CCameraExposureObject;
		pCameraExposureObject->m_nPosIndex = i;
		pCameraExposureObject->m_nCamIndex = m_pVisionASMConfig->m_vPosInfo[i].m_nCamIndex;
		pCameraExposureObject->m_pOwner = this;
		pCameraExposureObject->m_nPatIndex = 0;
		m_vpCameraExposureObject.push_back(pCameraExposureObject);
		m_vhCameraExposureEndEvent[i] = CreateEvent(NULL,true,false,_T(""));

	}

	m_mpDmCodeImagePos.SetMarkImagePosNum(nPatternNum);
	m_mpDmCodeBoardPos.SetMarkImagePosNum(nPatternNum);

	m_vDmCodeCalibTool.resize(m_pPlatformInfo->m_nPositionNum);
	m_vmmCalibTargetType.resize(2);
	m_vmmPreCalibTargetType.resize(2);
	for (i=0;i<2;i++)
	{
		m_vmmCalibTargetType.at(i).resize(m_pPlatformInfo->m_nPositionNum,eSinglePatternSingleMark);
		m_vmmPreCalibTargetType.at(i).resize(m_pPlatformInfo->m_nPositionNum,eSinglePatternSingleMark);
	}
	m_vpGuiCalibrateGraphics.resize(m_pPlatformInfo->m_nPositionNum);
	m_vpPreGuiCalibrateDisplay.resize(m_pPlatformInfo->m_nPositionNum,NULL);
	for (i=0;i<m_pPlatformInfo->m_nPositionNum;i++)
	{
		m_vpGuiCalibrateGraphics.at(i)=new CGuiGraphics;
	}

	for (i=0;i<m_vDmCodeCalibTool.size();i++)
	{
		m_vDmCodeCalibTool.at(i).SetGuiGraphics(m_vpGuiCalibrateGraphics.at(i));
	}
	m_vBoardPosForTarFixOffset.resize(m_pPlatformInfo->m_nPositionNum);


	// 2. 初始化图像变换工具

	for (i=0; i<nPatternNum; i++)
	{
		InitializeCriticalSection(&m_vcsResource.at(i));		
		//		InitializeCriticalSection(&m_vcsResourceProc.at(i));

		m_vImageInput.push_back(imgInput);
		m_vImageSearch.push_back(imgInput);
		m_vpGuiDisplay.push_back(pGuiDisplay);

		dmDisplayModule.SetRotationType(eRotate0);
		dmDisplayModule.SetMirrorType();
		dmDisplayModule.SetROI();

		// 旋转
		RotateType rotateType;
		switch (m_pVisionASMConfig->m_vImageRoi[i].m_nRotation)
		{
		case 0:
			{
				rotateType = eRotate0;
			}
			break;
		case 1:
			{
				rotateType = eRotate90;
			}
			break;
		case 2:
			{
				rotateType = eRotate180;
			}
			break;
		case 3:
			{
				rotateType = eRotate270;
			}
			break;
		default:
			{
				rotateType = eRotate0;
			}
			break;					  
		}

		dmDisplayModule.SetRotationType(rotateType);

		// 镜像
		BOOL bCheckHorizMirror = m_pVisionASMConfig->m_vImageRoi[i].m_bMirrorHoriz;
		BOOL bCheckVertMirror  = m_pVisionASMConfig->m_vImageRoi[i].m_bMirrorVert;

		if (bCheckHorizMirror && bCheckVertMirror)
		{
			dmDisplayModule.SetMirrorType(eHorVerMirror);
		}
		else if (bCheckVertMirror&&(!bCheckHorizMirror))
		{
			dmDisplayModule.SetMirrorType(eVerMirror);
		}
		else if((!bCheckVertMirror)&&bCheckHorizMirror)
		{
			dmDisplayModule.SetMirrorType(eHorMirror);
		}
		else
		{
			dmDisplayModule.SetMirrorType();
		}  

		// Gamma
		BOOL bGammaCorrectionEnable = m_pVisionASMConfig->m_vImageRoi[i].m_bGammaCorrectionEnable;
		double dGamma = m_pVisionASMConfig->m_vImageRoi[i].m_dGamma;

		dmDisplayModule.SetGammaCorrectionEnable(bGammaCorrectionEnable);
		dmDisplayModule.SetGammaPara(dGamma);

		m_vImageTransfer.push_back(dmDisplayModule);  	
	}

	// 3.0 初始化协议
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	m_XYDCommProtocol.SetPlatformIndex(sysPlatformInfo.m_nPlatformIndex);
	m_XYDCommProtocol.SetMidPlatformInfo(sysPlatformInfo.m_eMidPlatformType, GetMidPlatformInfo());
	m_XYDCommProtocol.SetEnableCommMultiCalibExtension(sysPlatformInfo.m_bEnableMultiCalibExtension && optionInfo.m_bEnableCommMultiCalibExtension);
	m_XYDCommProtocol.SetEnableCommMutiTarget(optionInfo.m_bEnableMutiTarget);

	// 设置通信参数
	m_XYDCommProtocol.SetCmdParamOrderType(m_pVisionASMConfig->m_CommParamInfo.m_eCmdParamOrderType);
	m_XYDCommProtocol.SetProtocolType(m_pVisionASMConfig->m_CommParamInfo.m_eProtocolType);
	m_XYDCommProtocol.SetExProtocolType(m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType);
	m_XYDCommProtocol.SetPLCRegType(m_pVisionASMConfig->m_CommParamInfo.m_bRegiterType);
	m_XYDCommProtocol.SetPLCRegDataTypeIndex(m_pVisionASMConfig->m_CommParamInfo.m_nRegDataTypeIndex);

	m_XYDCommProtocol.SetPLCBaseRegAddr(100);
	m_XYDCommProtocol.m_vKeyenceCodeParam = m_pVisionASMConfig->m_vKeyenceCodeParam;
	m_XYDCommProtocol.m_bEnableMulRegTrigger = sysPlatformInfo.m_bEnableMulRegTrigger;
	//m_XYDCommProtocol.m_mapMulRegTrigger = sysPlatformInfo.m_mapMulRegTrigger;
	m_XYDCommProtocol.m_vnMulRegTriggerSet = m_pVisionASMConfig->m_PlatformOptionInfo.m_vnMulRegTriggerSet;
	//SetMutiTarget();



	// 	if (0 == sysPlatformInfo.m_nPlatformIndex)
	// 	{
	// 		m_XYDCommProtocol.SetCmdParamOrderType(eCPOrderYXD);
	// 	}
	// 	else if (1 == sysPlatformInfo.m_nPlatformIndex)
	// 	{
	// 		m_XYDCommProtocol.SetCmdParamOrderType(eCPOrderXYD);
	// 	}

	// 3. 初始化通信接口：根据通信接口信息（接口类型及相应的配置信息），初始化通信接口，准备开始接收通信指令信息；
	if (FALSE == InitComm())
	{
		m_bValidComm = FALSE;

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_INIT_FAILED);	//_T("初始化通信接口失败")
		m_strStatusBarInfo2 = _T("");

		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
	}

	if (FALSE == OpenComm())
	{
		m_bValidComm = FALSE;

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OPEN_COMM_PORT_FAILED);	//_T("打开通信接口失败")
		m_strStatusBarInfo2 = _T("");

		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

		dwReturn |= INIT_COMMU_FAILED;
	}
	else
	{
		m_bValidComm = TRUE;
	}

	// 4. 根据当前产品信息初始化相关定位、标定、对位工具
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pProduct == NULL)
	{
		dwReturn |=INIT_VISION_ALIGN_TOOL_FAILED;
	}

	if (FALSE == UpdateCurVisionASMTool(TRUE, TRUE))
	{	
		dwReturn |=INIT_VISION_ALIGN_TOOL_FAILED;
	}

	// 5. 创建平台的对位处理线程
	if(FALSE == CreateWorkThread())
	{
		dwReturn |= INIT_CREATE_THREAD_FAILED;
	}


	return dwReturn;
} 

// 根据当前产品信息初始化相关定位、标定、对位工具
BOOL vcBaseVisionAlign::UpdateCurVisionASMTool(BOOL bUpdateCalibSearchTool /*= TRUE*/, BOOL bUpdateAlignTool/* = FALSE*/)
{   
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	BOOL bResult = FALSE;

	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	//Bug修复：初始调试软件时，流程类中m_pAlignerTool没有new，导致流程中执行指令函数时的空指针调用出现崩溃的bug；
	//通过UpdateCurVisionASMTool()中不进行空产品判断返回的方式执行InitAlignTool函数，确保软件启动后m_pAlignerTool非空；并且对流程类中m_pAlignerTool进行空指针判断和处理，防止崩溃；

	//CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	//if (pProduct == NULL)
	//{
	//	return FALSE;
	//}

	//m_bLoadSingleProductSearchToolEnable优先级高于m_bLoadSingleProductSearchToolEnableFaChd，所以在单产品下，不会加载整个大产品
	if(!m_pPlatformInfo->m_bLoadSingleProductSearchToolEnable)
	{	
		// 启用大小品种且只加载单个大产品时，加载当前品种对应大品种下的其他全部小品种
		if (m_pPlatformInfo->m_bProductFaChd && m_pPlatformInfo->m_bLoadSingleProductSearchToolEnableFaChd)
		{
			bResult = TRUE;
			int nProductIndexFa = 0;
			int nProductIndexChd = 0;
			m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nProductIndexFa, nProductIndexChd);

			int nProductCountChd = m_pVisionASMConfig->m_TotalProductData.GetProductCountChd(nProductIndexFa);
			for (int i =0; i<nProductCountChd; i++)
			{
				int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nProductIndexFa,i);
				if (nProductIndex == nCurProductIndex)
				{
					continue;
				}
				bResult &= UpdateVisionASMTool(nProductIndex, bUpdateCalibSearchTool, bUpdateAlignTool);
			}
			bResult &= UpdateVisionASMTool(nCurProductIndex, bUpdateCalibSearchTool, bUpdateAlignTool);
			return bResult;

		}
	}
	bResult = UpdateVisionASMTool(nCurProductIndex, bUpdateCalibSearchTool, bUpdateAlignTool);

	return bResult;

}            


// 根据当前产品信息初始化相关定位、标定、对位工具
BOOL vcBaseVisionAlign::UpdateVisionASMTool(int nProductIndex , BOOL bUpdateCalibSearchTool /*= TRUE*/, BOOL bUpdateAlignTool/* = FALSE*/)
{   
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	BOOL bResult = TRUE;
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	// 1.更新标定用定位工具（从XML文件读取加载）
	if (bUpdateCalibSearchTool)
	{
		m_bValidCalibSearchTool = InitCalibObjectSearchToolRepository(nProductIndex);
		bResult = m_bValidCalibSearchTool;
	}

	// 2.根据当前产品，更新对位用定位工具

	// 实时目标定位工具
	if (eTargetOnline  == m_pPlatformInfo->m_eAlignerTargetType)
	{
		m_bIsRepositoryInitAlnTargetSearch = InitAlnTargetSearchToolRepository(nProductIndex);
		bResult = bResult&&m_bIsRepositoryInitAlnTargetSearch;

		m_bValidTargetSearchTool = m_bIsRepositoryInitAlnTargetSearch;
		bResult = bResult&&m_bValidTargetSearchTool;

		// 		m_bValidTargetSearchTool = InitAlnTargetSearchTools();
		// 		bResult = bResult&&m_bValidTargetSearchTool;
	}   

	// 初始化对象定位工具库
	m_bIsRepositoryInitAlnObjectSearch = InitAlnObjectSearchToolRepository(nProductIndex);
	bResult = bResult&&m_bIsRepositoryInitAlnObjectSearch;
	m_bValidObjectSearchTool =m_bIsRepositoryInitAlnObjectSearch;
	bResult = bResult&&m_bValidObjectSearchTool;

	// 	// 实时对象定位工具/
	// 	m_bValidObjectSearchTool = InitAlnObjectSearchTools();
	// 	bResult = bResult&&m_bValidObjectSearchTool;

	// 虚拟对象定位工具
	if (eObjectVirtual == m_pPlatformInfo->m_eAlignerObjectType)
	{

		m_bIsRepositoryInitAlnVirtualObjectSearch = InitAlnVirtualObjectSearchToolRepository(nProductIndex);
		bResult = bResult&&m_bIsRepositoryInitAlnVirtualObjectSearch;

		m_bValidVirtualSearchTool= m_bIsRepositoryInitAlnVirtualObjectSearch;
		bResult = bResult&&m_bValidVirtualSearchTool;

		// 		m_bValidVirtualSearchTool= InitAlnVirtualSearchTools();
		// 		bResult = bResult&&m_bValidVirtualSearchTool;
	}

	// 关联标定定位工具
	if ((TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate) || (FALSE == m_pPlatformInfo->m_bTargetObjectCamSeparate && TRUE == m_pPlatformInfo->m_bTargetCalibUseBoard))
	{
		m_bIsRepositoryInitAlnCalibTargetSearch = InitAlnCalibTargetSearchToolRepository(nProductIndex);
		bResult = bResult&&m_bIsRepositoryInitAlnCalibTargetSearch;

		m_bValidCalibTargetSearchTool = m_bIsRepositoryInitAlnCalibTargetSearch;
		bResult = bResult&&m_bValidCalibTargetSearchTool;

		// 		m_bValidCalibTargetSearchTool = InitAlnCalibTargetSearchTools();
		// 		bResult = bResult&&m_bValidCalibTargetSearchTool;
	}

	// 检测模板定位工具
	//if (TRUE == optionInfo.m_bInspectEnable)
	{
		m_bIsRepositoryInitAlnInspectSearch = InitAlnInspectSearchToolRepository(nProductIndex);
		bResult = bResult&&m_bIsRepositoryInitAlnInspectSearch;

		m_bValidInspectSearchTool = m_bIsRepositoryInitAlnInspectSearch;
		bResult = bResult&&m_bValidInspectSearchTool;
	}

	// 3.设置对位工具相关参数
	m_bValidAlignerTool = InitAlignTool(nProductIndex); 
	// 
	// 	if (eTargetOnline == m_pPlatformInfo->m_eAlignerTargetType)
	// 	{
	// 		m_bTargetMarkSearchSucceed = FALSE;
	// 	}	



	bResult = bResult&&m_bValidAlignerTool;

	return bResult;
}                 


// 获取所有产品的存储地址指针
CTotalProductData* vcBaseVisionAlign::GetTotalProuductData() 
{
	if (m_pVisionASMConfig != NULL)
	{
		return &(m_pVisionASMConfig->m_TotalProductData);
	}
	else
	{
		return NULL;
	}
}  

// 获取所有产品标定的存储地址指针
CTotalCalibData* vcBaseVisionAlign::GetTotalCalibData()
{
	if (m_pVisionASMConfig != NULL)
	{
		return &(m_pVisionASMConfig->m_TotalCalibData);
	}
	else
	{
		return NULL;
	}
}

// 设置中间平台信息（与主界面交互）
void vcBaseVisionAlign::SetMidPlatformInfo(CPlatformInfo*	pPlatformInfo)
{
	if ((NULL == pPlatformInfo)||(NULL == m_pVisionASMConfig))
	{
		return;
	}

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	// 	if (sysPlatformInfo.m_eMidPlatformType != pPlatformInfo->GetPlatformType())
	// 	{
	// 		return;
	// 	}

	DeleteMidPlatformInfo();
	switch(sysPlatformInfo.m_eMidPlatformType)
	{
	case ePlatformXYD:
		{
			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		}
		break;
		// 	case ePlatformXYPD:
		// 		{
		// 			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		// 		}
		// 		break;
		// 	case ePlatformXD:
		// 		{
		// 			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		// 		}
		// 		break;
		// 	case ePlatformXY:
		// 		{
		// 			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		// 		}
		// 		break;
		// 	case ePlatformX:
		// 		{
		// 			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		// 		}
		// 		break;
		// 	case ePlatformY:
		// 		{
		// 			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		// 		}
		// 		break;
		// 	case ePlatformXDPY:
		// 		{
		// 			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		// 		}
		// 		break;
		// 	case ePlatformXDPY1:
		// 		{
		// 			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		// 		}
		// 		break;
		// 	case ePlatformYD:
		// 		{
		// 			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		// 		}
		// 		break;
	case ePlatformXY1Y2:
		{
			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXY1Y2Info(*(CPlatformXY1Y2Info*)pPlatformInfo);
		}
		break;
	case ePlatformX1X2Y:
		{
			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformX1X2YInfo(*(CPlatformX1X2YInfo*)pPlatformInfo);
		}
		break;
	default:
		{
			m_pVisionASMConfig->m_pMidPlatformInfo = new CPlatformXYDInfo(*(CPlatformXYDInfo*)pPlatformInfo);
		}
		break;
	}
	return;
}
// 获取中间平台信息	（与主界面交互）
CPlatformInfo* vcBaseVisionAlign::GetMidPlatformInfo()
{
	return m_pVisionASMConfig->m_pMidPlatformInfo;
}

//////////////////////////////////////////////////////////////////////////
// 通信相关

// 初始化通信接口
BOOL vcBaseVisionAlign::InitComm()
{
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		// 共享自其他的通信comm
		if (m_pVisionAlignOther != NULL)
		{
			m_pComm = m_pVisionAlignOther->GetComm();
		}	
		else
		{
			return FALSE;
		}
		return TRUE;
	}


	if ((NULL == m_pPlatformInfo) || (NULL == m_pVisionASMConfig) || (NULL == m_pVisionASMConfig->m_pCommParam))
	{
		return FALSE;
	}

	//if (m_pPlatformInfo->m_eCommType!=m_pVisionASMConfig->m_pCommParam->GetCommType())
	//{
	//	return FALSE;
	//}
	if (m_pVisionASMConfig->m_CommParamInfo.m_eCommType != m_pVisionASMConfig->m_pCommParam->GetCommType())
	{
		return FALSE;
	}

	UninitComm();

	switch(m_pVisionASMConfig->m_pCommParam->GetCommType())
	{
	case eSerial:
		{
			m_pComm = new vcSerialComm;
		}
		break;
	case eSocket:
		{
			m_pComm = new vcSocketComm;
			vcSocketComm::InitWSA(); 
		}
		break;
	default:
		{
			return FALSE;
		}
		break;
	}  	

	// 	SysPlatformInfo sysPlatformInfo;
	// 	GetSysPlatformInfo(sysPlatformInfo);
	// 	m_pComm->SetPlatformIndex(sysPlatformInfo.m_nPlatformIndex);
	// 	m_pComm->SetProtocolType(sysPlatformInfo.m_eProtocolType);

	return TRUE;
}

// 释放通信接口								
void vcBaseVisionAlign::UninitComm()
{
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		return ;
	}

	if (m_pComm!=NULL)
	{
		delete m_pComm;
		m_pComm = NULL;
	}	
}

// 设置通信接口参数
BOOL vcBaseVisionAlign::SetCommParam(vcCommInfo* pCommInfo)
{
	if ((NULL == m_pPlatformInfo)||(NULL == m_pVisionASMConfig)||(NULL == pCommInfo))
	{
		return FALSE;
	}

	if (m_pVisionASMConfig->m_pCommParam != pCommInfo)
	{
		DeleteCommInfo();

		switch(m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
		{
		case eSerial:
			{
				m_pVisionASMConfig->m_pCommParam = new vcSerialCommInfo;      	   

				vcSerialCommInfo* pSerialCommInfoNew = (vcSerialCommInfo*)m_pVisionASMConfig->m_pCommParam;
				vcSerialCommInfo* pSerialCommInfo    = (vcSerialCommInfo*)pCommInfo;

				pSerialCommInfoNew->m_uiComPort    = pSerialCommInfo->m_uiComPort;
				pSerialCommInfoNew->m_uiBaudRate   = pSerialCommInfo->m_uiBaudRate;
				pSerialCommInfoNew->m_Parity       = pSerialCommInfo->m_Parity;
				pSerialCommInfoNew->m_StopBits     = pSerialCommInfo->m_StopBits;
				pSerialCommInfoNew->m_uiDataBits   = pSerialCommInfo->m_uiDataBits;
				pSerialCommInfoNew->m_strCommStop  = pSerialCommInfo->m_strCommStop;
				pSerialCommInfoNew->m_strCmdStop   = pSerialCommInfo->m_strCmdStop;
				pSerialCommInfoNew->m_lRegAddress  = pSerialCommInfo->m_lRegAddress;
				pSerialCommInfoNew->m_lTempRegAddress  = pSerialCommInfo->m_lTempRegAddress;

				m_pVisionASMConfig->m_pCommParam = pSerialCommInfoNew;

			}
			break;
		case  eSocket:
			{
				m_pVisionASMConfig->m_pCommParam = new vcSocketCommInfo;      	   

				vcSocketCommInfo* pSocketCommInfoNew = (vcSocketCommInfo*)m_pVisionASMConfig->m_pCommParam;
				vcSocketCommInfo* pSocketCommInfo    = (vcSocketCommInfo*)pCommInfo;

				pSocketCommInfoNew->m_socketType  = pSocketCommInfo->m_socketType;
				pSocketCommInfoNew->m_uiPort      = pSocketCommInfo->m_uiPort;
				pSocketCommInfoNew->m_uiListenNum = pSocketCommInfo->m_uiListenNum;
				pSocketCommInfoNew->m_strCommStop = pSocketCommInfo->m_strCommStop;
				pSocketCommInfoNew->m_strCmdStop  = pSocketCommInfo->m_strCmdStop;			

				for (int i=0; i<4; i++)
				{
					pSocketCommInfoNew->m_byAddr[i] = pSocketCommInfo->m_byAddr[i];
				}        

				pSocketCommInfoNew->m_lRegAddress  = pSocketCommInfo->m_lRegAddress;
				pSocketCommInfoNew->m_lTempRegAddress  = pSocketCommInfo->m_lTempRegAddress;
				pSocketCommInfoNew->m_lWZRegAddress  = pSocketCommInfo->m_lWZRegAddress;
				pSocketCommInfoNew->m_lRegAddress3  = pSocketCommInfo->m_lRegAddress3;
				m_pVisionASMConfig->m_pCommParam = pSocketCommInfoNew;
			}
			break;
		default:
			{
				return FALSE;
			}
			break;
		}
	}

	return TRUE;
}

// 获取通信接口参数
vcCommInfo* vcBaseVisionAlign::GetCommParam()
{
	if (NULL == m_pVisionASMConfig)
	{
		return NULL;
	}

	return m_pVisionASMConfig->m_pCommParam;
}

// 根据通信接口参数更新通信工具
BOOL vcBaseVisionAlign::UpdateCommTool()
{
	return OpenComm();
}                                   

// 打开通信接口
BOOL vcBaseVisionAlign::OpenComm()
{
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		if ((NULL == m_pVisionASMConfig) || (NULL == m_pVisionASMConfig->m_pCommParam))
		{
			return FALSE;
		}

		if (m_pVisionASMConfig->m_CommParamInfo.m_eCommType !=m_pVisionASMConfig->m_pCommParam->GetCommType())
		{
			return FALSE;
		}

		vcCommInfo* pCommInfo = m_pVisionASMConfig->m_pCommParam;
		if (eSerial == m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
		{
			vcSerialCommInfo* pSerialCCommInfo = new vcSerialCommInfo;

			*pSerialCCommInfo = (*(vcSerialCommInfo*)pCommInfo);
			m_XYDCommProtocol.SetPLCBaseRegAddr(pSerialCCommInfo->m_lRegAddress);
			m_XYDCommProtocol.SetPLCTempBaseRegAddr(pSerialCCommInfo->m_lTempRegAddress);
			m_XYDCommProtocol.m_vKeyenceCodeParam = m_pVisionASMConfig->m_vKeyenceCodeParam;
			if (pSerialCCommInfo !=  NULL)
			{
				delete pSerialCCommInfo;
				pSerialCCommInfo = NULL;
			}
		}
		else if (eSocket == m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
		{
			vcSocketCommInfo* pSocketCommInfo = new vcSocketCommInfo;

			*pSocketCommInfo = (*(vcSocketCommInfo*)pCommInfo);
			m_XYDCommProtocol.SetPLCBaseRegAddr(pSocketCommInfo->m_lRegAddress);
			m_XYDCommProtocol.SetPLCTempBaseRegAddr(pSocketCommInfo->m_lTempRegAddress);
			m_XYDCommProtocol.SetPLCWZRegAddr(pSocketCommInfo->m_lWZRegAddress);
			m_XYDCommProtocol.SetPLCIDRegAddr(pSocketCommInfo->m_lRegAddress3);
			m_XYDCommProtocol.SetEnableIDRead(pSocketCommInfo->m_bEnableIDRaed);
			m_XYDCommProtocol.SetPLCIDLength(pSocketCommInfo->m_nIDLength);
			m_XYDCommProtocol.SetEnableIDInvert(pSocketCommInfo->m_bIDInvert);
			m_XYDCommProtocol.m_vKeyenceCodeParam = m_pVisionASMConfig->m_vKeyenceCodeParam;
			if (pSocketCommInfo !=  NULL)
			{
				delete pSocketCommInfo;
				pSocketCommInfo = NULL;
			}
		}

		if (m_pVisionAlignOther != NULL)
		{
			m_bValidComm = m_pVisionAlignOther->IsCommOpen();
		}
		else
		{
			m_bValidComm = FALSE;
		}		

		if (m_bValidComm)
		{
			m_CommStatus = eCommSucceed;
		}
		else
		{
			m_CommStatus = eCommUnConnect;
		}

		return m_bValidComm;
	}


	if ((NULL == m_pVisionASMConfig) || (NULL == m_pVisionASMConfig->m_pCommParam))
	{
		return FALSE;
	}

	if (m_pVisionASMConfig->m_CommParamInfo.m_eCommType!=m_pVisionASMConfig->m_pCommParam->GetCommType())
	{
		return FALSE;
	}

	vcCommInfo* pCommInfo = m_pVisionASMConfig->m_pCommParam;

	if (eSocket == m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
	{
		vcSocketComm::InitWSA(); 
	}

	LockShareComm(); //加锁共享通信

	// 设置通信协议类型
	if (m_pComm != NULL)
	{
		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		m_pComm->SetPlatformIndex(sysPlatformInfo.m_nPlatformIndex);
		m_pComm->SetProtocolType(m_pVisionASMConfig->m_CommParamInfo.m_eProtocolType);

		if (m_XYDCommProtocol.IsPlcProtocolType())
		{
			m_pComm->SetTimeout(2000);	// 寄存器通信超时200ms
		}
		else
		{
			m_pComm->SetTimeout(30000);	// 无协议通信超时30000ms
		}
	}

	// FM 2013.02.24 
	// 当通知终止符为字符串"CR"时，强制转换为字符CR本来所代表的值0x0D
	if (eSerial == m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
	{
		vcSerialCommInfo* pSerialCCommInfo = new vcSerialCommInfo;

		*pSerialCCommInfo = (*(vcSerialCommInfo*)pCommInfo);
		if (_T("CR") == pSerialCCommInfo->m_strCommStop)
		{
			CString strCR = CString(char(0x0D));
			CString strCommStop = strCR;
			pSerialCCommInfo->m_strCommStop = strCommStop;
		}
		else if (_T("CRLF") == pSerialCCommInfo->m_strCommStop)
		{
			CString strCR = CString(char(0x0D));
			CString strLF = CString(char(0x0A));
			CString strCommStop = strCR + strLF;
			pSerialCCommInfo->m_strCommStop = strCommStop;
		}

		// 		SysPlatformInfo sysPlatformInfo;
		// 		GetSysPlatformInfo(sysPlatformInfo);
		// 		m_pComm->SetPlatformIndex(sysPlatformInfo.m_nPlatformIndex);
		// 		m_pComm->SetProtocolType(sysPlatformInfo.m_eProtocolType);

		m_XYDCommProtocol.SetPLCBaseRegAddr(pSerialCCommInfo->m_lRegAddress);
		m_XYDCommProtocol.SetPLCTempBaseRegAddr(pSerialCCommInfo->m_lTempRegAddress);

		m_bValidComm = m_pComm->Open(pSerialCCommInfo);
		if (!m_bValidComm)
		{
			for(int i = 0; i < 1; i++)
			{
				m_bValidComm = m_pComm->Open(pSerialCCommInfo);
				if (m_bValidComm)
				{
					break;
				}
			}
		}

		if (m_bValidComm)
		{
			m_CommStatus = eCommSucceed;
		}
		else
		{
			m_CommStatus = eCommUnConnect;
		}

		if (pSerialCCommInfo !=  NULL)
		{
			delete pSerialCCommInfo;
			pSerialCCommInfo = NULL;
		}
	}
	else if (eSocket == m_pVisionASMConfig->m_CommParamInfo.m_eCommType)
	{
		vcSocketCommInfo* pSocketCommInfo = new vcSocketCommInfo;

		*pSocketCommInfo = (*(vcSocketCommInfo*)pCommInfo);
		if (_T("CR") == pSocketCommInfo->m_strCommStop)
		{
			CString strCR = CString(char(0x0D));
			CString strCommStop = strCR ;
			pSocketCommInfo->m_strCommStop = strCommStop;
		}
		else if (_T("CRLF") == pSocketCommInfo->m_strCommStop)
		{
			CString strCR = CString(char(0x0D));
			CString strLF = CString(char(0x0A));
			CString strCommStop = strCR + strLF;
			pSocketCommInfo->m_strCommStop = strCommStop;
		}

		// 		SysPlatformInfo sysPlatformInfo;
		// 		GetSysPlatformInfo(sysPlatformInfo);
		// 		m_pComm->SetPlatformIndex(sysPlatformInfo.m_nPlatformIndex);
		// 		m_pComm->SetProtocolType(sysPlatformInfo.m_eProtocolType);

		m_XYDCommProtocol.SetPLCBaseRegAddr(pSocketCommInfo->m_lRegAddress);
		m_XYDCommProtocol.SetPLCTempBaseRegAddr(pSocketCommInfo->m_lTempRegAddress);
		m_XYDCommProtocol.SetPLCWZRegAddr(pSocketCommInfo->m_lWZRegAddress);
		m_XYDCommProtocol.SetPLCIDRegAddr(pSocketCommInfo->m_lRegAddress3);
		m_XYDCommProtocol.SetEnableIDRead(pSocketCommInfo->m_bEnableIDRaed);
		m_XYDCommProtocol.SetPLCIDLength(pSocketCommInfo->m_nIDLength);
		m_XYDCommProtocol.SetEnableIDInvert(pSocketCommInfo->m_bIDInvert);
		// 强制为UDP
		if (eProRegMitsubishiQSocketAsciiUDP == m_pVisionASMConfig->m_CommParamInfo.m_eProtocolType ||
			eProRegMitsubishiQSocketBinaryUDP == m_pVisionASMConfig->m_CommParamInfo.m_eProtocolType)
		{
			pSocketCommInfo->m_socketProtoType = eSPTProtoUDP;
		}
		else
		{
			pSocketCommInfo->m_socketProtoType = eSPTProtoTCP;
		}

		m_pComm->Close();
		m_bValidComm = m_pComm->Open(pSocketCommInfo);

		if (m_bValidComm  && eProRegOmronSocketFins == m_pVisionASMConfig->m_CommParamInfo.m_eProtocolType)
		{
			vcSocketCommInfo localSocketCommInfo;
			BOOL bRetVal = ((vcSocketComm*)(m_pComm))->GetLocalCommInfo(&localSocketCommInfo);
			if (bRetVal == TRUE)
			{
				m_XYDCommProtocol.SetServerCommInfo(pSocketCommInfo);
				m_XYDCommProtocol.SetLocalCommInfo(&localSocketCommInfo);
				m_bValidComm = CommShakeHands();
			}
			else
			{
				m_bValidComm = FALSE;
			}
		}
		// 		if (!m_bValidComm)
		// 		{
		// 			for(int i = 0; i < 1; i++)
		// 			{
		// 				m_bValidComm = m_pComm->Open(pSocketCommInfo);
		// 				if (m_bValidComm)
		// 				{
		// 					break;
		// 				}
		// 			}
		// 		}

		if (m_bValidComm)
		{
			m_CommStatus = eCommSucceed;
		}
		else
		{
			m_CommStatus = eCommUnConnect;
		}

		if (pSocketCommInfo !=  NULL)
		{
			delete pSocketCommInfo;
			pSocketCommInfo = NULL;
		}
	}

	UnlockShareComm(); //解锁共享通信;
	return m_bValidComm;
}

// 重新打开通信接口
BOOL vcBaseVisionAlign::ReOpenComm()
{

	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		return (m_pVisionAlignOther != NULL) && (m_pVisionAlignOther->IsCommOpen());
	}

	if (m_XYDCommProtocol.IsPlcProtocolType())	// 如果是PLC直接读取存储寄存器协议
	{
		if (m_CommStatus != eCommSucceed
			&& m_CommStatus != eCommStop
			/*&& m_CommStatus != eCommTimeOut*/)
		{ 
			if (OpenComm())
			{
				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);//_T("通信异常");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_RECONNECT_SUCCEED);//_T("重新连接成功");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			}
			else
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);//_T("通信异常");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_RECONNECT_FAILED);//_T("重新连接失败");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				int i = 0;
				while(!m_bStopNow)
				{
					i++;
					if (i>50)
					{
						break;
					}
					Sleep(10);
				}
			}

			SYSTEMTIME tm;
			GetLocalTime(&tm);
			CString strTime,strSendLog;
			CString tmpstr;

			int iplat= GetSysPlatformIndex();

			tmpstr.Format(_T("  重新打开通信接口 通讯异常  平台%d"),iplat);
			strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
			strSendLog = strTime +_T("-------ReOpenComm    ")+tmpstr;
			VisionAlignLogRecord(_T("D:\\VisionASMLog\\commErrorLog.txt"),strSendLog);

		}

	}
	else // 如果通用无协议
	{
		if (m_CommStatus != eCommSucceed
			&& m_CommStatus != eCommStop
			&& m_CommStatus != eCommTimeOut)
		{
			if (OpenComm())
			{
				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);//_T("通信异常");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_RECONNECT_SUCCEED);//_T("重新连接成功");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			}
			else
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);//_T("通信异常");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_RECONNECT_FAILED);//_T("重新连接失败");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				int i = 0;
				while(!m_bStopNow)
				{
					i++;
					if (i>50)
					{
						break;
					}
					Sleep(10);
				}
			}

		}






	}
	return TRUE;
}

// 关闭通信接口					
BOOL vcBaseVisionAlign::CloseComm()
{
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		return (m_pVisionAlignOther != NULL) && (!m_pVisionAlignOther->IsCommOpen());
	}

	if (NULL == m_pComm)
	{
		m_CommStatus = eCommUnConnect;
		return FALSE;
	}

	if(m_pComm->Close()) 
	{
		m_bValidComm = FALSE;
		m_CommStatus = eCommUnConnect;
		return TRUE;
	}
	else
	{
		m_CommStatus = eCommUnConnect;
		return FALSE;
	}
}
// 开始接收数据
BOOL vcBaseVisionAlign::StartReceiveComm()
{
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		return TRUE;
	}

	if (m_pComm != NULL)
	{
		if (m_pComm->StartRecieveData())
		{
			m_CommStatus = eCommSucceed;
			return TRUE;
		}
		else
		{
			m_CommStatus = eCommUnConnect;
			return FALSE;
		};
	}
	return TRUE;
}

// 停止接收数据
BOOL vcBaseVisionAlign::StopReceiveComm()
{
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		return TRUE;
	}
	if (m_pComm != NULL)
	{
		if (m_pComm->StopRecieveData())
		{
			m_CommStatus = eCommStop;
			return TRUE;
		}
		else
		{
			m_CommStatus = eCommUnConnect;
			return FALSE;
		}
	}
	return TRUE;
}

// 接收通信接口命令信息							
BOOL vcBaseVisionAlign::ReceiveCommInfo(CString& strInfo, BOOL bReset/* = FALSE*/, BOOL bLog/* = TRUE*/)
{	
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		InitComm();
	}

	if (bReset == TRUE)
	{
		if (m_pComm != NULL)
		{
			m_pComm->ClearRecievedData();
		}
		return TRUE;
	}
	if (NULL == m_pComm)
	{
		return FALSE;
	}

	m_CommStatus = m_pComm->RecieveData(strInfo);
	if (m_CommStatus != eCommSucceed)
	{
		return FALSE;
	}

	// 	if (FALSE == m_pComm->RecieveData(strInfo))
	// 	{
	// 		return FALSE;
	// 	}

	// 接收延时
	if (m_pSystempOptionConfig->m_bCommRecDelayEnable == TRUE)
	{
		Sleep(m_pSystempOptionConfig->m_nCommRecDelayTime);
	}

	// 获取时间	
	SYSTEMTIME tm;
	GetLocalTime(&tm);
	CString strTime;
	strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);

	CString strTimeInfo;
	strTimeInfo = strTime + strInfo;

	if (bLog)
	{
		AddCommCommandInfo(FALSE, strTimeInfo,TRUE);
	}


	if (m_pVisionASMConfig)
	{
		if (m_pVisionASMConfig->m_DataRecord.m_bCommunication && bLog)
		{	
			// 			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
			// 			CString strOut =strTemp + _T("Receive:") + strInfo;
			// 
			// 			FILE *stream;		
			// 			stream = fopen(m_strCommunicationData, _T("a+t"));
			// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
			// 			fclose(stream);	VCRemoveFile(m_strCommunicationData);		

			CString strOut;
			strOut = _T("\n");
			VisionAlignLogRecord(m_strCommunicationData, strOut, FALSE);

			strOut =_T("Rece:") + strTime + strInfo;
			VisionAlignLogRecord(m_strCommunicationData, strOut);
		}
	}

	return TRUE;
}

// 接收通信接口命令信息							
BOOL vcBaseVisionAlign::ReceiveCommInfo2(CString& strInfo, CString& strFrontInfo, BOOL bReset/* = FALSE*/, BOOL bLog/* = TRUE*/)
{
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		InitComm();
	}

	if (bReset == TRUE)
	{
		if (m_pComm != NULL)
		{
			m_pComm->ClearRecievedData();
		}
		return TRUE;
	}
	if (NULL == m_pComm)
	{
		return FALSE;
	}

	m_CommStatus = m_pComm->RecieveData2(strInfo, strFrontInfo);
	if (m_CommStatus != eCommSucceed)
	{
		return FALSE;
	}

	// 	if (FALSE == m_pComm->RecieveData2(strInfo, strFrontInfo))
	// 	{
	// 		return FALSE;
	// 	}

	// 接收延时
	if (m_pSystempOptionConfig->m_bCommRecDelayEnable == TRUE)
	{
		Sleep(m_pSystempOptionConfig->m_nCommRecDelayTime);
	}

	if (bLog)
	{
		if (FALSE == strFrontInfo.IsEmpty())
		{
			AddCommCommandInfo(FALSE, strFrontInfo);
		}

		AddCommCommandInfo(FALSE, strInfo);
	}

	if (m_pVisionASMConfig)
	{
		if (m_pVisionASMConfig->m_DataRecord.m_bCommunication && bLog && !strFrontInfo.IsEmpty())
		{	
			// 			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
			// 			CString strOut =strTemp + _T("Receive:") + strFrontInfo;
			// 
			// 			FILE *stream;		
			// 			stream = fopen(m_strCommunicationData, _T("a+t"));
			// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
			// 			fclose(stream);	VCRemoveFile(m_strCommunicationData);	

			CString strOut;
			strOut = _T("\n");
			VisionAlignLogRecord(m_strCommunicationData, strOut, FALSE);

			strOut =_T("Rece:") + strFrontInfo;
			VisionAlignLogRecord(m_strCommunicationData, strOut);
		}

		if (m_pVisionASMConfig->m_DataRecord.m_bCommunication && bLog)
		{	
			// 			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
			// 			CString strOut =strTemp + _T("Receive:") + strInfo;
			// 
			// 			FILE *stream;		
			// 			stream = fopen(m_strCommunicationData, _T("a+t"));
			// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
			// 			fclose(stream);	VCRemoveFile(m_strCommunicationData);		

			CString strOut;
			strOut = _T("\n");
			VisionAlignLogRecord(m_strCommunicationData, strOut, FALSE);

			strOut =_T("Rece:") + strInfo;
			VisionAlignLogRecord(m_strCommunicationData, strOut);
		}
	}

	return TRUE;
}

// 向通信接口发送命令信息
BOOL vcBaseVisionAlign::SendCommInfo(CString strInfo, BOOL bLog/* = TRUE*/, CString strShow /*= _T("")*/)
{	
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		InitComm();
	}

	if (NULL == m_pComm)
	{
		return FALSE;
	}
	//////////////////////////////////////////////////////////////////////////
	//fumin20180119
	//寄存器通信时进入关联界面获取轴位置时获取以前的位置信息bug

	if (m_XYDCommProtocol.IsPlcProtocolType())
	{
		CString strTemp;
		ReceiveCommInfo(strTemp,TRUE);
	}

	CCommOptionInfo commOptionInfo;
	GetCommOptionInfo(commOptionInfo);
	if (commOptionInfo.m_nCommDelay > 0)
	{
		Sleep(commOptionInfo.m_nCommDelay);
	}
	//if (m_pSystempOptionConfig->m_nCommDelay > 0)
	//{
	//	Sleep(m_pSystempOptionConfig->m_nCommDelay);
	//}



	// 获取时间	
	SYSTEMTIME tm;
	GetLocalTime(&tm);
	CString strTime;
	strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);

	if (FALSE == m_pComm->SendData(strInfo))
	{
		m_CommStatus = eCommUnConnect;
		return FALSE;
	}

	CString strTimeInfo;
	strTimeInfo = strTime + strInfo;

	if (bLog)
	{
		AddCommCommandInfo(TRUE,strTimeInfo,TRUE);
		if (!m_XYDCommProtocol.IsPlcProtocolType())
		{
			if (strShow == _T(""))
			{
				AddCommCommandInfo(TRUE,strInfo,FALSE,FALSE);
			}
			else
			{
				AddCommCommandInfo(TRUE,strShow,FALSE,FALSE);
			}
		}
	}

	if (m_pVisionASMConfig)
	{
		if (m_pVisionASMConfig->m_DataRecord.m_bCommunication && bLog)
		{			
			// 			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
			// 			CString strOut = strTemp + _T("Send:") + strInfo/* +_T("\\")*/;
			// 
			// 			FILE *stream;
			// 			stream = fopen(m_strCommunicationData, _T("a+t"));
			// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(m_strCommunicationData);		

			CString strOut;
			strOut = _T("\n");
			VisionAlignLogRecord(m_strCommunicationData, strOut, FALSE);

			strOut =_T("Send:") +strTime+ strInfo;
			VisionAlignLogRecord(m_strCommunicationData, strOut);
		}
	}

	return TRUE;
}				

// 判断通信接口是否已经打开
BOOL vcBaseVisionAlign::IsCommOpen()
{
	// 如果是共享的通信接口，共享自其他的通信comm
	if (eShareCommTar == GetShareCommType())
	{
		if (m_pVisionAlignOther != NULL)
		{
			m_bValidComm = m_pVisionAlignOther->IsCommOpen();
		}
		else
		{
			m_bValidComm = FALSE;
		}
	}

	return m_bValidComm;
}			

// 在规定时间内等待指令响应
int vcBaseVisionAlign::WaitCommInfo(int time, CString& strInfo) 
{
	if ((NULL == m_pComm)||(FALSE == m_pComm->IsValid()))
	{
		return 0;   
	}

	scTimer Timer;
	Timer.Reset();

	BOOL bReceived = m_pComm->RecieveData(strInfo);
	while (!bReceived)
	{
		Sleep(1);
		bReceived = m_pComm->RecieveData(strInfo);

		if (Timer.GetTimeMilli(FALSE) > time)
		{
			return 2;			
		}

	}

	return 1;
}
//////////////////////////////////////////////////////////////////////////
// 相机采集相关


// 重新构造相机对象并初始化相机
BOOL vcBaseVisionAlign::ReCreateInitCameras()
{
	m_vpCamera.clear();
	m_vpCamOwner.clear();
	scPTGrab2* pPTGrab=NULL;
	CCameraCallbackObject* pcbCallbackObject = NULL; 
	for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{	 
		// 1.1 创建相机，并设置相机回调函数
		if(GetCameraShareType(i)==eShareTar)
		{
			pPTGrab = NULL;
			pcbCallbackObject = NULL;
		}
		else
		{
			pPTGrab = new scPTGrab2();
			pcbCallbackObject = new CCameraCallbackObject;
			pcbCallbackObject->m_nCamIndex = i;
			pcbCallbackObject->m_pOwner = this;
		}

		//pPTGrab = scPTGrab2::CreateCamera();
		m_vpCamera.push_back(pPTGrab);


		m_vpCamOwner.push_back(pcbCallbackObject); 	

		if (GetCameraShareType(i) != eShareTar)
		{
			pPTGrab->SetOwner(m_vpCamOwner.at(i), GrabImageFinishedCallback);
		}
		InitCamera(i);
	}
	return TRUE;
}


// 初始化共享目标相机
BOOL vcBaseVisionAlign::InitShareTargetCamera(int nIndex)
{
	if ( nIndex<0 || nIndex>=m_vpCamera.size())
	{
		return FALSE;
	}
	CameraParam cameraParam = m_pVisionASMConfig->m_vCameraParam[nIndex];

	if (GetCameraShareType(nIndex)==eShareTar)
	{
		int nSrcPlatformIndex = cameraParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
		int nSrcCameraIndex   = cameraParam.m_vShareCamInfo.at(0).m_nCamIndex;
		vcBaseVisionAlign* pAlign = ((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIndex);
		m_vpCamera[nIndex] = pAlign->m_vpCamera.at(nSrcCameraIndex);
		return TRUE;
	}
	return FALSE;

}


// 初始化相机(根据相机序列号初始化)
BOOL vcBaseVisionAlign::InitCamera(int nIndex)
{
	if ( nIndex<0 || nIndex>=m_vpCamera.size())
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) ||(nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	if (GetCameraShareType(nIndex)==eShareTar)
	{
		return InitShareTargetCamera(nIndex);
	}


	if (NULL == m_vpCamera[nIndex])
	{
		return FALSE;
	}

	if (FALSE == DestroyCamera(nIndex))
	{
		return FALSE;
	}

	CameraParam cameraParam = m_pVisionASMConfig->m_vCameraParam[nIndex];

	if (FALSE == m_vpCamera[nIndex]->InitFromSerial(cameraParam.m_strDeviceID))
	{
		return FALSE;
	}


	// 	if (FALSE == m_vpCamera[nIndex]->InitFromSerial(cameraParam.m_lSerialNum))
	// 	{
	// 		return FALSE;
	// 	}

	return TRUE;
}

// 相机共享类型
CShareCamType vcBaseVisionAlign::GetCameraShareType(int nIndex)
{
	if ( nIndex<0 || nIndex>=m_pVisionASMConfig->m_vCameraParam.size())
	{
		return eNoShare;
	}
	CameraParam cameraParam = m_pVisionASMConfig->m_vCameraParam[nIndex];
	return cameraParam.m_eShareCamType;
}

// 将scPTGrab对象与硬件相机断开（以备下一次的初始化）
BOOL vcBaseVisionAlign::DestroyCamera( int nIndex )
{
	if ( nIndex<0 || nIndex>=m_vpCamera.size())
	{
		return FALSE;
	}


	if (GetCameraShareType(nIndex)==eShareTar)
	{
		return TRUE;
	}

	if ( NULL == m_vpCamera.at(nIndex))
	{
		return FALSE;
	}

	if(FALSE == m_vpCamera.at(nIndex)->IsOnline())
		return TRUE;

	return m_vpCamera.at(nIndex)->Destroy();

}

// 平台是否共享了相机
BOOL vcBaseVisionAlign::IsShareCameraPlatform()
{
	CameraParam camParam;
	BOOL bShareCamPlatform=FALSE;
	for (int i=0;i<GetCameraNum();i++)
	{
		if ((m_pVisionASMConfig->m_vCameraParam[i].m_eShareCamType)!=eNoShare)
		{
			bShareCamPlatform=TRUE;
			break;
		}
	}
	return bShareCamPlatform;
}

// 断开先前的相机，用于重新配置相机序列号时
BOOL vcBaseVisionAlign::DestroyPreShareCamera(int nIndex,BOOL bShareTarget)
{
	if ( nIndex<0 || nIndex>=m_vpCamera.size())
	{
		return FALSE;
	}


	if (bShareTarget)
	{

		return TRUE;

	}

	if ( NULL == m_vpCamera.at(nIndex))
	{
		return FALSE;
	}

	if(FALSE == m_vpCamera.at(nIndex)->IsOnline())
		return TRUE;

	return m_vpCamera.at(nIndex)->Destroy();
}

// 释放先前的相机对象，用于重新配置相机序列号时
BOOL vcBaseVisionAlign::UninitPreShareCamera(int nIndex,BOOL bShareTarget)
{
	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE ;
	}

	if (m_vpCamera.at(nIndex)!=NULL && !bShareTarget)
	{
		delete m_vpCamera.at(nIndex);
		//scPTGrab2::DeleteCamera(m_vpCamera.at(nIndex));
		m_vpCamera.at(nIndex) = NULL;
	}	

	if (m_vpCamOwner.at(nIndex)!=NULL)
	{
		delete m_vpCamOwner.at(nIndex);
		m_vpCamOwner.at(nIndex) = NULL;
	}
	return TRUE;
}
// 释放相机								
void vcBaseVisionAlign::UninitCamera(int nIndex)
{
	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return ;
	}

	if (m_vpCamera.at(nIndex)!=NULL && (m_pVisionASMConfig->m_vCameraParam[nIndex].m_eShareCamType!=eShareTar))
	{
		delete m_vpCamera.at(nIndex);
		//scPTGrab2::DeleteCamera(m_vpCamera.at(nIndex));
		m_vpCamera.at(nIndex) = NULL;
	}	

	if (m_vpCamOwner.at(nIndex)!=NULL)
	{
		delete m_vpCamOwner.at(nIndex);
		m_vpCamOwner.at(nIndex) = NULL;
	}

	// 	if (m_vpHideSearchGUIObject.at(nIndex) != NULL)
	// 	{
	// 		delete m_vpHideSearchGUIObject.at(nIndex);
	// 		m_vpHideSearchGUIObject.at(nIndex) = NULL;
	// 	}
}		

// 释放相机								
void vcBaseVisionAlign::UninitPos(int nIndex)
{
	if ( nIndex<0 || nIndex>=GetPosNum() )
	{
		return ;
	}

	// 	if (nIndex < m_vpHideSearchGUIObject.size())
	// 	{
	// 		if (m_vpHideSearchGUIObject.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpHideSearchGUIObject.at(nIndex);
	// 			m_vpHideSearchGUIObject.at(nIndex) = NULL;
	// 		}
	// 	}


	if (m_vpSearchObject.at(nIndex) != NULL)
	{
		delete m_vpSearchObject.at(nIndex);
		m_vpSearchObject.at(nIndex) = NULL;
	}

	if (m_vpSaveImageObject.at(nIndex) != NULL)
	{
		delete m_vpSaveImageObject.at(nIndex);
		m_vpSaveImageObject.at(nIndex) = NULL;
	}

	if (m_vpCameraExposureObject.at(nIndex) != NULL)
	{
		delete m_vpCameraExposureObject.at(nIndex);
		m_vpCameraExposureObject.at(nIndex) = NULL;
	}


	if (m_vhSearchEndEvent.at(nIndex) != NULL)
	{
		CloseHandle(m_vhSearchEndEvent.at(nIndex));
		m_vhSearchEndEvent.at(nIndex) = NULL;
	}

	if (m_vhCameraExposureEndEvent.at(nIndex) != NULL)
	{
		CloseHandle(m_vhCameraExposureEndEvent.at(nIndex));
		m_vhCameraExposureEndEvent.at(nIndex) = NULL;
	}


	if (m_vhSnapSearchImageEndEvent.at(nIndex) != NULL)
	{
		CloseHandle(m_vhSnapSearchImageEndEvent.at(nIndex));
		m_vhSnapSearchImageEndEvent.at(nIndex) = NULL;
	}

	// 	if (m_vpGuiAlnTargetImageMarkPos.at(nIndex) != NULL)
	// 	{
	// 		delete m_vpGuiAlnTargetImageMarkPos.at(nIndex);
	// 		m_vpGuiAlnTargetImageMarkPos.at(nIndex) = NULL;
	// 	}
	// 
	// 	if (m_vpGuiAlnTargetRotatedImageMarkPos.at(nIndex) != NULL)
	// 	{
	// 		delete m_vpGuiAlnTargetRotatedImageMarkPos.at(nIndex);
	// 		m_vpGuiAlnTargetRotatedImageMarkPos.at(nIndex) = NULL;
	// 	}
	//     if (m_vpGuiAlnTargetSearchRect.at(nIndex)!=NULL)
	//     {
	//         delete m_vpGuiAlnTargetSearchRect.at(nIndex);
	//         m_vpGuiAlnTargetSearchRect.at(nIndex)=NULL;
	//     }
	//     if (m_vpGuiAlnObjectSearchRect.at(nIndex)!=NULL)
	//     {
	//         delete m_vpGuiAlnObjectSearchRect.at(nIndex);
	//         m_vpGuiAlnObjectSearchRect.at(nIndex)=NULL;
	//     }
	// 	if (m_vpGuiAlnObjectImageMarkPos.at(nIndex) != NULL)
	// 	{
	// 		delete m_vpGuiAlnObjectImageMarkPos.at(nIndex);
	// 		m_vpGuiAlnObjectImageMarkPos.at(nIndex) = NULL;
	// 	}
	// 
	// 	if (m_vpGuiAlnVirtualObjectImageMarkPos.at(nIndex) != NULL)
	// 	{
	// 		delete m_vpGuiAlnVirtualObjectImageMarkPos.at(nIndex);
	// 		m_vpGuiAlnVirtualObjectImageMarkPos.at(nIndex) = NULL;
	// 	}
	// 
	// 
	// 	if (m_vpGuiAlnCalibTargetImageMarkPos.at(nIndex) != NULL)
	// 	{
	// 		delete m_vpGuiAlnCalibTargetImageMarkPos.at(nIndex);
	// 		m_vpGuiAlnCalibTargetImageMarkPos.at(nIndex) = NULL;
	// 	}

	// 	for (int i = 0; i < GetPosNum()*2; i++)
	// 	{
	// 		if (m_vpGuiAlnTargetLineImageMarkPos.at(i) != NULL)
	// 		{
	// 			delete m_vpGuiAlnTargetLineImageMarkPos.at(i);
	// 			m_vpGuiAlnTargetLineImageMarkPos.at(i) = NULL;
	// 		}
	// 
	// 		if (m_vpGuiAlnObjectLineImageMarkPos.at(i) != NULL)
	// 		{
	// 			delete m_vpGuiAlnObjectLineImageMarkPos.at(i);
	// 			m_vpGuiAlnObjectLineImageMarkPos.at(i) = NULL;
	// 		}
	// 	}

	// 	if (m_vpGuiAlnInspectImageMarkPos.at(nIndex) != NULL)
	// 	{
	// 		delete m_vpGuiAlnInspectImageMarkPos.at(nIndex);
	// 		m_vpGuiAlnInspectImageMarkPos.at(nIndex) = NULL;
	// 	}

	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_POS; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_POS + i;
	// 		if (m_vpGuiAlnExtraPos.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraPos.at(nTemp);
	// 			m_vpGuiAlnExtraPos.at(nTemp) = NULL;
	// 		}
	// 	}
	// 
	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_LINE; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_LINE + i;
	// 		if (m_vpGuiAlnExtraLine.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraLine.at(nTemp);
	// 			m_vpGuiAlnExtraLine.at(nTemp) = NULL;
	// 		}
	// 	}
	// 
	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_LINESEG; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_LINESEG + i;
	// 		if (m_vpGuiAlnExtraLineSeg.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraLineSeg.at(nTemp);
	// 			m_vpGuiAlnExtraLineSeg.at(nTemp) = NULL;
	// 		}
	// 	}
	// 
	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_RECT; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_RECT + i;
	// 		if (m_vpGuiAlnExtraRect.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraRect.at(nTemp);
	// 			m_vpGuiAlnExtraRect.at(nTemp) = NULL;
	// 		}
	// 	}
	// 
	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_AFFINERECT; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_AFFINERECT + i;
	// 		if (m_vpGuiAlnExtraAffineRect.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraAffineRect.at(nTemp);
	// 			m_vpGuiAlnExtraAffineRect.at(nTemp) = NULL;
	// 		}
	// 	}
	// 
	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_CIRCLE; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_CIRCLE + i;
	// 		if (m_vpGuiAlnExtraCircle.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraCircle.at(nTemp);
	// 			m_vpGuiAlnExtraCircle.at(nTemp) = NULL;
	// 		}
	// 	}
	// 
	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_OBROUND; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_OBROUND + i;
	// 		if (m_vpGuiAlnExtraObround.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraObround.at(nTemp);
	// 			m_vpGuiAlnExtraObround.at(nTemp) = NULL;
	// 		}
	// 	}
	// 
	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_TEXT; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_TEXT + i;
	// 		if (m_vpGuiAlnExtraText.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraText.at(nTemp)->GetTextFont();
	// 
	// 			delete m_vpGuiAlnExtraText.at(nTemp);
	// 			m_vpGuiAlnExtraText.at(nTemp) = NULL;
	// 		}
	// 	}
	// 
	// 	for (int i=0; i<EXTRA_GRAPHICS_NUM_CONST_TEXT; i++)
	// 	{
	// 		int nTemp = nIndex*EXTRA_GRAPHICS_NUM_CONST_TEXT + i;
	// 		if (m_vpGuiAlnExtraConstText.at(nTemp) != NULL)
	// 		{
	// 			delete m_vpGuiAlnExtraConstText.at(nTemp)->GetTextFont();
	// 
	// 			delete m_vpGuiAlnExtraConstText.at(nTemp);
	// 			m_vpGuiAlnExtraConstText.at(nTemp) = NULL;
	// 		}
	// 	}
	//////////////////////////////////////////////////////////////////////////
	// SY
	// 	if (0 == m_pPlatformInfo->m_nPositionShowMode)
	// 	{
	// 		if (m_vpShowGuiTargetImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiTargetImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiTargetImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiObjectImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiObjectImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiObjectImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiVirtualObjectImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiVirtualObjectImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiVirtualObjectImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiCalibTargetImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiCalibTargetImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiCalibTargetImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiInspectImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiInspectImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiInspectImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 	}
	// 	else if (1 == m_pPlatformInfo->m_nPositionShowMode)
	// 	{
	// 		if (m_vpShowGuiTargetImageMarkPosText.at(0) != NULL)
	// 		{
	// 			delete m_vpShowGuiTargetImageMarkPosText.at(0);
	// 			m_vpShowGuiTargetImageMarkPosText.at(0) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiObjectImageMarkPosText.at(0) != NULL)
	// 		{
	// 			delete m_vpShowGuiObjectImageMarkPosText.at(0);
	// 			m_vpShowGuiObjectImageMarkPosText.at(0) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiVirtualObjectImageMarkPosText.at(0) != NULL)
	// 		{
	// 			delete m_vpShowGuiVirtualObjectImageMarkPosText.at(0);
	// 			m_vpShowGuiVirtualObjectImageMarkPosText.at(0) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiCalibTargetImageMarkPosText.at(0) != NULL)
	// 		{
	// 			delete m_vpShowGuiCalibTargetImageMarkPosText.at(0);
	// 			m_vpShowGuiCalibTargetImageMarkPosText.at(0) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiInspectImageMarkPosText.at(0) != NULL)
	// 		{
	// 			delete m_vpShowGuiInspectImageMarkPosText.at(0);
	// 			m_vpShowGuiInspectImageMarkPosText.at(0) = NULL;
	// 		}
	// 	}
	// 	else
	// 	{
	// 		if (m_vpShowGuiTargetImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiTargetImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiTargetImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiObjectImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiObjectImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiObjectImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiVirtualObjectImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiVirtualObjectImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiVirtualObjectImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiCalibTargetImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiCalibTargetImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiCalibTargetImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 
	// 		if (m_vpShowGuiInspectImageMarkPosText.at(nIndex) != NULL)
	// 		{
	// 			delete m_vpShowGuiInspectImageMarkPosText.at(nIndex);
	// 			m_vpShowGuiInspectImageMarkPosText.at(nIndex) = NULL;
	// 		}
	// 	}
	//////////////////////////////////////////////////////////////////////////
	if (m_vpGuiCalibrateGraphics.at(nIndex)!=NULL)
	{
		delete m_vpGuiCalibrateGraphics.at(nIndex);
		m_vpGuiCalibrateGraphics.at(nIndex)=NULL;
	}
}		

// 获取相机数量
int  vcBaseVisionAlign::GetCameraNum()
{
	if (NULL == m_pPlatformInfo)
	{
		return 0;
	}

	return m_pPlatformInfo->m_nCamNum;
}

// 获取位置数量
int  vcBaseVisionAlign::GetPosNum()
{
	if (NULL == m_pPlatformInfo)
	{
		return 0;
	}

	return m_pPlatformInfo->m_nPositionNum;
}

// 获取目标位置数量
int vcBaseVisionAlign::GetTargetPosNum()
{
	if (NULL == m_pPlatformInfo)
	{
		return 0;
	}

	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		return m_pPlatformInfo->m_nPositionNum/2;
	}

	return m_pPlatformInfo->m_nPositionNum;
}

// 获取对象位置数量
int vcBaseVisionAlign::GetObjectPosNum()
{
	if (NULL == m_pPlatformInfo)
	{
		return 0;
	}

	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		return m_pPlatformInfo->m_nPositionNum/2;
	}

	return m_pPlatformInfo->m_nPositionNum;
}
BOOL vcBaseVisionAlign::SetPlatformOptionInfo(CPlatformOptionInfo optionInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	m_pVisionASMConfig->m_PlatformOptionInfo = optionInfo;

	return TRUE;
}
BOOL vcBaseVisionAlign::GetPlatformOptionInfo(CPlatformOptionInfo& optionInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	optionInfo = m_pVisionASMConfig->m_PlatformOptionInfo;

	return TRUE;
}

BOOL vcBaseVisionAlign::SetCommParamInfo(CCommParamInfo commParamInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	m_pVisionASMConfig->m_CommParamInfo = commParamInfo;

	return TRUE;
}
BOOL vcBaseVisionAlign::GetCommParamInfo(CCommParamInfo& commParamInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	commParamInfo = m_pVisionASMConfig->m_CommParamInfo;

	return TRUE;
}

BOOL vcBaseVisionAlign::SetPlatformLayoutInfo(CPlatformLayoutInfo layoutInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	m_pVisionASMConfig->m_PlatformLayoutInfo = layoutInfo;

	return TRUE;
}

BOOL vcBaseVisionAlign::GetPlatformLayoutInfo(CPlatformLayoutInfo& layoutInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	layoutInfo = m_pVisionASMConfig->m_PlatformLayoutInfo;

	return TRUE;
}

//设置/获取通信参数信息
BOOL vcBaseVisionAlign::SetCommOptionInfo(CCommOptionInfo commOptionInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	m_pVisionASMConfig->m_commOptionInfo = commOptionInfo;
	m_pVisionASMConfig->m_commOptionInfoXML = commOptionInfo;
	//CommProtocolParam commProtocolParam;
	//commProtocolParam.m_nCommTimeOut = commOptionInfo.m_nCommTimeOut;
	//commProtocolParam.m_nCommReSendTimes = commOptionInfo.m_nCommReSendTimes;
	//commProtocolParam.m_nCommXUnitExp = commOptionInfo.m_nCommXUnitExp;
	//commProtocolParam.m_nCommYUnitExp = commOptionInfo.m_nCommYUnitExp;
	//commProtocolParam.m_nCommDUnitExp = commOptionInfo.m_nCommDUnitExp;
	//commProtocolParam.m_nCommDataLenType = commOptionInfo.m_nCommDataLenType;
	//m_XYDCommProtocol.SetCommProtocolParam(commProtocolParam);

	UpdateCommOptionInfo();
	return TRUE;
}
BOOL vcBaseVisionAlign::GetCommOptionInfo(CCommOptionInfo& commOptionInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	commOptionInfo = m_pVisionASMConfig->m_commOptionInfo;

	return TRUE;
}

BOOL vcBaseVisionAlign::GetCommOptionInfoXML(CCommOptionInfo& commOptionInfo)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	commOptionInfo = m_pVisionASMConfig->m_commOptionInfoXML;

	return TRUE;
}

BOOL vcBaseVisionAlign::UpdateCommOptionInfo()
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}
	CCommOptionInfo commOptionInfo = m_pVisionASMConfig->m_commOptionInfo;
	if (!commOptionInfo.m_bUsePlatformComm)
	{
		commOptionInfo.m_nCommDataLenType = m_pSystempOptionConfig->m_nCommDataLenType;
		commOptionInfo.m_nCommDelay = m_pSystempOptionConfig->m_nCommDelay;
		commOptionInfo.m_nCommTimeOut = m_pSystempOptionConfig->m_nCommTimeOut;
		commOptionInfo.m_nCommReSendTimes = m_pSystempOptionConfig->m_nCommReSendTimes;
		commOptionInfo.m_nCommXUnitExp = m_pSystempOptionConfig->m_nCommXYUnitExp;
		commOptionInfo.m_nCommYUnitExp = m_pSystempOptionConfig->m_nCommXYUnitExp;
		commOptionInfo.m_nCommDUnitExp = m_pSystempOptionConfig->m_nCommDUnitExp;
		m_pVisionASMConfig->m_commOptionInfo = commOptionInfo;

	}

	CommProtocolParam commProtocolParam;
	commProtocolParam.m_nCommTimeOut = commOptionInfo.m_nCommTimeOut;
	commProtocolParam.m_nCommReSendTimes = commOptionInfo.m_nCommReSendTimes;
	commProtocolParam.m_nCommXUnitExp = commOptionInfo.m_nCommXUnitExp;
	commProtocolParam.m_nCommYUnitExp = commOptionInfo.m_nCommYUnitExp;
	commProtocolParam.m_nCommDUnitExp = commOptionInfo.m_nCommDUnitExp;
	commProtocolParam.m_nCommDataLenType = commOptionInfo.m_nCommDataLenType;
	m_XYDCommProtocol.SetCommProtocolParam(commProtocolParam);

	return TRUE;
}

// 设置所有相机参数
BOOL vcBaseVisionAlign::SetCameraParam(int nIndex, CameraParam camParam)
{
	// 	if ( nIndex<0 || nIndex>=m_vpCamera.size())
	// 	{
	// 		return FALSE;
	// 	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	m_pVisionASMConfig->m_vCameraParam[nIndex] = camParam;

	return TRUE;
}

// 获取所有相机参数		
BOOL vcBaseVisionAlign::GetCameraParam(int nIndex, CameraParam& cameParam)
{
	// 	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	// 	{
	// 		return FALSE;
	// 	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	cameParam = m_pVisionASMConfig->m_vCameraParam[nIndex];

	if (GetCameraShareType(nIndex)==eShareTar)
	{
		int nSrcPlatformIdx=cameParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
		int nSrcCamIdx=cameParam.m_vShareCamInfo.at(0).m_nCamIndex;
		CameraParam tempCamParam;
		//tempCamParam=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx)->m_pVisionASMConfig->m_vCameraParam[nSrcCamIdx];
		if (m_pMainFrameWnd != NULL && ((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx) != NULL)
		{
			if (((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx)->GetCameraShareSrcParam(nSrcCamIdx, tempCamParam))
			{
				//	cameParam.m_strDeviceID=tempCamParam.m_strDeviceID;
				cameParam.m_dShutter=tempCamParam.m_dShutter;
				cameParam.m_dCalibTargetShutter=tempCamParam.m_dCalibTargetShutter;
				cameParam.m_dGain=tempCamParam.m_dGain;
				cameParam.m_bGammaEnable=tempCamParam.m_bGammaEnable;
				cameParam.m_dGamma=tempCamParam.m_dGamma;

				cameParam.m_dWhiteBalanceRatioR = tempCamParam.m_dWhiteBalanceRatioR;
				cameParam.m_dWhiteBalanceRatioG = tempCamParam.m_dWhiteBalanceRatioG;
				cameParam.m_dWhiteBalanceRatioB = tempCamParam.m_dWhiteBalanceRatioB;
			}
		}
	}
	return TRUE;
}

// 获取共享相机时，主相机参数（与主界面交互）   
BOOL vcBaseVisionAlign::GetCameraShareSrcParam(int nIndex, CameraParam& cameParam)
{
	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	if (GetCameraShareType(nIndex)==eShareTar)
	{
		return FALSE;
	}

	cameParam = m_pVisionASMConfig->m_vCameraParam[nIndex];

	return TRUE;


}
// 设置所有相机参数
BOOL vcBaseVisionAlign::SetPosCameraParam(int nPosIndex, CameraParam camParam)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return SetCameraParam(nCameraIndex, camParam);
}

// 获取所有相机参数		
BOOL vcBaseVisionAlign::GetPosCameraParam(int nPosIndex, CameraParam& camParam)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return GetCameraParam(nCameraIndex, camParam);
}


// 设置位置信息（与主界面交互）
BOOL vcBaseVisionAlign::SetPosInfo(int nIndex, CPosInfo posInfo)
{
	if ( nIndex<0 )
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vPosInfo.size()))
	{
		return FALSE;
	}

	m_pVisionASMConfig->m_vPosInfo[nIndex] = posInfo;

	return TRUE;
}

// 获取位置信息（与主界面交互）
BOOL vcBaseVisionAlign::GetPosInfo(int nIndex, CPosInfo& posInfo)
{
	if ( nIndex<0 )
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vPosInfo.size()))
	{
		return FALSE;
	}

	posInfo = m_pVisionASMConfig->m_vPosInfo[nIndex];

	return TRUE;
}

int  vcBaseVisionAlign::GetPosCameraIndex(int nPosIndex)
{
	CPosInfo posInfo;
	if (!GetPosInfo(nPosIndex, posInfo))
	{
		return -1;
	}
	return posInfo.m_nCamIndex;
}

int  vcBaseVisionAlign::GetCameraFirstPosIndex(int nCamIndex)
{
	if (nCamIndex<0 || nCamIndex>=m_pPlatformInfo->m_nCamNum)
	{
		return -1;
	}
	int i = 0;
	for(i = 0; i < GetPosNum();i++)
	{
		if (nCamIndex == GetPosCameraIndex(i))
		{
			return i;
		}
	}

	return -1;
}

BOOL vcBaseVisionAlign::IsCameraFirstPosIndex(int nPosIndex)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);
	if (nCameraIndex == -1)
	{
		return FALSE;
	}

	int nIndex = 0;
	for(nIndex = 0; nIndex < nPosIndex; nIndex++)
	{
		if (nCameraIndex == GetPosCameraIndex(nIndex))
		{
			return FALSE;
		}
	}

	return TRUE;
}


// 设置相机的视频模式（与主界面交互）
BOOL vcBaseVisionAlign::SetCameraVideoMode(int nIndex, int nCurVideoMode, sc2Vector vStartPt, sc2Vector vCustomWH) 
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) || (nCurVideoMode<0) || (nCurVideoMode>5))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	m_pVisionASMConfig->m_vCameraParam[nIndex].m_nVideoMode = nCurVideoMode;

	if (5 == nCurVideoMode)
	{
		m_pVisionASMConfig->m_vCameraParam[nIndex].m_nCustemStartX = vStartPt.GetX();
		m_pVisionASMConfig->m_vCameraParam[nIndex].m_nCustemStartY = vStartPt.GetY();
		m_pVisionASMConfig->m_vCameraParam[nIndex].m_nCustemWidth  = vCustomWH.GetX();
		m_pVisionASMConfig->m_vCameraParam[nIndex].m_nCustemHeight = vCustomWH.GetY();
	}

	return TRUE;
}  


// 设置相机的帧率（与主界面交互）
BOOL vcBaseVisionAlign::SetCameraFrameRate(int nIndex, double dCurFrameRate)  
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	m_pVisionASMConfig->m_vCameraParam[nIndex].m_dFrameRate = dCurFrameRate;

	return TRUE;
}
// 设置相机的曝光时间（与主界面交互）   
BOOL vcBaseVisionAlign::SetCameraShutter(int nIndex, double dCurShutter)  
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	if (GetCameraShareType(nIndex)==eShareTar)
	{
		int nSrcPlatformIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nPlatformIndex;
		int nSrcCamIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nCamIndex;
		vcBaseVisionAlign* pAlign=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx);
		pAlign->m_pVisionASMConfig->m_vCameraParam.at(nSrcCamIdx).m_dShutter=dCurShutter;
		return TRUE;
	}
	m_pVisionASMConfig->m_vCameraParam[nIndex].m_dShutter = dCurShutter;

	return TRUE;
}  
// 设置相机的增益（与主界面交互）      
BOOL vcBaseVisionAlign::SetCameraGain(int nIndex, double dCurGain)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	if (GetCameraShareType(nIndex)==eShareTar)
	{
		int nSrcPlatformIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nPlatformIndex;
		int nSrcCamIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nCamIndex;
		vcBaseVisionAlign* pAlign=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx);
		pAlign->m_pVisionASMConfig->m_vCameraParam.at(nSrcCamIdx).m_dGain=dCurGain;
		return TRUE;
	}

	m_pVisionASMConfig->m_vCameraParam[nIndex].m_dGain = dCurGain;

	return TRUE;
}    

// 设置相机的Gmma（与主界面交互）
BOOL vcBaseVisionAlign::SetCameraGamma(int nIndex, bool bEnable, double dCurGamma)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	if (GetCameraShareType(nIndex)==eShareTar)
	{
		int nSrcPlatformIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nPlatformIndex;
		int nSrcCamIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nCamIndex;
		vcBaseVisionAlign* pAlign=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx);
		pAlign->m_pVisionASMConfig->m_vCameraParam.at(nSrcCamIdx).m_bGammaEnable=bEnable;
		pAlign->m_pVisionASMConfig->m_vCameraParam.at(nSrcCamIdx).m_dGamma=dCurGamma;
		return TRUE;
	}

	m_pVisionASMConfig->m_vCameraParam[nIndex].m_bGammaEnable=bEnable;
	m_pVisionASMConfig->m_vCameraParam[nIndex].m_dGamma=dCurGamma;

	return TRUE;
}




// 设置相机的视频模式（与主界面交互）
BOOL vcBaseVisionAlign::SetPosCameraVideoMode(int nPosIndex, int nCurVideoMode, sc2Vector vStartPt, sc2Vector vCustomWH) 
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return SetCameraVideoMode(nCameraIndex, nCurVideoMode, vStartPt, vCustomWH);
}  


// 设置相机的帧率（与主界面交互）
BOOL vcBaseVisionAlign::SetPosCameraFrameRate(int nPosIndex, double dCurFrameRate)  
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return SetCameraFrameRate(nCameraIndex, dCurFrameRate);
}
// 设置相机的曝光时间（与主界面交互）   
BOOL vcBaseVisionAlign::SetPosCameraShutter(int nPosIndex, double dCurShutter)  
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return SetCameraShutter(nCameraIndex, dCurShutter);
}  
// 设置相机的增益（与主界面交互）      
BOOL vcBaseVisionAlign::SetPosCameraGain(int nPosIndex, double dCurGain)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return SetCameraGain(nCameraIndex, dCurGain);
}                			
// 设置相机的Gamma（与主界面交互）		
BOOL vcBaseVisionAlign::SetPosCameraGamma(int nPosIndex, bool bEnable, double dCurGamma)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return SetCameraGamma(nCameraIndex, bEnable, dCurGamma);
}


BOOL vcBaseVisionAlign::SetCameraWhiteBalanceRatio(int nIndex,double dR,double dG,double dB)  
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}

	if (GetCameraShareType(nIndex)==eShareTar)
	{
		int nSrcPlatformIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nPlatformIndex;
		int nSrcCamIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nCamIndex;
		vcBaseVisionAlign* pAlign=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx);
		pAlign->m_pVisionASMConfig->m_vCameraParam.at(nSrcCamIdx).m_dWhiteBalanceRatioR = dR;
		pAlign->m_pVisionASMConfig->m_vCameraParam.at(nSrcCamIdx).m_dWhiteBalanceRatioG = dG;
		pAlign->m_pVisionASMConfig->m_vCameraParam.at(nSrcCamIdx).m_dWhiteBalanceRatioB = dB;
		return TRUE;
	}

	m_pVisionASMConfig->m_vCameraParam[nIndex].m_dWhiteBalanceRatioR = dR;
	m_pVisionASMConfig->m_vCameraParam[nIndex].m_dWhiteBalanceRatioG = dG;
	m_pVisionASMConfig->m_vCameraParam[nIndex].m_dWhiteBalanceRatioB = dB;
	return TRUE;
} 

BOOL vcBaseVisionAlign::GetCameraWhiteBalanceRatio(int nIndex,double &dR,double &dG,double &dB)  
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vCameraParam.size()))
	{
		return FALSE;
	}
	CameraParam cameParam = m_pVisionASMConfig->m_vCameraParam[nIndex];
	if (GetCameraShareType(nIndex)==eShareTar)
	{
		int nSrcPlatformIdx=cameParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
		int nSrcCamIdx=cameParam.m_vShareCamInfo.at(0).m_nCamIndex;
		//tempCamParam=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx)->m_pVisionASMConfig->m_vCameraParam[nSrcCamIdx];
		if (m_pMainFrameWnd != NULL && ((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx) != NULL)
		{
			((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx)->GetCameraShareSrcParam(nSrcCamIdx, cameParam);
		}
	}
	dR = cameParam.m_dWhiteBalanceRatioR;
	dG = cameParam.m_dWhiteBalanceRatioG;
	dB = cameParam.m_dWhiteBalanceRatioB;
	return TRUE;
} 
BOOL vcBaseVisionAlign::SetPosWhiteBalanceRatio(int nPosIndex,double dR,double dG,double dB)  
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return SetCameraWhiteBalanceRatio(nCameraIndex, dR, dG, dB);
}  
BOOL vcBaseVisionAlign::GetPosWhiteBalanceRatio(int nPosIndex,double &dR,double &dG,double &dB)  
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return GetCameraWhiteBalanceRatio(nCameraIndex, dR, dG, dB);
}

// 设置图像显示参数（与主界面交互）
BOOL vcBaseVisionAlign::SetImageROIParam(int nIndex, ImageRoi imageRoi)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) || (nIndex>=m_vImageTransfer.size()))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vImageRoi.size()))
	{
		return FALSE;
	}

	//李艳萍：单相机多个位置时，nIndex（相机索引）只有一个，但是m_vImageRoi向量大小是位置数。
	if (1==m_pPlatformInfo->m_nCamNum)
	{
		int nNum = m_pPlatformInfo->m_nPositionNum;
		for (int i=0; i<nNum; i++)
		{
			m_pVisionASMConfig->m_vImageRoi.at(i) = imageRoi;

			// 更新ROI设置工具
			// 旋转
			RotateType rotateType;
			switch (m_pVisionASMConfig->m_vImageRoi.at(i).m_nRotation)
			{
			case 0:
				{
					rotateType = eRotate0;
				}
				break;
			case 1:
				{
					rotateType = eRotate90;
				}
				break;
			case 2:
				{
					rotateType = eRotate180;
				}
				break;
			case 3:
				{
					rotateType = eRotate270;
				}
				break;
			default:
				{
					rotateType = eRotate0;
				}
				break;					  
			}

			m_vImageTransfer.at(i).SetRotationType(rotateType);

			// 镜像
			BOOL bCheckHorizMirror = m_pVisionASMConfig->m_vImageRoi.at(i).m_bMirrorHoriz;
			BOOL bCheckVertMirror  = m_pVisionASMConfig->m_vImageRoi.at(i).m_bMirrorVert;

			if (bCheckHorizMirror && bCheckVertMirror)
			{
				m_vImageTransfer.at(i).SetMirrorType(eHorVerMirror);
			}
			else if (bCheckVertMirror&&(!bCheckHorizMirror))
			{
				m_vImageTransfer.at(i).SetMirrorType(eVerMirror);
			}
			else if((!bCheckVertMirror)&&bCheckHorizMirror)
			{
				m_vImageTransfer.at(i).SetMirrorType(eHorMirror);
			}
			else
			{
				m_vImageTransfer.at(i).SetMirrorType();
			}  

			// Gamma
			BOOL bGammaCorrectionEnable = m_pVisionASMConfig->m_vImageRoi.at(i).m_bGammaCorrectionEnable;
			double dGamma = m_pVisionASMConfig->m_vImageRoi.at(i).m_dGamma;

			m_vImageTransfer.at(i).SetGammaCorrectionEnable(bGammaCorrectionEnable);
			m_vImageTransfer.at(i).SetGammaPara(dGamma);
		}
	}//if

	else
	{
		m_pVisionASMConfig->m_vImageRoi.at(nIndex) = imageRoi;

		// 更新ROI设置工具
		// 旋转
		RotateType rotateType;
		switch (m_pVisionASMConfig->m_vImageRoi.at(nIndex).m_nRotation)
		{
		case 0:
			{
				rotateType = eRotate0;
			}
			break;
		case 1:
			{
				rotateType = eRotate90;
			}
			break;
		case 2:
			{
				rotateType = eRotate180;
			}
			break;
		case 3:
			{
				rotateType = eRotate270;
			}
			break;
		default:
			{
				rotateType = eRotate0;
			}
			break;					  
		}

		m_vImageTransfer.at(nIndex).SetRotationType(rotateType);

		// 镜像
		BOOL bCheckHorizMirror = m_pVisionASMConfig->m_vImageRoi.at(nIndex).m_bMirrorHoriz;
		BOOL bCheckVertMirror  = m_pVisionASMConfig->m_vImageRoi.at(nIndex).m_bMirrorVert;

		if (bCheckHorizMirror && bCheckVertMirror)
		{
			m_vImageTransfer.at(nIndex).SetMirrorType(eHorVerMirror);
		}
		else if (bCheckVertMirror&&(!bCheckHorizMirror))
		{
			m_vImageTransfer.at(nIndex).SetMirrorType(eVerMirror);
		}
		else if((!bCheckVertMirror)&&bCheckHorizMirror)
		{
			m_vImageTransfer.at(nIndex).SetMirrorType(eHorMirror);
		}
		else
		{
			m_vImageTransfer.at(nIndex).SetMirrorType();
		}  

		// Gamma
		BOOL bGammaCorrectionEnable = m_pVisionASMConfig->m_vImageRoi[nIndex].m_bGammaCorrectionEnable;
		double dGamma = m_pVisionASMConfig->m_vImageRoi[nIndex].m_dGamma;

		m_vImageTransfer.at(nIndex).SetGammaCorrectionEnable(bGammaCorrectionEnable);
		m_vImageTransfer.at(nIndex).SetGammaPara(dGamma);

	}//else

	return TRUE;
}		    

// 获取图像显示参数（与主界面交互）
BOOL vcBaseVisionAlign::GetImageROIParam(int nIndex, ImageRoi& imageRoi)
{
	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nIndex >= m_pVisionASMConfig->m_vImageRoi.size()))
	{
		return FALSE;
	}

	imageRoi = m_pVisionASMConfig->m_vImageRoi.at(nIndex);

	return TRUE;
}				

// 设置图像显示参数（与主界面交互）
BOOL vcBaseVisionAlign::SetPosImageROIParam(int nPosIndex, ImageRoi imageRoi)
{
	if ( (nPosIndex<0) || (nPosIndex>=GetPosNum()) || (nPosIndex>=m_vImageTransfer.size()))
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nPosIndex >= m_pVisionASMConfig->m_vImageRoi.size()))
	{
		return FALSE;
	}

	if (!IsCameraFirstPosIndex(nPosIndex))
	{
		return TRUE;
	}

	int nCameraIndex = GetPosCameraIndex(nPosIndex);
	int nNum = m_pPlatformInfo->m_nPositionNum;
	for (int i=nPosIndex; i<nNum; i++)
	{
		if (nCameraIndex != GetPosCameraIndex(i))
		{
			continue;
		}

		m_pVisionASMConfig->m_vImageRoi.at(i) = imageRoi;

		// 更新ROI设置工具
		// 旋转
		RotateType rotateType;
		switch (m_pVisionASMConfig->m_vImageRoi.at(i).m_nRotation)
		{
		case 0:
			{
				rotateType = eRotate0;
			}
			break;
		case 1:
			{
				rotateType = eRotate90;
			}
			break;
		case 2:
			{
				rotateType = eRotate180;
			}
			break;
		case 3:
			{
				rotateType = eRotate270;
			}
			break;
		default:
			{
				rotateType = eRotate0;
			}
			break;					  
		}

		m_vImageTransfer.at(i).SetRotationType(rotateType);

		// 镜像
		BOOL bCheckHorizMirror = m_pVisionASMConfig->m_vImageRoi.at(i).m_bMirrorHoriz;
		BOOL bCheckVertMirror  = m_pVisionASMConfig->m_vImageRoi.at(i).m_bMirrorVert;

		if (bCheckHorizMirror && bCheckVertMirror)
		{
			m_vImageTransfer.at(i).SetMirrorType(eHorVerMirror);
		}
		else if (bCheckVertMirror&&(!bCheckHorizMirror))
		{
			m_vImageTransfer.at(i).SetMirrorType(eVerMirror);
		}
		else if((!bCheckVertMirror)&&bCheckHorizMirror)
		{
			m_vImageTransfer.at(i).SetMirrorType(eHorMirror);
		}
		else
		{
			m_vImageTransfer.at(i).SetMirrorType();
		}  

		// Gamma
		BOOL bGammaCorrectionEnable = m_pVisionASMConfig->m_vImageRoi.at(i).m_bGammaCorrectionEnable;
		double dGamma = m_pVisionASMConfig->m_vImageRoi.at(i).m_dGamma;

		m_vImageTransfer.at(i).SetGammaCorrectionEnable(bGammaCorrectionEnable);
		m_vImageTransfer.at(i).SetGammaPara(dGamma);
	}
	m_vbShareCamTransferSame.at(nCameraIndex)=IsShareCamTransferSame(nCameraIndex);
	CameraParam camParam;
	GetCameraParam(nCameraIndex,camParam);
	if (camParam.m_eShareCamType==eShareSrc)
	{
		CVisionASMDlg* pMainDlg=(CVisionASMDlg*)(m_pMainFrameWnd);
		vcBaseVisionAlign* pBaseTarVisionASM = NULL;
		for (int g=0;g<camParam.m_nShareCamNum;g++)
		{
			int nTarPlatformIdx=camParam.m_vShareCamInfo.at(g).m_nPlatformIndex;
			int nTarCamIdx=camParam.m_vShareCamInfo.at(g).m_nCamIndex;
			pBaseTarVisionASM=pMainDlg->m_vpVisionASM.at(nTarPlatformIdx);
			pBaseTarVisionASM->UpdateShareCamTransferSame(nTarCamIdx);
		}
	}
	return TRUE;
}		

// 获取图像显示参数（与主界面交互）
BOOL vcBaseVisionAlign::GetPosImageROIParam(int nPosIndex, ImageRoi& imageRoi)
{
	if ( nPosIndex<0 || nPosIndex>=GetPosNum() )
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig) || (nPosIndex >= m_pVisionASMConfig->m_vImageRoi.size()))
	{
		return FALSE;
	}

	imageRoi = m_pVisionASMConfig->m_vImageRoi.at(nPosIndex);

	return TRUE;
}				



// 根据相机参数更新相机所有状态
BOOL vcBaseVisionAlign::UpdateCameraStatus(int nIndex)
{
	BOOL bUpdateVideoMode = TRUE;//UpdateCameraVideo(nIndex);
	BOOL bUpdateFrameRate = TRUE;//UpdateCameraFrameRate(nIndex);
	Sleep(50);
	BOOL bUpdateShutter   = UpdateCameraShutter(nIndex); 
	Sleep(50);
	BOOL bUpdateGain      = UpdateCameraGain(nIndex);

	// 	Sleep(50);
	// 	BOOL bUpdateGamma      = UpdateCameraGamma(nIndex);

	BOOL bUpdataWhiteBalance = TRUE;
	CamPixelFormat eFormat;
	GetCameraPixelFormat(nIndex,eFormat);
	if(eFormat == eCamBayer_BG8 || eFormat == eCamBayer_GB8 ||eFormat == eCamBayer_RG8 ||eFormat == eCamBayer_GR8 || eFormat == eCamRGBPacked)
	{
		bUpdataWhiteBalance = UpdateCameraWhiteBalance(nIndex);
	}

	BOOL bUpdate = bUpdateVideoMode && bUpdateFrameRate && bUpdateShutter && bUpdateGain && bUpdataWhiteBalance;

	return bUpdate;
}

// 更新相机本身的视频模式
BOOL vcBaseVisionAlign::UpdateCameraVideo(int nIndex)  
{
	// 相机未连接时返回失败 
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	CameraParam cameraParam;

	if (FALSE == GetCameraParam(nIndex, cameraParam))
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}	

	BOOL bGrabLive = pPTGrab->IsGrabbing();

	if (bGrabLive)
	{
		pPTGrab->Freeze();
		Sleep(10);	
	}

	// 	VideoMode vmMode;
	// 	if (5 == cameraParam.m_nVideoMode)
	// 	{
	// 		if (TRUE == pPTGrab->GetCurVideoMode(&vmMode) && (VIDEOMODE_FORMAT7 != vmMode))
	// 		{
	// 			if(FALSE == pPTGrab->SetCurVideoMode(VIDEOMODE_FORMAT7))
	// 			{         
	// 				if (bGrabLive)
	// 				{
	// 					pPTGrab->Grab();
	// 				}  
	// 				return FALSE;
	// 			}		
	// 		}
	// 
	// 		PTFormat7Info ptformat7;
	// 		if (FALSE == pPTGrab->GetFormat7Config(ptformat7))
	// 		{
	// 			if (bGrabLive)
	// 			{
	// 				pPTGrab->Grab();
	// 			}  
	// 
	// 			return FALSE;
	// 		}
	// 		
	// 		ptformat7.m_uiStartX = cameraParam.m_nCustemStartX;
	// 		ptformat7.m_uiStartY = cameraParam.m_nCustemStartY;
	// 		ptformat7.m_uiWidth  = cameraParam.m_nCustemWidth;
	// 		ptformat7.m_uiHeight = cameraParam.m_nCustemHeight;
	// 		
	// 		if (FALSE == pPTGrab->SetFormat7Config(ptformat7))
	// 		{
	// 			if (bGrabLive)
	// 			{
	// 				pPTGrab->Grab();
	// 			}  
	// 
	// 			return FALSE;
	// 		}	
	// 
	// 	}
	// 	else
	// 	{
	// 		// 设置视频模式
	// 		if (!pPTGrab->SetCurVideoMode(g_vmVideoMode[cameraParam.m_nVideoMode]))
	// 		{        
	// 			if (bGrabLive)
	// 			{
	// 				pPTGrab->Grab();
	// 			}  
	// 			
	// 			return FALSE;
	// 		}  
	// 	}

	// 更新帧率、曝光时间、增益的存储值
	double dCurFrameRate(0.0);
	double dMinFrameRate(0.0);
	double dMaxFrameRate(0.0);

	double dCurShutter(0.0);
	double dMinShutter(0.0);
	double dMaxShutter(0.0);

	double dCurGain(0.0);
	double dMinGain(0.0);
	double dMaxGain(0.0);

	// 保证切换到新的Format及Mode时，帧率模式也相应更新到最大，以保证帧率模式充分可调
	// 	FrameRate frameRate ;
	// 	if (pPTGrab->GetMaxFrameRate(&frameRate))
	// 	{
	//       pPTGrab->SetCurFrameRate(frameRate);
	// 	}

	// 视频模式更新后，测试当前的帧率是否仍能使用
	// 若可以则仍使用当前帧率，否则重新获取视频模式更新后所支持的当前帧率
	// 	if (!pPTGrab->SetCurFrameRate(cameraParam.m_dFrameRate))
	// 	{        
	//        	if (!GetCameraFrameRate(nIndex, dCurFrameRate, dMinFrameRate, dMaxFrameRate))
	// 		{
	// 			if (bGrabLive)
	// 			{
	// 				pPTGrab->Grab();
	// 			}  
	// 			return FALSE;
	// 		} 
	// 		else
	// 		{
	//             cameraParam.m_dFrameRate = dCurFrameRate;
	// 		}
	// 	} 

	// 视频模式更新后，测试当前的曝光是否仍能使用
	// 若可以则仍使用当前曝光，否则重新获取视频模式更新后所支持的当前曝光
	if (!pPTGrab->SetCurShutter(cameraParam.m_dShutter))
	{        
		if (!GetCameraShutter(nIndex, dCurShutter, dMinShutter, dMaxShutter))
		{
			if (bGrabLive)
			{
				pPTGrab->Grab();
			}  
			return FALSE;
		}
		else
		{
			cameraParam.m_dShutter = dCurShutter;
		}		
	}  

	if (!SetCameraParam(nIndex, cameraParam))
	{
		if (bGrabLive)
		{
			pPTGrab->Grab();
		}  

		return FALSE;
	}    

	if (bGrabLive)
	{
		pPTGrab->Grab();
	}  

	return TRUE;
}                         

// 更新相机本身的帧率
BOOL vcBaseVisionAlign::UpdateCameraFrameRate(int nIndex)  
{
	// 相机未连接时返回失败
	// 	if (!m_vpCamera.at(nIndex)->IsOnline())
	// 	{
	// 		return FALSE;
	// 	}
	// 
	// 	CameraParam cameraParam;
	// 	
	// 	if (FALSE == GetCameraParam(nIndex, cameraParam))
	// 	{
	// 		return FALSE;
	// 	}
	// 	
	// 	scPTGrab2* pPTGrab = m_vpCamera[nIndex];
	// 	
	// 	if (NULL == pPTGrab)
	// 	{
	// 		return FALSE;
	// 	}
	// 	
	//     BOOL bGrabLive = pPTGrab->IsGrabbing();
	// 	
	// 	if (bGrabLive)
	// 	{
	// 		pPTGrab->Freeze();
	// 		Sleep(10);	
	// 	}
	//     
	// 	// 设置帧率
	// 	if (!pPTGrab->SetCurFrameRate(cameraParam.m_dFrameRate))
	// 	{        
	// 		if (bGrabLive)
	// 		{
	// 			pPTGrab->Grab();
	// 		}   
	// 		
	// 		return FALSE;
	// 	}  
	// 	
	// 	// 更新曝光时间、增益的存储值	
	// 	double dCurShutter(0.0);
	// 	double dMinShutter(0.0);
	// 	double dMaxShutter(0.0);
	// 	
	// 	double dCurGain(0.0);
	// 	double dMinGain(0.0);
	// 	double dMaxGain(0.0);
	// 	
	// 	// 帧率更新后，测试当前的曝光是否仍能使用
	// 	// 若可以则仍使用当前曝光，否则重新获取帧率更新后所支持的当前曝光
	// 	if (!pPTGrab->SetCurShutter(cameraParam.m_dShutter))
	// 	{        
	// 		if (!GetCameraShutter(nIndex, dCurShutter, dMinShutter, dMaxShutter))
	// 		{
	// 			if (bGrabLive)
	// 			{
	// 				pPTGrab->Grab();
	// 			}  
	// 			return FALSE;
	// 		}
	// 		else
	// 		{
	// 			cameraParam.m_dShutter = dCurShutter;
	// 		}		
	// 	}  
	// 	
	// 	if (!SetCameraParam(nIndex, cameraParam))
	// 	{
	// 		if (bGrabLive)
	// 		{
	// 			pPTGrab->Grab();
	// 		}  
	// 		
	// 		return FALSE;
	// 	}    
	// 
	// 	if (bGrabLive)
	// 	{
	// 		pPTGrab->Grab();
	// 	} 

	return TRUE;
}                       

// 更新相机本身的曝光时间
BOOL vcBaseVisionAlign::UpdateCameraShutter(int nIndex)
{
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	CameraParam cameraParam;

	if (FALSE == GetCameraParam(nIndex, cameraParam))
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	BOOL bGrabLive = pPTGrab->IsGrabbing();

	if (bGrabLive)
	{
		pPTGrab->Freeze();
		Sleep(10);	
	}

	// 设置曝光时间
	if (!pPTGrab->SetCurShutter(cameraParam.m_dShutter))
	{        
		if (bGrabLive)
		{
			pPTGrab->Grab();
		}   

		return FALSE;
	}  

	if (bGrabLive)
	{
		pPTGrab->Grab();
	} 

	return TRUE;
}                           

// 更新相机本身的增益
BOOL vcBaseVisionAlign::UpdateCameraGain(int nIndex)  
{
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	CameraParam cameraParam;

	if (FALSE == GetCameraParam(nIndex, cameraParam))
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	// 	if (eGigE == pPTGrab->GetCameraType())
	// 	{
	// //		return TRUE;
	// 	}

	BOOL bGrabLive = pPTGrab->IsGrabbing();

	if (bGrabLive)
	{
		pPTGrab->Freeze();
		Sleep(10);	
	}

	// 设置增益
	if (!pPTGrab->SetCurGain(cameraParam.m_dGain))
	{        
		if (bGrabLive)
		{
			pPTGrab->Grab();
		}   

		return FALSE;
	}  

	if (bGrabLive)
	{
		pPTGrab->Grab();
	} 

	return TRUE;
}     

// 更新相机本身的Gamma
BOOL vcBaseVisionAlign::UpdateCameraGamma(int nIndex)
{
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	CameraParam cameraParam;

	if (FALSE == GetCameraParam(nIndex, cameraParam))
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	// 	if (eGigE == pPTGrab->GetCameraType())
	// 	{
	// //		return TRUE;
	// 	}

	BOOL bGrabLive = pPTGrab->IsGrabbing();

	if (bGrabLive)
	{
		pPTGrab->Freeze();
		Sleep(10);	
	}

	// 设置Gamma
	if (!pPTGrab->SetCurGamma(cameraParam.m_dGamma))
	{        
		if (bGrabLive)
		{
			pPTGrab->Grab();
		}   

		return FALSE;
	}  

	if (!pPTGrab->SetGammaEnable(cameraParam.m_bGammaEnable))
	{        
		if (bGrabLive)
		{
			pPTGrab->Grab();
		}   

		return FALSE;
	}

	if (bGrabLive)
	{
		pPTGrab->Grab();
	} 

	return TRUE;
}

BOOL vcBaseVisionAlign::UpdateCameraWhiteBalance(int nIndex)
{
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	CameraParam cameraParam;

	if (FALSE == GetCameraParam(nIndex, cameraParam))
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	BOOL bGrabLive = pPTGrab->IsGrabbing();

	if (bGrabLive)
	{
		pPTGrab->Freeze();
		Sleep(10);	
	}

	// 设置曝光时间
	if (!pPTGrab->SetWhiteBalanceRatio(cameraParam.m_dWhiteBalanceRatioR,cameraParam.m_dWhiteBalanceRatioG,cameraParam.m_dWhiteBalanceRatioB))
	{        
		if (bGrabLive)
		{
			pPTGrab->Grab();
		}   

		return FALSE;
	}  

	if (bGrabLive)
	{
		pPTGrab->Grab();
	} 

	return TRUE;
}                           

// 更新相机本身到指定的视频模式、帧率、曝光时间、增益（注：该函数并不考虑各参数下状态之间是否合理）
BOOL vcBaseVisionAlign::UpdateCameraToCeartainStatus( int nIndex, CameraParam cameraParam )
{
	// 相机未连接时返回失败 
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}	

	BOOL bGrabLive = pPTGrab->IsGrabbing();

	if (bGrabLive)
	{
		pPTGrab->Freeze();
		Sleep(10);	
	}

	// 	// 设置视频模式
	// 	pPTGrab->SetCurVideoMode(g_vmVideoMode[cameraParam.m_nVideoMode]);

	// 设置帧率
	//	pPTGrab->SetCurFrameRate(cameraParam.m_dFrameRate);

	// 设置曝光时间
	pPTGrab->SetCurShutter(cameraParam.m_dShutter);

	// 设置增益
	pPTGrab->SetCurGain(cameraParam.m_dGain);       

	// 	// 设置Gmma
	// 	pPTGrab->SetCurGamma(cameraParam.m_dGamma); 
	// 	pPTGrab->SetGammaEnable(cameraParam.m_bGammaEnable);  

	if (bGrabLive)
	{
		pPTGrab->Grab();
	} 	

	return TRUE;

}

// 获取相机当前的视频模式（从相机本身获取）
BOOL vcBaseVisionAlign::GetCameraVideoMode(int nIndex, VideoMode& vmCameraMode)
{	
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	// 	if (!pPTGrab->GetCurVideoMode(&vmCameraMode))
	// 	{
	//        return FALSE;
	// 	}

	return TRUE;

}            

// 获取相机帧率（从相机本身获取）
BOOL vcBaseVisionAlign::GetCameraFrameRate(int nIndex, double& dCurFR, double& dMinFR, double& dMaxFR)
{
	// 相机未连接时返回失败
	// 	if (!m_vpCamera.at(nIndex)->IsOnline())
	// 	{
	// 		return FALSE;
	// 	}
	// 
	// 	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	// 	{
	// 		return FALSE;
	// 	}
	// 	
	// 	scPTGrab2* pPTGrab = m_vpCamera[nIndex];
	// 	
	// 	if (NULL == pPTGrab)
	// 	{
	// 		return FALSE;
	// 	}
	// 
	// 	float fCurFR(0.0), fMinFR(0.0), fMaxFR(0.0);
	// 	
	// 	if (!pPTGrab->GetCurFrameRate(&fCurFR))
	// 	{
	// 		return FALSE;
	// 	}
	// 	else
	// 	{
	// 		dCurFR = fCurFR;
	// 	}	
	// 
	// 	if (!pPTGrab->GetFrameRateRange(&fMinFR, &fMaxFR))
	// 	{
	// 		return FALSE;
	// 	}
	// 	else
	// 	{
	// 		dMinFR = fMinFR;
	// 		dMaxFR = fMaxFR;
	// 	}

	return TRUE;
}

// 获取相机曝光时间/增益（从相机本身获取）
BOOL vcBaseVisionAlign::GetCameraShutter(int nIndex, double& dCurShutter, double& dMinShutter, double& dMaxShutter)
{
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	float fCurShutter(0.0), fMinShutter(0.0), fMaxShutter(0.0);

	if (!pPTGrab->GetCurShutter(&fCurShutter))
	{
		return FALSE;
	}
	else
	{
		dCurShutter = fCurShutter;
	}	

	if (!pPTGrab->GetShutterRange(&fMinShutter, &fMaxShutter))
	{
		return FALSE;
	}
	else
	{
		dMinShutter = fMinShutter;
		dMaxShutter = fMaxShutter;
	}


	return TRUE;
}

BOOL vcBaseVisionAlign::GetCameraGain(int nIndex, double& dCurGain, double& dMinGain, double& dMaxGain)
{
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	float fCurGain(0.0), fMinGain(0.0), fMaxGain(0.0);

	if (!pPTGrab->GetCurGain(&fCurGain))
	{
		return FALSE;
	}
	else
	{
		dCurGain = fCurGain;
	}	

	if (!pPTGrab->GetGainRange(&fMinGain, &fMaxGain))
	{
		return FALSE;
	}
	else
	{
		dMinGain = fMinGain;
		dMaxGain = fMaxGain;
	}

	return TRUE;
}           

BOOL vcBaseVisionAlign::GetCameraGamma(int nIndex, bool& bEnable, double& dCurGamma, double& dMinGamma, double& dMaxGamma)
{
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	bool bGammaEnable = false;
	float fCurGamma(0.0), fMinGamma(0.0), fMaxGamma(0.0);

	if (!pPTGrab->GetGammaEnable(&bGammaEnable))
	{
		return FALSE;
	}

	if (!pPTGrab->GetCurGamma(&fCurGamma))
	{
		return FALSE;
	}
	else
	{
		dCurGamma = fCurGamma;
	}	

	if (!pPTGrab->GetGammaRange(&fMinGamma, &fMaxGamma))
	{
		return FALSE;
	}
	else
	{
		dMinGamma = fMinGamma;
		dMaxGamma = fMaxGamma;
	}

	return TRUE;
}

// 获取相机像素格式
BOOL vcBaseVisionAlign::GetCameraPixelFormat(int nIndex, CamPixelFormat& ePixelFormat)
{
	// 相机未连接时返回失败
	if (!m_vpCamera.at(nIndex)->IsOnline())
	{
		return FALSE;
	}

	if ( nIndex<0 || nIndex>=m_vpCamera.size() )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];
	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	int nFormat = 0;


	if (!pPTGrab->GetCamPixelFormat(nFormat))
	{
		return FALSE;
	}
	else
	{
		ePixelFormat = CamPixelFormat(nFormat);
	}	


	return TRUE;
} 

// 根据相机参数更新相机所有状态
BOOL vcBaseVisionAlign::UpdatePosCameraStatus(int nPosIndex)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return UpdateCameraStatus(nCameraIndex);
}

// 更新相机本身的视频模式
BOOL vcBaseVisionAlign::UpdatePosCameraVideo(int nPosIndex)  
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return UpdateCameraVideo(nCameraIndex);
}                         

// 更新相机本身的帧率
BOOL vcBaseVisionAlign::UpdatePosCameraFrameRate(int nPosIndex)  
{

	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return UpdateCameraFrameRate(nCameraIndex);
}                       

// 更新相机本身的曝光时间
BOOL vcBaseVisionAlign::UpdatePosCameraShutter(int nPosIndex)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return UpdateCameraShutter(nCameraIndex);
}                           

// 更新相机本身的增益
BOOL vcBaseVisionAlign::UpdatePosCameraGain(int nPosIndex)  
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return UpdateCameraGain(nCameraIndex);
}                     

// 更新相机本身的Gamma
BOOL vcBaseVisionAlign::UpdatePosCameraGamma(int nPosIndex)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return UpdateCameraGamma(nCameraIndex);
}

// 更新相机本身到指定的视频模式、帧率、曝光时间、增益（注：该函数并不考虑各参数下状态之间是否合理）
BOOL vcBaseVisionAlign::UpdatePosCameraToCeartainStatus( int nPosIndex, CameraParam cameraParam )
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return UpdateCameraToCeartainStatus(nCameraIndex, cameraParam);
}

// 获取相机当前的视频模式（从相机本身获取）
BOOL vcBaseVisionAlign::GetPosCameraVideoMode(int nPosIndex, VideoMode& vmPosCameraMode)
{	
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return GetCameraVideoMode(nCameraIndex, vmPosCameraMode);
}            

// 获取相机帧率（从相机本身获取）
BOOL vcBaseVisionAlign::GetPosCameraFrameRate(int nPosIndex, double& dCurFR, double& dMinFR, double& dMaxFR)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return GetCameraFrameRate(nCameraIndex, dCurFR, dMinFR, dMaxFR);
}

// 获取相机曝光时间/增益（从相机本身获取）
BOOL vcBaseVisionAlign::GetPosCameraShutter(int nPosIndex, double& dCurShutter, double& dMinShutter, double& dMaxShutter)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return GetCameraShutter(nCameraIndex, dCurShutter, dMinShutter, dMaxShutter);
}

BOOL vcBaseVisionAlign::GetPosCameraGain(int nPosIndex, double& dCurGain, double& dMinGain, double& dMaxGain)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return GetCameraGain(nCameraIndex,  dCurGain, dMinGain, dMaxGain);
}  

BOOL vcBaseVisionAlign::GetPosCameraGamma(int nPosIndex, bool& bEnable, double& dCurGamma, double& dMinGamma, double& dMaxGamma)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return GetCameraGamma(nCameraIndex, bEnable,  dCurGamma, dMinGamma, dMaxGamma);
}

// 获取相机像素格式
BOOL vcBaseVisionAlign::GetPosCameraPixelFormat(int nPosIndex,CamPixelFormat& pixelFormat)
{
	int nCameraIndex = -1;
	nCameraIndex = GetPosCameraIndex(nPosIndex);

	return GetCameraPixelFormat(nCameraIndex, pixelFormat);
}

BOOL vcBaseVisionAlign::SetCameraShutterByProduct( const CProductData& product )
{
	m_vvdTargetSearchShutter = product.m_pAlignerParam->m_vvdTargetSearchShutter;
	m_vvdObjectSearchShutter = product.m_pAlignerParam->m_vvdObjectSearchShutter;
	m_vvdCalibTargetSearchShutter = product.m_pAlignerParam->m_vvdCalibTargetSearchShutter;
	m_vvdVirtualObjectSearchShutter = product.m_pAlignerParam->m_vvdVirtualObjectSearchShutter;
	m_vvdInspectSearchShutter = product.m_pAlignerParam->m_vvdInspectSearchShutter;

	return TRUE;
}

BOOL vcBaseVisionAlign::SwitchToSearchShutter(int nPosIndex, double dShutter)
{
	int nIndex = GetPosCameraIndex(nPosIndex);
	if (nIndex<0 || nIndex >= m_vpCamera.size())
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (NULL == pPTGrab)
	{
		return FALSE;
	}

	BOOL bGrabLive = pPTGrab->IsGrabbing();

	if (bGrabLive)
	{
		pPTGrab->Freeze();
		Sleep(10);	
	}

	// 设置曝光时间
	if (!pPTGrab->SetCurShutter(dShutter))
	{        
		if (bGrabLive)
		{
			pPTGrab->Grab();
		}   

		return FALSE;
	}  

	if (bGrabLive)
	{
		pPTGrab->Grab();
	} 
	return TRUE;
}

BOOL vcBaseVisionAlign::SwitchToTargetSearchShutter(int nPosIndex, int nCandPatIndex)
{
	if (nCandPatIndex < 0)
	{
		nCandPatIndex = 0;
	}

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	//int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableSearchShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nCandPatIndex).m_bShutterEnable;
	BOOL bEnableSearchGain = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nCandPatIndex).m_bGainEnable;
	BOOL bEnableSearchGamma = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nCandPatIndex).m_bGammaEnable;
	if (bEnableSearchShutter || bEnableSearchGain || bEnableSearchGamma)
	{
		int nCameraIndex = GetPosCameraIndex(nPosIndex);

		scPTGrab2* pPTGrab = m_vpCamera[nCameraIndex];

		if (NULL == pPTGrab)
		{
			return FALSE;
		}

		//		Sleep(nDelayTime);

		// 设置曝光时间
		if (bEnableSearchShutter && !pPTGrab->SetCurShutter(m_vvdTargetSearchShutter[nPosIndex][nCandPatIndex].m_dShutter))
		{        
			return FALSE;
		}  	

		// 设置增益时间
		if (bEnableSearchGain && !pPTGrab->SetCurGain(m_vvdTargetSearchShutter[nPosIndex][nCandPatIndex].m_dGain))
		{        
			return FALSE;
		} 

		// 设置Gamma
		if (bEnableSearchGamma)
		{
			m_vImageTransfer.at(nPosIndex).SetGammaPara(m_vvdTargetSearchShutter[nPosIndex][nCandPatIndex].m_dGamma);
		}

		//		Sleep(nDelayTime);

		return TRUE;
	}

	return TRUE;
}

BOOL vcBaseVisionAlign::SwitchToObjectSearchShutter(int nPosIndex, int nCandPatIndex)
{
	if (nCandPatIndex < 0)
	{
		nCandPatIndex = 0;
	}

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	//int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableSearchShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nCandPatIndex).m_bShutterEnable;
	BOOL bEnableSearchGain = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nCandPatIndex).m_bGainEnable;
	BOOL bEnableSearchGamma = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nCandPatIndex).m_bGammaEnable;
	if (bEnableSearchShutter || bEnableSearchGain || bEnableSearchGamma)
	{
		int nCameraIndex = GetPosCameraIndex(nPosIndex);

		scPTGrab2* pPTGrab = m_vpCamera[nCameraIndex];

		if (NULL == pPTGrab)
		{
			return FALSE;
		}

		//		Sleep(nDelayTime);

		// 设置曝光时间
		if (bEnableSearchShutter && !pPTGrab->SetCurShutter(m_vvdObjectSearchShutter[nPosIndex][nCandPatIndex].m_dShutter))
		{        
			return FALSE;
		}

		// 设置增益时间
		if (bEnableSearchGain && !pPTGrab->SetCurGain(m_vvdObjectSearchShutter[nPosIndex][nCandPatIndex].m_dGain))
		{        
			return FALSE;
		} 

		// 设置Gamma
		if (bEnableSearchGamma)
		{
			m_vImageTransfer.at(nPosIndex).SetGammaPara(m_vvdObjectSearchShutter[nPosIndex][nCandPatIndex].m_dGamma);
		}

		//		Sleep(nDelayTime);

		return TRUE;
	}

	return TRUE;
}


BOOL vcBaseVisionAlign::SwitchToCalibTargetSearchShutter(int nPosIndex, int nCandPatIndex)
{
	if (nCandPatIndex < 0)
	{
		nCandPatIndex = 0;
	}

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	//int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();

	BOOL bEnableSearchShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableCalibTargetSearchShutter(nCandPatIndex).m_bShutterEnable;
	BOOL bEnableSearchGain = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableCalibTargetSearchShutter(nCandPatIndex).m_bGainEnable;
	BOOL bEnableSearchGamma = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableCalibTargetSearchShutter(nCandPatIndex).m_bGammaEnable;
	if (bEnableSearchShutter || bEnableSearchGain || bEnableSearchGamma)
	{
		int nCameraIndex = GetPosCameraIndex(nPosIndex);

		scPTGrab2* pPTGrab = m_vpCamera[nCameraIndex];

		if (NULL == pPTGrab)
		{
			return FALSE;
		}

		//		Sleep(nDelayTime);

		// 设置曝光时间
		if (bEnableSearchShutter && !pPTGrab->SetCurShutter(m_vvdCalibTargetSearchShutter[nPosIndex][nCandPatIndex].m_dShutter))
		{        
			return FALSE;
		} 

		// 设置增益时间
		if (bEnableSearchGain && !pPTGrab->SetCurGain(m_vvdCalibTargetSearchShutter[nPosIndex][nCandPatIndex].m_dGain))
		{        
			return FALSE;
		}

		// 设置Gamma
		if (bEnableSearchGamma)
		{
			m_vImageTransfer.at(nPosIndex).SetGammaPara(m_vvdCalibTargetSearchShutter[nPosIndex][nCandPatIndex].m_dGamma);
		}

		//		Sleep(nDelayTime);

		return TRUE;
	}

	return TRUE;
}


BOOL vcBaseVisionAlign::SwitchToVirtualObjectSearchShutter(int nPosIndex, int nCandPatIndex)
{
	if (nCandPatIndex < 0)
	{
		nCandPatIndex = 0;
	}

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	//int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableSearchShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableVirtualObjectSearchShutter(nCandPatIndex).m_bShutterEnable;
	BOOL bEnableSearchGain = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableVirtualObjectSearchShutter(nCandPatIndex).m_bGainEnable;
	BOOL bEnableSearchGamma = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableVirtualObjectSearchShutter(nCandPatIndex).m_bGammaEnable;
	if (bEnableSearchShutter || bEnableSearchGain || bEnableSearchGamma)
	{
		int nCameraIndex = GetPosCameraIndex(nPosIndex);

		scPTGrab2* pPTGrab = m_vpCamera[nCameraIndex];

		if (NULL == pPTGrab)
		{
			return FALSE;
		}

		//		Sleep(nDelayTime);

		// 设置曝光时间
		if (bEnableSearchShutter && !pPTGrab->SetCurShutter(m_vvdVirtualObjectSearchShutter[nPosIndex][nCandPatIndex].m_dShutter))
		{        
			return FALSE;
		}  	

		// 设置增益时间
		if (bEnableSearchGain && !pPTGrab->SetCurGain(m_vvdVirtualObjectSearchShutter[nPosIndex][nCandPatIndex].m_dGain))
		{        
			return FALSE;
		} 

		// 设置Gamma
		if (bEnableSearchGamma)
		{
			m_vImageTransfer.at(nPosIndex).SetGammaPara(m_vvdVirtualObjectSearchShutter[nPosIndex][nCandPatIndex].m_dGamma);
		}

		//		Sleep(nDelayTime);

		return TRUE;
	}

	return TRUE;
}

BOOL vcBaseVisionAlign::SwitchToDmCodeSearchShutter(int nPosIndex)
{
	CTotalProductData *pTotalProductData;
	pTotalProductData = GetTotalProuductData();
	int nCurProductIdx = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 获取当前产品对应的标定数据
	CProductData* pProductData;
	pProductData = pTotalProductData->GetItemPtr(nCurProductIdx);
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIdx)->m_pAlignerParam->GetObjectSearchDelayTime2();
	Sleep(nDelayTime);
	scDMCodeParam DmCodeParam;
	DmCodeParam = pProductData->m_vDMcodeCalib.at(nPosIndex);
	if (DmCodeParam.m_dShutter >= 0.001 )
	{
		return SwitchToSearchShutter(nPosIndex, DmCodeParam.m_dShutter);
	}
	return FALSE;
}

BOOL vcBaseVisionAlign::SwitchToInspectSearchShutter(int nPosIndex, int nCandPatIndex)
{
	if (nCandPatIndex < 0)
	{
		nCandPatIndex = 0;
	}

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	//int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();

	BOOL bEnableSearchShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nCandPatIndex).m_bShutterEnable;
	BOOL bEnableSearchGain = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nCandPatIndex).m_bGainEnable;
	BOOL bEnableSearchGamma = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nCandPatIndex).m_bGammaEnable;
	if (bEnableSearchShutter || bEnableSearchGain || bEnableSearchGamma)
	{
		int nCameraIndex = GetPosCameraIndex(nPosIndex);

		scPTGrab2* pPTGrab = m_vpCamera[nCameraIndex];

		if (NULL == pPTGrab)
		{
			return FALSE;
		}

		//Sleep(nDelayTime);

		// 设置曝光时间
		if (bEnableSearchShutter && !pPTGrab->SetCurShutter(m_vvdInspectSearchShutter[nPosIndex][nCandPatIndex].m_dShutter))
		{        
			return FALSE;
		}  	

		// 设置增益时间
		if (bEnableSearchGain && !pPTGrab->SetCurGain(m_vvdInspectSearchShutter[nPosIndex][nCandPatIndex].m_dGain))
		{        
			return FALSE;
		} 

		// 设置Gamma
		if (bEnableSearchGamma)
		{
			m_vImageTransfer.at(nPosIndex).SetGammaPara(m_vvdInspectSearchShutter[nPosIndex][nCandPatIndex].m_dGamma);
		}

		//Sleep(nDelayTime);

		return TRUE;
	}

	return TRUE;
}

BOOL vcBaseVisionAlign::SetCameraTriggerMode(PTTriggerMode eCameraTriggerMode)
{
	// 设置同一平台下所有的相机采集模式
	for (int i = 0; i < m_vpCamera.size(); ++i)
	{
		scPTGrab2* pGrab = m_vpCamera[i];
		if (NULL != pGrab)
		{
			// 停止相机采集，保存当前相机的工作状态，修改采集模式时，需要停止采集
			bool bGrabbing = false;
			if (pGrab->IsGrabbing())
			{
				FreezeCamera(i);
				bGrabbing = true;
			}

			// 在触发模式下，需要将相机的超时时间设置为无限大，连续采集模式默认为2000
			unsigned long ulLimitTime = 2000;
			if (ePTHardwareTrigger == eCameraTriggerMode || ePTSoftwareTrigger == eCameraTriggerMode)
			{
				ulLimitTime = INFINITE;
			}
			pGrab->SetTriggerMode(eCameraTriggerMode, ulLimitTime);

			// 相机在修改采集模式后会重置曝光及增益参数，需要重新设置
			CameraParam cameraParam;
			if (FALSE == GetCameraParam(i, cameraParam))
			{
				return FALSE;
			}
			pGrab->SetCurShutter(cameraParam.m_dShutter);
			pGrab->SetCurGain(cameraParam.m_dGain);

			// 			pGrab->SetCurGamma(cameraParam.m_dGamma);
			// 			pGrab->SetGammaEnable(cameraParam.m_bGammaEnable);

			// 恢复相机工作状态
			if (bGrabbing)
			{
				GrabCamera(i);
			}
		}
	}
	return TRUE;
}

// 采集所有相机的图像
BOOL vcBaseVisionAlign::GrabAllCameras()
{
	if (0 == m_vpCamera.size())
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = NULL;
	BOOL bLiveGrab = FALSE;

	for (int i=0; i<m_vpCamera.size(); i++)
	{
		pPTGrab = m_vpCamera[i];
		if (m_vbCameraLiveGrab[i] == TRUE)
		{
			continue;
		}
		if (pPTGrab!=NULL)
		{
			bLiveGrab = pPTGrab->Grab();            
			m_vbCameraLiveGrab[i] = bLiveGrab;	
			SetShareCameraLiveGrab(i,bLiveGrab);
		}
		else
		{
			return FALSE;
		}
	}

	return TRUE;
}

// 暂停所有相机的采集									
BOOL vcBaseVisionAlign::FreezeAllCameras()
{
	if (0 == m_vpCamera.size())
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = NULL;

	for (int i=0; i<m_vpCamera.size(); i++)
	{

		if (GetCameraShareType(i)==eShareTar)
		{
			continue;
		}

		pPTGrab = m_vpCamera[i];

		if (pPTGrab!=NULL)
		{
			if(TRUE == pPTGrab->Freeze())
			{
				m_vbCameraLiveGrab[i] = FALSE;
				SetShareCameraLiveGrab(i,FALSE);
			}
			else
			{
				return FALSE;
			}					
		}
		else
		{
			return FALSE;
		}
	}

	return TRUE;
}

// 采集单个相机的图像
BOOL vcBaseVisionAlign::GrabCamera(int nIndex)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];
	if (m_vbCameraLiveGrab[nIndex] == TRUE)
	{
		return TRUE;
	}
	BOOL bLiveGrab = FALSE;	

	if (pPTGrab!=NULL)
	{
		bLiveGrab = pPTGrab->Grab();		
		m_vbCameraLiveGrab[nIndex] = bLiveGrab;	
		SetShareCameraLiveGrab(nIndex,bLiveGrab);
	}
	else
	{
		return FALSE;
	}

	return bLiveGrab;
}

// 设置与该相机共享的相机是否在线
BOOL vcBaseVisionAlign::SetShareCameraLiveGrab(int nIndex,BOOL bGrab)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) )
	{
		return FALSE;
	}

	vcBaseVisionAlign* pAlign=NULL;
	if (GetCameraShareType(nIndex)==eShareSrc)
	{
		for (int i=0;i<m_pVisionASMConfig->m_vCameraParam[nIndex].m_nShareCamNum;i++)
		{
			int nTarPlatformIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(i).m_nPlatformIndex;
			int nTarCamIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(i).m_nCamIndex;
			pAlign=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nTarPlatformIdx);
			pAlign->m_vbCameraLiveGrab[nTarCamIdx]=bGrab;
		}
	}
	if (GetCameraShareType(nIndex)==eShareTar)
	{
		int nSrcPlatformIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nPlatformIndex;
		int nSrcCamIdx=m_pVisionASMConfig->m_vCameraParam[nIndex].m_vShareCamInfo.at(0).m_nCamIndex;
		pAlign=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nSrcPlatformIdx);
		pAlign->m_vbCameraLiveGrab[nSrcCamIdx]=bGrab;

		for (int i=0;i<pAlign->m_pVisionASMConfig->m_vCameraParam[nSrcCamIdx].m_nShareCamNum;i++)
		{
			vcBaseVisionAlign* pAlignTar=NULL;
			int nTarPlatformIdx= pAlign->m_pVisionASMConfig->m_vCameraParam[nSrcCamIdx].m_vShareCamInfo.at(i).m_nPlatformIndex;
			int nTarCamIdx= pAlign->m_pVisionASMConfig->m_vCameraParam[nSrcCamIdx].m_vShareCamInfo.at(i).m_nCamIndex;
			pAlignTar=((CVisionASMDlg*)m_pMainFrameWnd)->m_vpVisionASM.at(nTarPlatformIdx);
			pAlignTar->m_vbCameraLiveGrab[nTarCamIdx]=bGrab;
		}

	}
	return TRUE;
}


// 暂停单个相机的图像									
BOOL vcBaseVisionAlign::FreezeCamera(int nIndex)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (pPTGrab!=NULL)
	{
		if(TRUE == pPTGrab->Freeze())
		{
			m_vbCameraLiveGrab[nIndex] = FALSE;	
			SetShareCameraLiveGrab(nIndex,FALSE);
		}				
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

// 采集单个相机的单帧图像
BOOL vcBaseVisionAlign::SnapCamera(int nIndex)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];

	if (pPTGrab!=NULL)
	{
		if (pPTGrab->IsGrabbing())
		{
			pPTGrab->Freeze();
			Sleep(10);
		}

		return pPTGrab->Snap(TRUE);			
	}
	else
	{
		return FALSE;
	}

}

BOOL vcBaseVisionAlign::AutoBalance(int nIndex)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];
	BOOL bAutoBalance = FALSE;	

	if (pPTGrab!=NULL)
	{
		double d1 = 1.0;
		double d2 = 1.0;
		double d3 = 1.0;
		bAutoBalance = pPTGrab->AutoBalance(d1,d2,d3);	
		if (bAutoBalance)
		{
			SetCameraWhiteBalanceRatio(nIndex,d1,d2,d3);
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return bAutoBalance;
}

// 设置默认白平衡
BOOL vcBaseVisionAlign::SetCameraWhiteBalanceRatioDefault(int nIndex)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) )
	{
		return FALSE;
	}

	scPTGrab2* pPTGrab = m_vpCamera[nIndex];
	BOOL bOK = FALSE;	

	if (pPTGrab!=NULL)
	{
		double d1 = 1.0;
		double d2 = 1.0;
		double d3 = 1.0;
		bOK = pPTGrab->SetWhiteBalanceRatioDefault(d1,d2,d3);	
		if (bOK)
		{
			SetCameraWhiteBalanceRatio(nIndex,d1,d2,d3);
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return bOK;
}
// 判断某个相机是否在线
BOOL vcBaseVisionAlign::IsCameraOnline(int nIndex)
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) || (NULL == m_vpCamera[nIndex]) )
	{
		return FALSE;
	}	

	return m_vpCamera[nIndex]->IsOnline();
}								

// 判断某个相机是否正在采集
BOOL vcBaseVisionAlign::IsCameraGrabbing( int nIndex )
{
	if ( (nIndex<0) || (nIndex>=m_vpCamera.size()) || (NULL == m_vpCamera[nIndex]) )
	{
		return FALSE;
	}	

	return m_vpCamera[nIndex]->IsGrabbing();
}



// 采集单个相机的图像
BOOL vcBaseVisionAlign::GrabPosCamera(int nPosIndex)
{
	int nCameraIndex = GetPosCameraIndex(nPosIndex);
	return GrabCamera(nCameraIndex);
}

// 暂停单个相机的图像									
BOOL vcBaseVisionAlign::FreezePosCamera(int nPosIndex)
{
	int nCameraIndex = GetPosCameraIndex(nPosIndex);
	return FreezeCamera(nCameraIndex);
}

// 采集单个相机的单帧图像
BOOL vcBaseVisionAlign::SnapPosCamera(int nPosIndex)
{
	int nCameraIndex = GetPosCameraIndex(nPosIndex);
	return SnapCamera(nCameraIndex);
}


BOOL vcBaseVisionAlign::SetPosAutoBalance(int nPosIndex)
{
	int nCameraIndex = GetPosCameraIndex(nPosIndex);
	return AutoBalance(nCameraIndex);
}

// 设置默认白平衡
BOOL vcBaseVisionAlign::SetPosCameraWhiteBalanceRatioDefault(int nPosIndex)
{
	int nCameraIndex = GetPosCameraIndex(nPosIndex);
	return SetCameraWhiteBalanceRatioDefault(nCameraIndex);
}


// 判断某个相机是否在线
BOOL vcBaseVisionAlign::IsPosCameraOnline(int nPosIndex)
{
	int nCameraIndex = GetPosCameraIndex(nPosIndex);
	return IsCameraOnline(nCameraIndex);
}								

BOOL vcBaseVisionAlign::IsCameraOnlineStatus(int nIndex)
{
	if ( (nIndex<0) || nIndex>=m_vPTCameraIsOnLine.size())
	{
		return FALSE;
	}

	return (m_vPTCameraIsOnLine[nIndex]==ePTGrabOK)?TRUE:FALSE;
}

// 判断某个相机是否正在采集
BOOL vcBaseVisionAlign::IsPosCameraGrabbing( int nPosIndex )
{
	int nCameraIndex = GetPosCameraIndex(nPosIndex);
	return IsCameraGrabbing(nCameraIndex);
}

// 回调函数：要确认是哪个采集对象调用的，回调处理要识别是谁调用的，然后调用谁去做相应的处理
// 解决方法：使用采集回调对象（采集回调类中包括相机序号、采集回调类对象的拥有者）作为回调函数中的一个参数
//			 通过相机序号指定，使用回调处理函数调用对应的类对象进行操作

// pOwner即是一个回调采集对象
// 相机采集完成的回调函数，所有相机只有一个函数，这个是设计的比较麻烦的问题
void vcBaseVisionAlign::GrabImageFinishedCallback(void* pOwner, PTStatus status, unsigned char* pImage, 					
	long lWidth, long lHeight, PTPixelFormat pixelFormat)
{
	CCameraCallbackObject* pcbCallbackObject = (CCameraCallbackObject*)(pOwner);

	vcBaseVisionAlign* pBaseVisionASM = (vcBaseVisionAlign*)(pcbCallbackObject->m_pOwner);
	int nCameraIndex = pcbCallbackObject->m_nCamIndex;

	if(NULL == pBaseVisionASM)
	{
		return;
	}

	// 修复硬触发模式下，采集回调无返回时，错误判定掉线Bug
	if(nCameraIndex< pBaseVisionASM->m_vPTCameraIsOnLine.size()/* && nCameraIndex< pBaseVisionASM->m_vPTCameraIsOnLinePre.size() && !pBaseVisionASM->m_pPlatformInfo->m_bEnableCameraTriggerModeSet*/)
	{
		pBaseVisionASM->m_vPTCameraIsOnLine[nCameraIndex] = status;
		//pBaseVisionASM->SetShareCameraOnLine(nCameraIndex,status);

		//BOOL bChangeSave = FALSE; // 状态变更后才记录
		//if(pBaseVisionASM->m_vPTCameraIsOnLine[nCameraIndex] != pBaseVisionASM->m_vPTCameraIsOnLinePre[nCameraIndex])
		//{
		//	bChangeSave = TRUE;
		//	pBaseVisionASM->m_vPTCameraIsOnLinePre[nCameraIndex] = pBaseVisionASM->m_vPTCameraIsOnLine[nCameraIndex];
		//}

		if(ePTGrabOK != status)
		{
			//CString StrPath = pBaseVisionASM->m_strEXEDir + _T("\\VSLog\\CameraOfflineLog.txt");
			CString StrPath =  "D:\\CameLog.txt";
			CString StrLog = _T("");
			SysPlatformInfo sysPlatformInfo;
			pBaseVisionASM->GetSysPlatformInfo(sysPlatformInfo);

			if(pBaseVisionASM->m_pVisionASMConfig && nCameraIndex<pBaseVisionASM->m_pVisionASMConfig->m_vCameraParam.size())
			{
				CameraParam cameraParam = pBaseVisionASM->m_pVisionASMConfig->m_vCameraParam[nCameraIndex];
				StrLog.Format(_T("工位%d-相机%d(%s)采集回调状态：%d;相机掉线"),sysPlatformInfo.m_nPlatformIndex+1,nCameraIndex+1,cameraParam.m_strDeviceID,status);
				pBaseVisionASM->VisionAlignLogRecord(StrPath,StrLog);
				//if(pBaseVisionASM->m_pVisionASMConfig->m_DataRecord.m_bEnableCameraOffLineLog)
				//{
				//	pBaseVisionASM->VisionAlignLogRecord(StrPath,StrLog);
				//}
			}
		}

	}




	if (ePTGrabOK!=status)
	{
		return;
	}

	if (NULL == pOwner || pImage == NULL)
	{
		return ;
	}    


	if(NULL == pBaseVisionASM)
	{
		return;
	}

	// 	cpImage srcImage(pImage, lWidth, lHeight, 1);
	// 	
	// 	pBaseVisionASM->m_vbShareSrcCamTransferFinished.at(nCameraIndex) = FALSE;//重置源相机旋转镜像完成结果
	// 	pBaseVisionASM->ImageProcess(nCameraIndex, srcImage);

	cpImage srcImage;
	pBaseVisionASM->m_vbShareSrcCamTransferFinished.at(nCameraIndex) = FALSE;//重置源相机旋转镜像完成结果
	if (ePTGrey8 == pixelFormat)
	{
		CamPixelFormat eFormat;
		pBaseVisionASM->GetCameraPixelFormat(nCameraIndex,eFormat);
		if(eFormat == eCamBayer_BG8 || eFormat == eCamBayer_GB8 ||eFormat == eCamBayer_RG8 ||eFormat == eCamBayer_GR8)
		{
			srcImage.CreateImageBuffer(pImage, lWidth, lHeight,epGray8, 1);	

			pBaseVisionASM->ImageProcess(nCameraIndex, srcImage);

		}
		else if(eFormat == eCamGray)
		{
			srcImage.CreateImageBuffer(pImage, lWidth, lHeight,epGray8, 1);		
			pBaseVisionASM->ImageProcess(nCameraIndex, srcImage);
		}
		else
		{
			srcImage.CreateImageBuffer(pImage, lWidth, lHeight,epGray8, 1);		
			pBaseVisionASM->ImageProcess(nCameraIndex, srcImage);
		}

	}
	else if (ePTRGB24 == pixelFormat )
	{
		srcImage.CreateImageBuffer(pImage, lWidth, lHeight,epPackedRGB24, 1);	
		pBaseVisionASM->ImageProcess(nCameraIndex, srcImage);
	}
	else if (ePTRGBA32 == pixelFormat)
	{
		srcImage.CreateImageBuffer(pImage, lWidth, lHeight,epPackedRGB32, 1);	
		pBaseVisionASM->ImageProcess(nCameraIndex, srcImage);
	}

	CameraParam camParam;
	pBaseVisionASM->GetCameraParam(nCameraIndex,camParam);//获取相机参数
	if (camParam.m_eShareCamType==eShareSrc)//若为源相机
	{
		vcBaseVisionAlign* pBaseTarVisionASM = NULL;
		CVisionASMDlg* pMainDlg=(CVisionASMDlg*)(pBaseVisionASM->m_pMainFrameWnd);
		for (int g=0;g<camParam.m_nShareCamNum;g++)
		{
			//查找目标相机平台与相机序号
			int nPlatformIdx=camParam.m_vShareCamInfo.at(g).m_nPlatformIndex;
			int nCamIdx=camParam.m_vShareCamInfo.at(g).m_nCamIndex;
			pBaseTarVisionASM=pMainDlg->m_vpVisionASM.at(nPlatformIdx);

			if(NULL == pBaseTarVisionASM)
			{
				return;
			}

			pBaseTarVisionASM->ImageProcess(nCamIdx, srcImage);//目标相机图像处理

		}	
	}
}

void vcBaseVisionAlign::ImageProcess(int nIndex, const cpImage& srcImage)
{ 

	if (nIndex<0 || nIndex>m_vpCamera.size() || nIndex>m_vbImageProcessFinished.size())
	{
		return;
	}

	if ((NULL == m_pVisionASMConfig)||(NULL == m_pPlatformInfo))
	{
		return;
	}

	// 连续采集处理
	if (m_vbImageProcessFinished.at(nIndex))
	{
		m_vbImageProcessFinished.at(nIndex) = FALSE;

		int i = 0;
		int nPosIndex = 0;
		BOOL bSnapSearch = FALSE;	// 是否为定位搜索采集图像，如果是则后续延时发送显示图像消息以便让出CPU
		BOOL bCameraFirstPosIndexUpdateImage = FALSE;
		std::vector<BOOL> vbSnapSearchImageUpdateImage;
		vbSnapSearchImageUpdateImage.resize(m_vnSnapSearchImageIndex.size(), FALSE);

		std::vector<int> vnDisplayPosIndex;
		std::vector<BOOL> vbDisplaySnapSearch;

		for(i = 0; i < GetPosNum(); i++)
		{
			if (m_pVisionASMConfig->m_vPosInfo[i].m_nCamIndex == nIndex)
			{
				nPosIndex = i;

				// 获取相机像素类型，然后设置Bayer滤波类型
				{
					BOOL bBayerFilterEnable = FALSE;
					epBayerType bayerFilterType = epBayerRG8;

					CamPixelFormat eFormat = eCamColorUnknown;
					CameraParam camParam;
					GetCameraParam(nIndex,camParam);
					if (camParam.m_eShareCamType == eShareTar)//若为目标相机
					{
						//获取目标相机的源相机的平台和相机序号
						CVisionASMDlg* pSrcMainDlg=(CVisionASMDlg*)(m_pMainFrameWnd);
						int nSrcPlatformIdx=camParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
						int nSrcCamIdx=camParam.m_vShareCamInfo.at(0).m_nCamIndex;
						vcBaseVisionAlign* pBaseSrcVisionASM = pSrcMainDlg->m_vpVisionASM.at(nSrcPlatformIdx);
						pBaseSrcVisionASM->GetCameraPixelFormat(nSrcCamIdx, eFormat);

					}
					else
					{
						GetCameraPixelFormat(nIndex,eFormat);
					}

					if(eFormat == eCamBayer_RG8 || eFormat == eCamBayer_GB8 
						|| eFormat == eCamBayer_GR8 || eFormat == eCamBayer_BG8)
					{
						bBayerFilterEnable = TRUE;
						bayerFilterType = epBayerType(eFormat);
					}
					else
					{
						bBayerFilterEnable = FALSE;
					}

					m_vImageTransfer[nPosIndex].SetBayerFilterEnable(bBayerFilterEnable);
					m_vImageTransfer[nPosIndex].SetBayerFilterType(bayerFilterType);
				}



				// 图像的序号累加
				if (m_vnSnapSearchImageIndex[nPosIndex] >= m_pSystempOptionConfig->m_nDisplayIndex
					|| m_vnSnapSearchImageIndex[nPosIndex] < 0)
				{
					m_vnSnapSearchImageIndex[nPosIndex] = 0;
				}
				m_vnSnapSearchImageIndex[nPosIndex]++;

				if (m_vbSnapSearchImageStart[nPosIndex] == TRUE)// 如果需要进行搜索定位
				{
					//// 拷贝临时图像
					//m_vImageTemp1[nPosIndex] = srcImage;
					//m_vImageTemp2[nPosIndex] = srcImage; 	

					//// ROI设置
					//m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);

					int nCameraFirstPosIndex = GetCameraFirstPosIndex(nIndex);			



					if(nPosIndex == nCameraFirstPosIndex) 
					{
						// 如果nPosIndex是该索引号相机对应的第一个位置，那么进行相应图像变换

						// 拷贝临时图像
						m_vImageTemp1[nPosIndex] = srcImage;
						//m_vImageTemp2[nPosIndex] = srcImage; 	

						// ROI设置
						CameraParam camParam;
						GetCameraParam(nIndex,camParam);
						if (camParam.m_eShareCamType == eShareTar && m_vbShareCamTransferSame.at(nIndex))//若为目标相机且与源相机旋转镜像相同
						{
							//获取目标相机的源相机的平台和相机序号
							CVisionASMDlg* pSrcMainDlg=(CVisionASMDlg*)(m_pMainFrameWnd);
							int nSrcPlatformIdx=camParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
							int nSrcCamIdx=camParam.m_vShareCamInfo.at(0).m_nCamIndex;
							vcBaseVisionAlign* pBaseSrcVisionASM = pSrcMainDlg->m_vpVisionASM.at(nSrcPlatformIdx);
							int nSrcPos=pBaseSrcVisionASM->GetCameraFirstPosIndex(nSrcCamIdx);
							if (pBaseSrcVisionASM->m_vbShareSrcCamTransferFinished.at(nSrcCamIdx))
							{
								m_vImageTemp2[nPosIndex]=pBaseSrcVisionASM->GetTransferredImage(nSrcPos);//从源相机工位获取旋转镜像后的图象
							}
							else
							{
								m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);
							}					
						}
						else
						{
							m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);
							if (camParam.m_eShareCamType == eShareSrc)
							{
								m_vbShareSrcCamTransferFinished.at(nIndex)=TRUE;
							}			
						}

						bCameraFirstPosIndexUpdateImage = TRUE;
					}	
					else if((nPosIndex != nCameraFirstPosIndex) && bCameraFirstPosIndexUpdateImage == FALSE)
					{
						// 虽然nPosIndex不是该索引号相机对应的第一个位置，但nCameraFirstPosIndex最近未更新图像，那么也进行相应图像变换

						// 拷贝临时图像
						m_vImageTemp1[nPosIndex] = srcImage;
						//m_vImageTemp2[nPosIndex] = srcImage;

						// ROI设置
						CameraParam camParam;
						GetCameraParam(nIndex,camParam);
						if (camParam.m_eShareCamType == eShareTar && m_vbShareCamTransferSame.at(nIndex))//若为目标相机且与源相机旋转镜像相同
						{
							//获取目标相机的源相机的平台和相机序号
							CVisionASMDlg* pSrcMainDlg=(CVisionASMDlg*)(m_pMainFrameWnd);
							int nSrcPlatformIdx=camParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
							int nSrcCamIdx=camParam.m_vShareCamInfo.at(0).m_nCamIndex;
							vcBaseVisionAlign* pBaseSrcVisionASM = pSrcMainDlg->m_vpVisionASM.at(nSrcPlatformIdx);
							int nSrcPos=pBaseSrcVisionASM->GetCameraFirstPosIndex(nSrcCamIdx);
							if (pBaseSrcVisionASM->m_vbShareSrcCamTransferFinished.at(nSrcCamIdx))
							{
								m_vImageTemp2[nPosIndex]=pBaseSrcVisionASM->GetTransferredImage(nSrcPos);//从源相机工位获取旋转镜像后的图象
							}
							else
							{
								m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);
							}					
						}
						else
						{
							m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);
						}

						// 更新nCameraFirstPosIndex位置的图像
						m_vImageTemp2[nCameraFirstPosIndex] = m_vImageTemp2[nPosIndex];
						bCameraFirstPosIndexUpdateImage = TRUE;
						if (camParam.m_eShareCamType == eShareSrc)
						{
							m_vbShareSrcCamTransferFinished.at(nIndex)=TRUE;
						}
					}
					else	// 如果nPosIndex不是该索引号相机对应的第一个位置，那么进行从相机对应的第一个位置图像中拷贝相应临时图像。
					{
						// 拷贝临时图像
						m_vImageTemp2[nPosIndex] = m_vImageTemp2[nCameraFirstPosIndex];
					}


					// 拷贝图像显示		
					EnterCriticalSection(&m_vcsResource.at(nPosIndex));
					m_vImageInput[nPosIndex] = m_vImageTemp2[nPosIndex];
					CCoordPos imageSize;
					imageSize.m_dPosX = m_vImageInput[nPosIndex].Width();
					imageSize.m_dPosY = m_vImageInput[nPosIndex].Height();
					if (m_pAlignerTool != NULL)
					{
						m_pAlignerTool->SetImageSize(nPosIndex, TRUE, imageSize);
					}

					LeaveCriticalSection(&m_vcsResource.at(nPosIndex));


					if (m_vnSnapSearchImageStartIndex[nPosIndex] == 0) // 定位采集图像使用当前帧
					{
						//						m_vnSnapSearchImageStartIndex[nPosIndex]++;

						bSnapSearch = TRUE;
						m_vbSnapSearchImageStart[nPosIndex] = FALSE;
						m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
						m_vbSnapSearchImageEnd[nPosIndex] = TRUE;
						SetEvent(m_vhSnapSearchImageEndEvent[nPosIndex]);
						m_vnSnapSearchImageStartIndex[nPosIndex] = 0;

						// 图像的序号直接累加到CAMERA_IMAGE_DISPLAY_INDEX，用于后续的显示
						//m_vnSnapSearchImageIndex[nPosIndex] = m_pSystempOptionConfig->m_nDisplayIndex;
						vbSnapSearchImageUpdateImage[nPosIndex] = TRUE;

						// 						// 单帧显示
						// 						if (m_pSystempOptionConfig->m_nDisplayMode == 1)
						// 						{
						// 							// 发送显示图像的消息
						// 							PostMessageUpdateDisplaySearchImage(nPosIndex);
						// 						}


						vnDisplayPosIndex.push_back(nPosIndex);
						vbDisplaySnapSearch.push_back(TRUE);
					}
					else if(m_vnSnapSearchImageStartIndex[nPosIndex] == 1)		// 定位采集图像使用下一帧
					{
						bSnapSearch = TRUE;
						m_vbSnapSearchImageStart[nPosIndex] = FALSE;
						m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
						m_vbSnapSearchImageEnd[nPosIndex] = TRUE;
						SetEvent(m_vhSnapSearchImageEndEvent[nPosIndex]);
						m_vnSnapSearchImageStartIndex[nPosIndex] = 0;

						// 图像的序号直接累加到CAMERA_IMAGE_DISPLAY_INDEX，用于后续的显示
						//m_vnSnapSearchImageIndex[nPosIndex] = m_pSystempOptionConfig->m_nDisplayIndex;
						vbSnapSearchImageUpdateImage[nPosIndex] = TRUE;

						// 						// 单帧显示
						// 						if (m_pSystempOptionConfig->m_nDisplayMode == 1)
						// 						{
						// 							// 发送显示图像的消息
						// 							PostMessageUpdateDisplaySearchImage(nPosIndex);
						// 						}

						vnDisplayPosIndex.push_back(nPosIndex);
						vbDisplaySnapSearch.push_back(TRUE);
					}

				}
				else // 否则进行抽帧处理和显示
				{
					//// 图像的序号累加
					//if (m_vnSnapSearchImageIndex[nPosIndex] >= m_pSystempOptionConfig->m_nDisplayIndex
					//	|| m_vnSnapSearchImageIndex[nPosIndex] < 0)
					//{
					//	m_vnSnapSearchImageIndex[nPosIndex] = 0;
					//}
					//m_vnSnapSearchImageIndex[nPosIndex]++;

					// 当是连续显示模式，并且图像的序号是CAMERA_IMAGE_DISPLAY_INDEX时，则发送显示图像的信息
					//if (m_pSystempOptionConfig->m_nDisplayMode == 0
					if ( (m_pSystempOptionConfig->m_nDisplayMode == 0 || m_bEnableSingleFrameShowMode == FALSE)
						&& m_vnSnapSearchImageIndex[nPosIndex] == m_pSystempOptionConfig->m_nDisplayIndex)
					{

						//// 拷贝临时图像
						//m_vImageTemp1[nPosIndex] = srcImage;
						//m_vImageTemp2[nPosIndex] = srcImage; 	

						//// ROI设置
						//m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);

						int nCameraFirstPosIndex = GetCameraFirstPosIndex(nIndex);						
						if(nPosIndex == nCameraFirstPosIndex) 
						{
							// 如果nPosIndex是该索引号相机对应的第一个位置，那么进行相应图像变换

							// 拷贝临时图像
							m_vImageTemp1[nPosIndex] = srcImage;
							//m_vImageTemp2[nPosIndex] = srcImage; 	

							// ROI设置
							CameraParam camParam;
							GetCameraParam(nIndex,camParam);
							if (camParam.m_eShareCamType == eShareTar && m_vbShareCamTransferSame.at(nIndex))//若为目标相机且与源相机旋转镜像相同
							{
								//获取目标相机的源相机的平台和相机序号
								CVisionASMDlg* pSrcMainDlg=(CVisionASMDlg*)(m_pMainFrameWnd);
								int nSrcPlatformIdx=camParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
								int nSrcCamIdx=camParam.m_vShareCamInfo.at(0).m_nCamIndex;
								vcBaseVisionAlign* pBaseSrcVisionASM = pSrcMainDlg->m_vpVisionASM.at(nSrcPlatformIdx);
								int nSrcPos=pBaseSrcVisionASM->GetCameraFirstPosIndex(nSrcCamIdx);
								if (pBaseSrcVisionASM->m_vbShareSrcCamTransferFinished.at(nSrcCamIdx))
								{
									m_vImageTemp2[nPosIndex]=pBaseSrcVisionASM->GetTransferredImage(nSrcPos);//从源相机工位获取旋转镜像后的图象
								}
								else
								{
									m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);
								}					
							}
							else
							{
								m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);
								if (camParam.m_eShareCamType == eShareSrc)
								{
									m_vbShareSrcCamTransferFinished.at(nIndex)=TRUE;
								}
							}

							bCameraFirstPosIndexUpdateImage = TRUE;
						}	
						else if((nPosIndex != nCameraFirstPosIndex) && bCameraFirstPosIndexUpdateImage == FALSE)
						{
							// 虽然nPosIndex不是该索引号相机对应的第一个位置，但nCameraFirstPosIndex最近未更新图像，那么也进行相应图像变换

							// 拷贝临时图像
							m_vImageTemp1[nPosIndex] = srcImage;
							//m_vImageTemp2[nPosIndex] = srcImage;

							// ROI设置
							CameraParam camParam;
							GetCameraParam(nIndex,camParam);
							if (camParam.m_eShareCamType == eShareTar && m_vbShareCamTransferSame.at(nIndex))//若为目标相机且与源相机旋转镜像相同
							{
								//获取目标相机的源相机的平台和相机序号
								CVisionASMDlg* pSrcMainDlg=(CVisionASMDlg*)(m_pMainFrameWnd);
								int nSrcPlatformIdx=camParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
								int nSrcCamIdx=camParam.m_vShareCamInfo.at(0).m_nCamIndex;
								vcBaseVisionAlign* pBaseSrcVisionASM = pSrcMainDlg->m_vpVisionASM.at(nSrcPlatformIdx);
								int nSrcPos=pBaseSrcVisionASM->GetCameraFirstPosIndex(nSrcCamIdx);
								if (pBaseSrcVisionASM->m_vbShareSrcCamTransferFinished.at(nSrcCamIdx))
								{
									m_vImageTemp2[nPosIndex]=pBaseSrcVisionASM->GetTransferredImage(nSrcPos);//从源相机工位获取旋转镜像后的图象
								}
								else
								{
									m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);
								}					
							}
							else
							{
								m_vImageTransfer[nPosIndex].GetDisplayImage(m_vImageTemp1[nPosIndex], m_vImageTemp2[nPosIndex]);
							}

							// 更新nCameraFirstPosIndex位置的图像
							m_vImageTemp2[nCameraFirstPosIndex] = m_vImageTemp2[nPosIndex];
							bCameraFirstPosIndexUpdateImage = TRUE;
							if (camParam.m_eShareCamType == eShareSrc)
							{
								m_vbShareSrcCamTransferFinished.at(nIndex)=TRUE;
							}
						}
						else	// 如果nPosIndex不是该索引号相机对应的第一个位置，那么进行从相机对应的第一个位置图像中拷贝相应临时图像。
						{
							// 拷贝临时图像
							m_vImageTemp2[nPosIndex] = m_vImageTemp2[nCameraFirstPosIndex];	
						}



						// 拷贝图像显示		
						EnterCriticalSection(&m_vcsResource.at(nPosIndex));
						m_vImageInput[nPosIndex] = m_vImageTemp2[nPosIndex];
						CCoordPos imageSize;
						imageSize.m_dPosX = m_vImageInput[nPosIndex].Width();
						imageSize.m_dPosY = m_vImageInput[nPosIndex].Height();
						if (m_pAlignerTool != NULL)
						{
							m_pAlignerTool->SetImageSize(nPosIndex, TRUE, imageSize);
						}
						LeaveCriticalSection(&m_vcsResource.at(nPosIndex));

						vnDisplayPosIndex.push_back(nPosIndex);
						vbDisplaySnapSearch.push_back(FALSE);

					}

				}

			}
		}

		// 是否为定位搜索采集图像，如果是则后续延时发送显示图像消息以便让出CPU
		if (bSnapSearch)
		{
			Sleep(1);
		}


		//// 发送显示图像的消息
		//for(i = 0; i < GetPosNum(); i++)
		//{
		//	if (m_pVisionASMConfig->m_vPosInfo[i].m_nCamIndex == nIndex)
		//	{
		//		if (nIndex == 0)
		//		{
		//			int wel = 0;
		//			wel++;
		//		}

		//		if (nIndex == 1)
		//		{
		//			int wel = 0;
		//			wel++;
		//		}

		//		nPosIndex = i;
		//		if ((m_pPlatformInfo != NULL) && (m_pPlatformInfo->m_nShowMode == 1))	// 按相机数量显示图像时,一般只刷新第一个与相机匹配的对位位置
		//		{
		//			// 当是连续显示模式，并且图像的序号是CAMERA_IMAGE_DISPLAY_INDEX时，则发送显示图像的信息
		//			//if (m_pSystempOptionConfig->m_nDisplayMode == 0
		//			if ( (m_pSystempOptionConfig->m_nDisplayMode == 0 || m_bEnableSingleFrameShowMode == FALSE)
		//				&& ((m_vnSnapSearchImageIndex[nPosIndex] == m_pSystempOptionConfig->m_nDisplayIndex && (IsCameraFirstPosIndex(nPosIndex) || m_bEnableSingleFrameShowMode == FALSE)) 
		//				|| (vbSnapSearchImageUpdateImage[nPosIndex] == TRUE)))
		//			{
		//				PostMessageUpdateDisplayImage(nPosIndex);
		//			}
		//		}
		//		else	// 按对位位置数量显示图像时
		//		{
		//			// 当是连续显示模式，并且图像的序号是CAMERA_IMAGE_DISPLAY_INDEX时，则发送显示图像的信息
		//			//if (m_pSystempOptionConfig->m_nDisplayMode == 0
		//			if ( (m_pSystempOptionConfig->m_nDisplayMode == 0 || m_bEnableSingleFrameShowMode == FALSE)
		//				&& ((m_vnSnapSearchImageIndex[nPosIndex] == m_pSystempOptionConfig->m_nDisplayIndex) || vbSnapSearchImageUpdateImage[nPosIndex] == TRUE))
		//			{
		//				PostMessageUpdateDisplayImage(nPosIndex);
		//			}
		//		}

		//	}
		//}

		// 发送显示图像的消息
		for(i = 0; i < vnDisplayPosIndex.size(); i++)
		{
			nPosIndex = vnDisplayPosIndex[i];
			if (m_pPlatformInfo != NULL && m_pPlatformInfo->m_nShowMode == 1)
			{
				if (m_bEnableSingleFrameShowMode == FALSE)
				{
					PostMessageUpdateDisplayImage(nPosIndex);
				}
				else
				{
					if (i == 0)
					{
						PostMessageUpdateDisplayImage(nPosIndex);
					}
				}
			}
			else
			{
				PostMessageUpdateDisplayImage(nPosIndex);
			}
		}

		m_vbImageProcessFinished.at(nIndex) = TRUE;
	}

	// 		// 定位
	// 		CCoordPos cp;
	// 		//switch(m_smSearchMode)
	// 		switch(m_vsmSearchMode[nIndex])
	// 		{
	// 		case eNoSearch:			
	// 			break;
	// 		case eCalibSearch:
	// 			{	
	// 				if (TRUE == m_vbSearchFinished[nIndex]) break;								
	// 
	// 				if(TRUE == ExecuteCalibTargetSearch(nIndex))
	// 				{
	// 					m_vbSearchSucceed[nIndex] = TRUE;						 
	// 					m_vSeachResults[nIndex] = GetCalibTargetSearchResult(nIndex);
	// 					PostMessageUpdateCalibTargetSearchGraphics(nIndex, TRUE);
	// 
	// 					cp.m_dPosX  = m_vSeachResults[nIndex].m_dPosX;
	// 					cp.m_dPosY  = m_vSeachResults[nIndex].m_dPosY;
	// 					cp.m_dAngle = m_vSeachResults[nIndex].m_dAngle;
	// 					m_mpCalibMarkImagePos.SetMarkImagePos(nIndex, m_vbSearchSucceed[nIndex], cp);	
	// 
	// 				}
	// 				else
	// 				{
	// 					m_vbSearchSucceed[nIndex] =FALSE;							
	// 
	// 					// 					CString str;				
	// 					// 					str.Format(_T("%d"),nIndex);
	// 					// 					m_bStatusBar = FALSE;
	// 					// 					//m_strStatusBarInfo1 = _T("相机通道") + str +_T("标定定位失败!"); 
	// 					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CHANNEL) + str + GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_FAILED);
	// 					// 					m_strStatusBarInfo2 = _T("");
	// 					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
	// 					{	
	// 						CTime t = CTime::GetCurrentTime();	
	// 						m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageCalibSearchFailed.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 						m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 						m_vDibTemp.at(nIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nIndex));
	// 					}			 
	// 
	// 				}						 
	// 
	// 				m_vbSearchFinished[nIndex] = TRUE;
	// 			}
	// 			break;
	// 		case eTargetSearch:
	// 			{
	// 				if (TRUE == m_vbSearchFinished[nIndex]) break;			
	// 
	// 				if (TRUE == ExecuteAlnTargetSearch(nIndex))
	// 				{
	// 					m_vbSearchSucceed[nIndex] = TRUE;
	// 					m_vSeachResults[nIndex] = GetAlnTargetSearchResult(nIndex);
	// 					PostMessageUpdateAlnTargetSearchGraphics(nIndex, TRUE);  
	// 
	// 					cp.m_dPosX  = m_vSeachResults[nIndex].m_dPosX;
	// 					cp.m_dPosY  = m_vSeachResults[nIndex].m_dPosY;
	// 					cp.m_dAngle = m_vSeachResults[nIndex].m_dAngle;
	// 					m_mpTargetMarkImagePos.SetMarkImagePos(nIndex, m_vbSearchSucceed[nIndex], cp);
	// 				}
	// 				else
	// 				{
	// 					m_vbSearchSucceed[nIndex] =FALSE;
	// 
	// 					// 					CString str;				
	// 					// 					str.Format(_T("%d"),nIndex);
	// 					// 					m_bStatusBar = FALSE;
	// 					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CHANNEL) + str + GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
	// 					// 					m_strStatusBarInfo2 = _T("");
	// 					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();					
	// 
	// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
	// 					{		
	// 						CTime t = CTime::GetCurrentTime();	
	// 						m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageTargetSearchFailed.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 						m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 						m_vDibTemp.at(nIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nIndex));
	// 					}						
	// 				}
	// 
	// 				m_vbSearchFinished[nIndex] = TRUE;
	// 			}
	// 			break;
	// 		case eObjectSearch:
	// 			{
	// 				if (TRUE == m_vbSearchFinished[nIndex]) break;	
	// 
	// 				scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	// 
	// 				stObjectSearchTimer.Reset();
	// 				if (TRUE == ExecuteAlnObjectSearch(nIndex))
	// 				{
	// 					dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
	// 					CString str;
	// 					str.Format("Object search time = %f",dObjectSearchTime);
	// 					AlignLogRecord(str);
	// 					m_vbSearchSucceed[nIndex] = TRUE;
	// 					m_vSeachResults[nIndex] = GetAlnObjectSearchResult(nIndex);
	// 					PostMessageUpdateAlnObjectSearchGraphics(nIndex, TRUE);
	// 
	// 					cp.m_dPosX  = m_vSeachResults[nIndex].m_dPosX;
	// 					cp.m_dPosY  = m_vSeachResults[nIndex].m_dPosY;
	// 					cp.m_dAngle = m_vSeachResults[nIndex].m_dAngle;
	// 					m_mpObjectMarkImagePos.SetMarkImagePos(nIndex, m_vbSearchSucceed[nIndex], cp);
	// 
	// 				}
	// 				else
	// 				{
	// 					m_vbSearchSucceed[nIndex] =FALSE;
	// 
	// 					// 					CString str;				
	// 					// 					str.Format(_T("%d"),nIndex);
	// 					// 					m_bStatusBar = FALSE;
	// 					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CHANNEL) + str + GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
	// 					// 					m_strStatusBarInfo2 = _T("");
	// 					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
	// 					{							 
	// 						CTime t = CTime::GetCurrentTime();	
	// 						m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageObjectSearchFailed.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 						m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 						m_vDibTemp.at(nIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nIndex));
	// 					}
	// 
	// 				}
	// 
	// 				m_vbSearchFinished[nIndex] = TRUE;
	// 			}
	// 			break;
	// 		case eVirtualSearch:
	// 			{
	// 				if (TRUE == m_vbSearchFinished[nIndex]) break;
	// 
	// 				if (TRUE == ExecuteAlnVirtualObjectSearch(nIndex))
	// 				{
	// 					m_vbSearchSucceed[nIndex] = TRUE;
	// 					m_vSeachResults[nIndex] = GetAlnVirtualObjectSearchResult(nIndex);
	// 					PostMessageUpdateAlnVirtualObjectGraphics(nIndex, TRUE);
	// 
	// 					cp.m_dPosX  = m_vSeachResults[nIndex].m_dPosX;
	// 					cp.m_dPosY  = m_vSeachResults[nIndex].m_dPosY;
	// 					cp.m_dAngle = m_vSeachResults[nIndex].m_dAngle;
	// 					m_mpVirtualMarkImagePos.SetMarkImagePos(nIndex, m_vbSearchSucceed[nIndex], cp);
	// 				}
	// 				else
	// 				{
	// 					m_vbSearchSucceed[nIndex] =FALSE;
	// 
	// 					// 					CString str;				
	// 					// 					str.Format(_T("%d"),nIndex);
	// 					// 					m_bStatusBar = FALSE;
	// 					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CHANNEL) + str + GetSysInfoString(m_psaSysInfoStrings,IDS_SB_VIRTUAL_SEARCH_FAILED);
	// 					// 					m_strStatusBarInfo2 = _T("");
	// 					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
	// 					{							 
	// 						CTime t = CTime::GetCurrentTime();	
	// 						m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageVirtualSearchFailed.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 						m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 						m_vDibTemp.at(nIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nIndex));
	// 					}			
	// 
	// 				}
	// 
	// 				m_vbSearchFinished[nIndex] = TRUE;
	// 			}
	// 			break;
	// 		default:
	// 			break;
	// 		}	
	// 
	// 		m_vbImageProcessFinished.at(nIndex) = TRUE;
	// 	}   



	// 	// 连续采集处理
	// 	if (m_vbImageProcessFinished.at(nIndex))
	// 	{
	// 		m_vbImageProcessFinished.at(nIndex) = FALSE;
	// 
	// 		m_vImageTemp1[nIndex] = srcImage;
	// 		m_vImageTemp2[nIndex] = srcImage; 	
	// 		
	// 		// ROI设置
	// 		m_vImageTransfer[nIndex].GetDisplayImage(m_vImageTemp1[nIndex], m_vImageTemp2[nIndex]);
	// 		
	// 		// 图像显示		
	// 		EnterCriticalSection(&m_vcsResource.at(nIndex));
	// 		m_vImageInput[nIndex] = m_vImageTemp2[nIndex];
	// 		LeaveCriticalSection(&m_vcsResource.at(nIndex));
	// 		  
	// 		PostMessageUpdateDisplayImage(nIndex);	
	// 	
	// 		// 定位
	// 		CCoordPos cp;
	// 		//switch(m_smSearchMode)
	// 		switch(m_vsmSearchMode[nIndex])
	// 		{
	// 		case eNoSearch:			
	// 			break;
	// 		case eCalibSearch:
	// 			{	
	// 				if (TRUE == m_vbSearchFinished[nIndex]) break;								
	// 				
	// 				if(TRUE == ExecuteCalibTargetSearch(nIndex))
	// 				{
	// 					m_vbSearchSucceed[nIndex] = TRUE;						 
	// 					m_vSeachResults[nIndex] = GetCalibTargetSearchResult(nIndex);
	// 					PostMessageUpdateCalibTargetSearchGraphics(nIndex, TRUE);
	//                     
	// 					cp.m_dPosX  = m_vSeachResults[nIndex].m_dPosX;
	// 					cp.m_dPosY  = m_vSeachResults[nIndex].m_dPosY;
	// 					cp.m_dAngle = m_vSeachResults[nIndex].m_dAngle;
	// 					m_mpCalibMarkImagePos.SetMarkImagePos(nIndex, m_vbSearchSucceed[nIndex], cp);	
	// 					
	// 				}
	// 				else
	// 				{
	// 					m_vbSearchSucceed[nIndex] =FALSE;							
	// 
	// // 					CString str;				
	// // 					str.Format(_T("%d"),nIndex);
	// // 					m_bStatusBar = FALSE;
	// // 					//m_strStatusBarInfo1 = _T("相机通道") + str +_T("标定定位失败!"); 
	// // 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CHANNEL) + str + GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_FAILED);
	// // 					m_strStatusBarInfo2 = _T("");
	// // 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 					
	// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
	// 					{	
	// 						CTime t = CTime::GetCurrentTime();	
	// 			            m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageCalibSearchFailed.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 						m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 						m_vDibTemp.at(nIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nIndex));
	// 					}			 
	// 					
	// 				}						 
	// 				
	// 				m_vbSearchFinished[nIndex] = TRUE;
	// 			}
	// 			break;
	// 		case eTargetSearch:
	// 			{
	// 				if (TRUE == m_vbSearchFinished[nIndex]) break;			
	// 						
	// 				if (TRUE == ExecuteAlnTargetSearch(nIndex))
	// 				{
	// 					m_vbSearchSucceed[nIndex] = TRUE;
	// 					m_vSeachResults[nIndex] = GetAlnTargetSearchResult(nIndex);
	// 					PostMessageUpdateAlnTargetSearchGraphics(nIndex, TRUE);  
	// 					
	// 					cp.m_dPosX  = m_vSeachResults[nIndex].m_dPosX;
	// 					cp.m_dPosY  = m_vSeachResults[nIndex].m_dPosY;
	// 					cp.m_dAngle = m_vSeachResults[nIndex].m_dAngle;
	// 					m_mpTargetMarkImagePos.SetMarkImagePos(nIndex, m_vbSearchSucceed[nIndex], cp);
	// 				}
	// 				else
	// 				{
	// 					m_vbSearchSucceed[nIndex] =FALSE;
	// 					
	// // 					CString str;				
	// // 					str.Format(_T("%d"),nIndex);
	// // 					m_bStatusBar = FALSE;
	// // 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CHANNEL) + str + GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
	// // 					m_strStatusBarInfo2 = _T("");
	// // 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();					
	// 
	// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
	// 					{		
	// 						CTime t = CTime::GetCurrentTime();	
	// 			            m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageTargetSearchFailed.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 						m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 						m_vDibTemp.at(nIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nIndex));
	// 					}						
	// 				}
	// 				
	// 				m_vbSearchFinished[nIndex] = TRUE;
	// 			}
	// 			break;
	// 		case eObjectSearch:
	// 			{
	// 				if (TRUE == m_vbSearchFinished[nIndex]) break;	
	// 				
	// 				scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	// 
	// 				stObjectSearchTimer.Reset();
	// 				if (TRUE == ExecuteAlnObjectSearch(nIndex))
	// 				{
	// 					dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
	// 					CString str;
	// 					str.Format("Object search time = %f",dObjectSearchTime);
	// 					AlignLogRecord(str);
	// 					m_vbSearchSucceed[nIndex] = TRUE;
	// 					m_vSeachResults[nIndex] = GetAlnObjectSearchResult(nIndex);
	// 					PostMessageUpdateAlnObjectSearchGraphics(nIndex, TRUE);
	// 					
	// 					cp.m_dPosX  = m_vSeachResults[nIndex].m_dPosX;
	// 					cp.m_dPosY  = m_vSeachResults[nIndex].m_dPosY;
	// 					cp.m_dAngle = m_vSeachResults[nIndex].m_dAngle;
	// 					m_mpObjectMarkImagePos.SetMarkImagePos(nIndex, m_vbSearchSucceed[nIndex], cp);
	// 					
	// 				}
	// 				else
	// 				{
	// 					m_vbSearchSucceed[nIndex] =FALSE;
	// 					
	// // 					CString str;				
	// // 					str.Format(_T("%d"),nIndex);
	// // 					m_bStatusBar = FALSE;
	// // 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CHANNEL) + str + GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
	// // 					m_strStatusBarInfo2 = _T("");
	// // 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 					
	// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
	// 					{							 
	// 						CTime t = CTime::GetCurrentTime();	
	// 			            m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageObjectSearchFailed.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 						m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 						m_vDibTemp.at(nIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nIndex));
	// 					}
	// 					
	// 				}
	// 				
	// 				m_vbSearchFinished[nIndex] = TRUE;
	// 			}
	// 			break;
	// 		case eVirtualSearch:
	// 			{
	// 				if (TRUE == m_vbSearchFinished[nIndex]) break;
	// 								
	// 				if (TRUE == ExecuteAlnVirtualObjectSearch(nIndex))
	// 				{
	// 					m_vbSearchSucceed[nIndex] = TRUE;
	// 					m_vSeachResults[nIndex] = GetAlnVirtualObjectSearchResult(nIndex);
	// 					PostMessageUpdateAlnVirtualObjectGraphics(nIndex, TRUE);
	// 					
	// 					cp.m_dPosX  = m_vSeachResults[nIndex].m_dPosX;
	// 					cp.m_dPosY  = m_vSeachResults[nIndex].m_dPosY;
	// 					cp.m_dAngle = m_vSeachResults[nIndex].m_dAngle;
	// 					m_mpVirtualMarkImagePos.SetMarkImagePos(nIndex, m_vbSearchSucceed[nIndex], cp);
	// 				}
	// 				else
	// 				{
	// 					m_vbSearchSucceed[nIndex] =FALSE;
	// 					
	// // 					CString str;				
	// // 					str.Format(_T("%d"),nIndex);
	// // 					m_bStatusBar = FALSE;
	// // 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CHANNEL) + str + GetSysInfoString(m_psaSysInfoStrings,IDS_SB_VIRTUAL_SEARCH_FAILED);
	// // 					m_strStatusBarInfo2 = _T("");
	// // 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 					
	// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
	// 					{							 
	// 						CTime t = CTime::GetCurrentTime();	
	// 			            m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageVirtualSearchFailed.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 						m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 						m_vDibTemp.at(nIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nIndex));
	// 					}			
	// 					
	// 				}
	// 				
	// 				m_vbSearchFinished[nIndex] = TRUE;
	// 			}
	// 			break;
	// 		default:
	// 			break;
	// 			}	
	// 			
	// 			m_vbImageProcessFinished.at(nIndex) = TRUE;
	// 		}   

}
cpImage& vcBaseVisionAlign::GetTransferredImage(int nPosIndex)
{
	return	m_vImageTemp2[nPosIndex];
}
BOOL vcBaseVisionAlign::IsShareCamTransferSame(int nIndex)
{
	if (nIndex<0 || nIndex>=m_vpCamera.size())
	{
		return FALSE;
	}

	if ((NULL == m_pVisionASMConfig)||(NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CameraParam camParam;
	GetCameraParam(nIndex,camParam);
	if (camParam.m_eShareCamType==eShareTar)//判断目标相机与源相机旋转镜像是否相同
	{
		int nPosIdx=GetCameraFirstPosIndex(nIndex);
		ImageRoi imgRoi;
		GetPosImageROIParam(nPosIdx,imgRoi);

		vcBaseVisionAlign* pBaseSrcVisionASM=NULL;
		CVisionASMDlg* pMainDlg=(CVisionASMDlg*)m_pMainFrameWnd;

		int bSame=TRUE;
		{
			int nSrcPlatformIdx=camParam.m_vShareCamInfo.at(0).m_nPlatformIndex;
			int nSrcCamIdx=camParam.m_vShareCamInfo.at(0).m_nCamIndex;
			pBaseSrcVisionASM=pMainDlg->m_vpVisionASM.at(nSrcPlatformIdx);
			if(NULL == pBaseSrcVisionASM)
			{
				return FALSE;
			}
			int nTempPosIdx=pBaseSrcVisionASM->GetCameraFirstPosIndex(nSrcCamIdx);
			ImageRoi tempImageRoi;
			pBaseSrcVisionASM->GetPosImageROIParam(nTempPosIdx,tempImageRoi);
			if (tempImageRoi.m_bMirrorHoriz!=imgRoi.m_bMirrorHoriz || tempImageRoi.m_bMirrorVert!=imgRoi.m_bMirrorVert)
			{
				bSame=FALSE;
			}
			if (tempImageRoi.m_nRotation!=imgRoi.m_nRotation)
			{
				bSame=FALSE;
			}
			if (tempImageRoi.m_bGammaCorrectionEnable!=imgRoi.m_bGammaCorrectionEnable || fabs(tempImageRoi.m_dGamma - imgRoi.m_dGamma) > 0.001)
			{
				bSame=FALSE;
			}
		}
		return bSame;
	}
	return FALSE;

}
BOOL vcBaseVisionAlign::UpdateShareCamTransferSame()
{
	for (int i=0;i<m_vbShareCamTransferSame.size();i++)
	{
		m_vbShareCamTransferSame.at(i)=IsShareCamTransferSame(i);
	}
	return TRUE;
}
BOOL vcBaseVisionAlign::UpdateShareCamTransferSame(int nIndex)
{
	m_vbShareCamTransferSame.at(nIndex)=IsShareCamTransferSame(nIndex);
	return TRUE;
}

BOOL vcBaseVisionAlign::SetCameraCallback(void* pOwner)
{
	if ((NULL == pOwner))
	{
		return FALSE;
	}

	CCameraCallbackObject* pCallbackObject = (CCameraCallbackObject*)pOwner;

	if ((pCallbackObject->m_nCamIndex<0) || (pCallbackObject->m_nCamIndex>=m_vpCamera.size()) || (pCallbackObject->m_nCamIndex>=m_vpCamOwner.size()))
	{
		return FALSE;
	}

	m_vpCamOwner[pCallbackObject->m_nCamIndex]->m_nCamIndex = pCallbackObject->m_nCamIndex;
	m_vpCamOwner[pCallbackObject->m_nCamIndex]->m_pOwner    = pCallbackObject->m_pOwner;  	

	return TRUE;
}

// 获取相机的回调及相关调用所有者							
BOOL vcBaseVisionAlign::GetCameraCallback(void* pOwner)
{
	if ((NULL == pOwner))
	{
		return FALSE;
	}

	CCameraCallbackObject* pCallbackObject = (CCameraCallbackObject*)pOwner;

	if ((pCallbackObject->m_nCamIndex<0) || (pCallbackObject->m_nCamIndex>=m_vpCamera.size()) || (pCallbackObject->m_nCamIndex>=m_vpCamOwner.size()))
	{
		return FALSE;
	}

	pCallbackObject->m_pOwner = m_vpCamOwner[pCallbackObject->m_nCamIndex]->m_pOwner;

	pOwner = pCallbackObject;

	return TRUE;
}

// 设置用于显示各个相机采集图像的Display
void vcBaseVisionAlign::SetCameraDisplay(int nIndex, scGuiDisplay* pDisplay)
{

	if (NULL == m_pPlatformInfo || nIndex<0 || nIndex>=GetPosNum() || nIndex>=m_vpGuiDisplay.size())
	{
		return ;
	}

	m_vpGuiDisplay[nIndex] = pDisplay;		

	// 获取当前使用的产品
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	SetPosSearchToolDisplay(nCurProductIndex, nIndex, pDisplay);

}

// 获取用于显示单个相机采集图像的Display		
scGuiDisplay* vcBaseVisionAlign::GetCameraDisplay(int nIndex)
{
	if ( nIndex<0 || nIndex>=GetPosNum() || nIndex>=m_vpGuiDisplay.size() )
	{
		return NULL;
	}

	return m_vpGuiDisplay[nIndex];

}


// 设置用于显示各个相机采集图像的Display
void vcBaseVisionAlign::SetPosDisplay(int nIndex, scGuiDisplay* pDisplay)
{
	if (NULL == m_pPlatformInfo || nIndex<0 || nIndex>=GetPosNum() || nIndex>=m_vpGuiDisplay.size())
	{
		return ;
	}

	m_vpGuiDisplay[nIndex] = pDisplay;		

	// 获取当前使用的产品
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	SetPosSearchToolDisplay(nCurProductIndex, nIndex, pDisplay);
}

// 获取用于显示单个相机采集图像的Display		
scGuiDisplay* vcBaseVisionAlign::GetPosDisplay(int nIndex)
{
	if ( nIndex<0 || nIndex>=GetPosNum() || nIndex>=m_vpGuiDisplay.size() )
	{
		return NULL;
	}

	return m_vpGuiDisplay[nIndex];
}

// 设置用于显示各位置定位工具的Display
void vcBaseVisionAlign::SetPosSearchToolDisplay(int nProductIndex, int nPosIndex, scGuiDisplay* pDisplay)
{
	// 
	CBaseSearchTool *pSearchTool = NULL;
	int nPatIndex = 0;
	int nSearchToolCount = 0;

	nSearchToolCount = GetRepoCalibObjectSearchToolCount(nProductIndex, nPosIndex);
	for (nPatIndex = 0; nPatIndex < nSearchToolCount; nPatIndex++)
	{
		pSearchTool = GetRepoCalibObjectSearchTool(nProductIndex, nPosIndex, nPatIndex);
		if (pSearchTool != NULL)
		{
			pSearchTool->SetDisplay(pDisplay);
		}
	}

	nSearchToolCount = GetRepoAlnTargetSearchToolCount(nProductIndex, nPosIndex);
	for (nPatIndex = 0; nPatIndex < nSearchToolCount; nPatIndex++)
	{
		pSearchTool = GetRepoAlnTargetSearchTool(nProductIndex, nPosIndex, nPatIndex);
		if (pSearchTool != NULL)
		{
			pSearchTool->SetDisplay(pDisplay);
		}
	}

	nSearchToolCount = GetRepoAlnObjectSearchToolCount(nProductIndex, nPosIndex);
	for (nPatIndex = 0; nPatIndex < nSearchToolCount; nPatIndex++)
	{
		pSearchTool = GetRepoAlnObjectSearchTool(nProductIndex, nPosIndex, nPatIndex);
		if (pSearchTool != NULL)
		{
			pSearchTool->SetDisplay(pDisplay);
		}
	}

	nSearchToolCount = GetRepoAlnCalibTargetSearchToolCount(nProductIndex, nPosIndex);
	for (nPatIndex = 0; nPatIndex < nSearchToolCount; nPatIndex++)
	{
		pSearchTool = GetRepoAlnCalibTargetSearchTool(nProductIndex, nPosIndex, nPatIndex);
		if (pSearchTool != NULL)
		{
			pSearchTool->SetDisplay(pDisplay);
		}
	}

	nSearchToolCount = GetRepoAlnVirtualObjectSearchToolCount(nProductIndex, nPosIndex);
	for (nPatIndex = 0; nPatIndex < nSearchToolCount; nPatIndex++)
	{
		pSearchTool = GetRepoAlnVirtualObjectSearchTool(nProductIndex, nPosIndex, nPatIndex);
		if (pSearchTool != NULL)
		{
			pSearchTool->SetDisplay(pDisplay);
		}
	}


	nSearchToolCount = GetRepoAlnInspectSearchToolCount(nProductIndex, nPosIndex);
	for (nPatIndex = 0; nPatIndex < nSearchToolCount; nPatIndex++)
	{
		pSearchTool = GetRepoAlnInspectSearchTool(nProductIndex, nPosIndex, nPatIndex);
		if (pSearchTool != NULL)
		{
			pSearchTool->SetDisplay(pDisplay);
		}
	}

}



// 如何将发出的消息与响应对应起来呢？
// 发送的消息：只有两个参数，怎么区分是哪个平台、哪个相机、哪种处理方法呢？
// 解决方法：建立消息映射表
// 发送更新Display显示图像的消息
void vcBaseVisionAlign::PostMessageUpdateDisplayImage(int nIndex)
{
	if (nIndex<0 || nIndex>=m_vpGuiDisplay.size())
	{
		return;
	}

	if (NULL == m_pMainWnd)
	{
		return;
	}

	PostMessage(m_pMainWnd->GetSafeHwnd(), WM_UPDATE_DISPLAY_IMAGE, nIndex, 0);

}



// 更新Display显示的图像，该函数被系统的主线程调用					
void vcBaseVisionAlign::UpdateDisplayImage(int nIndex)
{
	if (nIndex<0 || nIndex>=m_vpGuiDisplay.size()||nIndex>=m_vImageInput.size())
	{
		return;
	}

	scGuiDisplay* pGuiDisplay = m_vpGuiDisplay[nIndex];

	if (NULL == pGuiDisplay)
	{
		return;
	}


	EnterCriticalSection(&m_vcsResource.at(nIndex));

	if (pGuiDisplay->GetImageCP() != NULL
		&& pGuiDisplay->GetImageWidth() == m_vImageInput[nIndex].Width()
		&& pGuiDisplay->GetImageHeight() == m_vImageInput[nIndex].Height())
	{
		pGuiDisplay->SetImage(m_vImageInput[nIndex], FALSE);	
	}
	else
	{
		pGuiDisplay->SetImage(m_vImageInput[nIndex], TRUE);	
	}

	// 	// 记录所有图像数据
	// 	if (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImgData)
	// 	{	
	// 		CTime t = CTime::GetCurrentTime();	
	// 		m_vstrTemp.at(nIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d.bmp"), t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nIndex);
	// 
	// 		SYSTEMTIME sys;
	// 		GetLocalTime(&sys); 
	// 		m_vstrTemp.at(nIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%d.bmp"),	sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nIndex);
	// 
	// 		/*m_vDibTemp.at(nIndex).Init(m_vImageInput[nIndex]);
	// 		m_vDibTemp.at(nIndex).Write(m_pVisionASMConfig->m_DataRecord.m_strSaveAllImgDataAddr + _T("\\") + m_vstrTemp.at(nIndex));*/
	// 		SaveImage(nIndex,m_vImageInput[nIndex],m_pVisionASMConfig->m_DataRecord.m_strSaveAllImgDataAddr + _T("\\") + m_vstrTemp.at(nIndex));
	// 	}

	LeaveCriticalSection(&m_vcsResource.at(nIndex));

}
#ifdef READ_LOCAL_IMAGE
//自己添加的
BOOL vcBaseVisionAlign::SnapSearchImage(std::vector<int> vnPosIndex)
{
	
	int nPosIndex;
	CImageFormatTransfer tr;
	
	
	m_bStatusBar = FALSE;	


	for (int i = 0; i < vnPosIndex.size(); i++)
	{
		nPosIndex = vnPosIndex[i];
		cpImage cpimage1;
		cpImage cpimage2;
		CString filestr,errorStr;
		filestr.Format(_T("F:\\Image\\读取本地图片目录\\位置%d\\Snap.bmp"),nPosIndex+1);
		errorStr.Format(_T("位置%d"),nPosIndex+1);
		if(!tr.Read(filestr,cpimage1))
		{

			SetStatusBarInfo(m_bStatusBar,errorStr,_T("读取本地图片失败"));
			PostMessageUpdateStatusBarInfo();
			Sleep(1000);
			return FALSE;
		}
		if(!tr.Read(filestr,cpimage2))
		{
			SetStatusBarInfo(m_bStatusBar,errorStr,_T("读取本地图片失败"));
			PostMessageUpdateStatusBarInfo();
			Sleep(1000);
			return FALSE;
		}	
		m_vImageInput[nPosIndex]=cpimage1;               // 旋转镜像后的图像
		m_vImageSearch[nPosIndex]=cpimage2; ;              // 流程失败时，最近一次定位使用的图像数据（此时定位应该是成功的）


	}
	if (m_pSystempOptionConfig->m_nDisplayMode == 1)
	{
		for (int i = 0; i < vnPosIndex.size(); i++)
		{
			nPosIndex = vnPosIndex[i];
			if (m_vbSnapSearchImageEnd[nPosIndex] == TRUE)
			{
				PostMessageUpdateDisplayImage(nPosIndex);
			}
		}
	}
	m_bStatusBar = TRUE;	
	SetStatusBarInfo(m_bStatusBar,_T("从本地读取图片"),_T("读取成功"));
	PostMessageUpdateStatusBarInfo();
	return true;
}
#else
BOOL vcBaseVisionAlign::SnapSearchImage(std::vector<int> vnPosIndex)
{
	int i = 0;
	int nPosIndex;		
	int nPosNum = vnPosIndex.size();
	// 准备采集图像
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		m_vnSnapSearchImageStartIndex[nPosIndex] = 0;
		m_vbSnapSearchImageEnd[nPosIndex] = FALSE;
		m_phPosEvent[i] = m_vhSnapSearchImageEndEvent[nPosIndex];
		ResetEvent(m_phPosEvent[i]);
	}

	// 开始采集图像
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		m_vbSnapSearchImageStart[nPosIndex] = TRUE;
	}


	// 等待采集图像完成
	scTimer tmSnapTimer;
	tmSnapTimer.Reset();
	BOOL bTimeOut = FALSE;
	BOOL bFinished = FALSE;
	BOOL bAllCamOnline = TRUE;
	std::vector<BOOL> vbOnline(nPosNum, FALSE);
	while (!bFinished)
	{
		if (m_bStopNow)
		{
			return FALSE;
		}

		for (i=0; i<nPosNum; i++)
		{
			// 判断各相机是否在线，避免相机掉线后出现死循环
			nPosIndex = vnPosIndex[i];
			vbOnline.at(i) = IsPosCameraOnline(nPosIndex);
			bAllCamOnline = bAllCamOnline && vbOnline.at(i);
		}
		if (!bAllCamOnline)
		{
			break;
		}

		if (WaitForMultipleObjects(nPosNum, m_phPosEvent, TRUE, 100) != WAIT_TIMEOUT)
		{
			bFinished = TRUE;
			m_boIsSnapImgSucceed = TRUE;
			m_strSnapImgStatuString = _T("");
		}
		//SysPlatformInfo sysPlatformInfo;
		//GetSysPlatformInfo(sysPlatformInfo);
		float fTimeoutTime = 1000;//ms
#ifdef _DEBUG
fTimeoutTime = 5000; //debug模式下采集时间长一些
#endif
		// 在硬触发模式下，超时时间设置为30s
		if (m_pPlatformInfo->m_bCameraHardTriggerMode)
		{
			fTimeoutTime = 30*1000;
		}
		if (tmSnapTimer.GetTimeMilli(FALSE) > fTimeoutTime)
		{
			bTimeOut = TRUE;
			break;
		}

	}

	if (m_pSystempOptionConfig->m_nDisplayMode == 1)
	{
		for (i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			if (m_vbSnapSearchImageEnd[nPosIndex] == TRUE)
			{
				PostMessageUpdateDisplayImage(nPosIndex);
			}
		}
	}


	if (bTimeOut)
	{
		CString strInfo, strInfo1;
		for (i=0; i<nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			if (!m_vbSnapSearchImageEnd[nPosIndex])
			{
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_CPFAST_STR_POS), nPosIndex + 1);
				strInfo1 += strInfo;
			}
		}
		/*strInfo1 = strInfo1.Left(strInfo1.GetLength() - 2);*/
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_SSS_SSS), strInfo1, GetSysInfoString(m_psaSysInfoStrings,IDS_SB_LOST_CONNECTION));

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		m_boIsSnapImgSucceed = FALSE;					//  [5/8/2020 zzc]
		m_strSnapImgStatuString = m_strStatusBarInfo2;	//  [5/8/2020 zzc]


		return FALSE;
	}

	if (!bAllCamOnline)
	{		
		CString strInfo, strInfo1;
		for (i=0; i<nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			if (!vbOnline.at(i))
			{
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_CPFAST_STR_POS), nPosIndex);
				strInfo1 += strInfo;
			}
		}
		strInfo1 = strInfo1.Left(strInfo1.GetLength() - 2);
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_SSS_SSS), strInfo1, GetSysInfoString(m_psaSysInfoStrings,IDS_SB_LOST_CONNECTION));

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	return bFinished;
}
#endif // _DEBUG


BOOL vcBaseVisionAlign::IsSysMemoryUsedRateWarning()
{
	if (m_pSystemStatusInfo!=NULL)
	{
		return m_pSystemStatusInfo->IsSysMemoryUsedRateWarning();
	}
	return FALSE;
}
BOOL vcBaseVisionAlign::IsDiskUsedRateWarning(CString strDriveName)
{
	if (m_pSystemStatusInfo!=NULL)
	{
		return m_pSystemStatusInfo->IsDiskUsedRateWarning(strDriveName);
	}
	return FALSE;
}

BOOL vcBaseVisionAlign::ExecuteAlnCalibTargetAutoSearch(int nCalibPos)
{
	//if (FALSE == m_vImageInput[nCalibPos].IsValid())
	//{
	//	return FALSE;
	//}

	//m_vImageSearch[nCalibPos] = m_vImageInput[nCalibPos];
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);


	for (int i=0;i<2;i++)
	{
		for (int j=0;j<m_vmmCalibTargetType.at(i).size();j++)
		{
			m_vmmCalibTargetType.at(i).at(j)=pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode();
		}

	}
	if (FALSE == m_vImageSearch[nCalibPos].IsValid())
	{
		SetCalibrateTargetMarkGuiPos(nCalibPos);
		return FALSE;
	}


	if ((pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == FALSE))
	{

		if (m_nCalibTargetMovePosIndex < 0 || m_nCalibTargetMovePosIndex >= m_vpmpCalibMarkImagePos.size() )
		{
			SetCalibrateTargetMarkGuiPos(nCalibPos);
			return FALSE;
		}

		CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
		std::vector<CMarkImagePos*> vpMarkImagePos;
		if (m_nCalibTargetMovePosIndex < 0 || m_nCalibTargetMovePosIndex > 1)
		{
			SetCalibrateTargetMarkGuiPos(nCalibPos);
			return FALSE;
		}
		CMarkImagePos* pMarkImagePos = m_vpmpCalibMarkImagePos.at(m_nCalibTargetMovePosIndex);

		if (pMarkImagePos == NULL)
		{
			SetCalibrateTargetMarkGuiPos(nCalibPos);
			return FALSE;
		}
		CCoordPos pos;
		pMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, pos);
		if (0 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{
			// 目标定位工具是否正常 
			if (m_bValidTargetSearchTool!=TRUE)
			{
				SetCalibrateTargetMarkGuiPos(nCalibPos);
				return FALSE;
			}

			// 用目标模板执行标定搜索
			CCoordPos cp;
			BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 0);
			if(bSearchSucceed)
			{			
				m_vbSearchSucceed[nCalibPos] = TRUE;
				m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,0);

				cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
				cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
				cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
				pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
				m_vmmPreCalibTargetType.at(m_nCalibTargetMovePosIndex).at(nCalibPos) = eSinglePatternSingleMark;
			}
			else
			{
				////////////////////////////////////////////////////
				if (TRUE == ExcuteManualSearch(2,nCalibPos,m_nCalibTargetMovePosIndex))
				{
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vmmPreCalibTargetType.at(m_nCalibTargetMovePosIndex).at(nCalibPos) = eSinglePatternSingleMark;
				}
				else
				{
					////////////////////////////////////////////////////
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					SetCalibrateTargetMarkGuiPos(nCalibPos);
					return FALSE;
				}

			}

		}	
		else if (1 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{
			// 对象定位工具是否正常 
			if (m_bValidObjectSearchTool!=TRUE)
			{
				SetCalibrateTargetMarkGuiPos(nCalibPos);
				return FALSE;
			}

			// 用对象模板执行标定搜索
			CCoordPos cp;
			BOOL bSearchSucceed = ExecuteAlnObjectSearch(nCalibPos, 0);
			if(bSearchSucceed)
			{			
				m_vbSearchSucceed[nCalibPos] = TRUE;
				m_vSeachResults[nCalibPos] = GetAlnObjectSearchResult(nCalibPos,0);

				cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
				cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
				cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
				pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
				m_vmmPreCalibTargetType.at(m_nCalibTargetMovePosIndex).at(nCalibPos) = eSinglePatternSingleMark;
			}
			else
			{
				////////////////////////////////////////////////////
				if (TRUE == ExcuteManualSearch(2,nCalibPos,m_nCalibTargetMovePosIndex))
				{
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vmmPreCalibTargetType.at(m_nCalibTargetMovePosIndex).at(nCalibPos) = eSinglePatternSingleMark;
				}
				else
				{
					////////////////////////////////////////////////////
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					SetCalibrateTargetMarkGuiPos(nCalibPos);
					return FALSE;
				}

			}
		}
		else if (2 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{
			// 标定定位工具是否正常 
			if (m_bValidCalibSearchTool!=TRUE)
			{
				SetCalibrateTargetMarkGuiPos(nCalibPos);
				return FALSE;
			}

			// 用目标模板执行标定搜索
			CCoordPos cp;
			BOOL bSearchSucceed = ExecuteCalibTargetSearch(nCalibPos, 0);
			if(bSearchSucceed)
			{			
				m_vbSearchSucceed[nCalibPos] = TRUE;
				m_vSeachResults[nCalibPos] = GetCalibSearchResult(nCalibPos,0);

				cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
				cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
				cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
				pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
				m_vmmPreCalibTargetType.at(m_nCalibTargetMovePosIndex).at(nCalibPos) = eSinglePatternSingleMark;
			}
			else
			{
				////////////////////////////////////////////////////
				if (TRUE == ExcuteManualSearch(2,nCalibPos,m_nCalibTargetMovePosIndex))
				{
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vmmPreCalibTargetType.at(m_nCalibTargetMovePosIndex).at(nCalibPos) = eSinglePatternSingleMark;
				}
				else
				{
					////////////////////////////////////////////////////
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					SetCalibrateTargetMarkGuiPos(nCalibPos);
					return FALSE;
				}

			}

		}
	}
	else if(eSinglePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
	{

		if (m_nCalibTargetMovePosIndex < 0 || m_nCalibTargetMovePosIndex >= m_vpmpCalibMarkImagePos.size() )
		{
			SetCalibrateTargetMarkGuiPos(nCalibPos);
			return FALSE;
		}

		CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
		std::vector<CMarkImagePos*> vpMarkImagePos;
		CMarkImagePos* pMarkImagePos = m_vpmpCalibMarkImagePos.at(m_nCalibTargetMovePosIndex);

		if (pMarkImagePos == NULL)
		{
			SetCalibrateTargetMarkGuiPos(nCalibPos);
			return FALSE;
		}
		CCoordPos pos;
		pMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, pos);

		{
			// 用第0组关联标定模板执行标定搜索
			CCoordPos cp;
			BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
			if(bSearchSucceed)
			{			
				m_vbSearchSucceed[nCalibPos] = TRUE;
				m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);

				cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
				cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
				cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
				pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
				m_vmmPreCalibTargetType.at(m_nCalibTargetMovePosIndex).at(nCalibPos) = eSinglePatternSingleMark;

			}
			else
			{
				////////////////////////////////////////////////////
				if (TRUE == ExcuteManualSearch(2,nCalibPos,m_nCalibTargetMovePosIndex))
				{
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vmmPreCalibTargetType.at(m_nCalibTargetMovePosIndex).at(nCalibPos) = eSinglePatternSingleMark;
				}
				else
				{
					////////////////////////////////////////////////////
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					SetCalibrateTargetMarkGuiPos(nCalibPos);
					return FALSE;
				}

			}

		}

	}
	else
	{
		for (int nMoveIndex=0;nMoveIndex<2;nMoveIndex++)
		{
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			std::vector<CMarkImagePos*> vpMarkImagePos;
			CMarkImagePos* pMarkImagePos = m_vpmpCalibMarkImagePos.at(nMoveIndex);
			if (pMarkImagePos == NULL)
			{
				return FALSE;
			}
			CCoordPos pos;
			pMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, pos);


			if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE)
			{
				// 标定用定位工具是否正常 
				if (m_bValidCalibTargetSearchTool!=TRUE)
				{
					return FALSE;
				}

				// 用关联标定模板执行标定搜索

				if (eDoublePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
				{
					// 用第0、1组关联标定模板执行标定搜索
					CCoordPos cp;
					BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, nMoveIndex);

					if(bSearchSucceed)
					{			
						m_vbSearchSucceed[nCalibPos] = TRUE;
						m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,nMoveIndex);

						cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
						cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
						cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
						pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
						m_vmmPreCalibTargetType.at(nMoveIndex).at(nCalibPos) = eDoublePatternSingleMark;
					}
					else
					{
						////////////////////////////////////////////////////
						if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
						{
							m_vbSearchSucceed[nCalibPos] = TRUE;
							m_vmmPreCalibTargetType.at(nMoveIndex).at(nCalibPos) = eDoublePatternSingleMark;

						}
						else
						{
							////////////////////////////////////////////////////
							cp.m_dPosX  = 0;
							cp.m_dPosY  = 0;
							cp.m_dAngle = 0;
							m_vbSearchSucceed[nCalibPos] =FALSE;
							pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
							return FALSE;
						}

					}
				}
				else if (eSinglePatternMultiMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
				{

					{
						// 用第0组关联标定模板执行标定搜索，单模板双标记点
						CCoordPos cp;
						BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);

						if(bSearchSucceed)
						{			
							m_vbSearchSucceed[nCalibPos] = TRUE;
							m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);

							int nTempMoveIndex = 0;
							CMarkImagePos* pTempMarkImagePos = NULL;
							CCoordPos posTemp;

							// 移动位置0或标记点0
							nTempMoveIndex = 0;
							pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
							if (pTempMarkImagePos == NULL)
							{
								return FALSE;
							}					
							pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
							cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
							cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
							cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
							pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
							if (nMoveIndex == nTempMoveIndex)
							{
								pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
							}

							// 移动位置1或标记点1
							nTempMoveIndex = 1;
							pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
							if (pTempMarkImagePos == NULL)
							{
								return FALSE;
							}					
							pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
							cp.m_dPosX  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(0);
							cp.m_dPosY  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(0);
							cp.m_dAngle = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(0);
							pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
							if (nMoveIndex == nTempMoveIndex)
							{
								pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
							}
							m_vmmPreCalibTargetType.at(nMoveIndex).at(nCalibPos) = eSinglePatternMultiMark;
						}
						else
						{
							////////////////////////////////////////////////////
							if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
							{
								m_vbSearchSucceed[nCalibPos] = TRUE;
								m_vmmPreCalibTargetType.at(nMoveIndex).at(nCalibPos) = eSinglePatternMultiMark;

							}
							else
							{
								////////////////////////////////////////////////////
								cp.m_dPosX  = 0;
								cp.m_dPosY  = 0;
								cp.m_dAngle = 0;
								m_vbSearchSucceed[nCalibPos] =FALSE;
								pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
								return FALSE;
							}

						}
					}

				}
				else if (eSinglePatternGuanlian4Point == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
				{
					// 用第0组关联标定模板执行标定搜索，单模板双标记点
					CCoordPos cp;
					BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);

					if(bSearchSucceed)
					{			
						m_vbSearchSucceed[nCalibPos] = TRUE;
						m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);

						int nTempMoveIndex = 0;
						CMarkImagePos* pTempMarkImagePos = NULL;
						CCoordPos posTemp;

						if (nMoveIndex == 0)
						{
							cp.m_vdAuxiliaryPosX.at(0)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(0);
							cp.m_vdAuxiliaryPosY.at(0)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(0);
							cp.m_vdAuxiliaryAngle.at(0) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(0);

							cp.m_vdAuxiliaryPosX.at(1)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(1);
							cp.m_vdAuxiliaryPosY.at(1)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(1);
							cp.m_vdAuxiliaryAngle.at(1) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(1);
						}
						else
						{
							cp.m_vdAuxiliaryPosX.at(2)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(2);
							cp.m_vdAuxiliaryPosY.at(2)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(2);
							cp.m_vdAuxiliaryAngle.at(2) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(2);

							cp.m_vdAuxiliaryPosX.at(3)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(3);
							cp.m_vdAuxiliaryPosY.at(3)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(3);
							cp.m_vdAuxiliaryAngle.at(3) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(3);
						}
						cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
						cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
						cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;

						{
							pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
						}
						m_vmmPreCalibTargetType.at(nMoveIndex).at(nCalibPos) = eSinglePatternGuanlian4Point;
					}
					else
					{
						////////////////////////////////////////////////////
						//if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex,2))
						//{
						//	m_vbSearchSucceed[nCalibPos] = TRUE;
						//	m_vmmPreCalibTargetType.at(nMoveIndex).at(nCalibPos) = eSinglePatternGuanlian4Point;

						//}
						//else
						//{
						////////////////////////////////////////////////////
						cp.m_dPosX  = 0;
						cp.m_dPosY  = 0;
						cp.m_dAngle = 0;
						m_vbSearchSucceed[nCalibPos] =FALSE;
						pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
						return FALSE;
						/*}*/

					}
				}
			}   	
		}
	}

	SetCalibrateTargetMarkGuiPos(nCalibPos);
	return TRUE;

}

void vcBaseVisionAlign::SetCalibrateTargetMarkGuiPos(int nCalibPos)
{
	if (GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point)
	{

		scDegree tempDegree[2]={scDegree(45),scDegree(0)};
		COLORREF lineColor[2]={RGB(255,0,0),RGB(0,0,255)};
		for (int nMovePosIndex = 0;nMovePosIndex<2;nMovePosIndex++)
		{						
			if (nMovePosIndex < m_vpmpCalibMarkImagePos.size()
				&& TRUE == m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetIsMarkImagePosOK(nCalibPos)
				&& m_vmmCalibTargetType.at(nMovePosIndex).at(nCalibPos) == m_vmmPreCalibTargetType.at(nMovePosIndex).at(nCalibPos))
			{
				CCoordPos pos;
				pos =  m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetMarkImagePos(nCalibPos);
				CGuiGraphics* tempCalibrateGraphics = m_vpGuiCalibrateGraphics.at(nCalibPos);

				if(nMovePosIndex == 0)
				{
					tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetCenterRotationLengths(
						sc2Vector(pos.GetAuxiliaryPosX(0),pos.GetAuxiliaryPosY(0)),tempDegree[nMovePosIndex],100,100);

					tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex+2)->SetCenterRotationLengths(
						sc2Vector(pos.GetAuxiliaryPosX(1),pos.GetAuxiliaryPosY(1)),tempDegree[nMovePosIndex],100,100);
				}
				else if(nMovePosIndex == 1)
				{
					tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetCenterRotationLengths(
						sc2Vector(pos.GetAuxiliaryPosX(2),pos.GetAuxiliaryPosY(2)),tempDegree[nMovePosIndex],100,100);

					tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex+2)->SetCenterRotationLengths(
						sc2Vector(pos.GetAuxiliaryPosX(3),pos.GetAuxiliaryPosY(3)),tempDegree[nMovePosIndex],100,100);
				}

				tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetLineWidth(2);
				tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetLineColor(lineColor[nMovePosIndex]);
				tempCalibrateGraphics->m_vbShowObjectCoordCross.at(nMovePosIndex) = TRUE;

				tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex+2)->SetLineWidth(2);
				tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex+2)->SetLineColor(lineColor[nMovePosIndex]);
				tempCalibrateGraphics->m_vbShowObjectCoordCross.at(nMovePosIndex+2) = TRUE;
			}
			//	else
			//	{
			//		return FALSE;
			//	}
		}
		PostMessageUpdateGuiCalibrateTargetGraphics(nCalibPos,TRUE);
		//return TRUE;
	}
	else
	{

		scDegree tempDegree[2]={scDegree(45),scDegree(0)};
		COLORREF lineColor[2]={RGB(255,0,0),RGB(0,0,255)};
		for (int nMovePosIndex = 0;nMovePosIndex<2;nMovePosIndex++)
		{				
			if (nMovePosIndex < m_vpmpCalibMarkImagePos.size()
				&& TRUE == m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetIsMarkImagePosOK(nCalibPos)
				&& m_vmmCalibTargetType.at(nMovePosIndex).at(nCalibPos) == m_vmmPreCalibTargetType.at(nMovePosIndex).at(nCalibPos))
			{
				CCoordPos pos;
				pos =  m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetMarkImagePos(nCalibPos);
				CGuiGraphics* tempCalibrateGraphics = m_vpGuiCalibrateGraphics.at(nCalibPos);
				tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetCenterRotationLengths(
					sc2Vector(pos.GetPosX(),pos.GetPosY()),tempDegree[nMovePosIndex],100,100);
				tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetLineWidth(2);
				tempCalibrateGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetLineColor(lineColor[nMovePosIndex]);
				tempCalibrateGraphics->m_vbShowObjectCoordCross.at(nMovePosIndex) = TRUE;
			}
			//	else
			//	{
			//		return FALSE;
			//	}
		}
		PostMessageUpdateGuiCalibrateTargetGraphics(nCalibPos,TRUE);
		//return TRUE;
	}
}
BOOL vcBaseVisionAlign::ExecuteAlnCalibTargetDmCodeSearch(int nIndex)
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}	

	if (nIndex<0 || nIndex>=m_vDmCodeCalibTool.size() || nIndex>=m_vImageSearch.size())
	{
		return FALSE;
	}

	//if (FALSE == m_vImageInput[nIndex].IsValid())
	//{
	//	return FALSE;
	//}

	//m_vImageSearch[nIndex] = m_vImageInput[nIndex];
	if (FALSE == m_vImageSearch[nIndex].IsValid())
	{
		return FALSE;
	}
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{		
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
		return FALSE;
	}
	scDMCodeParam DmCodeParam;
	DmCodeParam = pCurProductData->m_vDMcodeCalib.at(nIndex);
	m_vDmCodeCalibTool.at(nIndex).SetDmCodeParam(DmCodeParam);
	m_vDmCodeCalibTool.at(nIndex).SetSearchImage(m_vImageSearch[nIndex]);
	if (!m_vDmCodeCalibTool.at(nIndex).SearchDmCode())
	{
		return FALSE;
	}
	PostMessageUpdateGuiCalibrateTargetGraphics(nIndex,TRUE);
	return TRUE;
}

void vcBaseVisionAlign::UnInitAlignTool()
{
	if (m_pAlignerTool!=NULL)
	{
		delete m_pAlignerTool;
		m_pAlignerTool = NULL;
	}
}

BOOL vcBaseVisionAlign::InitAlignTool(int nProductIndex)
{
	return FALSE;
}

void vcBaseVisionAlign::UnInitAlignTool(int nProductIndex)
{
	if (m_pAlignerTool!=NULL)
	{
		delete m_pAlignerTool;
		m_pAlignerTool = NULL;
	}
}				

// 设置标定时平台基准位置
void vcBaseVisionAlign::SetCalibPlatformPos( CPlatformAxisPos* pPlatformAxisPos/*, int nIndex, BOOL bTarCamWithDiffObjCam*/)
{
	if ((NULL == pPlatformAxisPos) || (NULL == m_pAlignerTool))
	{
		return;
	}

	m_pAlignerTool->SetCalibPlatformPos(pPlatformAxisPos/*, nIndex, bTarCamWithDiffObjCam*/);
}

// 获取平移标定和旋转标定时平台各轴的移动位置
std::vector<CPlatformAxisPos*> vcBaseVisionAlign::GetCalibPlatformAxisMovePos(int nMarkType)
{      
	if (NULL == m_pAlignerTool)
	{
		std::vector<CPlatformAxisPos*> vpPos;
		return vpPos;
	}

	return m_pAlignerTool->GetCalibPlatformMovePos(nMarkType);	
}

// 获取平移标定和旋转标定时平台各轴的移动位置
std::vector<CPlatformAxisPos*> vcBaseVisionAlign::GetCalibPlatformAxisMovePos(int nPosIndex,int nMarkType)
{      
	if (NULL == m_pAlignerTool)
	{
		std::vector<CPlatformAxisPos*> vpPos;
		return vpPos;
	}

	//return m_pAlignerTool->GetCalibPlatformMovePos(nPosIndex,nMarkType);
	if (m_pPlatformInfo->m_bPlatformPick && m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformShareXY)
	{
		// 修复ePickCamPlatformShareXY 拾取应用标定D轴时错误
		if (nMarkType==0)
		{
			return m_pAlignerTool->GetCalibPlatformPickMovePos(nPosIndex);
		}
		else if (nMarkType==1)
		{
			return m_pAlignerTool->GetCalibCenterPlatformPickMovePos(nPosIndex);
		}
		else
		{
			std::vector<CPlatformAxisPos*> vpPos;
			return vpPos;
		}

	}
	else
	{
		return m_pAlignerTool->GetCalibPlatformMovePos(nPosIndex,nMarkType);
	}
}

// 获取平移标定和旋转标定时平台各轴的移动位置
std::vector<CPlatformAxisPos*> vcBaseVisionAlign::GetCalibCenterPlatformAxisMovePos(int nPosIndex)
{      
	if (NULL == m_pAlignerTool)
	{
		std::vector<CPlatformAxisPos*> vpPos;
		return vpPos;
	}

	if (m_pPlatformInfo->m_bPlatformPick)
	{
		return m_pAlignerTool->GetCalibCenterPlatformPickMovePos(nPosIndex);
	}
	else
	{
		return m_pAlignerTool->GetCalibPlatformMovePos(nPosIndex);	
	}

}

// 执行标定（计算）
BOOL vcBaseVisionAlign::ExecuteCalibrate( std::vector<CMarkImagePos*> pMarkImagePos )
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	for (int i=0;i<CALIBPOS;i++)
	{
		m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,i);//所有标定位置都设置标定图像坐标，因为所有位置都标定计算，？？？是否有问题
	}


	if (FALSE == m_pAlignerTool->ExecuteCalibrate())
	{
		return FALSE;
	}

	return TRUE;
}

BOOL vcBaseVisionAlign::ExecuteCalibrateTarget(int nExProductIndex/*=0*/)
{
	SysPlatformInfo platformInfo;
	GetSysPlatformInfo(platformInfo);

	// 扩展序号超过扩展数量
	if((m_pPlatformInfo->m_bEnableMultiCalibExtension && nExProductIndex >m_pPlatformInfo->m_nMultiCalibExtensionMaxNum) || (!m_pPlatformInfo->m_bEnableMultiCalibExtension) && nExProductIndex!=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE);// .Format(_T("标定失败"));
		m_strStatusBarInfo2 = _T("扩展序号超过扩展数目");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
		return FALSE;
	}

	std::vector<BOOL> bCalibSucceed;
	bCalibSucceed.resize(GetPosNum()/2,FALSE);

	if (GetCalibTargetMarkPatternMode() == eDmCodeCalib)
	{
		for (int i=0;i<m_vDmCodeCalibTool.size();i++)
		{
			if (FALSE == m_vDmCodeCalibTool.at(i).IsSearchValid())
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE);// .Format(_T("标定失败"));
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_OBJECT_AND_TARGET_POS);//.Format(_T("请获取对象、目标位置！"));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
				return FALSE;
			}
		}

		if(!m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib)
		{
			if(!m_bGetAutoCalibrateBaseAxisSucceed)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE);// .Format(_T("标定失败"));
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_AXIS_POS);//.Format(_T("请获取平台轴位置！"));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

		}

		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Empty();
			m_strStatusBarInfo2.Empty();

			CString strTempInfo1;
			CString strTempInfo2;
			int nPosIndex = 0;
			for(nPosIndex = 0; nPosIndex < GetPosNum()/2; nPosIndex++)
			{
				BOOL bOK = FALSE;
				if (platformInfo.m_eMidPlatformType == ePlatformXYPD)
				{
					bOK = ExecuteCalibrateDmCode(nPosIndex+nExProductIndex*GetPosNum(),nPosIndex + GetPosNum()/2+nExProductIndex*GetPosNum());
				}
				else
				{
					bOK = ExecuteCalibrateDmCode(nPosIndex + GetPosNum()/2+nExProductIndex*GetPosNum(),nPosIndex+nExProductIndex*GetPosNum());
				}
				if(bOK)
				{
					bCalibSucceed.at(nPosIndex) = TRUE;

				}
				else
				{
					bCalibSucceed.at(nPosIndex) = FALSE;
				}
			}

			m_bStatusBar = bCalibSucceed.at(0);
			for(nPosIndex = 0; nPosIndex < GetPosNum()/2; nPosIndex++)
			{
				m_bStatusBar = m_bStatusBar && bCalibSucceed.at(nPosIndex);
				if (TRUE == bCalibSucceed.at(nPosIndex))
				{
					strTempInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_POS_CALI_SUCCESS)/*_T("目标位置%d标定成功！")*/, nPosIndex + 1 + GetPosNum()/2);
				}
				else
				{
					strTempInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_POS_CALI_FAILE)/*_T("目标位置%d标定失败！")*/, nPosIndex + 1 + GetPosNum()/2);
				}
				m_strStatusBarInfo2 += strTempInfo2;
			}

			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_SUCCESS)/*_T("标定成功")*/;
				//m_bAutoCalibrateSucceed = TRUE;
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
				//m_bGetAutoCalibrateBaseAxisSucceed = FALSE;
			}
			else
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE);// .Format(_T("标定失败"));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
				return FALSE;
			}	
		}

		//return m_bStatusBar;
	}
	else
	{
		if (m_vpmpCalibMarkImagePos.size() < 2)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE);// .Format(_T("标定失败"));
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_OBJECT_AND_TARGET_POS);//.Format(_T("请获取对象、目标位置！"));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		int nPosIndex = 0;
		int nMovePosIndex = 0;
		for (nMovePosIndex = 0; nMovePosIndex < m_vpmpCalibMarkImagePos.size(); nMovePosIndex++)
		{
			for (nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
			{
				if (FALSE == m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetIsMarkImagePosOK(nPosIndex))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE);// .Format(_T("标定失败"));
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_OBJECT_AND_TARGET_POS);//.Format(_T("请获取对象、目标位置！"));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
			}	
		}

		if(!m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib)
		{
			if(!m_bGetAutoCalibrateBaseAxisSucceed)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE);// .Format(_T("标定失败"));
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_AXIS_POS);//.Format(_T("请获取平台轴位置！"));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

		}

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Empty();
		m_strStatusBarInfo2.Empty();

		CString strTempInfo1;
		CString strTempInfo2;
		//int nPosIndex = 0;
		for(nPosIndex = 0; nPosIndex < GetPosNum()/2; nPosIndex++)
		{
			BOOL bOK = FALSE;
			if (platformInfo.m_eMidPlatformType == ePlatformXYPD)
			{
				bOK = ExecuteCalibrateFCBS(m_vpmpCalibMarkImagePos, nPosIndex+nExProductIndex*GetPosNum() ,2);
			}
			else
			{
				bOK = ExecuteCalibrate(m_vpmpCalibMarkImagePos, nPosIndex + GetPosNum()/2+nExProductIndex*GetPosNum());
			}
			if (bOK)
			{
				bCalibSucceed.at(nPosIndex) = TRUE;
			}
			else
			{
				bCalibSucceed.at(nPosIndex) = FALSE;
			}
		}

		m_bStatusBar = bCalibSucceed.at(0);
		for(nPosIndex = 0; nPosIndex < GetPosNum()/2; nPosIndex++)
		{
			m_bStatusBar = m_bStatusBar && bCalibSucceed.at(nPosIndex);
			if (TRUE == bCalibSucceed.at(nPosIndex))
			{
				strTempInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_POS_CALI_SUCCESS)/*_T("目标位置%d标定成功！")*/, nPosIndex + 1 + GetPosNum()/2);
			}
			else
			{
				strTempInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_POS_CALI_FAILE)/*_T("目标位置%d标定失败！")*/, nPosIndex + 1 + GetPosNum()/2);
			}
			m_strStatusBarInfo2 += strTempInfo2;
		}

		if (m_bStatusBar)
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_SUCCESS)/*_T("标定成功")*/;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
			//for (nMovePosIndex = 0; nMovePosIndex < m_vpmpCalibMarkImagePos.size(); nMovePosIndex++)
			//{
			//	for (nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
			//	{
			//		 m_vpmpCalibMarkImagePos.at(nMovePosIndex)->m_vbOK.at(nPosIndex) = FALSE;
			//	}	
			//}
			//m_bGetAutoCalibrateBaseAxisSucceed = FALSE;
		}
		else
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE);// .Format(_T("标定失败"));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
			return FALSE;
		}

		//return m_bStatusBar;
	}
	if (m_bStatusBar)
	{

		// 获取系统标定后的所有信息
		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
		vpAllCalibratedInfo = GetAllCalibratedInfo();	

		/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
		SetCurCalibratedInfo(vpAllCalibratedInfo);	

		// 保存标定后信息到当前产品中及配置文件中
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_SUCCESS));
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SAVE_SUCCESS);//.Format(_T("保存成功"));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

	}
	else
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_CALIBRATE_FAILE)); 
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SAVE_FAILE);//.Format(_T("保存失败"));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
	}
	return m_bStatusBar;

}

BOOL vcBaseVisionAlign::ExecuteCalibrateDmCodeBoard(int nCalibPos,std::vector<sc2Vector> &vImagePos,std::vector<sc2Vector> &vBoardPos,int nMarkType)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	if (FALSE == m_pAlignerTool->ExecuteCalibrateDmCodeBoard(nCalibPos,vImagePos,vBoardPos,nMarkType))
	{
		return FALSE;
	}
	return TRUE;
}

// 执行标定（计算）
BOOL vcBaseVisionAlign::ExecuteCalibrateDmCode(int nCalibPos,int nBasePos)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}
	int nRemCalibPos =nCalibPos%GetPosNum();
	int nRemBasePos = nBasePos%GetPosNum();
	CString strOutLog;
	strOutLog.Format(_T("位置%d二维码码关联开始-----------------------------"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

	if (!m_vDmCodeCalibTool.at(nRemCalibPos).RelatedTo(m_vDmCodeCalibTool.at(nRemBasePos)))
	{
		strOutLog.Format(_T("获取角点交集失败"));
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

		strOutLog.Format(_T("位置%d二维码码关联结束-----------------------------"),nCalibPos);
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOutLog);
		return FALSE;
	}

	strOutLog.Format(_T("获取角点交集成功"));
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

	CString strTmp;
	strOutLog = _T("角点交集图像坐标:");
	for (int i=0;i<m_vDmCodeCalibTool.at(nRemCalibPos).m_vImgDecodecornersResult.size();i++)
	{
		strTmp.Format(_T(" %.3f,%.3f"),m_vDmCodeCalibTool.at(nRemCalibPos).m_vImgDecodecornersResult.at(i).GetX(),m_vDmCodeCalibTool.at(nRemCalibPos).m_vImgDecodecornersResult.at(i).GetY());
		strOutLog = strOutLog + strTmp;
	}

	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

	PostMessageUpdateGuiCalibrateTargetGraphics(nRemCalibPos,TRUE);
	PostMessageUpdateGuiCalibrateTargetGraphics(nRemBasePos,TRUE);

	strOutLog.Format(_T("显示角点交集成功"));
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);
	////GYM-关联日志存储-记录二维码关联交集坐标
	CString strCorrelationLogPath;
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	//strCorrelationLogPath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
	//	m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex()+1);
	vcBaseAlignTool* tmpAlignTool = GetAlignTool();
	CString StrTmp = _T("");
	if (tmpAlignTool !=NULL)
	{

		if (sysPlatformInfo.m_bProductFaChd)
		{
			int nCurProductIndexFa;
			int nCurProductIndexCh;
			m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
			StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
				nCurProductIndexFa+1,nCurProductIndexCh+1);
		}
		else
		{
			StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
				m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
		}

	}

	strCorrelationLogPath = StrTmp;

	CString strInfo;
	CString strTemp;
	strInfo.Empty();
	strTemp.Format(_T("......位置%d 和 位置%d 共计%d个交集角点;\n"),nRemBasePos+1,nRemCalibPos+1,m_vDmCodeCalibTool.at(/*nCalibPos*/nRemCalibPos).m_vImgDecodecornersResult.size());
	strInfo += strTemp;

	strTemp.Format(_T("......位置%d在拍照位的图像定位坐标:\n"),nRemBasePos+1);
	strInfo += strTemp;
	for (int j = 0;j < m_vDmCodeCalibTool.at(/*nCalibPos*/nRemCalibPos).m_vImgDecodecornersResult.size();j++)
	{
		strTemp.Format(_T("Mark%d : X: %.2f; Y: %.2f;"),j,m_vDmCodeCalibTool.at(nRemBasePos).m_vImgDecodecornersResult[j].GetX(),m_vDmCodeCalibTool.at(nRemBasePos).m_vImgDecodecornersResult[j].GetY());
		strInfo += strTemp;
	}
	strTemp.Format(_T("\n"));
	strInfo += strTemp;
	strTemp.Format(_T("......位置%d在拍照位的图像定位坐标:\n"),nRemCalibPos+1);
	strInfo += strTemp;
	for (int j = 0;j < m_vDmCodeCalibTool.at(/*nCalibPos*/nRemCalibPos).m_vImgDecodecornersResult.size();j++)
	{
		strTemp.Format(_T("Mark%d : X: %.2f; Y: %.2f;"),j,m_vDmCodeCalibTool.at(nRemCalibPos).m_vImgDecodecornersResult[j].GetX(),m_vDmCodeCalibTool.at(nRemCalibPos).m_vImgDecodecornersResult[j].GetY());
		strInfo += strTemp;
	}
	// 	strTemp.Format(_T("\n"));
	// 	strInfo += strTemp;

	VisionAlignLogRecord(strCorrelationLogPath,strInfo,FALSE);
	///GYM

	if (FALSE == m_pAlignerTool->ExecuteCalibrateDmCode(nCalibPos,
		m_vDmCodeCalibTool.at(nRemCalibPos).m_vImgDecodecornersResult,
		m_vDmCodeCalibTool.at(nRemBasePos).m_vImgDecodecornersResult))
	{
		strOutLog.Format(_T("执行关联失败"));
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

		strOutLog.Format(_T("位置%d二维码码关联结束-----------------------------"),nCalibPos);
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOutLog);
		return FALSE;
	}
	//m_vDmCodeCalibTool.at(nCalibPos).SetSearchValid(FALSE);
	//m_vDmCodeCalibTool.at(nBasePos).SetSearchValid(FALSE);

	strOutLog.Format(_T("执行关联成功"));
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

	strOutLog.Format(_T("位置%d二维码码关联结束-----------------------------"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

	return TRUE;
}
BOOL vcBaseVisionAlign::ExecuteCalibrateDmCode(int nCalibPos,int nBasePos,std::vector<sc2Vector>& vCalibImagePos,std::vector<sc2Vector>& vBaseImagePos)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	CString strOutLog;
	strOutLog.Format(_T("位置%d二维码码关联开始-----------------------------"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

	CString strTmp;
	strOutLog = _T("角点图像坐标:");
	for (int i=0;i<vCalibImagePos.size();i++)
	{
		strTmp.Format(_T(" %.3f,%.3f"),vCalibImagePos.at(i).GetX(),vCalibImagePos.at(i).GetY());
		strOutLog = strOutLog + strTmp;
	}
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);


	strOutLog = _T("基准角点图像坐标:");
	for (int i=0;i<vBaseImagePos.size();i++)
	{
		strTmp.Format(_T(" %.3f,%.3f"),vBaseImagePos.at(i).GetX(),vBaseImagePos.at(i).GetY());
		strOutLog = strOutLog + strTmp;
	}
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);


	if (FALSE == m_pAlignerTool->ExecuteCalibrateDmCode(nCalibPos,
		vCalibImagePos,
		vBaseImagePos))
	{
		strOutLog.Format(_T("执行关联失败"));
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

		strOutLog.Format(_T("位置%d二维码码关联结束-----------------------------"),nCalibPos);
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOutLog);
		return FALSE;
	}
	//m_vDmCodeCalibTool.at(nCalibPos).SetSearchValid(FALSE);
	//m_vDmCodeCalibTool.at(nBasePos).SetSearchValid(FALSE);

	strOutLog.Format(_T("执行关联成功"));
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

	strOutLog.Format(_T("位置%d二维码码关联结束-----------------------------"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strOutLog);

	return TRUE;
}
BOOL vcBaseVisionAlign::ExecuteCalibrate( std::vector<CMarkImagePos*> pMarkImagePos,int nCalibPos )
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nCalibPos%GetPosNum());

	if (FALSE == m_pAlignerTool->ExecuteCalibrate(nCalibPos))
	{
		return FALSE;
	}

	return TRUE;
}

//XYPD平台执行全局二维码靶标标定时,建立靶标坐标与平台坐标之间的关系
BOOL vcBaseVisionAlign::ExecuteCalibrateWholeDmcodeBoardBoardToPlatFCBS(std::vector<CMarkImagePos*> pMarkImagePos,int nCalibPos, int nMarkType)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	if (ePlatformXYPD != sysPlatformInfo.m_eMidPlatformType)
	{
		return FALSE;

	}

	CString strInfo;
	strInfo.Format(_T("Pos%d执行全局二维码靶标靶标到平台坐标映射开始-----------------------------"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strInfo);

	int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;
	if (nMarkType==0 || nMarkType==1)
	{

		m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nMarkType,nRemCalibPos);			

	}
	else
	{
		if (pMarkImagePos.size()>0)
		{
			m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nRemCalibPos);
		}
	}
	SaveCalibMoveImagePosInfo();

	if (FALSE == m_pAlignerTool->ExecuteCalibrateWholeDmCodeBoardBoardToPlat(nCalibPos, nMarkType))
	{
		strInfo.Format(_T("执行全局二维码靶标靶标到平台坐标映射失败"),nCalibPos);
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		return FALSE;
	}
	strInfo.Format(_T("执行全局二维码靶标靶标到平台坐标映射成功"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strInfo);

	strInfo.Format(_T("Pos%d执行全局二维码靶标靶标到平台坐标映射结束-----------------------------"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strInfo);

	return TRUE;
}

// 执行全局二维码靶标标定时建立靶标坐标与平台坐标之间的关系
BOOL vcBaseVisionAlign::ExecuteCalibrateWholeDmcodeBoardBoardToPlat(std::vector<CMarkImagePos*> pMarkImagePos,int nCalibPos, int nMarkType)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}
	CString strInfo;
	strInfo.Format(_T("Pos%d执行全局二维码靶标靶标到平台坐标映射开始-----------------------------"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strInfo);

	int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;
	if (m_pPlatformInfo->m_bPlatformPick && m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformShareXY)
	{
		m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nMarkType,nRemCalibPos);	
	}
	else
	{
		m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nRemCalibPos);
	}


	if (FALSE == m_pAlignerTool->ExecuteCalibrateWholeDmCodeBoardBoardToPlat(nCalibPos, nMarkType))
	{
		strInfo.Format(_T("执行全局二维码靶标靶标到平台坐标映射失败"),nCalibPos);
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		return FALSE;
	}
	strInfo.Format(_T("执行全局二维码靶标靶标到平台坐标映射成功"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strInfo);

	strInfo.Format(_T("Pos%d执行全局二维码靶标靶标到平台坐标映射结束-----------------------------"),nCalibPos);
	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strAlignProcessData, strInfo);

	return TRUE;
}

BOOL vcBaseVisionAlign::ExecuteCalibrate(std::vector<CMarkImagePos*> pMarkImagePos,int nCalibPos, int nMarkType)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;

	m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nRemCalibPos);

	if (FALSE == m_pAlignerTool->ExecuteCalibrate(nCalibPos, nMarkType))
	{
		return FALSE;
	}

	return TRUE;
}

// 执行标定从位置拷贝到其他位置(nType = 1 对象，nType = 2 目标)		
BOOL vcBaseVisionAlign::ExecuteCopyCalibrateData(int nType,int nExProductIdx/* = 0*/)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if(optionInfo.m_bAutoCopyCalibData)
	{
		std::vector<int> vnPos;
		int nSrcPosIndex;
		int nEndPosIndex;
		if (m_pPlatformInfo->m_bTargetObjectCamSeparate) // 对象目标相机分离
		{
			if(nType == 1)
			{
				nSrcPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum;
				nEndPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum + m_pPlatformInfo->m_nPositionNum / 2;
			}
			else if(nType == 2)
			{
				nSrcPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum + m_pPlatformInfo->m_nPositionNum / 2;
				nEndPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum + m_pPlatformInfo->m_nPositionNum;
			}
		} 
		else // 修改用于直接删除重复变量 m_bDiffPosWithSameCalibInfoEnabled
		{
			if(m_pPlatformInfo->m_bEnableMultiCalibExtension && optionInfo.m_bAutoCopyCalibDataExProduct)
			{
				nSrcPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum;
				nEndPosIndex = (m_pPlatformInfo->m_nMultiCalibExtensionMaxNum)*m_pPlatformInfo->m_nPositionNum + m_pPlatformInfo->m_nPositionNum;
			}
			else
			{
				nSrcPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum;
				nEndPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum + m_pPlatformInfo->m_nPositionNum;
			}
		}

		for(int k=nSrcPosIndex;k<nEndPosIndex;k++)
		{
			if (k != nSrcPosIndex)
			{
				vnPos.push_back(k);
			}
		}

		BOOL bResult = SetSameCalibrateInfo(nSrcPosIndex,vnPos);

		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
		vpAllCalibratedInfo =  GetAllCalibratedInfo();	

		SetCurCalibratedInfo(vpAllCalibratedInfo);

		// 6.保存标定信息到磁盘中
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);	
		return TRUE;
	}
	return FALSE;
}

BOOL vcBaseVisionAlign::ExecuteCalibrateFCBS(std::vector<CMarkImagePos*> pMarkImagePos,int nCalibPos, int nMarkType)
{

	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	if (m_pPlatformInfo->m_bPlatformPick && m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformShareXY)
	{
		int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;

		if (nMarkType==0 || nMarkType==1)
		{
			m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nMarkType,nRemCalibPos);		

			SaveCalibMoveImagePosInfo();

			return TRUE;
		}	

		SaveCalibMoveImagePosInfo();

		if (FALSE == m_pAlignerTool->ExecuteCalibrateFCBS(nCalibPos, nMarkType))
		{
			return FALSE;
		}

		return TRUE;
	}
	else
	{
		if (ePlatformXYPD != m_pPlatformInfo->m_eMidPlatformType)
		{
			return FALSE;
		}

		int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;

		if (nMarkType==0 || nMarkType==1)
		{
			m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nMarkType,nRemCalibPos);	

			SaveCalibMoveImagePosInfo();

			return TRUE;
		}	

		if (pMarkImagePos.size()>0)
		{
			m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nRemCalibPos);
		}

		SaveCalibMoveImagePosInfo();

		if (FALSE == m_pAlignerTool->ExecuteCalibrateFCBS(nCalibPos, nMarkType))
		{
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

BOOL vcBaseVisionAlign::ExecuteCalibrateBenchMarkRgisterPlace(int nCalibPos, int nMarkType)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	if (FALSE == m_pAlignerTool->ExecuteCalibrateBenchMarkRgisterPlace(nCalibPos, nMarkType))
	{
		return FALSE;
	}

	return TRUE;
}

BOOL vcBaseVisionAlign::ExecuteCalibrateBenchMarkRgister(std::vector<CMarkImagePos*> pMarkImagePos, int nCalibPos, int nMarkType)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nCalibPos%GetPosNum());

	if (FALSE == m_pAlignerTool->ExecuteCalibrateBenchMarkRgister(nCalibPos, nMarkType))
	{
		return FALSE;
	}

	return TRUE;
}


// 执行基本靶标的关联映射标定
BOOL vcBaseVisionAlign::ExecuteCalibrateBoard(std::vector<CMarkImagePos*> pMarkImagePos, std::vector<CMarkImagePos*> pMarkBoardPos,
	sc2Vector vBoardSize, int nCalibPos, int nMarkType)
{

	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	if (!sysPlatformInfo.m_bTargetCalibUseBoard)
	{
		return FALSE;
	}


	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	{
		if (nMarkType==0 || nMarkType==1)
		{

			m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nMarkType,nCalibPos%GetPosNum());			

			return TRUE;
		}
		else if (nMarkType==2)
		{

		}

	}
	else
	{
		m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nCalibPos%GetPosNum());
	}

	m_pAlignerTool->SetCalibBoardSize(vBoardSize);
	m_pAlignerTool->SetCalibBoardResult(pMarkBoardPos, nCalibPos);


	if (FALSE == m_pAlignerTool->ExecuteCalibrateBoardSingleCamEX(nCalibPos))
	{
		return FALSE;
	}


	return TRUE;
}


// 获取标定时相机平台的基准位置
void vcBaseVisionAlign::SetCalibCamPlatformPos( std::vector<CPlatformXYAxisPos*> vpPlatformXYAxisPos )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	for (int i=0; i<vpPlatformXYAxisPos.size(); i++)
	{
		m_pAlignerTool->SetCalibCamPlatformPos(i, vpPlatformXYAxisPos.at(i));
	}
}					

// 获取标定时,指定相机需要移动的所有位置
void vcBaseVisionAlign::GetCalibCamPlatformMovePos( int nIndex, std::vector<CPlatformXYAxisPos*>& vpCameraMoveAxisPos )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	std::vector<CPlatformAxisPos*> vpCPlatformAxisPos = m_pAlignerTool->GetCalibCameraMovePos(nIndex);

	if (vpCPlatformAxisPos.size()!=vpCPlatformAxisPos.size())
	{
		return;
	}

	for (int i=0; i<vpCPlatformAxisPos.size(); i++)
	{
		vpCameraMoveAxisPos.push_back((CPlatformXYAxisPos*)vpCPlatformAxisPos.at(i));
	}	

}

// 设置所有相机平台在所有位置的定位结果
void vcBaseVisionAlign::SetCalibCameraMoveSearchResult( std::vector<CMarkImagePos*> vpImageResults )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	if (0 == vpImageResults.size())
	{
		return;
	}

	m_pAlignerTool->SetCalibCameraMoveSearchResult(vpImageResults);	
}					

// 执行相机平台的标定
BOOL vcBaseVisionAlign::ExecuteCamPlatformCalibrate(int nCalibPos)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->ExecuteCamCalibrate(nCalibPos);	
}
BOOL vcBaseVisionAlign::ExecuteCamPlatformCalibrate()
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->ExecuteCamCalibrate();	
}

// 获取所有相机标定结果
std::vector<CCalibratedInfo*> vcBaseVisionAlign::GetAllCalibratedInfo()
{
	std::vector<CCalibratedInfo*> vpCalibratedInfo;

	if (NULL == m_pAlignerTool)
	{
		return vpCalibratedInfo;
	}

	vpCalibratedInfo = m_pAlignerTool->GetCalibratedInfo();

	return  vpCalibratedInfo;	
}

BOOL vcBaseVisionAlign::SetSameCalibrateInfo(int nSrcPos,std::vector<int>vnPos)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}
	return m_pAlignerTool->SetSameCalibrateInfo(nSrcPos,vnPos);

}



//////////////////////////////////////////////////////////////////////////
// 对位工具：对位	

// 设置当前平台用到的标定后信息（设置好后，并保存到m_pVisionASMConfig->m_vpCalibratedInfo及配置文件中）
void vcBaseVisionAlign::SetCurCalibratedInfo( std::vector<CCalibratedInfo*> vCalibratedInfo )
{
	if (NULL == m_pAlignerTool || NULL == m_pVisionASMConfig)
	{
		return;
	}

	if (0 == vCalibratedInfo.size())
	{
		return;
	}

	m_pAlignerTool->SetProductCalibratedInfo(vCalibratedInfo);

	// 	// 保存标定后的信息到配置文件
	// 	for (int m=0; m<m_pVisionASMConfig->m_vpCalibratedInfo.size(); m++)
	// 	{
	// 		if (vCalibratedInfo.at(m))
	// 		{
	// 			*m_pVisionASMConfig->m_vpCalibratedInfo.at(m) = *vCalibratedInfo.at(m);
	// 		}       
	// 	}
	// 
	// 	SaveCalibratedInfo();

	SaveCalibMoveImagePosInfo();

}		

// 设置实时目标定位时平台绝对位置
void vcBaseVisionAlign::SetTargetPlatformPos( CPlatformAxisPos* pPlatformAxisPos ,int nIndex)
{
	if (NULL == m_pAlignerTool || NULL == pPlatformAxisPos)
	{
		return;
	}

	m_pAlignerTool->SetTargetPlatformPos(pPlatformAxisPos,nIndex);	
}			
// 设置多目标定位时平台绝对位置
void vcBaseVisionAlign::SetMutiTargetPlatformPos( CPlatformAxisPos* pPlatformAxisPos ,int nIndex)
{
	if (NULL == m_pAlignerTool || NULL == pPlatformAxisPos)
	{
		return;
	}
	if (m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(nIndex)!= NULL)
	{
		delete m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(nIndex);
		m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(nIndex) = NULL;
	}	

	CPlatformAxisPos *platformAxisPos;
	platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
	m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(nIndex)=platformAxisPos; 



}

// 设置实时目标定位时相机平台绝对位置
void vcBaseVisionAlign::SetTargetCamPlatformPos( std::vector<CPlatformXYAxisPos*> vpCamPltfmAxisPos )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	std::vector<CPlatformAxisPos*> vpTemp;

	for (int i=0; i<vpCamPltfmAxisPos.size(); i++)
	{
		vpTemp.push_back(vpCamPltfmAxisPos.at(i));
	}

	m_pAlignerTool->SetTargetCameraPos(vpTemp);

}									
// 设置实时目标定位时相机平台绝对位置
void vcBaseVisionAlign::SetTargetCamPlatformPos( std::vector<CPlatformXYAxisPos*> vpCamPltfmAxisPos,int nCamPos )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}
	if (nCamPos<=vpCamPltfmAxisPos.size())
	{
		return;
	}

	std::vector<CPlatformAxisPos*> vpTemp;

	for (int i=0; i<vpCamPltfmAxisPos.size(); i++)
	{
		vpTemp.push_back(vpCamPltfmAxisPos.at(i));
	}

	m_pAlignerTool->SetTargetCameraPos(vpTemp,nCamPos);

}
// 设置目标Mark的图像搜索结果
void vcBaseVisionAlign::SetTargetMarkSearchResults( CMarkImagePos ImageResults )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	m_pAlignerTool->SetTargetMarkSearchResults(ImageResults);
}

CMarkImagePos vcBaseVisionAlign::GetTargetMarkSearchResults()
{
	if (NULL == m_pAlignerTool)
	{
		CMarkImagePos pos;
		return pos;
	}

	return m_pAlignerTool->GetTargetMarkSearchResults();
}

CMarkImagePos vcBaseVisionAlign::GetObjectMarkSearchResults()
{
	if (NULL == m_pAlignerTool)
	{
		CMarkImagePos pos;
		return pos;
	}

	return m_pAlignerTool->GetObjectMarkSearchResults();

}

// 设置实时对象定位时平台绝对位置
void vcBaseVisionAlign::SetObjectPlatformPos(std::vector<CPlatformAxisPos*> pPlatformAxisPos )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	m_pAlignerTool->SetObjectPlatformPos(pPlatformAxisPos);
}
void vcBaseVisionAlign::SetObjectPlatformPos(CPlatformAxisPos* pPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	m_pAlignerTool->SetObjectPlatformPos(pPlatformAxisPos,nIndex);
}
// 设置实时对象定位时相机平台绝对位置
void vcBaseVisionAlign::SetObjectCamPlatformPos( std::vector<CPlatformXYAxisPos*> vpCamPltfmAxisPos )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	std::vector<CPlatformAxisPos*> vpTemp;

	for (int i=0; i<vpCamPltfmAxisPos.size(); i++)
	{
		vpTemp.push_back(vpCamPltfmAxisPos.at(i));
	}

	m_pAlignerTool->SetObjectCameraPos(vpTemp);

}
void vcBaseVisionAlign::SetObjectCamPlatformPos(CPlatformAxisPos* pCamPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}
	if(pCamPlatformAxisPos == NULL)
	{
		return;
	}
	m_pAlignerTool->SetObjectCameraPos(pCamPlatformAxisPos,nIndex);

}
void vcBaseVisionAlign::SetObjectCamAxisPlatformAxisPos(CPlatformAxisPos* pCamAxisPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}
	if(pCamAxisPlatformAxisPos == NULL)
	{
		return;
	}
	m_pAlignerTool->SetObjectCamAxisPlatformAxisPos(pCamAxisPlatformAxisPos,nIndex);

}
void vcBaseVisionAlign::SetObjectCamPlatformPos_MultiEx(CPlatformAxisPos* pCamPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool || NULL == pCamPlatformAxisPos)
	{
		return;
	}
	if(m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		int it = m_pAlignerTool->GetAlignExProductIndex();
		if (m_vvpObjectCamAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpObjectCamAxisPosMultiEx.at(it).at(nIndex);
			m_vvpObjectCamAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pCamPlatformAxisPos));
		m_vvpObjectCamAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	else
	{
		int it = 0;
		if (m_vvpObjectCamAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpObjectCamAxisPosMultiEx.at(it).at(nIndex);
			m_vvpObjectCamAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pCamPlatformAxisPos));
		m_vvpObjectCamAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	if(m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		m_pAlignerTool->SetObjectCamAxisPos_MultiEx(pCamPlatformAxisPos,nIndex);
	}
}
void vcBaseVisionAlign::SetObjectCamAxisPlatformAxisPos_MultiEx(CPlatformAxisPos* pCamAxisPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool || NULL == pCamAxisPlatformAxisPos)
	{
		return;
	}
	if(m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		int it = m_pAlignerTool->GetAlignExProductIndex();
		if (m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex);
			m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pCamAxisPlatformAxisPos));
		m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	else
	{
		int it = 0;
		if (m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex);
			m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pCamAxisPlatformAxisPos));
		m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	if(m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		m_pAlignerTool->SetObjectCamAxisPlatformAxisPos_MultiEx(pCamAxisPlatformAxisPos,nIndex);
	}
}

void vcBaseVisionAlign::SetTargetCamPlatformPos(CPlatformAxisPos* pCamPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}
	if(pCamPlatformAxisPos == NULL)
	{
		return;
	}
	m_pAlignerTool->SetTargetCameraPos(pCamPlatformAxisPos,nIndex);
}
void vcBaseVisionAlign::SetTargetCamAxisPlatformAxisPos(CPlatformAxisPos* pCamAxisPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}
	if(pCamAxisPlatformAxisPos == NULL)
	{
		return;
	}
	m_pAlignerTool->SetTargetCamAxisPlatformAxisPos(pCamAxisPlatformAxisPos,nIndex);
}
void vcBaseVisionAlign::SetTargetCamPlatformPos_MultiEx(CPlatformAxisPos* pCamPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool || NULL == pCamPlatformAxisPos)
	{
		return;
	}
	if(m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		int it = m_pAlignerTool->GetAlignExProductIndex();
		if (m_vvpTargetCamAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpTargetCamAxisPosMultiEx.at(it).at(nIndex);
			m_vvpTargetCamAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pCamPlatformAxisPos));
		m_vvpTargetCamAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	else
	{
		int it = 0;
		if (m_vvpTargetCamAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpTargetCamAxisPosMultiEx.at(it).at(nIndex);
			m_vvpTargetCamAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pCamPlatformAxisPos));
		m_vvpTargetCamAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	if(m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		m_pAlignerTool->SetTargetCamAxisPos_MultiEx(pCamPlatformAxisPos,nIndex);
	}
}
void vcBaseVisionAlign::SetTargetCamAxisPlatformAxisPos_MultiEx(CPlatformAxisPos* pCamAxisPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool || NULL == pCamAxisPlatformAxisPos)
	{
		return;
	}
	if(m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		int it = m_pAlignerTool->GetAlignExProductIndex();
		if (m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex);
			m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pCamAxisPlatformAxisPos));
		m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	else
	{
		int it = 0;
		if (m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex);
			m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pCamAxisPlatformAxisPos));
		m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	if(m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		m_pAlignerTool->SetTargetCamAxisPlatformAxisPos_MultiEx(pCamAxisPlatformAxisPos,nIndex);
	}
}
// 设置实时对象Mark的图像搜索结果
void vcBaseVisionAlign::SetObjectMarkSearchResults( CMarkImagePos ImageResults )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	m_pAlignerTool->SetObjectMarkSearchResults(ImageResults);
}


// 设置单产品扩展平台 对位时目标平台绝对位置
void vcBaseVisionAlign::SetTargetPlatformPos_MultiEx( CPlatformAxisPos* pPlatformAxisPos ,int nIndex)
{
	if (NULL == m_pAlignerTool || NULL == pPlatformAxisPos)
	{
		return;
	}

	//if (m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nIndex)!= NULL)
	//{
	//	delete m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nIndex);
	//	m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nIndex) = NULL;
	//}	

	//CPlatformAxisPos *platformAxisPos;
	//platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
	//m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nIndex)=platformAxisPos; 


	if(m_pAlignerTool->m_bEnableMultiCalibExtension && m_pAlignerTool->m_bEnableMultiCombinationCode && (m_pAlignerTool->m_nCombinationCode>=99 && m_pAlignerTool->m_nCombinationCode<=103))
	{
		std::vector<int> vnCode;
		int nNum = 0;
		nNum = m_pAlignerTool->GetMultiCalibExtensionMaxNum()+1;
		switch (m_pAlignerTool->m_nCombinationCode)
		{
		case 99: // 全部
			{
				for (int it=0;it<nNum;it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 100: // 前一半
			{
				for (int it=0;it<(int)(nNum/2 +0.5);it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 101: // 后一半
			{
				for (int it=(int)(nNum/2);it<nNum;it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 102:   //奇数组
			{
				for (int it=0;it<nNum;it+=2)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 103: // 偶数组
			{
				for (int it=1;it<nNum;it+=2)
				{
					vnCode.push_back(it);
				}
			}
			break;
		default:
			{
				vnCode.push_back(0);
			}
			break;
		}

		for (int it = 0;it<vnCode.size();it++)
		{
			if (m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
			{
				delete m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex);
				m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
			}	

			CPlatformAxisPos *platformAxisPos;
			platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
			m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
		}
	}
	else if(m_pAlignerTool->m_bEnableMultiCombinationCode == FALSE && m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		int it = m_pAlignerTool->GetAlignExProductIndex();
		if (m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex);
			m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
		m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	else
	{
		int it = 0;
		if (m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex);
			m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
		m_vvpTargetPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}

}

// 设置单产品扩展平台 对位时对象平台绝对位置
void vcBaseVisionAlign::SetObjectPlatformPos_MultiEx( CPlatformAxisPos* pPlatformAxisPos ,int nIndex)
{
	if (NULL == m_pAlignerTool || NULL == pPlatformAxisPos)
	{
		return;
	}


	//if (m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nIndex)!= NULL)
	//{
	//	delete m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nIndex);
	//	m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nIndex) = NULL;
	//}	

	//CPlatformAxisPos *platformAxisPos;
	//platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
	//m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nIndex)=platformAxisPos; 


	// 1）默认将有轴位置复制保存全部扩展中
	//for(int it = 0;it<m_pAlignerTool->GetMultiCalibExtensionMaxNum()+1;it++)
	//{
	//	if (m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
	//	{
	//		delete m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex);
	//		m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
	//	}	

	//	CPlatformAxisPos *platformAxisPos;
	//	platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
	//	m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	//}

	// 2) 根据对象组合指令确定 

	if(m_pAlignerTool->m_bEnableMultiCalibExtension && m_pAlignerTool->m_bEnableMultiCombinationCode && (m_pAlignerTool->m_nCombinationCode>=99 && m_pAlignerTool->m_nCombinationCode<=103))
	{
		std::vector<int> vnCode;
		int nNum = 0;
		nNum = m_pAlignerTool->GetMultiCalibExtensionMaxNum()+1;
		switch (m_pAlignerTool->m_nCombinationCode)
		{
		case 99: // 全部
			{
				for (int it=0;it<nNum;it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 100: // 前一半
			{
				for (int it=0;it<(int)(nNum/2 +0.5);it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 101: // 后一半
			{
				for (int it=(int)(nNum/2);it<nNum;it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 102:   //奇数组
			{
				for (int it=0;it<nNum;it+=2)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 103: // 偶数组
			{
				for (int it=1;it<nNum;it+=2)
				{
					vnCode.push_back(it);
				}
			}
			break;
		default:
			{
				vnCode.push_back(0);
			}
			break;
		}

		for (int it = 0;it<vnCode.size();it++)
		{
			if (m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
			{
				delete m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex);
				m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
			}	

			CPlatformAxisPos *platformAxisPos;
			platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
			m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
		}
	}
	else if(m_pAlignerTool->m_bEnableMultiCombinationCode == FALSE && m_pAlignerTool->m_bEnableMultiCalibExtension)
	{
		int it = m_pAlignerTool->GetAlignExProductIndex();
		if (m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex);
			m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
		m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}
	else
	{
		int it = 0;
		if (m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex)!= NULL)
		{
			delete m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex);
			m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex) = NULL;
		}	

		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
		m_vvpObjectPlatformAxisPosMultiEx.at(it).at(nIndex)=platformAxisPos;
	}


}


// 设置虚拟对象定位时平台绝对位置
void vcBaseVisionAlign::SetVirtualPlatformPos( CPlatformAxisPos* pPlatformAxisPos )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	m_pAlignerTool->SetVirtualPlatformPos(pPlatformAxisPos);
}


void vcBaseVisionAlign::SetVirtualPlatformPos(CPlatformAxisPos* pPlatformAxisPos,int nIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	m_pAlignerTool->SetVirtualPlatformPos(pPlatformAxisPos,nIndex);
}

// 设置虚拟对象定位时相机平台绝对位置
void vcBaseVisionAlign::SetVirtualCamPlatformPos( std::vector<CPlatformXYAxisPos*> vpCamPltfmAxisPos )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	std::vector<CPlatformAxisPos*> vpTemp;

	for (int i=0; i<vpCamPltfmAxisPos.size(); i++)
	{
		vpTemp.push_back(vpCamPltfmAxisPos.at(i));
	}

	m_pAlignerTool->SetVirtualCameraPos(vpTemp);
}

// 设置虚拟对象Mark的图像搜索结果
void vcBaseVisionAlign::SetVirtualMarkSearchResults( CMarkImagePos ImageResults )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	m_pAlignerTool->SetVirtualMarkSearchResults(ImageResults);
}



// 计算实时对象Mark到虚拟对象Mark之间的位置关系
BOOL vcBaseVisionAlign::CalculateObjectToVirtualMarkOffset( std::vector<CCoordPos>& vObjectToVirtualOffsets, int nExProductIndex/* = 0 */)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	m_pAlignerTool->SetAlignExProductIndex(nExProductIndex);

	return m_pAlignerTool->CalculateObjectToVirtualMarkOffset(vObjectToVirtualOffsets);
}

// 设置对象Mark到虚拟Mark之间的位置关系
void vcBaseVisionAlign::SetObjectMarkToVirtualMarkOffset( std::vector<CCoordPos> vObjectToVirtualOffsets )
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}

	m_pAlignerTool->SetObjectMarkToVirtualMarkOffset(vObjectToVirtualOffsets);
}

// 保留序号
void vcBaseVisionAlign::SetAlignReservedIndex(int nAlignReservedIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}
	m_pAlignerTool->SetAlignReservedIndex(nAlignReservedIndex);
}
// 基准居中对位补偿序号
void vcBaseVisionAlign::SetAlignBenchOffsetIndex(int nAlignBenchOffsetIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}
	m_pAlignerTool->SetAlignBenchOffsetIndex(nAlignBenchOffsetIndex);
}
// 扩展产品序号
void vcBaseVisionAlign::SetAlignExProductIndex(int nAlignExProductIndex)
{
	if (NULL == m_pAlignerTool)
	{
		return;
	}
	m_pAlignerTool->SetAlignExProductIndex(nAlignExProductIndex);
}

// 执行对位偏差计算
BOOL vcBaseVisionAlign::ExecuteAlign(int nAlnIndex/* = 0*/, BOOL bInspect /*= TRUE*/)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->ExecuteAlign(nAlnIndex,bInspect);
}		

BOOL vcBaseVisionAlign::CaculateTargetFixOffset(CCoordPos &offset)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->CaculateTargetFixOffset(offset);
}

// 叠片机执行对位
BOOL vcBaseVisionAlign::ExecuteAlignExHLLayer(int nAlnIndex, std::vector<CCoordPos> vcpCurCrossPos)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->ExecuteAlignExHLLayer(nAlnIndex, vcpCurCrossPos);
}

// 发送更新主界面对位过程信息的消息给主线程
// 再调用GetAlignerProcessInfo，更新主界面
void vcBaseVisionAlign::PostMessageUpdateAlignerProcessInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	{
		// 		AlignerProcessInfo Tmp;
		// 		GetAlignerProcessInfo(Tmp);
		// 		std::vector<CString> StrMove;
		// 
		// 		CString StrTmp = _T("");
		// 		StrTmp.Format(_T("X:%.3fmm"),Tmp.dXMove);
		// 		StrMove.push_back(StrTmp);
		// 
		// 		StrTmp.Format(_T("Y:%.3fmm"),Tmp.dYMove);
		// 		StrMove.push_back(StrTmp);
		// 
		// 		StrTmp.Format(_T("D:%.3f°"),Tmp.dDMove);
		// 		StrMove.push_back(StrTmp);
		// 
		// 		std::vector<int> vnPosIndex;
		// 		vnPosIndex.push_back(0);
		// 		int m = 2;
		// 		int nPosIndex = 0;
		// 		double dImageWidth = 0;
		// 		double dImageHeight = 125;
		// 		double dControlWidth = 0;
		// 		double dControlHeight = 150;
		// 		if (NULL != GetPosDisplay(nPosIndex))
		// 		{
		// 			dImageWidth  = GetPosDisplay(nPosIndex)->GetImageWidth();
		// 			dImageHeight = GetPosDisplay(nPosIndex)->GetImageHeight();
		// 			if (m_pMainWnd!=NULL)
		// 			{
		// 				CRect rcClient;
		// 				if (NULL !=m_pMainWnd->GetDlgItem(GetPosDisplay(nPosIndex)->GetID()))
		// 				{
		// 					m_pMainWnd->GetDlgItem(GetPosDisplay(nPosIndex)->GetID())->GetWindowRect(rcClient);
		// 					dControlWidth = rcClient.Width();
		// 					dControlHeight = rcClient.Height();
		// 
		// 					if (dControlHeight<125)
		// 					{
		// 						dControlHeight = 125;
		// 					}
		// 
		// 				}
		// 
		// 			}
		// 
		// 		}
		// 
		// 
		// 		for ( m=2;m<5;m++)
		// 		{
		// 			int nTemp = EXTRA_GRAPHICS_NUM_CONST_TEXT*nPosIndex + m;
		// 
		// 			m_vGuiAlnExtraConstTextPos.at(nTemp) = sc2Vector(10,dControlHeight-125+25*(m-2));
		// 
		// 			m_vbVisibleGuiAlnExtraConstText.at(nTemp) = TRUE;
		// 			//m_vcColorGuiAlnExtraConstText.at(nTemp) = RGB(255,0,0);
		// 			// 以目标的颜色显示运动量
		// 			m_vcColorGuiAlnExtraConstText.at(nTemp) = m_pSystempOptionConfig->m_TarSearchResultCrossSize.nLineColor;
		// 
		// 
		// 			CString strTmp = _T("");
		// 			strTmp.Format(_T("运动量%s"),StrMove.at(m-2));
		// 			m_vGuiAlnExtraConstText.at(nTemp) = strTmp;
		// 		}
		//----LJJ
		// 		SetGuiAlnExtraConstText(vnPosIndex);
		// 		PostMessageUpdateGuiAlnExtraConstTextGraphics(vnPosIndex);

		CString strInfo;
		std::vector<int> vnPosIndex;
		m_cVisionAlignGui.SetConstTextShow(vnPosIndex, strInfo, 5);
	}


	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_PROCESS_INFO, TRUE, 0);

}
// 获取对位过程中对位精度、耗时、次数、平台偏移量信息
void vcBaseVisionAlign::GetAlignerProcessInfo(AlignerProcessInfo& alignerProcessInfo)
{
	alignerProcessInfo = m_apAlignerProcesInfo;
}


void vcBaseVisionAlign::GetAlignerProcessInfoLine(AlignerProcessInfo& alignerProcessInfo)
{
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Enter GetAlignerProcessInfoLine------");
	EnterCriticalSection(&m_csAlignerProcessInfoLine);
	if (m_apAlignerProcesInfoline.empty())
	{
		alignerProcessInfo = m_apAlignerProcesInfo;
	} 
	else
	{
		alignerProcessInfo = m_apAlignerProcesInfoline.front();
		
		m_apAlignerProcesInfoline.erase(m_apAlignerProcesInfoline.begin());
	}
	LeaveCriticalSection(&m_csAlignerProcessInfoLine);
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Leave GetAlignerProcessInfoLine------");
}

// 发送更新主界面目标距离信息的消息给主线程
void vcBaseVisionAlign::PostMessageUpdateAlignerTargetSizeInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_TARGET_SIZE_INFO, TRUE, 0);
}

// 获取对位过程中目标距离信息
void vcBaseVisionAlign::GetAlignerTargetSizeInfo(AlignerTargetSizeInfo& alignerTargetSizeInfo)
{
	alignerTargetSizeInfo = m_AlignerTargetSizeInfo;
}
// 发送更新主界面对象距离信息的消息给主线程
void vcBaseVisionAlign::PostMessageUpdateAlignerObjectSizeInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_OBJECT_SIZE_INFO, TRUE, 0);
}
// 获取对位过程中对象距离信息                                     
void vcBaseVisionAlign::GetAlignerObjectSizeInfo(AlignerObjectSizeInfo& alignerObjectSizeInfo)
{
	alignerObjectSizeInfo = m_AlignerObjectSizeInfo;
}

// 发送更新主界面目标标准距离信息的消息给主线程
void vcBaseVisionAlign::PostMessageUpdateAlignerTargetStdSizeInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_TARGET_STD_SIZE_INFO, TRUE, 0);
}

// 获取对位过程中目标标准距离信息
void vcBaseVisionAlign::GetAlignerTargetStdSizeInfo(CAlignCheckInfo& checkInfo)
{
	if (m_pVisionASMConfig == NULL)
	{
		return;
	}

	// 1.获取当前产品索引
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return ;
	}

	// 2.获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return ;
	}
	checkInfo = pCurProductData->m_pAlignerParam->GetAlignCheckInfo(m_pAlignerTool->GetAlignExProductIndex());
}

// 发送更新主界面对象距离信息的消息给主线程
void vcBaseVisionAlign::PostMessageUpdateAlignerObjectStdSizeInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_OBJECT_STD_SIZE_INFO, TRUE, 0);
}

// 获取对位过程中对象标准距离信息
void vcBaseVisionAlign::GetAlignerObjectStdSizeInfo(CAlignCheckInfo& checkInfo)
{
	if (m_pVisionASMConfig == NULL)
	{
		return;
	}

	// 1.获取当前产品索引
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return ;
	}

	// 2.获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return ;
	}
	checkInfo = pCurProductData->m_pAlignerParam->GetAlignCheckInfo(m_pAlignerTool->GetAlignExProductIndex());
}



void vcBaseVisionAlign::PostMessageUpdateAlignerTargetAngleInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_TARGET_ANGLE_INFO, TRUE, 0);
}


void vcBaseVisionAlign::GetAlignerTargetAngleInfo(AlignerTargetAngleInfo& alignerTargetAngleInfo)
{
	alignerTargetAngleInfo = m_AlignerTargetAngleInfo;
}


void vcBaseVisionAlign::PostMessageUpdateAlignerObjectAngleInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_OBJECT_ANGLE_INFO, TRUE, 0);
}


void vcBaseVisionAlign::GetAlignerObjectAngleInfo(AlignerObjectAngleInfo& alignerObjectAngleInfo)
{
	alignerObjectAngleInfo = m_AlignerObjectAngleInfo;
}




void vcBaseVisionAlign::PostMessageUpdateAlignerTargetStdAngleInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_TARGET_STD_ANGLE_INFO, TRUE, 0);
}

void vcBaseVisionAlign::GetAlignerTargetStdAngleInfo(CAlignCheckInfo& checkInfo)
{
	if (m_pVisionASMConfig == NULL)
	{
		return;
	}

	// 1.获取当前产品索引
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return ;
	}

	// 2.获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return ;
	}

	checkInfo = pCurProductData->m_pAlignerParam->GetAlignCheckInfo(m_pAlignerTool->GetAlignExProductIndex());
}

void vcBaseVisionAlign::PostMessageUpdateAlignerObjectStdAngleInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGNER_OBJECT_STD_ANGLE_INFO, TRUE, 0);
}

void vcBaseVisionAlign::GetAlignerObjectStdAngleInfo(CAlignCheckInfo& checkInfo)
{
	if (m_pVisionASMConfig == NULL)
	{
		return;
	}

	// 1.获取当前产品索引
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return ;
	}

	// 2.获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return ;
	}

	checkInfo = pCurProductData->m_pAlignerParam->GetAlignCheckInfo(m_pAlignerTool->GetAlignExProductIndex());
}


void vcBaseVisionAlign::PostMessageUpdateAlignerWarningInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}
	PostMessage(m_pOperatingInfoShowWnd->GetSafeHwnd(), WM_UPDATE_WARNING_INFO, m_pPlatformInfo->m_nPlatformIndex, 0);
}
void vcBaseVisionAlign::GetWarningInfo(deque<CString>& saWarningInfo)
{
	EnterCriticalSection(&m_csResourceWarning);
	saWarningInfo = m_saWarningInfo;
	LeaveCriticalSection(&m_csResourceWarning);
}
void vcBaseVisionAlign::ClearWarningInfo()
{
	EnterCriticalSection(&m_csResourceWarning);
	m_saWarningInfo.clear();
	LeaveCriticalSection(&m_csResourceWarning);
}
//////////////////////////////////////////////////////////////////////////
// 更新状态栏
// 发送更新状态栏信息给主线程
void vcBaseVisionAlign::PostMessageUpdateStatusBarInfo()
{
	if (NULL == m_pMainWnd)
	{
		return;
	}

	PostMessage(m_pMainWnd->GetSafeHwnd(), WM_UPDATE_STATUSBAR_INFO, 0, 0);	
}
// 设置用于更新的状态栏内容
void vcBaseVisionAlign::SetStatusBarInfo(BOOL bStatus, CString strText1, CString strText2)
{
	EnterCriticalSection(&m_csResource);
	m_bTempStatusBar = bStatus;
	m_strTempStatusBarInfo1 = strText1;
	m_strTempStatusBarInfo2 = strText2;
	LeaveCriticalSection(&m_csResource);
}

// 获取用于更新的状态栏内容
void vcBaseVisionAlign::GetStatusBarInfo(BOOL& bStatus, CString& strText1, CString& strText2) 
{
	EnterCriticalSection(&m_csResource);
	bStatus = m_bTempStatusBar;
	strText1 = m_strTempStatusBarInfo1;
	strText2 = m_strTempStatusBarInfo2;
	LeaveCriticalSection(&m_csResource);
}

// 发送更新状态栏信息给主线程	
void vcBaseVisionAlign::PostMessageUpdateCommCommandInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_COMM_COMMAND_INFO, 0, 0);		//hk20180130
}

// 主线程获取用于更新的状态栏内容
void vcBaseVisionAlign::GetCommCommandInfo(	deque<CString>& saCommCommandSimple, deque<CString>& saCommCommandDetail)
{
	EnterCriticalSection(&m_csResourceComm);
	saCommCommandSimple = m_saCommCommandSimple;
	saCommCommandDetail = m_saCommCommandDetail;
	LeaveCriticalSection(&m_csResourceComm);
}
void vcBaseVisionAlign::SetCommCommandName(CString strCommCommandName, SysWorkCmdType eCommandType)
{
	EnterCriticalSection(&m_csResourceCommName);
	if (strCommCommandName != "FCHK")
	{
		CString strNewCmdName;
		m_XYDCommProtocol.ReplaceNewCommCmd(strCommCommandName, strNewCmdName);
		m_strCommCommandName = strNewCmdName;
	}
	else
	{
		m_strCommCommandName = strCommCommandName;
	}
	if (eCommandType != eCmdUnknow)
	{
		m_cmdTypeCommandName = eCommandType;
		m_mapCmdNameValue.insert(std::make_pair(m_strCommCommandName, m_cmdTypeCommandName));
	}
	LeaveCriticalSection(&m_csResourceCommName);
}

void vcBaseVisionAlign::GetCommCommandName(CString& strCommCommandName)
{
	EnterCriticalSection(&m_csResourceCommName);
	if (m_strCommCommandName != _T(""))
	{
		strCommCommandName = m_strCommCommandName + _T(":");
	}
	else
	{
		strCommCommandName = _T("");
	}
	LeaveCriticalSection(&m_csResourceCommName);
}

CString vcBaseVisionAlign::GetCmdWarningString(CString strCmd)
{
	CString strWarningString = _T("");
	EnterCriticalSection(&m_csResourceCommName);
	std::map<CString, SysWorkCmdType>::iterator it = m_mapCmdNameValue.find(strCmd.Left(4));	//指令均为4个字节，不取冒号
	if (it != m_mapCmdNameValue.end())
	{
		switch (it->second)
		{
		case eCmdSetProductIndexFSPC:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_CHANGE_PRODUCT_NAME_FAILE);	//切换产品失败
			}
			break;
		case eCmdSaveProductIndexFSSV:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SAVE_PRODUCT_FAILE);	//保存产品失败
			}
			break;
		case eCmdGetProductIndexFGSP:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_GETPRODUCTNUMBER_FAILED);	//获取产品序号失败
			}
			break;
		case eCmdSetProductVirtualAlnFVAS:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_VALN_SETTING_FAIL);	//内/外mark设置失败
			}
			break;
		case eCmdCalibrateFCLB:
		case eCmdCalibrateFCBS:
		case eCmdCalibrateFCPR:
		case eCmdCalibrateFCBP:
		case eCmdFAFO:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);	//系统标定失败
			}
			break;
		case eCmdGetTargetObjectOffsetFACO:
		case eCmdOnceAlignMovePickFALP:
		case eCmdAutoAlignFAAL:
		case eCmdAutoAlignFAAC:
		case eCmdAutoAlignFXYA:
		case eCmdAutoAlignFAAB:
		case eCmdAutoAlignFACB:
		case eCmdAutoAlignFAHL:
		case eCmdOnceAlignMoveFALG:
		case eCmdGetTargetObjectOffsetFOLC:
		case eCmdGetTargetObjectOffsetFABO:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);	//对位失败
			}
			break;
		case eCmdTargetSearchFTGT:
		case eCmdTargetSearchFTGC:
		case eCmdTargetSearchFCNO:
		case eCmdGetImagePosFGTC:
		case eCmdGetTargetPlatformPosFGTW:
		case eCmdGetTargetImagePosFGTP:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);	//实时目标Mark定位失败
			}
			break;
		case eCmdObjectSearchFOBJ:
		case eCmdObjectSearchFOBC:
		case eCmdObjectSearchFCNT:
		case eCmdGetImagePosFGAP:
		case eCmdGetObjectWorldPosFGOW:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);	//实时对象Mark定位失败
			}
			break;
		case eCmdObjectSearchFOBM:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_STR_SELECT_MARK_OBJECT_POSITION_FAIL);	//实时对象Mark手动定位失败
			}
			break;
		case eCmdTargetSearchFTGM:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_STR_SELECT_MARK_TARGET_POSITION_FAIL);	//实时目标Mark手动定位失败
			}
			break;
		case eCmdGetObjectImagePosFOBG:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_GET_OBJECT_MARK_COORD_FAILED);	//获取对象Mark图像坐标失败
			}
			break;
		case eCmdGetTargetImagePosFTGG:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_GET_OBJECT_MARK_COORD_FAILED);	//获取目标Mark图像坐标失败
			}
			break;
		case eCmdGetSearchWorldPosFWLD:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_GET_PLATFORM_COORD_FAILED);	//获取平台坐标失败
			}
			break;
		case eCmdFWDR:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_GET_RADIUS_FAILED);	//获取半径失败
			}
			break;
		case eCmdGetAlignPrecisionFGAL:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_GET_PRECISION_FAILE);	//获取对准精度失败
			}
			break;
		case eCmdSetAlignPrecisionFALL:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SET_PRECISION_FAILE);	//设置对准精度失败
			}
			break;	
		case eCmdGetAlignTimeFGAC:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_GET_ALN_TIME_FAILE);	//获取对准最多次数失败
			}
			break;
		case eCmdSetAlignTimeFALC:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SET_ALN_TIME_FAILE);	//设置对准最多次数失败
			}
			break;
		case eCmdGetAlignOffsetFGOF:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_GET_ALN_OFFSET_FAILE);	//获取对位补偿失败
			}
			break;
		case eCmdSetAlignOffsetFOFS:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SET_ALN_OFFSET_FAILE);	//设置对位补偿失败
			}
			break;
		case eCmdObjTarSearchFPCB: 
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_SEARCH_FAILED);	//定位失败
			}
			break;
		case  eCmdSpecialCommFCHK:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_COMM_HAND_TO_HAND_FAILE);	//PLC握手通讯失败
			}
			break;
		case eCmdACFInspectFCHB:
		case eCmdACFInspectFCHC:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);	//ACF检测失败
			}
			break;
		case eCmdFDRP:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_CALCU_FAILE);	//计算失败
			}
			break;
		case eCmdSetProductExposureFSPE:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_CHANGE_PRODUCT_EXPOSURE_FAIL);	//切换产品曝光失败
			}
			break;
		case eCmdInspectFINS:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_INSPECT_FAIL);	//检测失败
			}
			break;
		case eCmdPCBPrecisionFPIS:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_PRECISION_INSPECT_FAIL);	//精度检测失败
			}
			break;
		case eCmdChangePlatformIndex:
			{
				strWarningString = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_CHANGE_PLATFORM_FAIL);	//切换平台失败
			}
			break;
		}
	}
	LeaveCriticalSection(&m_csResourceCommName);
	return strWarningString;
}
void vcBaseVisionAlign::ClearCommCommandInfo()
{
	EnterCriticalSection(&m_csResourceComm);
	m_saCommCommandSimple.clear();
	m_saCommCommandDetail.clear();
	LeaveCriticalSection(&m_csResourceComm);
}
void vcBaseVisionAlign::AddCommCommandInfo(BOOL bSend, CString strCmd, BOOL bTimeExist/* = FALSE*/,BOOL bAddDetailInfo)
{
	return;
}

// 发送更新当前产品
void vcBaseVisionAlign::PostMessageUpdateCurProductAlignInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_CUR_PRODUCT_ALIGN_INFO, 0, 0);	
}
// 发送更新对位精度
void vcBaseVisionAlign::PostMessageUpdateAlignPrecisionInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGN_PRECISION, 0, 0);	
}

// 发送更新对位补偿
void vcBaseVisionAlign::PostMessageUpdateAlignOffsetInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_ALIGN_OFFSET, 0, 0);	
}
// 发送更新当前位置                                                                              
// void vcBaseVisionAlign::PostMessageUpdateCurPlatformAxisPosInfo()
// {
// 	if (NULL == m_pMainRunWnd)
// 	{
// 		return;
// 	}
// 
// 	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_CUR_PLATFORM_AXIS_POS_INFO, 0, 0);	
// }


//////////////////////////////////////////////////////////////////////////
// 平台工作线程
// 挂起工作线程(一个流程走完，再进入等待状态)（与主界面交互）
BOOL vcBaseVisionAlign::SuspendWorkThread()
{

	//	AlignLogRecord(_T("SuspendWorkThread Start"));
	m_bStopNow  = TRUE;

	scTimer stTimer;
	stTimer.Reset();
	//	AlignLogRecord(_T("CloseComm Start"));
	// 	if (CloseComm())
	// 	{
	// 	}	
	//	AlignLogRecord(_T("CloseComm End"));
	StopReceiveComm();


	m_bSuspendWorkThread = TRUE;
	//	AlignLogRecord(_T("WaitThreadWorkFinished  Start"));
	while(FALSE == m_bCurThreadWorkFinished)
	{
		if (stTimer.GetTimeMilli(FALSE)>=WAIT_THREAD_SUSPEND_TIME)
		{
			VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt","等待工作线程流程结束(m_bCurThreadWorkFinished = TRUE)超时");
			break;
		}
			

		Sleep(2);
	}
	//	AlignLogRecord(_T("WaitThreadWorkFinished  End"));
	// 	if (m_pWorkThread!=NULL)
	// 	{
	// 		m_pWorkThread->SuspendThread();
	// 	}


	// F
	// 	if (m_pHideSearchGuiThread!=NULL)
	// 	{
	// 		m_pHideSearchGuiThread->SuspendThread();
	// 	}
	//	AlignLogRecord(_T("SearchThread  Start"));

	// 暂时未使用
	// 	for(int i = 0; i < m_vpHideSearchGUIObject.size(); i++)
	// 	{
	// 		Sleep(20);
	// 		m_vpHideSearchGuiThread[i]->SuspendThread();
	// 	}

	for(int i = 0; i < m_vpSearchThread.size(); i++)
	{
		int nSleepCnt = 1000; // 10s内判断，就强制停止吧，虽然有风险
		while(nSleepCnt--)
		{
			// 线程安全，可以执行挂起函数
			if (m_vbSearchThreadSuspended[i])
			{
				
				break;
			}
			Sleep(10);
		}
		if (!nSleepCnt)
		{
			CString Tempstr;
			Tempstr.Format(_T("搜索线程%d m_vbSearchThreadSuspended[%d]强制挂起"),i,i);
			VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt",Tempstr);
		}
		//		Sleep(20);

		m_vpSearchThread[i]->SuspendThread();
	}

	for(int i = 0; i < m_vpSaveImageThread.size(); i++)
	{
		int nSleepCnt = 1000; // 10s内判断，就强制停止吧，虽然有风险
		while(nSleepCnt--)
		{
			// 线程安全，可以执行挂起函数
			if (m_vbSaveImageThreadSuspended[i])
			{
				
				break;
			}
			Sleep(10);
		}
		if (!nSleepCnt)
		{
			CString Tempstr;
			Tempstr.Format(_T("存图线程%d m_vpSaveImageThread[%d]强制挂起"),i,i);
			VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt",Tempstr);
		}

		//		Sleep(20);
		m_vpSaveImageThread[i]->SuspendThread();
	}


	for(int i = 0; i < m_vpCameraExposureThread.size(); i++)
	{
		int nSleepCnt = 1000; // 10s内判断，就强制停止吧，虽然有风险
		while(nSleepCnt--)
		{
			// 线程安全，可以执行挂起函数
			if (m_vbCameraExposureThreadSuspended[i])
			{
				
				break;
			}
			Sleep(10);
		}
		if (!nSleepCnt)
		{
			CString Tempstr;
			Tempstr.Format(_T("曝光线程%d m_vpCameraExposureThread[%d]强制挂起"),i,i);
			VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt",Tempstr);
		}
		//		Sleep(20);
		DWORD	nSusResult = m_vpCameraExposureThread[i]->SuspendThread();
		if (nSusResult == -1)
		{
			CString Tempstr;
			Tempstr.Format(_T("曝光线程%d m_vpCameraExposureThread[%d]挂起失败"),i,i);
			VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt",Tempstr);
		}
	}


	//	AlignLogRecord(_T("SearchThread  End"));
	m_bStopNow  = FALSE;

	// 如果启用按时刻存图和文件，从运行到停止时挂起删除文件夹线程
	if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == TRUE)
	{
		// 挂起删除文件夹线程
		if (m_bCheckRemoveFolderThreadSuspend == FALSE)
		{
		//	VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt","搜索线程m_pCheckRemoveFolderThread挂起");
			m_pCheckRemoveFolderThread->SuspendThread();
			m_bCheckRemoveFolderThreadSuspend = TRUE;
		}

	}

	//光源切换线程挂起
	//for(int i = 0; i < m_vpLightCtrlThread.size(); i++)
	//{
	//	int nSleepCnt = 1000; // 10s内判断，就强制停止吧，虽然有风险
	//	while(nSleepCnt--)
	//	{
	//		// 线程安全，可以执行挂起函数
	//		if (m_vbLightCtrlSuspended[i])
	//		{
	//			break;
	//		}
	//		Sleep(10);
	//	}
	//	//		Sleep(20);
	//	m_vpLightCtrlThread[i]->SuspendThread();
	//}

	//	AlignLogRecord(_T("SuspendWorkThread  End"));
	return TRUE;
}

// 恢复工作线程（与主界面交互）
BOOL vcBaseVisionAlign::ResumeWorkThread()
{	
	// 	if (OpenComm())
	// 	{
	// 	}

	StartReceiveComm();

	m_bStopNow = FALSE;

	m_bCurThreadWorkFinished = TRUE;

	m_bSuspendWorkThread = FALSE;

	if (m_pWorkThread!=NULL)
	{
		m_pWorkThread->ResumeThread();
	}

	// 	if (m_pHideSearchGuiThread!=NULL)
	// 	{
	// 		m_pHideSearchGuiThread->ResumeThread();
	// 	}


	// 	for(int i = 0; i < m_vpHideSearchGUIObject.size(); i++)
	// 	{
	// 		m_vpHideSearchGuiThread[i]->ResumeThread();
	// 	}

	for(int i = 0; i < m_vpSearchThread.size(); i++)
	{
		DWORD nResumResult = m_vpSearchThread[i]->ResumeThread();
		while (nResumResult > 1)
		{
			nResumResult = m_vpSearchThread[i]->ResumeThread();
		}
	}

	for (int i = 0; i < m_vpSaveImageThread.size(); i++)
	{
		DWORD nResumResult = m_vpSaveImageThread[i]->ResumeThread();
		while (nResumResult > 1)
		{
			nResumResult = m_vpSaveImageThread[i]->ResumeThread();
		}
	}

	for(int i = 0; i < m_vpCameraExposureThread.size(); i++)
	{
		DWORD nResumResult =  m_vpCameraExposureThread[i]->ResumeThread();

		while (nResumResult > 1)
		{
			nResumResult = m_vpCameraExposureThread[i]->ResumeThread();
		}
		/*if (nResumResult == -1)
		{
		CString Tempstr;
		Tempstr.Format(_T("曝光线程%d m_vpCameraExposureThread[%d]恢复失败"),i,i);
		VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt",Tempstr);
		}*/
	}

	//for (int i = 0; i < m_vpLightCtrlThread.size(); i++)
	//{
	//	m_vpLightCtrlThread[i]->ResumeThread();
	//}

	// 如果启用按时刻存图和文件，从停止到运行时恢复删除文件夹线程
	if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == TRUE)
	{
		// 挂起删除文件夹线程
		if (m_bCheckRemoveFolderThreadSuspend == TRUE)
		{
			m_pCheckRemoveFolderThread->ResumeThread();
			m_bCheckRemoveFolderThreadSuspend = FALSE;
		}

	}

	return TRUE;
}

// 判断整个对位过程是否结束（TRUE标结束，FALSE标未结束）（nAlignTime为已经执行的对位动作次数）
BOOL vcBaseVisionAlign::IsAlignFinished(int nAlignTime, BOOL bMulAligner)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->IsAlignFinished(nAlignTime, bMulAligner);
}

// 判断整个对位过程是否成功（TRUE标成功，FALSE标未成功）
BOOL vcBaseVisionAlign::IsAlignSucceed()
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->IsAlignSucceed();
}

// 对位偏差计算成功后，获取平台对位时要移动的绝对位置
CPlatformAxisPos* vcBaseVisionAlign::GetAlignPlatformMovementResults(BOOL bUseOffset/* = FALSE*/)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->GetAlignPlatformMovementResults(bUseOffset);
}

// 对位偏差计算成功后，获取平台对位时要移动的绝对位置
CPlatformAxisPos* vcBaseVisionAlign::GetAdjustAlignPlatformMovementResults(double dratioX,double dratioY,double dratioD/*=1.0*/)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	return m_pAlignerTool->GetAdjustAlignPlatformMovementResults(dratioX,dratioY,dratioD);
}

// 获取对位产品的偏移值，用于界面显示，用XYD形式显示
CCoordPos vcBaseVisionAlign::GetAlignProductOffset()
{
	CCoordPos cp;

	if (NULL == m_pAlignerTool)
	{
		return cp;
	}

	return m_pAlignerTool->GetAlignProductOffset();
}

// 获取对位产品的偏移值，用于界面显示，用XYD形式显示
CCoordPos vcBaseVisionAlign::GetAlignProductOffsetXYPD()
{
	CCoordPos cp;

	if (NULL == m_pAlignerTool)
	{
		return cp;
	}

	return m_pAlignerTool->GetAlignProductOffsetXYPD();
}

// 获取对位各轴偏差量计算结果，用于界面显示，用XYD形式显示
CCoordPos vcBaseVisionAlign::GetAlignPlatformOffset()
{
	CCoordPos cp;

	if (NULL == m_pAlignerTool)
	{
		return cp;
	}

	return m_pAlignerTool->GetAlignPlatformOffset();
}

// 获取对位各轴偏差量计算结果，用于输出控制轴运动
CCoordPos vcBaseVisionAlign::GetAlignPlatformPosOffset()
{
	CCoordPos cp;

	if (NULL == m_pAlignerTool)
	{
		return cp;
	}

	return m_pAlignerTool->GetAlignPlatformPosOffset();
}

CCoordPos vcBaseVisionAlign::GetAlignPlatformPickRevise()
{
	CCoordPos cp;

	if (NULL == m_pAlignerTool)
	{
		return cp;
	}

	return m_pAlignerTool->GetAlignPlatformPosOffsetPickRevise();
}

// 中间对位过程，当相机为独立安装时，获取下次定位前各相机要移动到的绝对位置
std::vector<CPlatformAxisPos*> vcBaseVisionAlign::GetAlignCameraMovementResults()
{
	if (NULL == m_pAlignerTool)
	{
		std::vector<CPlatformAxisPos*> vpPos;
		return vpPos;
	}

	return m_pAlignerTool->GetAlignCameraMovementResults();

}

// 保存标定后信息到当前产品中及配置文件中
void vcBaseVisionAlign::SaveCalibratedInfoToCurProduct( std::vector<CCalibratedInfo*> vCalibratedInfo )
{
	if (NULL == m_pAlignerTool || NULL == m_pVisionASMConfig)
	{
		return;
	}

	if (0 == m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return;	
	}

	int nIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nIndex <0 || nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount() )
	{
		return;
	}

	// 将标定后的信息存入当前产品
	CProductData product = m_pVisionASMConfig->m_TotalProductData.GetItem(nIndex);	    
	for (int i=0; i<vCalibratedInfo.size(); i++)
	{
		if (vCalibratedInfo.at(i))	//hk20180130
		{
			*product.m_vpCalibratedInfo.at(i) = *vCalibratedInfo.at(i);       
		}
	}
	m_pVisionASMConfig->m_TotalProductData.SetItem(nIndex, product);
	SaveProductDataInfo(nIndex);



	// 将标定后信息存入当前标定数据中
	CCalibData* pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nIndex);	  
	if (pCalibData == NULL)
	{
		return;
	}
	for (int i=0; i<vCalibratedInfo.size() ; i++)
	{
		if (vCalibratedInfo.at(i))	//hk20180130
		{
			*pCalibData->m_vpCalibratedInfo.at(i) = *vCalibratedInfo.at(i);       
		}
	}
	SaveCalibDataInfo(nIndex);

	// 更新当前对位工具使用的标定后信息
	//m_pAlignerTool->SetProductCalibratedInfo(product.m_vpCalibratedInfo);
	m_pAlignerTool->SetProductCalibratedInfo(pCalibData->m_vpCalibratedInfo);


}

BOOL vcBaseVisionAlign::SearchMark(std::vector<int> vnPosIndex, std::vector<SearchMode> vsmSearchMode)
{
	if (vnPosIndex.size() < 1 || vsmSearchMode.size() < 1 || vnPosIndex.size() != vsmSearchMode.size())
	{
		return FALSE;
	}

	int i = 0;
	int nPosIndex;		
	int nPosNum = vnPosIndex.size();
	m_StrSearchErrorInfo = _T("");
	// 准备定位
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		m_vsmSearchMode[nPosIndex] = vsmSearchMode[i];
		m_vbSearchEnd[nPosIndex] = FALSE;
		m_vbSearchFinished[nPosIndex] = FALSE;
		m_phPosEvent[i] = m_vhSearchEndEvent[nPosIndex];
		ResetEvent(m_phPosEvent[i]);
	}

	// 开始定位
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		m_vbSearchStart[nPosIndex] = TRUE;
	}


	// 等待定位完成
	BOOL bSearchFinished = FALSE;
	while (!bSearchFinished)
	{
		if (m_bStopNow)
		{
			return FALSE;
		}

		DWORD tt;
		tt = WaitForMultipleObjects(nPosNum, m_phPosEvent, TRUE, 120);
		if (tt != WAIT_TIMEOUT)
		{
			bSearchFinished = TRUE;
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// 记录对象目标搜索错误原因
	{
		CString strSearchMark = _T("");
		CString strErrorInfo = _T("");
		m_StrSearchErrorInfo += strErrorInfo;
		for (i=0; i<nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];

			strErrorInfo = _T("");
			if(!m_vbSearchSucceed[nPosIndex])  //如果失败
			{
				strErrorInfo.Format(_T("位置%d"),vnPosIndex[i]+1);
				if(vsmSearchMode[i] == eTargetSearch)
				{
					int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
					int nPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
					CBaseSearchTool* pSearchTool = GetRepoAlnTargetSearchTool(nCurProdcutIndex, nPosIndex, nPatIndex);
					if (NULL !=pSearchTool)
					{
						strErrorInfo += (pSearchTool->GetResultErrInfo());
					}
				}
				else if (vsmSearchMode[i] == eObjectSearch)
				{
					int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
					int nPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
					CBaseSearchTool* pSearchTool = GetRepoAlnObjectSearchTool(nCurProdcutIndex, nPosIndex, nPatIndex);
					if (NULL !=pSearchTool)
					{
						strErrorInfo += (pSearchTool->GetResultErrInfo());
					}
				}

			}
			m_StrSearchErrorInfo += (strErrorInfo + _T(",")) ;
		}

	}
	//////////////////////////////////////////////////////////////////////////

	// 分析定位结果，发送指令响应
	BOOL bSearchSucceed = TRUE;
	//	int bTempCount = 0;  // 计数器，配合if使用；iyo

	// 	// 获取当前产品信息
	// 	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	// 	CPCBInfo PCBInfo;
	// 	PCBInfo = curProductData.m_pAlignerParam->GetPCBInfo();
	// 	int nPCBInsPreType = PCBInfo.m_nPCBInsPreType;
	// 	BOOL ShowPCB4To3Align = PCBInfo.m_bShowPCB4To3Align;

	for (i=0; i<nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		// 且为PCB定制
		//if (m_pSystempOptionConfig->m_bShowPCB4To3Align&&sysPlatformInfo.m_bShowPCB4To3Align) 

		// 		if(ShowPCB4To3Align && nPosNum == 4)
		// 		{
		// 			////////////////////////// 
		// 			// 针对4个相机，如果定位失败为1个或者0个则返回ture；
		// 		    // 否则为失败
		// 			if (!m_vbSearchSucceed[nPosIndex])
		// 			{
		// 				bTempCount++;
		// 			}
		// 			if (bTempCount==0)
		// 			{
		// 				m_searchAllResultStatus = eSARSResultOK;   // 没有定位失败的情况
		// 				bSearchSucceed = TRUE;
		// 			}else if (bTempCount ==1)
		// 			{
		// 				m_searchAllResultStatus = eSARSResultNG1;   // 定位失败1个的情况
		// 				bSearchSucceed = TRUE;
		// 			}
		// 			else 
		// 			{
		// 				m_searchAllResultStatus = eSARSResultNGMore;
		// 				bSearchSucceed = FALSE;
		// 			}
		// 		}
		// 		// 非定制，常规
		// 		else
		{
			bSearchSucceed = bSearchSucceed && m_vbSearchSucceed[nPosIndex];
		}
	}

	return bSearchSucceed;

}		


// 曝光线程
UINT vcBaseVisionAlign::CameraExposureThread( LPVOID pParam)
{
	CCameraExposureObject* pCameraExposureObject = (CCameraExposureObject*)pParam;
	if (pCameraExposureObject == NULL)
	{
		return 0;
	}

	vcBaseVisionAlign* pBaseVisionASM = (vcBaseVisionAlign*) pCameraExposureObject->m_pOwner;
	if (pBaseVisionASM ==  NULL)
	{
		return 0;
	}

	int nPosIndex = pCameraExposureObject->m_nPosIndex;
	int nCandPatIndex = pCameraExposureObject->m_nPatIndex;

	if (nCandPatIndex < 0)
	{
		nCandPatIndex = 0;
	}

	pBaseVisionASM->CameraExposureProcess(nPosIndex, nCandPatIndex);

	return 0;
}

void vcBaseVisionAlign::CameraExposureProcess(int nPosIndex, int nCandIndex)
{
	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{
		return;
	}

	while(FALSE == m_vbExitCameraExposureThread[nPosIndex])
	{

		m_vbCameraExposureThreadSuspended[nPosIndex] = m_bSuspendWorkThread;
		if (m_vbCameraExposureThreadSuspended[nPosIndex])
		{
			Sleep(1);
			continue;
		}

		if (TRUE == m_vbCameraExposureStart[nPosIndex])
		{
			m_vbCameraExposureStart[nPosIndex] = FALSE;

			CameraExposureType nSearchMode = m_vsmSearchCameraExposureType[nPosIndex];
			nCandIndex = m_vpCameraExposureObject.at(nPosIndex)->m_nPatIndex;

			switch(nSearchMode)
			{
			case eNoSearchCameraExposure:
				break;

			case eTargetSearchCameraExposure:
				{

					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("TargetExposureStart:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

					BOOL bSuccess = FALSE;
					bSuccess = SwitchToTargetSearchShutter(nPosIndex, nCandIndex);

					// 					if(!bSuccess)
					// 						VisionAlignLogRecord(_T("D:\\曝光切换.txt"),_T("SwitchToTargetSearchShutter执行失败"));

					m_vbCameraExposureEnd[nPosIndex] = TRUE;
					SetEvent(m_vhCameraExposureEndEvent[nPosIndex]);

					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("TargetExposureEnd:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

				}
				break;

			case eObjectSearchCameraExposure:
				{
					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("ObjectExposureStart:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

					BOOL bSuccess = FALSE;
					bSuccess = SwitchToObjectSearchShutter(nPosIndex, nCandIndex);

					// 					if(!bSuccess)
					// 						VisionAlignLogRecord(_T("D:\\曝光切换.txt"),_T("SwitchToObjectSearchShutter执行失败"));

					m_vbCameraExposureEnd[nPosIndex] = TRUE;
					SetEvent(m_vhCameraExposureEndEvent[nPosIndex]);


					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("ObjectExposureEnd:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

				}
				break;
			case eCalibTargetSearchCameraExposure:
				{
					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("CalibTargetExposureStart:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

					BOOL bSuccess = FALSE;
					bSuccess = SwitchToCalibTargetSearchShutter(nPosIndex);

					m_vbCameraExposureEnd[nPosIndex] = TRUE;
					SetEvent(m_vhCameraExposureEndEvent[nPosIndex]);


					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("CalibTargetExposureEnd:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

				}
				break;

			case eVirtualSearchCameraExposure:
				{
					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("VirtualObjectExposureStart:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

					BOOL bSuccess = FALSE;
					bSuccess = SwitchToVirtualObjectSearchShutter(nPosIndex, nCandIndex);

					m_vbCameraExposureEnd[nPosIndex] = TRUE;
					SetEvent(m_vhCameraExposureEndEvent[nPosIndex]);


					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("VirtualObjectExposureEnd:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

				}
				break;
			case eInspectSearchCameraExposure:
				{
					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("InspectExposureStart:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

					BOOL bSuccess = FALSE;
					bSuccess = SwitchToInspectSearchShutter(nPosIndex, nCandIndex);

					m_vbCameraExposureEnd[nPosIndex] = TRUE;
					SetEvent(m_vhCameraExposureEndEvent[nPosIndex]);


					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("InspectExposureEnd:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

				}
				break;
			case eDmCodeSearchCameraExposure:
				{
					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("DmCodeExposureStart:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}

					BOOL bSuccess = FALSE;
					bSuccess = SwitchToDmCodeSearchShutter(nPosIndex);

					m_vbCameraExposureEnd[nPosIndex] = TRUE;
					SetEvent(m_vhCameraExposureEndEvent[nPosIndex]);


					// 					{
					// 						CString strTemp;
					// 						CString strOut;
					// 						CCoordPos cp;
					// 
					// 						strOut = _T("DmCodeExposureEnd:");
					// 
					// 						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					// 						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					// 					}
				}
				break;
			}

			// 			m_vbCameraExposureEnd[nPosIndex] = TRUE;
			// 			SetEvent(m_vhCameraExposureEndEvent[nPosIndex]);

		}		

		Sleep(1);
	}

	CString tempstr;
	tempstr.Format(_T("CameraExposureProcess相机曝光线程%d m_vbExitCameraExposureThread[%d] 退出"),nPosIndex);
	VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt",tempstr);
}

// 指定相机进行曝光，直到曝光完成退出
BOOL vcBaseVisionAlign::CameraExposureSetting(std::vector<int> vnPosIndex, std::vector<CameraExposureType> vsmSearchMode, int nCandIndex)
{
	if (vnPosIndex.size() < 1 || vsmSearchMode.size() < 1 || vnPosIndex.size() != vsmSearchMode.size())
	{
		return FALSE;
	}

	if (nCandIndex < 0)
	{
		return FALSE;
	}

	int i = 0;
	int nPosIndex;		
	int nPosNum = vnPosIndex.size();
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		if(nPosIndex>=GetPosNum() || 
			nPosIndex>=m_vsmSearchCameraExposureType.size() || 
			nPosIndex>=m_vbCameraExposureEnd.size() || 
			nPosIndex>=m_vhCameraExposureEndEvent.size() || 
			nPosIndex>=m_vpCameraExposureObject.size() ||
			nPosIndex>=m_vbCameraExposureStart.size())
		{
			return FALSE;
		}
	}



	// 准备设置曝光时间
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		m_vsmSearchCameraExposureType[nPosIndex] = vsmSearchMode[i];
		m_vbCameraExposureEnd[nPosIndex] = FALSE;
		m_phPosEvent[i] = m_vhCameraExposureEndEvent[nPosIndex];
		m_vpCameraExposureObject.at(nPosIndex)->m_nPatIndex= nCandIndex;
		ResetEvent(m_phPosEvent[i]);
	}

	// 开始设置曝光时间
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		m_vbCameraExposureStart[nPosIndex] = TRUE;
	}


	// 等待设置曝光时间
	scTimer tmSetExpTimer;
	tmSetExpTimer.Reset();
	BOOL bTimeOut = FALSE;
	BOOL bFinished = FALSE;
	BOOL bAllCamOnline = TRUE;
	std::vector<BOOL> vbOnline(nPosNum, FALSE);
	while (!bFinished)
	{
		if (m_bStopNow)
		{
			break;
		}

		for (i=0; i<nPosNum; i++)
		{
			// 判断各相机是否在线，避免相机掉线后出现死循环
			nPosIndex = vnPosIndex[i];
			vbOnline.at(i) = IsPosCameraOnline(nPosIndex);
			bAllCamOnline = bAllCamOnline && vbOnline.at(i);
		}
		if (!bAllCamOnline)
		{
			break;
		}

		if (WaitForMultipleObjects(nPosNum, m_phPosEvent, TRUE, 90) != WAIT_TIMEOUT)
		{
			bFinished = TRUE;
		}

		// 		if (tmSetExpTimer.GetTimeMilli(FALSE) > 8000)
		// 		{
		// 			bTimeOut = TRUE;
		// 			break;
		// 		}
	}

	if (bTimeOut)
	{
		return FALSE;
	}

	if (!bAllCamOnline)
	{		
		CString strInfo, strInfo1;
		for (i=0; i<nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			if (!vbOnline.at(i))
			{
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_CPFAST_STR_POS), nPosIndex);
				strInfo1 += strInfo;
			}
		}
		strInfo1 = strInfo1.Left(strInfo1.GetLength() - 2);
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_SSS_SSS), strInfo1, GetSysInfoString(m_psaSysInfoStrings,IDS_SB_LOST_CONNECTION));

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	return bFinished;
}

BOOL vcBaseVisionAlign::SetCurProductName( CString strCurProductName )
{
	CTotalProductData*  pTotalProductData = GetTotalProuductData();
	if (pTotalProductData == NULL)
	{
		return FALSE;
	}

	// 遍历
	int i = 0;
	for(i = 0; i < pTotalProductData->GetCount(); i++)
	{
		if (strCurProductName == pTotalProductData->GetItemName(i))
		{
			BOOL bOK = FALSE;
			bOK = SetCurProductIndex(i);

			return bOK;
		}
	}

	return FALSE;
}

BOOL vcBaseVisionAlign::SetCurProductIndex( int nCurProductIndex )
{
	if (nCurProductIndex < 0)
	{
		return FALSE;
	}

	CTotalProductData*  pTotalProductData = GetTotalProuductData();
	if (pTotalProductData == NULL)
	{
		return FALSE;
	}

	if (pTotalProductData->GetCount() <= 0 || pTotalProductData->GetCount() <= nCurProductIndex)
	{
		return FALSE;
	}

	if (nCurProductIndex == pTotalProductData->GetCurProductIndex())
	{
		return TRUE;
	}

	// 释放原来产品的定位工具20170516
	{
		//SysPlatformInfo sysPlatformInfo;
		//GetSysPlatformInfo(sysPlatformInfo);
		if (m_pPlatformInfo->m_bLoadSingleProductSearchToolEnable == TRUE)
		{
			//CProductData *pPreProductData = pTotalProductData->GetItemPtr(pTotalProductData->GetCurProductIndex());
			//if (pPreProductData != NULL)
			//{
			//	pPreProductData->DeleteObjectSearchTools();
			//	pPreProductData->DeleteTargetSearchTools();
			//	pPreProductData->DeleteVirtualObjectSearchTools();
			//	pPreProductData->DeleteCalibTargetSearchTools();
			//	pPreProductData->DeleteInspectSearchTools();
			//}
			if(!SendMessageTimeOutUpdateChangeProductSetDisplay(pTotalProductData->GetCurProductIndex(), 7))
			{
				return FALSE;
			}
		}
		// 启用大小品种且只加载单个大产品时，释放其他全部大品种的全部小品种
		else if (m_pPlatformInfo->m_bProductFaChd && m_pPlatformInfo->m_bLoadSingleProductSearchToolEnableFaChd)
		{
			int nCurProductIndexFa = 0;
			int nCurProductIndexChd =0;
			pTotalProductData->GetDlgProductIndex(nCurProductIndex, nCurProductIndexFa, nCurProductIndexChd);

			for (int i=0; i<pTotalProductData->GetProductCountFa(); i++ )
			{
				if(i == nCurProductIndexFa) continue;

				for (int j =0; j< pTotalProductData->GetProductCountChd(i); j++)
				{
					int nProductIndex = pTotalProductData->GetProductIndex(i, j);
					//CProductData *pPreProductData  = pTotalProductData->GetItemPtr(nProductIndex);
					//if (pPreProductData != NULL)
					//{
					//	pPreProductData->DeleteObjectSearchTools();
					//	pPreProductData->DeleteTargetSearchTools();
					//	pPreProductData->DeleteVirtualObjectSearchTools();
					//	pPreProductData->DeleteCalibTargetSearchTools();
					//	pPreProductData->DeleteInspectSearchTools();
					//}
					if(!SendMessageTimeOutUpdateChangeProductSetDisplay(nProductIndex, 7))
					{
						return FALSE;
					}
				}
			}
		}
	}

	pTotalProductData->SetCurProductIndex(nCurProductIndex);

	// 
	// 	CTotalCalibData* pTotalCalibData = GetTotalCalibData();
	// 	if (pTotalCalibData != NULL)
	// 	{
	// 		if (nCurProductIndex != pTotalCalibData->GetCurCalibIndex())
	// 		{
	// 			if (pTotalCalibData->GetCount() > 0 && pTotalCalibData->GetCount() > nCurProductIndex)
	// 			{
	// 				pTotalCalibData->SetCurCalibIndex(nCurProductIndex);
	// 			}
	// 			SaveTotalCalibDataInfo(FALSE);
	// 		}
	// 	}

	//-LJJ
	// 	PostMessageUpdateAllGuiAlnTargetImagePosGraphics(FALSE);
	// 	PostMessageUpdateAllGuiAlnObjectImagePosGraphics(FALSE);
	// 
	// 	PostMessageUpdateAllGuiAlnTargetLineImagePosGraphics(FALSE);
	// 	PostMessageUpdateAllGuiAlnObjectLineImagePosGraphics(FALSE);
	// 
	// 	// SY ?
	// 	PostMessageUpdateAllShowGuiTargetImagePosToDisplay(FALSE);
	// 	PostMessageUpdateAllShowGuiObjectImagePosToDisplay(FALSE);
	std::vector<int> vnPosIndex;	 
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

	// 保存到配置文件
	if(!SaveTotalProductDataInfo(FALSE))
	{
		//AfxMessageBox(_T("保存数据失败,请确保产品名称正确！"));
		return FALSE;
	}

	// 更新产品信息及相关定位工具
	if (!UpdateCurVisionASMTool(TRUE, TRUE))
	{
		return FALSE;
	}

	// 	PostMessageUpdateAllGuiAlnTargetImagePosGraphics(TRUE);
	// 	PostMessageUpdateAllShowGuiTargetImagePosToDisplay(TRUE);

	//m_cVisionAlignGui.SetAllPosSearchResult(eTargetSearch);


	return TRUE;
}

BOOL vcBaseVisionAlign::SetCurProductVirtualAln( BOOL bVAlnOn )
{	

	CTotalProductData*  pTotalProductData = GetTotalProuductData();
	if (pTotalProductData == NULL)
	{
		return FALSE;
	}

	if (m_pPlatformInfo->m_eAlignerObjectType!= eObjectVirtual)
	{
		return FALSE;
	}

	int nCurProductIndex = pTotalProductData->GetCurProductIndex();	

	pTotalProductData->GetItemPtr(nCurProductIndex)->m_pAlignerParam->SetVirtualObjectMarkEnable(bVAlnOn);

	// 保存到配置文件
	if(!SaveProductDataInfo(nCurProductIndex))
	{		
		return FALSE;
	}


	return TRUE;
}

// 根据索引设置当前产品
BOOL vcBaseVisionAlign::SetCurCalibDataIndex(int nCurProductIndex)
{
	if (nCurProductIndex < 0)
	{
		return FALSE;
	}

	CTotalCalibData* pTotalCalibData = GetTotalCalibData();
	if (pTotalCalibData == NULL)
	{
		return FALSE;
	}

	if (pTotalCalibData->GetCount() <= 0 || pTotalCalibData->GetCount() <= nCurProductIndex)
	{
		return FALSE;
	}

	if (nCurProductIndex == pTotalCalibData->GetCurCalibIndex())
	{
		return TRUE;
	}

	// 释放原来产品的定位工具20170516
	{
		//SysPlatformInfo sysPlatformInfo;
		//GetSysPlatformInfo(sysPlatformInfo);
		if (m_pPlatformInfo->m_bLoadSingleProductSearchToolEnable == TRUE)
		{
			//CCalibData *pPreCalibData = pTotalCalibData->GetItemPtr(pTotalCalibData->GetCurCalibIndex());
			//if (pPreCalibData != NULL)
			//{
			//	pPreCalibData->DeleteObjectSearchTools();
			//}
			if(!SendMessageTimeOutUpdateChangeProductSetDisplay(pTotalCalibData->GetCurCalibIndex(), 8))
			{
				return FALSE;
			}
		}
		// 启用大小品种且只加载单个大产品时，释放其他全部大品种的全部小品种
		else if (m_pPlatformInfo->m_bProductFaChd && m_pPlatformInfo->m_bLoadSingleProductSearchToolEnableFaChd)
		{
			int nCurProductIndexFa = 0;
			int nCurProductIndexChd =0;
			pTotalCalibData->GetDlgCalibIndex(nCurProductIndex, nCurProductIndexFa, nCurProductIndexChd);

			for (int i=0; i<pTotalCalibData->GetCalibCountFa(); i++ )
			{
				if(i == nCurProductIndexFa) continue;

				for (int j =0; j< pTotalCalibData->GetCalibCountChd(i); j++)
				{
					int nCalibIndex = pTotalCalibData->GetCalibIndex(i, j);
					//CCalibData *pPreCalibData  = pTotalCalibData->GetItemPtr(nCalibIndex);
					//if (pPreCalibData != NULL)
					//{
					//	pPreCalibData->DeleteObjectSearchTools();
					//}
					if(!SendMessageTimeOutUpdateChangeProductSetDisplay(nCalibIndex, 8))
					{
						return FALSE;
					}
				}
			}
		}
	}

	pTotalCalibData->SetCurCalibIndex(nCurProductIndex);

	// 保存到配置文件
	if(!SaveTotalCalibDataInfo(FALSE))
	{
		return FALSE;
	}

	return TRUE;
}

BOOL vcBaseVisionAlign::SetCurCalibDataAndProductIndex(int nCurProductIndex)
{
	if (nCurProductIndex < 0)
	{
		return FALSE;
	}

	CTotalCalibData* pTotalCalibData = GetTotalCalibData();
	if (pTotalCalibData == NULL)
	{
		return FALSE;
	}

	if (pTotalCalibData->GetCount() <= 0 || pTotalCalibData->GetCount() <= nCurProductIndex)
	{
		return FALSE;
	}

	if (nCurProductIndex == pTotalCalibData->GetCurCalibIndex())
	{
		return TRUE;
	}

	CTotalProductData*  pTotalProductData = GetTotalProuductData();
	if (pTotalProductData == NULL)
	{
		return FALSE;
	}

	if (pTotalProductData->GetCount() <= 0 || pTotalProductData->GetCount() <= nCurProductIndex)
	{
		return FALSE;
	}

	if (nCurProductIndex == pTotalProductData->GetCurProductIndex())
	{
		return TRUE;
	}

	// 释放原来产品的定位工具20170516
	{

		if (m_pPlatformInfo->m_bLoadSingleProductSearchToolEnable == TRUE)
		{
			// 释放原始标定
			if(!SendMessageTimeOutUpdateChangeProductSetDisplay(pTotalCalibData->GetCurCalibIndex(), 8))
			{
				return FALSE;
			}
			//释放原始产品
			if(!SendMessageTimeOutUpdateChangeProductSetDisplay(pTotalProductData->GetCurProductIndex(), 7))
			{
				return FALSE;
			}
		}
		// 启用大小品种且只加载单个大产品时，释放其他全部大品种的全部小品种
		else if (m_pPlatformInfo->m_bProductFaChd && m_pPlatformInfo->m_bLoadSingleProductSearchToolEnableFaChd)
		{
			int nCurProductIndexFa = 0;
			int nCurProductIndexChd =0;
			pTotalCalibData->GetDlgCalibIndex(nCurProductIndex, nCurProductIndexFa, nCurProductIndexChd);

			// 释放原始标定
			for (int i=0; i<pTotalCalibData->GetCalibCountFa(); i++ )
			{
				if(i == nCurProductIndexFa) continue;

				for (int j =0; j< pTotalCalibData->GetCalibCountChd(i); j++)
				{
					int nCalibIndex = pTotalCalibData->GetCalibIndex(i, j);

					if(!SendMessageTimeOutUpdateChangeProductSetDisplay(nCalibIndex, 8))
					{
						return FALSE;
					}
				}
			}

			//释放原始产品
			pTotalProductData->GetDlgProductIndex(nCurProductIndex, nCurProductIndexFa, nCurProductIndexChd);

			for (int i=0; i<pTotalProductData->GetProductCountFa(); i++ )
			{
				if(i == nCurProductIndexFa) continue;

				for (int j =0; j< pTotalProductData->GetProductCountChd(i); j++)
				{
					int nProductIndex = pTotalProductData->GetProductIndex(i, j);
					if(!SendMessageTimeOutUpdateChangeProductSetDisplay(nProductIndex, 7))
					{
						return FALSE;
					}
				}
			}
		}
	}


	pTotalCalibData->SetCurCalibIndex(nCurProductIndex);
	pTotalProductData->SetCurProductIndex(nCurProductIndex);


	std::vector<int> vnPosIndex;	 
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

	// 保存到配置文件
	if(!SaveTotalCalibDataInfo(FALSE))
	{
		return FALSE;
	}

	// 保存到配置文件
	if(!SaveTotalProductDataInfo(FALSE))
	{
		//AfxMessageBox(_T("保存数据失败,请确保产品名称正确！"));
		return FALSE;
	}

	// 更新产品信息及相关定位工具
	if (!UpdateCurVisionASMTool(TRUE, TRUE))
	{
		return FALSE;
	}

	return TRUE;
}

BOOL vcBaseVisionAlign::ProductEmpty(int nProductIndex)
{
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CString strModuelDir;
	GetModuleFileName(NULL, strModuelDir.GetBuffer(MAX_PATH), MAX_PATH);
	strModuelDir.ReleaseBuffer();
	strModuelDir = strModuelDir.Left(strModuelDir.ReverseFind('\\')); 

	// 清空产品数据
	CString strDir;
	strDir.Format(_T("%s\\Jobs\\%03d"), sysPlatformInfo.m_strPlatformDetailSavePath, nProductIndex+1);
	strDir = strModuelDir + strDir;
	if (!ClearDirectoryPro(strDir))
	{
		return FALSE;	
	}
	CreateDirectoryPro(strDir + _T("\\ObjectModels"));
	CreateDirectoryPro(strDir + _T("\\TargetModels"));
	CString strNewName = _T("------");
	m_pVisionASMConfig->m_TotalProductData.SetItemName(nProductIndex, strNewName);
	SaveProductDataInfo(nProductIndex);
	m_pVisionASMConfig->m_TotalProductData.ClearItem(nProductIndex);

	// 清空标定数据
	CString strCalibDir;
	strCalibDir.Format(_T("%s\\JobCalibs\\%03d"), sysPlatformInfo.m_strPlatformDetailSavePath, nProductIndex+1);
	strCalibDir = strModuelDir + strCalibDir;
	if (!ClearDirectoryPro(strCalibDir))
	{
		return FALSE;	
	}
	CreateDirectoryPro(strCalibDir + _T("\\CalibModels"));
	strNewName = _T("------");
	m_pVisionASMConfig->m_TotalCalibData.SetItemName(nProductIndex, strNewName);
	SaveCalibDataInfo(nProductIndex);
	m_pVisionASMConfig->m_TotalCalibData.ClearItem(nProductIndex);

	return TRUE;
}

BOOL vcBaseVisionAlign::ProductCopy(int nSrcProductIndex, int nDstProductIndex)
{
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	//////////////////////////////////////////////////////////////////////////
	// 复制产品

	CProductData *pSrcProduct =  m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nSrcProductIndex);
	CProductData *pDstProduct =  m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nDstProductIndex);

	//if (!m_pVisionASMConfig->m_TotalProductData.ClearItem(nDstProductIndex))
	//{
	//	return FALSE;
	//}
	SendMessageTimeOutUpdateChangeProductSetDisplay(nDstProductIndex, 7);

	CString strPrevDstProductName;
	strPrevDstProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nDstProductIndex);

	if (!m_pVisionASMConfig->m_TotalProductData.CopyItem(nSrcProductIndex, nDstProductIndex))
	{
		return FALSE;
	}

	if (!m_pVisionASMConfig->m_TotalProductData.SetItemName(nDstProductIndex, strPrevDstProductName))
	{
		return FALSE;
	}

	if (pDstProduct != NULL)
	{
		pDstProduct->ResetTargetSearchTools();
		pDstProduct->ResetObjectSearchTools();
		pDstProduct->ResetVirtualObjectSearchTools();
		pDstProduct->ResetCalibTargetSearchTools();
		pDstProduct->ResetInspectSearchTools();
	}

	int nSrcProductIndexFa = 0;
	int nSrcProductIndexChd = 0;
	m_pVisionASMConfig->m_TotalProductData.GetDlgProductIndex(nSrcProductIndex, nSrcProductIndexFa, nSrcProductIndexChd);

	int nDstProductIndexFa = 0;
	int nDstProductIndexChd = 0;
	m_pVisionASMConfig->m_TotalProductData.GetDlgProductIndex(nDstProductIndex, nDstProductIndexFa, nDstProductIndexChd);

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nCurProductIndexFa = 0;
	int nCurProductIndexChd = 0;
	m_pVisionASMConfig->m_TotalProductData.GetDlgProductIndex(nCurProductIndex, nCurProductIndexFa, nCurProductIndexChd);


	// 目标模板
	if (nSrcProductIndex != nCurProductIndex)
	{
		InitAlnTargetSearchToolRepository(nSrcProductIndex);
	}
	int i = 0, j = 0;
	if (pSrcProduct->m_pAlignerParam->GetTargetMarkType() == eTargetOnline)
	{
		CBaseSearchTool* pTargetSearchTool = NULL;
		for (i=0; i<pSrcProduct->m_pAlignerParam->GetTargetMarkPatternNum(); i++)
		{
			for(j = 0; j<TARGETCANDIDATENUM; j++)
			{
				pTargetSearchTool = GetRepoAlnTargetSearchTool(nSrcProductIndex, i, j);
				SetRepoAlnTargetSearchTool(nDstProductIndex, i, j, pTargetSearchTool);
			}
		}
		SaveAlnTargetSearchToolRepository(nDstProductIndex);
		pDstProduct->m_bAlnTargetSearchToolInited = TRUE;
	}

	// 对象模板
	if (nSrcProductIndex != nCurProductIndex)
	{
		InitAlnObjectSearchToolRepository(nSrcProductIndex);
	}
	if (pSrcProduct->m_pAlignerParam->GetObjectMarkType() != eObjectBench)
	{
		CBaseSearchTool* pObjSearchTool = NULL;
		for (i=0; i<pSrcProduct->m_pAlignerParam->GetObjectMarkPatternNum(); i++)
		{
			for(j = 0; j<OBJECTCANDIDATENUM; j++)
			{
				pObjSearchTool = GetRepoAlnObjectSearchTool(nSrcProductIndex, i, j);
				SetRepoAlnObjectSearchTool(nDstProductIndex, i, j, pObjSearchTool);
			}
		}
		SaveAlnObjectSearchToolRepository(nDstProductIndex);
		pDstProduct->m_bAlnObjectSearchToolInited = TRUE;
	}

	// 虚拟对象模板
	if (nSrcProductIndex != nCurProductIndex)
	{
		InitAlnVirtualObjectSearchToolRepository(nSrcProductIndex);
	}
	if (pSrcProduct->m_pAlignerParam->GetObjectMarkType() == eObjectVirtual)
	{
		CBaseSearchTool* pVirtualObjSearchTool = NULL;
		for (i=0; i<pSrcProduct->m_pAlignerParam->GetObjectMarkPatternNum()/*GetVirtualObjectMarkPatternNum()*/; i++)
		{
			for(j = 0; j<VIRTUALOBJECTCANDIDATENUM; j++)
			{
				GetRepoAlnVirtualObjectSearchTool(nSrcProductIndex, i, j);
				SetRepoAlnVirtualObjectSearchTool(nDstProductIndex, i, j, pVirtualObjSearchTool);
			}
		}
		SaveAlnVirtualObjectSearchToolRepository(nDstProductIndex);
		pDstProduct->m_bAlnVirtualObjectSearchToolInited = TRUE;
	}

	// 关联标定模板
	if (nSrcProductIndex != nCurProductIndex)
	{
		InitAlnCalibTargetSearchToolRepository(nSrcProductIndex);
	}
	if (pSrcProduct->m_pAlignerParam->GetTargetObjectCamSeparateEnable() == TRUE ||
		(pSrcProduct->m_pAlignerParam->GetTargetObjectCamSeparateEnable() == FALSE && pSrcProduct->m_pAlignerParam->GetTargetCalibUseBoardEnable() == TRUE))
	{
		CBaseSearchTool* pCalibTargetSearchTool = NULL;
		for (i=0; i<pSrcProduct->m_pAlignerParam->GetCalibTargetMarkPatternNum(); i++)
		{
			for(j = 0; j<ALNCALIBTARGETCANDIDATENUM; j++)
			{
				pCalibTargetSearchTool = GetRepoAlnCalibTargetSearchTool(nSrcProductIndex, i, j);
				SetRepoAlnCalibTargetSearchTool(nDstProductIndex, i, j, pCalibTargetSearchTool);
			}
		}
		SaveAlnCalibTargetSearchToolRepository(nDstProductIndex);
		pDstProduct->m_bAlnCalibTargetSearchToolInited = TRUE;
	}

	// 检测模板
	if (nSrcProductIndex != nCurProductIndex)
	{
		InitAlnInspectSearchToolRepository(nSrcProductIndex);
	}
	if (pSrcProduct->m_pAlignerParam->GetSysPlatformInspectEnable() == TRUE)
	{
		CBaseSearchTool* pInspectSearchTool = NULL;
		for (i=0; i<pSrcProduct->m_pAlignerParam->GetInspectMarkPatternNum(); i++)
		{
			for(j = 0; j<INSPECTCANDIDATENUM; j++)
			{
				pInspectSearchTool = GetRepoAlnInspectSearchTool(nSrcProductIndex, i, j);
				SetRepoAlnInspectSearchTool(nDstProductIndex, i, j, pInspectSearchTool);
			}
		}
		SaveAlnInspectSearchToolRepository(nDstProductIndex);
		pDstProduct->m_bAlnInspectSearchToolInited = TRUE;
	}

	if (sysPlatformInfo.m_bLoadSingleProductSearchToolEnable)
	{
		if (nSrcProductIndex != nCurProductIndex && pSrcProduct != NULL)
		{
			//m_pVisionASMConfig->m_TotalProductData.ClearItem(nSrcProductIndex);
			SendMessageTimeOutUpdateChangeProductSetDisplay(nSrcProductIndex, 7);
		}
		if (nDstProductIndex != nCurProductIndex && pDstProduct != NULL)
		{
			//m_pVisionASMConfig->m_TotalProductData.ClearItem(nDstProductIndex);
			SendMessageTimeOutUpdateChangeProductSetDisplay(nDstProductIndex, 7);
		}
	}
	else if (sysPlatformInfo.m_bProductFaChd && sysPlatformInfo.m_bLoadSingleProductSearchToolEnableFaChd)
	{
		if (nSrcProductIndexFa != nCurProductIndexFa && pSrcProduct != NULL)
		{
			//m_pVisionASMConfig->m_TotalProductData.ClearItem(nSrcProductIndex);
			SendMessageTimeOutUpdateChangeProductSetDisplay(nSrcProductIndex, 7);
		}
		if (nDstProductIndexFa != nCurProductIndexFa && pDstProduct != NULL)
		{
			//m_pVisionASMConfig->m_TotalProductData.ClearItem(nDstProductIndex);
			SendMessageTimeOutUpdateChangeProductSetDisplay(nDstProductIndex, 7);
		}
	}

	CopyXMLDataFile(nSrcProductIndex, nDstProductIndex);



	//////////////////////////////////////////////////////////////////////////
	// 复制标定

	int nSrcCalibIndex = nSrcProductIndex;
	int nDstCalibIndex = nDstProductIndex;

	CCalibData *pSrcCalib =  m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nSrcCalibIndex);
	CCalibData *pDstCalib =  m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nDstCalibIndex);

	//if (!m_pVisionASMConfig->m_TotalCalibData.ClearItem(nDstCalibIndex))
	//{
	//	return FALSE;
	//}
	SendMessageTimeOutUpdateChangeProductSetDisplay(nDstCalibIndex, 8);

	CString strPrevDstCalibName;
	strPrevDstCalibName = m_pVisionASMConfig->m_TotalCalibData.GetItemName(nDstCalibIndex);

	if (!m_pVisionASMConfig->m_TotalCalibData.CopyItem(nSrcCalibIndex, nDstCalibIndex))
	{
		return FALSE;
	}

	if (!m_pVisionASMConfig->m_TotalCalibData.SetItemName(nDstCalibIndex, strPrevDstCalibName))
	{
		return FALSE;
	}

	if (pDstCalib != NULL)
	{
		pDstCalib->ResetObjectSearchTools();
	}

	int nSrcCalibIndexFa = 0;
	int nSrcCalibIndexChd = 0;
	m_pVisionASMConfig->m_TotalCalibData.GetDlgCalibIndex(nSrcCalibIndex, nSrcCalibIndexFa, nSrcCalibIndexChd);

	int nDstCalibIndexFa = 0;
	int nDstCalibIndexChd = 0;
	m_pVisionASMConfig->m_TotalCalibData.GetDlgCalibIndex(nDstCalibIndex, nDstCalibIndexFa, nDstCalibIndexChd);

	int nCurCalibIndex = m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	int nCurCalibIndexFa = 0;
	int nCurCalibIndexChd = 0;
	m_pVisionASMConfig->m_TotalCalibData.GetDlgCalibIndex(nCurCalibIndex, nCurCalibIndexFa, nCurCalibIndexChd);


	// 标定对象模板
	if (nSrcCalibIndex != nCurCalibIndex)
	{
		InitCalibObjectSearchToolRepository(nSrcCalibIndex);
	}
	CBaseSearchTool* pCalibObjSearchTool = NULL;
	for (i=0; i<sysPlatformInfo.m_nPositionNum; i++)
	{
		for(j = 0; j<CALIBOBJECTCANDIDATENUM; j++)
		{
			pCalibObjSearchTool = GetRepoCalibObjectSearchTool(nSrcCalibIndex, i, j);
			SetRepoCalibObjectSearchTool(nDstCalibIndex, i, j, pCalibObjSearchTool);
		}
	}
	SaveCalibObjectSearchToolRepository(nDstCalibIndex);
	pDstCalib->m_bCalibObjectSearchToolInited = TRUE;


	if (sysPlatformInfo.m_bLoadSingleProductSearchToolEnable)
	{
		if (nSrcCalibIndex != nCurCalibIndex && pSrcProduct != NULL)
		{
			//m_pVisionASMConfig->m_TotalCalibData.ClearItem(nSrcCalibIndex);
			SendMessageTimeOutUpdateChangeProductSetDisplay(nSrcCalibIndex, 8);
		}
		if (nDstCalibIndex != nCurCalibIndex && pDstProduct != NULL)
		{
			//m_pVisionASMConfig->m_TotalCalibData.ClearItem(nDstCalibIndex);
			SendMessageTimeOutUpdateChangeProductSetDisplay(nDstCalibIndex, 8);
		}
	}
	else if (sysPlatformInfo.m_bProductFaChd && sysPlatformInfo.m_bLoadSingleProductSearchToolEnableFaChd)
	{
		if (nSrcCalibIndexFa != nCurCalibIndexFa && pSrcProduct != NULL)
		{
			//m_pVisionASMConfig->m_TotalCalibData.ClearItem(nSrcCalibIndex);
			SendMessageTimeOutUpdateChangeProductSetDisplay(nSrcCalibIndex, 8);
		}
		if (nDstCalibIndexFa != nCurCalibIndexFa && pDstProduct != NULL)
		{
			//m_pVisionASMConfig->m_TotalCalibData.ClearItem(nDstCalibIndex);
			SendMessageTimeOutUpdateChangeProductSetDisplay(nDstCalibIndex, 8);
		}
	}

	CopyCalibXMLDataFile(nSrcCalibIndex, nDstCalibIndex);

	return TRUE;
}

BOOL vcBaseVisionAlign::ProductNew(int nProductIndexFa, int nProductIndexChd)
{
	// 为了和界面中新建品种操作操作统一，指令流程中新建品种时，也将当前品种索引切换至新建品种

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	// 新建品种后，当前品种索引会切换至新建品种，因此需要根据系统配置清空内存中切换前品种的定位工具
	int nPrevProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (sysPlatformInfo.m_bLoadSingleProductSearchToolEnable)
	{
		//m_pVisionASMConfig->m_TotalProductData.ClearItem(nPrevProductIndex);
		SendMessageTimeOutUpdateChangeProductSetDisplay(nPrevProductIndex, 7);
	}
	else if (sysPlatformInfo.m_bProductFaChd && sysPlatformInfo.m_bLoadSingleProductSearchToolEnableFaChd)
	{
		for (int i=0; i<m_pVisionASMConfig->m_TotalProductData.GetProductCountFa(); i++ )
		{
			if(i == nProductIndexFa) continue;
			for (int j=0; j<m_pVisionASMConfig->m_TotalProductData.GetProductCountChd(i); j++)
			{
				int nTempIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(i, j);
				//m_pVisionASMConfig->m_TotalProductData.ClearItem(nTempIndex);
				SendMessageTimeOutUpdateChangeProductSetDisplay(nTempIndex, 7);
			}
		}
	}

	// 新建品种
	int nCount = m_pVisionASMConfig->m_TotalProductData.GetCount();
	CProductData product(sysPlatformInfo);
	m_pVisionASMConfig->m_TotalProductData.AddItem(product);
	CString strNewName = _T("------");
	m_pVisionASMConfig->m_TotalProductData.SetItemName(nCount, strNewName);
	m_pVisionASMConfig->m_TotalProductData.SetProductIndex(nProductIndexFa, nProductIndexChd, nCount);
	m_pVisionASMConfig->m_TotalProductData.SetCurProductIndex(nCount);
	SaveTotalProductDataInfo(FALSE);
	SaveProductDataInfo(nCount);


	//////////////////////////////////////////////////////////////////////////
	// 根据产品品种的新建方式，相应处理标定品种

	// 新建品种后，当前品种索引会切换至新建品种，因此需要根据系统配置清空内存中切换前品种的定位工具
	int nCalibPrevProductIndex = m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	if (sysPlatformInfo.m_bLoadSingleProductSearchToolEnable)
	{
		//m_pVisionASMConfig->m_TotalCalibData.ClearItem(nCalibPrevProductIndex);
		SendMessageTimeOutUpdateChangeProductSetDisplay(nCalibPrevProductIndex, 8);
	}
	else if (sysPlatformInfo.m_bProductFaChd && sysPlatformInfo.m_bLoadSingleProductSearchToolEnableFaChd)
	{
		for (int i=0; i<m_pVisionASMConfig->m_TotalCalibData.GetCalibCountFa(); i++ )
		{
			if(i == nProductIndexFa) continue;
			for (int j=0; j<m_pVisionASMConfig->m_TotalCalibData.GetCalibCountChd(i); j++)
			{
				int nTempIndex = m_pVisionASMConfig->m_TotalCalibData.GetCalibIndex(i, j);
				//m_pVisionASMConfig->m_TotalCalibData.ClearItem(nTempIndex);
				SendMessageTimeOutUpdateChangeProductSetDisplay(nTempIndex, 8);
			}
		}
	}

	// 新建品种
	int nCalibCount = m_pVisionASMConfig->m_TotalCalibData.GetCount();
	CCalibData calibProduct(sysPlatformInfo);
	m_pVisionASMConfig->m_TotalCalibData.AddItem(calibProduct);
	strNewName = _T("------");
	m_pVisionASMConfig->m_TotalCalibData.SetItemName(nCalibCount, strNewName);
	m_pVisionASMConfig->m_TotalCalibData.SetCalibIndex(nProductIndexFa, nProductIndexChd, nCalibCount);
	m_pVisionASMConfig->m_TotalCalibData.SetCurCalibIndex(nCalibCount);
	SaveTotalCalibDataInfo(FALSE);
	SaveCalibDataInfo(nCalibCount);


	//////////////////////////////////////////////////////////////////////////
	// 当前品种索引切换至新建品种后，更新定位对位工具
	if (!UpdateCurVisionASMTool(TRUE, TRUE))
	{
		return FALSE;
	}

	return TRUE;
}

//拷贝产品的SearchData.xml文件和Camera.xml文件
BOOL vcBaseVisionAlign::CopyXMLDataFile(int nSrcProductIndex, int nDstProductIndex)
{
	CString strEXEDir;
	GetModuleFileName(NULL, strEXEDir.GetBuffer(MAX_PATH), MAX_PATH);    
	strEXEDir.ReleaseBuffer();
	strEXEDir = strEXEDir.Left(strEXEDir.ReverseFind('\\')); 

	CString strSrcName;
	CString strDstName;
	strSrcName.Format(_T("%03d"),nSrcProductIndex+1);
	strDstName.Format(_T("%03d"),nDstProductIndex+1);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CString strSrcDir = strEXEDir + sysPlatformInfo.m_strPlatformDetailSavePath 
		+ _T("\\Jobs\\") + strSrcName;
	CString strDstDir = strEXEDir + sysPlatformInfo.m_strPlatformDetailSavePath 
		+ _T("\\Jobs\\") + strDstName;

	CFileFind findFile;
	BOOL IsFild, IsDir;
	IsFild = FALSE;
	IsDir = FALSE;
	IsFild = findFile.FindFile(strSrcDir);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	if (!IsDir)
	{
		return FALSE;
	}
	IsFild = FALSE;
	IsDir = FALSE;
	IsFild = findFile.FindFile(strDstDir);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	if (!IsDir)
	{
		return FALSE;
	}

	CString strSrcSearchDataDir = strSrcDir + _T("\\SearchData.xml");
	CString strDstSearchDataDir = strDstDir + _T("\\SearchData.xml");
	CString strSrcCameraDataDir = strSrcDir + _T("\\Camera.xml");
	CString strDstCameraDataDir = strDstDir + _T("\\Camera.xml");

	BOOL bResult = CopyFile(strSrcSearchDataDir,strDstSearchDataDir,FALSE);
	bResult = CopyFile(strSrcCameraDataDir,strDstCameraDataDir,FALSE) && bResult;

	return bResult; 
}

BOOL vcBaseVisionAlign::CopyCalibXMLDataFile(int nSrcProductIndex, int nDstProductIndex)
{
	CString strEXEDir;
	GetModuleFileName(NULL, strEXEDir.GetBuffer(MAX_PATH), MAX_PATH);    
	strEXEDir.ReleaseBuffer();
	strEXEDir = strEXEDir.Left(strEXEDir.ReverseFind('\\')); 

	SysPlatformInfo platInfo;
	CString strSrcName;
	CString strDstName;
	strSrcName.Format(_T("%03d"),nSrcProductIndex+1);
	strDstName.Format(_T("%03d"),nDstProductIndex+1);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CString strSrcDir = strEXEDir + sysPlatformInfo.m_strPlatformDetailSavePath 
		+ _T("\\JobCalibs\\") + strSrcName;
	CString strDstDir = strEXEDir + sysPlatformInfo.m_strPlatformDetailSavePath 
		+ _T("\\JobCalibs\\") + strDstName;

	CFileFind findFile;
	BOOL IsFild, IsDir;
	IsFild = FALSE;
	IsDir = FALSE;
	IsFild = findFile.FindFile(strSrcDir);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	if (!IsDir)
	{
		return FALSE;
	}
	IsFild = FALSE;
	IsDir = FALSE;
	IsFild = findFile.FindFile(strDstDir);
	while (IsFild)
	{
		IsFild = findFile.FindNextFile();
		IsDir = findFile.IsDirectory();
		if(IsDir) break;
	}
	if (!IsDir)
	{
		return FALSE;
	}

	CString strSrcDataDir = strSrcDir + _T("\\CalibMoveImagePos.xml");
	CString strDstDataDir = strDstDir + _T("\\CalibMoveImagePos.xml");

	BOOL bResult = CopyFile(strSrcDataDir,strDstDataDir,FALSE);

	return bResult; 
}


BOOL vcBaseVisionAlign::CreateSearchTool( CSearchToolType cSearchToolType, CBaseSearchTool** ppNewBaseSearchTool )
{
	if (ppNewBaseSearchTool == NULL)
	{
		return FALSE;
	}

	// 根据定位工具类型创建定位工具
	CBaseSearchTool* pBaseSearchTool = NULL;
	BOOL bOK = TRUE;
	switch (cSearchToolType)
	{
	case eQuickSearchTool:
		{
			pBaseSearchTool = new CQuickSearchTool;
		}
		break;
	case ePatternSearchTool:
		{
			pBaseSearchTool = new CPatternSearchTool;
		}
		break;
	case eLineSearchTool:
		{
			pBaseSearchTool = new CLineSearchTool;
		}
		break;
	case eCornerSearchTool:
		{
			pBaseSearchTool = new CCornerSearchTool;
		}
		break;
	case eCircleSearchTool:
		{
			pBaseSearchTool = new CCircleSearchTool;
		}
		break;
	case eCrossSearchTool:
		{
			pBaseSearchTool = new CCrossSearchTool;
		}
		break;
	case ePatCornerSearchTool:
		{
			pBaseSearchTool = new CPatCornerSearchTool;
		}
		break;
	case eProCircleSearchTool:
		{
			pBaseSearchTool = new CProCircleSearchTool;
		}
		break;
	case eFixedPosSearchTool:
		{
			pBaseSearchTool = new CFixedPosSearchTool;
		}
		break;
	case ePatternCornerSearchTool:
		{
			pBaseSearchTool = new CPatternCornerSearchTool;
		}
		break;
	case eCombinedQuickSearchTool:
		{
			pBaseSearchTool = new CCombinedQuickSearch;
		}
		break;
	case eCombinedPatternSearchTool:
		{
			pBaseSearchTool = new CCombinedPatternSearchTool;
		}
		break;
	case eBaseCornerSearchTool:
		{
			pBaseSearchTool = new CBaseCornerSearchTool;
		}
		break;
	case ePatternSearchCheckTool:
		{
			pBaseSearchTool = new CPatternSearchCheckTool;
		}
		break;
	case eQuickSearchCheckTool:
		{
			pBaseSearchTool = new CQuickSearchCheckTool;
		}
		break;
	case eQuickSearchObroundTool:
		{
			pBaseSearchTool = new CQuickSearchObroundTool;
		}
		break;
	case ePatternSearchObroundTool:
		{
			pBaseSearchTool = new CPatternSearchObroundTool;
		}
		break;
	case eMPatternSearchTool:
		{
			pBaseSearchTool = new CMPatternSearchTool;
		}
		break;
	case eMQuickSearchTool:
		{
			pBaseSearchTool = new CMQuickSearchTool;
		}
		break;
	case eMQuickCornerSearchTool:
		{
			pBaseSearchTool = new CMQuickCornerSearchTool;
		}
		break;
	case eMQuickPickCornerSearchTool:
		{
			pBaseSearchTool = new CMQuickPickCornerSearchTool;
		}
		break;
	case eQuickSearchGenRectTool:
		{
			pBaseSearchTool = new CQuickSearchGenRectTool;
		}
		break;
	case ePatternSearchGenRectTool:
		{
			pBaseSearchTool = new CPatternSearchGenRectTool;
		}
		break;
	case ePatternLineSearchTool:
		{
			pBaseSearchTool = new CPatternLineSearchTool;
		}
		break;	
	case e2PatternSearchTool:
		{
			pBaseSearchTool = new C2PatternSearchTool;
		}
		break;
	case eQuickLineCircleSearchTool:
		{
			pBaseSearchTool = new CQuickLineCircleTool;
		}
		break;
	case ePatternLineCircleSearchTool:
		{
			pBaseSearchTool = new CPatternLineCircleTool;
		}
		break;
	case ePatternCircleSearchTool:
		{
			pBaseSearchTool = new CPatternCircleSearchTool;
		}
		break;
	case eQuickSearchCheckLineTool:
		{
			pBaseSearchTool = new CQuickSearchCheckLineTool;
		}
		break;
	case ePatternSearchCheckLineTool:
		{
			pBaseSearchTool = new CPatternSearchCheckLineTool;
		}
		break;
	case ePatternBlobSearchTool:
		{
			pBaseSearchTool = new CPatternBlobSearchTool;

		}
		break;
	case eCornerSearchCheckTool:
		{
			pBaseSearchTool = new CCornerSearchCheckTool;
		}
		break;
	case eRectSearchTool:
		{
			pBaseSearchTool = new CRectSearchTool;
		}
		break;
	case ePatternRectSearchTool:
		{
			pBaseSearchTool = new CPatternRectSearchTool;
		}
		break;
	case eAreaInspectTool:
		{
			pBaseSearchTool = new CAreaInspectTool;
		}
		break;
	case eAreaInspectToolEx:
		{
			pBaseSearchTool = new CAreaInspectToolEx;
		}
		break;
	case eChordSearchTool:
		{
			pBaseSearchTool = new CChordSearchTool;
		}
		break;
	case eTwoPatModelSearchTool:
		{
			pBaseSearchTool = new CTwoPatModelSearchTool;
		}
		break;
	case eMPatternCornerSearchTool:
		{
			pBaseSearchTool = new CMPatternCornerSearchTool;
		}
		break;
	case eMPatternPickCornerSearchTool:
		{
			pBaseSearchTool = new CMPatternPickCornerSearchTool;
		}
		break;
	case ePatternCornerCircleSearchTool:
		{
			pBaseSearchTool = new CPatternCornerCircleSearchTool;
		}
		break;
	case eQuickCornerCircleSearchTool:
		{
			pBaseSearchTool = new CQuickCornerCircleSearchTool;
		}
		break;
	case ePatternPosLineDistanceTool:
		{
			pBaseSearchTool = new CPatternPosLineDistanceTool;
		}
		break;
	case eCornerSearchCheckInspectTool:
		{
			pBaseSearchTool = new CCornerCheckSearchTool;
		}
		break;
	case eCircleCornerSearchCheckInspectTool:
		{
			pBaseSearchTool = new CCircleCornerCheckSearchTool;
		}
		break;
	case ePatternDouleSearchTool:
		{
			pBaseSearchTool = new CPatternDoubleSearchTool;
		}
		break;
	case ePatternChordSearchTool:
		{
			pBaseSearchTool = new CPatternChordSearchTool;
		}
		break;
	case eQuickMulCircleSearchTool:
		{
			pBaseSearchTool = new CQuickMulCircleSearchTool;
		}
		break;
	case eDmCodeCalibrateTool:
		{
			pBaseSearchTool = new CDmCodeCalibrateTool;
		}
		break;
	case ePatternCircle4LineSearchTool:
		{
			pBaseSearchTool = new CPatternCircle4LineSearchTool;
		}
		break;
	case eQuickCircle4LineSearchTool:
		{
			pBaseSearchTool = new CQuickCircle4LineSearchTool;
		}
		break;
	case eSpecialPickSearchTool:
		{
			pBaseSearchTool = new CSpecialPickSearchTool;
		}
		break;
	case ePatternCornerLineSearchTool:
		{
			pBaseSearchTool = new CPatternCornerLineSearchTool;
		}
		break;
	case ePatternMulCircleSearchTool:
		{
			pBaseSearchTool = new CPatternMulCircleSearchTool;
		}
		break;
	case ePatternCornerMulCircleSearchTool:
		{
			pBaseSearchTool = new CPatternCornerMulCircleSearchTool;
		}
		break;
	case ePatternCornerMulObroundTool:
		{
			pBaseSearchTool = new CPatternCornerMulObroundTool;
		}
		break;
	case eQuickCornerMulObroundTool:
		{
			pBaseSearchTool = new CQuickCornerMulObroundTool;
		}
		break;
	case eACFInspectTool:
		{
			pBaseSearchTool = new CACFInspectTool;
		}
		break;
	case eVirtualRectSearchTool:
		{
			pBaseSearchTool = new CVirtualRectSearchTool;
		}
		break;
	case ePatternVirtualRectSearchTool:
		{
			pBaseSearchTool = new CPatternVirtualRectSearchTool;
		}
		break;
	case eTwoQuickModelSearchTool:
		{
			pBaseSearchTool = new CTwoQuickModelSearchTool;
		}
		break;
	case eIdReaderDmCodeTool:
		{
			pBaseSearchTool = new CIdReaderDmCodeTool;
		}
		break;
	case eIdReaderBarCodeTool:
		{
			pBaseSearchTool = new CIdReaderBarCodeTool;
		}
		break;
	case eCombinationCornerSearchTool:
		{
			pBaseSearchTool = new CCombinationCornerSearchTool;
		}
		break;
	case eMQuickPickSearchTool:
		{
			pBaseSearchTool = new CMQuickPickSearchTool;
		}
		break;
	case eMPatternPickSearchTool:
		{
			pBaseSearchTool = new CMPatternPickSearchTool;
		}
		break;
	case eQuickPosLineDistanceTool:
		{
			pBaseSearchTool = new CQuickPosLineDistanceTool;
		}
		break;
	case eAreaInspectPickTool:
		{
			pBaseSearchTool = new CAreaInspectPickTool;
		}
		break;
	default:
		{
			bOK = FALSE;
		}
		break;

	}

	*ppNewBaseSearchTool = pBaseSearchTool;

	return bOK;
}

BOOL vcBaseVisionAlign::CloneSearchTool( CBaseSearchTool* pBaseSearchTool, CBaseSearchTool** ppNewBaseSearchTool )
{

	if (pBaseSearchTool == NULL || ppNewBaseSearchTool == NULL)
	{
		return FALSE;
	}

	*ppNewBaseSearchTool = NULL;
	// 根据定位工具类型创建定位工具（采用拷贝构造赋值）
	switch (pBaseSearchTool->GetSearchToolType())
	{
	case eQuickSearchTool:
		{
			CQuickSearchTool* pQuickSearchTool = (CQuickSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickSearchTool(*pQuickSearchTool);
		}
		break;
	case ePatternSearchTool:
		{
			CPatternSearchTool* pPatternSearchTool = (CPatternSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternSearchTool(*pPatternSearchTool);
		}
		break;
	case eLineSearchTool:
		{
			CLineSearchTool* pLineSearchTool = (CLineSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CLineSearchTool(*pLineSearchTool);
		}
		break;
	case eCornerSearchTool:
		{
			CCornerSearchTool* pCornerSearchTool = (CCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCornerSearchTool(*pCornerSearchTool);
		}
		break;
	case eCircleSearchTool:
		{
			CCircleSearchTool* pCircleSearchTool = (CCircleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCircleSearchTool(*pCircleSearchTool);
		}
		break;
	case eCrossSearchTool:
		{
			CCrossSearchTool* pCrossSearchTool = (CCrossSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCrossSearchTool(*pCrossSearchTool);
		}
		break;
	case ePatCornerSearchTool:
		{
			CPatCornerSearchTool* pPatCornerSearchTool = (CPatCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatCornerSearchTool(*pPatCornerSearchTool);
		}
		break;
	case eProCircleSearchTool:
		{
			CProCircleSearchTool* pProCircleSearchTool = (CProCircleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CProCircleSearchTool(*pProCircleSearchTool);
		}
		break;
	case eFixedPosSearchTool:
		{
			CFixedPosSearchTool* pFixedPosSearchTool = (CFixedPosSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CFixedPosSearchTool(*pFixedPosSearchTool);
		}
		break;
	case ePatternCornerSearchTool:
		{
			CPatternCornerSearchTool* pPatternCornerSearchTool = (CPatternCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternCornerSearchTool(*pPatternCornerSearchTool);
		}
		break;
	case eCombinedQuickSearchTool:
		{
			CCombinedQuickSearch* pCombinedQuickSearchTool = (CCombinedQuickSearch*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCombinedQuickSearch(*pCombinedQuickSearchTool);
		}
		break;
	case eCombinedPatternSearchTool:
		{
			CCombinedPatternSearchTool* pCombinedPatternSearchTool = (CCombinedPatternSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCombinedPatternSearchTool(*pCombinedPatternSearchTool);
		}
		break;
	case eBaseCornerSearchTool:
		{
			CBaseCornerSearchTool* pBaseCornerSearchTool = (CBaseCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CBaseCornerSearchTool(*pBaseCornerSearchTool);
		}
		break;
	case ePatternSearchCheckTool:
		{
			CPatternSearchCheckTool* pPatternSearchCheckTool = (CPatternSearchCheckTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternSearchCheckTool(*pPatternSearchCheckTool);
		}
		break;
	case eQuickSearchCheckTool:
		{
			CQuickSearchCheckTool* pQuickSearchCheckTool = (CQuickSearchCheckTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickSearchCheckTool(*pQuickSearchCheckTool);
		}
		break;
	case eQuickSearchObroundTool:
		{
			CQuickSearchObroundTool* pQuickSearchObroundTool = (CQuickSearchObroundTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickSearchObroundTool(*pQuickSearchObroundTool);
		}
		break;
	case ePatternSearchObroundTool:
		{
			CPatternSearchObroundTool* pPatternSearchObroundTool = (CPatternSearchObroundTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternSearchObroundTool(*pPatternSearchObroundTool);
		}
		break;
	case eMPatternSearchTool:
		{
			CMPatternSearchTool* pMPatternSearchTool = (CMPatternSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CMPatternSearchTool(*pMPatternSearchTool);
		}
		break;
	case eMQuickSearchTool:
		{
			CMQuickSearchTool* pMQuickSearchTool = (CMQuickSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CMQuickSearchTool(*pMQuickSearchTool);
		}
		break;
	case eMQuickCornerSearchTool:
		{
			CMQuickCornerSearchTool* pMQuickCornerSearchTool = (CMQuickCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CMQuickCornerSearchTool(*pMQuickCornerSearchTool);
		}
		break;
	case eMQuickPickCornerSearchTool:
		{
			CMQuickPickCornerSearchTool* pMQuickPickCornerSearchTool = (CMQuickPickCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CMQuickPickCornerSearchTool(*pMQuickPickCornerSearchTool);
		}
		break;
	case eQuickSearchGenRectTool:
		{
			CQuickSearchGenRectTool* pQuickSearchGenRectTool = (CQuickSearchGenRectTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickSearchGenRectTool(*pQuickSearchGenRectTool);
		}
		break;
	case ePatternSearchGenRectTool:
		{
			CPatternSearchGenRectTool* pPatternSearchGenRectTool = (CPatternSearchGenRectTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternSearchGenRectTool(*pPatternSearchGenRectTool);
		}
		break;
	case ePatternLineSearchTool:
		{
			CPatternLineSearchTool* pPatternLineSearchTool = (CPatternLineSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternLineSearchTool(*pPatternLineSearchTool);
		}
		break;
	case e2PatternSearchTool:
		{
			C2PatternSearchTool* p2PatternSearchTool = (C2PatternSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new C2PatternSearchTool(*p2PatternSearchTool);
		}
		break;
	case eQuickLineCircleSearchTool:
		{
			CQuickLineCircleTool* pQuickLineCircleSearchTool = (CQuickLineCircleTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickLineCircleTool(*pQuickLineCircleSearchTool);
		}
		break;
	case ePatternLineCircleSearchTool:
		{
			CPatternLineCircleTool* pPatternLineCircleSearchTool = (CPatternLineCircleTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternLineCircleTool(*pPatternLineCircleSearchTool);
		}
		break;
	case ePatternCircleSearchTool:
		{
			CPatternCircleSearchTool* pPatternCircleSearchTool = (CPatternCircleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternCircleSearchTool(*pPatternCircleSearchTool);
		}
		break;
	case eQuickSearchCheckLineTool:
		{
			CQuickSearchCheckLineTool* pQuickSearchCheckLineTool = (CQuickSearchCheckLineTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickSearchCheckLineTool(*pQuickSearchCheckLineTool);
		}
		break;
	case ePatternSearchCheckLineTool:
		{
			CPatternSearchCheckLineTool* pPatternSearchCheckLineTool = (CPatternSearchCheckLineTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternSearchCheckLineTool(*pPatternSearchCheckLineTool);
		}
		break;
	case ePatternBlobSearchTool:
		{
			CPatternBlobSearchTool* pPatternBlobSearchTool = (CPatternBlobSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternBlobSearchTool(*pPatternBlobSearchTool);
		}
		break;
	case eCornerSearchCheckTool:
		{
			CCornerSearchCheckTool* pCornerSearchCheckTool = (CCornerSearchCheckTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCornerSearchCheckTool(*pCornerSearchCheckTool);
		}
		break;
	case eRectSearchTool:
		{
			CRectSearchTool* pRectSearchTool = (CRectSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CRectSearchTool(*pRectSearchTool);
		}
		break;
	case ePatternRectSearchTool:
		{
			CPatternRectSearchTool* pPatternRectSearchTool = (CPatternRectSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternRectSearchTool(*pPatternRectSearchTool);
		}
		break;
	case eAreaInspectTool:
		{
			CAreaInspectTool* pAreaInspectTool = (CAreaInspectTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CAreaInspectTool(*pAreaInspectTool);
		}
		break;
	case eAreaInspectToolEx:
		{
			CAreaInspectToolEx* pAreaInspectExTool = (CAreaInspectToolEx*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CAreaInspectToolEx(*pAreaInspectExTool);
		}
		break;
	case eChordSearchTool:
		{
			CChordSearchTool* pChordSearchTool = (CChordSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CChordSearchTool(*pChordSearchTool);
		}
		break;
	case eTwoPatModelSearchTool:
		{
			CTwoPatModelSearchTool* pTwoPatModelSearchTool = (CTwoPatModelSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CTwoPatModelSearchTool(*pTwoPatModelSearchTool);
		}
		break;
	case eMPatternCornerSearchTool:
		{
			CMPatternCornerSearchTool* pMPatternCornerSearchTool = (CMPatternCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CMPatternCornerSearchTool(*pMPatternCornerSearchTool);
		}
		break;
	case eMPatternPickCornerSearchTool:
		{
			CMPatternPickCornerSearchTool* pMPatternPickCornerSearchTool = (CMPatternPickCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CMPatternPickCornerSearchTool(*pMPatternPickCornerSearchTool);
		}
		break;
	case ePatternCornerCircleSearchTool:
		{
			CPatternCornerCircleSearchTool* pPatternCornerCircleSearchTool = (CPatternCornerCircleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternCornerCircleSearchTool(*pPatternCornerCircleSearchTool);
		}
		break;
	case eQuickCornerCircleSearchTool:
		{
			CQuickCornerCircleSearchTool* pPatternCornerCircleSearchTool = (CQuickCornerCircleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickCornerCircleSearchTool(*pPatternCornerCircleSearchTool);
		}
		break;
	case ePatternPosLineDistanceTool:
		{
			CPatternPosLineDistanceTool* pPatternPosLineDistanceTool = (CPatternPosLineDistanceTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternPosLineDistanceTool(*pPatternPosLineDistanceTool);
		}
		break;
	case eCornerSearchCheckInspectTool:
		{
			CCornerCheckSearchTool* pCornerCheckSearchTool = (CCornerCheckSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCornerCheckSearchTool(*pCornerCheckSearchTool);
		}
		break;
	case eCircleCornerSearchCheckInspectTool:
		{
			CCircleCornerCheckSearchTool* pCornerCheckSearchTool = (CCircleCornerCheckSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCircleCornerCheckSearchTool(*pCornerCheckSearchTool);
		}
		break;
	case ePatternDouleSearchTool:
		{
			CPatternDoubleSearchTool* pPatternDoubleSearchTool = (CPatternDoubleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternDoubleSearchTool(*pPatternDoubleSearchTool);
		}
		break;
	case ePatternChordSearchTool:
		{
			CPatternChordSearchTool* pPatternChordSearchTool = (CPatternChordSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternChordSearchTool(*pPatternChordSearchTool);
		}
		break;
	case eQuickMulCircleSearchTool:
		{
			CQuickMulCircleSearchTool* pQuickMulCircleSearchTool = (CQuickMulCircleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickMulCircleSearchTool(*pQuickMulCircleSearchTool);
		}
		break;
	case eDmCodeCalibrateTool:
		{
			CDmCodeCalibrateTool* pDmCodeCalibrateTool = (CDmCodeCalibrateTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CDmCodeCalibrateTool(*pDmCodeCalibrateTool);
		}
		break;
	case ePatternCircle4LineSearchTool:
		{
			CPatternCircle4LineSearchTool* pPatternCircle4LineTool = (CPatternCircle4LineSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternCircle4LineSearchTool(*pPatternCircle4LineTool);
		}
		break;
	case eQuickCircle4LineSearchTool:
		{
			CQuickCircle4LineSearchTool* pPatternCircle4LineTool = (CQuickCircle4LineSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickCircle4LineSearchTool(*pPatternCircle4LineTool);
		}
		break;
	case eSpecialPickSearchTool:
		{
			CSpecialPickSearchTool* pSpecialPickSearchTool = (CSpecialPickSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CSpecialPickSearchTool(*pSpecialPickSearchTool);

		}
		break;
	case ePatternCornerLineSearchTool:
		{
			CPatternCornerLineSearchTool* pPatternCornerLineSearchTool = (CPatternCornerLineSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternCornerLineSearchTool(*pPatternCornerLineSearchTool);
		}
		break;
	case ePatternMulCircleSearchTool:
		{
			CPatternMulCircleSearchTool* pPatternMulCircleSearchTool = (CPatternMulCircleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternMulCircleSearchTool(*pPatternMulCircleSearchTool);
		}
		break;
	case ePatternCornerMulCircleSearchTool:
		{
			CPatternCornerMulCircleSearchTool* pPatternCornerMulCircleSearchTool = (CPatternCornerMulCircleSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternCornerMulCircleSearchTool(*pPatternCornerMulCircleSearchTool);
		}
		break;
	case ePatternCornerMulObroundTool:
		{
			CPatternCornerMulObroundTool* pPatternCornerMulObroundTool = (CPatternCornerMulObroundTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternCornerMulObroundTool(*pPatternCornerMulObroundTool);
		}
		break;
	case eQuickCornerMulObroundTool:
		{
			CQuickCornerMulObroundTool* pQuickCornerMulObroundTool = (CQuickCornerMulObroundTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickCornerMulObroundTool(*pQuickCornerMulObroundTool);
		}
		break;
	case eACFInspectTool:
		{
			CACFInspectTool* pCACFInspectTool = (CACFInspectTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CACFInspectTool(*pCACFInspectTool);

		}
		break;
	case eVirtualRectSearchTool:
		{
			CVirtualRectSearchTool* pVirtualRectSearchTool = (CVirtualRectSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CVirtualRectSearchTool(*pVirtualRectSearchTool);
		}
		break;
	case ePatternVirtualRectSearchTool:
		{
			CPatternVirtualRectSearchTool* pPatternVirtualRectSearchTool = (CPatternVirtualRectSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CPatternVirtualRectSearchTool(*pPatternVirtualRectSearchTool);
		}
		break;
	case eTwoQuickModelSearchTool:
		{

			CTwoQuickModelSearchTool* pTwoQuickModelSearchTool= (CTwoQuickModelSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CTwoQuickModelSearchTool(*pTwoQuickModelSearchTool);
		}
		break;
	case eIdReaderDmCodeTool:
		{

			CIdReaderDmCodeTool* pIdReaderDmCodeTool = (CIdReaderDmCodeTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CIdReaderDmCodeTool(*pIdReaderDmCodeTool);
		}
		break;
	case eIdReaderBarCodeTool:
		{
			CIdReaderBarCodeTool* pIdReaderBarCodeTool = (CIdReaderBarCodeTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CIdReaderBarCodeTool(*pIdReaderBarCodeTool);
		}
		break;
	case eCombinationCornerSearchTool:
		{
			CCombinationCornerSearchTool* pCombinationCornerSearchTool = (CCombinationCornerSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CCombinationCornerSearchTool(*pCombinationCornerSearchTool);
		}
		break;
	case eMQuickPickSearchTool:
		{
			CMQuickPickSearchTool* pMQuickPickSearchTool = (CMQuickPickSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CMQuickPickSearchTool(*pMQuickPickSearchTool);
		}
		break;
	case eMPatternPickSearchTool:
		{
			CMPatternPickSearchTool* pMPatternPickSearchTool = (CMPatternPickSearchTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CMPatternPickSearchTool(*pMPatternPickSearchTool);
		}
		break;
	case eQuickPosLineDistanceTool:
		{
			CQuickPosLineDistanceTool* pCQuickPosLineDistanceTool = (CQuickPosLineDistanceTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CQuickPosLineDistanceTool(*pCQuickPosLineDistanceTool);
		}
		break;
	case eAreaInspectPickTool:
		{
			CAreaInspectPickTool* pAreaInspectPickTool = (CAreaInspectPickTool*)pBaseSearchTool;
			*ppNewBaseSearchTool = new CAreaInspectPickTool(*pAreaInspectPickTool);
		}
		break;
	default:
		{
			return FALSE;
		}
		break;		
	}

	return TRUE;
}

void vcBaseVisionAlign::SearchProcessLogRecord(CString strlog,int nPlatformIndex,int nPosIndex)
{
	if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
	{

		SYSTEMTIME sys; 
		GetLocalTime( &sys ); 
		CString t;
		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
		CString strPath;


		CString strTemp = "";
		strTemp += t;
		strTemp += strlog;
		strTemp+= "\n";
		FILE *stream;

		CString strDir;
		CFileFind findFile;
		BOOL IsFild, IsDir;
		IsFild = FALSE;
		IsDir = FALSE;


		strDir= "D:\\VisionASMLog";

		IsFild = findFile.FindFile(strDir);
		while (IsFild)
		{
			IsFild = findFile.FindNextFile();
			IsDir = findFile.IsDirectory();
			if(IsDir) break;
		}	
		if (!IsDir)
		{
			if (!CreateDirectory(strDir, NULL))// 创建文件夹
			{
				return;
			}
		}

		IsFild = FALSE;
		IsDir = FALSE;
		strDir = "D:\\VisionASMLog\\CameraFixMarkInfo";
		IsFild = findFile.FindFile(strDir);
		while (IsFild)
		{
			IsFild = findFile.FindNextFile();
			IsDir = findFile.IsDirectory();
			if(IsDir) break;
		}
		if (!IsDir)
		{
			if (!CreateDirectory(strDir, NULL))// 创建文件夹
			{
				return;
			}
		}

		IsFild = FALSE;
		IsDir = FALSE;
		strDir.Format("D:\\VisionASMLog\\CameraFixMarkInfo\\WS%d",nPlatformIndex) ;
		IsFild = findFile.FindFile(strDir);
		while (IsFild)
		{
			IsFild = findFile.FindNextFile();
			IsDir = findFile.IsDirectory();
			if(IsDir) break;
		}
		if (!IsDir)
		{
			if (!CreateDirectory(strDir, NULL))// 创建文件夹
			{
				return;
			}
		}

		strPath.Format("\\CameraFixMarkInfoPos%d.txt",nPosIndex);
		strPath = strDir + strPath;


		stream = fopen(strPath, _T("a+t"));
		if (stream != NULL)
		{
			fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
			fclose(stream);	
		}
		VCRemoveFile(strPath);					
	}
}


void vcBaseVisionAlign::AlignLogRecord(CString strlog)
{
	if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
	{

		SYSTEMTIME sys; 
		GetLocalTime( &sys ); 
		CString t;
		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
		CString strPath;


		CString strTemp = "";
		strTemp += t;
		strTemp += strlog;
		strTemp+= "\n";
		FILE *stream;

		CString strDir;
		CFileFind findFile;
		BOOL IsFild, IsDir;
		IsFild = FALSE;
		IsDir = FALSE;

		strDir  = "D:\\VisionASMLog";

		IsFild = findFile.FindFile(strDir);
		while (IsFild)
		{
			IsFild = findFile.FindNextFile();
			IsDir = findFile.IsDirectory();
			if(IsDir) break;
		}	
		if (!IsDir)
		{
			if (!CreateDirectory(strDir, NULL))// 创建文件夹
			{

				return ;
			}
		}

		if (m_pPlatformInfo != NULL)
		{
			strPath.Format(_T("D:\\VisionASMLog\\AlignInfo%d.txt"), m_pPlatformInfo->m_nPlatformIndex);
		}
		else
		{
			strPath.Format(_T("D:\\VisionASMLog\\AlignInfo.txt"));
		}

		stream = fopen(strPath, _T("a+t"));
		if (stream != NULL)
		{
			fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
			fclose(stream);	
		}
		VCRemoveFile(strPath);					
	}
}

void vcBaseVisionAlign::AlignXmlLog(CString strFunc, CString strXmlFunc, BOOL bFuncResult)
{
	if (0)
	{

		SYSTEMTIME sys; 
		GetLocalTime( &sys ); 
		CString t;
		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
		CString strPath;


		CString strTemp = "";
		strTemp += t;
		strTemp += ":" + strFunc + "," + strXmlFunc + ",";
		if (bFuncResult == TRUE)
		{
			strTemp += GetSysInfoString(m_psaSysInfoStrings,IDS_FUNCTION_RESULT_SUCCESS);
		}
		else
		{
			strTemp +=  GetSysInfoString(m_psaSysInfoStrings,IDS_FUNCTION_RESULT_FAILE);
		}
		strTemp+= "\n";
		FILE *stream;

		strPath = m_strDataRecord + _T("\\XmlLog.txt");
		stream = fopen(strPath, _T("a+t"));
		if (stream != NULL)
		{
			fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
			fclose(stream);	VCRemoveFile(strPath);	
		}				
	}
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnObjectSearchTool( int nPosIndex, int nPatIndex )
{

	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnObjectSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex];	
	// 	if (nPosIndex<0 || nPosIndex>=m_vvpAlnObjectSearchToolRepo.size())
	// 	{
	// 		return NULL;
	// 	}
	// 
	// 	if (nPatIndex<0 || nPatIndex>=m_vvpAlnObjectSearchToolRepo[nPosIndex].size())
	// 	{
	// 		return NULL;
	// 	}
	// 
	// 	return m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex];		
}

BOOL vcBaseVisionAlign::InitAlnObjectSearchToolRepository(int nProductIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	// 获取当前产品信息
	//int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nProductIndex<0 || nProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strObjectMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strObjectMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\ObjectModels");;
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (pProduct->m_bAlnObjectSearchToolInited == TRUE)
	{
		return TRUE;
	}

	UninitAlnObjectSearchToolRepository(nProductIndex);

	// 初始化定位工具容器	
	//	int nPatternNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nPatternNum = m_pPlatformInfo->m_nPositionNum;
	pProduct->m_vvpAlnObjectSearchToolRepo.resize(pProduct->m_pAlignerParam->m_vObjectPosPatInfo.size());
	for (int k=0; k<pProduct->m_vvpAlnObjectSearchToolRepo.size(); k++)
	{
		pProduct->m_vvpAlnObjectSearchToolRepo[k].resize(pProduct->m_pAlignerParam->m_vObjectPosPatInfo[k].m_nPatNum, NULL);
	}
	CString strInfo;
	//// 加载每个定位工具
	//BOOL bOK = TRUE;
	//for (int j=0; j<pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++)
	//{
	//	for (int i=0; i<pProduct->m_vvpAlnObjectSearchToolRepo[j].size(); i++)
	//	{
	//		strPatternDir.Format(_T("\\Pos%d_M%d"), j, i);
	//		strPatternDir = strObjectMarkPatternsDir + strPatternDir;

	//		// 从XML文件中获取定位工具类型
	//		CSearchToolType cSearchToolType = CBaseSearchTool::GetSearchToolTypeFromFile(strPatternDir);

	//		// 根据定位工具类型创建定位工具
	//		pBaseSearchTool = NULL;
	//		bOK = CreateSearchTool(cSearchToolType, &pBaseSearchTool);
	//		if (!bOK)
	//		{
	//			continue;
	//		}
	//		
	//		// 加载定位模板
	//		if ((NULL == pBaseSearchTool) || (FALSE == pBaseSearchTool->LoadModelFromFile(strPatternDir)))
	//		{
	//			if (pBaseSearchTool!=NULL)
	//			{
	//				delete pBaseSearchTool;
	//				pBaseSearchTool = NULL;
	//			}

	//			bOK = FALSE;
	//			continue;
	//		}
	//		//pBaseSearchTool->SetDisplay(m_vpGuiDisplay[j]);
	//		pProduct->m_vvpAlnObjectSearchToolRepo[j][i] = pBaseSearchTool;
	//	}
	//}


	{	//线程加载对象模板
		HANDLE hSearchToolThread[MAXPOSNUM];
		CInitSearchToolThreadParam InitSearchToolThreadParam[MAXPOSNUM];
		for (int j=0; j<pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++)
		{
			InitSearchToolThreadParam[j]=CInitSearchToolThreadParam(this,strObjectMarkPatternsDir,pProduct->m_vvpAlnObjectSearchToolRepo[j].size(),j);
			hSearchToolThread[j] = CreateThread(NULL,0,InitSearchToolRepositoryThread,&InitSearchToolThreadParam[j],0,NULL);
		}
		//等待线程加载所有模板后，程序继续运行,默认等待2分钟
		int nReturn = WaitForMultipleObjects(pProduct->m_vvpAlnObjectSearchToolRepo.size(),hSearchToolThread,TRUE,INITSEARCHTOOLTHREAD_WAITINGTIME);
		if(nReturn == WAIT_TIMEOUT)
		{
			for (int i = 0; i < pProduct->m_vvpAlnObjectSearchToolRepo.size(); i++)
			{
				TerminateThread(hSearchToolThread[i], 0);
				CloseHandle(hSearchToolThread[i]);
			}
			//线程加载超时
			return FALSE;
		}
		for(int j= 0; j < pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++ )
		{	
			CloseHandle(hSearchToolThread[j]);    // 关闭所有线程句柄并释放内存
		}
		//if(nReturn == WAIT_TIMEOUT)
		//{
		//	//线程加载超时
		//	return FALSE;
		//}
		//开始将线程保存的模板，从线程参数ObjectSearchToolParam中读出
		for (int j=0; j<pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++)
		{
			for (int i=0; i<pProduct->m_vvpAlnObjectSearchToolRepo[j].size(); i++)
			{
				if(InitSearchToolThreadParam[j].GetSearchToolInitResult(i))
				{
					//m_vvpAlnObjectSearchToolRepo为保护成员变量，所以没有在线程中直接赋值，而是在线程外重新遍历赋值
					pProduct->m_vvpAlnObjectSearchToolRepo[j][i] =InitSearchToolThreadParam[j].m_vpAlnSearchToolRepo[i];
				}
			}
		}
	}



	if (!SendMessageTimeOutUpdateChangeProductSetDisplay(nProductIndex, 3))
	{
		return FALSE;
	}

	pProduct->m_bAlnObjectSearchToolInited = TRUE;
	return TRUE;
}

// 保存对象定位工具库到文件
BOOL vcBaseVisionAlign::SaveAlnObjectSearchToolRepository(int nProductIndex)
{

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strObjectMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strObjectMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\ObjectModels");;
	CreateDirectoryPro(strObjectMarkPatternsDir);
	// 保存每个定位工具
	BOOL bOK = TRUE;
	//for (int j=0; j<pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++)
	//{
	//	for (int i=0; i<pProduct->m_vvpAlnObjectSearchToolRepo[j].size(); i++)
	//	{
	//		strPatternDir.Format(_T("\\Pos%d_M%d"), j, i);
	//		strPatternDir = strObjectMarkPatternsDir + strPatternDir;

	//		pBaseSearchTool = pProduct->m_vvpAlnObjectSearchToolRepo[j][i];
	//		// 保存定位模板
	//		if ((NULL != pBaseSearchTool))
	//		{
	//			bOK = bOK && pBaseSearchTool->SaveModelToFile(strPatternDir);
	//		}
	//		else
	//		{
	//			bOK = bOK && CBaseSearchTool::SaveSearchToolTypeToFile(strPatternDir);
	//		}
	//	}
	//}

	//使用线程保存每个定位工具
	HANDLE hSaveSearchToolTheard[MAXPOSNUM];//每个相机位对应一个线程
	CSaveSearchToolRepositoryThreadParam SaveSearchToolThreadParam[MAXPOSNUM];//线程传递的参数
	for (int j=0; j<pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++)
	{
		SaveSearchToolThreadParam[j] = CSaveSearchToolRepositoryThreadParam(strObjectMarkPatternsDir,j,pProduct->m_vvpAlnObjectSearchToolRepo[j]);//赋值传递参数
		hSaveSearchToolTheard[j] = CreateThread(NULL, 0,SaveSearchToolRepositoryThread,&SaveSearchToolThreadParam[j],0,NULL);//创建线程
	}
	//等待所有线程运行完毕，默认等待1.5分钟
	int nReturn=WaitForMultipleObjects(pProduct->m_vvpAlnObjectSearchToolRepo.size(),hSaveSearchToolTheard,TRUE,SAVESEARCHTOOLTHREAD_WAITINGTIME);
	//关闭线程并释放资源
	for (int j=0; j<pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++)
	{
		CloseHandle(hSaveSearchToolTheard[j]);
	}
	if(nReturn==WAIT_TIMEOUT)
	{
		//保存超时
		return FALSE;
	}
	//判断所有模板是否保存成功
	for (int j=0; j<pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++)
	{
		bOK = bOK && SaveSearchToolThreadParam[j].GetAllSearchToolSaveResult();
	}
	return bOK;
}



// 销毁定位工具库
BOOL vcBaseVisionAlign::UninitAlnObjectSearchToolRepository(int nProductIndex)
{
	int i=0;
	// 	for (i=0; i<m_vpAlnObjectSearchTool.size(); i++)
	// 	{
	// 		// 		m_vpAlnObjectSearchTool[i]->SetDisplay(NULL);
	// 		m_vpAlnObjectSearchTool[i] = NULL;
	// 	}

	// 	for (i=0; i<m_vvpAlnObjectSearchToolRepo.size(); i++)
	// 	{
	// 		for (int j=0; j<m_vvpAlnObjectSearchToolRepo[i].size(); j++)
	// 		{
	// 			delete m_vvpAlnObjectSearchToolRepo[i][j];
	// 			m_vvpAlnObjectSearchToolRepo[i][j] = NULL;
	// 		}
	// 		m_vvpAlnObjectSearchToolRepo[i].clear();
	// 	}
	// 	m_vvpAlnObjectSearchToolRepo.clear();
	// 	m_bIsRepositoryInitAlnObjectSearch = FALSE;

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	pProduct->DeleteObjectSearchTools();


	return TRUE;
}

BOOL vcBaseVisionAlign::SetRepoAlnObjectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex]!=NULL)
	{
		delete pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	// 根据定位工具类型创建定位工具（采用拷贝构造赋值）
	CBaseSearchTool* pNewBaseSearchTool = NULL;
	if (!CloneSearchTool(pBaseSearchTool, &pNewBaseSearchTool))
	{
		return FALSE;
	}
	pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex] = pNewBaseSearchTool;

	return TRUE;
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnObjectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnObjectSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex];		
}

BOOL vcBaseVisionAlign::AddRepoAlnObjectSearchTool(int nProductIndex,  int nPosIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].push_back(NULL);


	return SetRepoAlnObjectSearchTool(nProductIndex, nPosIndex, pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].size()-1, pBaseSearchTool);
}

BOOL vcBaseVisionAlign::DeleteRepoAlnObjectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}	

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnObjectSearchToolRepo.size())
	{
		return FALSE;
	}


	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex] != NULL)
	{
		delete pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	//	pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].erase(pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].begin() + nPatIndex);
	return TRUE;
}

int vcBaseVisionAlign::GetRepoAlnObjectSearchToolCount(int nProductIndex, int nPosIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}


	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	return pProduct->m_vvpAlnObjectSearchToolRepo[nPosIndex].size();
}



// 初始化定位工具库
BOOL vcBaseVisionAlign::InitAlnVirtualObjectSearchToolRepository(int nProductIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	// 获取当前产品信息
	//int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nProductIndex<0 || nProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strVirtualObjectMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strVirtualObjectMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\VirtualObjectModels");;
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (pProduct->m_bAlnVirtualObjectSearchToolInited == TRUE)
	{
		return TRUE;
	}

	UninitAlnVirtualObjectSearchToolRepository(nProductIndex);

	// 初始化定位工具容器	
	//	int nPatternNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nPatternNum = m_pPlatformInfo->m_nPositionNum;
	//pProduct->m_vvpAlnVirtualObjectSearchToolRepo.resize(pProduct->m_pAlignerParam->GetVirtualObjectMarkPatternNum());
	pProduct->m_vvpAlnVirtualObjectSearchToolRepo.resize(pProduct->m_pAlignerParam->GetObjectMarkPatternNum());
	for (int k=0; k<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); k++)
	{
		pProduct->m_vvpAlnVirtualObjectSearchToolRepo[k].resize(VIRTUALOBJECTCANDIDATENUM, NULL);
	}

	//// 加载每个定位工具
	//BOOL bOK = TRUE;
	//for (int j=0; j<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); j++)
	//{
	//	for (int i=0; i<pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j].size(); i++)
	//	{
	//		strPatternDir.Format(_T("\\Pos%d_M%d"), j, i);
	//		strPatternDir = strVirtualObjectMarkPatternsDir + strPatternDir;

	//		// 从XML文件中获取定位工具类型
	//		CSearchToolType cSearchToolType = CBaseSearchTool::GetSearchToolTypeFromFile(strPatternDir);

	//		// 根据定位工具类型创建定位工具
	//		pBaseSearchTool = NULL;
	//		bOK = CreateSearchTool(cSearchToolType, &pBaseSearchTool);
	//		if (!bOK)
	//		{
	//			continue;
	//		}

	//		// 加载定位模板
	//		if ((NULL == pBaseSearchTool) || (FALSE == pBaseSearchTool->LoadModelFromFile(strPatternDir)))
	//		{
	//			if (pBaseSearchTool!=NULL)
	//			{
	//				delete pBaseSearchTool;
	//				pBaseSearchTool = NULL;
	//			}

	//			bOK = FALSE;
	//			continue;
	//		}

	//		//pBaseSearchTool->SetDisplay(m_vpGuiDisplay[j]);
	//		pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j][i] = pBaseSearchTool;
	//	}
	//}


	{	//线程加载虚拟模板
		HANDLE hSearchToolThread[MAXPOSNUM];
		CInitSearchToolThreadParam InitSearchToolThreadParam[MAXPOSNUM];
		for (int j=0; j<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); j++)
		{
			InitSearchToolThreadParam[j]=CInitSearchToolThreadParam(this,strVirtualObjectMarkPatternsDir,pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j].size(),j);
			hSearchToolThread[j] = CreateThread(NULL,0,InitSearchToolRepositoryThread,&InitSearchToolThreadParam[j],0,NULL);
		}
		//等待线程加载所有模板后，程序继续运行,默认等待1.5分钟
		int nReturn = WaitForMultipleObjects(pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(),hSearchToolThread,TRUE,INITSEARCHTOOLTHREAD_WAITINGTIME);
		if(nReturn == WAIT_TIMEOUT)
		{
			for (int i = 0; i < pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); i++)
			{
				TerminateThread(hSearchToolThread[i], 0);
				CloseHandle(hSearchToolThread[i]);
			}
			//线程加载超时
			return FALSE;
		}

		for(int i = 0; i < pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); i++ )
		{	
			CloseHandle(hSearchToolThread[i]);    // 关闭所有线程句柄并释放内存
		}
		//if(nReturn == WAIT_TIMEOUT)
		//{
		//	//线程加载超时
		//	return FALSE;
		//}
		//开始将线程保存的模板，从线程参数TargetSearchToolParam中读出
		for (int j=0; j<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); j++)
		{
			for (int i=0; i<pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j].size(); i++)
			{
				if(InitSearchToolThreadParam[j].GetSearchToolInitResult(i))
				{
					//m_vvpAlnObjectSearchToolRepo为保护成员变量，所以没有在线程中直接赋值，而是在线程外重新遍历赋值
					pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j][i] = InitSearchToolThreadParam[j].m_vpAlnSearchToolRepo[i];
				}
			}
		}
	}
	if (!SendMessageTimeOutUpdateChangeProductSetDisplay(nProductIndex, 4))
	{
		return FALSE;
	}

	pProduct->m_bAlnVirtualObjectSearchToolInited = TRUE;
	return TRUE;
}

// 保存对象定位工具库到文件
BOOL vcBaseVisionAlign::SaveAlnVirtualObjectSearchToolRepository(int nProductIndex)
{

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strVirtualObjectMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strVirtualObjectMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\VirtualObjectModels");;
	CreateDirectoryPro(strVirtualObjectMarkPatternsDir);
	// 保存每个定位工具
	BOOL bOK = TRUE;
	//for (int j=0; j<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); j++)
	//{
	//	for (int i=0; i<pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j].size(); i++)
	//	{
	//		strPatternDir.Format(_T("\\Pos%d_M%d"), j, i);
	//		strPatternDir = strVirtualObjectMarkPatternsDir + strPatternDir;

	//		pBaseSearchTool = pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j][i];
	//		// 保存定位模板
	//		if ((NULL != pBaseSearchTool))
	//		{
	//			bOK = bOK && pBaseSearchTool->SaveModelToFile(strPatternDir);
	//		}
	//		else
	//		{
	//			bOK = bOK && CBaseSearchTool::SaveSearchToolTypeToFile(strPatternDir);
	//		}
	//	}
	//}

	//使用线程保存每个定位工具
	HANDLE hSaveSearchToolTheard[MAXPOSNUM];//每个相机位对应一个线程
	CSaveSearchToolRepositoryThreadParam SaveSearchToolThreadParam[MAXPOSNUM];//线程传递的参数
	for (int j=0; j<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); j++)
	{
		SaveSearchToolThreadParam[j] = CSaveSearchToolRepositoryThreadParam(strVirtualObjectMarkPatternsDir,j,pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j]);//赋值传递参数
		hSaveSearchToolTheard[j] = CreateThread(NULL, 0,SaveSearchToolRepositoryThread,&SaveSearchToolThreadParam[j],0,NULL);//创建线程
	}
	//等待所有线程运行完毕，默认等待5分钟
	int nReturn=WaitForMultipleObjects(pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(),hSaveSearchToolTheard,TRUE,SAVESEARCHTOOLTHREAD_WAITINGTIME);
	//关闭线程释放资源
	for (int j=0; j<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); j++)
	{
		CloseHandle(hSaveSearchToolTheard[j]);
	}
	if(nReturn==WAIT_TIMEOUT)
	{
		//保存超时
		return FALSE;
	}
	//判断所有模板是否保存成功
	for (int j=0; j<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); j++)
	{
		bOK = bOK && SaveSearchToolThreadParam[j].GetAllSearchToolSaveResult();
	}
	return bOK;
}



// 销毁定位工具库
BOOL vcBaseVisionAlign::UninitAlnVirtualObjectSearchToolRepository(int nProductIndex)
{
	// 	int i=0;
	// 	for (i=0; i<m_vpAlnVirtualObjectSearchTool.size(); i++)
	// 	{
	// 		// 		m_vpAlnVirtualObjectSearchTool[i]->SetDisplay(NULL);
	// 		m_vpAlnVirtualObjectSearchTool[i] = NULL;
	// 	}

	// 	for (i=0; i<m_vvpAlnVirtualObjectSearchToolRepo.size(); i++)
	// 	{
	// 		for (int j=0; j<m_vvpAlnVirtualObjectSearchToolRepo[i].size(); j++)
	// 		{
	// 			delete m_vvpAlnVirtualObjectSearchToolRepo[i][j];
	// 			m_vvpAlnVirtualObjectSearchToolRepo[i][j] = NULL;
	// 		}
	// 		m_vvpAlnVirtualObjectSearchToolRepo[i].clear();
	// 	}
	// 	m_vvpAlnVirtualObjectSearchToolRepo.clear();
	// 	m_bIsRepositoryInitAlnVirtualObjectSearch = FALSE;

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	pProduct->DeleteVirtualObjectSearchTools();


	return TRUE;
}

BOOL vcBaseVisionAlign::SetRepoAlnVirtualObjectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex]!=NULL)
	{
		delete pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	// 根据定位工具类型创建定位工具（采用拷贝构造赋值）
	CBaseSearchTool* pNewBaseSearchTool = NULL;
	if (!CloneSearchTool(pBaseSearchTool, &pNewBaseSearchTool))
	{
		return FALSE;
	}
	pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex] = pNewBaseSearchTool;

	return TRUE;
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnVirtualObjectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex];		
}


CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnVirtualObjectSearchTool(int nPosIndex, int nPatIndex)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex];	
}

BOOL vcBaseVisionAlign::AddRepoAlnVirtualObjectSearchTool(int nProductIndex,  int nPosIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].push_back(NULL);


	return SetRepoAlnVirtualObjectSearchTool(nProductIndex, nPosIndex, pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].size()-1, pBaseSearchTool);
}

BOOL vcBaseVisionAlign::DeleteRepoAlnVirtualObjectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}	

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size())
	{
		return FALSE;
	}


	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex] != NULL)
	{
		delete pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	//	pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].erase(pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].begin() + nPatIndex);
	return TRUE;
}

BOOL vcBaseVisionAlign::ProductSearchToolLoadState(int nProductIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	if (nProductIndex<0 || nProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	CCalibData* pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
	if (pProduct == NULL || pCalibData == NULL)
	{
		return FALSE;
	}

	if (pProduct->m_bAlnTargetSearchToolInited || pProduct->m_bAlnCalibTargetSearchToolInited ||pProduct->m_bAlnInspectSearchToolInited
		|| pProduct->m_bAlnObjectSearchToolInited || pProduct->m_bAlnVirtualObjectSearchToolInited || pCalibData->m_bCalibObjectSearchToolInited)
	{
		return TRUE;
	}
	return FALSE;
}

int vcBaseVisionAlign::GetRepoAlnVirtualObjectSearchToolCount(int nProductIndex, int nPosIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}


	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	return pProduct->m_vvpAlnVirtualObjectSearchToolRepo[nPosIndex].size();
}


// 初始化定位工具库
BOOL vcBaseVisionAlign::InitAlnTargetSearchToolRepository(int nProductIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	// 获取当前产品信息
	//int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nProductIndex<0 || nProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strTargetMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strTargetMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\TargetModels");;
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (pProduct->m_bAlnTargetSearchToolInited == TRUE)
	{
		return TRUE;
	}

	UninitAlnTargetSearchToolRepository(nProductIndex);

	// 初始化定位工具容器	
	//	int nPatternNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nPatternNum = m_pPlatformInfo->m_nPositionNum;
	pProduct->m_vvpAlnTargetSearchToolRepo.resize(pProduct->m_pAlignerParam->m_vTargetPosPatInfo.size());
	for (int k=0; k<pProduct->m_vvpAlnTargetSearchToolRepo.size(); k++)
	{
		pProduct->m_vvpAlnTargetSearchToolRepo[k].resize(pProduct->m_pAlignerParam->m_vTargetPosPatInfo[k].m_nPatNum, NULL);
	}

	// 加载每个定位工具
	//BOOL bOK = TRUE;
	//for (int j=0; j<pProduct->m_vvpAlnTargetSearchToolRepo.size(); j++)
	//{
	//	for (int i=0; i<pProduct->m_vvpAlnTargetSearchToolRepo[j].size(); i++)
	//	{
	//		strPatternDir.Format(_T("\\Pos%d_M%d"), j, i);
	//		strPatternDir = strTargetMarkPatternsDir + strPatternDir;

	//		// 从XML文件中获取定位工具类型
	//		CSearchToolType cSearchToolType = CBaseSearchTool::GetSearchToolTypeFromFile(strPatternDir);

	//		// 根据定位工具类型创建定位工具
	//		pBaseSearchTool = NULL;
	//		bOK = CreateSearchTool(cSearchToolType, &pBaseSearchTool);
	//		if (!bOK)
	//		{
	//			continue;
	//		}

	//		// 加载定位模板
	//		if ((NULL == pBaseSearchTool) || (FALSE == pBaseSearchTool->LoadModelFromFile(strPatternDir)))
	//		{
	//			if (pBaseSearchTool!=NULL)
	//			{
	//				delete pBaseSearchTool;
	//				pBaseSearchTool = NULL;
	//			}

	//			bOK = FALSE;
	//			continue;
	//		}

	//		//pBaseSearchTool->SetDisplay(m_vpGuiDisplay[j]);
	//		pProduct->m_vvpAlnTargetSearchToolRepo[j][i] = pBaseSearchTool;
	//	}
	//}

	{	//线程加载目标模板
		HANDLE hSearchToolThread[MAXPOSNUM];
		CInitSearchToolThreadParam InitSearchToolThreadParam[MAXPOSNUM];
		for (int j=0; j<pProduct->m_vvpAlnTargetSearchToolRepo.size(); j++)
		{
			InitSearchToolThreadParam[j]=CInitSearchToolThreadParam(this,strTargetMarkPatternsDir,pProduct->m_vvpAlnTargetSearchToolRepo[j].size(),j);
			hSearchToolThread[j] = CreateThread(NULL,0,InitSearchToolRepositoryThread,&InitSearchToolThreadParam[j],0,NULL);
		}
		//等待线程加载所有模板后，程序继续运行，默认等待1.5分钟
		int nReturn = WaitForMultipleObjects(pProduct->m_vvpAlnTargetSearchToolRepo.size(),hSearchToolThread,TRUE,INITSEARCHTOOLTHREAD_WAITINGTIME);

		if(nReturn == WAIT_TIMEOUT)
		{
			for (int i = 0; i < pProduct->m_vvpAlnTargetSearchToolRepo.size(); i++)
			{
				TerminateThread(hSearchToolThread[i], 0);
				CloseHandle(hSearchToolThread[i]);
			}
			//线程加载超时
			return FALSE;
		}

		for(int i = 0; i < pProduct->m_vvpAlnTargetSearchToolRepo.size(); i++ )
		{	
			CloseHandle(hSearchToolThread[i]);    // 关闭所有线程句柄并释放内存
		}
		//if(nReturn == WAIT_TIMEOUT)
		//{
		//	//线程加载超时
		//	return FALSE;
		//}
		//开始将线程保存的模板，从线程参数TargetSearchToolParam中读出
		for (int j=0; j<pProduct->m_vvpAlnTargetSearchToolRepo.size(); j++)
		{
			for (int i=0; i<pProduct->m_vvpAlnTargetSearchToolRepo[j].size(); i++)
			{
				if(InitSearchToolThreadParam[j].GetSearchToolInitResult(i))
				{
					//m_vvpAlnObjectSearchToolRepo为保护成员变量，所以没有在线程中直接赋值，而是在线程外重新遍历赋值
					pProduct->m_vvpAlnTargetSearchToolRepo[j][i] =InitSearchToolThreadParam[j].m_vpAlnSearchToolRepo[i];
				}
			}
		}
	}

	if (!SendMessageTimeOutUpdateChangeProductSetDisplay(nProductIndex, 2))
	{
		return FALSE;
	}

	pProduct->m_bAlnTargetSearchToolInited = TRUE;
	return TRUE;
}


// 保存对象定位工具库到文件
BOOL vcBaseVisionAlign::SaveAlnTargetSearchToolRepository(int nProductIndex)
{

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strTargetMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strTargetMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\TargetModels");;
	CreateDirectoryPro(strTargetMarkPatternsDir);
	// 保存每个定位工具
	BOOL bOK = TRUE;
	//for (int j=0; j<pProduct->m_vvpAlnTargetSearchToolRepo.size(); j++)
	//{
	//	for (int i=0; i<pProduct->m_vvpAlnTargetSearchToolRepo[j].size(); i++)
	//	{
	//		strPatternDir.Format(_T("\\Pos%d_M%d"), j, i);
	//		strPatternDir = strTargetMarkPatternsDir + strPatternDir;

	//		pBaseSearchTool = pProduct->m_vvpAlnTargetSearchToolRepo[j][i];
	//		// 保存定位模板
	//		if ((NULL != pBaseSearchTool))
	//		{
	//			bOK = bOK && pBaseSearchTool->SaveModelToFile(strPatternDir);
	//		}
	//		else
	//		{
	//			bOK = bOK && CBaseSearchTool::SaveSearchToolTypeToFile(strPatternDir);
	//		}
	//	}
	//}

	//使用线程保存每个定位工具
	HANDLE hSaveSearchToolTheard[MAXPOSNUM];//每个相机位对应一个线程
	CSaveSearchToolRepositoryThreadParam SaveSearchToolThreadParam[MAXPOSNUM];//线程传递的参数
	for (int j=0; j<pProduct->m_vvpAlnTargetSearchToolRepo.size(); j++)
	{
		SaveSearchToolThreadParam[j] = CSaveSearchToolRepositoryThreadParam(strTargetMarkPatternsDir,j,pProduct->m_vvpAlnTargetSearchToolRepo[j]);//赋值传递参数
		hSaveSearchToolTheard[j] = CreateThread(NULL, 0,SaveSearchToolRepositoryThread,&SaveSearchToolThreadParam[j],0,NULL);//创建线程
	}
	//等待所有线程运行完毕，默认等待1.2分钟
	int nReturn=WaitForMultipleObjects(pProduct->m_vvpAlnTargetSearchToolRepo.size(),hSaveSearchToolTheard,TRUE,SAVESEARCHTOOLTHREAD_WAITINGTIME);
	//关闭线程释放资源
	for (int j=0; j<pProduct->m_vvpAlnTargetSearchToolRepo.size(); j++)
	{
		CloseHandle(hSaveSearchToolTheard[j]);
	}
	if(nReturn==WAIT_TIMEOUT)
	{
		//保存超时
		return FALSE;
	}
	//判断所有模板是否保存成功
	for (int j=0; j<pProduct->m_vvpAlnTargetSearchToolRepo.size(); j++)
	{
		bOK = bOK && SaveSearchToolThreadParam[j].GetAllSearchToolSaveResult();
	}

	return bOK;
}

// 销毁定位工具库
BOOL vcBaseVisionAlign::UninitAlnTargetSearchToolRepository(int nProductIndex)
{
	int i=0;
	// 	for (i=0; i<m_vpAlnTargetSearchTool.size(); i++)
	// 	{
	// 		// 		m_vpAlnTargetSearchTool[i]->SetDisplay(NULL);
	// 		m_vpAlnTargetSearchTool[i] = NULL;
	// 	}

	// 	for (i=0; i<m_vvpAlnTargetSearchToolRepo.size(); i++)
	// 	{
	// 		for (int j=0; j<m_vvpAlnTargetSearchToolRepo[i].size(); j++)
	// 		{
	// 			delete m_vvpAlnTargetSearchToolRepo[i][j];
	// 			m_vvpAlnTargetSearchToolRepo[i][j] = NULL;
	// 		}
	// 		m_vvpAlnTargetSearchToolRepo[i].clear();
	// 	}
	// 	m_vvpAlnTargetSearchToolRepo.clear();
	// 	m_bIsRepositoryInitAlnTargetSearch = FALSE;

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	pProduct->DeleteTargetSearchTools();


	return TRUE;
}

BOOL vcBaseVisionAlign::SetRepoAlnTargetSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnTargetSearchToolRepo.size())
	{
		return FALSE;
	}

	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex]!=NULL)
	{
		delete pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	// 根据定位工具类型创建定位工具（采用拷贝构造赋值）
	CBaseSearchTool* pNewBaseSearchTool = NULL;
	if (!CloneSearchTool(pBaseSearchTool, &pNewBaseSearchTool))
	{
		return FALSE;
	}
	pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex] = pNewBaseSearchTool;

	return TRUE;
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnTargetSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnTargetSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex];		
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnTargetSearchTool( int nPosIndex, int nPatIndex )
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnTargetSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex];			
}

BOOL vcBaseVisionAlign::AddRepoAlnTargetSearchTool(int nProductIndex,  int nPosIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnTargetSearchToolRepo.size())
	{
		return FALSE;
	}

	pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].push_back(NULL);


	return SetRepoAlnTargetSearchTool(nProductIndex, nPosIndex, pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].size()-1, pBaseSearchTool);
}

BOOL vcBaseVisionAlign::DeleteRepoAlnTargetSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}	

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnTargetSearchToolRepo.size())
	{
		return FALSE;
	}


	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex] != NULL)
	{
		delete pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	//	pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].erase(pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].begin() + nPatIndex);
	return TRUE;
}

int vcBaseVisionAlign::GetRepoAlnTargetSearchToolCount(int nProductIndex, int nPosIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}


	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnTargetSearchToolRepo.size())
	{
		return FALSE;
	}

	return pProduct->m_vvpAlnTargetSearchToolRepo[nPosIndex].size();
}

// 初始化定位工具库
BOOL vcBaseVisionAlign::InitAlnCalibTargetSearchToolRepository(int nProductIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	// 获取当前产品信息
	//int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nProductIndex<0 || nProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strCalibTargetMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strCalibTargetMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\CalibTargetModels");;
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (pProduct->m_bAlnCalibTargetSearchToolInited == TRUE)
	{
		return TRUE;
	}

	UninitAlnCalibTargetSearchToolRepository(nProductIndex);

	// 初始化定位工具容器	
	//	int nPatternNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nPatternNum = m_pPlatformInfo->m_nPositionNum;
	pProduct->m_vvpAlnCalibTargetSearchToolRepo.resize(pProduct->m_pAlignerParam->GetCalibTargetMarkPatternNum());
	for (int k=0; k<pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); k++)
	{
		pProduct->m_vvpAlnCalibTargetSearchToolRepo[k].resize(ALNCALIBTARGETCANDIDATENUM, NULL);
	}

	{	//线程加载关联模板
		HANDLE hSearchToolThread[MAXPOSNUM];
		CInitSearchToolThreadParam InitSearchToolThreadParam[MAXPOSNUM];
		for (int j=0; j<pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); j++)
		{
			InitSearchToolThreadParam[j]=CInitSearchToolThreadParam(this,strCalibTargetMarkPatternsDir,pProduct->m_vvpAlnCalibTargetSearchToolRepo[j].size(),j);
			hSearchToolThread[j] = CreateThread(NULL,0,InitSearchToolRepositoryThread,&InitSearchToolThreadParam[j],0,NULL);
		}
		//等待线程加载所有模板后，程序继续运行，默认等待1.5分钟
		int nReturn = WaitForMultipleObjects(pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(),hSearchToolThread,TRUE,INITSEARCHTOOLTHREAD_WAITINGTIME);

		// 修复超时后 线程继续执行而 hSearchToolThread生命周期结束导致InitSearchToolRepositoryThread野指针传入导致崩溃
		if(nReturn == WAIT_TIMEOUT)
		{
			for (int i = 0; i < pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); i++)
			{
				TerminateThread(hSearchToolThread[i], 0);
				CloseHandle(hSearchToolThread[i]);
			}
			//线程加载超时
			return FALSE;
		}

		for(int i = 0; i < pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); i++ )
		{	
			CloseHandle(hSearchToolThread[i]);    // 关闭所有线程句柄并释放内存
		}

		//开始将线程保存的模板，从线程参数TargetSearchToolParam中读出
		for (int j=0; j<pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); j++)
		{
			for (int i=0; i<pProduct->m_vvpAlnCalibTargetSearchToolRepo[j].size(); i++)
			{
				if(InitSearchToolThreadParam[j].GetSearchToolInitResult(i))
				{
					//m_vvpAlnObjectSearchToolRepo为保护成员变量，所以没有在线程中直接赋值，而是在线程外重新遍历赋值
					pProduct->m_vvpAlnCalibTargetSearchToolRepo[j][i] =InitSearchToolThreadParam[j].m_vpAlnSearchToolRepo[i];
				}
			}
		}
	}

	if (!SendMessageTimeOutUpdateChangeProductSetDisplay(nProductIndex, 5))
	{
		return FALSE;
	}

	pProduct->m_bAlnCalibTargetSearchToolInited = TRUE;
	return TRUE;
}


// 保存对象定位工具库到文件
BOOL vcBaseVisionAlign::SaveAlnCalibTargetSearchToolRepository(int nProductIndex)
{

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strCalibTargetMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strCalibTargetMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\CalibTargetModels");;
	CreateDirectoryPro(strCalibTargetMarkPatternsDir);
	// 保存每个定位工具
	BOOL bOK = TRUE;
	HANDLE hSaveSearchToolTheard[MAXPOSNUM];//每个相机位对应一个线程
	CSaveSearchToolRepositoryThreadParam SaveSearchToolThreadParam[MAXPOSNUM];//线程传递的参数
	for (int j=0; j<pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); j++)
	{
		SaveSearchToolThreadParam[j] = CSaveSearchToolRepositoryThreadParam(strCalibTargetMarkPatternsDir,j,pProduct->m_vvpAlnCalibTargetSearchToolRepo[j]);//赋值传递参数
		hSaveSearchToolTheard[j] = CreateThread(NULL, 0,SaveSearchToolRepositoryThread,&SaveSearchToolThreadParam[j],0,NULL);//创建线程
	}
	//等待所有线程运行完毕，默认等待1.5分钟
	int nReturn=WaitForMultipleObjects(pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(),hSaveSearchToolTheard,TRUE,SAVESEARCHTOOLTHREAD_WAITINGTIME);
	//关闭线程释放资源
	for (int j=0; j<pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); j++)
	{
		CloseHandle(hSaveSearchToolTheard[j]);
	}
	if(nReturn==WAIT_TIMEOUT)
	{
		//保存超时
		return FALSE;
	}
	//判断所有模板是否保存成功
	for (int j=0; j<pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); j++)
	{
		bOK = bOK && SaveSearchToolThreadParam[j].GetAllSearchToolSaveResult();
	}
	return bOK;
}




// 销毁定位工具库
BOOL vcBaseVisionAlign::UninitAlnCalibTargetSearchToolRepository(int nProductIndex)
{
	// 	int i=0;
	// 	for (i=0; i<m_vpAlnCalibTargetSearchTool.size(); i++)
	// 	{
	// 		// 		m_vpAlnCalibTargetSearchTool[i]->SetDisplay(NULL);
	// 		m_vpAlnCalibTargetSearchTool[i] = NULL;
	// 	}

	// 	for (i=0; i<m_vvpAlnCalibTargetSearchToolRepo.size(); i++)
	// 	{
	// 		for (int j=0; j<m_vvpAlnCalibTargetSearchToolRepo[i].size(); j++)
	// 		{
	// 			delete m_vvpAlnCalibTargetSearchToolRepo[i][j];
	// 			m_vvpAlnCalibTargetSearchToolRepo[i][j] = NULL;
	// 		}
	// 		m_vvpAlnCalibTargetSearchToolRepo[i].clear();
	// 	}
	// 	m_vvpAlnCalibTargetSearchToolRepo.clear();
	// 	m_bIsRepositoryInitAlnCalibTargetSearch = FALSE;

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	pProduct->DeleteCalibTargetSearchTools();


	return TRUE;
}

BOOL vcBaseVisionAlign::SetRepoAlnCalibTargetSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnCalibTargetSearchToolRepo.size())
	{
		return FALSE;
	}

	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex]!=NULL)
	{
		delete pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	// 根据定位工具类型创建定位工具（采用拷贝构造赋值）
	CBaseSearchTool* pNewBaseSearchTool = NULL;
	if (!CloneSearchTool(pBaseSearchTool, &pNewBaseSearchTool))
	{
		return FALSE;
	}
	pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex] = pNewBaseSearchTool;

	return TRUE;
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnCalibTargetSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{
	if ((NULL == m_pVisionASMConfig))
	{
		return NULL;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return NULL;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnCalibTargetSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex];		
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnCalibTargetSearchTool(int nPosIndex, int nPatIndex)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return NULL;
	}

	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return NULL;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnCalibTargetSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex];	
}

BOOL vcBaseVisionAlign::AddRepoAlnCalibTargetSearchTool(int nProductIndex,  int nPosIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnCalibTargetSearchToolRepo.size())
	{
		return FALSE;
	}

	pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].push_back(NULL);


	return SetRepoAlnCalibTargetSearchTool(nProductIndex, nPosIndex, pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].size()-1, pBaseSearchTool);
}

BOOL vcBaseVisionAlign::DeleteRepoAlnCalibTargetSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}	

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnCalibTargetSearchToolRepo.size())
	{
		return FALSE;
	}


	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex] != NULL)
	{
		delete pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	//	pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].erase(pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].begin() + nPatIndex);
	return TRUE;
}

int vcBaseVisionAlign::GetRepoAlnCalibTargetSearchToolCount(int nProductIndex, int nPosIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}


	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnCalibTargetSearchToolRepo.size())
	{
		return FALSE;
	}

	return pProduct->m_vvpAlnCalibTargetSearchToolRepo[nPosIndex].size();
}




// 初始化定位工具库
BOOL vcBaseVisionAlign::InitCalibObjectSearchToolRepository(int nCalibIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}



	// 获取当前产品信息
	//int nCalibIndex = m_pVisionASMConfig->m_TotalCalibData.GetCurProductIndex();

	if (nCalibIndex<0 || nCalibIndex>=m_pVisionASMConfig->m_TotalCalibData.GetCount())
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strObjectMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalCalibData.GetItemName(nCalibIndex);
	strProductName.Format(_T("%03d"), nCalibIndex+1);
	strObjectMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\JobCalibs\\") + strProductName+_T("\\CalibModels");
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}
	if (pCalibData->m_bCalibObjectSearchToolInited == TRUE)
	{
		return TRUE;
	}

	UninitCalibObjectSearchToolRepository(nCalibIndex);

	// 初始化定位工具容器	
	//	int nPatternNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nPatternNum = m_pPlatformInfo->m_nPositionNum;
	pCalibData->m_vvpCalibObjectSearchToolRepo.resize(nPatternNum);
	for (int k=0; k<pCalibData->m_vvpCalibObjectSearchToolRepo.size(); k++)
	{
		pCalibData->m_vvpCalibObjectSearchToolRepo[k].resize(1, NULL);
	}

	// 加载每个定位工具
	BOOL bOK = TRUE;

	{	//线程加载标定模板
		HANDLE hSearchToolThread[MAXPOSNUM];
		CInitSearchToolThreadParam InitSearchToolThreadParam[MAXPOSNUM];
		for (int j=0; j<pCalibData->m_vvpCalibObjectSearchToolRepo.size(); j++)
		{
			InitSearchToolThreadParam[j]=CInitSearchToolThreadParam(this,strObjectMarkPatternsDir,pCalibData->m_vvpCalibObjectSearchToolRepo[j].size(),j);
			hSearchToolThread[j] = CreateThread(NULL,0,InitSearchToolRepositoryThread,&InitSearchToolThreadParam[j],0,NULL);
		}
		//等待线程加载所有模板后，程序继续运行,默认等待1.5分钟
		int nReturn = WaitForMultipleObjects(pCalibData->m_vvpCalibObjectSearchToolRepo.size(),hSearchToolThread,TRUE,INITSEARCHTOOLTHREAD_WAITINGTIME);

		if(nReturn == WAIT_TIMEOUT)
		{
			for (int i = 0; i < pCalibData->m_vvpCalibObjectSearchToolRepo.size(); i++)
			{
				TerminateThread(hSearchToolThread[i], 0);
				CloseHandle(hSearchToolThread[i]);
			}
			//线程加载超时
			return FALSE;
		}

		for(int j= 0; j < pCalibData->m_vvpCalibObjectSearchToolRepo.size(); j++ )
		{	
			CloseHandle(hSearchToolThread[j]);    // 关闭所有线程句柄并释放内存
		}
		//if(nReturn == WAIT_TIMEOUT)
		//{
		//	//线程加载超时
		//	return FALSE;
		//}
		//开始将线程保存的模板，从线程参数ObjectSearchToolParam中读出
		for (int j=0; j<pCalibData->m_vvpCalibObjectSearchToolRepo.size(); j++)
		{
			for (int i=0; i<pCalibData->m_vvpCalibObjectSearchToolRepo[j].size(); i++)
			{
				if(InitSearchToolThreadParam[j].GetSearchToolInitResult(i))
				{
					//m_vvpAlnObjectSearchToolRepo为保护成员变量，所以没有在线程中直接赋值，而是在线程外重新遍历赋值
					pCalibData->m_vvpCalibObjectSearchToolRepo[j][i] =InitSearchToolThreadParam[j].m_vpAlnSearchToolRepo[i];
				}
			}
		}
	}

	if (!SendMessageTimeOutUpdateChangeProductSetDisplay(nCalibIndex, 1))
	{
		return FALSE;
	}

	pCalibData->m_bCalibObjectSearchToolInited = TRUE;
	return TRUE;
}


// 保存对象定位工具库到文件
BOOL vcBaseVisionAlign::SaveCalibObjectSearchToolRepository(int nCalibIndex)
{

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strObjectMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalCalibData.GetItemName(nCalibIndex);
	strProductName.Format(_T("%03d"), nCalibIndex+1);
	strObjectMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\JobCalibs\\") + strProductName + _T("\\CalibModels");
	CreateDirectoryPro(strObjectMarkPatternsDir);
	// 保存每个定位工具
	BOOL bOK = TRUE;
	HANDLE hSaveSearchToolTheard[MAXPOSNUM];//每个相机位对应一个线程
	CSaveSearchToolRepositoryThreadParam SaveSearchToolThreadParam[MAXPOSNUM];//线程传递的参数
	for (int j=0; j<pCalibData->m_vvpCalibObjectSearchToolRepo.size(); j++)
	{
		SaveSearchToolThreadParam[j] = CSaveSearchToolRepositoryThreadParam(strObjectMarkPatternsDir,j,pCalibData->m_vvpCalibObjectSearchToolRepo[j]);//赋值传递参数
		hSaveSearchToolTheard[j] = CreateThread(NULL, 0,SaveSearchToolRepositoryThread,&SaveSearchToolThreadParam[j],0,NULL);//创建线程
	}
	//等待所有线程运行完毕，默认等1.5分钟
	int nReturn=WaitForMultipleObjects(pCalibData->m_vvpCalibObjectSearchToolRepo.size(),hSaveSearchToolTheard,TRUE,SAVESEARCHTOOLTHREAD_WAITINGTIME);
	//关闭线程释放资源
	for (int j=0; j<pCalibData->m_vvpCalibObjectSearchToolRepo.size(); j++)
	{
		CloseHandle(hSaveSearchToolTheard[j]);
	}
	if(nReturn==WAIT_TIMEOUT)
	{
		//保存超时
		return FALSE;
	}
	//判断所有模板是否保存成功
	for (int j=0; j<pCalibData->m_vvpCalibObjectSearchToolRepo.size(); j++)
	{
		bOK = bOK && SaveSearchToolThreadParam[j].GetAllSearchToolSaveResult();
	}
	return bOK;
}


// 销毁定位工具库
BOOL vcBaseVisionAlign::UninitCalibObjectSearchToolRepository(int nCalibIndex)
{
	int i=0;
	// 	for (i=0; i<m_vpCalibSearchTool.size(); i++)
	// 	{
	// 		// 		m_vpCalibSearchTool[i]->SetDisplay(NULL);
	// 		m_vpCalibSearchTool[i] = NULL;
	// 	}

	// 	for (i=0; i<m_vvpCalibObjectSearchToolRepo.size(); i++)
	// 	{
	// 		for (int j=0; j<m_vvpCalibObjectSearchToolRepo[i].size(); j++)
	// 		{
	// 			delete m_vvpCalibObjectSearchToolRepo[i][j];
	// 			m_vvpCalibObjectSearchToolRepo[i][j] = NULL;
	// 		}
	// 		m_vvpCalibObjectSearchToolRepo[i].clear();
	// 	}
	// 	m_vvpCalibObjectSearchToolRepo.clear();
	// 	m_bIsRepositoryInitCalibObjectSearch = FALSE;

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}

	pCalibData->DeleteObjectSearchTools();


	return TRUE;
}

BOOL vcBaseVisionAlign::SetRepoCalibObjectSearchTool(int nCalibIndex,  int nPosIndex, int nPatIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pCalibData->m_vvpCalibObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	if ((nPatIndex < 0) || (nPatIndex >= pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex]!=NULL)
	{
		delete pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex];
		pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	// 根据定位工具类型创建定位工具（采用拷贝构造赋值）
	CBaseSearchTool* pNewBaseSearchTool = NULL;
	if (!CloneSearchTool(pBaseSearchTool, &pNewBaseSearchTool))
	{
		return FALSE;
	}
	pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex] = pNewBaseSearchTool;

	return TRUE;
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoCalibObjectSearchTool(int nCalibIndex,  int nPosIndex, int nPatIndex )
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pCalibData->m_vvpCalibObjectSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex];		
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoCalibObjectSearchTool(int nPosIndex, int nPatIndex)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}
	int nCalibIndex = m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pCalibData->m_vvpCalibObjectSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex];	
}

BOOL vcBaseVisionAlign::AddRepoCalibObjectSearchTool(int nCalibIndex,  int nPosIndex, CBaseSearchTool* pBaseSearchTool )
{

	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pCalibData->m_vvpCalibObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].push_back(NULL);


	return SetRepoCalibObjectSearchTool(nCalibIndex, nPosIndex, pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].size()-1, pBaseSearchTool);
}

BOOL vcBaseVisionAlign::DeleteRepoCalibObjectSearchTool(int nCalibIndex,  int nPosIndex, int nPatIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}	

	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pCalibData->m_vvpCalibObjectSearchToolRepo.size())
	{
		return FALSE;
	}


	if ((nPatIndex < 0) || (nPatIndex >= pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex] != NULL)
	{
		delete pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex];
		pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	//	pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].erase(pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].begin() + nPatIndex);
	return TRUE;
}

int vcBaseVisionAlign::GetRepoCalibObjectSearchToolCount(int nCalibIndex, int nPosIndex )
{

	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCalibIndex);
	if (pCalibData == NULL)
	{
		return FALSE;
	}


	if (nPosIndex<0 || nPosIndex>=pCalibData->m_vvpCalibObjectSearchToolRepo.size())
	{
		return FALSE;
	}

	return pCalibData->m_vvpCalibObjectSearchToolRepo[nPosIndex].size();
}



// 初始化检测Inspect定位工具库
BOOL vcBaseVisionAlign::InitAlnInspectSearchToolRepository(int nProductIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	// 获取当前产品信息
	//int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nProductIndex<0 || nProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strInspectMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strInspectMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\InspectModels");;
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (pProduct->m_bAlnInspectSearchToolInited == TRUE)
	{
		return TRUE;
	}

	UninitAlnInspectSearchToolRepository(nProductIndex);

	// 初始化定位工具容器	
	//	int nPatternNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
	int nPatternNum = m_pPlatformInfo->m_nPositionNum;
	pProduct->m_vvpAlnInspectSearchToolRepo.resize(pProduct->m_pAlignerParam->GetInspectMarkPatternNum());
	for (int k=0; k<pProduct->m_vvpAlnInspectSearchToolRepo.size(); k++)
	{
		pProduct->m_vvpAlnInspectSearchToolRepo[k].resize(INSPECTCANDIDATENUM, NULL);
	}

	{	//线程加载检测模板
		HANDLE hSearchToolThread[MAXPOSNUM];
		CInitSearchToolThreadParam InitSearchToolThreadParam[MAXPOSNUM];
		for (int j=0; j<pProduct->m_vvpAlnInspectSearchToolRepo.size(); j++)
		{
			InitSearchToolThreadParam[j]=CInitSearchToolThreadParam(this,strInspectMarkPatternsDir,pProduct->m_vvpAlnInspectSearchToolRepo[j].size(),j);
			hSearchToolThread[j] = CreateThread(NULL,0,InitSearchToolRepositoryThread,&InitSearchToolThreadParam[j],0,NULL);
		}
		//等待线程加载所有模板后，程序继续运行,默认等待2分钟
		int nReturn = WaitForMultipleObjects(pProduct->m_vvpAlnInspectSearchToolRepo.size(),hSearchToolThread,TRUE,INITSEARCHTOOLTHREAD_WAITINGTIME); 
		if(nReturn == WAIT_TIMEOUT)
		{
			for (int i = 0; i < pProduct->m_vvpAlnInspectSearchToolRepo.size(); i++)
			{
				TerminateThread(hSearchToolThread[i], 0);
				CloseHandle(hSearchToolThread[i]);
			}
			//线程加载超时
			return FALSE;
		}
		for(int i = 0; i < pProduct->m_vvpAlnInspectSearchToolRepo.size(); i++ )
		{	
			CloseHandle(hSearchToolThread[i]);    // 关闭所有线程句柄并释放内存
		}
		//if(nReturn == WAIT_TIMEOUT)
		//{
		//	//线程加载超时
		//	return FALSE;
		//}
		//开始将线程保存的模板，从线程参数TargetSearchToolParam中读出
		for (int j=0; j<pProduct->m_vvpAlnInspectSearchToolRepo.size(); j++)
		{
			for (int i=0; i<pProduct->m_vvpAlnInspectSearchToolRepo[j].size(); i++)
			{
				if(InitSearchToolThreadParam[j].GetSearchToolInitResult(i))
				{
					//m_vvpAlnObjectSearchToolRepo为保护成员变量，所以没有在线程中直接赋值，而是在线程外重新遍历赋值
					pProduct->m_vvpAlnInspectSearchToolRepo[j][i] =InitSearchToolThreadParam[j].m_vpAlnSearchToolRepo[i];
				}
			}
		}
	}

	if (!SendMessageTimeOutUpdateChangeProductSetDisplay(nProductIndex, 6))
	{
		return FALSE;
	}

	pProduct->m_bAlnInspectSearchToolInited = TRUE;
	return TRUE;

}

// 保存检测Inspect定位工具库到文件
BOOL vcBaseVisionAlign::SaveAlnInspectSearchToolRepository(int nProductIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	// 从配置文件获取定位工具类型，并加载模板
	CString strProductName;
	CString strInspectMarkPatternsDir;
	CString strPatternDir; 

	CBaseSearchTool* pBaseSearchTool = NULL;	
	strProductName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nProductIndex);
	strProductName.Format(_T("%03d"),nProductIndex+1);
	strInspectMarkPatternsDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath+ _T("\\Jobs\\") + strProductName + _T("\\InspectModels");;
	CreateDirectoryPro(strInspectMarkPatternsDir);

	// 保存每个定位工具
	BOOL bOK = TRUE;
	HANDLE hSaveSearchToolTheard[MAXPOSNUM];//每个相机位对应一个线程
	CSaveSearchToolRepositoryThreadParam SaveSearchToolThreadParam[MAXPOSNUM];//线程传递的参数
	for (int j=0; j<pProduct->m_vvpAlnInspectSearchToolRepo.size(); j++)
	{
		SaveSearchToolThreadParam[j] = CSaveSearchToolRepositoryThreadParam(strInspectMarkPatternsDir,j,pProduct->m_vvpAlnInspectSearchToolRepo[j]);//赋值传递参数
		hSaveSearchToolTheard[j] = CreateThread(NULL, 0,SaveSearchToolRepositoryThread,&SaveSearchToolThreadParam[j],0,NULL);//创建线程
	}
	//等待所有线程运行完毕，默认等1.5分钟
	int nReturn=WaitForMultipleObjects(pProduct->m_vvpAlnInspectSearchToolRepo.size(),hSaveSearchToolTheard,TRUE,SAVESEARCHTOOLTHREAD_WAITINGTIME);
	//关闭线程释放资源
	for (int j=0; j<pProduct->m_vvpAlnInspectSearchToolRepo.size(); j++)
	{
		CloseHandle(hSaveSearchToolTheard[j]);
	}
	if(nReturn==WAIT_TIMEOUT)
	{
		//保存超时
		return FALSE;
	}
	//判断所有模板是否保存成功
	for (int j=0; j<pProduct->m_vvpAlnInspectSearchToolRepo.size(); j++)
	{
		bOK = bOK && SaveSearchToolThreadParam[j].GetAllSearchToolSaveResult();
	}
	return bOK;
}

// 销毁检测Inspect定位工具库
BOOL vcBaseVisionAlign::UninitAlnInspectSearchToolRepository(int nProductIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	pProduct->DeleteInspectSearchTools();


	return TRUE;
}

BOOL vcBaseVisionAlign::AddRepoAlnInspectSearchTool(int nProductIndex,  int nPosIndex, CBaseSearchTool* pBaseSearchTool )
{
	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnInspectSearchToolRepo.size())
	{
		return FALSE;
	}

	pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].push_back(NULL);


	return SetRepoAlnInspectSearchTool(nProductIndex, nPosIndex, pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].size()-1, pBaseSearchTool);
}

BOOL vcBaseVisionAlign::DeleteRepoAlnInspectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{
	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}	

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>= pProduct->m_vvpAlnInspectSearchToolRepo.size())
	{
		return FALSE;
	}


	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex] != NULL)
	{
		delete pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	//	pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].erase(pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].begin() + nPatIndex);
	return TRUE;
}

BOOL vcBaseVisionAlign::SetRepoAlnInspectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex, CBaseSearchTool* pBaseSearchTool )
{
	if ((NULL == m_pVisionASMConfig) || (NULL == pBaseSearchTool))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnInspectSearchToolRepo.size())
	{
		return FALSE;
	}

	if ((nPatIndex < 0) || (nPatIndex >= pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].size()))
	{
		return FALSE;
	}

	if (pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex]!=NULL)
	{
		delete pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex];
		pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex] = NULL;
	}

	// 根据定位工具类型创建定位工具（采用拷贝构造赋值）
	CBaseSearchTool* pNewBaseSearchTool = NULL;
	if (!CloneSearchTool(pBaseSearchTool, &pNewBaseSearchTool))
	{
		return FALSE;
	}
	pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex] = pNewBaseSearchTool;

	return TRUE;
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnInspectSearchTool(int nProductIndex,  int nPosIndex, int nPatIndex )
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnInspectSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex];
}

CBaseSearchTool* vcBaseVisionAlign::GetRepoAlnInspectSearchTool(int nPosIndex, int nPatIndex)
{
	if ((NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	int nProductIndex =  m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnInspectSearchToolRepo.size())
	{
		return NULL;
	}

	if (nPatIndex<0 || nPatIndex>=pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].size())
	{
		return NULL;
	}

	return pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex][nPatIndex];
}

int vcBaseVisionAlign::GetRepoAlnInspectSearchToolCount(int nProductIndex, int nPosIndex )
{
	if (NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}

	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}


	if (nPosIndex<0 || nPosIndex>=pProduct->m_vvpAlnInspectSearchToolRepo.size())
	{
		return FALSE;
	}

	return pProduct->m_vvpAlnInspectSearchToolRepo[nPosIndex].size();
}

// 执行标定定位
BOOL vcBaseVisionAlign::ExecuteCalibTargetSearch(int nPosIndex, int nPatIndex)
{   
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoCalibObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL == pSearchTool)
	{
		return FALSE;
	}

	if (FALSE == m_vImageSearch[nPosIndex].IsValid())
	{
		return FALSE;
	}	

	if (!pSearchTool->Search(m_vImageSearch[nPosIndex]))
	{
		return FALSE;
	}
	// 	else
	// 	{
	// 		m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
	// 	}

	return TRUE;
}

// 获取标定定位的结果
CSearchResult vcBaseVisionAlign::GetCalibTargetSearchResult(int nPosIndex, int nPatIndex)
{
	CSearchResult result;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoCalibObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		pSearchTool->GetResult(0, result);
	}

	return result;
}

CameraParamEnable vcBaseVisionAlign::GetAlnTargetSearchCandidatePatShutterEnable(int nPatIndex)
{
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	CameraParamEnable cameraParamEnable;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pProductData == NULL)
	{
		return cameraParamEnable;
	}
	if (pProductData->m_pAlignerParam != NULL)
	{
		return pProductData->m_pAlignerParam->GetEnableTargetSearchShutter(nPatIndex);
	}

	return cameraParamEnable;
}


// 获取对位定位的候补模板是否有效
BOOL vcBaseVisionAlign::GetAlnTargetSearchCandidatePatEnable(int nPatIndex)
{
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pProductData == NULL)
	{
		return FALSE;
	}
	if (pProductData->m_pAlignerParam != NULL)
	{
		return pProductData->m_pAlignerParam->GetTargetCandidateOffsetEnable(nPatIndex);
	}

	return FALSE;
}


// 执行对位定位
BOOL vcBaseVisionAlign::ExecuteAlnTargetSearch(int nPosIndex, int nPatIndex)
{
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnTargetSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL == pSearchTool)
	{
		return FALSE;
	}

	if (FALSE == m_vImageSearch[nPosIndex].IsValid())
	{
		return FALSE;
	}	

	if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool)
	{
		if(m_bSearchWithInspect)
		{
			CBaseTrainDataParam *m_pTrainDataParam = new CCornerCheckSearchTrainDataParam();
			pSearchTool->GetTrainDataParam(m_pTrainDataParam);
			((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[0] = true;
			((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[1] = true;
			((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[2] = true;
			((CCornerCheckSearchTool*)pSearchTool)->SetTrainDataParamForce(m_pTrainDataParam);
			if (m_pTrainDataParam !=NULL)
			{
				delete m_pTrainDataParam;
				m_pTrainDataParam =NULL;
			}
		}
		else 
		{
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			if (optionInfo.m_bSearchWithDistanceInspect)
			{
				CBaseTrainDataParam *m_pTrainDataParam = new CCornerCheckSearchTrainDataParam();
				pSearchTool->GetTrainDataParam(m_pTrainDataParam);
				((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[0] = optionInfo.m_bSearchWithDistanceInspect;
				((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[1] = optionInfo.m_bSearchWithDistanceInspect;
				((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[2] = optionInfo.m_bSearchWithDistanceInspect;
				((CCornerCheckSearchTool*)pSearchTool)->SetTrainDataParamForce(m_pTrainDataParam);
				if (m_pTrainDataParam !=NULL)
				{
					delete m_pTrainDataParam;
					m_pTrainDataParam =NULL;
				}
			}

		}

	}

	if (!pSearchTool->Search(m_vImageSearch[nPosIndex]))
	{
		if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool && (m_bSearchWithInspect))
		{   
			if (nPosIndex<8)
			{
				m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_bPosSearchFinished=TRUE;
			}
		}
		return FALSE;
	}
	if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool && (m_bSearchWithInspect))
	{   
		CSearchResult tmpSearchResult;
		pSearchTool->GetResult(0,tmpSearchResult);
		if (nPosIndex<8)
		{
			//m_XYDCommProtocol.m_vdDistance.at(2*nPosIndex+1) = tmpSearchResult.m_ResultL2LInspectDistance.m_dDistanceMM[1];
			//m_XYDCommProtocol.m_vdDistance.at(2*nPosIndex) = tmpSearchResult.m_ResultL2LInspectDistance.m_dDistanceMM[0];
			m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_L2LDistanceResult=tmpSearchResult.m_ResultL2LInspectDistance;
			m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_bPosSearchFinished=TRUE;

		}
	}
	// 	else
	// 	{
	// 		m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
	// 	}

	return TRUE;
}

// 获取对位定位的结果
CSearchResult vcBaseVisionAlign::GetAlnTargetSearchResult(int nPosIndex, int nPatIndex)
{
	CSearchResult result;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnTargetSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		pSearchTool->GetResult(0, result);
	}

	return result;
}


std::vector<CSearchResult> vcBaseVisionAlign::GetAlnTargetSearchResults(int nPosIndex, int nPatIndex)
{
	CSearchResult result;
	std::vector<CSearchResult> results;
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnTargetSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		int i = 0; 
		for(i = 0; i < pSearchTool->GetResultNum(); i++)
		{
			pSearchTool->GetResult(i, result);
			results.push_back(result);
		}

	}

	return results;
}

// SY 20171110
// 获取目标定位结果个数
int vcBaseVisionAlign::GetAlnTargetSearchResultNumber(int nPosIndex, int nPatIndex)
{
	int nResultNumber = 0;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnTargetSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		nResultNumber = pSearchTool->GetResultNum();
	}

	return nResultNumber;
}

// 执行关联标定定位
BOOL vcBaseVisionAlign::ExecuteAlnCalibTargetSearch(int nPosIndex, int nPatIndex)
{
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnCalibTargetSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL == pSearchTool)
	{
		return FALSE;
	}

	if (FALSE == m_vImageSearch[nPosIndex].IsValid())
	{
		return FALSE;
	}	

	if (!pSearchTool->Search(m_vImageSearch[nPosIndex]))
	{
		return FALSE;
	}
	// 	CSearchToolType SearchToolType = pSearchTool->GetSearchToolType();
	// 	if (SearchToolType == ePatternCornerSearchTool || SearchToolType == eCornerSearchTool ||
	// 		SearchToolType == eBaseCornerSearchTool ||SearchToolType == eCornerSearchCheckInspectTool
	// 		||SearchToolType == ePatternCornerCircleSearchTool
	// 		||SearchToolType == ePatternCornerMulCircleSearchTool
	// 		||SearchToolType == eQuickCornerCircleSearchTool)
	// 	{
	// 		m_bIsTargetCornerSearchTool[nPosIndex] = TRUE;
	// 	}
	// 	else
	// 	{
	// 		m_bIsTargetCornerSearchTool[nPosIndex] = FALSE;
	// 	}
	// 	else
	// 	{
	// 		m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
	// 	}

	return TRUE;
}

// 获取检测定位的候补模板是否有效
BOOL vcBaseVisionAlign::GetAlnInspectSearchCandidatePatEnable(int nPatIndex)	
{
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pProductData == NULL)
	{
		return FALSE;
	}
	if (pProductData->m_pAlignerParam != NULL)
	{
		return pProductData->m_pAlignerParam->GetInspectCandidateOffsetEnable(nPatIndex);
	}

	return FALSE;
}

// 执行检测定位
BOOL vcBaseVisionAlign::ExecuteAlnInspectSearch(int nPosIndex, int nPatIndex)
{
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnInspectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL == pSearchTool)
	{
		return FALSE;
	}

	if (FALSE == m_vImageSearch[nPosIndex].IsValid())
	{
		return FALSE;
	}	

	// 激活线距检测工具
	/*if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool)
	{
	if(m_bSearchWithInspect)
	{
	CBaseTrainDataParam *m_pTrainDataParam = new CCornerCheckSearchTrainDataParam();
	pSearchTool->GetTrainDataParam(m_pTrainDataParam);
	((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[0] = true;
	((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[1] = true;
	((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[2] = true;
	((CCornerCheckSearchTool*)pSearchTool)->SetTrainDataParamForce(m_pTrainDataParam);
	if (m_pTrainDataParam !=NULL)
	{
	delete m_pTrainDataParam;
	m_pTrainDataParam =NULL;
	}
	}
	else 
	{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (optionInfo.m_bSearchWithDistanceInspect)
	{
	CBaseTrainDataParam *m_pTrainDataParam = new CCornerCheckSearchTrainDataParam();
	pSearchTool->GetTrainDataParam(m_pTrainDataParam);
	((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[0] = optionInfo.m_bSearchWithDistanceInspect;
	((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[1] = optionInfo.m_bSearchWithDistanceInspect;
	((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[2] = optionInfo.m_bSearchWithDistanceInspect;
	((CCornerCheckSearchTool*)pSearchTool)->SetTrainDataParamForce(m_pTrainDataParam);
	if (m_pTrainDataParam !=NULL)
	{
	delete m_pTrainDataParam;
	m_pTrainDataParam =NULL;
	}
	}
	}

	}
	*/
	if (!pSearchTool->Search(m_vImageSearch[nPosIndex]))
	{
		if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool && (m_bSearchWithInspect))
		{   
			if (nPosIndex<8)
			{
				m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_bPosSearchFinished=TRUE;
			}
		}
		return FALSE;
	}

	if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool && (m_bSearchWithInspect))
	{   
		CSearchResult tmpSearchResult;
		pSearchTool->GetResult(0,tmpSearchResult);
		if (nPosIndex<8)
		{
			//m_XYDCommProtocol.m_vdDistance.at(2*nPosIndex+1) = tmpSearchResult.m_ResultL2LInspectDistance.m_dDistanceMM[1];
			//m_XYDCommProtocol.m_vdDistance.at(2*nPosIndex) = tmpSearchResult.m_ResultL2LInspectDistance.m_dDistanceMM[0];
			m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_L2LDistanceResult=tmpSearchResult.m_ResultL2LInspectDistance;
			m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_bPosSearchFinished=TRUE;

		}
	}

	return TRUE;
}

// 获取关联标定定位的结果
CSearchResult vcBaseVisionAlign::GetAlnCalibTargetSearchResult(int nPosIndex, int nPatIndex)
{
	CSearchResult result;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnCalibTargetSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		pSearchTool->GetResult(0, result);
	}

	return result;
}

// 获取检测定位的结果
CSearchResult vcBaseVisionAlign::GetAlnInspectSearchResult(int nPosIndex, int nPatIndex)
{
	CSearchResult result;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if(nPatIndex >= INSPECTCANDIDATENUM - 1)
	{
		for(nPatIndex = INSPECTCANDIDATENUM;nPatIndex >= 0;nPatIndex--)
		{
			CBaseSearchTool* pSearchTool = GetRepoAlnInspectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

			if (NULL != pSearchTool)
			{
				pSearchTool->GetResult(0, result);
				break;
			}
		}
	}
	else
	{
		CBaseSearchTool* pSearchTool = GetRepoAlnInspectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

		if (NULL != pSearchTool)
		{
			pSearchTool->GetResult(0, result);
		}
	}

	return result;
}

BOOL vcBaseVisionAlign::ExecuteAlnCrossBenchSearch(int nPosIndex, int nPatIndex, CSearchResult& result,BOOL bZeroAngle)
{
	// 根据当前产品信息获取相关定位工具对象
	if (FALSE == m_vImageSearch[nPosIndex].IsValid())
	{
		return FALSE;
	}	

	result.m_dPosX = m_vImageSearch[nPosIndex].Width()/2.0;
	result.m_dPosY = m_vImageSearch[nPosIndex].Height()/2.0;
	result.m_dAngle = 0.0;
	result.m_dScore = 1.0;

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	BOOL bEnableFWEL  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_bEnableWeld;

	if ( (sysPlatformInfo.m_nCamNum==1) && (bEnableFWEL))
	{  
		if(bZeroAngle)
		{
			if (nPosIndex==0)
			{
				result.m_dPosX = 0;//m_vImageSearch[nPosIndex].Width()/2.0;
				result.m_dPosY = m_vImageSearch[nPosIndex].Height()/2.0;
				result.m_dAngle = 0.0;
				result.m_dScore = 1.0;
			}
			else if (nPosIndex==1)
			{
				result.m_dPosX = m_vImageSearch[nPosIndex].Width();
				result.m_dPosY = m_vImageSearch[nPosIndex].Height()/2.0;
				result.m_dAngle = 0.0;
				result.m_dScore = 1.0;
			}
		}
		else
		{
			if (nPosIndex==0)
			{
				result.m_dPosX = m_vImageSearch[nPosIndex].Width()/2.0;
				result.m_dPosY = 0;
				result.m_dAngle = 0.0;
				result.m_dScore = 1.0;
			}
			else if (nPosIndex==1)
			{
				result.m_dPosX = m_vImageSearch[nPosIndex].Width()/2.0;
				result.m_dPosY = m_vImageSearch[nPosIndex].Height();
				result.m_dAngle = 0.0;
				result.m_dScore = 1.0;
			}
		}

	}
	else
	{
		result.m_dPosX = m_vImageSearch[nPosIndex].Width()/2.0;
		result.m_dPosY = m_vImageSearch[nPosIndex].Height()/2.0;
		result.m_dAngle = 0.0;
		result.m_dScore = 1.0;
	}



	return TRUE;
}

CameraParamEnable vcBaseVisionAlign::GetAlnObjectSearchCandidatePatShutterEnable(int nPatIndex)	
{
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	CameraParamEnable cameraParamEnable;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pProductData == NULL)
	{
		return cameraParamEnable;
	}
	if (pProductData->m_pAlignerParam != NULL)
	{
		return pProductData->m_pAlignerParam->GetEnableObjectSearchShutter(nPatIndex);
	}

	return cameraParamEnable;
}

// 获取对位定位的候补模板是否有效
BOOL vcBaseVisionAlign::GetAlnObjectSearchCandidatePatEnable(int nPatIndex)	
{
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pProductData == NULL)
	{
		return FALSE;
	}
	if (pProductData->m_pAlignerParam != NULL)
	{
		return pProductData->m_pAlignerParam->GetObjectCandidateOffsetEnable(nPatIndex);
	}

	return FALSE;
}


// 执行实时对象对位定位
BOOL vcBaseVisionAlign::ExecuteAlnObjectSearch(int nPosIndex, int nPatIndex)
{	
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL == pSearchTool)
	{
		return FALSE;
	}

	if (FALSE == m_vImageSearch[nPosIndex].IsValid())
	{
		return FALSE;
	}	

	if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool)
	{
		if(m_bSearchWithInspect)
		{
			CBaseTrainDataParam *m_pTrainDataParam = new CCornerCheckSearchTrainDataParam();
			pSearchTool->GetTrainDataParam(m_pTrainDataParam);
			((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[0] = true;
			((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[1] = true;
			((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[2] = true;
			((CCornerCheckSearchTool*)pSearchTool)->SetTrainDataParamForce(m_pTrainDataParam);
			if (m_pTrainDataParam !=NULL)
			{
				delete m_pTrainDataParam;
				m_pTrainDataParam =NULL;
			}
		}
		else 
		{
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			if (optionInfo.m_bSearchWithDistanceInspect)
			{
				CBaseTrainDataParam *m_pTrainDataParam = new CCornerCheckSearchTrainDataParam();
				pSearchTool->GetTrainDataParam(m_pTrainDataParam);
				((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[0] = optionInfo.m_bSearchWithDistanceInspect;
				((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[1] = optionInfo.m_bSearchWithDistanceInspect;
				((CCornerCheckSearchTrainDataParam*)m_pTrainDataParam)->m_bEnableInspect[2] = optionInfo.m_bSearchWithDistanceInspect;
				((CCornerCheckSearchTool*)pSearchTool)->SetTrainDataParamForce(m_pTrainDataParam);
				if (m_pTrainDataParam !=NULL)
				{
					delete m_pTrainDataParam;
					m_pTrainDataParam =NULL;
				}
			}
		}

	}



	if (!pSearchTool->Search(m_vImageSearch[nPosIndex]))
	{
		if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool && (m_bSearchWithInspect))
		{   

			if (nPosIndex<4)
			{
				m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_bPosSearchFinished=TRUE;
			}
		}
		return FALSE;
	}
	if(pSearchTool->GetSearchToolType() == eCornerSearchCheckInspectTool && (m_bSearchWithInspect))
	{   
		CSearchResult tmpSearchResult;
		pSearchTool->GetResult(0,tmpSearchResult);
		if (nPosIndex<4)
		{
			//m_XYDCommProtocol.m_vdDistance.at(2*nPosIndex+1) = tmpSearchResult.m_ResultL2LInspectDistance.m_dDistanceMM[1];
			//m_XYDCommProtocol.m_vdDistance.at(2*nPosIndex) = tmpSearchResult.m_ResultL2LInspectDistance.m_dDistanceMM[0];
			m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_L2LDistanceResult=tmpSearchResult.m_ResultL2LInspectDistance;
			m_XYDCommProtocol.m_vstL2LDistanceResult.at(nPosIndex).m_bPosSearchFinished=TRUE;

		}
	}
	// 	else
	// 	{
	// 		m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
	// 	}


	return TRUE;
}

// 获取实时对象对位定位的结果					
CSearchResult vcBaseVisionAlign::GetCalibSearchResult(int nPosIndex, int nPatIndex)
{
	CSearchResult result;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoCalibObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		pSearchTool->GetResult(0, result);
	}

	return result;
}
// 获取实时对象对位定位的结果					
CSearchResult vcBaseVisionAlign::GetAlnObjectSearchResult(int nPosIndex, int nPatIndex)
{
	CSearchResult result;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		pSearchTool->GetResult(0, result);
	}

	return result;
}




std::vector<CSearchResult> vcBaseVisionAlign::GetAlnObjectSearchResults(int nPosIndex, int nPatIndex)
{
	CSearchResult result;
	std::vector<CSearchResult> results;
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		int i = 0; 
		for(i = 0; i < pSearchTool->GetResultNum(); i++)
		{
			pSearchTool->GetResult(i, result);
			results.push_back(result);
		}

	}

	return results;
}

// SY 20171110
// 获取实时对象对位定位结果个数					
int vcBaseVisionAlign::GetAlnObjectSearchResultNumber(int nPosIndex, int nPatIndex)
{
	int nResultNumber = 0;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		//		pSearchTool->GetResult(0, result);
		nResultNumber = pSearchTool->GetResultNum();
	}

	return nResultNumber;
}

// 执行虚拟对象对位定位
BOOL vcBaseVisionAlign::ExecuteAlnVirtualObjectSearch(int nPosIndex, int nPatIndex)
{	
	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnVirtualObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL == pSearchTool)
	{
		return FALSE;
	}

	if (FALSE == m_vImageSearch[nPosIndex].IsValid())
	{
		return FALSE;
	}	

	if (!pSearchTool->Search(m_vImageSearch[nPosIndex]))
	{
		return FALSE;
	}
	// 	else
	// 	{
	// 		m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
	// 	}


	return TRUE;
}

// 获取虚拟对象对位定位的结果					
CSearchResult vcBaseVisionAlign::GetAlnVirtualObjectSearchResult(int nPosIndex, int nPatIndex)
{
	CSearchResult result;

	// 根据当前产品信息获取相关定位工具对象
	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CBaseSearchTool* pSearchTool = GetRepoAlnVirtualObjectSearchTool(nCurProductIndex, nPosIndex, nPatIndex);

	if (NULL != pSearchTool)
	{
		pSearchTool->GetResult(0, result);
	}

	return result;
}

UINT vcBaseVisionAlign::SearchThread( LPVOID pParam)
{
	CSearchObject* pSearchObject = (CSearchObject*)pParam;
	if (pSearchObject == NULL)
	{
		return 0;
	}
	vcBaseVisionAlign* pBaseVisionASM = (vcBaseVisionAlign*) pSearchObject->m_pOwner;
	if (pBaseVisionASM ==  NULL)
	{
		return 0;
	}
	int nPosIndex = pSearchObject->m_nPosIndex;

	pBaseVisionASM->SearchProcess(nPosIndex);

	return 0;
}


void vcBaseVisionAlign::SearchProcess(int nPosIndex)
{
	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{
		return;
	}

	long lSizeX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
	long lSizeY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;

	while(FALSE == m_vbExitSearchThread[nPosIndex])
	{

		m_vbSearchThreadSuspended[nPosIndex] = m_bSuspendWorkThread;
		if(m_vbSearchThreadSuspended[nPosIndex])
		{
			Sleep(1);
			continue;
		}

		if (TRUE == m_vbSearchStart[nPosIndex])
		{
			m_vbSearchStart[nPosIndex] = FALSE;

			// 			// 如果是关键帧显示
			// 			if (m_pSystempOptionConfig->m_nDisplayMode == 1)
			// 			{
			// 				PostMessageUpdateDisplaySearchImage(nPosIndex);
			// 			}

			//			if (m_pVisionASMConfig->m_DataRecord.m_bThreadSaveImageMode)
			if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (1 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
			{
				StartSaveImage(nPosIndex);
			}

			CCoordPos cp;
			SearchMode nSearchMode = m_vsmSearchMode[nPosIndex];
			switch(nSearchMode)// 定位
			{
			case eNoSearch:			
				break;
			case eCalibSearch:
				{		
					CPlatformOptionInfo optionInfo;
					GetPlatformOptionInfo(optionInfo);
					if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
					{
						BOOL bResult;
						BOOL bSuccess = ExecuteAlnCalibTargetDmCodeSearch(nPosIndex);
						bResult = bSuccess;
						if (bSuccess)
						{
							if (m_bIsFirstCalibPos)
							{
								sc2Vector ImagePos;
								sc2Vector BoardPos;
								std::vector<sc2Vector> vImagePos;
								std::vector<sc2Vector> vBoardPos;
								double dImageWidth  = m_vImageInput.at(nPosIndex).Width();
								double dImageHeight = m_vImageInput.at(nPosIndex).Height();
								ImagePos.SetX(dImageWidth/2);
								ImagePos.SetY(dImageHeight/2);
								m_vDmCodeCalibTool.at(nPosIndex).GetCornersImagePos(vImagePos);
								m_vDmCodeCalibTool.at(nPosIndex ).GetCornersLabelPos(vBoardPos);

								m_mpDmCodeImagePos.SetMarkImagePos(nPosIndex, vImagePos);
								m_mpDmCodeBoardPos.SetMarkImagePos(nPosIndex, vBoardPos);

								if(m_pAlignerTool->ConvertSrcPosToDstPos(vImagePos,vBoardPos,ImagePos,BoardPos, TRUE, nPosIndex))
								{
									m_vbSearchSucceed[nPosIndex] = TRUE;
									m_vDmCodeCalibBoardPos.at(nPosIndex).SetPos(BoardPos);
									cp.SetPos(ImagePos);
									m_mpCalibMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	

								}
								else
								{
									bResult = FALSE;
									m_vbSearchSucceed[nPosIndex] = FALSE;
									cp.m_dPosX  = 0;
									cp.m_dPosY  = 0;
									cp.m_dAngle = 0;
									cp.m_dLineAngle1 = 0;
									cp.m_dLineAngle2 = 0;
									m_mpCalibMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
								}
							}
							else
							{
								std::vector<sc2Vector> vImagePos;
								std::vector<sc2Vector> vBoardPos;
								sc2Vector imgPos;
								m_vDmCodeCalibTool.at(nPosIndex).GetCornersImagePos(vImagePos);
								m_vDmCodeCalibTool.at(nPosIndex ).GetCornersLabelPos(vBoardPos);

								m_mpDmCodeImagePos.SetMarkImagePos(nPosIndex, vImagePos);
								m_mpDmCodeBoardPos.SetMarkImagePos(nPosIndex, vBoardPos);

								if (m_pAlignerTool->ConvertSrcPosToDstPos(vBoardPos,vImagePos,m_vDmCodeCalibBoardPos.at(nPosIndex).GetPos(),imgPos, FALSE, nPosIndex))
								{
									m_vbSearchSucceed[nPosIndex] = TRUE;
									cp.SetPos(imgPos);
									m_mpCalibMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	
								}
								else
								{
									bResult = FALSE;
									m_vbSearchSucceed[nPosIndex] = FALSE;
									cp.m_dPosX  = 0;
									cp.m_dPosY  = 0;
									cp.m_dAngle = 0;
									cp.m_dLineAngle1 = 0;
									cp.m_dLineAngle2 = 0;
									m_mpCalibMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
								}
							}
						}
						else
						{
							m_vbSearchSucceed[nPosIndex] = FALSE;
							cp.m_dPosX  = 0;
							cp.m_dPosY  = 0;
							cp.m_dAngle = 0;
							cp.m_dLineAngle1 = 0;
							cp.m_dLineAngle2 = 0;
							m_mpCalibMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
						}
						if (!bResult)
						{
							if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
							{
								SaveSearchNGImage(nPosIndex);
							}
						}

						if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) )
						{
							SaveSearchAllImage(nPosIndex);
						}

						if (bSuccess)
						{
							Sleep(100);
							PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,FALSE);
						}

						m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
						SetEvent(m_vhSearchEndEvent[nPosIndex]);
						m_vbSearchFinished[nPosIndex] = TRUE; // 定位显示结束
					}
					else
					{
						BOOL bSuccess = FALSE;
						int nStartPatIndex = m_vnCalibSearchStartPatIndex[nPosIndex];
						int nEndPatIndex = m_vnCalibSearchEndPatIndex[nPosIndex];
						int nSuccessPatIndex = -1;
						int nPatIndex = 0;
						for(nPatIndex = nStartPatIndex; nPatIndex <= nEndPatIndex ; nPatIndex++)
						{
							if(TRUE == ExecuteCalibTargetSearch(nPosIndex, nPatIndex))
							{							
								bSuccess = TRUE;
								break;
							}			 
						}

						if (bSuccess)
						{
							nSuccessPatIndex = nPatIndex;
							m_vbSearchSucceed[nPosIndex] = TRUE;						 
							m_vSeachResults[nPosIndex] = GetCalibTargetSearchResult(nPosIndex, nPatIndex);

							cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
							cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
							cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
							cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
							cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
							cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
							cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
							cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
							m_mpCalibMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	
							m_vnCalibSearchSuccessPatIndex[nPosIndex] = nSuccessPatIndex;
						}
						else
						{
							m_vbSearchSucceed[nPosIndex] =FALSE;	
							cp.m_dPosX  = 0;
							cp.m_dPosY  = 0;
							cp.m_dAngle = 0;
							cp.m_dLineAngle1 = 0;
							cp.m_dLineAngle2 = 0;
							m_mpCalibMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
							m_vnCalibSearchSuccessPatIndex[nPosIndex] = nStartPatIndex;

							if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
							{
								SaveSearchNGImage(nPosIndex);
							}			 
						}

						if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) )
						{
							SaveSearchAllImage(nPosIndex);
						}

						m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
						SetEvent(m_vhSearchEndEvent[nPosIndex]);

						if (bSuccess)
						{
							std::vector<int> vnPosIndex;
							vnPosIndex.push_back(nPosIndex);
							m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eCalibSearch);
							//PostMessageUpdateCalibTargetSearchGraphics(nPosIndex, nPatIndex, TRUE);
							Sleep(200);
							m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eCalibSearch);
							//PostMessageUpdateCalibTargetSearchGraphics(nPosIndex, nPatIndex, FALSE);
						}

						m_vbSearchFinished[nPosIndex] = TRUE; // 定位显示结束
					}

				}
				break;
				//全局二维码靶标标定时，图像坐标到靶标坐标映射时的二维码搜索
			case eCalibWholeDmcodeBoard:
				{
					CPlatformOptionInfo optionInfo;
					GetPlatformOptionInfo(optionInfo);
					if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
					{
						BOOL bSuccess = ExecuteAlnCalibTargetDmCodeSearch(nPosIndex);
						m_vbSearchSucceed[nPosIndex] = bSuccess;
					}
					m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
					SetEvent(m_vhSearchEndEvent[nPosIndex]);
					m_vbSearchFinished[nPosIndex] = TRUE; // 定位显示结束
					PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,FALSE);
				}
				break;
			case eTargetSearch:
				{
					CPlatformOptionInfo optionInfo;
					GetPlatformOptionInfo(optionInfo);
					if (optionInfo.m_bRecordCamFixMarkPos)
					{
						if (FALSE == GetAlnTargetSearchCandidatePatEnable(4))
						{
							BOOL bFixSearchSuccessed = FALSE;
							CCoordPos cpFixSearchResult;
							CSearchResult FixSearchResult;

							if(TRUE == ExecuteAlnTargetSearch(nPosIndex, 4))
							{
								bFixSearchSuccessed = TRUE;
							}

							if (bFixSearchSuccessed)
							{
								FixSearchResult = GetAlnTargetSearchResult(nPosIndex, 4);

								cpFixSearchResult.m_dPosX = FixSearchResult.m_dPosX;
								cpFixSearchResult.m_dPosY = FixSearchResult.m_dPosY;
								cpFixSearchResult.m_dAngle = FixSearchResult.m_dAngle;

								m_mpFixTargetMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpFixSearchResult);
							}
							else
							{
								cpFixSearchResult.m_dPosX = 0;
								cpFixSearchResult.m_dPosY = 0;
								cpFixSearchResult.m_dAngle = 0;

								m_mpFixTargetMarkImagePos.SetMarkImagePos(nPosIndex, FALSE, cpFixSearchResult);
							}

							// 标记点位置记录
							{

								CString strOut;
								CCoordPos cp;

								cp = m_mpFixTargetMarkImagePos.GetMarkImagePos(nPosIndex);
								strOut.Format(_T("TargetFixMarkPos %d ( %.2f, %.2f ) "), nPosIndex, cp.GetPosX(), cp.GetPosY());

								SearchProcessLogRecord(strOut,m_pPlatformInfo->m_nPlatformIndex,nPosIndex);
							}
						}
					}

					int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
					CProductData* pProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
					BOOL bSync = pProductData->m_pAlignerParam->GetTargetCandidateSyncEnable();

					BOOL bSuccess = FALSE;
					int nStartPatIndex = m_vnTargetSearchStartPatIndex[nPosIndex];
					int nEndPatIndex = m_vnTargetSearchEndPatIndex[nPosIndex];
					int nSuccessPatIndex = -1;
					int nPatIndex = 0;
					for(nPatIndex = nStartPatIndex; nPatIndex <= nEndPatIndex ; nPatIndex++)
					{
						if (nPatIndex > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(nPatIndex)))
						{
							continue;
						}

						if(TRUE == ExecuteAlnTargetSearch(nPosIndex, nPatIndex))
						{	
							bSuccess = TRUE;
							break;
						}			 
					}

					if (bSuccess)
					{
						nSuccessPatIndex = nPatIndex;
						m_vbSearchSucceed[nPosIndex] = TRUE;
						m_vSeachResults[nPosIndex] = GetAlnTargetSearchResult(nPosIndex,nPatIndex);

						cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
						cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
						cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
						cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
						cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
						cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
						cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
						cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
						cp.m_bFindLine1 = m_vSeachResults[nPosIndex].m_bFindLine1;
						cp.m_bFindLine2 = m_vSeachResults[nPosIndex].m_bFindLine2;
						cp.m_SearchRect=m_vSeachResults[nPosIndex].m_resultSearchRect.m_searchRect;
						cp.m_bFindSearchRect=m_vSeachResults[nPosIndex].m_resultSearchRect.m_bFindRect;
						m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
						m_vnTargetSearchSuccessPatIndex[nPosIndex] = nSuccessPatIndex;
						m_vnTargetSearchResultNumber[nPosIndex] = GetAlnTargetSearchResultNumber(nPosIndex,nPatIndex);

						// 配置启用m_bEnableMultiMarkMode多标记点模式
						// 该选项针对 上料、目标对象分离的对位启用多标记点模式，定位工具的选择也需要能够返回多个可用辅助点的工具
						// 定位工具上2v2 ：需要用（区域几何）多标记点、（区域几何）多标记点角定位工具、  区域线圆工具(可用于任意点1边2的的圆形产品对位)
						// 4v4时， 需要用矩形工具、（区域几何）虚拟矩形工具
						{
							//SysPlatformInfo sysPlatformInfo;
							//GetSysPlatformInfo(sysPlatformInfo);
							CAlignerParam* pAlignerParam = GetProductAlignerParam();
							if (NULL != pAlignerParam)
							{
								if ((optionInfo.m_bEnableMultiMarkMode == TRUE)
									&& ((m_pPlatformInfo->m_bTargetObjectCamSeparate && nPosIndex== m_pPlatformInfo->m_nPositionNum/2) || (m_pPlatformInfo->m_bTargetObjectCamSeparate==FALSE && nPosIndex== 0) ))
								{
									// 循环将辅助点设置给目标的每个位置
									int nCurProductIndex = 0;
									nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
									CBaseSearchTool* pSearchTool = GetRepoAlnTargetSearchTool(nCurProductIndex,nPosIndex,nPatIndex);
									if (NULL != pSearchTool )
									{
										// 2位置的多标记点
										if ((m_pPlatformInfo->m_bTargetObjectCamSeparate==TRUE && (m_pPlatformInfo->m_nPositionNum==4)) || (m_pPlatformInfo->m_bTargetObjectCamSeparate==FALSE  && m_pPlatformInfo->m_nPositionNum==2)  )
										{
											// 只有支持多标记点的工具才能进行赋值 //
											if (pSearchTool->GetSearchToolType() == eMQuickCornerSearchTool
												|| pSearchTool->GetSearchToolType() == eMQuickPickCornerSearchTool
												|| pSearchTool->GetSearchToolType() == eMQuickSearchTool
												|| pSearchTool->GetSearchToolType() == eMPatternCornerSearchTool
												|| pSearchTool->GetSearchToolType() == eMPatternPickCornerSearchTool
												|| pSearchTool->GetSearchToolType() == eMPatternSearchTool
												|| pSearchTool->GetSearchToolType() == ePatternLineCircleSearchTool
												|| pSearchTool->GetSearchToolType() == eFixedPosSearchTool)
											{
												int nStartPos = 0;
												if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
												{
													nStartPos = m_pPlatformInfo->m_nPositionNum/2;

													for (int nTempIndex = nStartPos+1; nTempIndex < m_pPlatformInfo->m_nPositionNum; nTempIndex++)
													{
														cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(nTempIndex - m_pPlatformInfo->m_nPositionNum/2 -1);
														cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(nTempIndex - m_pPlatformInfo->m_nPositionNum/2 -1);
														cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(nTempIndex - m_pPlatformInfo->m_nPositionNum/2 -1);
														m_mpTargetMarkImagePos.SetMarkImagePos(nTempIndex, m_vbSearchSucceed[nPosIndex], cp);
														m_vnTargetSearchSuccessPatIndex[nTempIndex] = nSuccessPatIndex;
														m_vnTargetSearchResultNumber[nTempIndex] = GetAlnTargetSearchResultNumber(nPosIndex,nPatIndex);
													}

												}
												else
												{
													nStartPos = 0;

													for (int nTempIndex = nStartPos+1; nTempIndex < m_pPlatformInfo->m_nPositionNum; nTempIndex++)
													{
														cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(nTempIndex -1);
														cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(nTempIndex -1);
														cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(nTempIndex -1);
														m_mpTargetMarkImagePos.SetMarkImagePos(nTempIndex, m_vbSearchSucceed[nPosIndex], cp);
														m_vnTargetSearchSuccessPatIndex[nTempIndex] = nSuccessPatIndex;
														m_vnTargetSearchResultNumber[nTempIndex] = GetAlnTargetSearchResultNumber(nPosIndex,nPatIndex);
													}
												}


											}
										}
										else if ((m_pPlatformInfo->m_bTargetObjectCamSeparate==TRUE && (m_pPlatformInfo->m_nPositionNum==8)) || (m_pPlatformInfo->m_bTargetObjectCamSeparate==FALSE )  )
										{

											if (pSearchTool->GetSearchToolType() == eRectSearchTool
												|| pSearchTool->GetSearchToolType() == ePatternVirtualRectSearchTool
												|| pSearchTool->GetSearchToolType() == eVirtualRectSearchTool)
											{
												// 根据目标是否分离，区分起始位置
												int nStartPos = 0;
												if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
												{
													nStartPos = m_pPlatformInfo->m_nPositionNum/2;

													for (int nTempIndex = nStartPos; nTempIndex < m_pPlatformInfo->m_nPositionNum; nTempIndex++)
													{
														cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(nTempIndex - m_pPlatformInfo->m_nPositionNum/2);
														cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(nTempIndex - m_pPlatformInfo->m_nPositionNum/2);
														cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(nTempIndex - m_pPlatformInfo->m_nPositionNum/2);
														m_mpTargetMarkImagePos.SetMarkImagePos(nTempIndex, m_vbSearchSucceed[nPosIndex], cp);
														m_vnTargetSearchSuccessPatIndex[nTempIndex] = nSuccessPatIndex;
														m_vnTargetSearchResultNumber[nTempIndex] = GetAlnTargetSearchResultNumber(nPosIndex,nPatIndex);
													}
												}
												else
												{
													nStartPos = 0;
													for (int nTempIndex = nStartPos; nTempIndex < m_pPlatformInfo->m_nPositionNum; nTempIndex++)
													{
														cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(nTempIndex);
														cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(nTempIndex);
														cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(nTempIndex);
														m_mpTargetMarkImagePos.SetMarkImagePos(nTempIndex, m_vbSearchSucceed[nPosIndex], cp);
														m_vnTargetSearchSuccessPatIndex[nTempIndex] = nSuccessPatIndex;
														m_vnTargetSearchResultNumber[nTempIndex] = GetAlnTargetSearchResultNumber(nPosIndex,nPatIndex);
													}
												}

											}




										}

									}
								}
							}
						}



					}
					else
					{
						m_vbSearchSucceed[nPosIndex] =FALSE;	
						m_vSeachResults[nPosIndex] = GetAlnTargetSearchResult(nPosIndex,nEndPatIndex);
						cp.m_dPosX  = 0;
						cp.m_dPosY  = 0;
						cp.m_dAngle = 0;
						cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
						cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
						cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
						cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
						cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
						cp.m_bFindLine1 = m_vSeachResults[nPosIndex].m_bFindLine1;
						cp.m_bFindLine2 = m_vSeachResults[nPosIndex].m_bFindLine2;
						cp.m_SearchRect=m_vSeachResults[nPosIndex].m_resultSearchRect.m_searchRect;
						cp.m_bFindSearchRect=m_vSeachResults[nPosIndex].m_resultSearchRect.m_bFindRect;
						m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	
						m_vnTargetSearchSuccessPatIndex[nPosIndex] = nStartPatIndex;				

						if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
						{
							SaveSearchNGImage(nPosIndex);
						}

					}

					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (0 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
					{
						SaveSearchAllImage(nPosIndex);
					}	


					{
						// 标定结果验证：开启就存图；定位失败和成功都使用相同的命名规则；

						// 目标尺寸存图
						if (m_bIsExecuteSizeCheck)
						{
							SYSTEMTIME sys; 
							GetLocalTime(&sys); 

							m_vstrTemp.at(nPosIndex).Format(_T("%04d_%02d_%02d_%02d_%02d_%02d_%02d_ImageTargetSearchFailed_TargetSizeCheck_CH%02d_Times%03d.bmp"), 
								sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex, m_nExecuteCheckTimes);

							CString strPath = m_strDataRecord + _T("\\AlignTool");
							SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));	

						}
						// 目标固定，对象拍照，验证对位过程存图
						else if (m_bIsExecuteFixTargetCheck)
						{
							SYSTEMTIME sys; 
							GetLocalTime(&sys); 

							m_vstrTemp.at(nPosIndex).Format(_T("%04d_%02d_%02d_%02d_%02d_%02d_%02d_ImageTargetSearchFailed_TargetFixCheck_CH%02d_Times%03d.bmp"), 
								sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex, m_nExecuteCheckTimes);

							CString strPath = m_strDataRecord + _T("\\AlignTool");
							SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));	
						}
					}



					m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
					SetEvent(m_vhSearchEndEvent[nPosIndex]);

					m_vbSearchFinished[nPosIndex] = TRUE;
				}
				break;
			case eObjectSearch:
				{
					CPlatformOptionInfo optionInfo;
					GetPlatformOptionInfo(optionInfo);
					//SysPlatformInfo sysPlatformInfo;
					//GetSysPlatformInfo(sysPlatformInfo);
					// 对象-标记点记录
					if (optionInfo.m_bRecordCamFixMarkPos)
					{
						if (FALSE == GetAlnObjectSearchCandidatePatEnable(4))
						{
							BOOL bFixSearchSuccessed = FALSE;
							CCoordPos cpFixSearchResult;
							CSearchResult FixSearchResult;

							if(TRUE == ExecuteAlnObjectSearch(nPosIndex, 4))
							{
								bFixSearchSuccessed = TRUE;
							}

							if (bFixSearchSuccessed)
							{
								FixSearchResult = GetAlnObjectSearchResult(nPosIndex, 4);

								cpFixSearchResult.m_dPosX = FixSearchResult.m_dPosX;
								cpFixSearchResult.m_dPosY = FixSearchResult.m_dPosY;
								cpFixSearchResult.m_dAngle = FixSearchResult.m_dAngle;

								m_mpFixObjectMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpFixSearchResult);
							}
							else
							{
								cpFixSearchResult.m_dPosX = 0;
								cpFixSearchResult.m_dPosY = 0;
								cpFixSearchResult.m_dAngle = 0;

								m_mpFixObjectMarkImagePos.SetMarkImagePos(nPosIndex, FALSE, cpFixSearchResult);
							}

							// 标记点位置记录
							{

								CString strOut;
								CCoordPos cp;

								cp = m_mpFixObjectMarkImagePos.GetMarkImagePos(nPosIndex);
								strOut.Format(_T("ObjectFixMarkPos %d ( %.2f, %.2f ) "), nPosIndex, cp.GetPosX(), cp.GetPosY());

								SearchProcessLogRecord(strOut,m_pPlatformInfo->m_nPlatformIndex,nPosIndex);
							}

						}
					}

					{
						// 十字中心基准目标
						{
							BOOL bSuccess = FALSE;
							int nPatIndex = 0;
							CSearchResult result;
							bSuccess = ExecuteAlnCrossBenchSearch(nPosIndex, nPatIndex, result);
							if (bSuccess)
							{
								cp.m_dPosX  = result.m_dPosX;
								cp.m_dPosY  = result.m_dPosY;
								cp.m_dAngle = result.m_dAngle;
								cp.m_vdAuxiliaryPosX = result.m_vdAuxiliaryPosX;
								cp.m_vdAuxiliaryPosY = result.m_vdAuxiliaryPosY;
								cp.m_vdAuxiliaryAngle =result.m_vdAuxiliaryAngle;
								cp.m_dLineAngle1 = result.m_dLineAngle1;
								cp.m_dLineAngle2 = result.m_dLineAngle2;
								m_mpCrossBenchMarkImagePos.SetMarkImagePos(nPosIndex, bSuccess, cp);	
							}
							else
							{
								cp.m_dPosX  = 0;
								cp.m_dPosY  = 0;
								cp.m_dAngle = 0;
								cp.m_dLineAngle1 = 0;
								cp.m_dLineAngle2 = 0;
								m_mpCrossBenchMarkImagePos.SetMarkImagePos(nPosIndex, bSuccess, cp);
							}
						}


						BOOL bSuccess = FALSE;
						int nStartPatIndex = m_vnObjectSearchStartPatIndex[nPosIndex];
						int nEndPatIndex = m_vnObjectSearchEndPatIndex[nPosIndex];
						int nSuccessPatIndex = -1;
						int nPatIndex = 0;
						for(nPatIndex = nStartPatIndex; nPatIndex <= nEndPatIndex ; nPatIndex++)
						{
							if (nPatIndex > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(nPatIndex)))
							{
								continue;
							}

							if(TRUE == ExecuteAlnObjectSearch(nPosIndex, nPatIndex))
							{							
								bSuccess = TRUE;
								break;
							}			 
						}


						if (bSuccess)
						{



							CAlignerParam* pAlignerParam = GetProductAlignerParam();

							/*if ((m_pPlatformInfo->m_bPlatformPick == TRUE && m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformSepFix) 
							&& (m_pSystempOptionConfig->m_bOmitRePickObjectEnable == TRUE)
							&& (pAlignerParam->m_bDiffPosWithSameSearchResultEnabled) && (nPosIndex == 0))*/
							if ((m_pPlatformInfo->m_bPlatformPick == TRUE && m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformSepFix) 
								&& (optionInfo.m_bOmitRePickObjectEnable == TRUE)
								&& (optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
							{
								// 如果是拾取,且相机固定安装全景拾取，支持忽略拾取不起来的产品
								// 只判断第一个Mark的定位结果，是否已经出现过
								// 另外，还要判断是否出现了，换盘信号，即可以拾取的只有1片了（这里有个需要注意的问题是，定位工具设置的搜索数量要足够多，多于可能拾不起来产品的数量）

								std::vector<CSearchResult> vTempSeachResults;
								vTempSeachResults = GetAlnObjectSearchResults(nPosIndex,nPatIndex);

								BOOL bRePicked = FALSE;		// 是否是重复的
								BOOL bTempSucceed = FALSE;
								int nFirstTempIndex = -1;
								int nTempPickNum = 0;
								int nTempIndex = 0;							
								int nSearchedIndex = 0;

								for (nTempIndex = 0; nTempIndex < vTempSeachResults.size(); nTempIndex++)
								{
									bRePicked = FALSE;
									// 如果当前找到的定位结果，与以前已经找到的偏差在设置范围内，则认为重复没有拾取起来
									for (nSearchedIndex = 0; nSearchedIndex < m_vObjectSearchedSeachResults.size(); nSearchedIndex++)
									{									
										if (fabs(vTempSeachResults[nTempIndex].m_dPosX - m_vObjectSearchedSeachResults[nSearchedIndex].m_dPosX) < optionInfo.m_dRePickOffsetMaxX
											&& fabs(vTempSeachResults[nTempIndex].m_dPosY - m_vObjectSearchedSeachResults[nSearchedIndex].m_dPosY) < optionInfo.m_dRePickOffsetMaxY)
										{
											bRePicked = TRUE;
											break;
										}
									}

									// 如果没有类似的结果
									if (bRePicked == FALSE)
									{
										if (nFirstTempIndex == -1)
										{
											nFirstTempIndex = nTempIndex;
											nTempPickNum++;
											bTempSucceed = TRUE;
										}
										else
										{
											nTempPickNum++;
										}
									}
								}

								if (bTempSucceed == TRUE && nFirstTempIndex != -1)
								{
									// 存储要拾取的定位结果
									m_vObjectSearchedSeachResults.push_back(vTempSeachResults[nFirstTempIndex]);

									nSuccessPatIndex = nPatIndex;
									m_vbSearchSucceed[nPosIndex] = TRUE;
									m_vSeachResults[nPosIndex] = vTempSeachResults[nFirstTempIndex];

									cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
									cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
									cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
									cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
									cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
									cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
									cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
									cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
									m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	
									m_vnObjectSearchSuccessPatIndex[nPosIndex] = nSuccessPatIndex;
									m_vnObjectSearchResultNumber[nPosIndex] = nTempPickNum;



									CAlignerParam* pAlignerParam = GetProductAlignerParam();
									if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
									{	
										m_vbSearchSucceed[nPosIndex+1] = TRUE;
										cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(0);
										cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(0);
										cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(0);
										m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex+1, m_vbSearchSucceed[nPosIndex], cp);	
										m_vnObjectSearchSuccessPatIndex[nPosIndex+1] = nSuccessPatIndex;
										m_vnObjectSearchResultNumber[nPosIndex+1] = nTempPickNum;
									}
								}
								else
								{
									bSuccess = FALSE;

									m_vbSearchSucceed[nPosIndex] =FALSE;		
									cp.m_dPosX  = 0;
									cp.m_dPosY  = 0;
									cp.m_dAngle = 0;
									cp.m_dLineAngle1 = 0;
									cp.m_dLineAngle2 = 0;
									m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);

									CAlignerParam* pAlignerParam = GetProductAlignerParam();
									if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
									{
										cp.m_dPosX  = 0;
										cp.m_dPosY  = 0;
										cp.m_dAngle = 0;
										cp.m_dLineAngle1 = 0;
										cp.m_dLineAngle2 = 0;
										m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex+1, m_vbSearchSucceed[nPosIndex], cp);	
									}

								}
							}
							else if ((m_pPlatformInfo->m_bPlatformPick == TRUE && m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformSepFix) 
								&& (optionInfo.m_bOmitRePickObjectEnable_MM == TRUE)
								&& (optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
							{

							}
							else
							{
								nSuccessPatIndex = nPatIndex;
								m_vbSearchSucceed[nPosIndex] = TRUE;
								m_vSeachResults[nPosIndex] = GetAlnObjectSearchResult(nPosIndex,nPatIndex);

								cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
								cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
								cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
								cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
								cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
								cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
								cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
								cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
								cp.m_bFindLine1 = m_vSeachResults[nPosIndex].m_bFindLine1;
								cp.m_bFindLine2 = m_vSeachResults[nPosIndex].m_bFindLine2;
								cp.m_SearchRect=m_vSeachResults[nPosIndex].m_resultSearchRect.m_searchRect;
								cp.m_bFindSearchRect=m_vSeachResults[nPosIndex].m_resultSearchRect.m_bFindRect;
								m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	
								m_vnObjectSearchSuccessPatIndex[nPosIndex] = nSuccessPatIndex;
								m_vnObjectSearchResultNumber[nPosIndex] = GetAlnObjectSearchResultNumber(nPosIndex,nPatIndex);

								CAlignerParam* pAlignerParam = GetProductAlignerParam();
								if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (m_pPlatformInfo->m_bPlatformPick == TRUE))
								{
									m_vbSearchSucceed[nPosIndex+1] = TRUE;
									cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(0);
									cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(0);
									cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(0);
									m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex+1, m_vbSearchSucceed[nPosIndex], cp);	
									m_vnObjectSearchSuccessPatIndex[nPosIndex+1] = nSuccessPatIndex;
									m_vnObjectSearchResultNumber[nPosIndex+1] = GetAlnObjectSearchResultNumber(nPosIndex,nPatIndex);
								}

								// 配置启用m_bEnableMultiMarkMode多标记点模式
								{
									if (NULL != pAlignerParam)
									{
										if ((optionInfo.m_bEnableMultiMarkMode == TRUE)
											&& ( nPosIndex== 0) && (m_pPlatformInfo->m_bPlatformPick == FALSE))
										{
											// 循环将辅助点设置给对象的每个位置
											int nCurProductIndex = 0;
											nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
											CBaseSearchTool* pSearchTool = GetRepoAlnObjectSearchTool(nCurProductIndex,nPosIndex,nPatIndex);

											if (NULL != pSearchTool )
											{
												// 2位置的多标记点
												if ((m_pPlatformInfo->m_bTargetObjectCamSeparate==TRUE && (m_pPlatformInfo->m_nPositionNum==4)) || (m_pPlatformInfo->m_bTargetObjectCamSeparate==FALSE  && m_pPlatformInfo->m_nPositionNum==2)  )
												{
													// 只有支持多标记点的工具才能进行赋值 //
													if (pSearchTool->GetSearchToolType() == eMQuickCornerSearchTool
														|| pSearchTool->GetSearchToolType() == eMQuickPickCornerSearchTool
														|| pSearchTool->GetSearchToolType() == eMQuickSearchTool
														|| pSearchTool->GetSearchToolType() == eMPatternCornerSearchTool
														|| pSearchTool->GetSearchToolType() == eMPatternPickCornerSearchTool
														|| pSearchTool->GetSearchToolType() == eMPatternSearchTool
														|| pSearchTool->GetSearchToolType() == ePatternLineCircleSearchTool
														|| pSearchTool->GetSearchToolType() == eFixedPosSearchTool)
													{
														int nEndPos = m_pPlatformInfo->m_nPositionNum;
														if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
														{
															nEndPos = m_pPlatformInfo->m_nPositionNum/2;
														}

														for (int nTempIndex = 1; nTempIndex < nEndPos; nTempIndex++)
														{
															cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(nTempIndex-1);
															cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(nTempIndex-1);
															cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(nTempIndex-1);
															m_mpObjectMarkImagePos.SetMarkImagePos(nTempIndex, m_vbSearchSucceed[nPosIndex], cp);	
															m_vnObjectSearchSuccessPatIndex[nTempIndex] = nSuccessPatIndex;
															m_vnObjectSearchResultNumber[nTempIndex] = GetAlnObjectSearchResultNumber(nPosIndex,nPatIndex);
														}
													}
												}
												else if ((m_pPlatformInfo->m_bTargetObjectCamSeparate==TRUE && (m_pPlatformInfo->m_nPositionNum==8)) || (m_pPlatformInfo->m_bTargetObjectCamSeparate==FALSE )  )
												{

													if (pSearchTool->GetSearchToolType() == eRectSearchTool
														|| pSearchTool->GetSearchToolType() == ePatternRectSearchTool
														|| pSearchTool->GetSearchToolType() == ePatternVirtualRectSearchTool
														|| pSearchTool->GetSearchToolType() == eVirtualRectSearchTool)
													{
														// 根据目标是否分离，区分起始位置
														int nEndPos = m_pPlatformInfo->m_nPositionNum;
														if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
														{
															nEndPos = m_pPlatformInfo->m_nPositionNum/2;
														}

														for (int nTempIndex = 0; nTempIndex < nEndPos; nTempIndex++)
														{
															cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(nTempIndex);
															cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(nTempIndex);
															cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(nTempIndex);
															m_mpObjectMarkImagePos.SetMarkImagePos(nTempIndex, m_vbSearchSucceed[nPosIndex], cp);	
															m_vnObjectSearchSuccessPatIndex[nTempIndex] = nSuccessPatIndex;
															m_vnObjectSearchResultNumber[nTempIndex] = GetAlnObjectSearchResultNumber(nPosIndex,nPatIndex);
														}
													}




												}

											}
										}
									}
								}

							}

						}			
						else
						{
							m_vbSearchSucceed[nPosIndex] =FALSE;	
							m_vSeachResults[nPosIndex] = GetAlnObjectSearchResult(nPosIndex,nEndPatIndex);
							cp.m_dPosX  = 0;
							cp.m_dPosY  = 0;
							cp.m_dAngle = 0;
							cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
							cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
							cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
							cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
							cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
							cp.m_bFindLine1 = m_vSeachResults[nPosIndex].m_bFindLine1;
							cp.m_bFindLine2 = m_vSeachResults[nPosIndex].m_bFindLine2;
							cp.m_SearchRect=m_vSeachResults[nPosIndex].m_resultSearchRect.m_searchRect;
							cp.m_bFindSearchRect=m_vSeachResults[nPosIndex].m_resultSearchRect.m_bFindRect;
							m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
							m_vnObjectSearchSuccessPatIndex[nPosIndex] = nStartPatIndex;


							CAlignerParam* pAlignerParam = GetProductAlignerParam();
							if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
							{
								cp.m_dPosX  = 0;
								cp.m_dPosY  = 0;
								cp.m_dAngle = 0;
								cp.m_dLineAngle1 = 0;
								cp.m_dLineAngle2 = 0;
								m_vbSearchSucceed[nPosIndex+1] = FALSE;
								m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex+1, m_vbSearchSucceed[nPosIndex], cp);	
							}


							if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
							{
								SaveSearchNGImage(nPosIndex);
							}
						}


						if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (0 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
						{
							SaveSearchAllImage(nPosIndex);
						}

						{
							// 标定结果验证：开启就存图；定位失败和成功都使用相同的命名规则；

							// 对象尺寸存图
							if (m_bIsExecuteSizeCheck)
							{
								SYSTEMTIME sys; 
								GetLocalTime(&sys); 

								m_vstrTemp.at(nPosIndex).Format(_T("%04d_%02d_%02d_%02d_%02d_%02d_%02d_ImageObjectSearch_ObjectSizeCheck_CH%02d_Times%03d.bmp"), 
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex, m_nExecuteCheckTimes);

								CString strPath = m_strDataRecord + _T("\\AlignTool");
								SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
							}
							// 对位过程，目标固定，对象存图
							else if (m_bIsExecuteFixTargetCheck)
							{
								SYSTEMTIME sys; 
								GetLocalTime(&sys); 

								m_vstrTemp.at(nPosIndex).Format(_T("%04d_%02d_%02d_%02d_%02d_%02d_%02d_ImageObjectSearch_TargetFixCheck_CH%02d_Times%03d.bmp"), 
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex, m_nExecuteCheckTimes);

								CString strPath = m_strDataRecord + _T("\\AlignTool");
								SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
							}
							// 使用标定走位的方式进行验证产品尺寸
							else if (optionInfo.m_bEnableCalibrateCheckByAxisMoveOption)
							{
								SYSTEMTIME sys; 
								GetLocalTime(&sys); 

								m_vstrTemp.at(nPosIndex).Format(_T("%04d_%02d_%02d_%02d_%02d_%02d_%02d_ImageObjectSearch_CalibrateCheck_CH%02d.bmp"), 
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

								CString strPath = m_strDataRecord + _T("\\AlignTool");
								SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
							}
						}

						m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
						SetEvent(m_vhSearchEndEvent[nPosIndex]);

						m_vbSearchFinished[nPosIndex] = TRUE;
					}	
				}

				break;
			case eVirtualSearch:
				{

					BOOL bSuccess = FALSE;
					int nStartPatIndex = m_vnVirtualObjectSearchStartPatIndex[nPosIndex];
					int nEndPatIndex = m_vnVirtualObjectSearchEndPatIndex[nPosIndex];
					int nSuccessPatIndex = -1;
					int nPatIndex = 0;
					for(nPatIndex = nStartPatIndex; nPatIndex <= nEndPatIndex ; nPatIndex++)
					{
						if(TRUE == ExecuteAlnVirtualObjectSearch(nPosIndex, nPatIndex))
						{							
							bSuccess = TRUE;
							break;
						}			 
					}


					if (bSuccess)
					{
						nSuccessPatIndex = nPatIndex;
						m_vbSearchSucceed[nPosIndex] = TRUE;
						m_vSeachResults[nPosIndex] = GetAlnVirtualObjectSearchResult(nPosIndex,nPatIndex);

						cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
						cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
						cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
						cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
						cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
						cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
						cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
						cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
						m_mpVirtualMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
						m_vnVirtualObjectSearchSuccessPatIndex[nPosIndex] = nSuccessPatIndex;
					}
					else
					{
						m_vbSearchSucceed[nPosIndex] =FALSE;		
						cp.m_dPosX  = 0;
						cp.m_dPosY  = 0;
						cp.m_dAngle = 0;
						cp.m_dLineAngle1 = 0;
						cp.m_dLineAngle2 = 0;
						m_mpVirtualMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
						m_vnVirtualObjectSearchSuccessPatIndex[nPosIndex] = nStartPatIndex;			


						if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
						{
							SaveSearchNGImage(nPosIndex);
						}

					}


					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (0 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
					{
						SaveSearchAllImage(nPosIndex);
					}

					m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
					SetEvent(m_vhSearchEndEvent[nPosIndex]);

					m_vbSearchFinished[nPosIndex] = TRUE;
				}			
				break;
			case eCalibTargetSearch:
				{
					int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
					CProductData* pProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);

					BOOL bSuccess = FALSE;
					int nStartPatIndex = m_vnCalibTargetSearchStartPatIndex[nPosIndex];
					int nEndPatIndex = m_vnCalibTargetSearchEndPatIndex[nPosIndex];
					int nSuccessPatIndex = -1;
					int nPatIndex = 0;
					for(nPatIndex = nStartPatIndex; nPatIndex <= nEndPatIndex ; nPatIndex++)
					{
						if(TRUE == ExecuteAlnCalibTargetSearch(nPosIndex, nPatIndex))
						{	
							bSuccess = TRUE;
							break;
						}			 
					}

					if (bSuccess)
					{
						nSuccessPatIndex = nPatIndex;
						m_vbSearchSucceed[nPosIndex] = TRUE;
						m_vSeachResults[nPosIndex] = GetAlnCalibTargetSearchResult(nPosIndex,nPatIndex);

						cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
						cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
						cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
						cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
						cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
						cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
						cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
						cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
						m_mpCalibTargetMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
						m_vnCalibTargetSearchSuccessPatIndex[nPosIndex] = nSuccessPatIndex;
					}
					else
					{
						m_vbSearchSucceed[nPosIndex] =FALSE;		
						cp.m_dPosX  = 0;
						cp.m_dPosY  = 0;
						cp.m_dAngle = 0;
						cp.m_dLineAngle1 = 0;
						cp.m_dLineAngle2 = 0;
						m_mpCalibTargetMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	
						m_vnCalibTargetSearchSuccessPatIndex[nPosIndex] = nStartPatIndex;					

						if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
						{
							SaveSearchNGImage(nPosIndex);
						}						
					}

					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) )
					{
						SaveSearchAllImage(nPosIndex);
					}	

					m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
					SetEvent(m_vhSearchEndEvent[nPosIndex]);

					m_vbSearchFinished[nPosIndex] = TRUE;
				}
				break;

			case eInspectSearch:
				{
					BOOL bSuccess = FALSE;
					int nStartPatIndex = m_vnInspectSearchStartPatIndex[nPosIndex];
					int nEndPatIndex = m_vnInspectSearchEndPatIndex[nPosIndex];
					int nSuccessPatIndex = -1;
					int nPatIndex = 0;
					// 定位失败时显示GUI时候补index
					int nLastPatIndex = 0;
					int nCurProdcutIndex = 0;
					BOOL bInspectSearchCandidate = FALSE;
					if(m_pVisionASMConfig!=NULL)
					{
						nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
						if(m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam!=NULL)
						{
							bInspectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
						}

					}

					for(nPatIndex = nStartPatIndex; nPatIndex <= nEndPatIndex ; nPatIndex++)
					{
						if (nPatIndex > 0 && (FALSE == GetAlnInspectSearchCandidatePatEnable(nPatIndex)))
						{
							continue;
						}

						CBaseSearchTool* pInspectTool = GetRepoAlnInspectSearchTool(nCurProdcutIndex, nPosIndex, nPatIndex);
						if (pInspectTool !=NULL && TRUE == GetAlnInspectSearchCandidatePatEnable(nPatIndex) && bInspectSearchCandidate)
						{
							nLastPatIndex = nPatIndex;
						}

						if(TRUE == ExecuteAlnInspectSearch(nPosIndex, nPatIndex))
						{							
							bSuccess = TRUE;
							break;
						}			 
					}

					if (bSuccess)
					{
						nSuccessPatIndex = nPatIndex;
						m_vbSearchSucceed[nPosIndex] = TRUE;
						m_vSeachResults[nPosIndex] = GetAlnInspectSearchResult(nPosIndex,nPatIndex);

						cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
						cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
						cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
						// 						cp.m_dWidth = m_vSeachResults[nPosIndex].m_dWidth;
						// 						cp.m_dHeight = m_vSeachResults[nPosIndex].m_dHeight;
						cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
						cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
						cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
						cp.m_dLineAngle1 = m_vSeachResults[nPosIndex].m_dLineAngle1;
						cp.m_dLineAngle2 = m_vSeachResults[nPosIndex].m_dLineAngle2;
						m_mpInspectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
						m_vnInspectSearchSuccessPatIndex[nPosIndex] = nSuccessPatIndex;
					}
					else
					{
						m_vSeachResults[nPosIndex] = GetAlnInspectSearchResult(nPosIndex,nPatIndex-1);
						m_vnInspectSearchSuccessPatIndex[nPosIndex] = nLastPatIndex;
						m_vbSearchSucceed[nPosIndex] =FALSE;		
						cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
						cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
						cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
						// 						cp.m_dWidth = m_vSeachResults[nPosIndex].m_dWidth;
						// 						cp.m_dHeight = m_vSeachResults[nPosIndex].m_dHeight;
						cp.m_vdAuxiliaryPosX = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX;
						cp.m_vdAuxiliaryPosY = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY;
						cp.m_vdAuxiliaryAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle;
						m_mpInspectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);
						m_vnInspectSearchSuccessPatIndex[nPosIndex] = nStartPatIndex;				


						if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
						{
							SaveSearchNGImage(nPosIndex);
						}	
					}

					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (0 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
					{
						SaveSearchAllImage(nPosIndex);
					}

					m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
					SetEvent(m_vhSearchEndEvent[nPosIndex]);

					m_vbSearchFinished[nPosIndex] = TRUE;
				}			
				break;

			case eAutoCalibTargetSearch:
				{
					if (GetCalibTargetMarkPatternMode() == eDmCodeCalib)
					{
						m_vbSearchSucceed[nPosIndex]=ExecuteAlnCalibTargetDmCodeSearch(nPosIndex);
					}
					else
					{
						ExecuteAlnCalibTargetAutoSearch(nPosIndex);
					}

					if (!m_vbSearchSucceed[nPosIndex])
					{
						if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
						{
							SaveSearchNGImage(nPosIndex);
						}
					}

					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) )
					{
						SaveSearchAllImage(nPosIndex);
					}

					m_vbSearchEnd[nPosIndex] = TRUE;	// 定位结束	
					SetEvent(m_vhSearchEndEvent[nPosIndex]);

					m_vbSearchFinished[nPosIndex] = TRUE;
				}
				break;
			default:
				break;
			}	

			//			if (m_pVisionASMConfig->m_DataRecord.m_bThreadSaveImageMode)
			if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (1 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
			{
				WaitSaveImage(nPosIndex);
			}

			//m_vbSearchEnd[nPosIndex] = TRUE;
		}		

		Sleep(1);
	}
}

BOOL vcBaseVisionAlign::SaveSearchNGImage(int nPosIndex)
{
	if (!m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
	{
		return TRUE;
	}

	SearchMode nSearchMode = m_vsmSearchMode[nPosIndex];
	switch(nSearchMode)// 定位
	{
	case eNoSearch:		
		{

		}
		break;
	case eCalibSearch:
		{
			SYSTEMTIME sys; 
			GetLocalTime(&sys); 

			m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibSearchFailed.bmp"),
				sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

			m_vSaveCalibSearchImageFailIndex.at(nPosIndex) = m_vSaveCalibSearchImageFailIndex.at(nPosIndex) + 1;

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				m_vstrTemp.at(nPosIndex).Format(_T("ImageCalibSearchFailed-CH%02d-%03d.bmp"), 
					nPosIndex,m_vSaveCalibSearchImageFailIndex.at(nPosIndex));
			}

			CString strPath = m_strDataRecord + _T("\\AlignTool");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

			if(m_vSaveCalibSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveCalibSearchImageFailIndex.at(nPosIndex) = 0;
			}
		}
		break;

	case eCalibWholeDmcodeBoard:
		{

		}
		break;

	case eTargetSearch:
		{
			m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) + 1;

			SYSTEMTIME sys; 
			GetLocalTime(&sys); 

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")))
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d.bmp"), 
						nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));

					m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);

				}
				else
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d.bmp"), 
						nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));
				}

			}
			else
			{
				if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")))
				{
					m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

					m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);

				}
				else
				{
					m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
				}

			}

			CString strPath = m_strDataRecord + _T("\\AlignProcess");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
			if(m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = 0;
			}

		}
		break;

	case eObjectSearch:
		{
			m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;

			SYSTEMTIME sys; 
			GetLocalTime(&sys); 

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d.bmp"), 
						nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));

					m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
				}
				else
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d.bmp"), 
						nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
				}

			}
			else
			{
				if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
				{
					m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

					m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
				}
				else
				{
					m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
				}

			}

			CString strPath = m_strDataRecord + _T("\\AlignProcess");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

			if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
			}
		}
		break;

	case eVirtualSearch:
		{
			m_vSaveAlignerVirtualSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerVirtualSearchImageFailIndex.at(nPosIndex) + 1;	

			SYSTEMTIME sys; 
			GetLocalTime(&sys); 							

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageVirtualObjectSearchFailed-CH%02d-%03d.bmp"), 
						nPosIndex,m_vSaveAlignerVirtualSearchImageFailIndex.at(nPosIndex));

					m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
				}
				else
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageVirtualObjectSearchFailed-CH%02d-%03d.bmp"), 
						nPosIndex,m_vSaveAlignerVirtualSearchImageFailIndex.at(nPosIndex));
				}

			}
			else
			{
				if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
				{
					m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageVirtualObjectSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

					m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
				}
				else
				{
					m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageVirtualObjectSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
				}

			}

			CString strPath = m_strDataRecord + _T("\\AlignProcess");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
			if(m_vSaveAlignerVirtualSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerVirtualSearchImageFailIndex.at(nPosIndex) = 0;
			}				
		}			
		break;

	case eCalibTargetSearch:
		{
			SYSTEMTIME sys; 
			GetLocalTime(&sys); 
			m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
				sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

			m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex) + 1;

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				m_vstrTemp.at(nPosIndex).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
					nPosIndex,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex));
			}

			CString strPath = m_strDataRecord + _T("\\AlignTool");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
			if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex) = 0;
			}	
		}
		break;

	case eInspectSearch:
		{
			m_vSaveAlignerInspectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerInspectSearchImageFailIndex.at(nPosIndex) + 1;

			SYSTEMTIME sys; 
			GetLocalTime(&sys); 

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageInspectSearchFailed-CH%02d-%03d.bmp"), 
						nPosIndex,m_vSaveAlignerInspectSearchImageFailIndex.at(nPosIndex));

					m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
				}
				else
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageInspectSearchFailed-CH%02d-%03d.bmp"), 
						nPosIndex,m_vSaveAlignerInspectSearchImageFailIndex.at(nPosIndex));
				}
			}
			else
			{
				if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
				{
					m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageInspectSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

					m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
				}
				else
				{
					m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageInspectSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
				}
			}

			CString strPath = m_strDataRecord + _T("\\AlignProcess");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

			if(m_vSaveAlignerInspectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerInspectSearchImageFailIndex.at(nPosIndex) = 0;
			}
		}			
		break;

	case eAutoCalibTargetSearch:
		{
			CTime t = CTime::GetCurrentTime();	
			m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
				t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

			SYSTEMTIME sys; 
			GetLocalTime(&sys); 
			m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
				sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

			m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex) + 1;

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				m_vstrTemp.at(nPosIndex).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
					nPosIndex,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex));
			}

			CString strPath = m_strDataRecord + _T("\\AlignTool");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
			if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nPosIndex) = 0;
			}
		}
		break;

	default:
		break;

	}


	return TRUE;
}

BOOL vcBaseVisionAlign::SaveSearchAllImage(int nPosIndex)
{
	if (!m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage)
	{
		return TRUE;
	}

	SearchMode nSearchMode = m_vsmSearchMode[nPosIndex];
	switch(nSearchMode)// 定位
	{
	case eNoSearch:		
		{

		}
		break;
	case eCalibSearch:
		{
			// 标定，不涉及到线程存图
			SYSTEMTIME sys; 
			GetLocalTime(&sys); 
			m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibSearch.bmp"),
				sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

			m_vSaveCalibSearchImageIndex.at(nPosIndex) = m_vSaveCalibSearchImageIndex.at(nPosIndex) + 1;

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				m_vstrTemp.at(nPosIndex).Format(_T("ImageCalibSearch-CH%02d-%03d.bmp"), 
					nPosIndex,m_vSaveCalibSearchImageIndex.at(nPosIndex));
			}

			CString strPath = m_strDataRecord + _T("\\AlignTool");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

			if(m_vSaveCalibSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum)
			{
				m_vSaveCalibSearchImageIndex.at(nPosIndex) = 0;
			}
		}
		break;

		//全局二维码靶标标定时，图像坐标到靶标坐标映射时的二维码搜索
	case eCalibWholeDmcodeBoard:
		{

		}
		break;

	case eTargetSearch:
		{
			if (0 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType)
			{
				if (m_bIsExecuteSizeCheck || m_bIsExecuteFixTargetCheck)
				{
					break;
				}

				m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex) + 1;

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 					

				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
					{
						m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearch-CH%02d-%03d.bmp"), nPosIndex,m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex));

						m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
					}
					else
					{
						m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearch-CH%02d-%03d.bmp"), nPosIndex,m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex));
					}


				}
				else
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
					{
						m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearch.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

						m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
					}
					else
					{
						m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearch.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
					}

				}

				CString strPath = m_strDataRecord + _T("\\Image文件");
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

				if(m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum)
				{
					m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex) = 0;
				}
			}	


		}
		break;
	case eObjectSearch:
		{
			if (0 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType)
			{
				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);

				if (m_bIsExecuteSizeCheck || m_bIsExecuteFixTargetCheck || optionInfo.m_bEnableCalibrateCheckByAxisMoveOption)
				{
					break;
				}

				m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;

				SYSTEMTIME sys; 
				GetLocalTime(&sys);							

				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
					{
						m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearch-CH%02d-%03d.bmp"), 
							nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));

						m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
					}
					else
					{
						m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearch-CH%02d-%03d.bmp"), 
							nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
					}

				}
				else
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
					{
						m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearch.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

						m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
					}
					else
					{
						m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearch.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
					}

				}


				CString strPath = m_strDataRecord + _T("\\Image文件");
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

				if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum)
				{
					m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}
		}
		break;
	case eVirtualSearch:
		{
			if (0 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType)
			{
				m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex) = m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex) + 1;	

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 

				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
					{
						m_vstrTemp.at(nPosIndex).Format(_T("ImageVirtualObjectSearch-CH%02d-%03d.bmp"), 
							nPosIndex,m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex));

						m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
					}
					else
					{
						m_vstrTemp.at(nPosIndex).Format(_T("ImageVirtualObjectSearch-CH%02d-%03d.bmp"), 
							nPosIndex,m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex));
					}

				}
				else
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
					{
						m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageVirtualObjectSearch.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

						m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
					}
					else
					{
						m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageVirtualObjectSearch.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
					}


				}

				CString strPath = m_strDataRecord + _T("\\Image文件");
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum)
				{
					m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex) = 0;
				}
			}
		}			
		break;
	case eCalibTargetSearch:
		{
			// 不涉及线程存图
			SYSTEMTIME sys; 
			GetLocalTime(&sys); 
			m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearch.bmp"),
				sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

			m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex) = m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex) + 1;

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				m_vstrTemp.at(nPosIndex).Format(_T("ImageCalibTargetSearch-CH%02d-%03d.bmp"), 
					nPosIndex,m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex));
			}

			CString strPath = m_strDataRecord + _T("\\AlignTool");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

			if(m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex) = 0;
			}	
		}
		break;
	case eInspectSearch:
		{
			if (0 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType)
			{
				m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex) = m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex) + 1;

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 					

				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
					{
						m_vstrTemp.at(nPosIndex).Format(_T("ImageInspectSearch-CH%02d-%03d.bmp"), 
							nPosIndex,m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex));

						m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
					}
					else
					{
						m_vstrTemp.at(nPosIndex).Format(_T("ImageInspectSearch-CH%02d-%03d.bmp"), 
							nPosIndex,m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex));
					}
				}
				else
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
					{
						m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageInspectSearch.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

						m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
					}
					else
					{
						m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageInspectSearch.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
					}


				}

				CString strPath = m_strDataRecord + _T("\\Image文件");
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum)
				{
					m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex) = 0;
				}
			}
		}			
		break;
	case eAutoCalibTargetSearch:
		{
			// 不涉及线程存图
			SYSTEMTIME sys; 
			GetLocalTime(&sys); 
			m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearch.bmp"),
				sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

			m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex) = m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex) + 1;

			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				m_vstrTemp.at(nPosIndex).Format(_T("ImageCalibTargetSearch-CH%02d-%03d.bmp"), 
					nPosIndex,m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex));
			}

			CString strPath = m_strDataRecord + _T("\\AlignTool");
			SaveImage(nPosIndex,m_vImageSearch[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

			if(m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerCalibTargetSearchImageIndex.at(nPosIndex) = 0;
			}
		}
		break;

	default:
		break;

	}

	return TRUE;
}

BOOL vcBaseVisionAlign::SaveImage(int nIndex,cpImage &imageInput,CString strFilePath)
{	
	CImageType tmpImageFormat = eBmp;
	int        nJpgImageQuality = 100;
	if (m_pVisionASMConfig != NULL)
	{
		tmpImageFormat = m_pVisionASMConfig->m_DataRecord.m_eImageFormat;
		nJpgImageQuality = m_pVisionASMConfig->m_DataRecord.m_nImageQuility;
	}
	CString strFilePathTemp = strFilePath.Left(strFilePath.ReverseFind('.'));
	switch (tmpImageFormat)
	{
	case eBmp:
		{
			strFilePath = strFilePathTemp + _T(".bmp");
		}
		break;
	case eJpeg:
		{
			strFilePath = strFilePathTemp + _T(".jpg");
		}
		break;
	case ePng:
		{
			strFilePath = strFilePathTemp + _T(".png");
		}
		break;
	}
	if (m_pSystemStatusInfo!=NULL /*&& m_pSystempOptionConfig->m_bGetSysResourceUse*/)
	{
		double dUsedRate = 0.0;
		m_pSystemStatusInfo->GetDiskUsedRate(m_strDataRecord,dUsedRate);
		//if ((dUsedRate)>m_pSystempOptionConfig->m_dMaxDiskUseThre)
		if (IsDiskUsedRateWarning(m_strDataRecord))
		{

			CString strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_ATTENTION);
			/*CString strTmp;
			strTmp = m_strDataRecord.Left(m_strDataRecord.Find('\\')+1);*/
			CString strStatusBarInfo2 = /*strTmp+*/GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DISK_OUT);
			SetStatusBarInfo(FALSE,strStatusBarInfo1,strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			CString strTempWarningType = _T("");
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strStatusBarInfo1 + strStatusBarInfo2));
			return FALSE;

		}
		/*if (dPercentUse>0.98)
		{
		return FALSE;
		}*/

	}

	if (imageInput.IsValid())
	{
		return m_vImageSaveTemp.at(nIndex).Write(strFilePath,imageInput,m_pVisionASMConfig->m_DataRecord.m_eImageFormat,nJpgImageQuality);
	}
	return FALSE;
}

// 存图线程
UINT vcBaseVisionAlign::SaveImageThread(LPVOID pParam)
{
	CSaveImageObject* pSaveImageObj = (CSaveImageObject*)pParam;
	if (pSaveImageObj == NULL)
	{
		return 0;
	}
	vcBaseVisionAlign* pBaseVisionASM = (vcBaseVisionAlign*) pSaveImageObj->m_pOwner;
	if (pBaseVisionASM ==  NULL)
	{
		return 0;
	}
	int nPosIndex = pSaveImageObj->m_nPosIndex;

	pBaseVisionASM->SaveImageProcess(nPosIndex);

	return 0;
}
// 存图
void vcBaseVisionAlign::SaveImageProcess(int nPosIndex)
{
	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{
		return;
	}

	while(FALSE == m_vbExitSaveImageThread[nPosIndex])
	{
		m_vbSaveImageThreadSuspended[nPosIndex] = m_bSuspendWorkThread;
		if(m_vbSaveImageThreadSuspended[nPosIndex])
		{
			Sleep(1);
			continue;

		}

		if (TRUE == m_vbSaveImageStart[nPosIndex])
		{
			m_vbSaveImageStart[nPosIndex] = FALSE;

			CCoordPos cp;
			SearchMode nSearchMode = m_vsmSearchMode[nPosIndex];
			int nProcessType = m_vnProcessType[nPosIndex];
			switch(nSearchMode)// 定位
			{
			case eNoSearch:			
				break;
			case eCalibSearch:
				{	
				}
				break;
				//全局二维码靶标标定时，图像坐标到靶标坐标映射时的二维码搜索
			case eCalibWholeDmcodeBoard:
				{

				}
				break;
			case eTargetSearch:
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (1 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
					{
						if (m_bIsExecuteSizeCheck || m_bIsExecuteFixTargetCheck)
						{
							break;
						}

						m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex) + 1;

						SYSTEMTIME sys; 
						GetLocalTime(&sys); 					

						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
							{
								m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearch-CH%02d-%03d.bmp"), nPosIndex,m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex));

								m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
							}
							else
							{
								m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearch-CH%02d-%03d.bmp"), nPosIndex,m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex));
							}

						}
						else
						{
							if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
							{
								m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearch.bmp"),
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

								m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
							}
							else
							{
								m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearch.bmp"),
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
							}


						}

						CString strPath = m_strDataRecord + _T("\\Image文件");
						SaveImage(nPosIndex,m_vSaveImage[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

						if(m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum)
						{
							m_vSaveAlignerTargetSearchImageIndex.at(nPosIndex) = 0;
						}

					}
					if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile&&m_pVisionASMConfig->m_DataRecord.m_bSaveTargetSnapVDBFile)//存储流程VDB文件
					{
						SaveVDBFileFunc(nPosIndex,nSearchMode,nProcessType);
					}

				}
				break;
			case eObjectSearch:
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (1 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
					{
						CPlatformOptionInfo optionInfo;
						GetPlatformOptionInfo(optionInfo);

						if (m_bIsExecuteSizeCheck || m_bIsExecuteFixTargetCheck || optionInfo.m_bEnableCalibrateCheckByAxisMoveOption)
						{
							break;
						}

						m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;

						SYSTEMTIME sys; 
						GetLocalTime(&sys); 

						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
							{
								m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearch-CH%02d-%03d.bmp"), 
									nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));

								m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
							}
							else
							{
								m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearch-CH%02d-%03d.bmp"), 
									nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
							}


						}
						else
						{
							if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
							{
								m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearch.bmp"),
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

								m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
							}
							else
							{
								m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearch.bmp"),
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
							}


						}

						CString strPath = m_strDataRecord + _T("\\Image文件");
						SaveImage(nPosIndex,m_vSaveImage[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

						if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum)
						{
							m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
						}


					}
					if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile&&(m_pVisionASMConfig->m_DataRecord.m_bSaveProcessSnapVDBFile||m_pVisionASMConfig->m_DataRecord.m_bSaveObjectSnapVDBFile))//存储流程VDB文件
					{
						SaveVDBFileFunc(nPosIndex,nSearchMode,nProcessType);
					}

				}
				break;
			case eVirtualSearch:
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (1 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
					{
						m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex) = m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex) + 1;			

						SYSTEMTIME sys; 
						GetLocalTime(&sys); 

						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
							{
								m_vstrTemp.at(nPosIndex).Format(_T("ImageVirtualObjectSearch-CH%02d-%03d.bmp"), 
									nPosIndex,m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex));

								m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
							}
							else
							{
								m_vstrTemp.at(nPosIndex).Format(_T("ImageVirtualObjectSearch-CH%02d-%03d.bmp"), 
									nPosIndex,m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex));
							}

						}
						else
						{
							if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
							{
								m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageVirtualObjectSearch.bmp"),
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

								m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
							}
							else
							{
								m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageVirtualObjectSearch.bmp"),
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
							}


						}

						CString strPath = m_strDataRecord + _T("\\Image文件");
						SaveImage(nPosIndex,m_vSaveImage[nPosIndex], strPath + _T("\\") + m_vstrTemp.at(nPosIndex));
						if(m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveAllImageNum)
						{
							m_vSaveAlignerVirtualSearchImageIndex.at(nPosIndex) = 0;
						}
					}	
				}			
				break;
			case eCalibTargetSearch:
				{
				}
				break;
			case eInspectSearch:
				{
					if ( (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage) && (1 == m_pVisionASMConfig->m_DataRecord.m_bSaveAllImageType) )
					{
						m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex) = m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex) + 1;

						SYSTEMTIME sys; 
						GetLocalTime(&sys); 					

						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
							{
								m_vstrTemp.at(nPosIndex).Format(_T("ImageInspectSearch-CH%02d-%03d.bmp"), 
									nPosIndex,m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex));

								m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
							}
							else
							{
								m_vstrTemp.at(nPosIndex).Format(_T("ImageInspectSearch-CH%02d-%03d.bmp"), 
									nPosIndex,m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex));
							}

						}
						else
						{
							if ( (m_pVisionASMConfig->m_DataRecord.m_bImageName) && (m_strProductID != _T("")) )
							{
								m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageInspectSearch.bmp"),
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

								m_vstrTemp.at(nPosIndex) = m_strProductID + m_vstrTemp.at(nPosIndex);
							}
							else
							{
								m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageInspectSearch.bmp"),
									sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);
							}
						}

						SaveImage(nPosIndex,m_vSaveImage[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
						if(m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
						{
							m_vSaveAlignerInspectSearchImageIndex.at(nPosIndex) = 0;
						}
					}	
					if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)//存储流程VDB文件
					{
						SaveVDBFileFunc(nPosIndex,nSearchMode,nProcessType);
					}
				}			
				break;
			case eAutoCalibTargetSearch:
				{

				}
				break;
			default:
				break;
			}


			m_vbSearchFinished[nPosIndex] = true;
			SetEvent(m_vhSaveImageEvent[nPosIndex]);
		}		

		Sleep(1);
	}

}

void vcBaseVisionAlign::StartSaveImage(int nPosIndex)
{
	m_vbSaveImageFinish[nPosIndex] = FALSE;
	ResetEvent(m_vhSaveImageEvent[nPosIndex]);
	m_vSaveImage[nPosIndex] = m_vImageSearch[nPosIndex];
	m_vbSaveImageStart[nPosIndex] = TRUE;
}


bool vcBaseVisionAlign::WaitSaveImage(int nPosIndex)
{
	BOOL bSaveFinish = FALSE;

	while (!bSaveFinish)
	{
		if (m_bStopNow)
		{
			return false;
		}

		DWORD dwRet = WaitForSingleObject(m_vhSaveImageEvent[nPosIndex], 30);
		if (dwRet != WAIT_TIMEOUT)
		{
			bSaveFinish = TRUE;
		}
	}

	return TRUE;
}

void vcBaseVisionAlign::InitTargetPlatformAxisPos()
{
	UnInitTargetPlatformAxisPos();
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	m_vpTargetPlatformAxisPos.resize(nPosNum,NULL);
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
	}

	for (i=0;i<MUTITARGETMAXNUM;i++)
	{
		m_vpMutiTargetPlatformAxisPos.at(i).resize(nPosNum,NULL);
		for (int j=0;j<nPosNum;j++)
		{
			m_vpMutiTargetPlatformAxisPos.at(i).at(j)= new CPlatformXYDAxisPos;
		}
	}
	for (i=0;i< m_vvpTargetPlatformAxisPosMultiEx.size();i++)
	{
		m_vvpTargetPlatformAxisPosMultiEx.at(i).resize(nPosNum,NULL);
		for (int j=0;j<nPosNum;j++)
		{
			m_vvpTargetPlatformAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
		}
	}
}



void vcBaseVisionAlign::UnInitTargetPlatformAxisPos()
{
	int i = 0; 
	for (i = 0 ; i < m_vpTargetPlatformAxisPos.size(); i++)
	{
		if (m_vpTargetPlatformAxisPos.at(i)!=NULL)
		{
			delete m_vpTargetPlatformAxisPos.at(i);
			m_vpTargetPlatformAxisPos.at(i) = NULL;
		}
	}
	// 2018.8.25 qw
	for (i=0;i<MUTITARGETMAXNUM;i++)
	{
		for (int j=0;j<m_vpMutiTargetPlatformAxisPos.at(i).size();j++)
		{
			if (m_vpMutiTargetPlatformAxisPos.at(i).at(j)!=NULL)
			{
				delete m_vpMutiTargetPlatformAxisPos.at(i).at(j);
				m_vpMutiTargetPlatformAxisPos.at(i).at(j)=NULL;
			}
		}
	}
	for (i=0;i<m_vvpTargetPlatformAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpTargetPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpTargetPlatformAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpTargetPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpTargetPlatformAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}
	}

}


void vcBaseVisionAlign::InitCrossBenchTargetPlatformAxisPos()
{
	UnInitCrossBenchTargetPlatformAxisPos();
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	m_vpCrossBenchPlatformAxisPos.resize(nPosNum,NULL);
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		m_vpCrossBenchPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
	}
}

void vcBaseVisionAlign::UnInitCrossBenchTargetPlatformAxisPos()
{
	int i = 0; 
	for (i = 0 ; i < m_vpCrossBenchPlatformAxisPos.size(); i++)
	{
		if (m_vpCrossBenchPlatformAxisPos.at(i)!=NULL)
		{
			delete m_vpCrossBenchPlatformAxisPos.at(i);
			m_vpCrossBenchPlatformAxisPos.at(i) = NULL;
		}
	}
}

void vcBaseVisionAlign::InitObjectPlatformAxisPos()
{
	UnInitObjectPlatformAxisPos();
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	m_vpObjectPlatformAxisPos.resize(nPosNum,NULL);
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		m_vpObjectPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
	}
	for (i=0;i<m_vvpObjectPlatformAxisPosMultiEx.size();i++)
	{
		m_vvpObjectPlatformAxisPosMultiEx.at(i).resize(nPosNum,NULL);
		for (int j=0;j<nPosNum;j++)
		{
			m_vvpObjectPlatformAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
		}
	}
}


void vcBaseVisionAlign::InitObjectCamAxisPos()
{
	UnInitObjectCamAxisPos();
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	m_vpObjectCamAxisPos.resize(nPosNum,NULL);
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		m_vpObjectCamAxisPos.at(i) = new CPlatformXYAxisPos;
	}
	for (i=0;i< m_vvpObjectCamAxisPosMultiEx.size();i++)
	{
		m_vvpObjectCamAxisPosMultiEx.at(i).resize(nPosNum,NULL);
		for (int j=0;j<nPosNum;j++)
		{
			m_vvpObjectCamAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
		}
	}
}


void vcBaseVisionAlign::InitTargetCamAxisPos()
{
	UnInitTargetCamAxisPos();
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	m_vpTargetCamAxisPos.resize(nPosNum,NULL);
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		m_vpTargetCamAxisPos.at(i) = new CPlatformXYAxisPos;
	}
	for (i=0;i< m_vvpTargetCamAxisPosMultiEx.size();i++)
	{
		m_vvpTargetCamAxisPosMultiEx.at(i).resize(nPosNum,NULL);
		for (int j=0;j<nPosNum;j++)
		{
			m_vvpTargetCamAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
		}
	}
}


void vcBaseVisionAlign::InitObjectCamAxisPlatformAxisPos()
{
	UnInitObjectCamAxisPlatformAxisPos();
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	m_vpObjectCamAxisPlatformAxisPos.resize(nPosNum,NULL);
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		m_vpObjectCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos;
	}
	for (i=0;i< m_vvpObjectCamAxisPlatformAxisPosMultiEx.size();i++)
	{
		m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).resize(nPosNum,NULL);
		for (int j=0;j<nPosNum;j++)
		{
			m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
		}
	}
}



void vcBaseVisionAlign::InitTargetCamAxisPlatformAxisPos()
{
	UnInitTargetCamAxisPlatformAxisPos();
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	m_vpTargetCamAxisPlatformAxisPos.resize(nPosNum,NULL);
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		m_vpTargetCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos;
	}
	for (i=0;i< m_vvpTargetCamAxisPlatformAxisPosMultiEx.size();i++)
	{
		m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).resize(nPosNum,NULL);
		for (int j=0;j<nPosNum;j++)
		{
			m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
		}
	}
}

void vcBaseVisionAlign::UnInitObjectPlatformAxisPos()
{
	int i = 0;
	for (i = 0 ; i < m_vpObjectPlatformAxisPos.size(); i++)
	{
		if (m_vpObjectPlatformAxisPos.at(i)!=NULL)
		{
			delete m_vpObjectPlatformAxisPos.at(i);
			m_vpObjectPlatformAxisPos.at(i) = NULL;
		}
	}
	for (i=0;i<m_vvpObjectPlatformAxisPosMultiEx.size();i++)
	{
		for(int j=0;j<m_vvpObjectPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpObjectPlatformAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpObjectPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpObjectPlatformAxisPosMultiEx.at(i).at(j)=NULL;
			}
		}
	}
}
void vcBaseVisionAlign::UnInitObjectCamAxisPos()
{
	int i = 0;
	for(int i = 0; i < m_vpObjectCamAxisPos.size(); i++)
	{
		if(m_vpObjectCamAxisPos.at(i) != NULL)
		{
			delete m_vpObjectCamAxisPos.at(i);
			m_vpObjectCamAxisPos.at(i) = NULL;
		}
	}
	for (i=0;i<m_vvpObjectCamAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpObjectCamAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpObjectCamAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpObjectCamAxisPosMultiEx.at(i).at(j);
				m_vvpObjectCamAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}
	}
}
void vcBaseVisionAlign::UnInitObjectCamAxisPlatformAxisPos()
{
	int i = 0;
	for(int i = 0; i < m_vpObjectCamAxisPlatformAxisPos.size(); i++)
	{
		if(m_vpObjectCamAxisPlatformAxisPos.at(i) != NULL)
		{
			delete m_vpObjectCamAxisPlatformAxisPos.at(i);
			m_vpObjectCamAxisPlatformAxisPos.at(i) = NULL;
		}
	}
	for (i=0;i<m_vvpObjectCamAxisPlatformAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}
	}
}
void vcBaseVisionAlign::UnInitTargetCamAxisPos()
{
	int i = 0;
	for(int i = 0; i < m_vpTargetCamAxisPos.size(); i++)
	{
		if(m_vpTargetCamAxisPos.at(i) != NULL)
		{
			delete m_vpTargetCamAxisPos.at(i);
			m_vpTargetCamAxisPos.at(i) = NULL;
		}
	}
	for (i=0;i<m_vvpTargetCamAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpTargetCamAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpTargetCamAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpTargetCamAxisPosMultiEx.at(i).at(j);
				m_vvpTargetCamAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}
	}
}
void vcBaseVisionAlign::UnInitTargetCamAxisPlatformAxisPos()
{
	int i = 0;
	for(int i = 0; i < m_vpTargetCamAxisPlatformAxisPos.size(); i++)
	{
		if(m_vpTargetCamAxisPlatformAxisPos.at(i) != NULL)
		{
			delete m_vpTargetCamAxisPlatformAxisPos.at(i);
			m_vpTargetCamAxisPlatformAxisPos.at(i) = NULL;
		}
	}
	for (i=0;i<m_vvpTargetCamAxisPlatformAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}
	}
}

void vcBaseVisionAlign::SetTempTargetPlatformAxisPos(int nPosIndex, CPlatformAxisPos* pPlatformAxisPos)
{
	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
	{
		return;
	}	
	if (pPlatformAxisPos==NULL)
	{
		return;
	}

	if (m_vpTargetPlatformAxisPos.at(nPosIndex) != NULL)
	{
		*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}
	else
	{
		m_vpTargetPlatformAxisPos.at(nPosIndex) = new CPlatformXYDAxisPos;
		*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}
	if (m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) != NULL)
	{
		*((CPlatformXYDAxisPos*)m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}
	else
	{
		m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) = new CPlatformXYDAxisPos;
		*((CPlatformXYDAxisPos*)m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}
}

void vcBaseVisionAlign::SetTempTargetCamAxisPos(int nPosIndex,CPlatformXYAxisPos* pCamAxisPos)
{
	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
	{
		return;
	}	
	if (pCamAxisPos==NULL)
	{
		return;
	}

	if (m_vpTargetCamAxisPos.at(nPosIndex) != NULL)
	{
		*((CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
	}
	else
	{
		m_vpTargetCamAxisPos.at(nPosIndex) = new CPlatformXYAxisPos;
		*((CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
	}
}

void vcBaseVisionAlign::SetTempObjectCamAxisPlatformAxisPos(int nPosIndex,CPlatformXYAxisPos* pCamAxisPos)
{
	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
	{
		return;
	}	
	if (pCamAxisPos==NULL)
	{
		return;
	}

	if (m_vpObjectCamAxisPlatformAxisPos.at(nPosIndex) != NULL)
	{
		*((CPlatformXYAxisPos*)m_vpObjectCamAxisPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
	}
	else
	{
		m_vpObjectCamAxisPlatformAxisPos.at(nPosIndex) = new CPlatformXYAxisPos;
		*((CPlatformXYAxisPos*)m_vpObjectCamAxisPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
	}
}

void vcBaseVisionAlign::SetTempCrossBenchTargetPlatformAxisPos(int nPosIndex, CPlatformAxisPos* pPlatformAxisPos)
{
	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
	{
		return;
	}	
	if (pPlatformAxisPos==NULL)
	{
		return;
	}

	if (m_vpCrossBenchPlatformAxisPos.at(nPosIndex) != NULL)
	{
		*((CPlatformXYDAxisPos*)m_vpCrossBenchPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}
	else
	{
		m_vpCrossBenchPlatformAxisPos.at(nPosIndex) = new CPlatformXYDAxisPos;
		*((CPlatformXYDAxisPos*)m_vpCrossBenchPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}

}

void vcBaseVisionAlign::SetTempObjectPlatformAxisPos(int nPosIndex, CPlatformAxisPos* pPlatformAxisPos)
{
	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
	{
		return;
	}	
	if (pPlatformAxisPos==NULL)
	{
		return;
	}

	if (m_vpObjectPlatformAxisPos.at(nPosIndex) != NULL)
	{
		*((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}
	else
	{
		m_vpObjectPlatformAxisPos.at(nPosIndex) = new CPlatformXYDAxisPos;
		*((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}

	if (m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) != NULL)
	{
		*(CPlatformXYDAxisPos*)m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}
	else
	{
		m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) = new CPlatformXYDAxisPos;
		*((CPlatformXYDAxisPos*)m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	}

}

void vcBaseVisionAlign::SetTempObjectCamAxisPos(int nPosIndex,CPlatformXYAxisPos* pCamAxisPos)
{
	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
	{
		return;
	}	
	if (pCamAxisPos==NULL)
	{
		return;
	}

	if (m_vpObjectCamAxisPos.at(nPosIndex) != NULL)
	{
		*((CPlatformXYAxisPos*)m_vpObjectCamAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
	}
	else
	{
		m_vpObjectCamAxisPos.at(nPosIndex) = new CPlatformXYAxisPos;
		*((CPlatformXYAxisPos*)m_vpObjectCamAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
	}
}

void vcBaseVisionAlign::SetTempTargetCamAxisPlatformAxisPos(int nPosIndex,CPlatformXYAxisPos* pCamAxisPos)
{
	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
	{
		return;
	}	
	if (pCamAxisPos==NULL)
	{
		return;
	}

	if (m_vpTargetCamAxisPlatformAxisPos.at(nPosIndex) != NULL)
	{
		*((CPlatformXYAxisPos*)m_vpTargetCamAxisPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
	}
	else
	{
		m_vpTargetCamAxisPlatformAxisPos.at(nPosIndex) = new CPlatformXYAxisPos;
		*((CPlatformXYAxisPos*)m_vpTargetCamAxisPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
	}
}


void vcBaseVisionAlign::AddAllGuiCalibrateGraphicsToDisplay()
{
	if (m_pPlatformInfo == NULL)
	{
		return;
	}
	int i;
	for (i=0; i<GetPosNum() && i<m_vpGuiDisplay.size(); i++)
	{   	
		AddGuiCalibrateGraphicsToDisplay(i,m_vpGuiDisplay.at(i));	
		m_vpPreGuiCalibrateDisplay.at(i) = m_vpGuiDisplay.at(i);
	}
}
void vcBaseVisionAlign::RemoveAllGuiCalibrateGraphicsFromDisplay()
{
	if (m_pPlatformInfo == NULL)
	{
		return;
	}
	int i;

	for (i=0; i<GetPosNum() && i<m_vpPreGuiCalibrateDisplay.size(); i++)
	{   	
		RemoveGuiCalibrateGraphicsFromDisplay(i,m_vpPreGuiCalibrateDisplay.at(i));	
	}
}
void vcBaseVisionAlign::AddGuiCalibrateGraphicsToDisplay(int nPosIndex,scGuiDisplay* pGuiDisplay)
{
	if (pGuiDisplay == NULL)
	{
		return;
	}
	if (nPosIndex<0 || nPosIndex>=GetPosNum())
	{
		return;
	}
	if (m_vpPreGuiCalibrateDisplay.at(nPosIndex)!=NULL)
	{
		RemoveGuiCalibrateGraphicsFromDisplay(nPosIndex,m_vpPreGuiCalibrateDisplay.at(nPosIndex));
	}
	ShowGuiCalibrateGraphics(nPosIndex,FALSE);	
	CString strInfo1;
	scGuiStaticContainer* pGuiStaticContainer = NULL;
	pGuiStaticContainer = pGuiDisplay->GetStaticContainer();
	CGuiGraphics* tempCalibrateGraphics = m_vpGuiCalibrateGraphics.at(nPosIndex);
	for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectCross.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateObjectCross%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
		pGuiStaticContainer->AddItem(tempCalibrateGraphics->m_vGuiObjectCross.at(j), strInfo1);
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetCross.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateTargetCross%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
		pGuiStaticContainer->AddItem(tempCalibrateGraphics->m_vGuiTargetCross.at(j), strInfo1);
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectCoordCross.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateObjectCoordCross%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
		pGuiStaticContainer->AddItem(tempCalibrateGraphics->m_vGuiObjectCoordCross.at(j), strInfo1);
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetCoordCross.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateTargetCoordCross%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
		pGuiStaticContainer->AddItem(tempCalibrateGraphics->m_vGuiTargetCoordCross.at(j), strInfo1);
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectPolyline.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateObjectPolyline%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
		pGuiStaticContainer->AddItem(tempCalibrateGraphics->m_vGuiObjectPolyline.at(j), strInfo1);
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetPolyline.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateTargetPolyline%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
		pGuiStaticContainer->AddItem(tempCalibrateGraphics->m_vGuiTargetPolyline.at(j), strInfo1);
	}
	pGuiDisplay->SetStaticContainer(pGuiStaticContainer);
	m_vpPreGuiCalibrateDisplay.at(nPosIndex) = pGuiDisplay;	
}
void vcBaseVisionAlign::RemoveGuiCalibrateGraphicsFromDisplay(int nPosIndex,scGuiDisplay* pGuiDisplay)
{
	if (pGuiDisplay == NULL)
	{
		return;
	}
	if (nPosIndex<0 || nPosIndex>=GetPosNum())
	{
		return;
	}
	CString strInfo1;
	scGuiStaticContainer* pGuiStaticContainer = NULL;
	pGuiStaticContainer = pGuiDisplay->GetStaticContainer();
	CGuiGraphics* tempCalibrateGraphics = m_vpGuiCalibrateGraphics.at(nPosIndex);
	for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectCross.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateObjectCross%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetCross.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateTargetCross%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectCoordCross.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateObjectCoordCross%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetCoordCross.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateTargetCoordCross%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectPolyline.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateObjectPolyline%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
	}
	for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetPolyline.size();j++)
	{
		strInfo1.Format(_T("Gui_CalibrateTargetPolyline%d"), j);
		pGuiStaticContainer->RemoveItem(strInfo1);	
	}
	m_vpPreGuiCalibrateDisplay.at(nPosIndex) = NULL;
}
void vcBaseVisionAlign::ShowGuiCalibrateGraphics(int nPosIndex,BOOL bShow)
{
	if (nPosIndex<0 || nPosIndex>=GetPosNum())
	{
		return;
	}

	CGuiGraphics* tempCalibrateGraphics = m_vpGuiCalibrateGraphics.at(nPosIndex);
	if (bShow)
	{
		for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectCross.size();j++)
		{
			tempCalibrateGraphics->m_vGuiObjectCross.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowObjectCross.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetCross.size();j++)
		{
			tempCalibrateGraphics->m_vGuiTargetCross.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowTargetCross.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectCoordCross.size();j++)
		{
			tempCalibrateGraphics->m_vGuiObjectCoordCross.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowObjectCoordCross.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetCoordCross.size();j++)
		{
			tempCalibrateGraphics->m_vGuiTargetCoordCross.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowTargetCoordCross.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectPolyline.size();j++)
		{
			tempCalibrateGraphics->m_vGuiObjectPolyline.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowObjectPolyline.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetPolyline.size();j++)
		{
			tempCalibrateGraphics->m_vGuiTargetPolyline.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowTargetPolyline.at(j));
		}
	}
	else
	{
		for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectCross.size();j++)
		{
			tempCalibrateGraphics->m_vbShowObjectCross.at(j) = FALSE;
			tempCalibrateGraphics->m_vGuiObjectCross.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowObjectCross.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetCross.size();j++)
		{
			tempCalibrateGraphics->m_vbShowTargetCross.at(j) = FALSE;
			tempCalibrateGraphics->m_vGuiTargetCross.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowTargetCross.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectCoordCross.size();j++)
		{
			tempCalibrateGraphics->m_vbShowObjectCoordCross.at(j) = FALSE;
			tempCalibrateGraphics->m_vGuiObjectCoordCross.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowObjectCoordCross.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetCoordCross.size();j++)
		{
			tempCalibrateGraphics->m_vbShowTargetCoordCross.at(j) = FALSE;
			tempCalibrateGraphics->m_vGuiTargetCoordCross.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowTargetCoordCross.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiObjectPolyline.size();j++)
		{
			tempCalibrateGraphics->m_vbShowObjectPolyline.at(j) = FALSE;
			tempCalibrateGraphics->m_vGuiObjectPolyline.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowObjectPolyline.at(j));
		}
		for (int j=0;j<tempCalibrateGraphics->m_vGuiTargetPolyline.size();j++)
		{
			tempCalibrateGraphics->m_vbShowTargetPolyline.at(j) = FALSE;
			tempCalibrateGraphics->m_vGuiTargetPolyline.at(j)->SetVisible(bShow && tempCalibrateGraphics->m_vbShowTargetPolyline.at(j));
		}
	}
	//if (m_vpPreGuiCalibrateDisplay.at(nPosIndex)!=NULL)
	//{
	//	m_vpPreGuiCalibrateDisplay.at(nPosIndex)->MyInvalidate();
	//}	
}
void vcBaseVisionAlign::ShowAllGuiCalibrateGraphics(BOOL bShow)
{
	if (m_pPlatformInfo == NULL)
	{
		return;
	}
	int i;
	for (i=0; i<GetPosNum(); i++)
	{   	
		PostMessageUpdateGuiCalibrateTargetGraphics(i,bShow);
	}
}

//存储VDB文件
void vcBaseVisionAlign::PostMessageSaveVDBFile(std::vector<int> vnPosIndex,SearchMode eSearchMode,int nProcessType/* = 0*/)
{
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Enter PostMessageSaveVDBFile------");
	if (NULL == m_pMainWnd)
	{
		return;
	}
	WPARAM wParam;
	int i = 0;
	int nPosIndex;		
	int nPosNum = vnPosIndex.size();
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		wParam = nPosIndex + (nProcessType*100);
		PostMessage(m_pMainWnd->GetSafeHwnd(), WM_SAVE_VDB_FILE, wParam, eSearchMode);
	}
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Leave PostMessageSaveVDBFile------");
}
void vcBaseVisionAlign::SaveSearchVDBFile(scGuiDisplay* pGuiDisplay,int nIndex,SearchMode eSearchMode,int nProcessType/* = 0*/)
{
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Enter SaveSearchVDBFile------");
	if (pGuiDisplay == NULL)
	{
		return;
	}
	//Sleep(10000);
	CString strPath;
	CString strFileName;
	
	CString strid= m_pVisionASMConfig->m_DataRecord.m_bVDBNameByID?(_T("_")+m_strProductID):_T("");

	CString strSearchResult = m_vbSearchSucceed.at(nIndex) ? _T("_OK"):_T("_NG");  //OK\NG
	CString strTempOkNgFile = m_vbSearchSucceed.at(nIndex) ? _T("OK\\"):_T("NG\\"); //OK/NG文件夹
	if (nProcessType != 0)
	{	
		strSearchResult = (nProcessType == 1) ? _T("_OK"):_T("_NG");  //OK\NG
		strTempOkNgFile = (nProcessType == 1) ? _T("OK\\"):_T("NG\\"); //OK/NG文件夹
	}

	strid += strSearchResult;


	switch(eSearchMode)
	{
	case eCalibSearch:
		{
			m_vSaveAlignerCalibSearchVDBFileIndex.at(nIndex) = m_vSaveAlignerCalibSearchVDBFileIndex.at(nIndex) + 1;
			strFileName.Format(_T("CalibSearch-CH%02d-%03d%s"),nIndex,m_vSaveAlignerCalibSearchVDBFileIndex.at(nIndex),strid);
			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == TRUE)
			{
				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				
				strFileName.Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CalibSearch-CH%02d%s"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nIndex,strid);
			}
			strPath = m_strDataRecord + _T("\\VDB文件\\") + strTempOkNgFile + strFileName;		

			if(m_vSaveAlignerCalibSearchVDBFileIndex.at(nIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums)
			{
				m_vSaveAlignerCalibSearchVDBFileIndex.at(nIndex) = 0;
			}
		}
		break;
	case eTargetSearch:
		{
			m_vSaveAlignerTargetSearchVDBFileIndex.at(nIndex) = m_vSaveAlignerTargetSearchVDBFileIndex.at(nIndex) + 1;
			strFileName.Format(_T("TargetSearch-CH%02d-%03d%s"),nIndex,m_vSaveAlignerTargetSearchVDBFileIndex.at(nIndex),strid);
			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == TRUE)
			{
				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				strFileName.Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-TargetSearch-CH%02d%s"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nIndex,strid);
			}
			strPath = m_strDataRecord + _T("\\VDB文件\\") + strTempOkNgFile + strFileName;

			if(m_vSaveAlignerTargetSearchVDBFileIndex.at(nIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums)
			{
				m_vSaveAlignerTargetSearchVDBFileIndex.at(nIndex) = 0;
			}
		}
		break;
	case eObjectSearch:
		{
			m_vSaveAlignerObjectSearchVDBFileIndex.at(nIndex) = m_vSaveAlignerObjectSearchVDBFileIndex.at(nIndex) + 1;
			strFileName.Format(_T("ObjectSearch-CH%02d-%03d%s"),nIndex,m_vSaveAlignerObjectSearchVDBFileIndex.at(nIndex),strid);
			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == TRUE)
			{
				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				strFileName.Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-ObjectSearch-CH%02d%s"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nIndex,strid);
			}
			strPath = m_strDataRecord + _T("\\VDB文件\\") + strTempOkNgFile + strFileName;

			if(m_vSaveAlignerObjectSearchVDBFileIndex.at(nIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums)
			{
				m_vSaveAlignerObjectSearchVDBFileIndex.at(nIndex) = 0;
			}
		}
		break;
	case eVirtualSearch:
		{
			m_vSaveAlignerVirtualSearchVDBFileIndex.at(nIndex) = m_vSaveAlignerVirtualSearchVDBFileIndex.at(nIndex) + 1;
			strFileName.Format(_T("VirtualSearch-CH%02d-%03d%s"),nIndex,m_vSaveAlignerVirtualSearchVDBFileIndex.at(nIndex),strid);
			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == TRUE)
			{
				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				strFileName.Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-VirtualSearch-CH%02d%s"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nIndex,strid);
			}
			strPath = m_strDataRecord + _T("\\VDB文件\\") + strTempOkNgFile + strFileName;

			if(m_vSaveAlignerVirtualSearchVDBFileIndex.at(nIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums)
			{
				m_vSaveAlignerVirtualSearchVDBFileIndex.at(nIndex) = 0;
			}
		}
		break;
	case eInspectSearch:
		{
			m_vSaveAlignerInspectSearchVDBFileIndex.at(nIndex) = m_vSaveAlignerInspectSearchVDBFileIndex.at(nIndex) + 1;
			strFileName.Format(_T("InspectSearch-CH%02d-%03d%s"),nIndex,m_vSaveAlignerInspectSearchVDBFileIndex.at(nIndex),strid);
			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == TRUE)
			{
				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				strFileName.Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-InspectSearch-CH%02d%s"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nIndex,strid);
			}
			strPath = m_strDataRecord + _T("\\VDB文件\\") + strTempOkNgFile + strFileName;

			if(m_vSaveAlignerInspectSearchVDBFileIndex.at(nIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums)
			{
				m_vSaveAlignerInspectSearchVDBFileIndex.at(nIndex) = 0;
			}
		}
		break;
	case eAutoCalibTargetSearch:
		{
			m_vSaveAlignerCalibTargetSearchVDBFileIndex.at(nIndex) = m_vSaveAlignerCalibTargetSearchVDBFileIndex.at(nIndex) + 1;

			strFileName.Format(_T("CalibTargetSearch-CH%02d-%03d%s"),nIndex,m_vSaveAlignerCalibTargetSearchVDBFileIndex.at(nIndex),strid);
			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == TRUE)
			{
				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				strFileName.Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CalibTargetSearch-CH%02d%s"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nIndex,strid);
			}
			strPath = m_strDataRecord + _T("\\VDB文件\\") + strTempOkNgFile + strFileName;

			if(m_vSaveAlignerCalibTargetSearchVDBFileIndex.at(nIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveVDBMaxNums)
			{
				m_vSaveAlignerCalibTargetSearchVDBFileIndex.at(nIndex) = 0;
			}
		}
		break;
	default:
		return;
	}
	
	/*SYSTEMTIME sys,sys2;
	float m_time;
	GetLocalTime(&sys);
	CString strFileTime;*/

	SaveVDBFile(pGuiDisplay,strPath,nIndex);

	/*GetLocalTime(&sys2);
	m_time = (sys2.wMinute-sys.wMinute)*60;
	m_time += sys2.wSecond-sys.wSecond;
	m_time *= 1000;
	m_time += sys2.wMilliseconds - sys.wMilliseconds;
	strFileTime.Format(_T("存图用时-%.f:ms"),m_time);
	VisionAlignLogRecord("D:\\TimeVDB.txt", strFileTime);*/

	//所有VDB存储到同一文件夹下，用于文件传输
	//产品ID_年月日时分秒.jpg
	if (m_pSystempOptionConfig->m_bAllSteoage)
	{
		SaveVDBFileID(pGuiDisplay,m_strProductID,nIndex);
	}
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Leave SaveSearchVDBFile------");
}
void vcBaseVisionAlign::SaveVDBFileID(scGuiDisplay* pGuiDisplay,CString ProductID,int nIndex)
{
	VisionAlignLogRecord("D:\\TimeLog.txt", "存图开始");

	// 判断文件夹是否存在，不存在新建
	CFileFind findFile;
	BOOL IsFild2 = FALSE; 
	BOOL IsDir2 = FALSE; 
	//CString strDir  = m_strDataRecord.Left(m_strDataRecord.GetLength()-4);
	
	CTime tCurrent = CTime::GetCurrentTime();
	CString strTemp;
	strTemp.Format(_T("%04d-%02d"), tCurrent.GetYear(), tCurrent.GetMonth());

	CString strDataRecord,strDRecord;
	if (m_pVisionASMConfig->m_DataRecord.m_bCustomLogPath && m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath != _T(""))
	{
		strDataRecord = m_pVisionASMConfig->m_DataRecord.m_strDataRecordPath;
	}
	else
	{
		strDataRecord = m_strEXEDir + _T("\\VSLog"); // ..\Bin\VSLog文件夹
		//strDataRecord = strDataRecord + m_pPlatformInfo->m_strPlatformDetailSavePath.Mid(m_pPlatformInfo->m_strPlatformDetailSavePath.ReverseFind('\\')); 
		strDRecord.Format(_T("\\WS%d"),m_pPlatformInfo->m_nPlatformIndex + 1);
		strDataRecord = strDataRecord + strDRecord;
	}
	strDataRecord = strDataRecord + _T("\\") + strTemp; // F:\VSLog\WS0\2022-11文件夹
	CString strDir = strDataRecord;

	IsFild2 = findFile.FindFile(strDir);
	while (IsFild2)
	{
		IsFild2 = findFile.FindNextFile();
		IsDir2 = findFile.IsDirectory();
		if(IsDir2) break;
	}
	if (!IsDir2)
	{
		if (!CreateDirectory(strDir, NULL))// 创建文件夹
		{
			//return FALSE;
		}
	}

	CString strFileName;
	strFileName.Format("Image");
	strFileName = strDir + _T("\\") + strFileName;

	IsFild2 = FALSE;
	IsDir2 = FALSE;

	IsFild2 = findFile.FindFile(strFileName);
	while (IsFild2)
	{
		IsFild2 = findFile.FindNextFile();
		IsDir2 = findFile.IsDirectory();
		if(IsDir2) break;
	}
	if (!IsDir2)
	{
		if (!CreateDirectory(strFileName, NULL))// 创建文件夹
		{
			//return FALSE;
		}
	}

	CString strPath;
	SYSTEMTIME sys; 
	GetLocalTime(&sys); 
	strPath.Format(_T("%s\\%s_%04d%02d%02d_%02d%02d%02d%02d"),strFileName,
		ProductID,sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond,nIndex);

	SaveVDBFile(pGuiDisplay,strPath,nIndex);
}

//void vcBaseVisionAlign::SaveVDBFile(scGuiDisplay* pGuiDisplay,CString strPath,int nIndex)
//{
//	int        nJpgImageQuality = 100;
//	int m_textWeight,m_textHeight,m_textWidth,m_LineWidth;
//	m_textWeight = 100;
//	m_textHeight = 30;
//	m_textWidth = 15;
//	m_LineWidth = 1;
//	//Sleep(10000);
//	
//	if (pGuiDisplay != NULL)
//	{
//		const cpImage cImage = m_vImageSearch[nIndex];
//		if (cImage.IsValid())
//		{
//			//long tStrat = GetTickCount();
//		    //CImageFormatTransfer vdb;
//			scVDB vdb;
//			ImageType tmpImageType = eImgPng;
//			if (m_pVisionASMConfig != NULL)
//			{
//				
//				switch (m_pVisionASMConfig->m_DataRecord.m_nVBDImageType)
//				{
//				case 0:
//					{
//						tmpImageType = eImgBmp;
//						strPath += _T(".bmp");
//					}
//					break;
//				case 1:
//					{
//						tmpImageType = eImgPng;
//						strPath += _T(".png");
//					}
//					break;
//				case 2:
//					{
//						tmpImageType = eImgJpeg;
//						nJpgImageQuality = m_pVisionASMConfig->m_DataRecord.m_nVDBImageQuility;
//						strPath += _T(".jpg");
//					}
//					break;
//				default:
//					{
//						tmpImageType = eImgPng;
//						strPath += _T(".bmp");
//					}
//					break;
//				}
//
//			}
//			vdb.AddImage(cImage,tmpImageType);
//
//
//
//
//			scGuiStaticContainer* pStaticContainer = pGuiDisplay->GetStaticContainer();
//			
//			int a;
//			if (pStaticContainer != NULL)
//			{
//				for (long i=0; i<pStaticContainer->GetCount(); i++)
//				{
//					scGuiGraphic* pGuiGraphic = pStaticContainer->GetItem(i);
//					if (pGuiGraphic != NULL)
//					{
//						if (pGuiGraphic->IsVisible())
//						{
//							a = pGuiGraphic->GetType();
//							if (pGuiGraphic->GetType()==eGuiText)
//							{
//
//								scGuiText* pGuiText = ((scGuiText*)pGuiGraphic);
//								LOGFONT* pFont = pGuiText->GetTextFont();
//								m_textWeight = pFont->lfWeight;
//								m_textHeight = pFont->lfHeight;
//								m_textWidth = pFont->lfWidth;
//
//								pFont->lfWeight = 900;
//								pFont->lfHeight = 30 * m_pVisionASMConfig->m_DataRecord.m_GuitextWeight;
//								pFont->lfWidth  = 15 * m_pVisionASMConfig->m_DataRecord.m_GuitextWeight;
//								((scGuiText*)pGuiGraphic)->SetTextFont(pFont);
//
//							}
//							else if (pGuiGraphic->GetType() == eGuiAffineRect)
//							{
//								scGuiAffineRect* pAffineRect = ((scGuiAffineRect*)pGuiGraphic);
//								m_LineWidth = pAffineRect->GetLineWidth();
//								pAffineRect->SetLineWidth(m_pVisionASMConfig->m_DataRecord.m_GuiLineWidth);
//
//
//							}
//							else if (pGuiGraphic->GetType() == eGuiCoordCross)
//							{
//								scGuiCoordCross* pCoordCross = ((scGuiCoordCross*)pGuiGraphic);
//								pCoordCross->SetLineWidth(m_pVisionASMConfig->m_DataRecord.m_GuiLineWidth);
//							}
//
//							vdb.AddGraphic(pGuiGraphic);
//						}
//					}
//				}
//			}
//
//			scGuiInteractiveContainer* pInteractiveContainer = pGuiDisplay->GetInteractiveContainer();
//			if (pInteractiveContainer != NULL)
//			{
//				for (long i=0; i<pInteractiveContainer->GetCount(); i++)
//				{
//					scGuiGraphic* pGuiGraphic = pInteractiveContainer->GetItem(i);
//					if (pGuiGraphic != NULL)
//					{
//						if (pGuiGraphic->IsVisible())
//						{
//							vdb.AddGraphic(pGuiGraphic);
//						}
//					}
//				}
//			}
//
//			
//
//			scGuiStaticContainer* pConstContainer = pGuiDisplay->GetConstContainer();
//			if (pConstContainer != NULL)
//			{
//				long dHeight = cImage.Height();
//				long dwidth = cImage.Width();
//				double dX=0,dY=0,dD=0;
//				for (long i=0; i<pConstContainer->GetCount(); i++)
//				{
//					scGuiGraphic* pGuiGraphic = pConstContainer->GetItem(i);
//					if (pGuiGraphic != NULL)
//					{
//						if (pGuiGraphic->IsVisible()&&pGuiGraphic->GetType()==eGuiText)
//						{
//							
//							((scGuiText*)pGuiGraphic)->GetXYRotation(dX,dY,dD);
//							 
//
//							double dPosXnew = dX;
//							double dPosYnew = dY;
//
//							RECT rtClient;
//							pGuiDisplay->GetClientRect(&rtClient);
//
//							if(rtClient.right > rtClient.left)
//							{
//								dPosXnew = dwidth*(dX-rtClient.left)/(rtClient.right-rtClient.left);
//							}
//							scGuiText* pGuiText = ((scGuiText*)pGuiGraphic);
//							LOGFONT* pFont = pGuiText->GetTextFont();
//							pFont->lfWeight = 900;
//							pFont->lfHeight = 30 * m_pVisionASMConfig->m_DataRecord.m_GuitextWeight;
//							pFont->lfWidth  = 15 * m_pVisionASMConfig->m_DataRecord.m_GuitextWeight;
//							((scGuiText*)pGuiGraphic)->SetTextFont(pFont);
//							if(rtClient.bottom > rtClient.top)
//							{
//								/*if (dY<((rtClient.bottom-rtClient.top)/2))
//								{
//
//								double nSegHeight = pFont->lfHeight;
//
//								dPosYnew = dHeight*(rtClient.bottom-(dY*2)-nSegHeight)/(rtClient.bottom-rtClient.top);
//								} 
//								else
//								{
//								dPosYnew = dHeight*(dY-rtClient.top)/(rtClient.bottom-rtClient.top);
//								}*/
//
//								double nSegHeight = pFont->lfHeight * i;
//
//								//dPosYnew = dHeight*(rtClient.bottom-nSegHeight)/(rtClient.bottom-rtClient.top);
//								dPosYnew = dHeight - nSegHeight;
//							}
//							
//							((scGuiText*)pGuiGraphic)->SetXYRotation(dPosXnew,dPosYnew,dD);
//							vdb.AddGraphic(pGuiGraphic);
//							((scGuiText*)pGuiGraphic)->SetXYRotation(dX,dY,dD);
//							
//						}
//					}
//				}
//			}
//
//			//long tend = GetTickCount();
//			//CString strTmp;
//			//strTmp.Format(_T("nIndex-%d vdb.AddGraphic(); Times:%d ms"),nIndex,tend-tStrat);
//			//AlignLogRecord(strTmp);
//
//			//tStrat = GetTickCount();
//			
//
//
//			
//			//if(tmpImageType == eImgJpeg)
//			//{
//			//	vdb.Write(strPath,nJpgImageQuality);//VDB压缩率
//			//}else
//			//{
//			//	vdb.Write(strPath);
//			//}
//			
//			// 进行资源管控 超过阈值不进行VDB储存
//			if (m_pSystemStatusInfo!=NULL)
//			{
//				double dUsedRate = 0.0;
//				m_pSystemStatusInfo->GetDiskUsedRate(m_strDataRecord,dUsedRate);
//				if (IsDiskUsedRateWarning(m_strDataRecord))
//				{
//
//					CString strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_ATTENTION);
//					/*CString strTmp;
//					strTmp = m_strDataRecord.Left(m_strDataRecord.Find('\\')+1);*/
//					CString strStatusBarInfo2 = /*strTmp+*/GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DISK_OUT);
//					SetStatusBarInfo(FALSE,strStatusBarInfo1,strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
//					CString strTempWarningType = _T("");
//					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
//					AddWarningInfo(strTempWarningType, (strStatusBarInfo1 + strStatusBarInfo2));
//					return;
//
//				}
//			}
//
//
//			CDC* pDC = pGuiDisplay->GetDC();
//			vdb.WriteToImageFile(pDC/*pGuiDisplay->GetDC()*/,strPath);
//			::ReleaseDC(pGuiDisplay->GetSafeHwnd(),pDC->GetSafeHdc());
//
//			if (pStaticContainer != NULL)
//			{
//				for (long i=0; i<pStaticContainer->GetCount(); i++)
//				{
//					scGuiGraphic* pGuiGraphic = pStaticContainer->GetItem(i);
//					if (pGuiGraphic != NULL)
//					{
//						if (pGuiGraphic->IsVisible())
//						{
//							if (pGuiGraphic->GetType()==eGuiText)
//							{
//
//								scGuiText* pGuiText = ((scGuiText*)pGuiGraphic);
//								LOGFONT* pFont = pGuiText->GetTextFont();
//								pFont->lfWeight = m_textWeight;
//								pFont->lfHeight = m_textHeight;
//								pFont->lfWidth  = m_textWidth;
//								((scGuiText*)pGuiGraphic)->SetTextFont(pFont);
//
//							}
//							else if (pGuiGraphic->GetType() == eGuiAffineRect)
//							{
//								scGuiAffineRect* pAffineRect = ((scGuiAffineRect*)pGuiGraphic);
//								pAffineRect->SetLineWidth(m_LineWidth);
//
//
//							}
//							else if (pGuiGraphic->GetType() == eGuiCoordCross)
//							{
//								scGuiCoordCross* pCoordCross = ((scGuiCoordCross*)pGuiGraphic);
//								pCoordCross->SetLineWidth(m_LineWidth);
//							}
//							vdb.AddGraphic(pGuiGraphic);
//						}
//					}
//				}
//			}
//
//			if (pStaticContainer != NULL)
//			{
//				long dHeight = cImage.Height();
//				long dwidth = cImage.Width();
//				double dX=0,dY=0,dD=0;
//				for (long i=0; i<pConstContainer->GetCount(); i++)
//				{
//					scGuiGraphic* pGuiGraphic = pConstContainer->GetItem(i);
//					if (pGuiGraphic != NULL)
//					{
//						double dPosXnew = dX;
//						double dPosYnew = dY;
//						if (pGuiGraphic->IsVisible()&&pGuiGraphic->GetType()==eGuiText)
//						{
//
//							((scGuiText*)pGuiGraphic)->GetXYRotation(dX,dY,dD);
//
//							RECT rtClient;
//							pGuiDisplay->GetClientRect(&rtClient);
//
//
//							scGuiText* pGuiText = ((scGuiText*)pGuiGraphic);
//							LOGFONT* pFont = pGuiText->GetTextFont();
//
//							pFont->lfWeight = 100;
//							pFont->lfHeight = 15;
//							pFont->lfWidth  = 10;
//							((scGuiText*)pGuiGraphic)->SetTextFont(pFont);
//							//((scGuiText*)pGuiGraphic)->SetXYRotation(dPosXnew,dPosYnew,dD);
//							//vdb.AddGraphic(pGuiGraphic);
//							//((scGuiText*)pGuiGraphic)->SetXYRotation(dX,dY,dD);
//							double nSegHeight = pFont->lfHeight * i;
//
//							//dPosYnew = dHeight*(rtClient.bottom-nSegHeight)/(rtClient.bottom-rtClient.top);
//							dPosYnew = rtClient.bottom - nSegHeight;
//						}
//						((scGuiText*)pGuiGraphic)->SetXYRotation(0,dPosYnew,dD);
//						
//					}
//				}
//			}
//			
//
//
//			//tend = GetTickCount();
//			//strTmp.Format(_T("nIndex-%d vdb.Write(strPath);; Times:%d ms"),nIndex,tend-tStrat);
//			//AlignLogRecord(strTmp);
//		}	
//	}
//}




void vcBaseVisionAlign::SaveVDBFile(scGuiDisplay* pGuiDisplay,CString strPath,int nIndex)
{
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Enter SaveVDBFile------");

	if (pGuiDisplay != NULL)
	{
		const cpImage cImage = m_vImageSearch[nIndex];
		if (cImage.IsValid())
		{
			//long tStrat = GetTickCount();

			scVDB vdb;
			ImageType tmpImageType = eImgPng;
			if (m_pVisionASMConfig != NULL)
			{

				switch (m_pVisionASMConfig->m_DataRecord.m_nVBDImageType)
				{
				case 0:
					{
						tmpImageType = eImgBmp;
						strPath += _T(".bmp");
					}
					break;
				case 1:
					{
						tmpImageType = eImgPng;
						strPath += _T(".png");
					}
					break;
				case 2:
					{
						tmpImageType = eImgJpeg;
						strPath += _T(".jpg");
					}
					break;
				default:
					{
						tmpImageType = eImgPng;
						strPath += _T(".bmp");
					}
					break;
				}

			}
			vdb.AddImage(cImage,tmpImageType);
			VisionAlignLogRecord("D:\\TimeLog.txt", "------Add image done------");


			scGuiStaticContainer* pStaticContainer = pGuiDisplay->GetStaticContainer();
			if (pStaticContainer != NULL)
			{
				for (long i=0; i<pStaticContainer->GetCount(); i++)
				{
					scGuiGraphic* pGuiGraphic = pStaticContainer->GetItem(i);
					if (pGuiGraphic != NULL)
					{
						if (pGuiGraphic->IsVisible())
						{
							vdb.AddGraphic(pGuiGraphic);
						}
					}
				}
			}

			scGuiStaticContainer* pGuiConstContainer = pGuiDisplay->GetConstContainer();
			if (pGuiConstContainer != NULL)
			{
				long dHeight = cImage.Height();
				long dwidth = cImage.Width();
				int nCurProductIndex =m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
				for (long i=0; i<pGuiConstContainer->GetCount(); i++)
				{
					scGuiGraphic* pGuiGraphic = pGuiConstContainer->GetItem(i);
					if (pGuiGraphic != NULL)
					{
						if (pGuiGraphic->IsVisible())
						{
							if(pGuiGraphic->GetType() == eGuiText)
							{
								scGuiText cGuiText;
								cGuiText.SetVisible(TRUE);

								double dPosX = 0.0, dPosY = 0.0, dPosD= 0.0;
								CString strText;

								scGuiText* pGuiText = ((scGuiText*)pGuiGraphic);
								cGuiText.SetLineColor(pGuiText->GetLineColor());
								pGuiText->GetXYRotation(dPosX,dPosY,dPosD);
								strText = pGuiText->GetText();
								LOGFONT* pFont = pGuiText->GetTextFont();
								if (pFont)
								{
									LOGFONT font = *pFont;
									font.lfWeight = 900;
									font.lfHeight = 30 * m_pVisionASMConfig->m_DataRecord.m_GuitextWeight;
									font.lfWidth  = 15 * m_pVisionASMConfig->m_DataRecord.m_GuitextWeight;
									cGuiText.SetTextFont(&font);
								}

								double dPosXnew = dPosX;
								double dPosYnew = dPosY;

								RECT rtClient;
								pGuiDisplay->GetClientRect(&rtClient);

								if(rtClient.right > rtClient.left)
								{
									dPosXnew = dwidth*(dPosX-rtClient.left)/(rtClient.right-rtClient.left);
								}
								if(rtClient.bottom > rtClient.top)
								{
									//dPosYnew = dHeight*(dPosY-rtClient.top)/(rtClient.bottom-rtClient.top);
									double nSegHeight = 30* m_pVisionASMConfig->m_DataRecord.m_GuitextWeight * i;
									dPosYnew = dHeight - nSegHeight;
								}

								cGuiText.SetXYRotationText(dPosXnew, dPosYnew, dPosD, strText);
								vdb.AddGraphic(&cGuiText);

							}
							else
							{
								vdb.AddGraphic(pGuiGraphic);
							}
						}
					}
				}
			}

			// 进行资源管控 超过阈值不进行VDB储存
			if (m_pSystemStatusInfo!=NULL)
			{
				double dUsedRate = 0.0;
				m_pSystemStatusInfo->GetDiskUsedRate(m_strDataRecord,dUsedRate);
				if (IsDiskUsedRateWarning(m_strDataRecord))
				{

					CString strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_ATTENTION);
					CString strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DISK_OUT);
					SetStatusBarInfo(FALSE,strStatusBarInfo1,strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					CString strTempWarningType = _T("");
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strStatusBarInfo1 + strStatusBarInfo2));
					return;

				}
			}
			VisionAlignLogRecord("D:\\TimeLog.txt", "------阈值管控完成------");

			// 自定义 VDB的保存线宽，字体大小；
			vdb.SetCustomGraphicParam(m_pVisionASMConfig->m_DataRecord.m_GuiLineWidth,
				m_pVisionASMConfig->m_DataRecord.m_GuitextWeight*12,
				m_pVisionASMConfig->m_DataRecord.m_GuitextWeight*12);
			vdb.EnableCustomGraphicParam(TRUE);

			CDC* pDC = pGuiDisplay->GetDC();
			vdb.WriteToImageFile(pDC,strPath);
			::ReleaseDC(pGuiDisplay->GetSafeHwnd(),pDC->GetSafeHdc());

			VisionAlignLogRecord("D:\\TimeLog.txt", "------WriteToImageFile done------");
		}	
	}
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Leave SaveVDBFile------");
}


void vcBaseVisionAlign::PostMessageUpdateGuiCalibrateTargetGraphics(int nPosIndex, BOOL bShow)
{
	if (NULL == m_pMainWnd)
	{
		return;
	}
	WPARAM wParam;
	wParam = nPosIndex;
	BOOL bPosShow = bShow/* && m_mpObjectMarkImagePos.GetIsMarkImagePosOK(nPosIndex)*/;
	PostMessage(m_pMainWnd->GetSafeHwnd(), WM_UPDATE_CALIBRATE_TARGET_GRAPHIC, wParam, bPosShow);
}

void vcBaseVisionAlign::SaveVDBFileFunc(int nIndex,SearchMode eSearchMode,int nProcessType/* = 0*/)
{
	if(NULL ==m_pMainWnd) return;


	CDlgVisionView2* pMainWnd = (CDlgVisionView2*)(m_pMainWnd);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	int nCamIndex = nIndex;

	if (sysPlatformInfo.m_nShowMode ==1 && sysPlatformInfo.m_eAlignerTargetMoveType != AlignerTargetMoveType::eTargetMoveByPlatform)
	{
		nCamIndex = GetPosCameraIndex(nIndex);
	}

	if (nCamIndex < pMainWnd->m_vpGuiDisplay.size() && pMainWnd->m_vpGuiDisplay.at(nCamIndex)!=NULL && pMainWnd->m_vpGuiDisplay.at(nCamIndex)->GetSafeHwnd())
	{
		SaveSearchVDBFile(pMainWnd->m_vpGuiDisplay.at(nCamIndex),nIndex,eSearchMode,nProcessType);
	}
}

void vcBaseVisionAlign::ExeSaveVDBFile(std::vector<int> vnPosIndex,SearchMode eSearchMode,int nProcessType/* = -1*/)
{
	if (!m_pVisionASMConfig->m_DataRecord.m_bSaveInsepectResultVDBFile) //不开按照检测结果保存功能时设置为默认方式
	{
		nProcessType = 0;
	}
	else
	{
		if (nProcessType != -1) //等于-1时为默认方式
		{
			nProcessType = nProcessType ? 1:2;
		}
		else
		{
			nProcessType = 0;
		}
	}

	if(m_pSystempOptionConfig== NULL) return;
	if (m_pSystempOptionConfig->m_bSaveVDBPostMessage==1)
	{
		VisionAlignLogRecord("D:\\TimeLog.txt", "存VDB 开始 线程存VDB");
		for(int it=0;it<vnPosIndex.size();it++)
		{
			m_vsmSearchMode[vnPosIndex.at(it)] = eSearchMode;
			m_vnProcessType[vnPosIndex.at(it)] = nProcessType;
			StartSaveImage(vnPosIndex.at(it));
		}
	}
	else if(m_pSystempOptionConfig->m_bSaveVDBPostMessage==2)
	{
		VisionAlignLogRecord("D:\\TimeLog.txt", "存VDB 开始 消息存VDB");

		PostMessageSaveVDBFile(vnPosIndex,eSearchMode,nProcessType);
	}
	else
	{
		VisionAlignLogRecord("D:\\TimeLog.txt", "存VDB 开始 直接存VDB");

		// 增加Sleep()
		int nDelayTime2 = 50; // 避免GUI未刷新就开始存VDB，出现只存图，缺少GUI情况
		if(m_pVisionASMConfig)
		{
			int nCurProductIndex =m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			if(m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex) && m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex)->m_pAlignerParam)
			{
				nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
			}
		}

		for(int it=0;it<vnPosIndex.size();it++)
		{
			Sleep(nDelayTime2);
			SaveVDBFileFunc(vnPosIndex.at(it),eSearchMode,nProcessType);
		}
	}
	VisionAlignLogRecord("D:\\TimeLog.txt", "存VDB结束"); 
}

void vcBaseVisionAlign::StopNow( BOOL bStopNow )
{
	m_bStopNow = bStopNow;
}

//	加载/保存机器人示教范围信息
BOOL vcBaseVisionAlign::LoadRobotTeachRangeInfo()
{
	return FALSE;
}

BOOL vcBaseVisionAlign::SaveRobotTeachRangeInfo()
{
	return FALSE;
}

// 设置、获取机器人示教范围信息
void vcBaseVisionAlign::SetRobotTeachRangeInfo( CRobotTeachRangeInfo robotTeachRangeInfo )
{
	m_RobotTeachRangeInfo = robotTeachRangeInfo;
}

void vcBaseVisionAlign::GetRobotTeachRangeInfo( CRobotTeachRangeInfo& robotTeachRangeInfo )
{
	robotTeachRangeInfo = m_RobotTeachRangeInfo;
}

// 创建手动搜索临界区
void vcBaseVisionAlign::CreateManualSearchSection()
{
	InitializeCriticalSection(&m_gManualSearchSection);
}

// 删除手动搜索临界区
void vcBaseVisionAlign::DeleteManualSearchSection()
{
	DeleteCriticalSection(&m_gManualSearchSection);
}

BOOL vcBaseVisionAlign::ExcuteManualSearch(int nMarkType,int nPosIndex,int nMoveIndex,int nMarkNum)
{
	EnterCriticalSection(&m_gManualSearchSection);

	// 取消显示是否启用手动选标；
	//CDlgSearchFailWarning dlg;
	//if (dlg.DoModal()==IDOK)
	{
		

		if (2 == nMarkType)  // 关联
		{
			CDlgManualSearchCalib msdlg;
			msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
			msdlg.SetMarkType(nMarkType);
			msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
			msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
			msdlg.m_nCurPosIndex = nPosIndex;
			msdlg.m_nMarkNum = nMarkNum;
			msdlg.nMoveIndex = nMoveIndex;
			msdlg.SetVisionAlignerRef(this);

			BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
			m_bEnableSingleFrameShowMode = FALSE;

			if (msdlg.DoModal()==IDOK)
			{
				m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

				if (nMarkType==1) // 对象Mark
				{
					if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
					{	
						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
					else
					{
						m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						m_mpObjectMarkImagePos.m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
						LeaveCriticalSection(&m_gManualSearchSection);

						std::vector<int> vnPosIndex;
						vnPosIndex.push_back(nPosIndex);
						//LJJ
						// 						SetGuiAlnObjectImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateGuiAlnObjectImagePosGraphics(nPosIndex, TRUE);
						// 
						// 						// SY
						// 						SetShowGuiObjectImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateShowGuiObjectImagePosToDisplay(nPosIndex, TRUE);
						m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

						return TRUE;
					}
				}
				else if (nMarkType==2) // 关联标定
				{
					if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
					{	
						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
					else
					{
						//m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						//m_mpObjectMarkImagePos.m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);

						m_vpmpCalibMarkImagePos.at(nMoveIndex)->m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						m_vpmpCalibMarkImagePos.at(nMoveIndex)->m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);

						LeaveCriticalSection(&m_gManualSearchSection);

						//std::vector<int> vnPosIndex;
						//vnPosIndex.push_back(nPosIndex);
						//SetGuiAlnObjectImageMarkPos(vnPosIndex);
						//PostMessageUpdateGuiAlnObjectImagePosGraphics(nPosIndex, TRUE);

						//// SY
						//SetShowGuiObjectImageMarkPos(vnPosIndex);
						//PostMessageUpdateShowGuiObjectImagePosToDisplay(nPosIndex, TRUE);

						return TRUE;
					}
				}
				else	// 目标Mark
				{
					if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
					{	
						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
					else
					{
						m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						m_mpTargetMarkImagePos.m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
						LeaveCriticalSection(&m_gManualSearchSection);
						std::vector<int> vnPosIndex;
						vnPosIndex.push_back(nPosIndex);

						m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
						// 						SetGuiAlnTargetImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateGuiAlnTargetImagePosGraphics(nPosIndex, TRUE);
						// 
						// 						// SY
						// 						SetShowGuiTargetImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateShowGuiTargetImagePosToDisplay(nPosIndex, TRUE);
						return TRUE;
					}

				}
			}

			m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

			LeaveCriticalSection(&m_gManualSearchSection);
			return FALSE;
		}
		else
		{
			CDlgManualSearch msdlg;

			msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
			msdlg.SetMarkType(nMarkType);
			msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
			msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
			msdlg.m_nCurPosIndex = nPosIndex;
			//msdlg.SetVisionAlignerRef(this);
			msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

			BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
			m_bEnableSingleFrameShowMode = FALSE;

			if (msdlg.DoModal()==IDOK)
			{
				m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

				if (nMarkType==1) // 对象Mark
				{
					if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
					{	
						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
					else
					{
						m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						m_mpObjectMarkImagePos.m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
						LeaveCriticalSection(&m_gManualSearchSection);

						std::vector<int> vnPosIndex;
						vnPosIndex.push_back(nPosIndex);
						// 						SetGuiAlnObjectImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateGuiAlnObjectImagePosGraphics(nPosIndex, TRUE);
						// 
						// 						// SY
						// 						SetShowGuiObjectImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateShowGuiObjectImagePosToDisplay(nPosIndex, TRUE);

						m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

						return TRUE;
					}
				}
				else if (nMarkType==2) // 关联标定
				{
					if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
					{	
						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
					else
					{
						//m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						//m_mpObjectMarkImagePos.m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);

						m_vpmpCalibMarkImagePos.at(nMoveIndex)->m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						m_vpmpCalibMarkImagePos.at(nMoveIndex)->m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);

						LeaveCriticalSection(&m_gManualSearchSection);

						std::vector<int> vnPosIndex;
						vnPosIndex.push_back(nPosIndex);
						m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

						// 						SetGuiAlnObjectImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateGuiAlnObjectImagePosGraphics(nPosIndex, TRUE);
						// 
						// 						// SY
						// 						SetShowGuiObjectImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateShowGuiObjectImagePosToDisplay(nPosIndex, TRUE);

						return TRUE;
					}
				}
				else	// 目标Mark
				{
					if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
					{	
						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
					else
					{
						m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						m_mpTargetMarkImagePos.m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
						LeaveCriticalSection(&m_gManualSearchSection);
						std::vector<int> vnPosIndex;
						vnPosIndex.push_back(nPosIndex);
						m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
						// 						SetGuiAlnTargetImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateGuiAlnTargetImagePosGraphics(nPosIndex, TRUE);
						// 
						// 						// SY
						// 						SetShowGuiTargetImageMarkPos(vnPosIndex);
						// 						PostMessageUpdateShowGuiTargetImagePosToDisplay(nPosIndex, TRUE);
						return TRUE;
					}

				}
			}

			m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

			LeaveCriticalSection(&m_gManualSearchSection);
			return FALSE;
		}

	}

	LeaveCriticalSection(&m_gManualSearchSection);
	return FALSE;
}

BOOL vcBaseVisionAlign::ExcuteManualSearch(int nMarkType,int nPosIndex)
{
	EnterCriticalSection(&m_gManualSearchSection);

	// 直接弹出选点界面 
	//CDlgSearchFailWarning dlg;
	//if (dlg.DoModal()==IDOK)
	{
		//20230803	wm	点击停止时直接返回，不再进行弹窗，防止卡死主线程
		if (m_bSuspendWorkThread)
		{
			VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt","点击[停止运行],直接返回");
			LeaveCriticalSection(&m_gManualSearchSection);
			return FALSE;
		}

		CDlgManualSearch msdlg;

		msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
		msdlg.SetMarkType(nMarkType);
		msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
		msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		msdlg.m_nCurPosIndex = nPosIndex;
		//msdlg.SetVisionAlignerRef(this);
		msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);


		BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
		m_bEnableSingleFrameShowMode = FALSE;

		if (msdlg.DoModal()==IDOK)
		{
			m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

			if (nMarkType==1) // 对象Mark
			{
				if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
				{	
					LeaveCriticalSection(&m_gManualSearchSection);
					return FALSE;
				}
				else
				{
					m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
					m_mpObjectMarkImagePos.m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
					LeaveCriticalSection(&m_gManualSearchSection);

					std::vector<int> vnPosIndex;
					vnPosIndex.push_back(nPosIndex);
					m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
					// 					SetGuiAlnObjectImageMarkPos(vnPosIndex);
					// 					PostMessageUpdateGuiAlnObjectImagePosGraphics(nPosIndex, TRUE);
					// 
					// 					// SY
					// 					SetShowGuiObjectImageMarkPos(vnPosIndex);
					// 					PostMessageUpdateShowGuiObjectImagePosToDisplay(nPosIndex, TRUE);

					return TRUE;
				}
			}
			else	// 目标Mark
			{
				if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
				{	
					LeaveCriticalSection(&m_gManualSearchSection);
					return FALSE;
				}
				else
				{
					m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
					m_mpTargetMarkImagePos.m_vPos.at(nPosIndex) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
					LeaveCriticalSection(&m_gManualSearchSection);
					std::vector<int> vnPosIndex;
					vnPosIndex.push_back(nPosIndex);
					m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
					// 					SetGuiAlnTargetImageMarkPos(vnPosIndex);
					// 					PostMessageUpdateGuiAlnTargetImagePosGraphics(nPosIndex, TRUE);
					// 
					// 					// SY
					// 					SetShowGuiTargetImageMarkPos(vnPosIndex);
					// 					PostMessageUpdateShowGuiTargetImagePosToDisplay(nPosIndex, TRUE);
					return TRUE;
				}

			}
		}

		m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

		LeaveCriticalSection(&m_gManualSearchSection);
		return FALSE;
	}

	LeaveCriticalSection(&m_gManualSearchSection);
	return FALSE;
}

BOOL vcBaseVisionAlign::ExcuteManualSearch(int nMarkType,std::vector<int> nPosIndex)
{
	EnterCriticalSection(&m_gManualSearchSection);
	//CDlgSearchFailWarning dlg;
	//if (dlg.DoModal()==IDOK)
	for (int i=0;i<nPosIndex.size();i++)
	{
		//20230803	wm	点击停止时直接返回，不再进行弹窗，防止卡死主线程
		if (m_bSuspendWorkThread)
		{
			VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt","点击[停止运行],直接返回");
			LeaveCriticalSection(&m_gManualSearchSection);
			return FALSE;
		}

		if (nMarkType==1)
		{
			if (m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
			{
				CDlgManualSearch msdlg;		

				msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
				msdlg.SetMarkType(nMarkType);
				msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
				msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
				msdlg.m_nCurPosIndex = nPosIndex.at(i);
				msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);
				//msdlg.SetVisionAlignerRef(this);

				BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
				m_bEnableSingleFrameShowMode = FALSE;

				if (msdlg.DoModal()==IDOK)
				{
					m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

					if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
					{	
						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
					else
					{
						m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
						//LeaveCriticalSection(&m_gManualSearchSection);

						std::vector<int> vnPosIndex;
						vnPosIndex.push_back(nPosIndex.at(i));
						m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
						// 							SetGuiAlnObjectImageMarkPos(vnPosIndex);
						// 							PostMessageUpdateGuiAlnObjectImagePosGraphics(nPosIndex.at(i), TRUE);
						// 
						// 							// SY
						// 							SetShowGuiObjectImageMarkPos(vnPosIndex);
						// 							PostMessageUpdateShowGuiObjectImagePosToDisplay(nPosIndex.at(i), TRUE);

					}
				}
				else
				{
					m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

					LeaveCriticalSection(&m_gManualSearchSection);
					return FALSE;
				}
			}

		}
		else if (nMarkType==0)
		{
			if (m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
			{
				CDlgManualSearch msdlg;	

				msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
				msdlg.SetMarkType(nMarkType);
				msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
				msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
				msdlg.m_nCurPosIndex = nPosIndex.at(i);
				msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);
				//msdlg.SetVisionAlignerRef(this);

				BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
				m_bEnableSingleFrameShowMode = FALSE;

				if (msdlg.DoModal()==IDOK)
				{
					m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

					if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
					{	
						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
					else
					{
						m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
						m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
						//LeaveCriticalSection(&m_gManualSearchSection);
						std::vector<int> vnPosIndex;
						vnPosIndex.push_back(nPosIndex.at(i));
						m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
						// 							SetGuiAlnTargetImageMarkPos(vnPosIndex);
						// 							PostMessageUpdateGuiAlnTargetImagePosGraphics(nPosIndex.at(i), TRUE);
						// 
						// 							// SY
						// 							SetShowGuiTargetImageMarkPos(vnPosIndex);
						// 							PostMessageUpdateShowGuiTargetImagePosToDisplay(nPosIndex.at(i), TRUE);
						//return TRUE;
					}
				}
				else
				{
					m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

					LeaveCriticalSection(&m_gManualSearchSection);
					return FALSE;
				}
			}
		}
		else if (nMarkType == 2)
		{
			if (m_mpInspectMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
			{
				// Target
				{

					CDlgManualSearch msdlg;	

					msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
					msdlg.SetMarkType(nMarkType);
					msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
					msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
					msdlg.m_nCurPosIndex = nPosIndex.at(i);
					msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

					BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
					m_bEnableSingleFrameShowMode = FALSE;

					if (msdlg.DoModal()==IDOK)
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
						{	
							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
						else
						{
							if (i==0)
							{
								m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							} 

							if(i==1)
							{
								m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							}

						}
					}
					else
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
				}


				Sleep(10);


				// Object
				{
					CDlgManualSearch msdlg;	

					msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
					msdlg.SetMarkType(nMarkType+1);
					msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
					msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
					msdlg.m_nCurPosIndex = nPosIndex.at(i);
					msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

					BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
					m_bEnableSingleFrameShowMode = FALSE;

					if (msdlg.DoModal()==IDOK)
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
						{	
							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
						else
						{
							if (i==0)
							{
								m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							} 
							if(i==1)
							{
								m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							}
						}
					}
					else
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
				}

				std::vector<int> vnPosIndex;
				vnPosIndex.push_back(nPosIndex.at(i));
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
				m_cVisionAlignGui.SetPosObjectToTargetResultLine(vnPosIndex);
			}
		}
	}

	LeaveCriticalSection(&m_gManualSearchSection);
	return TRUE;
}

BOOL vcBaseVisionAlign::ExcuteManualSearch_TX(int nMarkType,std::vector<int> nPosIndex)
{
	EnterCriticalSection(&m_gManualSearchSection);
	//CDlgSearchFailWarning dlg;
	//if (dlg.DoModal()==IDOK)
	for (int i=0;i<nPosIndex.size();i++)
	{
		//20230803	wm	点击停止时直接返回，不再进行弹窗，防止卡死主线程
		if (m_bSuspendWorkThread)
		{
			VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt","点击[停止运行],直接返回");
			LeaveCriticalSection(&m_gManualSearchSection);
			return FALSE;
		}

		if (nMarkType==0)
		{
			if (m_mpInspectMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
			{
				// Target
				{

					CDlgManualSearch msdlg;	

					msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
					msdlg.SetMarkType(nMarkType);
					msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
					msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
					msdlg.m_nCurPosIndex = nPosIndex.at(i);
					msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

					BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
					m_bEnableSingleFrameShowMode = FALSE;

					if (msdlg.DoModal()==IDOK)
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
						{	
							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
						else
						{
							if (i==0)
							{
								m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							} 

							if(i==1)
							{
								m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							}

						}
					}
					else
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
				}


				//Sleep(10);


				//// Object
				//	{
				//	CDlgManualSearch msdlg;	

				//	msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
				//	msdlg.SetMarkType(nMarkType+1);
				//	msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
				//	msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
				//	msdlg.m_nCurPosIndex = nPosIndex.at(i);
				//	msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

				//	BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
				//	m_bEnableSingleFrameShowMode = FALSE;

				//	if (msdlg.DoModal()==IDOK)
				//		{
				//		m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

				//		if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
				//			{	
				//			LeaveCriticalSection(&m_gManualSearchSection);
				//			return FALSE;
				//			}
				//		else
				//			{
				//			if (i==0)
				//				{
				//				m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
				//				m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
				//				} 
				//			if(i==1)
				//				{
				//				m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
				//				m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
				//				}
				//			}
				//		}
				//	else
				//		{
				//		m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

				//		LeaveCriticalSection(&m_gManualSearchSection);
				//		return FALSE;
				//		}
				//	}

				std::vector<int> vnPosIndex;
				vnPosIndex.push_back(nPosIndex.at(i));
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
				m_cVisionAlignGui.SetPosObjectToTargetResultLine(vnPosIndex);

			}
		}
		else if (nMarkType==1)
		{
			if (m_mpInspectMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
				/*if (m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)*/
			{
				// Target
				/*	{

				CDlgManualSearch msdlg;	

				msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
				msdlg.SetMarkType(nMarkType);
				msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
				msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
				msdlg.m_nCurPosIndex = nPosIndex.at(i);
				msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

				BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
				m_bEnableSingleFrameShowMode = FALSE;

				if (msdlg.DoModal()==IDOK)
				{
				m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

				if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
				{	
				LeaveCriticalSection(&m_gManualSearchSection);
				return FALSE;
				}
				else
				{
				if (i==0)
				{
				m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
				m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
				} 

				if(i==1)
				{
				m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
				m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
				}

				}
				}
				else
				{
				m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

				LeaveCriticalSection(&m_gManualSearchSection);
				return FALSE;
				}
				}


				Sleep(10);*/


				// Object
				{
					CDlgManualSearch msdlg;	

					msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
					msdlg.SetMarkType(nMarkType+1);
					msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
					msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
					msdlg.m_nCurPosIndex = nPosIndex.at(i);
					msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

					BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
					m_bEnableSingleFrameShowMode = FALSE;

					if (msdlg.DoModal()==IDOK)
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
						{	
							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
						else
						{
							if (i==0)
							{
								m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							} 
							if(i==1)
							{
								m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							}
						}
					}
					else
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
				}

				std::vector<int> vnPosIndex;
				vnPosIndex.push_back(nPosIndex.at(i));
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
				m_cVisionAlignGui.SetPosObjectToTargetResultLine(vnPosIndex);
			}
		}
		else if (nMarkType == 2)
		{
			//if (m_mpInspectMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
			if (m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
			{
				// Target
				{

					CDlgManualSearch msdlg;	

					msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
					msdlg.SetMarkType(nMarkType);
					msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
					msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
					msdlg.m_nCurPosIndex = nPosIndex.at(i);
					msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

					BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
					m_bEnableSingleFrameShowMode = FALSE;

					if (msdlg.DoModal()==IDOK)
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
						{	
							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
						else
						{
							if (i==0)
							{
								m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							} 

							if(i==1)
							{
								m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							}

						}
					}
					else
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
				}


				Sleep(10);


				// Object
				{
					CDlgManualSearch msdlg;	

					msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
					msdlg.SetMarkType(nMarkType+1);
					msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
					msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
					msdlg.m_nCurPosIndex = nPosIndex.at(i);
					msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

					BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
					m_bEnableSingleFrameShowMode = FALSE;

					if (msdlg.DoModal()==IDOK)
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
						{	
							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
						else
						{
							if (i==0)
							{
								m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							} 
							if(i==1)
							{
								m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
								m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							}
						}
					}
					else
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
				}

				std::vector<int> vnPosIndex;
				vnPosIndex.push_back(nPosIndex.at(i));
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
				m_cVisionAlignGui.SetPosObjectToTargetResultLine(vnPosIndex);
			}
		}
	}

	LeaveCriticalSection(&m_gManualSearchSection);
	return TRUE;
}

//折弯用手动弹窗
BOOL vcBaseVisionAlign::ExcuteManualSearch_EX(int nMarkType,std::vector<int> nPosIndex,std::vector<BOOL> nPosIndex1)
{
	EnterCriticalSection(&m_gManualSearchSection);
	//CDlgSearchFailWarning dlg;
	//if (dlg.DoModal()==IDOK)
	for (int i=0;i<nPosIndex.size();i++)
	{
		if (FALSE == nPosIndex1.at(i))
		{
			//20230803	wm	点击停止时直接返回，不再进行弹窗，防止卡死主线程
			if (m_bSuspendWorkThread)
			{
				VisionAlignLogRecord("D:\\SuspendWorkthreadLog.txt","点击[停止运行],直接返回");
				LeaveCriticalSection(&m_gManualSearchSection);
				return FALSE;
			}

			if (nMarkType==1)
			{
				if (m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
				{
					CDlgManualSearch msdlg;		

					msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
					msdlg.SetMarkType(nMarkType);
					msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
					msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
					msdlg.m_nCurPosIndex = nPosIndex.at(i);
					msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);
					//msdlg.SetVisionAlignerRef(this);

					BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
					m_bEnableSingleFrameShowMode = FALSE;

					if (msdlg.DoModal()==IDOK)
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
						{	
							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
						else
						{
							m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
							m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							//LeaveCriticalSection(&m_gManualSearchSection);

							std::vector<int> vnPosIndex;
							vnPosIndex.push_back(nPosIndex.at(i));
							m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
							// 							SetGuiAlnObjectImageMarkPos(vnPosIndex);
							// 							PostMessageUpdateGuiAlnObjectImagePosGraphics(nPosIndex.at(i), TRUE);
							// 
							// 							// SY
							// 							SetShowGuiObjectImageMarkPos(vnPosIndex);
							// 							PostMessageUpdateShowGuiObjectImagePosToDisplay(nPosIndex.at(i), TRUE);

						}
					}
					else
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
				}

			}
			else if (nMarkType==0)
			{
				if (m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
				{
					CDlgManualSearch msdlg;	

					msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
					msdlg.SetMarkType(nMarkType);
					msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
					msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
					msdlg.m_nCurPosIndex = nPosIndex.at(i);
					msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);
					//msdlg.SetVisionAlignerRef(this);

					BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
					m_bEnableSingleFrameShowMode = FALSE;

					if (msdlg.DoModal()==IDOK)
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
						{	
							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
						else
						{
							m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
							m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
							//LeaveCriticalSection(&m_gManualSearchSection);
							std::vector<int> vnPosIndex;
							vnPosIndex.push_back(nPosIndex.at(i));
							m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
						}
					}
					else
					{
						m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

						LeaveCriticalSection(&m_gManualSearchSection);
						return FALSE;
					}
				}
			}
			else if (nMarkType == 2)
			{
				//if (m_mpInspectMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE)
				if (1/*m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i))==FALSE*/)
				{
					// Target
					{

						CDlgManualSearch msdlg;	

						msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
						msdlg.SetMarkType(nMarkType);
						msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
						msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
						msdlg.m_nCurPosIndex = nPosIndex.at(i);
						msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

						BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
						m_bEnableSingleFrameShowMode = FALSE;

						if (msdlg.DoModal()==IDOK)
						{
							m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

							if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
							{	
								LeaveCriticalSection(&m_gManualSearchSection);
								return FALSE;
							}
							else
							{
								if (i==0)
								{
									m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
									m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
								} 

								if(i==1)
								{
									m_mpTargetMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
									m_mpTargetMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
								}

							}
						}
						else
						{
							m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
					}


					Sleep(10);


					// Object
					{
						CDlgManualSearch msdlg;	

						msdlg.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex+1;
						msdlg.SetMarkType(nMarkType+1);
						msdlg.SetSysInfoStringsRef(m_psaSysInfoStrings);
						msdlg.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
						msdlg.m_nCurPosIndex = nPosIndex.at(i);
						msdlg.SetSearchImage(m_vImageSearch[msdlg.m_nCurPosIndex]);

						BOOL bPrevEnableSingleFrameShowMode = m_bEnableSingleFrameShowMode;
						m_bEnableSingleFrameShowMode = FALSE;

						if (msdlg.DoModal()==IDOK)
						{
							m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

							if (msdlg.m_mpMarkImagePos.GetMarkImagePosNum()<=0)
							{	
								LeaveCriticalSection(&m_gManualSearchSection);
								return FALSE;
							}
							else
							{
								if (i==0)
								{
									m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
									m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
								} 
								if(i==1)
								{
									m_mpObjectMarkImagePos.m_vbOK.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vbOK.at(0);
									m_mpObjectMarkImagePos.m_vPos.at(nPosIndex.at(i)) = msdlg.m_mpMarkImagePos.m_vPos.at(0);
								}
							}
						}
						else
						{
							m_bEnableSingleFrameShowMode = bPrevEnableSingleFrameShowMode;

							LeaveCriticalSection(&m_gManualSearchSection);
							return FALSE;
						}
					}

					std::vector<int> vnPosIndex;
					vnPosIndex.push_back(nPosIndex.at(i));
					m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
					m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
					m_cVisionAlignGui.SetPosObjectToTargetResultLine(vnPosIndex);
				}
			}
		}
	}

	LeaveCriticalSection(&m_gManualSearchSection);
	return TRUE;
}


// 设置手动搜索Mark类型
void vcBaseVisionAlign::ExecuteManualSearchMark(SearchMode searchMode)
{
	m_nManualSearchMarkMode = searchMode;
}


void vcBaseVisionAlign::SinglePlatformProductManage(BOOL bExecuteProductManage)
{
	m_bExecuteProductManage = bExecuteProductManage;
}

// 设置对位精度
BOOL vcBaseVisionAlign::SetAlignerPrecision(CCoordPos precision)
{
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}
	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}

	EnterCriticalSection(&m_csAlignerPrecision);
	pCurProductData->m_pAlignerParam->SetAlignerPrecision(precision);
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetAlignerPrecision(precision);
	LeaveCriticalSection(&m_csAlignerPrecision);

	SaveProductDataInfo(nCurProductIndex);

	return TRUE;
}

// 设置对位最大次数
BOOL vcBaseVisionAlign::SetAlignerMaxTime(int nTime)
{
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}
	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}

	EnterCriticalSection(&m_csAlignerMaxTime);
	pCurProductData->m_pAlignerParam->SetAlignerMaxTime(nTime);
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetAlignerMaxTime(nTime);
	LeaveCriticalSection(&m_csAlignerMaxTime);

	SaveProductDataInfo(nCurProductIndex);

	return TRUE;
}
// 设置对位补偿值索引
BOOL vcBaseVisionAlign::SetCurAlignerOffsetIndex(int nIndex)
{
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}
	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nIndex);
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	//	PostMessageUpdateAlignOffsetInfo();

	SaveProductDataInfo(nCurProductIndex);

	return TRUE;
}
// 设置对位补偿值
BOOL vcBaseVisionAlign::SetCurAlignerOffset(int nIndex, CCoordPos Offset)
{
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}
	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nIndex);
	pCurProductData->m_pAlignerParam->SetAlignerOffset(nIndex, Offset);
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nIndex);
	pAlignerParam->SetAlignerOffset(nIndex, Offset);
	LeaveCriticalSection(&m_csAlignerOffset);
	//	PostMessageUpdateAlignOffsetInfo();

	SaveProductDataInfo(nCurProductIndex);

	return TRUE;
}


CalibTargetMarkPatternMode  vcBaseVisionAlign::GetCalibTargetMarkPatternMode()
{
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return eSinglePatternSingleMark;
	}	 
	return pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode();
}

CalibMarkPatternMode  vcBaseVisionAlign::GetCalibMarkPatternMode()
{
	int nCurCalibIndex = m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	CCalibData* pCurCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurCalibIndex);
	if (pCurCalibData == NULL)
	{
		return eTraditionalCalib;
	}	 
	return pCurCalibData->GetCalibMarkPatternMode();
}



CalibTargetMarkPatternMode  vcBaseVisionAlign::GetProductCalibTargetMarkPatternMode(int nIndex)
{
	if(nIndex<0 || nIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return eSinglePatternSingleMark;
	}
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nIndex);
	if (pCurProductData == NULL)
	{
		return eSinglePatternSingleMark;
	}	 
	return pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode();
}


// 设置对位检查信息
BOOL vcBaseVisionAlign::SetAlignCheckInfo(CAlignCheckInfo checkInfo)
{
	if (m_pVisionASMConfig == NULL)
	{
		return FALSE;
	}

	// 1.获取当前产品索引
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 2.获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}

	// 3.获取对位工具中的对位参数（？？？）
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();

	EnterCriticalSection(&m_csAlignCheckInfo);
	// 设置当前产品对位参数
	pCurProductData->m_pAlignerParam->SetAlignCheckInfo(checkInfo,m_pAlignerTool->GetAlignExProductIndex());
	// ？？？
	pAlignerParam->SetAlignCheckInfo(checkInfo,m_pAlignerTool->GetAlignExProductIndex());
	LeaveCriticalSection(&m_csAlignCheckInfo);

	SaveProductDataInfo(nCurProductIndex);

	return TRUE;
}
BOOL vcBaseVisionAlign::SetAlignCheckInfo(CAlignCheckInfo checkInfo,const int Index)
{
	if (m_pVisionASMConfig == NULL)
	{
		return FALSE;
	}

	// 1.获取当前产品索引
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 2.获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}

	// 3.获取对位工具中的对位参数（？？？）
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	if(Index <0 || Index >= pAlignerParam->m_vAlignCheckInfo.size()) return FALSE;


	EnterCriticalSection(&m_csAlignCheckInfo);
	// 设置当前产品对位参数
	pCurProductData->m_pAlignerParam->SetAlignCheckInfo(checkInfo,Index);
	// ？？？
	pAlignerParam->SetAlignCheckInfo(checkInfo,Index);
	LeaveCriticalSection(&m_csAlignCheckInfo);

	SaveProductDataInfo(nCurProductIndex);

	return TRUE;
}

CAlignerParam* vcBaseVisionAlign::GetProductAlignerParam()
{
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}
	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}

	return pCurProductData->m_pAlignerParam;

}


void vcBaseVisionAlign::PackAndAddCommSimpleInfo(CString & strInfo,CString strCmd,std::vector<int> nParam,std::vector<double> dParam)
{

	CString strHead = char(0x02);
	CString strName= strCmd;

	CString strBlank = _T(" ");
	CString strTail = char(0x03);	
	CString strCR = char(0x0D);

	CString strnParam;
	strnParam.Empty();
	for (int i=0;i<nParam.size();i++)
	{
		CString str;
		str.Format("%d",nParam.at(i));
		if (i!=0)
		{
			strnParam = strnParam + strBlank + str;
		}
		else
		{
			strnParam = strnParam + str;
		}
	}

	CString strdParam;
	strdParam.Empty();
	for (int i=0;i<dParam.size();i++)
	{
		CString str;
		str.Format("%.5f",dParam.at(i));
		if (i!=0)
		{
			strdParam = strdParam + strBlank + str;
		}
		else
		{
			strdParam =strBlank+ strdParam + str;
		}

	}


	//构造写命令
	strInfo.Empty();
	strInfo = strHead + strName + strBlank + strnParam + /*strBlank +*/ strdParam+ strTail;

	AddCommCommandInfo(FALSE,strInfo,FALSE,FALSE);

	return ;


}




//////////////////////////////////////////////////////////////////////////
void vcBaseVisionAlign::SetMultiEXObjectMarkSearchResultsWithCombinationCode(CMarkImagePos ImageResults)
{

	if(m_pAlignerTool->m_bEnableMultiCombinationCode && (m_pAlignerTool->m_nCombinationCode>=99 && m_pAlignerTool->m_nCombinationCode<=103))
	{
		std::vector<int> vnCode;
		int nNum = 0;
		nNum = m_pAlignerTool->GetMultiCalibExtensionMaxNum()+1;
		switch (m_pAlignerTool->m_nCombinationCode)
		{
		case 99: // 全部
			{
				for (int it=0;it<nNum;it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 100: // 前一半
			{
				for (int it=0;it<(int)(nNum/2 +0.5);it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 101: // 后一半
			{
				for (int it=(int)(nNum/2);it<nNum;it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 102:   //奇数组
			{
				for (int it=0;it<nNum;it+=2)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 103: // 偶数组
			{
				for (int it=1;it<nNum;it+=2)
				{
					vnCode.push_back(it);
				}
			}
			break;
		default:
			{
				vnCode.push_back(0);
			}
			break;
		}

		for (int it = 0;it<vnCode.size();it++)
		{
			m_vmpObjectMarkImagePos_MultiEX.at(vnCode.at(it)) = ImageResults;
		}
	}
	else
	{
		m_vmpObjectMarkImagePos_MultiEX.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpObjectMarkImagePos;
	}

	//std::vector<int> vnCode;
	//int nNum = 0;
	//nNum = m_pAlignerTool->GetMultiCalibExtensionMaxNum()+1;

	//for (int it=0;it<nNum;it++)
	//{
	//	vnCode.push_back(it);
	//}

	//for (int it = 0;it<vnCode.size();it++)
	//{
	//	m_vmpObjectMarkImagePos_MultiEX.at(vnCode.at(it)) = ImageResults;
	//}


}

void vcBaseVisionAlign::SetMultiEXTargetMarkSearchResultsWithCombinationCode(CMarkImagePos ImageResults)
{

	if(m_pAlignerTool->m_bEnableMultiCombinationCode && (m_pAlignerTool->m_nCombinationCode>=99 && m_pAlignerTool->m_nCombinationCode<=103))
	{
		std::vector<int> vnCode;
		int nNum = 0;
		nNum = m_pAlignerTool->GetMultiCalibExtensionMaxNum()+1;
		switch (m_pAlignerTool->m_nCombinationCode)
		{
		case 99: // 全部
			{
				for (int it=0;it<nNum;it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 100: // 前一半
			{
				for (int it=0;it<(int)(nNum/2 +0.5);it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 101: // 后一半
			{
				for (int it=(int)(nNum/2);it<nNum;it++)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 102:   //奇数组
			{
				for (int it=0;it<nNum;it+=2)
				{
					vnCode.push_back(it);
				}
			}
			break;
		case 103: // 偶数组
			{
				for (int it=1;it<nNum;it+=2)
				{
					vnCode.push_back(it);
				}
			}
			break;
		default:
			{
				vnCode.push_back(0);
			}
			break;
		}

		for (int it = 0;it<vnCode.size();it++)
		{
			m_vmpTargetMarkImagePosMultiEx.at(vnCode.at(it)) = ImageResults;
		}
	}
	else
	{
		m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
	}
}

//获得存储的文件夹
CString vcBaseVisionAlign::GetDataRecordDirectory()
{
	return m_strDataRecord;
}

CShareCommInfoArray* vcBaseVisionAlign::GetShareCommInfoArray()
{
	return &m_ShareCommInfoArray;
}

// 添加平台共享通信信息，即设置所有的共享通信信息
void vcBaseVisionAlign::AddPlatShareComm(int nPlatformIndex, int nShareCommIndex, BOOL bShareCommEnable)
{
	m_ShareCommInfoArray.AddPlatShareComm(nPlatformIndex, nShareCommIndex, bShareCommEnable);
}

ShareCommType vcBaseVisionAlign::GetShareCommType()
{
	return m_ShareCommInfoArray.GetShareCommType(GetSysPlatformIndex());
}

BOOL vcBaseVisionAlign::IsShareCommCurPlatform()
{
	return m_ShareCommInfoArray.GetCurCommPlatformIndex(GetSysPlatformIndex()) == GetSysPlatformIndex();
}

BOOL vcBaseVisionAlign::ShareCommNextPlatform()
{
	int nNextCommPlatformIndex = m_ShareCommInfoArray.GetNextCommPlatformIndex(GetSysPlatformIndex());

	m_ShareCommInfoArray.SetCurCommPlatformIndex(GetSysPlatformIndex(), nNextCommPlatformIndex);

	return TRUE;
}

BOOL vcBaseVisionAlign::IsShareCommPlatformParalle()
{
	if (eShareCommTar == GetShareCommType())
	{
		if (m_pVisionAlignOther != NULL && m_pVisionAlignOther->IsShareCommPlatformParalle())
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		if (m_pPlatformInfo == NULL)
		{
			return FALSE;
		}

		if (!m_pPlatformInfo->m_bShareCommEnable)
		{
			return FALSE;
		}

		return m_pPlatformInfo->m_bShareCommPlatformParallel;
	}

	return FALSE;
}

BOOL vcBaseVisionAlign::LockShareComm()
{
	// 如果是非并行的，不需要同步，直接返回
	if (!IsShareCommPlatformParalle())
	{	   
		return FALSE;
	}

	return m_ShareCommInfoArray.LockCurPlatformIndex(GetSysPlatformIndex());
}

BOOL vcBaseVisionAlign::UnlockShareComm()
{
	// 如果是非并行的，不需要同步，直接返回
	if (!IsShareCommPlatformParalle())
	{	   
		return FALSE;
	}

	return m_ShareCommInfoArray.UnlockCurPlatformIndex(GetSysPlatformIndex());
}

int vcBaseVisionAlign::GetSysPlatformIndex()
{
	if (NULL == m_pPlatformInfo)
	{	   
		return -1;
	}

	return m_pPlatformInfo->m_nPlatformIndex;
}


// 设置其他的视觉对位对象；
void vcBaseVisionAlign::SetVisionAlignOther(vcBaseVisionAlign *pVisionAlignOther)
{
	m_pVisionAlignOther = pVisionAlignOther;
}

// 获取其他的视觉对位对象；
vcBaseVisionAlign* vcBaseVisionAlign::GetVisionAlignOther()
{
	return m_pVisionAlignOther;
}


// 设置通信指针
void vcBaseVisionAlign::SetComm(vcComm *pComm)
{
	m_pComm = pComm;
}

// 获取通信指针
vcComm* vcBaseVisionAlign::GetComm()
{
	return m_pComm;
}

// 通信指令切换品种，加载新品种时向定位工具设置GuiDisplay和删除老品种时删除定位工具指针，从工作线程直接操作改为向主线程发送消息间接操作，避免上述两种操作和主界面连续采集状态刷新GUI并行调用冲突造成软件崩溃
BOOL vcBaseVisionAlign::SendMessageTimeOutUpdateChangeProductSetDisplay(int nProductIndex, int nToolType, int nTimeOut/* = 200*/)
{
	DWORD_PTR dwResult = 0; 
	LRESULT lr = SendMessageTimeout(m_pMainWnd->GetSafeHwnd(), WM_UPDATE_CHANGE_PRODUCT_SET_DISPLAY, nProductIndex, nToolType, SMTO_ABORTIFHUNG | SMTO_BLOCK, nTimeOut, &dwResult);
	if(lr)
	{
		return TRUE;	// 未超时返回成功
	}
	else
	{
		return FALSE;	// 超时返回成功
	}
}

void vcBaseVisionAlign::UpdateChangeProductSetDisplay(int nProductIndex, int nToolType)
{
	// 1:设置标定
	// 2:设置目标
	// 3:设置对象
	// 4:设置虚拟对象
	// 5:设置关联
	// 6:设置检测
	// 7:删除产品
	// 8:删除标定

	switch(nToolType)
	{
	case 1:	// 设置标定
		{
			CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
			if (pCalibData != NULL)
			{
				for (int j = 0; j < pCalibData->m_vvpCalibObjectSearchToolRepo.size(); j++)
				{
					for (int i=0; i<pCalibData->m_vvpCalibObjectSearchToolRepo[j].size(); i++)
					{
						if(pCalibData->m_vvpCalibObjectSearchToolRepo[j][i])
						{
							pCalibData->m_vvpCalibObjectSearchToolRepo[j][i]->SetDisplay(m_vpGuiDisplay[j]);
						}
					}
				}
			}
		}
		break;
	case 2:	// 设置目标
		{
			CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
			if (pProduct != NULL)
			{
				for (int j=0; j<pProduct->m_vvpAlnTargetSearchToolRepo.size(); j++)
				{
					for (int i=0; i<pProduct->m_vvpAlnTargetSearchToolRepo[j].size(); i++)
					{
						if(pProduct->m_vvpAlnTargetSearchToolRepo[j][i])
						{
							pProduct->m_vvpAlnTargetSearchToolRepo[j][i]->SetDisplay(m_vpGuiDisplay[j]);
						}
					}
				}
			}
		}
		break;
	case 3:	// 设置对象
		{
			CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
			if (pProduct != NULL)
			{
				for (int j=0; j<pProduct->m_vvpAlnObjectSearchToolRepo.size(); j++)
				{
					for (int i=0; i<pProduct->m_vvpAlnObjectSearchToolRepo[j].size(); i++)
					{
						if(pProduct->m_vvpAlnObjectSearchToolRepo[j][i])
						{
							pProduct->m_vvpAlnObjectSearchToolRepo[j][i]->SetDisplay(m_vpGuiDisplay[j]);
						}
					}
				}
			}
		}
		break;
	case 4:	// 设置虚拟对象
		{
			CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
			if (pProduct != NULL)
			{
				for (int j=0; j<pProduct->m_vvpAlnVirtualObjectSearchToolRepo.size(); j++)
				{
					for (int i=0; i<pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j].size(); i++)
					{
						if(pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j][i])
						{
							pProduct->m_vvpAlnVirtualObjectSearchToolRepo[j][i]->SetDisplay(m_vpGuiDisplay[j]);
						}
					}
				}
			}
		}
		break;
	case 5:	// 设置关联
		{
			CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
			if (pProduct != NULL)
			{
				for (int j=0; j<pProduct->m_vvpAlnCalibTargetSearchToolRepo.size(); j++)
				{
					for (int i=0; i<pProduct->m_vvpAlnCalibTargetSearchToolRepo[j].size(); i++)
					{
						if(pProduct->m_vvpAlnCalibTargetSearchToolRepo[j][i])
						{
							pProduct->m_vvpAlnCalibTargetSearchToolRepo[j][i]->SetDisplay(m_vpGuiDisplay[j]);
						}
					}
				}
			}
		}
		break;
	case 6:	// 设置检测
		{
			CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
			if (pProduct != NULL)
			{
				for (int j=0; j<pProduct->m_vvpAlnInspectSearchToolRepo.size(); j++)
				{
					for (int i=0; i<pProduct->m_vvpAlnInspectSearchToolRepo[j].size(); i++)
					{
						if(pProduct->m_vvpAlnInspectSearchToolRepo[j][i])
						{
							pProduct->m_vvpAlnInspectSearchToolRepo[j][i]->SetDisplay(m_vpGuiDisplay[j]);
						}
					}
				}
			}
		}
		break;
	case 7:	// 删除产品
		{
			CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
			if (pProduct != NULL)
			{
				pProduct->DeleteObjectSearchTools();
				pProduct->DeleteTargetSearchTools();
				pProduct->DeleteVirtualObjectSearchTools();
				pProduct->DeleteCalibTargetSearchTools();
				pProduct->DeleteInspectSearchTools();
			}
		}
		break;
	case 8:	// 删除标定
		{
			CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
			if (pCalibData != NULL)
			{
				pCalibData->DeleteObjectSearchTools();
			}
		}
		break;
	default:
		break;
	}
}

// 通信握手
BOOL  vcBaseVisionAlign::CommShakeHands()
{
	return FALSE;
}

void vcBaseVisionAlign::AddWarningInfo(CString strWarningType, CString strWarningMsg)
{
	EnterCriticalSection(&m_csResourceWarning);

	if (m_saWarningInfo.size() > MAXWARNINGCOUNT)
	{
		m_saWarningInfo.pop_front();
	}

	CString strSplitChar = _T("*");

	SYSTEMTIME tm;
	GetLocalTime(&tm);

	CString strTime;
	strTime.Format(_T("%02d/%02d %02d:%02d:%02d:%03d"), tm.wMonth,tm.wDay,tm.wHour,tm.wMinute,tm.wSecond,tm.wMilliseconds);
	m_saWarningInfo.push_back((strTime + strSplitChar + strWarningType + strSplitChar + strWarningMsg));	//用于显示

	VisionAlignLogRecord(m_strWarningInfoFilePath, _T("\n"), FALSE);
	VisionAlignLogRecord(m_strWarningInfoFilePath, (strSplitChar + strWarningType + strSplitChar + strWarningMsg));	//用于记录
	PostMessageUpdateAlignerWarningInfo();	//更新报警
	LeaveCriticalSection(&m_csResourceWarning);


}

void vcBaseVisionAlign::InitAlignerSizeInfo()
{
	if (m_pMainRunWnd!= NULL)
	{
		if ( ((CDlgVisionRun*)m_pMainRunWnd)->m_pDlgVisionRunProductInfo !=NULL)
		{
			m_AlignerObjectSizeInfo=  ((CDlgVisionRun*)m_pMainRunWnd)->m_pDlgVisionRunProductInfo->m_AlignerObjectSizeInfo;
			m_AlignerTargetSizeInfo =  ((CDlgVisionRun*)m_pMainRunWnd)->m_pDlgVisionRunProductInfo->m_AlignerTargetSizeInfo;
		}
	}
}

BOOL vcBaseVisionAlign::IsReadWriteAxisPosWithCmd()
{
	if(m_bSuspendWorkThread)
	{//工作线程挂起状态下轴位置不允许随指令读写(即关联等操作时必须通过通信获取轴位置)
		return FALSE;
	}
	CPlatformOptionInfo platformOptionInfo;
	if(GetPlatformOptionInfo(platformOptionInfo))
	{
		return platformOptionInfo.m_bReadWriteAxisPosWithCmd;
	}
	return FALSE;
}

void vcBaseVisionAlign::CalibrateParam_LogRecord(int nCalibPos)
{
	if(m_pVisionASMConfig == NULL) return;
	if(m_pVisionASMConfig->m_pMidPlatformInfo==NULL) return;

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;
	int nExCalibIndex = nCalibPos/m_pPlatformInfo->m_nPositionNum;

	CString strTemp = _T("");
	CString strInfo = _T("");



	// 1. 相机参数
	strTemp.Empty();
	strInfo.Empty();

	strTemp.Format(_T("相机参数\n"));
	strInfo += strTemp; 
	if (m_pVisionASMConfig->m_vImageRoi.at(nRemCalibPos).m_bMirrorHoriz == TRUE)
	{
		strTemp.Format(_T("......启用水平镜像; "));
		strInfo += strTemp;
	}
	else
	{
		strTemp.Format(_T("......不启用水平镜像; "));
		strInfo += strTemp;
	}

	if (m_pVisionASMConfig->m_vImageRoi.at(nRemCalibPos).m_bMirrorVert == TRUE)
	{
		strTemp.Format(_T("......启用垂直镜像; "));
		strInfo += strTemp;
	}
	else
	{
		strTemp.Format(_T("......不启用垂直镜像; "));
		strInfo += strTemp;
	}

	switch (m_pVisionASMConfig->m_vImageRoi.at(nRemCalibPos).m_nRotation)
	{
	case 0:
		{
			strTemp.Format(_T("......角度旋转为0°;\n"));
			strInfo += strTemp;
		}
		break;

	case 1:
		{
			strTemp.Format(_T("......角度旋转为90°;\n"));
			strInfo += strTemp;
		}
		break;

	case 2:
		{
			strTemp.Format(_T("......角度旋转为180°;\n"));
			strInfo += strTemp;
		}
		break;

	case 3:
		{
			strTemp.Format(_T("......角度旋转为270°;\n"));
			strInfo += strTemp;
		}
		break;

	default:
		{
			return;
		}
		break;
	}

	VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);	

	// 2. 平台参数
	strTemp.Empty();
	strInfo.Empty();

	strTemp.Format(_T("平台参数\n"));
	strInfo += strTemp; 
	switch(sysPlatformInfo.m_eMidPlatformType)
	{
	case ePlatformXYD:
		{
			strTemp.Format(_T("......平台类型: XYD平台\n"));
			strInfo += strTemp; 
		}
		break;

	case ePlatformX1X2Y:
		{
			strTemp.Format(_T("......平台类型: X1X2Y平台\n"));
			strInfo += strTemp; 
		}
		break;

	case ePlatformXY1Y2:
		{
			strTemp.Format(_T("......平台类型: XY1Y2平台\n"));
			strInfo += strTemp; 
		}
		break;

	case ePlatformXY:
		{
			strTemp.Format(_T("......平台类型: XY平台\n"));
			strInfo += strTemp; 
		}
		break;

	case ePlatformXD:
		{
			strTemp.Format(_T("......平台类型: XD平台\n"));
			strInfo += strTemp; 
		}
		break;

	case ePlatformYD:
		{
			strTemp.Format(_T("......平台类型: YD平台\n"));
			strInfo += strTemp; 
		}
		break;

	case ePlatformXYPD:
		{
			strTemp.Format(_T("......平台类型: XYPD平台\n"));
			strInfo += strTemp; 
		}
		break;

	default:
		{
			return;
		}
		break;
	}

	CPlatformXYDInfo* pPlatformInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pMidPlatformInfo);
	if (pPlatformInfo->m_nPlatformXCoordType == eDirectNegative)
	{
		strTemp.Format(_T("......X: 向左;  "));
		strInfo += strTemp; 
	} 
	else
	{
		strTemp.Format(_T("......X: 向右;  "));
		strInfo += strTemp; 
	}

	if (pPlatformInfo->m_nPlatformYCoordType == eDirectNegative)
	{
		strTemp.Format(_T("......Y: 向上;  "));
		strInfo += strTemp; 
	} 
	else
	{
		strTemp.Format(_T("......Y: 向下;  "));
		strInfo += strTemp; 
	}

	if (pPlatformInfo->m_nPlatformDCoordType == eDirectNegative)
	{
		strTemp.Format(_T("......D: 逆时针;\n"));
		strInfo += strTemp; 
	} 
	else
	{
		strTemp.Format(_T("......D: 顺时针;\n"));
		strInfo += strTemp; 
	}

	VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);	



	// 3. 标定参数
	strTemp.Empty();
	strInfo.Empty();

	strTemp.Format(_T("标定参数\n"));
	strInfo += strTemp; 
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nCalibRefineTime = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibRefineTime();

	double dCalibMoveX = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibMovement().GetPosX();
	double dCalibMoveY = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibMovement().GetPosY();
	double dCalibMoveD = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibMovement().GetAngle();	
	double dCalibRefineAngle = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibRefineMoveD();


	strTemp.Format(_T("......平台标定步长 X:%.3f ,Y:%.3f ,D:%.3f ,\n"),dCalibMoveX,dCalibMoveY,dCalibMoveD);
	strInfo += strTemp;

	strTemp.Format(_T("......求精次数:%d\n"),nCalibRefineTime);
	strInfo += strTemp;

	strTemp.Format(_T("......求精角度:%.3f\n"),dCalibRefineAngle);
	strInfo += strTemp;

	VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);

}

void vcBaseVisionAlign::CalibrateResult_LogRecord(int nCalibPos, int nMarkType/*, std::vector<CMarkImagePos*>vpMarkImagePos*/)
{
	if(m_pVisionASMConfig ==NULL) return;
	if(m_pVisionASMConfig->m_pMidPlatformInfo==NULL) return;

	int nRemCalibPos = nCalibPos%GetPosNum();

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	double dCalibMoveX = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibMovement().GetPosX();
	double dCalibMoveY = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibMovement().GetPosY();

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CString strTemp = _T("");
	CString strInfo = _T("");

	strTemp.Format(_T("图像坐标分析:\n"));
	strInfo += strTemp;

	// 所需分析距离值初始化
	double MaxDistance = -9999;
	vector<double> distance;	
	sc2Vector scMoveRangeImageDis = sc2Vector(0, 0);
	vector<CString> vstrAnalysisResult;

	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();


	// 判断不同平台的处理方式
	switch(sysPlatformInfo.m_eMidPlatformType)
	{
	case ePlatformXYD:
	case ePlatformXY1Y2:
	case ePlatformX1X2Y:
		{
			// 1. 运用向量叉乘，判断九宫格顺逆
			{

				// 				distance.clear();
				// 				distance.push_back((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY());

				double z = distance[0]*distance[3] - distance[1]*distance[2];
				if (z<0)
				{
					strTemp.Format(_T("......九宫格顺逆时针分析结果: 逆时针走位,正确; \n"));
					vstrAnalysisResult.push_back(strTemp);	// 0
				} 
				else
				{
					strTemp.Format(_T("......九宫格顺逆时针分析结果: 顺时针走位,错误; \n"));
					vstrAnalysisResult.push_back(strTemp);
				}

				strInfo += strTemp;
			}

			// 2. 运用向量叉乘，判断角度旋转顺逆
			{

				// 				distance.clear();
				// 				distance.push_back((vpMarkImagePos.at(10)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(10)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back((vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(9)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(9)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[10].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[10].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosY());

				double z = distance[0]*distance[3] - distance[1]*distance[2];
				if (z>0)
				{
					strTemp.Format(_T("......角度顺逆时针分析结果: 先顺时针旋转,正确; \n"));
					vstrAnalysisResult.push_back(strTemp);	// 1
				} 
				else
				{
					strTemp.Format(_T("......角度顺逆时针分析结果: 先逆时针旋转,错误; \n"));
					vstrAnalysisResult.push_back(strTemp);
				}
				strInfo += strTemp;
			}

			// 3. X图像偏差
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosX));
				distance.clear();
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosX() ) );
				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......X方向移动图像距离: DisX34: %.2f; DisX45: %.2f; DisX78: %.2f; DisX81: %.2f; DisX02: %.2f; DisX06: %.2f; X方向最大图像距离差值: %.2f;\n"),
					distance[0],distance[1],distance[2],distance[3],distance[4],distance[5],MaxDistance);
				strInfo += strTemp;

				strTemp.Format(_T("......X方向最大图像距离差值%.2f;\n"),MaxDistance);
				vstrAnalysisResult.push_back(strTemp);	// 2
			}

			// 4. Y图像偏差
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosY() ) );
				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......Y方向移动图像距离: DisY12: %.2f; DisY23: %.2f; DisY56: %.2f; DisY67: %.2f; DisY04: %.2f; DisY08: %.2f; Y方向最大图像距离差值: %.2f;\n"),
					distance[0],distance[1],distance[2],distance[3],distance[4],distance[5],MaxDistance);
				strInfo += strTemp;

				strTemp.Format(_T("......Y方向最大图像距离差值%.2f;\n"),MaxDistance);
				vstrAnalysisResult.push_back(strTemp);	// 3
			}

			// 5. XY图像移动距离
			{

				// 				distance.clear();
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosY,2)));
				distance.clear();
				double dDisX_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX();
				double dDisY_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T1, 2) + pow(dDisY_0T1, 2) ));

				double dDisX_0T3 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX();
				double dDisY_0T3 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T3, 2) + pow(dDisY_0T3, 2) ));

				double dDisX_0T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX();
				double dDisY_0T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T5, 2) + pow(dDisY_0T5, 2) ));

				double dDisX_0T7 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosX();
				double dDisY_0T7 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T7, 2) + pow(dDisY_0T7, 2) ));

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......XY方向移动图像距离: DisXY01: %.2f; DisXY03: %.2f; DisXY05: %.2f; DisXY07: %.2f; XY方向最大图像距离差值: %.2f;\n"),
					distance[0],distance[1],distance[2],distance[3],MaxDistance);

				strInfo += strTemp;
			}

			// 6. D方向移动图像距离
			{

				// 				distance.clear();
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(10)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(10)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(9)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(9)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosY,2)));
				distance.clear();
				double dDisX_10T11 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[10].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX();
				double dDisY_10T11 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[10].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY();
				distance.push_back(sqrt( pow(dDisX_10T11, 2) + pow(dDisY_10T11, 2) ));

				double dDisX_09T11 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX();
				double dDisY_09T11 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY();
				distance.push_back(sqrt( pow(dDisX_09T11, 2) + pow(dDisY_09T11, 2) ));

				strTemp.Format(_T("......D方向移动图像距离: DisD1011: %.2f; DisD911: %.2f; D方向最大图像距离差值: %.2f;\n"),distance[0],distance[1],fabs(distance[0]-distance[1]));
				strInfo += strTemp;

				strTemp.Format(_T("......D方向最大图像距离差值%.2f;\n"),fabs(distance[0]-distance[1]));
				vstrAnalysisResult.push_back(strTemp);	//  4
			}

			// 7. 起点终点图像坐标差值
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(11)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY());

				strTemp.Format(_T("......D起点与终点图像坐标差值: X差值: %.2f; Y差值: %.2f; \n"),distance[0],distance[1]);
				strInfo += strTemp;
			}

			// 8. 比例对应分析结果
			{

				// 				distance.clear();
				// 				distance.push_back(sqrt(pow((vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX),2) + pow((vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY),2)));
				// 				distance.push_back(sqrt(pow((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX),2) + pow((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY),2)));
				distance.clear();
				double dDisX_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
				double dDisY_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T2, 2) + pow(dDisY_0T2, 2) ));

				double dDisX_1T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
				double dDisY_1T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
				distance.push_back(sqrt( pow(dDisX_1T2, 2) + pow(dDisY_1T2, 2) ));

				if (distance[1]!=0)
				{
					distance.push_back(distance[0]/distance[1]);

					strTemp.Format(_T("......比例对应: 图像距离比值02/12: %.2f; 标定步长比值X/Y: %.2f; 标定步长比例与图像比例差值: %.2f;\n"),distance[2], dCalibMoveX/dCalibMoveY, fabs(dCalibMoveX/dCalibMoveY - distance[2]));
					strInfo += strTemp;

					strTemp.Format(_T("......标定步长比例与图像比例差值%.2f;\n"),fabs(dCalibMoveX/dCalibMoveY - distance[2]));
					vstrAnalysisResult.push_back(strTemp);	// 5
				}
				else
				{
					strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
					strInfo += strTemp;

					strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
					vstrAnalysisResult.push_back(strTemp);
				}
			}

			// 9. 标定移动图像最大范围比较
			{

				// 				distance.clear();
				// 				for (int i=0;i<vpMarkImagePos.size() && i<9;i++)
				// 				{
				// 					distance.push_back(vpMarkImagePos.at(i)->GetMarkImagePos(0).m_dPosX);
				// 				}
				// 				MaxDistance = *max_element(distance.begin(),distance.end()) - *min_element(distance.begin(),distance.end());
				// 				scMoveRangeImageDis.SetX(MaxDistance);
				// 
				// 				distance.clear();
				// 				for (int i=0;i<vpMarkImagePos.size() && i<9;i++)
				// 				{
				// 					distance.push_back(vpMarkImagePos.at(i)->GetMarkImagePos(0).m_dPosY);
				// 				}
				// 				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
				// 				scMoveRangeImageDis.SetY(MaxDistance);

				distance.clear();
				for (int i = 0; i < 9; i++)
				{
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[i].GetPosX());
				}
				MaxDistance = *max_element(distance.begin(),distance.end()) - *min_element(distance.begin(),distance.end());
				scMoveRangeImageDis.SetX(MaxDistance);

				distance.clear();
				for (int i = 0; i < 9; i++)
				{
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[i].GetPosY());
				}
				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
				scMoveRangeImageDis.SetY(MaxDistance);
			}
		}
		break;
	case ePlatformXD:
		{
			// 1. 运用向量点乘，判断XD标定走位是否正确
			{

				// 				distance.clear();
				// 				distance.push_back((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX());

				if (distance[0] > 0 && distance[1] < 0)
				{
					strTemp.Format(_T("......XD标定走位分析结果: 先向右后向左走位,正确; \n"));
					vstrAnalysisResult.push_back(strTemp);	// 0
				} 
				else
				{
					strTemp.Format(_T("......XD标定走位分析结果: 异常走位,错误; \n"));
					vstrAnalysisResult.push_back(strTemp);
				}
				strInfo += strTemp;
			}

			// 2. 运用向量叉乘，判断角度旋转顺逆
			{

				// 				distance.clear();
				// 				distance.push_back((vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back((vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY());

				double z = distance[0]*distance[3] - distance[1]*distance[2];
				if (z>0)
				{
					strTemp.Format(_T("......角度顺逆时针分析结果: 先顺时针旋转,正确; \n"));
					vstrAnalysisResult.push_back(strTemp);	// 1
				} 
				else
				{
					strTemp.Format(_T("......角度顺逆时针分析结果: 先逆时针旋转,错误; \n"));
					vstrAnalysisResult.push_back(strTemp);
				}
				strInfo += strTemp;
			}

			// 3. X图像偏差
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX));
				distance.clear();
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() ) );

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......X方向移动图像距离: DisX01: %.2f; DisX02: %.2f; X方向最大图像距离差值: %.2f;\n"), distance[0], distance[1], MaxDistance);
				strInfo += strTemp;

				strTemp.Format(_T("......X方向最大图像距离差值%.2f;\n"),MaxDistance);
				vstrAnalysisResult.push_back(strTemp);	// 2
			}

			// 4. Y图像偏差
			{

				//...对XD平台来说，Y方向图像偏差无意义,为格式统一，用水平方向两点
				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() ) );

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......Y方向移动图像距离: DisY01: %.2f; DisY02: %.2f; Y方向最大图像距离差值: %.2f;\n"), distance[0], distance[1], MaxDistance);
				strInfo += strTemp;

				strTemp.Format(_T("......Y方向最大图像距离差值%.2f;\n"), MaxDistance);
				vstrAnalysisResult.push_back(strTemp);	// 3
			}

			// 5. XY图像移动距离
			{				
				//...对XD平台来说，此值没有，为格式统一，用01,02
				// 				distance.clear();
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY,2)));
				distance.clear();
				double dDisX_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX();
				double dDisY_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T1, 2) + pow(dDisY_0T1, 2) ));

				double dDisX_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
				double dDisY_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T2, 2) + pow(dDisY_0T2, 2) ));

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......XY方向移动图像距离: DisXY01: %.2f; DisXY02: %.2f; XY方向最大图像距离差值: %.2f;\n"), distance[0], distance[1], MaxDistance);
				strInfo += strTemp;
			}

			// 6. D方向移动图像距离
			{

				// 				distance.clear();
				// 				distance.push_back(sqrt(((vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX))*(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX))
				// 					+ (vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY)*(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(sqrt(((vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX))*(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX))
				// 					+ (vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY)*(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY));
				// 
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY,2)));

				distance.clear();
				double dDisX_3T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX();
				double dDisY_3T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY();
				distance.push_back(sqrt( pow(dDisX_3T5, 2) + pow(dDisY_3T5, 2) ));

				double dDisX_4T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX();
				double dDisY_4T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY();
				distance.push_back(sqrt( pow(dDisX_4T5, 2) + pow(dDisY_4T5, 2) ));

				strTemp.Format(_T("......D方向移动图像距离: DisD35: %.2f; DisD45: %.2f; D方向最大图像距离差值: %.2f;\n"),distance[0],distance[1],fabs(distance[0]-distance[1]));
				strInfo += strTemp;

				strTemp.Format(_T("......D方向最大图像距离差值%.2f;\n"),fabs(distance[0]-distance[1]));
				vstrAnalysisResult.push_back(strTemp);	// 4
			}

			// 7. 起点终点图像坐标差值
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY());

				strTemp.Format(_T("......D起点与终点图像坐标差值: X差值: %.2f; Y差值: %.2f; \n"),distance[0],distance[1]);
				strInfo += strTemp;
			}

			// 8. 比例对应分析结果
			{

				//...没有Y向移动，此值为1
				// 				distance.clear();
				// 				distance.push_back(1);
				// 				distance.push_back(1);
				distance.clear();
				double dDisX_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
				double dDisY_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T2, 2) + pow(dDisY_0T2, 2) ));

				double dDisX_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX();
				double dDisY_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T1, 2) + pow(dDisY_0T1, 2) ));

				if (distance[1]!=0)
				{
					distance.push_back(distance[0]/distance[1]);

					strTemp.Format(_T("......比例对应: 图像距离比值02/01: %.2f; 标定步长比值X/Y: %.2f; 标定步长比例与图像比例差值: %.2f;\n"),distance[2],dCalibMoveX/dCalibMoveX,fabs(dCalibMoveX/dCalibMoveX - distance[2]));
					strInfo += strTemp;

					strTemp.Format(_T("......标定步长比例与图像比例差值%.2f;\n"),fabs(dCalibMoveX/dCalibMoveX - distance[2]));
					vstrAnalysisResult.push_back(strTemp);	// 5
				}
				else
				{
					strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
					strInfo += strTemp;

					strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
					vstrAnalysisResult.push_back(strTemp);
				}
			}

			// 9. 标定移动最大范围比较
			{

				// 				distance.clear();
				// 				for (int i=0;i<vpMarkImagePos.size() && i<3;i++)
				// 				{
				// 					distance.push_back(vpMarkImagePos.at(i)->GetMarkImagePos(0).m_dPosX);
				// 				}
				// 
				// 				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
				// 				scMoveRangeImageDis.SetX(MaxDistance);
				// 				scMoveRangeImageDis.SetY(MaxDistance);

				distance.clear();
				for (int i = 0; i < 3; i++)
				{
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[i].GetPosX());
				}
				MaxDistance = *max_element(distance.begin(),distance.end()) - *min_element(distance.begin(),distance.end());
				scMoveRangeImageDis.SetX(MaxDistance);
				scMoveRangeImageDis.SetY(MaxDistance);
			}
		}
		break;

	case ePlatformYD:
		{
			// 1. 运用向量点乘，判断XD标定走位是否正确
			{

				// 				distance.clear();
				// 				distance.push_back((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX());

				if (distance[0] < 0 && distance[1] > 0)
				{
					strTemp.Format(_T("......YD标定走位分析结果: 先向下后向上走位,正确; \n"));
					vstrAnalysisResult.push_back(strTemp);	// 0
				} 
				else
				{
					strTemp.Format(_T("......YD标定走位分析结果: 异常走位,错误; \n"));
					vstrAnalysisResult.push_back(strTemp);
				}
				strInfo += strTemp;
			}

			// 2. 运用向量叉乘，判断角度旋转顺逆
			{

				// 				distance.clear();
				// 				distance.push_back((vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back((vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY());

				double z = distance[0]*distance[3] - distance[1]*distance[2];
				if (z>0)
				{
					strTemp.Format(_T("......角度顺逆时针分析结果: 先顺时针旋转,正确; \n"));
					vstrAnalysisResult.push_back(strTemp);	// 1
				} 
				else
				{
					strTemp.Format(_T("......角度顺逆时针分析结果: 先逆时针旋转,错误; \n"));
					vstrAnalysisResult.push_back(strTemp);
				}
				strInfo += strTemp;
			}

			// 3. X图像偏差
			{

				//...对YD平台来说，Y方向图像偏差无意义,为格式统一，用竖直方向两点
				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX));
				distance.clear();
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() ) );

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......X方向移动图像距离: DisX01: %.2f; DisX02: %.2f; X方向最大图像距离差值: %.2f;\n"), distance[0], distance[1], MaxDistance);
				strInfo += strTemp;

				strTemp.Format(_T("......X方向最大图像距离差值%.2f;\n"),MaxDistance);
				vstrAnalysisResult.push_back(strTemp);	// 2
			}

			// 4. Y图像偏差
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() ) );

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......Y方向移动图像距离: DisY01: %.2f; DisY02: %.2f; Y方向最大图像距离差值: %.2f;\n"), distance[0], distance[1], MaxDistance);
				strInfo += strTemp;

				strTemp.Format(_T("......Y方向最大图像距离差值%.2f;\n"), MaxDistance);
				vstrAnalysisResult.push_back(strTemp);	// 3
			}

			// 5. XY图像移动距离
			{

				//...对YD平台来说，此值没有，为格式统一，用01,02
				// 				distance.clear();
				// 				distance.push_back(sqrt(((vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX))*(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX))
				// 					+ (vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY)*(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(sqrt(((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX))*(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX))
				// 					+ (vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY)*(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY));

				double dDisX_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX();
				double dDisY_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T1, 2) + pow(dDisY_0T1, 2) ));

				double dDisX_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
				double dDisY_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T2, 2) + pow(dDisY_0T2, 2) ));

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......XY方向移动图像距离: DisXY01: %.2f; DisXY02: %.2f; XY方向最大图像距离差值: %.2f;\n"), distance[0], distance[1], MaxDistance);
				strInfo += strTemp;
			}

			// 6. D方向移动图像距离
			{

				// 				distance.clear();
				// 				distance.push_back(sqrt(((vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX))*(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX))
				// 					+ (vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY)*(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(sqrt(((vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX))*(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX))
				// 					+ (vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY)*(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY));

				distance.clear();
				double dDisX_3T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX();
				double dDisY_3T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY();
				distance.push_back(sqrt( pow(dDisX_3T5, 2) + pow(dDisY_3T5, 2) ));

				double dDisX_4T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX();
				double dDisY_4T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY();
				distance.push_back(sqrt( pow(dDisX_4T5, 2) + pow(dDisY_4T5, 2) ));

				strTemp.Format(_T("......D方向移动图像距离: DisD35: %.2f; DisD45: %.2f; D方向最大图像距离差值: %.2f;\n"),distance[0],distance[1],fabs(distance[0]-distance[1]));
				strInfo += strTemp;

				strTemp.Format(_T("......D方向最大图像距离差值%.2f;\n"),fabs(distance[0]-distance[1]));
				vstrAnalysisResult.push_back(strTemp);	// 4
			}

			// 7. 起点终点图像坐标差值
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY());


				strTemp.Format(_T("......D起点与终点图像坐标差值: X差值: %.2f; Y差值: %.2f; \n"),distance[0],distance[1]);
				strInfo += strTemp;
			}

			// 8. 比例对应分析结果
			{

				//...没有X向移动，此值为1
				// 				distance.clear();
				// 				distance.push_back(1);
				// 				distance.push_back(1);
				distance.clear();
				double dDisX_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
				double dDisY_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T2, 2) + pow(dDisY_0T2, 2) ));

				double dDisX_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX();
				double dDisY_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T1, 2) + pow(dDisY_0T1, 2) ));

				if (distance[1]!=0)
				{
					distance.push_back(distance[0]/distance[1]);

					strTemp.Format(_T("......比例对应: 图像距离比值02/01: %.2f; 标定步长比值X/Y: %.2f; 标定步长比例与图像比例差值: %.2f;\n"),distance[2],dCalibMoveY/dCalibMoveY,fabs(dCalibMoveY/dCalibMoveY - distance[2]));
					strInfo += strTemp;

					strTemp.Format(_T("......标定步长比例与图像比例差值%.2f;\n"),fabs(dCalibMoveY/dCalibMoveY - distance[2]));
					vstrAnalysisResult.push_back(strTemp);	// 5
				}
				else
				{
					strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
					strInfo += strTemp;

					strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
					vstrAnalysisResult.push_back(strTemp);
				}
			}

			// 9. 标定移动最大范围比较
			{

				// 				distance.clear();
				// 				for (int i=0;i<vpMarkImagePos.size() && i<3;i++)
				// 				{
				// 					distance.push_back(vpMarkImagePos.at(i)->GetMarkImagePos(0).m_dPosY);
				// 				}
				// 
				// 				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
				// 
				// 				scMoveRangeImageDis.SetX(MaxDistance);
				// 				scMoveRangeImageDis.SetY(MaxDistance);

				distance.clear();
				for (int i = 0; i < 3; i++)
				{
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[i].GetPosY());
				}
				MaxDistance = *max_element(distance.begin(),distance.end()) - *min_element(distance.begin(),distance.end());
				scMoveRangeImageDis.SetX(MaxDistance);
				scMoveRangeImageDis.SetY(MaxDistance);
			}
		}
		break;

	case ePlatformXY:
		{
			// 1. 运用向量叉乘，判断九宫格顺逆
			{

				// 				distance.clear();
				// 				distance.push_back((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY());

				double z = distance[0]*distance[3] - distance[1]*distance[2];
				if (z<0)
				{
					strTemp.Format(_T("......九宫格顺逆时针分析结果: 逆时针走位,正确; \n"));
					vstrAnalysisResult.push_back(strTemp);	// 0
				} 
				else
				{
					strTemp.Format(_T("......九宫格顺逆时针分析结果: 顺时针走位,错误; \n"));
					vstrAnalysisResult.push_back(strTemp);
				}
				strInfo += strTemp;
			}

			// 2. 无角度顺逆
			{

				distance.clear();
				strTemp.Format(_T("......角度顺逆时针分析结果: 无角度; \n"));
				vstrAnalysisResult.push_back(strTemp);	// 1
			}

			// 3. X图像偏差
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosX));
				distance.clear();
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosX() ) );

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......X方向移动图像距离: DisX34: %.2f; DisX45: %.2f; DisX78: %.2f; DisX81: %.2f; DisX02: %.2f; DisX06: %.2f; X方向最大图像距离差值: %.2f;\n"),
					distance[0],distance[1],distance[2],distance[3],distance[4],distance[5],MaxDistance);
				strInfo += strTemp;

				strTemp.Format(_T("......X方向最大图像距离差值%.2f;\n"),MaxDistance);
				vstrAnalysisResult.push_back(strTemp);	// 2
			}

			// 4. Y图像偏差
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY));
				// 				distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosY() ) );
				distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosY()) );

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......Y方向移动图像距离: DisY12: %.2f; DisY23: %.2f; DisY56: %.2f; DisY67: %.2f; DisY04: %.2f; DisY08: %.2f; Y方向最大图像距离差值: %.2f;\n"),
					distance[0],distance[1],distance[2],distance[3],distance[4],distance[5],MaxDistance);
				strInfo += strTemp;

				strTemp.Format(_T("......Y方向最大图像距离差值%.2f;\n"),MaxDistance);
				vstrAnalysisResult.push_back(strTemp);	// 3
			}

			// 5. XY图像移动距离
			{

				// 				distance.clear();
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY,2)));
				// 				distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosY,2)));
				distance.clear();
				double dDisX_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX();
				double dDisY_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T1, 2) + pow(dDisY_0T1, 2) ));

				double dDisX_0T3 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX();
				double dDisY_0T3 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T3, 2) + pow(dDisY_0T3, 2) ));

				double dDisX_0T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX();
				double dDisY_0T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T5, 2) + pow(dDisY_0T5, 2) ));

				double dDisX_0T7 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosX();
				double dDisY_0T7 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T7, 2) + pow(dDisY_0T7, 2) ));

				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

				strTemp.Format(_T("......XY方向移动图像距离: DisXY01: %.2f; DisXY03: %.2f; DisXY05: %.2f; DisXY07: %.2f; XY方向最大图像移动差值: %.2f;\n"),
					distance[0],distance[1],distance[2],distance[3],MaxDistance);
				strInfo += strTemp;
			}

			// 6. D方向移动图像距离
			{			
				distance.clear();
				strTemp.Format(_T("......D方向移动图像距离: 无;\n"));
				strInfo += strTemp;

				vstrAnalysisResult.push_back(strTemp);	// 4
			}

			// 7. 起点终点图像坐标差值
			{

				// 				distance.clear();
				// 				distance.push_back(fabs(vpMarkImagePos.at(9)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
				// 				distance.push_back(fabs(vpMarkImagePos.at(9)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
				distance.clear();
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
				distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY());

				strTemp.Format(_T("......D起点与终点图像坐标差值: X差值: %.2f; Y差值: %.2f; \n"),distance[0],distance[1]);
				strInfo += strTemp;
			}

			// 8. 比例对应分析结果
			{

				// 				distance.clear();
				// 				distance.push_back(sqrt(pow((vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX),2) + pow((vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY),2)));
				// 				distance.push_back(sqrt(pow((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX),2) + pow((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY),2)));
				distance.clear();
				double dDisX_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
				double dDisY_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
				distance.push_back(sqrt( pow(dDisX_0T2, 2) + pow(dDisY_0T2, 2) ));

				double dDisX_1T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
				double dDisY_1T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
				distance.push_back(sqrt( pow(dDisX_1T2, 2) + pow(dDisY_1T2, 2) ));

				if (distance[1]!=0)
				{
					distance.push_back(distance[0]/distance[1]);

					strTemp.Format(_T("......比例对应: 图像距离比值02/12: %.2f; 标定步长比值X/Y: %.2f; 标定步长比例与图像比例差值: %.2f;\n"),distance[2],dCalibMoveX/dCalibMoveY,fabs(dCalibMoveX/dCalibMoveY - distance[2]));
					strInfo += strTemp;

					strTemp.Format(_T("......标定步长比例与图像比例差值%.2f;\n"),fabs(dCalibMoveX/dCalibMoveY - distance[2]));
					vstrAnalysisResult.push_back(strTemp);	// 5
				}
				else
				{
					strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
					strInfo += strTemp;

					strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
					vstrAnalysisResult.push_back(strTemp);
				}
			}

			// 9. 标定移动最大范围比较
			{

				// 				distance.clear();
				// 				for (int i=0;i<vpMarkImagePos.size();i++)
				// 				{
				// 					distance.push_back(vpMarkImagePos.at(i)->GetMarkImagePos(0).m_dPosX);
				// 				}
				// 				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
				// 				scMoveRangeImageDis.SetX(MaxDistance);
				// 
				// 				distance.clear();
				// 				for (int i=0;i<vpMarkImagePos.size();i++)
				// 				{
				// 					distance.push_back(vpMarkImagePos.at(i)->GetMarkImagePos(0).m_dPosY);
				// 				}
				// 
				// 				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
				// 				scMoveRangeImageDis.SetY(MaxDistance);

				distance.clear();
				for (int i = 0; i < 9; i++)
				{
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[i].GetPosX());
				}
				MaxDistance = *max_element(distance.begin(),distance.end()) - *min_element(distance.begin(),distance.end());
				scMoveRangeImageDis.SetX(MaxDistance);

				distance.clear();
				for (int i = 0; i < 9; i++)
				{
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[i].GetPosY());
				}
				MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
				scMoveRangeImageDis.SetY(MaxDistance);
			}

		}
		break;

	case ePlatformXYPD:
		{
			// 标定XY
			if (nMarkType == 0)
			{
				strTemp.Format(_T("平台标定XY时图像坐标分析:\n"));
				strInfo += strTemp;

				// 1. 运用向量叉乘，判断九宫格顺逆
				{

					// 					distance.clear();
					// 					distance.push_back((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
					// 					distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY));
					distance.clear();
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY());
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX());
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY());

					double z = distance[0]*distance[3] - distance[1]*distance[2];
					if (z<0)
					{
						strTemp.Format(_T("......九宫格顺逆时针分析结果: 逆时针走位,正确; \n"));
						vstrAnalysisResult.push_back(strTemp);	// 0
					} 
					else
					{
						strTemp.Format(_T("......九宫格顺逆时针分析结果: 顺时针走位,错误; \n"));
						vstrAnalysisResult.push_back(strTemp);
					}
					strInfo += strTemp;
				}

				// 2. 无角度顺逆
				{

					distance.clear();
					strTemp.Format(_T("......角度顺逆时针分析结果: 无角度; \n"));
					strInfo += strTemp;
					vstrAnalysisResult.push_back(strTemp);	// 1
				}

				// 3. X图像偏差
				{

					// 					distance.clear();
					// 					distance.push_back(fabs(vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back(fabs(vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back(fabs(vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back(fabs(vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosX));
					distance.clear();
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosX() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosX() ) );

					MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

					strTemp.Format(_T("......X方向移动图像距离: DisX34: %.2f; DisX45: %.2f; DisX78: %.2f; DisX81: %.2f; DisX02: %.2f; DisX06: %.2f; X方向最大图像距离差值: %.2f;\n"),
						distance[0],distance[1],distance[2],distance[3],distance[4],distance[5],MaxDistance);
					strInfo += strTemp;

					strTemp.Format(_T("......X方向最大图像距离差值%.2f;\n"),MaxDistance);
					vstrAnalysisResult.push_back(strTemp);	// 2
				}

				// 4. Y图像偏差
				{

					// 					distance.clear();
					// 					distance.push_back(fabs(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY));
					// 					distance.push_back(fabs(vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY));
					// 					distance.push_back(fabs(vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosY));
					// 					distance.push_back(fabs(vpMarkImagePos.at(6)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosY));
					// 					distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(4)->GetMarkImagePos(0).m_dPosY));
					// 					distance.push_back(fabs(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(8)->GetMarkImagePos(0).m_dPosY));
					distance.clear();
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosY() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[6].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosY() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[4].GetPosY() ) );
					distance.push_back( fabs( vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[8].GetPosY() ) );

					MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

					strTemp.Format(_T("......Y方向移动图像距离: DisY12: %.2f; DisY23: %.2f; DisY56: %.2f; DisY67: %.2f; DisY04: %.2f; DisY08: %.2f; Y方向最大图像距离差值: %.2f;\n"),
						distance[0],distance[1],distance[2],distance[3],distance[4],distance[5],MaxDistance);
					strInfo += strTemp;

					strTemp.Format(_T("......Y方向最大图像距离差值%.2f;\n"),MaxDistance);
					vstrAnalysisResult.push_back(strTemp);	// 3
				}

				// 5. XY图像移动距离
				{				
					// 					distance.clear();
					// 					distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY,2)));
					// 					distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY,2)));
					// 					distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(5)->GetMarkImagePos(0).m_dPosY,2)));
					// 					distance.push_back(sqrt(pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(7)->GetMarkImagePos(0).m_dPosY,2)));
					distance.clear();
					double dDisX_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX();
					double dDisY_0T1 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY();
					distance.push_back(sqrt( pow(dDisX_0T1, 2) + pow(dDisY_0T1, 2) ));

					double dDisX_0T3 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosX();
					double dDisY_0T3 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[3].GetPosY();
					distance.push_back(sqrt( pow(dDisX_0T3, 2) + pow(dDisY_0T3, 2) ));

					double dDisX_0T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosX();
					double dDisY_0T5 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[5].GetPosY();
					distance.push_back(sqrt( pow(dDisX_0T5, 2) + pow(dDisY_0T5, 2) ));

					double dDisX_0T7 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosX();
					double dDisY_0T7 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[7].GetPosY();
					distance.push_back(sqrt( pow(dDisX_0T7, 2) + pow(dDisY_0T7, 2) ));

					MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());

					strTemp.Format(_T("......XY方向移动图像距离: DisXY01: %.2f; DisXY03: %.2f; DisXY05: %.2f; DisXY07: %.2f; XY方向最大图像距离差值: %.2f;\n"),
						distance[0],distance[1],distance[2],distance[3],MaxDistance);

					strInfo += strTemp;
				}

				// 6. D方向移动图像距离
				{

					distance.clear();
					strTemp.Format(_T("......D方向移动图像距离: 无;\n"));
					strInfo += strTemp;
					vstrAnalysisResult.push_back(strTemp);	// 4
				}

				// 7. 起点终点图像坐标差值
				{

					// 					distance.clear();
					// 					distance.push_back(fabs(vpMarkImagePos.at(9)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back(fabs(vpMarkImagePos.at(9)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY));
					distance.clear();
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX());
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY());

					strTemp.Format(_T("......D起点与终点图像坐标差值: X差值: %.2f; Y差值: %.2f; \n"),distance[0],distance[1]);
					strInfo += strTemp;
				}

				// 8. 比例对应分析结果
				{

					// 					distance.clear();
					// 					distance.push_back(sqrt(pow((vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX),2) + pow((vpMarkImagePos.at(0)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY),2)));
					// 					distance.push_back(sqrt(pow((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX),2) + pow((vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY),2)));
					distance.clear();
					double dDisX_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
					double dDisY_0T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[0].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
					distance.push_back(sqrt( pow(dDisX_0T2, 2) + pow(dDisY_0T2, 2) ));

					double dDisX_1T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosX();
					double dDisY_1T2 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[1].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[2].GetPosY();
					distance.push_back(sqrt( pow(dDisX_1T2, 2) + pow(dDisY_1T2, 2) ));

					if (distance[1]!=0)
					{
						distance.push_back(distance[0]/distance[1]);
						strTemp.Format(_T("......比例对应: 图像距离比值02/12: %.2f; 标定步长比值X/Y: %.2f; 标定步长比例与图像比例差值: %.2f;\n"),distance[2],dCalibMoveX/dCalibMoveY,fabs(dCalibMoveX/dCalibMoveY - distance[2]));
						strInfo += strTemp;

						strTemp.Format(_T("标定步长比例与图像比例差值%.2f;\n"),fabs(dCalibMoveX/dCalibMoveY - distance[2]));
						vstrAnalysisResult.push_back(strTemp);
					}
					else
					{
						strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
						strInfo += strTemp;

						strTemp.Format(_T("......从1位置移动到2位置移动范围过小;\n"));
						vstrAnalysisResult.push_back(strTemp);
					}
				}

				// 9. 标定移动最大范围比较
				{

					// 					distance.clear();
					// 					for (int i=0;i<vpMarkImagePos.size();i++)
					// 					{
					// 						distance.push_back(vpMarkImagePos.at(i)->GetMarkImagePos(0).m_dPosX);
					// 					}
					// 					MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
					// 					scMoveRangeImageDis.SetX(MaxDistance);
					// 
					// 					distance.clear();
					// 					for (int i=0;i<vpMarkImagePos.size();i++)
					// 					{
					// 						distance.push_back(vpMarkImagePos.at(i)->GetMarkImagePos(0).m_dPosY);
					// 					}
					// 					MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
					// 					scMoveRangeImageDis.SetY(MaxDistance);

					distance.clear();
					for (int i = 0; i < 9; i++)
					{
						distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[i].GetPosX());
					}
					MaxDistance = *max_element(distance.begin(),distance.end()) - *min_element(distance.begin(),distance.end());
					scMoveRangeImageDis.SetX(MaxDistance);

					distance.clear();
					for (int i = 0; i < 9; i++)
					{
						distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[i].GetPosY());
					}
					MaxDistance = *max_element(distance.begin(),distance.end())-*min_element(distance.begin(),distance.end());
					scMoveRangeImageDis.SetY(MaxDistance);
				}

			}
			else if(nMarkType == 1)
			{
				strTemp.Format(_T("平台标定D时图像坐标分析:\n"));
				strInfo += strTemp;

				// 1. 运用向量叉乘，判断角度旋转顺逆
				{

					// 					distance.clear();
					// 					distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back((vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY));
					// 					distance.push_back((vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX));
					// 					distance.push_back((vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY));
					distance.clear();
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[10].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX());
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[10].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY());
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosX());
					distance.push_back(vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosY());

					double z = distance[0]*distance[3] - distance[1]*distance[2];
					if (z>0)
					{
						strTemp.Format(_T("......角度顺逆时针分析结果: 先顺时针旋转,正确; \n"));
						if (vstrAnalysisResult.size()>1)
						{
							vstrAnalysisResult[1] = strTemp;
						}

					} 
					else
					{
						strTemp.Format(_T("......角度顺逆时针分析结果: 先逆时针旋转,错误; \n"));

						if (vstrAnalysisResult.size()>1)
						{
							vstrAnalysisResult[1] = strTemp;
						}
					}
					strInfo += strTemp;
				}

				// D方向移动图像距离
				{

					// 					distance.clear();
					// 					distance.push_back(sqrt(pow(vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(2)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY,2)));
					// 					distance.push_back(sqrt(pow(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosX - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosX,2)+pow(vpMarkImagePos.at(1)->GetMarkImagePos(0).m_dPosY - vpMarkImagePos.at(3)->GetMarkImagePos(0).m_dPosY,2)));
					distance.clear();
					double dDisX_10T11 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[10].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX();
					double dDisY_10T11 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[10].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY();
					distance.push_back(sqrt( pow(dDisX_10T11, 2) + pow(dDisY_10T11, 2) ));

					double dDisX_09T11 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosX() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosX();
					double dDisY_09T11 = vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[9].GetPosY() - vpAllCalibratedInfo.at(nCalibPos)->m_cpObjectMarkImgCoordPos[11].GetPosY();
					distance.push_back(sqrt( pow(dDisX_09T11, 2) + pow(dDisY_09T11, 2) ));

					strTemp.Format(_T("......D方向移动图像距离: DisD1011: %.2f; DisD911: %.2f; 差值: %.2f;\n"),distance[0],distance[1],fabs(distance[0]-distance[1]));
					strInfo += strTemp;

					strTemp.Format(_T("D方向最大图像距离差值%.2f;\n"),fabs(distance[0]-distance[1]));

					if (vstrAnalysisResult.size()>4)
					{
						vstrAnalysisResult[4] = strTemp;
					}
				}
			}
		}
		break;

	default:
		{
			return;
		}
		break;
	}


	VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////




	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	strTemp.Empty();
	strInfo.Empty();

	strTemp.Format(_T("位置%d标定结果记录:\n"),nRemCalibPos+1);
	strInfo += strTemp;

	double h[9];
	vpAllCalibratedInfo.at(nCalibPos)->GetPlatformTransferH(h);


	strTemp.Format(_T("......转换矩阵: h0: %.5f; h1: %.5f; h2: %.5f; h3: %.5f; h4: %.5f; h5: %.5f; h6: %.5f; h7: %.5f; h8: %.5f;\n"),
		h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8]);
	strInfo += strTemp;

	strTemp.Format(_T("......像素分辨率: %.5f\n"),((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2);
	strInfo += strTemp;

	strTemp.Format(_T("......轴夹角: %.3f;\n"),((atan2(h[0],h[1]))+(atan2(h[4],-h[3])))/2);
	strInfo += strTemp;


	double dImageWidth2  = 640;
	double dImageHeight2 = 480;



	EnterCriticalSection(&m_vcsResource.at(nRemCalibPos));
	dImageWidth2  = m_vImageInput.at(nRemCalibPos).Width();
	dImageHeight2 = m_vImageInput.at(nRemCalibPos).Height();
	LeaveCriticalSection(&m_vcsResource.at(nRemCalibPos));


	{
		if(((sysPlatformInfo.m_nCamNum==2)&&(sysPlatformInfo.m_nPositionNum==8)&&(sysPlatformInfo.m_bTargetObjectCamSeparate==FALSE))||
			((sysPlatformInfo.m_nCamNum==2)&&(sysPlatformInfo.m_nPositionNum==4)&&(sysPlatformInfo.m_bTargetObjectCamSeparate==TRUE))||
			((sysPlatformInfo.m_nCamNum==2)&&(sysPlatformInfo.m_nPositionNum==8)&&(sysPlatformInfo.m_bTargetObjectCamSeparate==TRUE)))
		{
			strTemp.Format(_T("......视野: X: %.3f * Y: %.3f;\n"),dImageWidth2*((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2,
				dImageHeight2*((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2);
			strInfo += strTemp;
		} 
		else if(((sysPlatformInfo.m_nCamNum==2)&&(sysPlatformInfo.m_nPositionNum==2)&&(sysPlatformInfo.m_bTargetObjectCamSeparate==FALSE))||
			((sysPlatformInfo.m_nCamNum==4)&&(sysPlatformInfo.m_nPositionNum==4)&&(sysPlatformInfo.m_bTargetObjectCamSeparate==TRUE))||
			((sysPlatformInfo.m_nCamNum==8)&&(sysPlatformInfo.m_nPositionNum==8)&&(sysPlatformInfo.m_bTargetObjectCamSeparate==TRUE)))
		{

			strTemp.Format(_T("......视野: X: %.3f * Y: %.3f;\n"),dImageWidth2*((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2,
				dImageHeight2*((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2);
			strInfo += strTemp;
		}
		else if(((sysPlatformInfo.m_nCamNum==2)&&(sysPlatformInfo.m_nPositionNum==4)&&(sysPlatformInfo.m_bTargetObjectCamSeparate==FALSE))||
			((sysPlatformInfo.m_nCamNum==4)&&(sysPlatformInfo.m_nPositionNum==8)&&(sysPlatformInfo.m_bTargetObjectCamSeparate==TRUE)))
		{
			EnterCriticalSection(&m_vcsResource.at(nRemCalibPos/2));
			dImageWidth2  = m_vImageInput.at(nRemCalibPos/2).Width();
			dImageHeight2 = m_vImageInput.at(nRemCalibPos/2).Height();
			LeaveCriticalSection(&m_vcsResource.at(nRemCalibPos/2));

			strTemp.Format(_T("......视野: X: %.3f * Y: %.3f;\n"),dImageWidth2*((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2,
				dImageHeight2*((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2);
			strInfo += strTemp;
		}
		else
		{
			strTemp.Format(_T("......视野: X: %.3f * Y: %.3f;\n"),dImageWidth2*((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2,
				dImageHeight2*((sqrt(h[0]*h[0]+h[1]*h[1]))+(sqrt(h[3]*h[3]+h[4]*h[4])))/2);
			strInfo += strTemp;
		}

	}


	if (dImageWidth2!=0 && dImageHeight2!=0)
	{
		strTemp.Format(_T("......标定移动范围:X占视野比值: %.3f; Y占视野比值: %.3f;\n"),scMoveRangeImageDis.GetX()/dImageWidth2, scMoveRangeImageDis.GetY()/dImageHeight2);
	}
	else
	{
		strTemp.Format(_T("......标定移动范围:X占视野比值:无; Y占视野比值: 无;\n"));
	}
	strInfo += strTemp;
	vstrAnalysisResult.push_back(strTemp);	// 6

	CCoordPos cpTemp;
	cpTemp = vpAllCalibratedInfo.at(nCalibPos)->GetMarkImgCoordPos();
	strTemp.Format(_T("......标定基准图像坐标:  X: %.2f; Y: %.2f;\n"),cpTemp.m_dPosX,cpTemp.m_dPosY);
	strInfo += strTemp;

	cpTemp = vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPosBat();
	strTemp.Format(_T("......标定基准平台坐标:  X: %.2f; Y: %.2f;\n"),cpTemp.m_dPosX,cpTemp.m_dPosY);
	strInfo += strTemp;


	if ((cpTemp.m_dPosX>=0)&&(cpTemp.m_dPosY>=0))
	{
		//		strCalibResult += strTemp;
		strTemp.Format(_T("......标定基准平台坐标所在象限: 第四象限,即旋转轴中心在左上角;\n"));
	} 
	else if ((cpTemp.m_dPosX>=0)&&(cpTemp.m_dPosY<0))
	{
		//		strCalibResult += strTemp;
		strTemp.Format(_T("......标定基准平台坐标所在象限: 第一象限,即旋转轴中心在左下角;\n"));
	}
	else if ((cpTemp.m_dPosX<0)&&(cpTemp.m_dPosY>=0))
	{
		//		strCalibResult += strTemp;
		strTemp.Format(_T("......标定基准平台坐标所在象限: 第三象限,即旋转轴中心在右上角;\n"));
	}
	else if ((cpTemp.m_dPosX<0)&&(cpTemp.m_dPosY<0))
	{
		//		strCalibResult += strTemp;
		strTemp.Format(_T("......标定基准平台坐标所在象限: 第二象限,即旋转轴中心在右下角;\n"));
	}	
	strInfo += strTemp;


	VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);



	if (vstrAnalysisResult.size()>6)
	{
		strInfo.Empty();
		strTemp.Empty();

		strTemp.Format(_T("位置%d标定数据汇总分析结果:\n"),nRemCalibPos+1);
		strInfo += strTemp;

		strTemp.Format(_T("%s"),vstrAnalysisResult[0]);												// 1. 运用向量叉乘，判断九宫格顺逆
		strInfo += strTemp;

		strTemp.Format(_T("%s"),vstrAnalysisResult[1]);												// 2. 运用向量叉乘，判断角度旋转顺逆
		strInfo += strTemp;

		strTemp.Format(_T("......是否存在轴X重复性精度问题和反向间隙: %s"),vstrAnalysisResult[2]);	// 3. X图像偏差
		strInfo += strTemp;

		strTemp.Format(_T("......是否存在轴Y重复性精度问题和反向间隙: %s"),vstrAnalysisResult[3]);	// 4. Y图像偏差
		strInfo += strTemp;

		strTemp.Format(_T("......是否存在轴D重复性精度问题和反向间隙: %s"),vstrAnalysisResult[4]);	// 6. D图像偏差
		strInfo += strTemp;

		strTemp.Format(_T("......是否存在细分问题: %s"),vstrAnalysisResult[5]);						// 8. 比例对应分析结果
		strInfo += strTemp;

		strTemp.Format(_T("%s"),vstrAnalysisResult[6]);												// 9. 标定时X、Y分别占相机视野的比例
		strInfo += strTemp;

		VisionAlignLogRecord(m_strCalibrateProcessPath1,strInfo,FALSE);
	}

}

void vcBaseVisionAlign::HideObjTarGuiResultInSpect(std::vector<int> vnPosIndex, BOOL bShow)
{
	if (bShow)
	{
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
	}
	else
	{
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);
	}
}

int vcBaseVisionAlign::GetAlnSearchPatIndex(int nPosIndex, int eSearchMode)
{
	int nPatIndex = 0;
	switch(eSearchMode)
	{
	case eObjectSearch:
		nPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
		break;
	case eInspectSearch:
		nPatIndex = m_vnInspectSearchSuccessPatIndex[nPosIndex];
		break;
	case eCalibSearch:
		nPatIndex = m_vnCalibSearchSuccessPatIndex[nPosIndex];
		break;
	case eVirtualSearch:
		nPatIndex = m_vnVirtualObjectSearchSuccessPatIndex[nPosIndex];
		break;
	case eTargetSearch:
		nPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
		break;
	case eCalibTargetSearch:
		nPatIndex = m_vnCalibTargetSearchSuccessPatIndex[nPosIndex];
		break;
	case eAutoCalibTargetSearch:
		break;
	case eCalibWholeDmcodeBoard:
		break;
	}

	//nPatIndex = nPatIndex == -1 ? 0 : nPatIndex;

	return nPatIndex;
}

bool vcBaseVisionAlign::GetAlnSearchResult(int nPosIndex, int eSearchMode)
{
	bool bSuccess = false;
	switch(eSearchMode)
	{
	case eObjectSearch:
	case eInspectSearch:
	case eCalibSearch:
	case eVirtualSearch:
	case eTargetSearch:
	case eCalibTargetSearch:
	case eAutoCalibTargetSearch:
	case eCalibWholeDmcodeBoard:
		bSuccess = m_vbSearchSucceed[nPosIndex];
		break;
	}


	return bSuccess;
}

void  vcBaseVisionAlign::PostMessageShowMutiTargetImagePosToDisplay(BOOL bSuccess)
{
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	std::vector<int> vnPosIndex;
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;
	for (int j=0;j<GetPosNum();j++)
	{
		if (j>=GetPosNum()/2)
		{
			nAllPosIndex = j- GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = j;
			vnAllPosIndex.push_back(nAllPosIndex);
		}
	}
	int nPosIndex = 0;
	for(int i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	

	}
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 		if (bSuccess)
		// 		{
		// 			// 设定、显示目标定位结果十字，全部0/1/2/3图像
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 			// 设定、显示目标定位结果文字，全部0/1/2/3图像
		// 			SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
		// 
		// 		}

		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		if (bSuccess)
		{
			m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
		}
	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		if (bSuccess)
		// 		{
		// 			// 设定、显示结果图形
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 
		// 			// SY
		// 			SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
		// 		}

		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);
		if (bSuccess)
		{
			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
		}
	}


}

BOOL vcBaseVisionAlign::CheckProductDataCalibDataConsistency()
{
	if (m_pVisionASMConfig != NULL)
	{
		return m_pVisionASMConfig->CheckProductDataCalibDataConsistency();
	}
	else
	{
		// 配置不存在时,检查成功
		return TRUE;
	}
}

void vcBaseVisionAlign::SetParamToXYDCommProtocol()
{
	if (NULL == m_pVisionASMConfig)
	{
		return;
	}

	m_XYDCommProtocol.SetCmdParamOrderType(m_pVisionASMConfig->m_CommParamInfo.m_eCmdParamOrderType);
	m_XYDCommProtocol.SetProtocolType(m_pVisionASMConfig->m_CommParamInfo.m_eProtocolType);
	m_XYDCommProtocol.SetExProtocolType(m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType);
	m_XYDCommProtocol.SetPLCRegType(m_pVisionASMConfig->m_CommParamInfo.m_bRegiterType);
	m_XYDCommProtocol.SetPLCRegDataTypeIndex(m_pVisionASMConfig->m_CommParamInfo.m_nRegDataTypeIndex);

}

BOOL vcBaseVisionAlign::ChangeCommType(CommType eCommType)
{
	UninitComm();
	DeleteCommInfo();

	switch(eCommType)
	{
	case eSerial:
		{
			m_pVisionASMConfig->m_pCommParam = new vcSerialCommInfo;    
			// 后续优化：需要从文档中读入上一次设置，避免每次切换都需要重新设置;

			if (eShareCommTar == GetShareCommType())
			{
				// 共享自其他的通信comm
				if (m_pVisionAlignOther != NULL)
				{
					m_pComm = m_pVisionAlignOther->GetComm();
				}	
				else
				{
					return FALSE;
				}
				return TRUE;
			}
			m_pComm = new vcSerialComm;
		}
		break;
	case  eSocket:
		{
			m_pVisionASMConfig->m_pCommParam = new vcSocketCommInfo;     
			if (eShareCommTar == GetShareCommType())
			{
				// 共享自其他的通信comm
				if (m_pVisionAlignOther != NULL)
				{
					m_pComm = m_pVisionAlignOther->GetComm();
				}	
				else
				{
					return FALSE;
				}
				return TRUE;
			}
			m_pComm = new vcSocketComm;
			vcSocketComm::InitWSA(); 

		}
		break;
	default:
		{
			return FALSE;
		}
		break;
	}

	return TRUE;

}

BOOL vcBaseVisionAlign::ReInitComm()
{
	return InitComm();
}

BOOL vcBaseVisionAlign::IsAxisMoveOverRun(CCoordPos cp)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	return (cp.GetPosX() > optionInfo.m_dAxisMoveMaxX
		|| cp.GetPosY() > optionInfo.m_dAxisMoveMaxY
		|| cp.GetAngle() > optionInfo.m_dAxisMoveMaxD
		|| cp.GetPosX() < optionInfo.m_dAxisMoveMaxX_LowerLimit
		|| cp.GetPosY() < optionInfo.m_dAxisMoveMaxY_LowerLimit
		|| cp.GetAngle() < optionInfo.m_dAxisMoveMaxD_LowerLimit);
}

int vcBaseVisionAlign::GetWholeCalibCacuPos()
{
	int nCurCalibIndex = m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	CCalibData* pCurCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurCalibIndex);
	if (pCurCalibData == NULL)
	{
		return 0;
	}	 
	return pCurCalibData->GetWholeCalibCacuPos();
}

// 获取是否启用全局靶标标定方式选择位置自动计算旋转中心
BOOL vcBaseVisionAlign::GetWholeCalibCacuPosEnable()
{
	int nCurCalibIndex = m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	CCalibData* pCurCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurCalibIndex);
	if (pCurCalibData == NULL)
	{
		return 0;
	}	 
	return pCurCalibData->GetWholeCalibCacuPosEnable();
}

// XYD/XD/YD平台,全局二维码标定时，对位工具需要用到的二维码数据
BOOL vcBaseVisionAlign::ExecuteCalibrateWholeDmcodeMarkPosInfo(std::vector<CMulMarkPos*> vpDmCodeImagePos, std::vector<CMulMarkPos*> vpDmCodeBoardPos, std::vector<CMarkImagePos*> pMarkImagePos, int nCalibPos)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;

	m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nRemCalibPos);

	m_pAlignerTool->SetWholeDmCodeCalibImageResult(vpDmCodeImagePos,nRemCalibPos);
	m_pAlignerTool->SetWholeDmCodeCalibBoardResult(vpDmCodeBoardPos,nRemCalibPos);

	return TRUE;
}

// XYPD平台,全局二维码标定时，对位工具需要用到的二维码数据
BOOL vcBaseVisionAlign::ExecuteCalibrateWholeDmcodeMarkPosInfo(std::vector<CMulMarkPos*> vpDmCodeImagePos, std::vector<CMulMarkPos*> vpDmCodeBoardPos, std::vector<CMarkImagePos*> pMarkImagePos, int nCalibPos, int nMarkType)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;

	m_pAlignerTool->SetCalibPlatformMoveSearchResult(pMarkImagePos,nMarkType,nRemCalibPos);	

	m_pAlignerTool->SetWholeDmCodeCalibImageResult(vpDmCodeImagePos, nMarkType, nRemCalibPos);
	m_pAlignerTool->SetWholeDmCodeCalibBoardResult(vpDmCodeBoardPos, nMarkType, nRemCalibPos);

	return TRUE;
}


// 全局二维码标定时，建立二维码图像到靶标的映射关系
BOOL vcBaseVisionAlign::ExecuteCalibWholeDmCodeBoardImgToBoard(int nPosIndex)
{
	if (m_pAlignerTool == NULL )
	{
		return FALSE;
	}

	int nExProductIndex= nPosIndex/m_pPlatformInfo->m_nPositionNum;
	if (FALSE == m_pAlignerTool->ExecuteCalibrateWholeDmCodeBoardImgToBoard(nExProductIndex))
	{
		return FALSE;
	}

	return TRUE;

}

// 执行全局二维码靶标标定时建立,靶标坐标与平台坐标之间的关系
BOOL vcBaseVisionAlign::ExecuteCalibrateWholeDmcodeBoardBoardToPlat(int nCalibPos, int nMarkType)
{
	if (NULL == m_pAlignerTool)
	{
		return FALSE;
	}


	int nExProductIndex = nCalibPos/m_pPlatformInfo->m_nPositionNum;

	if (FALSE == m_pAlignerTool->ExecuteCalibrateWholeDmCodeBoardBoardToPlat(nExProductIndex, nMarkType))
	{
		return FALSE;
	}

	return TRUE;
}


// 执行全局二维码标定时，计算旋转中心位置
BOOL vcBaseVisionAlign::ExecuteCalibWholeDmCodeBoard(int nCalibPos)
{
	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}

	int nExProductIdx= nCalibPos/m_pPlatformInfo->m_nPositionNum;
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bPickDiffPosSameCalib = sysPlatformInfo.m_bPlatformPick && optionInfo.m_bAutoCopyCalibData && (sysPlatformInfo.m_nCamNum == 1);

	return m_pAlignerTool->ExecuteCalibWholeDmCodeBoard(nExProductIdx,bPickDiffPosSameCalib);
}

int vcBaseVisionAlign::ExecuteGitCommit(CString strCommit)
{
	int nRet = 0;
	int nEnable = 0;

#ifdef _DEBUG
	nEnable = 1;
#endif // _DEBUG

	// 调试测试使用git
	if(nEnable && m_bExecuteGitCommit)
	{
		CString strDir =_T("/c  ");
		strDir += m_strEXEDir;
		strDir += _T("\\Git_Test.bat");
		//strDir = strBat;
		strDir += _T(" ");
		strDir +=strCommit;
		VisionAlignLogRecord(_T("D:\\GitCommitlog.txt"),strDir);

		nRet = (int)ShellExecute(NULL,_T("open"),_T("cmd.exe"),strDir,NULL,SW_HIDE);


	}

	return nRet;
}

BOOL vcBaseVisionAlign::BendingCircleProcessInfo(CString &strInfo, std::vector<double> vdCircleRadius)
{
	// 获取当前产品序号
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}


	CString strError = _T("");

	BOOL bInspect = FALSE;
	std::vector<BOOL> vbInspect;


	CBendInfo BendInfo = pCurProductData->m_pAlignerParam->GetBendInfo();


	if ( (BendInfo.m_bBendingInspect) && (vdCircleRadius.size() > 5) )
	{
		 //判断半径是否符合阈值
		{
			double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[2];
			double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[1];
			m_BendInspectResultInfo.m_dCircleRadius[0] = vdCircleRadius.at(2);
			m_BendInspectResultInfo.m_dCircleRadius[1] = vdCircleRadius.at(5);
		//m_BendInspectResultInfo.m_dCircleRadiusX[i] = vdCircleRadius.at(i);
			//m_BendInspectResultInfo.m_dCircleRadiusY[i] = vdCircleRadius.at(i);
			for (int i = 0; i < nInspectDistNum; i++)
			{
				if ( (m_BendInspectResultInfo.m_dCircleRadius[i] <= dRangeMaxX) && (m_BendInspectResultInfo.m_dCircleRadius[i] >= dRangeMinX) )
				{
					bInspect = TRUE;
					vbInspect.push_back(bInspect);
				}
				else
				{
					CString strInfo;
					strInfo.Format(_T("Circle%d_Error,"), i + 1);

					strError = strError + strInfo;

					bInspect = FALSE;
					vbInspect.push_back(bInspect);
				}
			}
		}
		

		//判断X是否符合阈值
		{
			double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[2];
			double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[1];
			m_BendInspectResultInfo.m_dCircleRadiusX[0] = vdCircleRadius.at(0);
			m_BendInspectResultInfo.m_dCircleRadiusX[1] = vdCircleRadius.at(3);
			//m_BendInspectResultInfo.m_dCircleRadiusX[i] = vdCircleRadius.at(i);
			//m_BendInspectResultInfo.m_dCircleRadiusY[i] = vdCircleRadius.at(i);
			for (int i = 0; i < nInspectDistNum; i++)
			{
				if ( (m_BendInspectResultInfo.m_dCircleRadiusX[i] <= dRangeMaxX) && (m_BendInspectResultInfo.m_dCircleRadiusX[i] >= dRangeMinX) )
				{
					bInspect = TRUE;
					vbInspect.push_back(bInspect);
				}
				else
				{
					CString strInfo;
					strInfo.Format(_T("Circle%d_Error,"), i + 1);

					strError = strError + strInfo;

					bInspect = FALSE;
					vbInspect.push_back(bInspect);
				}
			}
		}




		//判断Y是否符合阈值
		{
			double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[2];
			double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[1];
			m_BendInspectResultInfo.m_dCircleRadiusY[0] = vdCircleRadius.at(1);
			m_BendInspectResultInfo.m_dCircleRadiusY[1] = vdCircleRadius.at(4);
			//m_BendInspectResultInfo.m_dCircleRadiusX[i] = vdCircleRadius.at(i);
			//m_BendInspectResultInfo.m_dCircleRadiusY[i] = vdCircleRadius.at(i);
			for (int i = 0; i < nInspectDistNum; i++)
			{
				if ( (m_BendInspectResultInfo.m_dCircleRadiusY[i] <= dRangeMaxX) && (m_BendInspectResultInfo.m_dCircleRadiusY[i] >= dRangeMinX) )
				{
					bInspect = TRUE;
					vbInspect.push_back(bInspect);
				}
				else
				{
					CString strInfo;
					strInfo.Format(_T("Circle%d_Error,"), i + 1);

					strError = strError + strInfo;

					bInspect = FALSE;
					vbInspect.push_back(bInspect);
				}
			}
		}


		/*
		for (int i = 0; ( i < vdCircleRadius.size() && i < nInspectDistNum); i++)
		{
		m_BendInspectResultInfo.m_dCircleRadius[i] = vdCircleRadius.at(i);
		m_BendInspectResultInfo.m_dCircleRadiusX[i] = vdCircleRadius.at(i);
		m_BendInspectResultInfo.m_dCircleRadiusY[i] = vdCircleRadius.at(i);

		if ( (m_BendInspectResultInfo.m_dCircleRadius[i] <= dRangeMaxX) && (m_BendInspectResultInfo.m_dCircleRadius[i] >= dRangeMinX) )
		{
		bInspect = TRUE;
		vbInspect.push_back(bInspect);
		}
		else
		{
		CString strInfo;
		strInfo.Format(_T("Circle%d_Error,"), i + 1);

		strError = strError + strInfo;

		bInspect = FALSE;
		vbInspect.push_back(bInspect);
		}
		}*/

	
	
	}




	for (int i = 0; i < vbInspect.size(); i++)
	{
		bInspect &= vbInspect.at(i);
	}

	return bInspect;
}

BOOL vcBaseVisionAlign::BendingCircleProcessInfo(CString &strInfo, std::vector<double> vdCircleRadius,std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult)
{
	// 获取当前产品序号
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}


	CString strError = _T("");
	CString m_StrText;
	BOOL bInspect = FALSE;
	std::vector<BOOL> vbInspect;


	CBendInfo BendInfo = pCurProductData->m_pAlignerParam->GetBendInfo();


	if ( (BendInfo.m_bBendingInspect) && (vdCircleRadius.size() > 5) )
	{
		 //判断半径是否符合阈值
		{
			double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[2];
			double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadius[1];
			m_BendInspectResultInfo.m_dCircleRadius[0] = vdCircleRadius.at(2);
			m_BendInspectResultInfo.m_dCircleRadius[1] = vdCircleRadius.at(5);
		//m_BendInspectResultInfo.m_dCircleRadiusX[i] = vdCircleRadius.at(i);
			//m_BendInspectResultInfo.m_dCircleRadiusY[i] = vdCircleRadius.at(i);
			for (int i = 0; i < nInspectDistNum; i++)
			{
				if ( (m_BendInspectResultInfo.m_dCircleRadius[i] <= dRangeMaxX) && (m_BendInspectResultInfo.m_dCircleRadius[i] >= dRangeMinX) )
				{
					bInspect = TRUE;
					vbInspect.push_back(bInspect);
				}
				else
				{
					CString strInfo;
					strInfo.Format(_T("Circle%d_Error,"), i + 1);

					strError = strError + strInfo;

					bInspect = FALSE;
					vbInspect.push_back(bInspect);
				}
			
				//添加变量用于前端GUI显示
				//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
				{
					bResult.push_back(bInspect);
					m_StrText.Format(_T("R:%.4f"),m_BendInspectResultInfo.m_dCircleRadius[i]);
					vSearchResult.push_back(m_StrText);
				}

			}
		}
		



		//判断X是否符合阈值
		{
			double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[2];
			double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusX[1];
			m_BendInspectResultInfo.m_dCircleRadiusX[0] = vdCircleRadius.at(0);
			m_BendInspectResultInfo.m_dCircleRadiusX[1] = vdCircleRadius.at(3);
			//m_BendInspectResultInfo.m_dCircleRadiusX[i] = vdCircleRadius.at(i);
			//m_BendInspectResultInfo.m_dCircleRadiusY[i] = vdCircleRadius.at(i);
			for (int i = 0; i < nInspectDistNum; i++)
			{
				if ( (m_BendInspectResultInfo.m_dCircleRadiusX[i] <= dRangeMaxX) && (m_BendInspectResultInfo.m_dCircleRadiusX[i] >= dRangeMinX) )
				{
					bInspect = TRUE;
					vbInspect.push_back(bInspect);
				}
				else
				{
					CString strInfo;
					strInfo.Format(_T("Circle%d_XError,"), i + 1);

					strError = strError + strInfo;

					bInspect = FALSE;
					vbInspect.push_back(bInspect);
				}

				//添加变量用于前端GUI显示
				//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
				{
					bResult.push_back(bInspect);
					m_StrText.Format(_T("X:%.4f"),m_BendInspectResultInfo.m_dCircleRadiusX[i]);
					vSearchResult.push_back(m_StrText);
				}


			}
		}


		//判断Y是否符合阈值
		{
			double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[2];
			double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeCircleRadiusY[1];
			m_BendInspectResultInfo.m_dCircleRadiusY[0] = vdCircleRadius.at(1);
			m_BendInspectResultInfo.m_dCircleRadiusY[1] = vdCircleRadius.at(4);
			//m_BendInspectResultInfo.m_dCircleRadiusX[i] = vdCircleRadius.at(i);
			//m_BendInspectResultInfo.m_dCircleRadiusY[i] = vdCircleRadius.at(i);
			for (int i = 0; i < nInspectDistNum; i++)
			{
				if ( (m_BendInspectResultInfo.m_dCircleRadiusY[i] <= dRangeMaxX) && (m_BendInspectResultInfo.m_dCircleRadiusY[i] >= dRangeMinX) )
				{
					bInspect = TRUE;
					vbInspect.push_back(bInspect);
				}
				else
				{
					CString strInfo;
					strInfo.Format(_T("Circle%d_YError,"), i + 1);

					strError = strError + strInfo;

					bInspect = FALSE;
					vbInspect.push_back(bInspect);
				}

				//添加变量用于前端GUI显示
				//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
				{
					bResult.push_back(bInspect);
					m_StrText.Format(_T("Y:%.4f"),m_BendInspectResultInfo.m_dCircleRadiusY[i]);
					vSearchResult.push_back(m_StrText);
				}

			}
		}

	}
	//strInfo = strError;
	for (int i = 0; i < vbInspect.size(); i++)
	{
		bInspect &= vbInspect.at(i);
	}

	if (!bInspect)
	{
		strInfo = _T("尺寸超限");
	}

	return bInspect;
}

BOOL vcBaseVisionAlign::BendingAlignProcessInfo(CString &strInfo)
{
	// 获取当前产品序号
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}

	// 	if (m_pPlatformInfo->m_bTargetObjectCamSeparate &&  !m_pSystempOptionConfig->m_bShowSepTargetPos)
	// 	{
	// 		return FALSE;
	// 	}


	CString strError = _T("");

	BOOL bInspect = FALSE;
	std::vector<BOOL> vbInspect;


	CBendInfo BendInfo = pCurProductData->m_pAlignerParam->GetBendInfo();

	double dTargetCH0_X = 0.0, dTargetCH0_Y = 0.0;
	double dTargetCH1_X = 0.0, dTargetCH1_Y = 0.0;

	double dObjectCH0_X = 0.0, dObjectCH0_Y = 0.0;
	double dObjectCH1_X = 0.0, dObjectCH1_Y = 0.0;

	// 平台检测和图像检测都调用该函数，目的是为了计算产品尺寸vdDis；
	std::vector<sc2Vector> vTargetPlaftormPos;
	std::vector<sc2Vector> vObjectPlatformPos;
	std::vector<double> vdDis;



	if (!m_pAlignerTool->ExeBendInsInfoCalcu(vTargetPlaftormPos, vObjectPlatformPos, vdDis))
	{
		strInfo = m_pAlignerTool->GetAlignErrInfo();
		return FALSE;
	}

	// 平台检测
	if (!BendInfo.m_bBendType)
	{
		dTargetCH0_X = vTargetPlaftormPos.at(0).GetX();
		dTargetCH0_Y = vTargetPlaftormPos.at(0).GetY();

		dTargetCH1_X = vTargetPlaftormPos.at(1).GetX();
		dTargetCH1_Y = vTargetPlaftormPos.at(1).GetY();


		dObjectCH0_X = vObjectPlatformPos.at(0).GetX();
		dObjectCH0_Y = vObjectPlatformPos.at(0).GetY();

		dObjectCH1_X = vObjectPlatformPos.at(1).GetX();
		dObjectCH1_Y = vObjectPlatformPos.at(1).GetY();

	}
	// 图像检测
	else
	{
		double dRadio = BendInfo.m_dBendImageRadio;

		// 目标图像坐标
		CMarkImagePos TargetMarkImagePos;
		TargetMarkImagePos = m_mpTargetMarkImagePos;

		if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
		{
			dTargetCH0_X = TargetMarkImagePos.m_vPos.at(2).GetPosX() * dRadio;
			dTargetCH0_Y = TargetMarkImagePos.m_vPos.at(2).GetPosY() * dRadio;

			dTargetCH1_X = TargetMarkImagePos.m_vPos.at(3).GetPosX() * dRadio;
			dTargetCH1_Y = TargetMarkImagePos.m_vPos.at(3).GetPosY() * dRadio;
		}
		else
		{
			dTargetCH0_X = TargetMarkImagePos.m_vPos.at(0).GetPosX() * dRadio;
			dTargetCH0_Y = TargetMarkImagePos.m_vPos.at(0).GetPosY() * dRadio;

			dTargetCH1_X = TargetMarkImagePos.m_vPos.at(1).GetPosX() * dRadio;
			dTargetCH1_Y = TargetMarkImagePos.m_vPos.at(1).GetPosY() * dRadio;
		}


		// 对象图像坐标
		CMarkImagePos ObjectMarkImagePos;
		ObjectMarkImagePos = m_mpObjectMarkImagePos;

		dObjectCH0_X = ObjectMarkImagePos.m_vPos.at(0).GetPosX() * dRadio;
		dObjectCH0_Y = ObjectMarkImagePos.m_vPos.at(0).GetPosY() * dRadio;

		dObjectCH1_X = ObjectMarkImagePos.m_vPos.at(1).GetPosX() * dRadio;
		dObjectCH1_Y = ObjectMarkImagePos.m_vPos.at(1).GetPosY() * dRadio;
	}


	// 1. Left_X
	{
		double dLeftX = fabs(dTargetCH0_X - dObjectCH0_X);

		if (BendInfo.m_bBendResultOffset)
		{
			m_BendInspectResultInfo.m_dLx = dLeftX + BendInfo.m_scBendLeftDisOffset.GetX();
		}
		else
		{
			m_BendInspectResultInfo.m_dLx = dLeftX;
		}


		double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeLX[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeLX[2];
		double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeLX[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeLX[1];

		// 实时计算Lx、Ly、Rx、Ry：目的是让计算的四个值和标准阈值进行比对判定
		if (BendInfo.m_bBendThreOffset)
		{
			if (m_BendInspectResultInfo.m_dLx >= dRangeMaxX)
			{
				m_BendInspectResultInfo.m_dLx = m_BendInspectResultInfo.m_dLx - BendInfo.m_scBendStanderThre.GetX();
			} 
			else if(m_BendInspectResultInfo.m_dLx <= dRangeMinX)
			{
				m_BendInspectResultInfo.m_dLx = m_BendInspectResultInfo.m_dLx + BendInfo.m_scBendStanderThre.GetX();
			}
		}

		if ( (m_BendInspectResultInfo.m_dLx >= dRangeMinX) && (m_BendInspectResultInfo.m_dLx <= dRangeMaxX))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			CString StrTmp = _T("");
			StrTmp.Format(_T("Lx超限(%.4f),"),m_BendInspectResultInfo.m_dLx);
			strError += StrTmp;

			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
	}

	// 2. Right_X
	{
		double dRightX = fabs(dTargetCH1_X - dObjectCH1_X);

		if (BendInfo.m_bBendResultOffset)
		{
			m_BendInspectResultInfo.m_dRx = dRightX + BendInfo.m_scBendRightDisOffset.GetX();
		}
		else
		{
			m_BendInspectResultInfo.m_dRx = dRightX;
		}

		double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeRX[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeRX[2];
		double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeRX[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeRX[1];

		if (BendInfo.m_bBendThreOffset)
		{
			if (m_BendInspectResultInfo.m_dRx >= dRangeMaxX)
			{
				m_BendInspectResultInfo.m_dRx = m_BendInspectResultInfo.m_dRx - BendInfo.m_scBendStanderThre.GetX();
			} 
			else if(m_BendInspectResultInfo.m_dRx <= dRangeMinX)
			{
				m_BendInspectResultInfo.m_dRx = m_BendInspectResultInfo.m_dRx + BendInfo.m_scBendStanderThre.GetX();
			}
		}

		if ( (m_BendInspectResultInfo.m_dRx >= dRangeMinX) && (m_BendInspectResultInfo.m_dRx <= dRangeMaxX))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("Rx_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Rx超限(%.4f),"),m_BendInspectResultInfo.m_dRx);
			strError += StrTmp;

			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
	}

	// 3. Left_Y
	{
		double dLeftY;
		if (BendInfo.m_bEnableFbsLRY)
		{
			dLeftY = dTargetCH0_Y - dObjectCH0_Y;
		} 
		else
		{
			dLeftY = fabs(dTargetCH0_Y - dObjectCH0_Y);
		}
		

		// 实时计算Lx、Ly、Rx、Ry：目的是让计算的四个值和标准阈值进行比对判定
		if (BendInfo.m_bBendResultOffset)
		{
			m_BendInspectResultInfo.m_dLy = dLeftY + BendInfo.m_scBendLeftDisOffset.GetY();
		}
		else
		{
			m_BendInspectResultInfo.m_dLy = dLeftY;
		}

		double dRangeMaxY = BendInfo.m_BendInspectRangeInfo.m_dRangeLY[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeLY[2];
		double dRangeMinY = BendInfo.m_BendInspectRangeInfo.m_dRangeLY[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeLY[1];

		if (BendInfo.m_bBendThreOffset)
		{
			if (m_BendInspectResultInfo.m_dLy >= dRangeMaxY)
			{
				m_BendInspectResultInfo.m_dLy = m_BendInspectResultInfo.m_dLy - BendInfo.m_scBendStanderThre.GetY();
			} 
			else if(m_BendInspectResultInfo.m_dLy <= dRangeMinY)
			{
				m_BendInspectResultInfo.m_dLy = m_BendInspectResultInfo.m_dLy + BendInfo.m_scBendStanderThre.GetY();
			}
		}


		if ( (m_BendInspectResultInfo.m_dLy >= dRangeMinY) && (m_BendInspectResultInfo.m_dLy <= dRangeMaxY))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("Ly_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Ly超限(%.4f),"),m_BendInspectResultInfo.m_dLy);
			strError += StrTmp;

			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}


	}

	// 4. Right_Y
	{
		double dRightY;
		if (BendInfo.m_bEnableFbsLRY)
		{
			dRightY = dTargetCH1_Y - dObjectCH1_Y;
		} 
		else
		{
			dRightY = fabs(dTargetCH1_Y - dObjectCH1_Y);
		}
		

		// 实时计算Lx、Ly、Rx、Ry：目的是让计算的四个值和标准阈值进行比对判定
		if (BendInfo.m_bBendResultOffset)
		{
			m_BendInspectResultInfo.m_dRy = dRightY + BendInfo.m_scBendLeftDisOffset.GetY();
		}
		else
		{
			m_BendInspectResultInfo.m_dRy = dRightY;
		}


		double dRangeMaxY = BendInfo.m_BendInspectRangeInfo.m_dRangeRY[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeRY[2];
		double dRangeMinY = BendInfo.m_BendInspectRangeInfo.m_dRangeRY[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeRY[1];

		if (BendInfo.m_bBendThreOffset)
		{
			if (m_BendInspectResultInfo.m_dRy >= dRangeMaxY)
			{
				m_BendInspectResultInfo.m_dRy = m_BendInspectResultInfo.m_dRy - BendInfo.m_scBendStanderThre.GetY();
			} 
			else if(m_BendInspectResultInfo.m_dRy <= dRangeMinY)
			{
				m_BendInspectResultInfo.m_dRy = m_BendInspectResultInfo.m_dRy + BendInfo.m_scBendStanderThre.GetY();
			}
		}

		if ( (m_BendInspectResultInfo.m_dRy >= dRangeMinY) && (m_BendInspectResultInfo.m_dRy <= dRangeMaxY))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("Ry_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Ly超限(%.4f),"),m_BendInspectResultInfo.m_dRy);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}


	}

	// 5. Left_Distance
	{
		sc2Vector vMark_Left[2];
		vMark_Left[0].SetX(dTargetCH0_X);
		vMark_Left[0].SetY(dTargetCH0_Y);
		vMark_Left[1].SetX(dObjectCH0_X);
		vMark_Left[1].SetY(dObjectCH0_Y);

		double dLeftDis = vMark_Left[0].Distance(vMark_Left[1]);
		m_BendInspectResultInfo.m_dDistanceL = dLeftDis;

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[1];

		if ( (m_BendInspectResultInfo.m_dDistanceL >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDistanceL <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("LeftDistance_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Ldis超限(%.4f),"),m_BendInspectResultInfo.m_dDistanceL);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

	}

	// 6. Right_Distance
	{
		sc2Vector vMark_Right[2];
		vMark_Right[0].SetX(dTargetCH1_X);
		vMark_Right[0].SetY(dTargetCH1_Y);
		vMark_Right[1].SetX(dObjectCH1_X);
		vMark_Right[1].SetY(dObjectCH1_Y);

		double dRightDis = vMark_Right[0].Distance(vMark_Right[1]);
		m_BendInspectResultInfo.m_dDistanceR = dRightDis;

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[1];

		if ( (m_BendInspectResultInfo.m_dDistanceR >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDistanceR <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("RightDistance_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Rdis超限(%.4f),"),m_BendInspectResultInfo.m_dDistanceR);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

	}

	// 7 Target Distance
	{
		double dTarget_Dis;
		dTarget_Dis = vdDis.at(0);

		if (BendInfo.m_bBendDisOffset)
		{
			m_BendInspectResultInfo.m_dTargetDistance = dTarget_Dis + BendInfo.m_dBendTargetDisOffset;
		}
		else
		{
			m_BendInspectResultInfo.m_dTargetDistance = dTarget_Dis;
		}

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[1];

		if ( (m_BendInspectResultInfo.m_dTargetDistance >= dRangeMinDis) && (m_BendInspectResultInfo.m_dTargetDistance <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("TargetDistance_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Tdis超限(%.4f),"),m_BendInspectResultInfo.m_dTargetDistance);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

	}

	// 8 Object Distance
	{
		double dObject_Dis;
		dObject_Dis = vdDis.at(1);

		if (BendInfo.m_bBendDisOffset)
		{
			m_BendInspectResultInfo.m_dObjectDistance = dObject_Dis + BendInfo.m_dBendObjectDisOffset;
		}
		else
		{
			m_BendInspectResultInfo.m_dObjectDistance = dObject_Dis;
		}

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[1];

		if ( (m_BendInspectResultInfo.m_dObjectDistance >= dRangeMinDis) && (m_BendInspectResultInfo.m_dObjectDistance <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("ObjectDistance_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Odis超限(%.4f),"),m_BendInspectResultInfo.m_dTargetDistance);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

	}

	// 9. X向偏差
	{
		double dSubX_Dis = fabs(m_BendInspectResultInfo.m_dLx - m_BendInspectResultInfo.m_dRx);
		m_BendInspectResultInfo.m_dDistanceSubX = dSubX_Dis;


		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[1];

		if ( (m_BendInspectResultInfo.m_dDistanceSubX >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDistanceSubX <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("(Lx-Rx)_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("(Lx-Rx)超限(%.4f),"),m_BendInspectResultInfo.m_dDistanceSubX);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
	}

	// 10. Y向偏差
	{
		double dSubY_Dis = fabs(m_BendInspectResultInfo.m_dLy - m_BendInspectResultInfo.m_dRy);
		m_BendInspectResultInfo.m_dDistanceSubY = dSubY_Dis;


		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[1];

		if ( (m_BendInspectResultInfo.m_dDistanceSubY >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDistanceSubY <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("(Ly-Ry)_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("((Ly-Ry)超限(%.4f),"),m_BendInspectResultInfo.m_dDistanceSubY);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
	}

	for (int i = 0; i < vbInspect.size(); i++)
	{
		bInspect &= vbInspect.at(i);
	}

	strInfo = strError;

	return bInspect;
}

BOOL vcBaseVisionAlign::BendingAlignProcessInfo(CString &strInfo,std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult,CString m_strProductID,CString strProductSTATION,CString strInspectStation /*= _T("")*/)
{
	// 获取当前产品序号
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}

	// 获取当前产品信息
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		return FALSE;
	}

	// 	if (m_pPlatformInfo->m_bTargetObjectCamSeparate &&  !m_pSystempOptionConfig->m_bShowSepTargetPos)
	// 	{
	// 		return FALSE;
	// 	}

	CBendInfo BendInfo = pCurProductData->m_pAlignerParam->GetBendInfo();

	bResult.clear();
	vSearchResult.clear();
	CString m_StrTextID;
	for (int i = 0; i < 2; i++)
	{
		bResult.push_back(1);
		m_StrTextID.Format(_T("SN:%s"),m_strProductID);
		//vSearchResult.push_back(m_StrText);
		vSearchResult.push_back(m_StrTextID);
	}
	if (strProductSTATION != "")
	{
		for (int i = 0; i < 2; i++)
		{
			bResult.push_back(1);
			m_StrTextID.Format(_T("%s:%s"),BendInfo.m_strPlatformName1,m_strProductSTATION);
			vSearchResult.push_back(m_StrTextID);
		}
	}
	if (strInspectStation != "")
	{
		for (int i = 0; i < 2; i++)
		{
			bResult.push_back(1);
			m_StrTextID.Format(_T("%s:%s"),BendInfo.m_strPlatformName2,strInspectStation);
			//vSearchResult.push_back(m_StrText);
			vSearchResult.push_back(m_StrTextID);
		}
	}

	CString strError = _T("");
	CString m_StrText = _T("");
	BOOL bInspect = FALSE;
	std::vector<BOOL> vbInspect;

	double dTargetCH0_X = 0.0, dTargetCH0_Y = 0.0;
	double dTargetCH1_X = 0.0, dTargetCH1_Y = 0.0;
	double dObjectCH0_X = 0.0, dObjectCH0_Y = 0.0;
	double dObjectCH1_X = 0.0, dObjectCH1_Y = 0.0;

	// 平台检测和图像检测都调用该函数，目的是为了计算产品尺寸vdDis；
	std::vector<sc2Vector> vTargetPlaftormPos;
	std::vector<sc2Vector> vObjectPlatformPos;
	std::vector<double> vdDis;



	if (!m_pAlignerTool->ExeBendInsInfoCalcu(vTargetPlaftormPos, vObjectPlatformPos, vdDis))
	{
		strInfo = m_pAlignerTool->GetAlignErrInfo();
		return FALSE;
	}

	// 平台检测
	if (!BendInfo.m_bBendType)
	{
		dTargetCH0_X = vTargetPlaftormPos.at(0).GetX();
		dTargetCH0_Y = vTargetPlaftormPos.at(0).GetY();

		dTargetCH1_X = vTargetPlaftormPos.at(1).GetX();
		dTargetCH1_Y = vTargetPlaftormPos.at(1).GetY();


		dObjectCH0_X = vObjectPlatformPos.at(0).GetX();
		dObjectCH0_Y = vObjectPlatformPos.at(0).GetY();

		dObjectCH1_X = vObjectPlatformPos.at(1).GetX();
		dObjectCH1_Y = vObjectPlatformPos.at(1).GetY();

	}
	// 图像检测
	else
	{
		double dRadio = BendInfo.m_dBendImageRadio;

		// 目标图像坐标
		CMarkImagePos TargetMarkImagePos;
		TargetMarkImagePos = m_mpTargetMarkImagePos;

		if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
		{
			dTargetCH0_X = TargetMarkImagePos.m_vPos.at(2).GetPosX() * dRadio;
			dTargetCH0_Y = TargetMarkImagePos.m_vPos.at(2).GetPosY() * dRadio;

			dTargetCH1_X = TargetMarkImagePos.m_vPos.at(3).GetPosX() * dRadio;
			dTargetCH1_Y = TargetMarkImagePos.m_vPos.at(3).GetPosY() * dRadio;
		}
		else
		{
			dTargetCH0_X = TargetMarkImagePos.m_vPos.at(0).GetPosX() * dRadio;
			dTargetCH0_Y = TargetMarkImagePos.m_vPos.at(0).GetPosY() * dRadio;

			dTargetCH1_X = TargetMarkImagePos.m_vPos.at(1).GetPosX() * dRadio;
			dTargetCH1_Y = TargetMarkImagePos.m_vPos.at(1).GetPosY() * dRadio;
		}


		// 对象图像坐标
		CMarkImagePos ObjectMarkImagePos;
		ObjectMarkImagePos = m_mpObjectMarkImagePos;

		dObjectCH0_X = ObjectMarkImagePos.m_vPos.at(0).GetPosX() * dRadio;
		dObjectCH0_Y = ObjectMarkImagePos.m_vPos.at(0).GetPosY() * dRadio;

		dObjectCH1_X = ObjectMarkImagePos.m_vPos.at(1).GetPosX() * dRadio;
		dObjectCH1_Y = ObjectMarkImagePos.m_vPos.at(1).GetPosY() * dRadio;
	}


	// 1. Left_X
	{
	    double dLeftX = fabs(dTargetCH0_X - dObjectCH0_X);
	    //double dLeftX = dTargetCH0_X - dObjectCH0_X;
		if (BendInfo.m_bBendResultOffset)
		{
			m_BendInspectResultInfo.m_dLx = dLeftX + BendInfo.m_scBendLeftDisOffset.GetX();
		}
		else
		{
			m_BendInspectResultInfo.m_dLx = dLeftX;
		}

		
		double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeLX[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeLX[2];
		double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeLX[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeLX[1];

		// 实时计算Lx、Ly、Rx、Ry：目的是让计算的四个值和标准阈值进行比对判定
		if (BendInfo.m_bBendThreOffset)
		{
			if (m_BendInspectResultInfo.m_dLx >= dRangeMaxX)
			{
				m_BendInspectResultInfo.m_dLx = m_BendInspectResultInfo.m_dLx - BendInfo.m_scBendStanderThre.GetX();
			} 
			else if(m_BendInspectResultInfo.m_dLx <= dRangeMinX)
			{
				m_BendInspectResultInfo.m_dLx = m_BendInspectResultInfo.m_dLx + BendInfo.m_scBendStanderThre.GetX();
			}
		}

		if ( (m_BendInspectResultInfo.m_dLx >= dRangeMinX) && (m_BendInspectResultInfo.m_dLx <= dRangeMaxX))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			CString StrTmp = _T("");
			StrTmp.Format(_T("Lx超限(%.4f),"),m_BendInspectResultInfo.m_dLx);
			strError += StrTmp;

			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
		//添加变量用于前端GUI显示
		//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
		{
			bResult.push_back(bInspect);
			m_StrText.Format(_T("Lx:%.4f"),m_BendInspectResultInfo.m_dLx);
			vSearchResult.push_back(m_StrText);
		}
	}

	// 2. Right_X
	{
		double dRightX = fabs(dTargetCH1_X - dObjectCH1_X);

		if (BendInfo.m_bBendResultOffset)
		{
			m_BendInspectResultInfo.m_dRx = dRightX + BendInfo.m_scBendRightDisOffset.GetX();
		}
		else
		{
			m_BendInspectResultInfo.m_dRx = dRightX;
		}

		double dRangeMaxX = BendInfo.m_BendInspectRangeInfo.m_dRangeRX[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeRX[2];
		double dRangeMinX = BendInfo.m_BendInspectRangeInfo.m_dRangeRX[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeRX[1];

		if (BendInfo.m_bBendThreOffset)
		{
			if (m_BendInspectResultInfo.m_dRx >= dRangeMaxX)
			{
				m_BendInspectResultInfo.m_dRx = m_BendInspectResultInfo.m_dRx - BendInfo.m_scBendStanderThre.GetX();
			} 
			else if(m_BendInspectResultInfo.m_dRx <= dRangeMinX)
			{
				m_BendInspectResultInfo.m_dRx = m_BendInspectResultInfo.m_dRx + BendInfo.m_scBendStanderThre.GetX();
			}
		}

		if ( (m_BendInspectResultInfo.m_dRx >= dRangeMinX) && (m_BendInspectResultInfo.m_dRx <= dRangeMaxX))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("Rx_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Rx超限(%.4f),"),m_BendInspectResultInfo.m_dRx);
			strError += StrTmp;

			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
	    
		//添加变量用于前端GUI显示
		//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
		{
			bResult.push_back(bInspect);
			m_StrText.Format(_T("Rx:%.4f"),m_BendInspectResultInfo.m_dRx);
		    vSearchResult.push_back(m_StrText);
		}
	
	
	}

	// 3. Left_Y
	{
		double dLeftY;
		if (BendInfo.m_bEnableFbsLRY)
		{
			dLeftY = dTargetCH0_Y - dObjectCH0_Y;
		} 
		else
		{
			dLeftY = fabs(dTargetCH0_Y - dObjectCH0_Y);
		}

		

		// 实时计算Lx、Ly、Rx、Ry：目的是让计算的四个值和标准阈值进行比对判定
		if (BendInfo.m_bBendResultOffset)
		{
			m_BendInspectResultInfo.m_dLy = dLeftY + BendInfo.m_scBendLeftDisOffset.GetY();
		}
		else
		{
			m_BendInspectResultInfo.m_dLy = dLeftY;
		}

		double dRangeMaxY = BendInfo.m_BendInspectRangeInfo.m_dRangeLY[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeLY[2];
		double dRangeMinY = BendInfo.m_BendInspectRangeInfo.m_dRangeLY[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeLY[1];

		if (BendInfo.m_bBendThreOffset)
		{
			if (m_BendInspectResultInfo.m_dLy >= dRangeMaxY)
			{
				m_BendInspectResultInfo.m_dLy = m_BendInspectResultInfo.m_dLy - BendInfo.m_scBendStanderThre.GetY();
			} 
			else if(m_BendInspectResultInfo.m_dLy <= dRangeMinY)
			{
				m_BendInspectResultInfo.m_dLy = m_BendInspectResultInfo.m_dLy + BendInfo.m_scBendStanderThre.GetY();
			}
		}


		if ( (m_BendInspectResultInfo.m_dLy >= dRangeMinY) && (m_BendInspectResultInfo.m_dLy <= dRangeMaxY))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("Ly_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Ly超限(%.4f),"),m_BendInspectResultInfo.m_dLy);
			strError += StrTmp;

			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

		//添加变量用于前端GUI显示
		//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
		{
			bResult.push_back(bInspect);
			m_StrText.Format(_T("Ly:%.4f"),m_BendInspectResultInfo.m_dLy);
			vSearchResult.push_back(m_StrText);
		}


	}

	// 4. Right_Y
	{
		double dRightY;
		if (BendInfo.m_bEnableFbsLRY)
		{
			dRightY = dTargetCH1_Y - dObjectCH1_Y;
		} 
		else
		{
			dRightY = fabs(dTargetCH1_Y - dObjectCH1_Y);
		}

		

		// 实时计算Lx、Ly、Rx、Ry：目的是让计算的四个值和标准阈值进行比对判定
		if (BendInfo.m_bBendResultOffset)
		{
			m_BendInspectResultInfo.m_dRy = dRightY + BendInfo.m_scBendRightDisOffset.GetY();
		}
		else
		{
			m_BendInspectResultInfo.m_dRy = dRightY;
		}


		double dRangeMaxY = BendInfo.m_BendInspectRangeInfo.m_dRangeRY[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeRY[2];
		double dRangeMinY = BendInfo.m_BendInspectRangeInfo.m_dRangeRY[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeRY[1];

		if (BendInfo.m_bBendThreOffset)
		{
			if (m_BendInspectResultInfo.m_dRy >= dRangeMaxY)
			{
				m_BendInspectResultInfo.m_dRy = m_BendInspectResultInfo.m_dRy - BendInfo.m_scBendStanderThre.GetY();
			} 
			else if(m_BendInspectResultInfo.m_dRy <= dRangeMinY)
			{
				m_BendInspectResultInfo.m_dRy = m_BendInspectResultInfo.m_dRy + BendInfo.m_scBendStanderThre.GetY();
			}
		}

		if ( (m_BendInspectResultInfo.m_dRy >= dRangeMinY) && (m_BendInspectResultInfo.m_dRy <= dRangeMaxY))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("Ry_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Ly超限(%.4f),"),m_BendInspectResultInfo.m_dRy);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

		//添加变量用于前端GUI显示
		//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
		{
			bResult.push_back(bInspect);
			m_StrText.Format(_T("Ry:%.4f"),m_BendInspectResultInfo.m_dRy);
			vSearchResult.push_back(m_StrText);
		}


	}

	// 5. Left_Distance
	{
		double dLeftDis = 0.0;
		if (!BendInfo.m_bEnableUseMathCaluLRDis)
		{
			sc2Vector vMark_Left[2];
			vMark_Left[0].SetX(dTargetCH0_X);
			vMark_Left[0].SetY(dTargetCH0_Y);
			vMark_Left[1].SetX(dObjectCH0_X);
			vMark_Left[1].SetY(dObjectCH0_Y);
			dLeftDis = vMark_Left[0].Distance(vMark_Left[1]);
		}
		else
		{
			dLeftDis = sqrt(m_BendInspectResultInfo.m_dLx * m_BendInspectResultInfo.m_dLx 
				+ m_BendInspectResultInfo.m_dLy * m_BendInspectResultInfo.m_dLy);
		}
		m_BendInspectResultInfo.m_dDistanceL = dLeftDis + (BendInfo.m_bBendResultOffset ? BendInfo.m_dLeftDisOffset:0.0);

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeLDis[1];

		if ( (m_BendInspectResultInfo.m_dDistanceL >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDistanceL <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("LeftDistance_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Ldis超限(%.4f),"),m_BendInspectResultInfo.m_dDistanceL);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}


		//添加变量用于前端GUI显示
		//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
		{
			bResult.push_back(bInspect);
			m_StrText.Format(_T("Ldis:%.4f"),m_BendInspectResultInfo.m_dDistanceL);
			vSearchResult.push_back(m_StrText);
		}

	}

	// 6. Right_Distance
	{
		double dRightDis = 0.0;
		if (!BendInfo.m_bEnableUseMathCaluLRDis)
		{
			sc2Vector vMark_Right[2];
			vMark_Right[0].SetX(dTargetCH1_X);
			vMark_Right[0].SetY(dTargetCH1_Y);
			vMark_Right[1].SetX(dObjectCH1_X);
			vMark_Right[1].SetY(dObjectCH1_Y);

			dRightDis = vMark_Right[0].Distance(vMark_Right[1]);
		}
		else
		{
			dRightDis = sqrt(m_BendInspectResultInfo.m_dRx * m_BendInspectResultInfo.m_dRx 
							+ m_BendInspectResultInfo.m_dRy * m_BendInspectResultInfo.m_dRy);
		}
		m_BendInspectResultInfo.m_dDistanceR = dRightDis + (BendInfo.m_bBendResultOffset ? BendInfo.m_dRightDisOffset:0.0);

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeRDis[1];

		if ( (m_BendInspectResultInfo.m_dDistanceR >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDistanceR <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("RightDistance_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Rdis超限(%.4f),"),m_BendInspectResultInfo.m_dDistanceR);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

		//添加变量用于前端GUI显示
		//std::vector<BOOL> &bResult,std::vector<CString> &vSearchResult
		{
			bResult.push_back(bInspect);
			m_StrText.Format(_T("Rdis:%.4f"),m_BendInspectResultInfo.m_dDistanceR);
			vSearchResult.push_back(m_StrText);
		}

	}

	// 7 Target Distance
	{
		double dTarget_Dis;
		dTarget_Dis = vdDis.at(0);

		if (BendInfo.m_bBendDisOffset)
		{
			m_BendInspectResultInfo.m_dTargetDistance = dTarget_Dis + BendInfo.m_dBendTargetDisOffset;
		}
		else
		{
			m_BendInspectResultInfo.m_dTargetDistance = dTarget_Dis;
		}

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeTargetDis[1];

		if ( (m_BendInspectResultInfo.m_dTargetDistance >= dRangeMinDis) && (m_BendInspectResultInfo.m_dTargetDistance <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("TargetDistance_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Tdis超限(%.4f),"),m_BendInspectResultInfo.m_dTargetDistance);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

	}

	// 8 Object Distance
	{
		double dObject_Dis;
		dObject_Dis = vdDis.at(1);

		if (BendInfo.m_bBendDisOffset)
		{
			m_BendInspectResultInfo.m_dObjectDistance = dObject_Dis + BendInfo.m_dBendObjectDisOffset;
		}
		else
		{
			m_BendInspectResultInfo.m_dObjectDistance = dObject_Dis;
		}

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeObjectDis[1];

		if ( (m_BendInspectResultInfo.m_dObjectDistance >= dRangeMinDis) && (m_BendInspectResultInfo.m_dObjectDistance <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("ObjectDistance_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("Odis超限(%.4f),"),m_BendInspectResultInfo.m_dTargetDistance);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}

	}

	// 9. X向偏差
	{
		double dSubX_Dis = fabs(m_BendInspectResultInfo.m_dLx - m_BendInspectResultInfo.m_dRx);
		m_BendInspectResultInfo.m_dDistanceSubX = dSubX_Dis;


		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractX[1];

		if ( (m_BendInspectResultInfo.m_dDistanceSubX >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDistanceSubX <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("(Lx-Rx)_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("(Lx-Rx)超限(%.4f),"),m_BendInspectResultInfo.m_dDistanceSubX);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
	}

	// 10. Y向偏差
	{
		double dSubY_Dis = fabs(m_BendInspectResultInfo.m_dLy - m_BendInspectResultInfo.m_dRy);
		m_BendInspectResultInfo.m_dDistanceSubY = dSubY_Dis;


		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[0] + BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[0] - BendInfo.m_BendInspectRangeInfo.m_dRangeSubtractY[1];

		if ( (m_BendInspectResultInfo.m_dDistanceSubY >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDistanceSubY <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("(Ly-Ry)_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("((Ly-Ry)超限(%.4f),"),m_BendInspectResultInfo.m_dDistanceSubY);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
	}

	//11、DeltaY (LDeltaY-RDeltaY看角度)
	{
		if (m_bisFirstAlign)
		{
			m_dLastLy = m_BendInspectResultInfo.m_dLy;
			m_dLastRy = m_BendInspectResultInfo.m_dRy;
			m_BendInspectResultInfo.m_dLDeltaY = 0.0;
			m_BendInspectResultInfo.m_dRDeltaY = 0.0;
			m_bisFirstAlign = FALSE;
		}
		else
		{
			m_BendInspectResultInfo.m_dLDeltaY = m_BendInspectResultInfo.m_dLy - m_dLastLy;
			m_BendInspectResultInfo.m_dRDeltaY = m_BendInspectResultInfo.m_dRy - m_dLastRy;
			m_dLastLy = m_BendInspectResultInfo.m_dLy;
			m_dLastRy = m_BendInspectResultInfo.m_dRy;
		}
		m_BendInspectResultInfo.m_dDeltaY = m_BendInspectResultInfo.m_dLDeltaY - m_BendInspectResultInfo.m_dRDeltaY;

		double dRangeMaxDis = BendInfo.m_BendInspectRangeInfo.m_dDeltaY[0] + BendInfo.m_BendInspectRangeInfo.m_dDeltaY[2];
		double dRangeMinDis = BendInfo.m_BendInspectRangeInfo.m_dDeltaY[0] - BendInfo.m_BendInspectRangeInfo.m_dDeltaY[1];

		if ( (m_BendInspectResultInfo.m_dDeltaY >= dRangeMinDis) && (m_BendInspectResultInfo.m_dDeltaY <= dRangeMaxDis))
		{
			bInspect = TRUE;
			vbInspect.push_back(bInspect);
		}
		else
		{
			//strError += _T("(Ly-Ry)_Error,");
			CString StrTmp = _T("");
			StrTmp.Format(_T("(DeltaY超限(%.4f),"),m_BendInspectResultInfo.m_dDeltaY);
			strError += StrTmp;
			bInspect = FALSE;
			vbInspect.push_back(bInspect);
		}
	}

	for (int i = 0; i < vbInspect.size(); i++)
	{
		bInspect &= vbInspect.at(i);
	}

	if (!bInspect)
	{
		//strInfo = strError;
		strInfo = _T("尺寸超限");
	}
	

	m_BendInspectResultInfo.m_strProductOKNG = bInspect;
	return bInspect;
}

void vcBaseVisionAlign::GetBendInspectResult(BendInspectResultInfo &BendInspectResult)
{
	BendInspectResult = m_BendInspectResultInfo;
}

void vcBaseVisionAlign::GetBendInspectResultLine(BendInspectResultInfo &BendInspectResult)
{
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Enter GetBendInspectResultLine------");
	EnterCriticalSection(&m_csBendInspectResultLine);
	if (m_BendInspectResultInfoline.empty())
	{
		BendInspectResult = m_BendInspectResultInfo;
	} 
	else
	{
		BendInspectResult = m_BendInspectResultInfoline.front();

		m_BendInspectResultInfoline.erase(m_BendInspectResultInfoline.begin());
	}
	LeaveCriticalSection(&m_csBendInspectResultLine);
	VisionAlignLogRecord("D:\\TimeLog.txt", "------Leave GetBendInspectResultLine------");
}

void vcBaseVisionAlign::PostMessageUpdateBendingProcessInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_BEND_INSPECT_RESULT, TRUE, 0);

	//SendMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_BEND_INSPECT_RESULT, TRUE, 0);
	

}

void vcBaseVisionAlign::PostMessageUpdateBendingCircleInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_BEND_CIRCLE_RESULT, TRUE, 0);
}


void vcBaseVisionAlign::PostMessageUpdateBendingDetalInfo()
{
	if (NULL == m_pMainRunWnd)
	{
		return;
	}

	PostMessage(m_pMainRunWnd->GetSafeHwnd(), WM_UPDATE_BEND_DETAL_RESULT, TRUE, 0);
}


void vcBaseVisionAlign::VisionInspectBendRecord(BOOL bAlignProcess /* = TRUE */, BOOL bBendProcess /* = TRUE */, BOOL bBendCircle /* = TRUE */, int nAlignStatus /* = 0 */ )
{
	// 存储CSV
	if (!m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		return;
	}

	AlignerProcessInfo alignerProcessInfo;
	BendInspectResultInfo BendInspectResult;

	if (bAlignProcess)
	{
		GetAlignerProcessInfo(alignerProcessInfo);
	}

	if (bBendProcess)
	{
		GetBendInspectResult(BendInspectResult);
	}

	EnterCriticalSection(&m_csAlignerProcessInfoLine);
	m_apAlignerProcesInfoline.push_back(alignerProcessInfo);
	LeaveCriticalSection(&m_csAlignerProcessInfoLine);
	EnterCriticalSection(&m_csBendInspectResultLine);
	m_BendInspectResultInfoline.push_back(BendInspectResult);
	LeaveCriticalSection(&m_csBendInspectResultLine);

	if (bBendCircle)
	{
		BendInspectResult.m_dCircleRadius[0] = m_BendInspectResultInfo.m_dCircleRadius[0];
		BendInspectResult.m_dCircleRadius[1] = m_BendInspectResultInfo.m_dCircleRadius[1];
	}
	else
	{
		BendInspectResult.m_dCircleRadius[0] = 0.0;
		BendInspectResult.m_dCircleRadius[1] = 0.0;
	}


	SYSTEMTIME sys; 
	GetLocalTime( &sys ); 

	CString strTime;
	strTime.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);

	CString strProcessInfo = _T("");	
	strProcessInfo.Format(_T(" %d, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f,"), 
		alignerProcessInfo.nTimes, 
		alignerProcessInfo.dXMove,   alignerProcessInfo.dYMove,   alignerProcessInfo.dDMove,
		alignerProcessInfo.dXOffset, alignerProcessInfo.dYOffset, alignerProcessInfo.dDOffset);

	CString strBendInfo = _T("");
	strBendInfo.Format(_T(" %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f,"), 
		BendInspectResult.m_dLx,				BendInspectResult.m_dLy,
		BendInspectResult.m_dRx,				BendInspectResult.m_dRy,
		BendInspectResult.m_dDistanceL,			BendInspectResult.m_dDistanceR,		
		BendInspectResult.m_dTargetDistance,	BendInspectResult.m_dObjectDistance,
		BendInspectResult.m_dDistanceSubX,			BendInspectResult.m_dDistanceSubY,
		BendInspectResult.m_dLDeltaY,			BendInspectResult.m_dRDeltaY,			BendInspectResult.m_dDeltaY,
		BendInspectResult.m_dCircleRadius[0],	BendInspectResult.m_dCircleRadius[1]);
	//strBendInfo.Format(_T(" %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f,"), 
	//	BendInspectResult.m_dLx,				BendInspectResult.m_dLy,
	//	BendInspectResult.m_dRx,				BendInspectResult.m_dRy,
	//	BendInspectResult.m_dDistanceL,			BendInspectResult.m_dDistanceR,		
	//	BendInspectResult.m_dTargetDistance,	BendInspectResult.m_dObjectDistance,
	//	BendInspectResult.m_dDistanceSubX,			BendInspectResult.m_dDistanceSubY,
	//	BendInspectResult.m_dCircleRadius[0],	BendInspectResult.m_dCircleRadius[1]);

	CString strTemp1 = strProcessInfo + strBendInfo;

	CString strBendProductID = BendInspectResult.m_strProductID;

	//20230804	wm	增加对位结果存储
	//CString strResult;
	//if (BendInspectResult.m_strProductOKNG)
	//{
	//	strResult = _T("OK,");
	//} 
	//else
	//{
	//	strResult = _T("NG,");
	//}

	//CPlatformOptionInfo optionInfo;
	//GetPlatformOptionInfo(optionInfo);
	//
	//if (bAlignProcess)
	//{
	//	if (optionInfo.m_nBendFIsAlignFinished == 2)
	//	{
	//		strResult += _T("NoJudge,");
	//	}
	//	else
	//	{
	//		if (bAlignReult)
	//		{
	//			strResult += _T("OK,");
	//		} 
	//		else
	//		{
	//			strResult += _T("NG,");
	//		}
	//	}
	//}
	//else
	//{
	//	strResult += _T(",");
	//}
	//
	//
	//strBendInfo = strResult + strBendInfo;

	if (bAlignProcess)
	{
		if (nAlignStatus != -1)
		{
			if (nAlignStatus == 0)
			{
				strBendInfo = _T("NG,") + strBendInfo;
			} 
			else if (nAlignStatus == 1)
			{
				strBendInfo = _T("OK,") + strBendInfo;
			}
			else if (nAlignStatus == 2)
			{
				strBendInfo = _T("RETRY,") + strBendInfo;
			}
		}
		else
		{
			if (BendInspectResult.m_strProductOKNG)
			{
				strBendInfo = _T("OK,") + strBendInfo;
			} 
			else
			{
				strBendInfo = _T("NG,") + strBendInfo;
			}
		}
		
	}
	else
	{
		if (BendInspectResult.m_strProductOKNG)
		{
			strBendInfo = _T("OK,") + strBendInfo;
		} 
		else
		{
			strBendInfo = _T("NG,") + strBendInfo;
		}
	}
	


	
	if ( _T("") != strBendProductID)
	{
		strBendInfo = strBendProductID + _T(",") + strBendInfo;
	}
	else
	{
		strBendInfo = _T(",") + strBendInfo;
	}

	CString strTemp = strProcessInfo + strBendInfo;


	CFileFind findFile;
	BOOL IsFild2 = FALSE; 
	BOOL IsDir2 = FALSE;
	CString strDir  = "D:\\VisionASMLog";

	IsFild2 = findFile.FindFile(strDir);
	while (IsFild2)
	{
		IsFild2 = findFile.FindNextFile();
		IsDir2 = findFile.IsDirectory();
		if(IsDir2) break;
	}	

	if (!IsDir2)
	{
		if (!CreateDirectory(strDir, NULL))// 创建文件夹
		{
			return;
		}
	}


	CString strFileName;
	strFileName.Format("[%04d_%02d_%02d]",sys.wYear,sys.wMonth,sys.wDay);
	strFileName = strDir + _T("\\") + strFileName;

	IsFild2 = FALSE;
	IsDir2 = FALSE;

	IsFild2 = findFile.FindFile(strFileName);
	while (IsFild2)
	{
		IsFild2 = findFile.FindNextFile();
		IsDir2 = findFile.IsDirectory();
		if(IsDir2) break;
	}	

	if (!IsDir2)
	{
		if (!CreateDirectory(strFileName, NULL))// 创建文件夹
		{
			return;
		}
	}

	CString strPathFileName;
	//m_pSystempOptionConfig->m_strPlatformCustomName[m_pPlatformInfo->m_nPlatformIndex];
	//strPathFileName.Format(_T("Platform%d_Bend_Inspect.csv"),m_pPlatformInfo->m_nPlatformIndex);
	strPathFileName.Format(_T("%s_Bend_Inspect.csv"),m_pSystempOptionConfig->m_strPlatformCustomName[m_pPlatformInfo->m_nPlatformIndex]);
	CString strPath;
	strPath = strFileName + _T("\\") + strPathFileName;

	//写csv
	//判断文件是否存在
	CStdioFile file;
	CFileStatus rStatus;
	BOOL bRes = CFile::GetStatus(strPath, rStatus);
	BOOL bTemp = FALSE;

	if (!bRes)
	{
		if(!file.Open(strPath, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeWrite))
		{
			return;
		}
		file.SeekToEnd();


		CString strcsv;
		strcsv.Format(_T("Time,Times,MoveX,MoveY,MoveD,ProductX,ProductY,ProductD,ID,Result,Lx,Ly,Rx,Ry,Left_Dis,Right_Dis,Tar_Dis,Obj_Dis,X_Sub,Y_Sub,LDeltaY,RDeltaY,DeltaY,Radius1,Radius2")_T("\n"));
		//strcsv.Format(_T("Time,Times,MoveX,MoveY,MoveD,ProductX,ProductY,ProductD,ID,Result,Lx,Ly,Rx,Ry,Left_Dis,Right_Dis,Tar_Dis,Obj_Dis,X_Sub,Y_Sub,Radius1,Radius2")_T("\n"));

		file.WriteString(strcsv);
		file.Close();

		bTemp = TRUE;

	}

	if (!file.Open(strPath, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeWrite))
	{
		return;
	}
	file.SeekToEnd();


	if (m_nAlignTime == 1)
	{
		if (bTemp)
		{
			CString strcsv;
			strcsv.Format(_T(" %s, %s")_T("\n"), strTime, strProcessInfo + strBendInfo);
			file.WriteString(strcsv);
			file.Close();
		}
		else
		{
			CString strcsv;
			strcsv.Format(_T(" %s, %s")_T("\n"), strTime, strProcessInfo + strBendInfo);
			file.WriteString(strcsv);
			file.Close();
		}
	}
	else
	{
		CString strcsv;
		strcsv.Format(_T(" %s, %s")_T("\n"), strTime, strProcessInfo + strBendInfo);
		file.WriteString(strcsv);
		file.Close();
	}

}

void vcBaseVisionAlign::VisionInspectBendRecordFixed(CString &strInfo,BOOL bAllSteoage,BOOL bAlignProcess, BOOL bBendProcess, BOOL bBendCircle )
{
	// 存储CSV
	if (!m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		return;
	}

	AlignerProcessInfo alignerProcessInfo;
	BendInspectResultInfo BendInspectResult;

	if (bAlignProcess)
	{
		GetAlignerProcessInfo(alignerProcessInfo);
	}

	if (bBendProcess)
	{
		GetBendInspectResult(BendInspectResult);
	}

	if (bBendCircle)
	{
		BendInspectResult.m_dCircleRadius[0] = m_BendInspectResultInfo.m_dCircleRadius[0];
		BendInspectResult.m_dCircleRadius[1] = m_BendInspectResultInfo.m_dCircleRadius[1];
	}
	else
	{
		BendInspectResult.m_dCircleRadius[0] = 0.0;
		BendInspectResult.m_dCircleRadius[1] = 0.0;
	}


	SYSTEMTIME sys; 
	GetLocalTime( &sys ); 

	CString strTime;
	strTime.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);

	CString strProcessInfo = _T("");	
	strProcessInfo.Format(_T(" %d, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f,"), 
		alignerProcessInfo.nTimes, 
		alignerProcessInfo.dXMove,   alignerProcessInfo.dYMove,   alignerProcessInfo.dDMove,
		alignerProcessInfo.dXOffset, alignerProcessInfo.dYOffset, alignerProcessInfo.dDOffset);

	CString strBendInfo = _T("");
	strBendInfo.Format(_T(" %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f,"), 
		BendInspectResult.m_dLx,				BendInspectResult.m_dLy,
		BendInspectResult.m_dRx,				BendInspectResult.m_dRy,
		BendInspectResult.m_dDistanceL,			BendInspectResult.m_dDistanceR,		
		BendInspectResult.m_dTargetDistance,	BendInspectResult.m_dObjectDistance,
		BendInspectResult.m_dDistanceSubX,			BendInspectResult.m_dDistanceSubY,
		BendInspectResult.m_dLDeltaY,			BendInspectResult.m_dRDeltaY,			BendInspectResult.m_dDeltaY,
		BendInspectResult.m_dCircleRadius[0],	BendInspectResult.m_dCircleRadius[1]);
	/*strBendInfo.Format(_T(" %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f, %.4f,"), 
	BendInspectResult.m_dLx,				BendInspectResult.m_dLy,
	BendInspectResult.m_dRx,				BendInspectResult.m_dRy,
	BendInspectResult.m_dDistanceL,			BendInspectResult.m_dDistanceR,		
	BendInspectResult.m_dTargetDistance,	BendInspectResult.m_dObjectDistance,
	BendInspectResult.m_dDistanceSubX,			BendInspectResult.m_dDistanceSubY,
	BendInspectResult.m_dCircleRadius[0],	BendInspectResult.m_dCircleRadius[1]);*/

	CString strTemp1 = strProcessInfo + strBendInfo;

	CString strBendProductID = BendInspectResult.m_strProductID;

	if (BendInspectResult.m_strProductOKNG)
	{
		strBendInfo = _T("OK,") + strBendInfo;
	} 
	else
	{
		strBendInfo = _T("NG,") + strBendInfo;
	}

	if ( _T("") != strBendProductID)
	{
		strBendInfo = strBendProductID + _T(",") + strBendInfo;
	}
	else
	{
		strBendInfo = _T(",") + strBendInfo;
	}

	CString strTemp = strProcessInfo + strBendInfo;


	CFileFind findFile;
	BOOL IsFild2 = FALSE; 
	BOOL IsDir2 = FALSE;
	CString strDir  = "D:\\VisionASMLog";

	IsFild2 = findFile.FindFile(strDir);
	while (IsFild2)
	{
		IsFild2 = findFile.FindNextFile();
		IsDir2 = findFile.IsDirectory();
		if(IsDir2) break;
	}	

	if (!IsDir2)
	{
		if (!CreateDirectory(strDir, NULL))// 创建文件夹
		{
			return;
		}
	}


	CString strFileName;
	strFileName.Format("Platform_Bend_Inspect");
	strFileName = strDir + _T("\\") + strFileName;

	IsFild2 = FALSE;
	IsDir2 = FALSE;

	IsFild2 = findFile.FindFile(strFileName);
	while (IsFild2)
	{
		IsFild2 = findFile.FindNextFile();
		IsDir2 = findFile.IsDirectory();
		if(IsDir2) break;
	}	

	if (!IsDir2)
	{
		if (!CreateDirectory(strFileName, NULL))// 创建文件夹
		{
			return;
		}
	}

	CString strPathFileName;
	strPathFileName.Format(_T("%s_Bend_Inspect.csv"),m_pSystempOptionConfig->m_strPlatformCustomName[m_pPlatformInfo->m_nPlatformIndex]);
	//strPathFileName.Format(_T("Platform%d_Bend_Inspect.csv"),m_pPlatformInfo->m_nPlatformIndex);

	CString strPath;
	strPath = strFileName + _T("\\") + strPathFileName;

	if (bAllSteoage)
	{
		//写csv
		//判断文件是否存在
		CStdioFile file;
		CFileStatus rStatus;
		BOOL bRes = CFile::GetStatus(strPath, rStatus);
		BOOL bTemp = FALSE;

		if (!bRes)
		{
			if(!file.Open(strPath, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeWrite))
			{
				return;
			}
			file.SeekToEnd();


			CString strcsv;
			strcsv.Format(_T("Time,Times,MoveX,MoveY,MoveD,ProductX,ProductY,ProductD,ID,OK/NG,Lx,Ly,Rx,Ry,Left_Dis,Right_Dis,Tar_Dis,Obj_Dis,X_Sub,Y_Sub,LDeltaY,RDeltaY,DeltaY,Radius1,Radius2")_T("\n"));
			//strcsv.Format(_T("Time,Times,MoveX,MoveY,MoveD,ProductX,ProductY,ProductD,ID,OK/NG,Lx,Ly,Rx,Ry,Left_Dis,Right_Dis,Tar_Dis,Obj_Dis,X_Sub,Y_Sub,Radius1,Radius2")_T("\n"));
			file.WriteString(strcsv);
			file.Close();

			bTemp = TRUE;

		}

		if (!file.Open(strPath, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeWrite))
		{
			return;
		}
		file.SeekToEnd();


		if (m_nAlignTime == 1)
		{
			if (bTemp)
			{
				CString strcsv;
				strcsv.Format(_T(" %s, %s")_T("\n"), strTime, strProcessInfo + strBendInfo);
				strInfo = strInfo + strcsv;
				file.WriteString(strInfo);
				file.Close();
			}
			else
			{
				CString strcsv;
				strcsv.Format(_T(" %s, %s")_T("\n"), strTime, strProcessInfo + strBendInfo);
				strInfo = strInfo + strcsv;
				file.WriteString(strInfo);
				file.Close();
			}
		}
		else
		{
			CString strcsv;
			strcsv.Format(_T(" %s, %s")_T("\n"), strTime, strProcessInfo + strBendInfo);
			strInfo = strInfo + strcsv;
			file.WriteString(strInfo);
			file.Close();
		}
	} 
	else
	{
		CString strcsv;
		strcsv.Format(_T(" %s, %s")_T("\n"), strTime, strProcessInfo + strBendInfo);
		strInfo = strInfo + strcsv;
	}
	

}

// BOOL vcBaseVisionAlign::BendingProductID(CString& strProductID)
// {
// 	return FALSE;
// }

// BOOL vcBaseVisionAlign::CommunicateGetAlignProcessProductID(CString& strProductID)
