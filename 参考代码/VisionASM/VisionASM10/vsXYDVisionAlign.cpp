// svXYDVisionAilgner.cpp: implementation of the vcXYDVisionAlign class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VisionASM.h"
#include "vsXYDVisionAlign.h"
#include "svXMLConfigurator.h"
#include "DlgSearchFailWarning.h"
#include "DlgManualSearch.h"
#include "DlgManualSearchPos1.h"
#include "DlgManualSearchPos2.h"

#include "VisionASMDlg.h"
#include <algorithm>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

void VCRemoveFile(CString strFilePath);


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CString g_strPLCCMD[7] = { _T(""), _T("CALIB"), _T("CALIB_MOV_OK"), _T(""), _T("OBJ_SEARCH"),_T("TAR_SEARCH"), _T("ALN_MOV_OK") };
CString g_strTrigerCMD[2] = { _T("NOT_TRIGERED"), _T("TRIGERED") };
vcXYDVisionAlign::vcXYDVisionAlign()
{
	m_nCurCalibrateIndex = 0;
	m_nCurAlignerTimesIndex = 0;
	m_dTotalAlignTime = 0.0;
	m_nCurFOBC_Index = 0;
	m_nCurFBIS_Index = 0;
	m_nCurFTGC_Index = 0;
	m_nCurFCBP_Index = 0;
	m_nCurFCBS_Index = 0;
	m_nCurFCBS_XY_Index = 0;
	m_nCurFCBS_Angle_Index = 0;
	m_nCurFCHB_Index = 0;
	
	m_nCurFCLB_Code_Index = 0;

	m_FPMI = -1;
	m_FPMIMIN = 0;
}

vcXYDVisionAlign::~vcXYDVisionAlign()
{

}

BOOL vcXYDVisionAlign::OnLightOnOff(int nCurCmd)
{
	if (1)
	{
		CString strRecordInfo;  //日志
		CString strTemp;

		SYSTEMTIME sys; 
		GetLocalTime( &sys ); 
		strRecordInfo.Format("\n[%02d_%02d_%02d_%02d_%02d_%03d]\n******光源切换Start******\n",
			sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);

		scTimer timer;  //超时判断

		//1、通过参数遍历找出当前指令需要进行控制的光源控制器
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		PhotoLightCtrlSet cObj = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetLightCtrlInfo();
		CurCMDPhotoLightCtrlSet cChild = cObj.m_vCmdLightCtrlInfo[nCurCmd]; //当前指令控制对象
		vector<int> vLightCtrlEnableCount;
		for (int i = 0; i < cChild.m_vCmdLightCtrlEnable.size(); ++i)//8个控制器
		{
			if(cChild.m_vCmdLightCtrlEnable[i])
			{
				vLightCtrlEnableCount.push_back(i);
			}
		}

		//2、遍历需要进行控制的光源控制器的有效通道进行控制
		vector<int> vnLightCtrlCount;
		for (int i = 0; i < vLightCtrlEnableCount.size(); ++i)
		{
			std::vector<int> vnChannelIndex;
			std::vector<int> vnIntensity;
			std::vector<BOOL> vChannelCtrlIndex;
			std::vector<BOOL> vChannelOnorOff;
			int nCtrlIndex = vLightCtrlEnableCount.at(i);                  //当前控制器编号
			vChannelCtrlIndex = cChild.m_vbChannelCtrlIndex[nCtrlIndex];  //当前控制器通道控制是否启用
			vChannelOnorOff = cChild.m_vbChannelOnorOff[nCtrlIndex];     //当前控制器通道是亮还是灭
			LightCtrlParam cParam = m_pSystempOptionConfig->m_sysOptLightConfig.m_lightCtrlParam[nCtrlIndex];  //当前控制器参数

			for (int j = 0; j < vChannelCtrlIndex.size(); ++j) //8通道循环判断
			{
				if (vChannelCtrlIndex[j] && j < cParam.m_nMaxChannels)
				{
					vnChannelIndex.push_back(j);
					int nIntensity = vChannelOnorOff[j] ? cParam.m_nChannelValue[j]:0;
					vnIntensity.push_back(nIntensity);
				}
			}

			if (vnChannelIndex.size())//准备切换
			{
				m_vstrLightCtrlInfo[nCtrlIndex] = _T(""); 
				m_vbLightCtrSucceed[nCtrlIndex] = FALSE;
				m_vbLightCtrlEnd[nCtrlIndex] = FALSE;
				m_vvnChannelIndex[nCtrlIndex] = vnChannelIndex;
				m_vvnIntensity[nCtrlIndex] = vnIntensity;
				m_vbLightCtrlStart[nCtrlIndex] = TRUE;
				vnLightCtrlCount.push_back(nCtrlIndex);
			}	
		}

		//3、等待光源切换结果反馈（OK、NG、超时）
		BOOL bFinished = FALSE;
		BOOL bResult   = TRUE;
		while (!bFinished)
		{
			if (m_bStopNow)
			{
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					strRecordInfo += _T("光源切换失败：软件停止");
					strRecordInfo += _T("\n******光源切换End******\n");
					VisionAlignLogRecord(m_strAlignProcessData, strRecordInfo,FALSE);
				}
				return FALSE;
			}

			//无可控时默认切换成功
			if (0 == vnLightCtrlCount.size())
			{
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					strRecordInfo += _T("光源切换成功：无有效控制通道");
					strRecordInfo += _T("\n******光源切换End******");
					VisionAlignLogRecord(m_strAlignProcessData, strRecordInfo,FALSE);
				}
				return TRUE;
			}

			if(timer.GetTime(FALSE) > 3) //超时失败(3s)
			{
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					strRecordInfo += _T("光源失败：超时3s");
					strRecordInfo += _T("\n******光源切换End******");
					VisionAlignLogRecord(m_strAlignProcessData, strRecordInfo,FALSE);
				}
				return FALSE;
			}

			BOOL bEnd = TRUE;
			for (int i = 0; i < vnLightCtrlCount.size(); ++i )
			{
				int nCtrlIndex = vnLightCtrlCount.at(i);
				bEnd = bEnd & m_vbLightCtrlEnd[nCtrlIndex];
			}
			if (bEnd)
			{
				bFinished = TRUE;
			}
		}

		for (int i = 0; i < vnLightCtrlCount.size(); ++i )
		{
			int nCtrlIndex = vnLightCtrlCount.at(i);
			bResult = bResult & m_vbLightCtrSucceed[nCtrlIndex];
			strRecordInfo += m_vstrLightCtrlInfo[nCtrlIndex]; //线程切换日志记录
		}

		// 记录光源切换时间
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			if (bResult)
			{
				strTemp.Format(_T("光源切换成功(耗时：%0.3f ms)"),timer.GetTimeMilli(FALSE),FALSE);
				strRecordInfo += strTemp;
			}
			else
			{
				strTemp.Format(_T("光源切换失败(耗时：%0.3f ms)"),timer.GetTimeMilli(FALSE),FALSE);
				strRecordInfo += strTemp;
			}

			strRecordInfo += _T("\n******光源切换End******");
			VisionAlignLogRecord(m_strAlignProcessData, strRecordInfo,FALSE);
		}

		return bResult;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CommunicateGetAlignProcessProductID(CString& strProductID)
{
	VisionAlignLogRecord("D:\\TimeLog.txt", "读二维码开始");

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);
	CBendInfo BendInfo = curProductData.m_pAlignerParam->GetBendInfo();
	std::vector<int> vnReceivedData;
	CString strSend;

	//cout<<BendInfo.m_bBendInspectSnCodeInvert<<endl;
	//cout<<BendInfo.m_bBendInspectSnCodeLength<<endl;


	int nOffSetMul = 0;

	BOOL bEnableMulReg= m_pPlatformInfo->m_bEnableMulRegTrigger;
	if(bEnableMulReg)
	{
		//nOffSetMul = m_XYDCommProtocol.m_nCurRegTriggerIndex*RREG_KEYENCE_PLC_REG_NUMS;
		nOffSetMul =RREG_KEYENCE_PLC_REG_NUMS*m_XYDCommProtocol.m_nCurRegTriggerIndex;
		if(m_XYDCommProtocol.m_nCurRegTriggerIndex>=0 && m_XYDCommProtocol.m_nCurRegTriggerIndex<optionInfo.m_vnMulRegTriggerSet.size())
		{
			nOffSetMul = optionInfo.m_vnMulRegTriggerSet[m_XYDCommProtocol.m_nCurRegTriggerIndex].m_nMulRegOffset;
		}
	}

	if (m_XYDCommProtocol.GetIsEnableIDRead())
	{
		nOffSetMul = 0;
		BendInfo.m_bBendInspectSnCodeLength = m_XYDCommProtocol.GetPLCIDLength();
		BendInfo.m_bBendInspectSnCodeInvert = m_XYDCommProtocol.GetIsEnableIDInvert();
	}

	//打包读取寄存器
	if(!m_XYDCommProtocol.PackPlcReadQRCode(strSend,nOffSetMul,BendInfo.m_bBendInspectSnCodeLength))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}



	// 发送读取命令，接收PLC回复
	BOOL bReceived;
	CString strInfo;
	CommStatus nCommStatus = eCommSucceed;
	bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}



	//VisionAlignLogRecord(_T("D:\\VisionASMLog\\SNCode.txt"),"\r\n");

	//解析读取的寄存器信息
	CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcReadQRCode(strInfo,vnReceivedData, BendInfo.m_bBendInspectSnCodeLength,BendInfo.m_bBendInspectSnCodeInvert);
	if(answeredStatus != eAswSucceed)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}
	CString str2DCoedInfo = "";
	CString strtmp;
	if(BendInfo.m_bBendInspectSnCodeLength<=vnReceivedData.size())
	for (int i=0;i<BendInfo.m_bBendInspectSnCodeLength;i++)
	{
		int nData = vnReceivedData.at(i);

		if(nData<32)
		{
			strtmp = "";
		}
		else
		{
			char ch = (char)nData;
			CString strchar(ch);
			strtmp = strchar;
		}

		str2DCoedInfo+=strtmp;
	}
	else
	{
		return FALSE;
	}

	m_bStatusBar = TRUE;

	SetStatusBarInfo(m_bStatusBar,_T("读码成功:"),str2DCoedInfo);
	PostMessageUpdateStatusBarInfo();

	strProductID=	m_strProductID = str2DCoedInfo;
	CString strIDleng;
	strIDleng.Format("%d",strProductID.GetLength());
	VisionAlignLogRecord("D:\\TimeLog.txt", "读二维码结束:"+strProductID);
	VisionAlignLogRecord("D:\\TimeLog.txt", "长度;" + strIDleng);
	return TRUE;
}

BOOL vcXYDVisionAlign::CommunicateGetAlignProcessProductSTATION(CString& strProductSTATION,CString& strStartIime,CString& strEndIime,CString& strProsessingIime,CString& strInspectStation)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);
	CBendInfo BendInfo = curProductData.m_pAlignerParam->GetBendInfo();

	int nOffSetMul = 0;
	BOOL bEnableMulReg= m_pPlatformInfo->m_bEnableMulRegTrigger;
	if(bEnableMulReg)
	{
		//nOffSetMul = m_XYDCommProtocol.m_nCurRegTriggerIndex*RREG_KEYENCE_PLC_REG_NUMS;
		nOffSetMul =RREG_KEYENCE_PLC_REG_NUMS*m_XYDCommProtocol.m_nCurRegTriggerIndex;
		if(m_XYDCommProtocol.m_nCurRegTriggerIndex>=0 && m_XYDCommProtocol.m_nCurRegTriggerIndex<optionInfo.m_vnMulRegTriggerSet.size())
		{
			nOffSetMul = optionInfo.m_vnMulRegTriggerSet[m_XYDCommProtocol.m_nCurRegTriggerIndex].m_nMulRegOffset;
		}
	}

	BOOL bReceived;
	CString strSend,strInfo,strtmp;
	CommStatus nCommStatus = eCommSucceed;
	CmdAnsweredStatus answeredStatus = eAswSucceed;

	//折弯工位编号
	if (BendInfo.m_bEnableReadWsInfo)
	{
		std::vector<int> vnReceivedData;
		CString str2DCoedInfo = "";
		VisionAlignLogRecord("D:\\TimeLog.txt", "读折弯工位开始");
		//打包读取寄存器
		if(!m_XYDCommProtocol.PackPlcReadSTATIONCode(strSend,nOffSetMul,1))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		// 发送读取命令，接收PLC回复
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		//VisionAlignLogRecord(_T("D:\\VisionASMLog\\SNCode.txt"),"\r\n");
		//解析读取的寄存器信息
		answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcReadQRCode(strInfo,vnReceivedData, 1,1);
		if(answeredStatus != eAswSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		if(1<=vnReceivedData.size())
		{
			for (int i=0;i<1;i++)
			{
				int nData = vnReceivedData.at(i);

				if(0< nData && nData<20)
				{
					strtmp.Format("%d",nData);
				}
				else
				{
					strtmp.Format("0");
				}

				str2DCoedInfo+=strtmp;
			}
		}
		else
		{
			//return FALSE;
			str2DCoedInfo = "0";
		}
		m_bStatusBar = TRUE;
		SetStatusBarInfo(m_bStatusBar,_T("读工位成功:"),str2DCoedInfo);
		PostMessageUpdateStatusBarInfo();
		strProductSTATION = str2DCoedInfo;
		VisionAlignLogRecord("D:\\TimeLog.txt", "读折弯工位结束:"+str2DCoedInfo);
	}

	//本压工位编号
	if (BendInfo.m_bEnableReadInspectWsInfo)
	{
		std::vector<int> vnReceivedData;
		CString str2DCoedInfo = "";
		VisionAlignLogRecord("D:\\TimeLog.txt", "读本压工位开始");
		//打包读取寄存器
		if(!m_XYDCommProtocol.PackPlcReadInspectStationCode(strSend,nOffSetMul,1))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		// 发送读取命令，接收PLC回复
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		//VisionAlignLogRecord(_T("D:\\VisionASMLog\\SNCode.txt"),"\r\n");
		//解析读取的寄存器信息
		answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcReadQRCode(strInfo,vnReceivedData, 1,1);
		if(answeredStatus != eAswSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		if(1<=vnReceivedData.size())
		{
			for (int i=0;i<1;i++)
			{
				int nData = vnReceivedData.at(i);

				if(0< nData && nData<20)
				{
					strtmp.Format("%d",nData);
				}
				else
				{
					strtmp.Format("0");
				}

				str2DCoedInfo+=strtmp;
			}
		}
		else
		{
			//return FALSE;
			str2DCoedInfo = "0";
		}
		strInspectStation = str2DCoedInfo;
		VisionAlignLogRecord("D:\\TimeLog.txt", "读本压工位结束:"+str2DCoedInfo);
	}

	//生产开始时间
	if (BendInfo.m_bEnableReadStartTimeInfo)
	{
		std::vector<int> vnReceivedData;
		CString str2DCoedInfo = "";
		//增加读取生产时间指令
		VisionAlignLogRecord("D:\\TimeLog.txt", "读生产开始时间");
		//打包读取寄存器
		if(!m_XYDCommProtocol.PackPlcReadTimeCode(strSend,nOffSetMul,20,6))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		// 发送读取命令，接收PLC回复
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		//解析读取的寄存器信息
		answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcReadTimeCode(strInfo,vnReceivedData,12,1);
		if(answeredStatus != eAswSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		if(1<=vnReceivedData.size())
		{
			for (int i=0;i<vnReceivedData.size();i++)
			{
				int nData = vnReceivedData.at(i);
				if (i==3)
				{
					str2DCoedInfo+=_T("_");
				} 
				if (nData<10)
				{
					strtmp.Format("0%d",nData);
				} 
				else
				{
					strtmp.Format("%d",nData);
				}

				str2DCoedInfo+=strtmp;
			}
		}
		else
		{
			//return FALSE;
		}
		strStartIime = str2DCoedInfo;
		VisionAlignLogRecord("D:\\TimeLog.txt", "读生产开始时间结束:"+str2DCoedInfo);
	}

	//生产结束时间
	if (BendInfo.m_bEnableReadEndTimeInfo)
	{
		std::vector<int> vnReceivedData;
		CString str2DCoedInfo = "";
		VisionAlignLogRecord("D:\\TimeLog.txt", "读生产结束时间开始");
		//打包读取寄存器
		if(!m_XYDCommProtocol.PackPlcReadTimeCode(strSend,nOffSetMul,30,6))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		// 发送读取命令，接收PLC回复
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		//解析读取的寄存器信息
		answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcReadTimeCode(strInfo,vnReceivedData,12,1);
		if(answeredStatus != eAswSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		if(1<=vnReceivedData.size())
		{
			for (int i=0;i<vnReceivedData.size();i++)
			{
				int nData = vnReceivedData.at(i);
				if (i==3)
				{
					str2DCoedInfo+=_T("_");
				}
				if (nData<10)
				{
					strtmp.Format("0%d",nData);
				} 
				else
				{
					strtmp.Format("%d",nData);
				}

				str2DCoedInfo+=strtmp;
			}
		}
		else
		{
			//return FALSE;
		}
		strEndIime = str2DCoedInfo;
		VisionAlignLogRecord("D:\\TimeLog.txt", "读生产结束时间结束:"+str2DCoedInfo);
	}

	//生产总时间
	if (BendInfo.m_bEnableReadProsessingTimeInfo)
	{
		std::vector<int> vnReceivedData;
		CString str2DCoedInfo = "";
		VisionAlignLogRecord("D:\\TimeLog.txt", "读生产总时间开始");
		//打包读取寄存器
		if(!m_XYDCommProtocol.PackPlcReadTimeCode(strSend,nOffSetMul,40,2))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		// 发送读取命令，接收PLC回复
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		//解析读取的寄存器信息
		answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcReadTimeCode(strInfo,vnReceivedData,4,1);
		if(answeredStatus != eAswSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		if(1<=vnReceivedData.size())
		{
			for (int i=0;i<vnReceivedData.size();i++)
			{
				int nData = vnReceivedData.at(i);
				if (i == 0)
				{
					strtmp.Format("%d",nData);
					str2DCoedInfo+=strtmp;
					VisionAlignLogRecord("D:\\TimeLog.txt", "读完成方式为:"+str2DCoedInfo);
					str2DCoedInfo = "";
				} 
				else
				{
					strtmp.Format("%d",nData);
					str2DCoedInfo+=strtmp;

				}
			}
		}
		else
		{
			//return FALSE;
		}
		strProsessingIime = str2DCoedInfo;
		VisionAlignLogRecord("D:\\TimeLog.txt", "读生产总时间结束:"+str2DCoedInfo);
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlnTargetSearchCandidateExFPMI_Ex(int nPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VPMI:");
	GetCommCommandName(strCmd);

	nPosIndex >22320 ? nPosIndex = 22320:nPosIndex = nPosIndex;
	//nPosIndex <5 ? nPosIndex =5:nPosIndex =nPosIndex;

	// 获取时间	
	SYSTEMTIME tm;
	GetLocalTime(&tm);
	int m_StopMin =(tm.wDay-1) * 1440 + tm.wHour * 60 + tm.wMinute;
	m_FPMI = m_StopMin;
	m_FPMIMIN = nPosIndex;
	if (!SETFPMI())
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = _T("失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
	}


	m_bStatusBar = TRUE;
	
	m_strStatusBarInfo1 = _T("成功:");
	m_strStatusBarInfo2.Format("设置权限时间%d分钟",nPosIndex);
	//m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();

	return TRUE;


}

// 两个及两个以上相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetSearchCandidateExFTGC(int nStartPatIndex)
{
	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VTGC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
			return FALSE;
		}    	
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;

	


	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nStartPatIndex);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter /*&& (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
				vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (nPosNum != m_vpTargetPlatformAxisPos.size() || m_vpTargetPlatformAxisPos.at(0) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(0));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))		
	if (!bCommuciateGetPlatformAxisAbsPos)	
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			SetTargetPlatformPos_MultiEx(pPlatformAxisPos,i);
			SetTargetPlatformPos(pPlatformAxisPos,i);
			SetTempTargetPlatformAxisPos(i,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,i);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	//	Sleep(1000);

	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;

	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eTargetSearch);	// 

		nAllPosIndex = nPosIndex;
		vnAllPosIndex.push_back(nAllPosIndex);
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		//         //HideExtraGraphics(vnAllPosIndex);
		//         ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);
	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		//         //HideExtraGraphics(vnPosIndex);
		//         ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
	BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (bTargetSearchCandidate == FALSE)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = i;
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bTargetSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[0];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = TARGETCANDIDATENUM-1;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{
				if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
				{
					continue;
				}

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = i;
					m_vnTargetSearchStartPatIndex[nPosIndex] = j;
					m_vnTargetSearchEndPatIndex[nPosIndex] = j;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				if (bSearchSucceed)
				{
					break;
				}
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}

	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
				BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
				if (bTargetSearchCandidate == FALSE)
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = i;
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
				else
				{
					if (bTargetSearchSync == TRUE)
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
						{
							nTempStartPatIndex = nStartPatIndex;
						}
						else if (nStartPatIndex == 9)
						{
							nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[0];
						}
						else
						{
							nTempStartPatIndex = 0;
						}
						nTempEndPatIndex = TARGETCANDIDATENUM-1;

						int j = 0;
						for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
						{
							if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
							{
								continue;
							}

							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = i;
								m_vnTargetSearchStartPatIndex[nPosIndex] = j;
								m_vnTargetSearchEndPatIndex[nPosIndex] = j;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
							if (bSearchSucceed)
							{
								break;
							}
						}
					}
					else
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = i;
							if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
							{
								nTempStartPatIndex = nStartPatIndex;
							}
							else if (nStartPatIndex == 9)
							{
								nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
							}
							else
							{
								nTempStartPatIndex = 0;
							}
							nTempEndPatIndex = TARGETCANDIDATENUM-1;

							m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
							m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}

				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		// SendCommInfo(CMD_TGG_SEARCH_SUCCEED);

		m_bStatusBar = TRUE;
		/*m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();*/
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		for (int k = GetPosNum()/2; k<GetPosNum(); k++)
		{
			vnHomoPosIndex.push_back(k);
		}

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					//	ReportTargetSearchResultFTGM(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					//return FALSE;
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		//         SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		//         PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		//         {
		//             SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // 设定、显示目标定位结果文字，全部0/1/2/3图像
		//         SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		//         PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
	}
	else
	{
		// 设定、显示结果图形
		//         SetGuiAlnTargetImageMarkPos(vnPosIndex);
		//         PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		//         {
		//             SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // SY
		//         SetShowGuiTargetImageMarkPos(vnPosIndex);
		//         PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
	}
	//if ((m_bIsTargetCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsTargetLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//{
	//ShowAllGuiAlnTargetExtraGraphics(nCurProdcutIndex,vnPosIndex);
	//ShowExtraGuiToDisplay(vnPosIndex, TRUE,0);
	//}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (bSearchSucceed)
	{
		/*m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();*/
	}
	else
	{
		// SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = m_StrSearchErrorInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		m_strStatusBarInfo1 += m_StrSearchErrorInfo;
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		// 4. 失败，关闭定位
		// CloseSearch();
		//		CloseSearch(vCamIndex);

		//		RecordTargetSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 4. 关闭定位
	// CloseSearch();
	//	CloseSearch(vCamIndex);

	// 5. 设置对位工具
	m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}

	// 计算目标距离
	//CalculateTargetDistance(); 
	if (!CheckTargetDistance())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//RecordTargetSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{	
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageTargetSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}			
		}

		return FALSE;
	}

	//RecordTargetSizeIndfo(TRUE, TRUE);

	if (!CheckTargetAngle())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());


	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	//for (int i=0;i<vnPosIndex.size();i++)
	//{
	//	int nIndx=vnPosIndex.at(i);
	//	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	//	{
	//		m_vbIsTargetPosSearchFinished.at(nIndx-GetPosNum()/2)=TRUE;
	//	}
	//	else
	//	{
	//		m_vbIsTargetPosSearchFinished.at(nIndx)=TRUE;
	//	}

	//}

	//BOOL bAllTargetPosSearch=TRUE;
	//for (int i=0;i<m_vbIsTargetPosSearchFinished.size();i++)
	//{
	//	bAllTargetPosSearch=bAllTargetPosSearch && m_vbIsTargetPosSearchFinished.at(i);
	//}
	//m_bAllTargetPosSearchSuccess=bAllTargetPosSearch;


	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1 /*&& m_bAllObjectPosSearchSuccess && m_bAllTargetPosSearchSuccess*/)
	{


		/*for (int i=0;i<m_vbIsTargetPosSearchFinished.size();i++)
		{
		m_vbIsTargetPosSearchFinished.at(i) = FALSE;
		}
		m_bAllTargetPosSearchSuccess = FALSE;*/
		BOOL m_bFOBCAndFTGC = ExecuteAlignAfterFOBCAndFTGC(vnPosIndex,2);
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return m_bFOBCAndFTGC;
	}

	if (bTargetSearchSync)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(TRUE, m_vnTargetSearchSuccessPatIndex[0]);
	}
	else
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(TRUE, -1);
	}
	if (bSearchSucceed)
	{
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}

	return TRUE;
}








void vcXYDVisionAlign::DestroyWorkThread()
{
	m_bStopNow = TRUE;
	//if (m_pComm != NULL)
	//{
	//	if (m_pComm->StopRecieveData())
	//	{
	//		m_CommStatus = eCommStop;
	//	}
	//}
	StopReceiveComm();


	if (m_pWorkThread)
	{
		m_pWorkThread->ResumeThread();
		m_bExitWorkThread = TRUE;
		if (WaitForSingleObject(m_pWorkThread->m_hThread,WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
		{
			TerminateThread(m_pWorkThread->m_hThread, 0);
		}
		m_pWorkThread = NULL;
	}

	if (m_pManualSearchThread)
	{
		m_bExitManualSearchThread = TRUE;
		if (WaitForSingleObject(m_pManualSearchThread->m_hThread,WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
		{
			TerminateThread(m_pManualSearchThread->m_hThread, 0);
		}
		m_pManualSearchThread = NULL;
	}

	// 	if (m_pHideSearchGuiThread)
	// 	{
	//         m_bExitHideSearchGuiThread = TRUE;
	// 		if (WaitForSingleObject(m_pHideSearchGuiThread->m_hThread, WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
	// 		{
	// 			TerminateThread(m_pHideSearchGuiThread->m_hThread, 0);
	// 		}
	//         m_pHideSearchGuiThread = NULL;
	// 	}

	// F
	int i = 0;
	// 	for(i = 0; i < m_vpHideSearchGUIObject.size(); i++)
	// 	{
	// 		m_vpHideSearchGuiThread[i]->ResumeThread();
	// 
	// 		m_vbExitHideSearchGuiThread[i] = TRUE;
	// 
	// 		if (WaitForSingleObject((m_vpHideSearchGuiThread[i])->m_hThread, WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
	// 		{
	// 			TerminateThread((m_vpHideSearchGuiThread[i])->m_hThread, 0);
	// 		}
	// 		m_vpHideSearchGuiThread[i] = NULL;
	// 	}

	for(i = 0; i < m_vpSearchObject.size(); i++)
	{
		m_vpSearchThread[i]->ResumeThread();

		m_vbExitSearchThread[i] = TRUE;

		if (WaitForSingleObject((m_vpSearchThread[i])->m_hThread, WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
		{
			TerminateThread((m_vpSearchThread[i])->m_hThread, 0);
		}
		m_vpSearchThread[i] = NULL;
	}

	for(i = 0; i < m_vpSaveImageObject.size(); i++)
	{
		m_vpSaveImageThread[i]->ResumeThread();

		m_vbExitSaveImageThread[i] = TRUE;

		if (WaitForSingleObject((m_vpSaveImageThread[i])->m_hThread, WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
		{
			TerminateThread((m_vpSaveImageThread[i])->m_hThread, 0);
		}
		m_vpSaveImageThread[i] = NULL;
	}

	for(i = 0; i < m_vpCameraExposureObject.size(); i++)
	{
		m_vpCameraExposureThread[i]->ResumeThread();

		m_vbExitCameraExposureThread[i] = TRUE;

		if (WaitForSingleObject((m_vpCameraExposureThread[i])->m_hThread, WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
		{
			TerminateThread((m_vpCameraExposureThread[i])->m_hThread, 0);
		}

		m_vpCameraExposureThread[i] = NULL;
	}

	// 	m_bExitWorkThread = TRUE;
	// 	m_bExitHideSearchGuiThread = TRUE;
	// 
	// 	if (m_pWorkThread&&m_pHideSearchGuiThread)
	// 	{
	// 		ResumeWorkThread();
	// 		WaitForSingleObject(m_pHideSearchGuiThread->m_hThread, INFINITE);
	// 		WaitForSingleObject(m_pWorkThread->m_hThread,INFINITE);
	// 	}
	if (m_pCheckRemoveFolderThread)
	{
		if (m_bCheckRemoveFolderThreadSuspend == TRUE)
		{
			m_pCheckRemoveFolderThread->ResumeThread();
			m_bCheckRemoveFolderThreadSuspend = FALSE;
		}

		m_bExitCheckRemoveFolderThread = TRUE;
		if (WaitForSingleObject(m_pCheckRemoveFolderThread->m_hThread,WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
		{
			TerminateThread(m_pCheckRemoveFolderThread->m_hThread, 0);
		}
		m_pCheckRemoveFolderThread = NULL;
		m_bCheckRemoveFolderThreadSuspend = TRUE;
	}

	for(i = 0; i < m_vpLightCtrlThread.size(); i++)
	{
		//m_vpLightCtrlThread[i]->ResumeThread();

		m_vbExitLightCtrlThread[i] = TRUE;

		if (WaitForSingleObject((m_vpLightCtrlThread[i])->m_hThread, WAIT_THREAD_QUIT_TIME) == WAIT_TIMEOUT)
		{
			TerminateThread((m_vpLightCtrlThread[i])->m_hThread, 0);
		}
		m_vpLightCtrlThread[i] = NULL;
	}
}


BOOL vcXYDVisionAlign::OnlineCalibrateFCLB(int nCalibPos, int nMarkType)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();

	CString strTempWarningType = _T("");
	CString strCmd = _T("VCLB:");
	GetCommCommandName(strCmd);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);


	// 平台为触发模式，标定时需要设置为非触发模式
	if (sysPlatformInfo.m_bCameraHardTriggerMode)
	{
		SetCameraTriggerMode(ePTNotTrigger);
	}

	// 隐藏对象结果图形			
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	std::vector<int> vnObjectPosIndex;
	int nObjectPosIndex = 0;
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nObjectPosIndex = i;
		vnObjectPosIndex.push_back(nObjectPosIndex);
	}	

	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);

	// 隐藏目标结果图形	
	std::vector<int> vnTargetPosIndex;
	int nTargetPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		if (sysPlatformInfo.m_bEnableMultiCalibExtension == TRUE)
		{
			if (i==((nCalibPos%nPosNum + nPosNum)%nPosNum))
			{
				nTargetPosIndex = i;
				vnTargetPosIndex.push_back(nTargetPosIndex);
			}
		}
		else
		{
			if (i==nCalibPos)
			{
				nTargetPosIndex = i;
				vnTargetPosIndex.push_back(nTargetPosIndex);
			}
		}

	}

	m_cVisionAlignGui.SetPosGuiInvisible(vnTargetPosIndex, eTargetSearch);




	BOOL bSucceed = FALSE;

	// 拾取系统，XYD平台，相机固定安装
	if ( (m_pPlatformInfo->m_bPlatformPick) && (m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformSepFix) )
	{	
		// 情况1：标定验证功能
		if (optionInfo.m_bEnableCalibrateCheckByAxisMoveOption)
		{
			bSucceed = OnlineCalibrate_CheckByAxisMove(nCalibPos, nMarkType);
		}
		// 情况2：全局二维码标定
		else if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
		{
			bSucceed = OnlineSingleCameraCalibrateFCLB_WholeDmCode(nCalibPos, nMarkType);
		}
		// 情况3：传统标定+二维码标定
		else
		{
			bSucceed = OnlineSingleCameraCalibrateFCLB(nCalibPos, nMarkType);
		}
	}
	else
	{		
		if ((nCalibPos == 10 || nCalibPos == 11) && sysPlatformInfo.m_bEnableMultiCalibExtension == FALSE)
		{
			bSucceed = OnSingleCameraBenchMarkRgister(nCalibPos-10, nMarkType);
		}
		else
		{
			// 情况1：标定验证功能
			if (optionInfo.m_bEnableCalibrateCheckByAxisMoveOption)
			{
				bSucceed = OnlineCalibrate_CheckByAxisMove(nCalibPos, nMarkType);
			}
			// 情况2：全局二维码标定
			else if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
			{
				bSucceed = OnlineSingleCameraCalibrateFCLB_WholeDmCode(nCalibPos, nMarkType);
			}
			// 情况3：传统标定+二维码标定
			else
			{
				bSucceed = OnlineSingleCameraCalibrateFCLB(nCalibPos, nMarkType);
			}			
		}
	}


	if (TRUE == bSucceed)
	{	
		CPlatformOptionInfo optionInfo;
		GetPlatformOptionInfo(optionInfo);
		if (optionInfo.m_bEnableCalibrateCheckByAxisMoveOption)
		{
			ReportCalibResult(TRUE);

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = _T("标定轴移动拍照验证完成");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
		}
		else
		{
			ReportCalibResult(TRUE);

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_SUCCEED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
		}
	}
	else
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		if (!m_boIsSnapImgSucceed)
		{
			m_strStatusBarInfo2 = m_strSnapImgStatuString;
		}
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	}

	// 平台为触发模式时，标定完成后恢复触发模式
	if (sysPlatformInfo.m_bCameraHardTriggerMode)
	{
		SetCameraTriggerMode(ePTHardwareTrigger);
	}

	return bSucceed;
}

BOOL vcXYDVisionAlign::OnlineCalibrateFCBS(int nCalibPos, int nMarkType)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	// 隐藏对象结果图形
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	std::vector<int> vnObjectPosIndex;
	int nObjectPosIndex = 0;
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nObjectPosIndex = i;
		vnObjectPosIndex.push_back(nObjectPosIndex);
	}
	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);

	// 隐藏目标结果图形	
	std::vector<int> vnTargetPosIndex;
	int nTargetPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nTargetPosIndex = i;
		vnTargetPosIndex.push_back(nTargetPosIndex);
	}
	m_cVisionAlignGui.SetPosGuiInvisible(vnTargetPosIndex, eTargetSearch);


	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);


	BOOL bSucceed = FALSE;

	// 拾取系统，XY+D平台，相机安装在XY轴上
	if ( (m_pPlatformInfo->m_bPlatformPick) && (m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformShareXY))
	{
		// 情况1：全局二维码标定
		if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
		{
			// 1为角度标定，0为平移标定，2为计算
			bSucceed = OnlineSingleCameraCalibrateFCBS_WholeDmCode(nCalibPos, nMarkType);
		}
		// 情况2：传统标定+二维码标定
		else
		{
			// 1为角度标定，0为平移标定，2为计算
			bSucceed = OnlineSingleCameraCalibrateFCBS(nCalibPos, nMarkType);
		}
	}
	else
	{
		CString strCmd = _T("VCBS");
		CString strTempWarningType = _T("");
		GetCommCommandName(strCmd);

		if (ePlatformXYPD != m_pPlatformInfo->m_eMidPlatformType)
		{
			ReportCalibResultFCBS(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_PLATFORMTYPE);
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

			return FALSE;
		}

		// 情况1：全局二维码标定
		if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
		{
			bSucceed = OnlineSingleCameraCalibrateFCBS_WholeDmCode(nCalibPos, nMarkType);
		}
		// 情况2：传统标定+二维码标定
		else
		{
			bSucceed = OnlineSingleCameraCalibrateFCBS(nCalibPos, nMarkType);
		}

	}


	if (TRUE == bSucceed)
	{	
		ReportCalibResultFCBS(TRUE);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_SUCCEED);

		if	(nMarkType == 0)
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_XY_SUCCEED);//_T("平台XY轴平移标定成功");
		}
		else if(nMarkType == 1)
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_D_SUCCEED);//_T("平台D轴旋转标定成功");
		}
		else if(nMarkType == 2)
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_CALCU_SUCCEED);//_T("平台标定计算成功");
		}

		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
	}
	else
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);

		if	(nMarkType == 0)
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_XY_FAILED);//_T("平台XY轴平移标定失败");
		}
		else if(nMarkType == 1)
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_D_FAILED);//_T("平台D轴旋转标定失败");
		}
		else if(nMarkType == 2)
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_CALCU_FAILED);//_T("平台标定计算失败");
		}
		if (!m_boIsSnapImgSucceed)
		{
			m_strStatusBarInfo2 = m_strSnapImgStatuString;
		}

		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}

	return bSucceed;
}

// 传统标定+二维码标定
BOOL vcXYDVisionAlign::OnlineSingleCameraCalibrateFCLB(int nCalibPos, int nMarkType)
{

	CString strTempWarningType = _T("");
	CString strCmd = _T("VCLB:");
	GetCommCommandName(strCmd);

	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
	{
		return FALSE;
	}

	if((nMarkType < 0 || nMarkType > 1) && nMarkType !=5)
	{
		ReportCalibResult(FALSE);

		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CALIBTYPE);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}	

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;


	int i=0;

	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	// 二维码标定曝光时间
	BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
	if (SystempOptionSearchShutter && optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
	{
		int nPosNum = 1;
		std::vector<int> vnCalibPos;
		vnCalibPos.push_back(nRemCalibPos);
		std::vector<CameraExposureType> vsmCameraExposureType;

		for(i = 0; i < nPosNum; i++)
		{
			vsmCameraExposureType.push_back(eDmCodeSearchCameraExposure);
		}

		if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("切换二维码曝光失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
		}
	}

	// ...标定结果分析过程日志-标定相关参数
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		int nCurProductIndexFa = 0;
		int nCurProductIndexCh = 0;
		int nExProductIndex = 0;
		int nRemCalibPos = 0;
		m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa, nCurProductIndexCh);
		nExProductIndex = nCalibPos / m_pPlatformInfo->m_nPositionNum;			// 扩展产品序号
		nRemCalibPos	= nCalibPos % m_pPlatformInfo->m_nPositionNum;			// 位置序号

		CString strInfo;
		strInfo.Format(_T("	大品种%d, 小品种%d, 扩展产品%d, 位置%d	\n"),nCurProductIndexFa + 1, nCurProductIndexCh + 1, nExProductIndex + 1, nRemCalibPos + 1);
		VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, TRUE);
	}

	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
	if (m_bCmdParamAxisPosEanble)
	{
		bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
	}
	else
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}
	else
	{
		SetCalibPlatformPos(pPlatformAxisPos/*, nCalibPos, FALSE*/);		

		if (m_CalibPlatformAxisAbsPos.size()<nRemCalibPos+1)
		{
			m_CalibPlatformAxisAbsPos.resize(nRemCalibPos+1);
		}
		m_CalibPlatformAxisAbsPos.at(nRemCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);



		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);


			// ...标定结果分析过程日志
			strTemp.Empty();
			strInfo.Empty();

			strTemp.Format(_T("平台标定时平台的绝对位置:\n"));
			strInfo += strTemp;

			strTemp.Format(_T("......X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"),pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo += strTemp;

			VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);

		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
	vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nRemCalibPos,nMarkType);

	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType))
	{
		ReportCalibResult(FALSE);
		return OnFailedGetCalibPlatformAxisMovePos(strCmd);
	}
	else
	{
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp = _T("");
			CString strInfo = _T("");
			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);

			CPlatformXYDAxisPos* pAxisPos;
			for (int i=0; i<vpPlatformAxisPos.size(); i++)
			{
				strInfo.Empty();
				strTemp.Empty();
				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           

				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
				strInfo = strInfo + strTemp;

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}




			// ...标定结果分析过程日志
			strTemp.Empty();
			strInfo.Empty();

			strTemp.Format(_T("平台标定时所需要移动的绝对轴位置:\n"));
			strInfo += strTemp;
			CPlatformXYDAxisPos* pTempAxisPos;
			for (int i=0; i<vpPlatformAxisPos.size(); i++)
			{
				strTemp.Empty();
				pTempAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
				strTemp.Format(_T("......平台位置%d: X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"), i, pTempAxisPos->m_dPosX, pTempAxisPos->m_dPosY, pTempAxisPos->m_dAngle);
				strInfo = strInfo + strTemp;

			}

			VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);
		}
	}



	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
	if (pCalibData == NULL || !pCalibData->IsValid())
	{
		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
	if (pCalibrateParam == NULL)
	{
		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	// 3. 驱动平台到位并定位
	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	std::vector<CMarkImagePos*> vpMarkImagePos;
	CMarkImagePos* pMarkImagePos = NULL;
	CMarkImagePos* pDisCorMarkImagePos = NULL;

	int k=0;
	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType); k++)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		// 驱动到位
		pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);

		if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
		{	 
			ReportCalibResult(FALSE);			
			return OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);

		}

		Sleep(100);
		// 等待搜索延时
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);


		// 将相机移动到多个位置，逐个定位
		pMarkImagePos = NULL;
		pDisCorMarkImagePos = NULL;

		pMarkImagePos = new CMarkImagePos;
		pMarkImagePos->SetMarkImagePosNum(1);

		pDisCorMarkImagePos = new CMarkImagePos;
		pDisCorMarkImagePos->SetMarkImagePosNum(1);

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nRemCalibPos);
		vsmSearchMode.push_back(eCalibSearch);	

		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{				
			ReportCalibResult(FALSE);				

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}  

			return OnFailedSnapSearchImage(strCmd);
		}


		// 定位	
		m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
		m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;	

		if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
		{
			if (k==0)
			{
				m_bIsFirstCalibPos = TRUE;
			}
			else
			{
				m_bIsFirstCalibPos = FALSE;
			}
		}

		BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eCalibSearch);
			ExeSaveVDBFile(vnPosIndex,eCalibSearch);
		}


		// 分析定位结果，发送指令响应
		if (FALSE == bSearchSucceed)
		{
			ReportCalibResult(FALSE);				

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			} 						 

			return OnFailedCalibSearch(strCmd, k, nCalibPos);
		}


		if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
		{
			// 二维码标定畸变矫正，在SearchProcess转换中进行
			pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));

			CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
			vpMarkImagePos.push_back(markpos); 

		}
		else
		{
			if(pCalibrateParam->m_nEnableDisCor)
			{
				CCoordPos OutPutPoint;
				m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
				pDisCorMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
			}

			// 保存定位结果			
			pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));


			if(pCalibrateParam->m_nEnableDisCor)
			{
				CMarkImagePos * markpos = new CMarkImagePos(*pDisCorMarkImagePos);
				vpMarkImagePos.push_back(markpos); 
			}
			else
			{
				CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
				vpMarkImagePos.push_back(markpos); 
			}
		}


		// 记录图像搜索数据
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strOut;
			CCoordPos cp;
			strOut = strTemp + _T("CalibSearch: ");		
			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = pMarkImagePos->GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

				strOut += strTemp;
			}

			if(pCalibrateParam->m_nEnableDisCor)
			{
				for (int i=0; i<pDisCorMarkImagePos->GetMarkImagePosNum(); i++)
				{
					strTemp = _T("");
					cp = pDisCorMarkImagePos->GetMarkImagePos(i);

					strTemp.Format(_T("DisCorMarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

					strOut += strTemp;
				}
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}

		if (pMarkImagePos!=NULL)
		{
			delete pMarkImagePos;
			pMarkImagePos = NULL;
		}  

		if(pDisCorMarkImagePos != NULL)
		{
			delete pDisCorMarkImagePos;
			pDisCorMarkImagePos = NULL;
		}

	} // for 

	// ...标定结果分析过程日志
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strInfo = _T("");		
		CString strTemp = _T("");	

		strTemp.Format(_T("平台标定时图像坐标:\n"));
		strInfo += strTemp;
		for (int i=0; i<vpMarkImagePos.size(); i++)
		{
			strTemp.Empty();
			CCoordPos cp;
			cp = vpMarkImagePos.at(i)->GetMarkImagePos(0);
			strTemp.Format(_T("......MarkPos%d: X: %.2f; Y: %.2f; D: %.3f;\n"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
			strInfo += strTemp;

		}

		VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);

	}

	// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具
	if(FALSE == ExecuteCalibrate(vpMarkImagePos,nCalibPos,nMarkType))
	{		
		ReportCalibResult(FALSE);		

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		if (pMarkImagePos!=NULL)
		{
			delete pMarkImagePos;
			pMarkImagePos = NULL;
		}  

		if(pDisCorMarkImagePos != NULL)
		{
			delete pDisCorMarkImagePos;
			pDisCorMarkImagePos = NULL;
		}

		for (k=0; k<vpMarkImagePos.size(); k++)
		{
			if (vpMarkImagePos.at(k))
			{
				delete vpMarkImagePos.at(k);
				vpMarkImagePos.at(k) = NULL;
			}
		} 

		//		SaveCurAllCameraChannelSearchImg();		
		return FALSE;
	}

	if (pMarkImagePos!=NULL)
	{
		delete pMarkImagePos;
		pMarkImagePos = NULL;
	}  

	if(pDisCorMarkImagePos != NULL)
	{
		delete pDisCorMarkImagePos;
		pDisCorMarkImagePos = NULL;
	}

	for (k=0; k<vpMarkImagePos.size(); k++)
	{
		if (vpMarkImagePos.at(k))
		{
			delete vpMarkImagePos.at(k);
			vpMarkImagePos.at(k) = NULL;
		}
	} 

	/////////////////////////////////////// 平台标定求精//////////////////////////////////////////

	if (nMarkType == 1)
	{
		// 			SysPlatformInfo sysPlatformInfo;
		// 			GetSysPlatformInfo(sysPlatformInfo);

		switch(sysPlatformInfo.m_eMidPlatformType)
		{
		case ePlatformXYD:
		case ePlatformX1X2Y:
		case ePlatformXY1Y2:
			{
				int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
				int nCalibRefineTime = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibRefineTime();

				// 					// ...标定结果分析过程日志
				// 					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				// 					{
				// 						CString strInfo = _T("");		
				// 						CString strTemp = _T("");	
				// 
				// 						strTemp.Format(_T("求精记录:\n"));
				// 						strInfo += strTemp;
				// 
				// 						VisionAlignLogRecord(m_strCalibrateProcessPath1,strInfo,FALSE);
				// 
				// 					}


				for (i = 0; i < nCalibRefineTime; i++)
				{
					std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
					vpAllCalibratedInfo = GetAllCalibratedInfo();


					// ...标定结果分析过程日志
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
					{
						CString strInfo = _T("");
						CString strTemp = _T("");

						strTemp.Format(_T("第%d次求精前后基准平台坐标对比:\n"),i+1);
						strInfo += strTemp;

						strTemp.Format(_T("......求精前基准平台坐标:\n"));
						strInfo += strTemp;

						strTemp.Format(_T("......PlatformPos: X: %.2f; Y: %.2f;\n"),vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos().m_dPosX,vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos().m_dPosY);
						strInfo += strTemp;

						VisionAlignLogRecord(m_strCalibrateProcessPath1,strInfo,FALSE);
					}

					if (FALSE == ExcutePlatformCalibrateRefine(nCalibPos))	//20180501hk修改 nRemCalibPos
					{
						ReportCalibResult(FALSE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_BENCH_POS_CALIB_REFINE_FAILED), nRemCalibPos);
						//m_strStatusBarInfo2 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();

						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

						//						SaveCurAllCameraChannelSearchImg();
						return FALSE;
					}

					// ...标定结果分析过程日志
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
					{
						CString strInfo = _T("");
						CString strTemp = _T("");

						vpAllCalibratedInfo = GetAllCalibratedInfo();

						strTemp.Format(_T("......求精后基准平台坐标:\n"));
						strInfo += strTemp;

						strTemp.Format(_T("......PlatformPos: X: %.2f; Y: %.2f;\n"),vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos().m_dPosX,vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos().m_dPosY);
						strInfo += strTemp;

						strTemp.Format(_T("......前后差值: X: %.2f; Y: %.2f;\n"),vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPosRefineOffset().GetPosX(),vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPosRefineOffset().GetPosY());
						strInfo += strTemp;

						VisionAlignLogRecord(m_strCalibrateProcessPath1,strInfo,FALSE);
					}
				}
			}
			break;

		default:
			{

			}
			break;
		}
	}


	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();

	/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
	SetCurCalibratedInfo(vpAllCalibratedInfo);	

	// 保存标定后信息到当前产品中及配置文件中
	SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);



	// 对象标定时是否选择一个位置为基准，其他位置通过图像平台坐标通过轴移动量计算
	if (!ExecuteCalibrate_ObjectBench(nCalibPos))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = _T("执行对象标准基准计算失败！");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportCalibResult(FALSE);	
		return FALSE;
	}

	//// 不同的位置使用相同标定结果：单相机
	//if (!ExecuteCalibrate_CopyInfo_SingleCamera(nCalibPos))
	//{
	//	ReportCalibResult(FALSE);	
	//	return FALSE;
	//}

	// 目标对象分离，是否启用-目标和对象位置虚拟模式，2VS4（暂没实现）
	if (!ExecuteCalibrate_CopyInfo_VirtualMode(nCalibPos))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = _T("执行对象目标虚拟时的标定拷贝失败！");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportCalibResult(FALSE);	
		return FALSE;
	}

	// 不同的位置使用相同标定结果：目标对象分离
	int nExProductIdx=nCalibPos/m_pPlatformInfo->m_nPositionNum;//扩展产品序号
	if(optionInfo.m_bAutoCopyCalibData && !optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
	{
		if (!ExecuteCopyCalibrateData(1,nExProductIdx))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = _T("执行标定拷贝失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			ReportCalibResult(FALSE);	
			return FALSE;
		}

	}

	// 保存目标定位结果信息
	m_bTargetMarkSearchSucceed = FALSE;	
	m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	if (!ExecuteCalibrate_TargetBench(nCalibPos))
	{

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = _T("设置标定位置为目标基准位置失败！");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportCalibResult(FALSE);	
		return FALSE;
	}

	// ...标定结果分析过程日志
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CalibrateParam_LogRecord(nCalibPos);

		CalibrateResult_LogRecord(nCalibPos, nMarkType);
	}

	return TRUE;

}

BOOL vcXYDVisionAlign::OnlineSingleCameraCalibrateFCLB_WholeDmCode(int nCalibPos, int nMarkType)
{
	CString strTempWarningType = _T("");
	CString strCmd = _T("VCLB:");
	GetCommCommandName(strCmd);

	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
	{
		return FALSE;
	}

	if((nMarkType < 0 || nMarkType > 1) && nMarkType !=5)
	{
		ReportCalibResult(FALSE);

		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CALIBTYPE);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}	

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (!(optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode()== eWholeDmcodeBoardCalib))
	{
		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_CHOOSE_WHOLE_DMCODE_CALIB_MODE);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	int i=0;
	int nCamPos = m_pPlatformInfo->m_nPositionNum;
	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;


	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if (nMarkType == 5)
	{
		if ( (sysPlatformInfo.m_eMidPlatformType != ePlatformX) && (sysPlatformInfo.m_eMidPlatformType != ePlatformXY) && (sysPlatformInfo.m_eMidPlatformType != ePlatformY))
		{
			// 1. 全局二维码靶标标定时，计算图像坐标到靶标坐标之间的映射关系-h1
			if (!ExecuteCalibWholeDmCodeBoardImgToBoard(nCalibPos))
			{
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}


			// 2. 全局二维码靶标标定时，计算靶标坐标到平台坐标的旋转缩放关系-h2
			if(FALSE == ExecuteCalibrateWholeDmcodeBoardBoardToPlat(nCalibPos,nMarkType))
			{		
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}

			// 3. 执行全局二维码标定计算-旋转中心
			if (FALSE == ExecuteCalibWholeDmCodeBoard(nCalibPos))
			{
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}
		}

		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
		vpAllCalibratedInfo = GetAllCalibratedInfo();

		SetCurCalibratedInfo(vpAllCalibratedInfo);	
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
	}


	//切换曝光时间
	BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
	if (SystempOptionSearchShutter && optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
	{
		int nPosNum = 1;
		std::vector<int> vnCalibPos;
		vnCalibPos.push_back(nRemCalibPos);
		std::vector<CameraExposureType> vsmCameraExposureType;

		for(i = 0; i < nPosNum; i++)
		{
			vsmCameraExposureType.push_back(eDmCodeSearchCameraExposure);
		}

		if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("切换二维码曝光失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		}
	}


	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
	if (m_bCmdParamAxisPosEanble)
	{
		bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
	}
	else
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}
	else
	{
		SetCalibPlatformPos(pPlatformAxisPos/*, nCalibPos, FALSE*/);		

		if (m_CalibPlatformAxisAbsPos.size()<nRemCalibPos+1)
		{
			m_CalibPlatformAxisAbsPos.resize(nRemCalibPos+1);
		}
		m_CalibPlatformAxisAbsPos.at(nRemCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);

		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
	vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nRemCalibPos,nMarkType);

	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType))
	{	

		ReportCalibResult(FALSE);
		return OnFailedGetCalibPlatformAxisMovePos(strCmd);
	}
	else
	{
		// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
			strInfo = strTemp + strInfo;

			CPlatformXYDAxisPos* pAxisPos;
			for (int i=0; i<vpPlatformAxisPos.size(); i++)
			{
				strTemp.Empty();
				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           

				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
				strInfo = strInfo + strTemp;
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);

		}
	}



	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
	if (pCalibData == NULL || !pCalibData->IsValid())
	{
		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
	if (pCalibrateParam == NULL)
	{
		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	// 3. 驱动平台到位并定位
	int k=0;
	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	std::vector<CMarkImagePos*> vpMarkImagePos;
	CMarkImagePos* pMarkImagePos = NULL;
	CMarkImagePos* pDisCorMarkImagePos = NULL;


	std::vector<CMulMarkPos*> vpDmCodeImagePos;
	std::vector<CMulMarkPos*> vpDmCodeBoardPos;
	CMulMarkPos* pDmCodeImagePos = NULL;
	CMulMarkPos* pDmCodeBoardPos = NULL;

	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType); k++)
	{ 
		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


		// 驱动到位
		pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);

		if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
		{	 

			ReportCalibResult(FALSE);			
			return OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);
		}


		Sleep(100);

		pMarkImagePos = NULL;
		pDisCorMarkImagePos = NULL;

		pDmCodeImagePos = NULL;
		pDmCodeBoardPos = NULL;

		pMarkImagePos = new CMarkImagePos;
		pMarkImagePos->SetMarkImagePosNum(1);

		pDisCorMarkImagePos = new CMarkImagePos;
		pDisCorMarkImagePos->SetMarkImagePosNum(1);


		pDmCodeImagePos = new CMulMarkPos;
		pDmCodeImagePos->SetMarkImagePosNum(1);

		pDmCodeBoardPos = new CMulMarkPos;
		pDmCodeBoardPos->SetMarkImagePosNum(1);

		// 等待搜索延时
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nRemCalibPos);		// nCalibPos	

		vsmSearchMode.push_back(eCalibSearch);	// 标定搜索		

		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{				
			ReportCalibResult(FALSE);				

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}  


			if (pDmCodeImagePos != NULL)
			{
				delete pDmCodeImagePos;
				pDmCodeImagePos = NULL;
			}

			if (pDmCodeBoardPos != NULL)
			{
				delete pDmCodeBoardPos;
				pDmCodeBoardPos = NULL;
			}

			for (int p=0; p<vpDmCodeImagePos.size(); p++)
			{
				if (vpDmCodeImagePos.at(p))
				{
					delete vpDmCodeImagePos.at(p);
					vpDmCodeImagePos.at(p) = NULL;
				}
			} 

			for (int p=0; p<vpDmCodeBoardPos.size(); p++)
			{
				if (vpDmCodeBoardPos.at(p))
				{
					delete vpDmCodeBoardPos.at(p);
					vpDmCodeBoardPos.at(p) = NULL;
				}
			} 

			return OnFailedSnapSearchImage(strCmd);

		}

		m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
		m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;			

		if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
		{
			if (k==0)
			{
				m_bIsFirstCalibPos = TRUE;
			}
			else
			{
				m_bIsFirstCalibPos = FALSE;
			}
		}

		BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eCalibSearch);
			ExeSaveVDBFile(vnPosIndex,eCalibSearch);
		}

		// 分析定位结果，发送指令响应
		if (FALSE == bSearchSucceed)
		{
			ReportCalibResult(FALSE);				

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}

			if (pDmCodeImagePos != NULL)
			{
				delete pDmCodeImagePos;
				pDmCodeImagePos = NULL;
			}

			if (pDmCodeBoardPos != NULL)
			{
				delete pDmCodeBoardPos;
				pDmCodeBoardPos = NULL;
			}

			for (int p=0; p<vpDmCodeImagePos.size(); p++)
			{
				if (vpDmCodeImagePos.at(p))
				{
					delete vpDmCodeImagePos.at(p);
					vpDmCodeImagePos.at(p) = NULL;
				}
			} 

			for (int p=0; p<vpDmCodeBoardPos.size(); p++)
			{
				if (vpDmCodeBoardPos.at(p))
				{
					delete vpDmCodeBoardPos.at(p);
					vpDmCodeBoardPos.at(p) = NULL;
				}
			} 

			return OnFailedCalibSearch(strCmd, k, nCalibPos);
		}

		// 保存定位结果			
		pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));

		CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
		vpMarkImagePos.push_back(markpos); 

		pDmCodeImagePos->SetMarkImagePos(0, m_mpDmCodeImagePos.GetMarkImagePos(nRemCalibPos));
		CMulMarkPos *pDmCodeImagePosTemp = new CMulMarkPos(*pDmCodeImagePos);
		vpDmCodeImagePos.push_back(pDmCodeImagePosTemp); 

		pDmCodeBoardPos->SetMarkImagePos(0, m_mpDmCodeBoardPos.GetMarkImagePos(nRemCalibPos));		
		CMulMarkPos *pDmCodeBoardPosTemp = new CMulMarkPos(*pDmCodeBoardPos);
		vpDmCodeBoardPos.push_back(pDmCodeBoardPosTemp);



		// 记录图像搜索数据
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strOut;
			CCoordPos cp;
			strOut = strTemp + _T("CalibSearch: ");		
			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = pMarkImagePos->GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

				strOut += strTemp;
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}

		if (pMarkImagePos!=NULL)
		{
			delete pMarkImagePos;
			pMarkImagePos = NULL;
		}  

		if(pDisCorMarkImagePos != NULL)
		{
			delete pDisCorMarkImagePos;
			pDisCorMarkImagePos = NULL;
		}

		if (pDmCodeImagePos != NULL)
		{
			delete pDmCodeImagePos;
			pDmCodeImagePos = NULL;
		}

		if (pDmCodeBoardPos != NULL)
		{
			delete pDmCodeBoardPos;
			pDmCodeBoardPos = NULL;
		}

	} // for


	if (pMarkImagePos!=NULL)
	{
		delete pMarkImagePos;
		pMarkImagePos = NULL;
	}  

	if(pDisCorMarkImagePos != NULL)
	{
		delete pDisCorMarkImagePos;
		pDisCorMarkImagePos = NULL;
	}

	if (pDmCodeImagePos != NULL)
	{
		delete pDmCodeImagePos;
		pDmCodeImagePos = NULL;
	}

	if (pDmCodeBoardPos != NULL)
	{
		delete pDmCodeBoardPos;
		pDmCodeBoardPos = NULL;
	}

	// 设置全局二维码标定时，对位工具需要用到的二维码数据
	if (FALSE == ExecuteCalibrateWholeDmcodeMarkPosInfo(vpDmCodeImagePos,vpDmCodeBoardPos, vpMarkImagePos, nCalibPos))
	{
		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		for (k=0; k<vpMarkImagePos.size(); k++)
		{
			if (vpMarkImagePos.at(k))
			{
				delete vpMarkImagePos.at(k);
				vpMarkImagePos.at(k) = NULL;
			}
		} 

		for (int p=0; p<vpDmCodeImagePos.size(); p++)
		{
			if (vpDmCodeImagePos.at(p))
			{
				delete vpDmCodeImagePos.at(p);
				vpDmCodeImagePos.at(p) = NULL;
			}
		} 

		for (int p=0; p<vpDmCodeBoardPos.size(); p++)
		{
			if (vpDmCodeBoardPos.at(p))
			{
				delete vpDmCodeBoardPos.at(p);
				vpDmCodeBoardPos.at(p) = NULL;
			}
		} 

		return FALSE;

	}


	// 5. 释放内存
	for (k=0; k<vpMarkImagePos.size(); k++)
	{
		if (vpMarkImagePos.at(k))
		{
			delete vpMarkImagePos.at(k);
			vpMarkImagePos.at(k) = NULL;
		}
	} 

	for (int p=0; p<vpDmCodeImagePos.size(); p++)
	{
		if (vpDmCodeImagePos.at(p))
		{
			delete vpDmCodeImagePos.at(p);
			vpDmCodeImagePos.at(p) = NULL;
		}
	} 

	for (int p=0; p<vpDmCodeBoardPos.size(); p++)
	{
		if (vpDmCodeBoardPos.at(p))
		{
			delete vpDmCodeBoardPos.at(p);
			vpDmCodeBoardPos.at(p) = NULL;
		}
	} 


	// 全局二维码标定时，当标定位置为选择的计算位置时，执行全局旋转中心计算
	if (GetWholeCalibCacuPosEnable() && nRemCalibPos == GetWholeCalibCacuPos())
	{
		if ( (sysPlatformInfo.m_eMidPlatformType != ePlatformX) && (sysPlatformInfo.m_eMidPlatformType != ePlatformXY) && (sysPlatformInfo.m_eMidPlatformType != ePlatformY))
		{
			// 1. 全局二维码靶标标定时，计算图像坐标到靶标坐标之间的映射关系-h1
			if (!ExecuteCalibWholeDmCodeBoardImgToBoard(nCalibPos))
			{
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}


			// 2. 全局二维码靶标标定时，计算靶标坐标到平台坐标的旋转缩放关系-h2
			if(FALSE == ExecuteCalibrateWholeDmcodeBoardBoardToPlat(nCalibPos,nMarkType))
			{		
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}

			// 3. 执行全局二维码标定计算-旋转中心
			if (FALSE == ExecuteCalibWholeDmCodeBoard(nCalibPos))
			{
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}
		}

		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
		vpAllCalibratedInfo = GetAllCalibratedInfo();

		SetCurCalibratedInfo(vpAllCalibratedInfo);	
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);


		// 对象标定时是否选择一个位置为基准，其他位置通过图像平台坐标通过轴移动量计算
		if (!ExecuteCalibrate_ObjectBench(nCalibPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = _T("执行对象标准基准计算失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			ReportCalibResult(FALSE);	
			return FALSE;
		}

		// 不同的位置使用相同标定结果：单相机
		if (!ExecuteCalibrate_CopyInfo_SingleCamera(nCalibPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = _T("单相机标定拷贝失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			ReportCalibResult(FALSE);	
			return FALSE;
		}

		// 目标对象分离，是否启用-目标和对象位置虚拟模式，2VS4（暂没实现）
		if (!ExecuteCalibrate_CopyInfo_VirtualMode(nCalibPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = _T("执行对象目标虚拟时的标定拷贝失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			ReportCalibResult(FALSE);	
			return FALSE;
		}

		// 不同的位置使用相同标定结果：目标对象分离
		int nExProductIdx=nCalibPos/m_pPlatformInfo->m_nPositionNum;//扩展产品序号
		if(optionInfo.m_bAutoCopyCalibData  && !optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
		{
			if (!ExecuteCopyCalibrateData(1,nExProductIdx))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = _T("执行标定拷贝失败！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				ReportCalibResult(FALSE);	
				return FALSE;
			}

		}

		// 保存目标定位结果信息
		m_bTargetMarkSearchSucceed = FALSE;	
		m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

		if (!ExecuteCalibrate_TargetBench(nCalibPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = _T("设置标定位置为目标基准位置失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			ReportCalibResult(FALSE);	
			return FALSE;
		}

	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineSingleCameraCalibrateFCBS(int nCalibPos, int nMarkType)
{
	CString strCmd = _T("VCBS");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);

	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
	{	
		ReportCalibResultFCBS(FALSE);
		return FALSE;
	}

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	int i = 0;

	// 	if (ePlatformXYPD != sysPlatformInfo.m_eMidPlatformType)
	// 	{
	// 		ReportCalibResultFCBS(FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_PLATFORMTYPE);
	// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
	// 		PostMessageUpdateStatusBarInfo();
	// 
	// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
	// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	// 
	// 		return FALSE;
	// 	}



	if((nMarkType < 0 || nMarkType > 2) && nMarkType!=5 )
	{
		ReportCalibResultFCBS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CALIBTYPE);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		nCalibPos = nCalibPos + m_pPlatformInfo->m_nPositionNum/2;
	}


	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;		// 位置序号
	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


	//只计算
	if(nMarkType == 2)
	{
		std::vector<CMarkImagePos*> Nullimage;
		Nullimage.clear();
		if(FALSE == ExecuteCalibrateFCBS(Nullimage,nCalibPos,nMarkType))
		{
			ReportCalibResultFCBS(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}

		//////////////////////////////////////// 获取标定结果///////////////////////////////////////////

		// 获取系统标定后的所有信息
		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
		vpAllCalibratedInfo = GetAllCalibratedInfo();

		SetCurCalibratedInfo(vpAllCalibratedInfo);	
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);


		if (!ExecuteCalibrate_ObjectBench(nCalibPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
			m_strStatusBarInfo2 = _T("执行对象标准基准计算失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

			ReportCalibResultFCBS(FALSE);
			return FALSE;
		}

		if (!ExecuteCalibrate_CopyInfo_SingleCamera(nCalibPos, nMarkType))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
			m_strStatusBarInfo2 = _T("执行对象目标虚拟时的标定拷贝失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			ReportCalibResultFCBS(FALSE);
			return FALSE;
		}

		int nExProductIdx = nCalibPos/GetPosNum();
		if(optionInfo.m_bAutoCopyCalibData  && !optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
		{
			if (!ExecuteCopyCalibrateData(2,nExProductIdx))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
				m_strStatusBarInfo2 = _T("执行标定拷贝失败！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				ReportCalibResultFCBS(FALSE);
				return FALSE;
			}

		}

		int nProductIdx=(GetTotalProuductData()->GetCurProductIndex());
		CProductData *pProductData=(GetTotalProuductData()->GetItemPtr(nProductIdx));
		if (sysPlatformInfo.m_bTargetObjectCamSeparate == TRUE && sysPlatformInfo.m_nPositionNum == 8 
			&& pProductData->m_pAlignerParam->GetAligner4Vs4Type()==eAlignerPos1234_56_4V2)
		{
			BOOL bResult=FALSE;
			std::vector<int> vnPos;
			if (nCalibPos==4 + nExProductIdx*GetPosNum())
			{
				vnPos.push_back(6 + nExProductIdx*GetPosNum());
				bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
			}
			if (nCalibPos==5 + nExProductIdx*GetPosNum())
			{
				vnPos.push_back(7 + nExProductIdx*GetPosNum());
				bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
			}

			if (FALSE == bResult)
			{
				ReportCalibResultFCBS(FALSE);
				return OnFailedSetSameCalibrateInfo(strCmd);
			}

			vpAllCalibratedInfo = GetAllCalibratedInfo();

			SetCurCalibratedInfo(vpAllCalibratedInfo);	
			SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
		}


		// 保存目标定位结果信息
		m_bTargetMarkSearchSucceed = FALSE;	
		m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

		if (!ExecuteCalibrate_TargetBench(nCalibPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
			m_strStatusBarInfo2 = _T("设置标定位置为目标基准位置失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			ReportCalibResult(FALSE);	
			return FALSE;
		}


		// ...标定结果分析过程日志
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CalibrateParam_LogRecord(nCalibPos);

			CalibrateResult_LogRecord(nCalibPos, nMarkType);
		}

		return TRUE;
	}



	// ...标定结果分析过程日志-标定相关参数
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		int nCurProductIndexFa = 0;
		int nCurProductIndexCh = 0;
		int nExProductIndex = 0;
		int nRemCalibPos = 0;
		m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa, nCurProductIndexCh);
		nExProductIndex = nCalibPos / m_pPlatformInfo->m_nPositionNum;			// 扩展产品序号
		nRemCalibPos	= nCalibPos % m_pPlatformInfo->m_nPositionNum;			// 位置序号

		CString strInfo;

		if (0 == nMarkType)
		{
			strInfo.Format(_T("	XY标定大品种%d, 小品种%d, 扩展产品%d, 位置%d	\n"),nCurProductIndexFa + 1, nCurProductIndexCh + 1, nExProductIndex + 1, nRemCalibPos + 1);
			VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, TRUE);
		}
		else if (1 == nMarkType)
		{
			strInfo.Format(_T("	D标定大品种%d, 小品种%d, 扩展产品%d, 位置%d	\n"),nCurProductIndexFa + 1, nCurProductIndexCh + 1, nExProductIndex + 1, nRemCalibPos + 1);
			VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, TRUE);
		}
	}


	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
	if (m_bCmdParamAxisPosEanble)
	{
		bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
	}
	else
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
	{
		ReportCalibResultFCBS(FALSE);

		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);

		return FALSE;
	}
	else
	{
		SetCalibPlatformPos(pPlatformAxisPos);		

		if (m_CalibPlatformAxisAbsPos.size()<nRemCalibPos+1)
		{
			m_CalibPlatformAxisAbsPos.resize(nRemCalibPos+1);
		}
		m_CalibPlatformAxisAbsPos.at(nRemCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);


			// ...标定结果分析过程日志
			strTemp.Empty();
			strInfo.Empty();

			if (nMarkType==0)
			{
				strTemp.Format(_T("平台标定XY时平台的绝对位置:\n"));
			}
			else if (nMarkType==1)
			{
				strTemp.Format(_T("平台标定D时平台的绝对位置:\n"));				
			}
			strInfo += strTemp;

			strTemp.Format(_T("......X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"),pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo += strTemp;

			VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);

		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
	vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nRemCalibPos,nMarkType);

	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType))
	{
		ReportCalibResultFCBS(FALSE);		
		return OnFailedGetCalibPlatformAxisMovePos(strCmd);
	}
	else
	{
		// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
			strInfo = strTemp + strInfo;

			CPlatformXYDAxisPos* pAxisPos;
			for (int i=0; i<vpPlatformAxisPos.size(); i++)
			{
				strTemp.Empty();
				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           

				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
				strInfo = strInfo + strTemp;
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);

			// ...标定结果分析过程日志
			strTemp.Empty();
			strInfo.Empty();

			if (nMarkType==0)
			{
				strTemp.Format(_T("平台标定XY时所需要移动的绝对轴位置:\n"));
			}
			else if (nMarkType==1)
			{
				strTemp.Format(_T("平台标定D时所需要移动的绝对轴位置:\n"));
			}
			strInfo += strTemp;


			CPlatformXYDAxisPos* pTempAxisPos;
			for (int i=0; i<vpPlatformAxisPos.size(); i++)
			{
				strTemp.Empty();
				pTempAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
				strTemp.Format(_T("......平台位置%d: X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"), i, pTempAxisPos->m_dPosX, pTempAxisPos->m_dPosY, pTempAxisPos->m_dAngle);
				strInfo = strInfo + strTemp;

			}

			VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);
		}
	}

	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
	if (pCalibData == NULL || !pCalibData->IsValid())
	{
		ReportCalibResultFCBS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
	if (pCalibrateParam == NULL)
	{
		ReportCalibResultFCBS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	// 3. 驱动平台到位并定位
	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	std::vector<CMarkImagePos*> vpMarkImagePos;
	CMarkImagePos* pMarkImagePos = NULL;
	CMarkImagePos* pDisCorMarkImagePos = NULL;

	int k=0;
	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType); k++)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		// 驱动到位
		pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);

		if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
		{
			ReportCalibResultFCBS(FALSE);
			return OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);
		}



		Sleep(100);
		// 等待搜索延时
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);


		// 将相机移动到多个位置，逐个定位
		pMarkImagePos = NULL;
		pDisCorMarkImagePos = NULL;

		pMarkImagePos = new CMarkImagePos;
		pMarkImagePos->SetMarkImagePosNum(1);

		pDisCorMarkImagePos = new CMarkImagePos;
		pDisCorMarkImagePos->SetMarkImagePosNum(1);

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nRemCalibPos);

		if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode))
		{
			vsmSearchMode.push_back(eCalibSearch);	// 标定搜索
		}
		else
		{
			if (nMarkType==0)
			{
				vsmSearchMode.push_back(eCalibSearch);	// 标定搜索
			}
			else if(nMarkType==1)
			{
				vsmSearchMode.push_back(eTargetSearch);	// 目标搜索
			}
		}

		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{			

			ReportCalibResultFCBS(FALSE);				

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}  

			return OnFailedSnapSearchImage(strCmd);
		}


		if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode))
		{
			m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
			m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;
		}
		else
		{
			// 定位
			if (nMarkType==0)
			{
				m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
				m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;
			}
			else if(nMarkType==1)
			{
				m_vnTargetSearchStartPatIndex[nRemCalibPos] = 0;
				m_vnTargetSearchEndPatIndex[nRemCalibPos] = 0;
			}
		}

		if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode))
		{
			if (k==0)
			{
				m_bIsFirstCalibPos = TRUE;
			}
			else
			{
				m_bIsFirstCalibPos = FALSE;
			}
		}

		BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eCalibSearch);
			ExeSaveVDBFile(vnPosIndex,eCalibSearch);
		}

		if(nMarkType==1)
		{
			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
		}


		// 分析定位结果，发送指令响应
		if (FALSE == bSearchSucceed)
		{
			ReportCalibResultFCBS(FALSE);		

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}  

			return OnFailedCalibSearch(strCmd, k, nCalibPos);
		}

		// 保存定位结果	
		if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode))
		{
			pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	

			CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
			vpMarkImagePos.push_back(markpos); 
		}
		else
		{
			if (nMarkType==0)
			{		
				if(pCalibrateParam->m_nEnableDisCor)
				{
					CCoordPos OutPutPoint;
					m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
					pDisCorMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
				}

				pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	

			}
			else if (nMarkType==1)
			{
				if(pCalibrateParam->m_nEnableDisCor)
				{
					CCoordPos OutPutPoint;
					m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
					pDisCorMarkImagePos->SetMarkImagePos(0, m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
				}

				pMarkImagePos->SetMarkImagePos(0, m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));	

			}

			if(pCalibrateParam->m_nEnableDisCor)
			{
				CMarkImagePos * markpos = new CMarkImagePos(*pDisCorMarkImagePos);
				vpMarkImagePos.push_back(markpos); 
			}
			else
			{
				CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
				vpMarkImagePos.push_back(markpos); 
			}

		}


		// 记录图像搜索数据
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strOut;
			CCoordPos cp;
			strOut = strTemp + _T("CalibSearch: ");		
			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = pMarkImagePos->GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

				strOut += strTemp;
			}

			if(pCalibrateParam->m_nEnableDisCor)
			{
				for (int i=0; i<pDisCorMarkImagePos->GetMarkImagePosNum(); i++)
				{
					strTemp = _T("");
					cp = pDisCorMarkImagePos->GetMarkImagePos(i);

					strTemp.Format(_T("DisCorMarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

					strOut += strTemp;
				}
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}

		if (pMarkImagePos!=NULL)
		{
			delete pMarkImagePos;
			pMarkImagePos = NULL;
		}

		if(pDisCorMarkImagePos != NULL)
		{
			delete pDisCorMarkImagePos;
			pDisCorMarkImagePos = NULL;
		}
	}

	// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具
	if(FALSE == ExecuteCalibrateFCBS(vpMarkImagePos,nCalibPos,nMarkType))
	{
		ReportCalibResultFCBS(FALSE);	

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		if (pMarkImagePos!=NULL)
		{
			delete pMarkImagePos;
			pMarkImagePos = NULL;
		} 

		if(pDisCorMarkImagePos != NULL)
		{
			delete pDisCorMarkImagePos;
			pDisCorMarkImagePos = NULL;
		}

		for (k=0; k<vpMarkImagePos.size(); k++)
		{
			if (vpMarkImagePos.at(k))
			{
				delete vpMarkImagePos.at(k);
				vpMarkImagePos.at(k) = NULL;
			}
		} 

		//		SaveCurAllCameraChannelSearchImg();		
		return FALSE;
	}


	// ...标定结果分析过程日志
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strInfo = _T("");		
		CString strTemp = _T("");	

		if (nMarkType==0)
		{
			strTemp.Format(_T("平台标定XY时图像坐标:\n"));
		}
		else if (nMarkType==1)
		{
			strTemp.Format(_T("平台标定D时图像坐标:\n"));
		}
		strInfo += strTemp;

		for (int i=0; i<vpMarkImagePos.size(); i++)
		{
			strTemp.Empty();
			CCoordPos cp;
			cp = vpMarkImagePos.at(i)->GetMarkImagePos(0);
			strTemp.Format(_T("......MarkPos%d: X: %.2f; Y: %.2f; D: %.3f;\n"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
			strInfo += strTemp;

		}

		VisionAlignLogRecord(m_strCalibrateProcessPath1, strInfo, FALSE);

	}


	if (pMarkImagePos!=NULL)
	{
		delete pMarkImagePos;
		pMarkImagePos = NULL;
	}  

	if(pDisCorMarkImagePos != NULL)
	{
		delete pDisCorMarkImagePos;
		pDisCorMarkImagePos = NULL;
	}

	for (k=0; k<vpMarkImagePos.size(); k++)
	{
		if (vpMarkImagePos.at(k))
		{
			delete vpMarkImagePos.at(k);
			vpMarkImagePos.at(k) = NULL;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineSingleCameraCalibrateFCBS_WholeDmCode(int nCalibPos, int nMarkType)
{
	CString strCmd = _T("VCBS");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);

	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
	{	
		ReportCalibResultFCBS(FALSE);
		return FALSE;
	}


	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if(!(optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
	{
		ReportCalibResultFCBS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_CHOOSE_WHOLE_DMCODE_CALIB_MODE);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}


	int i = 0;
	// 	if (ePlatformXYPD != sysPlatformInfo.m_eMidPlatformType)
	// 	{
	// 		ReportCalibResultFCBS(FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_PLATFORMTYPE);
	// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
	// 		PostMessageUpdateStatusBarInfo();
	// 
	// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
	// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	// 
	// 		return FALSE;
	// 	}

	if((nMarkType < 0 || nMarkType > 2) && nMarkType != 5)
	{
		ReportCalibResultFCBS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CALIBTYPE);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}


	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		nCalibPos = nCalibPos + m_pPlatformInfo->m_nPositionNum/2;
	}


	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;

	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if (nMarkType == 5)
	{
		if ( (sysPlatformInfo.m_eMidPlatformType != ePlatformX) && (sysPlatformInfo.m_eMidPlatformType != ePlatformXY) && (sysPlatformInfo.m_eMidPlatformType != ePlatformY) )
		{
			// 1. 全局二维码靶标标定时，计算图像坐标到靶标坐标之间的映射关系-h1
			if (!ExecuteCalibWholeDmCodeBoardImgToBoard(nCalibPos))
			{
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}

			// 2. 全局二维码靶标标定时，计算靶标坐标到平台坐标的旋转缩放关系-h2
			if(FALSE == ExecuteCalibrateWholeDmcodeBoardBoardToPlat(nCalibPos,nMarkType))
			{		
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}

			// 3. 执行全局二维码标定计算-旋转中心
			if (FALSE == ExecuteCalibWholeDmCodeBoard(nCalibPos))
			{
				ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}

			// 4. 设置系统标定后的所有信息
			std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
			vpAllCalibratedInfo = GetAllCalibratedInfo();

			SetCurCalibratedInfo(vpAllCalibratedInfo);	
			SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);

			// 5. 对象标定时是否选择一个位置为基准，其他位置通过图像平台坐标通过轴移动量计算
			if (!ExecuteCalibrate_ObjectBench(nCalibPos))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = _T("执行对象标准基准计算失败！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				ReportCalibResult(FALSE);	
				return FALSE;
			}

			// 6. 不同的位置使用相同标定结果：单相机
			if (!ExecuteCalibrate_CopyInfo_SingleCamera(nCalibPos))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = _T("执行单相机标定拷贝失败！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				ReportCalibResult(FALSE);	
				return FALSE;
			}

			// 7. 目标对象分离，是否启用-目标和对象位置虚拟模式，2VS4（暂没实现）
			if (!ExecuteCalibrate_CopyInfo_VirtualMode(nCalibPos))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = _T("执行对象目标虚拟时的标定拷贝失败！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				ReportCalibResult(FALSE);	
				return FALSE;
			}

			// 8. 不同的位置使用相同标定结果：目标对象分离
			int nExProductIdx=nCalibPos/m_pPlatformInfo->m_nPositionNum;//扩展产品序号
			if(optionInfo.m_bAutoCopyCalibData)
			{
				if (!ExecuteCopyCalibrateData(1,nExProductIdx))
				{
					ReportCalibResult(FALSE);	
					return FALSE;
				}

			}

			// 保存目标定位结果信息
			m_bTargetMarkSearchSucceed = FALSE;	
			m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

			if (!ExecuteCalibrate_TargetBench(nCalibPos))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = _T("设置标定位置为目标基准位置失败！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				ReportCalibResult(FALSE);	
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = _T("平台类型不符！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}

		return TRUE;
	}

	// 只计算
	if(nMarkType == 2)
	{
		//全局二维码靶标标定时，当标定位置为选择的计算位置时，执行旋转中心计算
		if (GetWholeCalibCacuPosEnable() && nRemCalibPos == GetWholeCalibCacuPos())
		{
			if ( (sysPlatformInfo.m_eMidPlatformType != ePlatformX) && (sysPlatformInfo.m_eMidPlatformType != ePlatformXY) && (sysPlatformInfo.m_eMidPlatformType != ePlatformY))
			{
				// 1. 全局二维码靶标标定时，计算图像坐标到靶标坐标之间的映射关系-h1
				if (!ExecuteCalibWholeDmCodeBoardImgToBoard(nCalibPos))
				{
					ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

					return FALSE;
				}

				// 2. 全局二维码靶标标定时，计算靶标坐标到平台坐标的旋转缩放关系-h2
				if(FALSE == ExecuteCalibrateWholeDmcodeBoardBoardToPlat(nCalibPos,nMarkType))
				{		
					ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

					return FALSE;
				}

				// 3. 执行全局二维码标定计算-旋转中心
				if (FALSE == ExecuteCalibWholeDmCodeBoard(nCalibPos))
				{
					ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

					return FALSE;
				}

				// 4. 设置系统标定后的所有信息
				std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
				vpAllCalibratedInfo = GetAllCalibratedInfo();

				SetCurCalibratedInfo(vpAllCalibratedInfo);	
				SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);

				// 5. 保存目标定位结果信息
				m_bTargetMarkSearchSucceed = FALSE;	
				m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
				SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
				SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

				return TRUE;
			}
			else
			{
				return FALSE;
			}


		}
		else
		{
			return TRUE;
		}

		return FALSE;
	}


	BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
	if (SystempOptionSearchShutter && optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode  || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
	{
		int nPosNum = 1;
		std::vector<int> vnCalibPos;
		vnCalibPos.push_back(nRemCalibPos);
		std::vector<CameraExposureType> vsmCameraExposureType;

		for(i = 0; i < nPosNum; i++)
		{
			vsmCameraExposureType.push_back(eDmCodeSearchCameraExposure);
		}

		if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType))
		{
			OnFailedCameraExposureSetting(strCmd);
		}
	}

	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
	if (m_bCmdParamAxisPosEanble)
	{
		bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
	}
	else
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
	{
		ReportCalibResultFCBS(FALSE);

		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);

		return FALSE;
	}
	else
	{
		SetCalibPlatformPos(pPlatformAxisPos);		

		if (m_CalibPlatformAxisAbsPos.size()<nRemCalibPos+1)
		{
			m_CalibPlatformAxisAbsPos.resize(nRemCalibPos+1);
		}
		m_CalibPlatformAxisAbsPos.at(nRemCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);

		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
	vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nRemCalibPos,nMarkType);

	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType))
	{
		ReportCalibResultFCBS(FALSE);		

		return OnFailedGetCalibPlatformAxisMovePos(strCmd);
	}
	else
	{
		// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
			strInfo = strTemp + strInfo;

			CPlatformXYDAxisPos* pAxisPos;
			for (int i=0; i<vpPlatformAxisPos.size(); i++)
			{
				strTemp.Empty();
				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           

				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
				strInfo = strInfo + strTemp;
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}
	}

	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
	if (pCalibData == NULL || !pCalibData->IsValid())
	{
		ReportCalibResultFCBS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
	if (pCalibrateParam == NULL)
	{
		ReportCalibResultFCBS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	// 3. 驱动平台到位并定位
	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	std::vector<CMarkImagePos*> vpMarkImagePos;
	CMarkImagePos* pMarkImagePos = NULL;
	CMarkImagePos* pDisCorMarkImagePos = NULL;

	std::vector<CMulMarkPos*> vpDmCodeImagePos;
	std::vector<CMulMarkPos*> vpDmCodeBoardPos;
	CMulMarkPos* pDmCodeImagePos = NULL;
	CMulMarkPos* pDmCodeBoardPos = NULL;

	int k=0;
	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType); k++)
	{         
		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


		// 驱动到位
		pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);

		if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
		{
			ReportCalibResultFCBS(FALSE);

			return OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);
		}


		Sleep(100);

		pMarkImagePos = NULL;
		pDisCorMarkImagePos = NULL;

		pDmCodeImagePos = NULL;
		pDmCodeBoardPos = NULL;

		pMarkImagePos = new CMarkImagePos;
		pMarkImagePos->SetMarkImagePosNum(1);

		pDisCorMarkImagePos = new CMarkImagePos;
		pDisCorMarkImagePos->SetMarkImagePosNum(1);

		pDmCodeImagePos = new CMulMarkPos;
		pDmCodeImagePos->SetMarkImagePosNum(1);

		pDmCodeBoardPos = new CMulMarkPos;
		pDmCodeBoardPos->SetMarkImagePosNum(1);

		// 等待搜索延时
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nRemCalibPos);

		vsmSearchMode.push_back(eCalibSearch);	// 标定搜索


		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{			
			ReportCalibResultFCBS(FALSE);				

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}  

			if (pDmCodeImagePos != NULL)
			{
				delete pDmCodeImagePos;
				pDmCodeImagePos = NULL;
			}

			if (pDmCodeBoardPos != NULL)
			{
				delete pDmCodeBoardPos;
				pDmCodeBoardPos = NULL;
			}

			for (int p=0; p<vpDmCodeImagePos.size(); p++)
			{
				if (vpDmCodeImagePos.at(p))
				{
					delete vpDmCodeImagePos.at(p);
					vpDmCodeImagePos.at(p) = NULL;
				}
			} 

			for (int p=0; p<vpDmCodeBoardPos.size(); p++)
			{
				if (vpDmCodeBoardPos.at(p))
				{
					delete vpDmCodeBoardPos.at(p);
					vpDmCodeBoardPos.at(p) = NULL;
				}
			} 

			return OnFailedSnapSearchImage(strCmd);
		}

		m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
		m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;


		if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
		{
			if (k==0)
			{
				m_bIsFirstCalibPos = TRUE;
			}
			else
			{
				m_bIsFirstCalibPos = FALSE;
			}
		}

		BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eCalibSearch);
			ExeSaveVDBFile(vnPosIndex,eCalibSearch);
		}

		// 分析定位结果，发送指令响应
		if (FALSE == bSearchSucceed)
		{			
			ReportCalibResultFCBS(FALSE);		

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}

			if (pDmCodeImagePos != NULL)
			{
				delete pDmCodeImagePos;
				pDmCodeImagePos = NULL;
			}

			if (pDmCodeBoardPos != NULL)
			{
				delete pDmCodeBoardPos;
				pDmCodeBoardPos = NULL;
			}

			for (int p=0; p<vpDmCodeImagePos.size(); p++)
			{
				if (vpDmCodeImagePos.at(p))
				{
					delete vpDmCodeImagePos.at(p);
					vpDmCodeImagePos.at(p) = NULL;
				}
			} 

			for (int p=0; p<vpDmCodeBoardPos.size(); p++)
			{
				if (vpDmCodeBoardPos.at(p))
				{
					delete vpDmCodeBoardPos.at(p);
					vpDmCodeBoardPos.at(p) = NULL;
				}
			} 

			return OnFailedCalibSearch(strCmd, k, nCalibPos);
		}

		pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	

		CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
		vpMarkImagePos.push_back(markpos); 

		pDmCodeImagePos->SetMarkImagePos(0, m_mpDmCodeImagePos.GetMarkImagePos(nRemCalibPos));
		CMulMarkPos *pDmCodeImagePosTemp = new CMulMarkPos(*pDmCodeImagePos);
		vpDmCodeImagePos.push_back(pDmCodeImagePosTemp); 

		pDmCodeBoardPos->SetMarkImagePos(0, m_mpDmCodeBoardPos.GetMarkImagePos(nRemCalibPos));		
		CMulMarkPos *pDmCodeBoardPosTemp = new CMulMarkPos(*pDmCodeBoardPos);
		vpDmCodeBoardPos.push_back(pDmCodeBoardPosTemp);



		// 记录图像搜索数据
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strOut;
			CCoordPos cp;
			strOut = strTemp + _T("CalibSearch: ");		
			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = pMarkImagePos->GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

				strOut += strTemp;
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}

		if (pMarkImagePos!=NULL)
		{
			delete pMarkImagePos;
			pMarkImagePos = NULL;
		}  

		if(pDisCorMarkImagePos != NULL)
		{
			delete pDisCorMarkImagePos;
			pDisCorMarkImagePos = NULL;
		}

		if (pDmCodeImagePos != NULL)
		{
			delete pDmCodeImagePos;
			pDmCodeImagePos = NULL;
		}

		if (pDmCodeBoardPos != NULL)
		{
			delete pDmCodeBoardPos;
			pDmCodeBoardPos = NULL;
		}
	}  // for


	if (pMarkImagePos!=NULL)
	{
		delete pMarkImagePos;
		pMarkImagePos = NULL;
	}  

	if(pDisCorMarkImagePos != NULL)
	{
		delete pDisCorMarkImagePos;
		pDisCorMarkImagePos = NULL;
	}

	if (pDmCodeImagePos != NULL)
	{
		delete pDmCodeImagePos;
		pDmCodeImagePos = NULL;
	}

	if (pDmCodeBoardPos != NULL)
	{
		delete pDmCodeBoardPos;
		pDmCodeBoardPos = NULL;
	}

	// 设置全局二维码标定时，对位工具需要用到的二维码数据
	if (FALSE == ExecuteCalibrateWholeDmcodeMarkPosInfo(vpDmCodeImagePos,vpDmCodeBoardPos, vpMarkImagePos, nCalibPos, nMarkType))
	{
		ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		for (k=0; k<vpMarkImagePos.size(); k++)
		{
			if (vpMarkImagePos.at(k))
			{
				delete vpMarkImagePos.at(k);
				vpMarkImagePos.at(k) = NULL;
			}
		} 

		for (int p=0; p<vpDmCodeImagePos.size(); p++)
		{
			if (vpDmCodeImagePos.at(p))
			{
				delete vpDmCodeImagePos.at(p);
				vpDmCodeImagePos.at(p) = NULL;
			}
		} 

		for (int p=0; p<vpDmCodeBoardPos.size(); p++)
		{
			if (vpDmCodeBoardPos.at(p))
			{
				delete vpDmCodeBoardPos.at(p);
				vpDmCodeBoardPos.at(p) = NULL;
			}
		} 

		return FALSE;

	}


	// 5. 释放内存
	for (k=0; k<vpMarkImagePos.size(); k++)
	{
		if (vpMarkImagePos.at(k))
		{
			delete vpMarkImagePos.at(k);
			vpMarkImagePos.at(k) = NULL;
		}
	} 

	for (int p=0; p<vpDmCodeImagePos.size(); p++)
	{
		if (vpDmCodeImagePos.at(p))
		{
			delete vpDmCodeImagePos.at(p);
			vpDmCodeImagePos.at(p) = NULL;
		}
	} 

	for (int p=0; p<vpDmCodeBoardPos.size(); p++)
	{
		if (vpDmCodeBoardPos.at(p))
		{
			delete vpDmCodeBoardPos.at(p);
			vpDmCodeBoardPos.at(p) = NULL;
		}
	} 




	// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具

	//全局二维码靶标标定时，XYPD平台进行XY标定时，计算靶标坐标到平台坐标的旋转缩放关系
	// 	if (nMarkType == 0)
	// 	{
	// 		if(FALSE == ExecuteCalibrateWholeDmcodeBoardBoardToPlatFCBS(vpMarkImagePos,nCalibPos,nMarkType))
	// 		{		
	// 			ReportCalibResultFCBS(FALSE);	
	// 
	// 			m_bStatusBar = FALSE;
	// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
	// 			m_strStatusBarInfo2 = _T("");
	// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	// 			PostMessageUpdateStatusBarInfo();
	// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
	// 
	// 			if (pMarkImagePos!=NULL)
	// 			{
	// 				delete pMarkImagePos;
	// 				pMarkImagePos = NULL;
	// 			}  
	// 
	// 			if(pDisCorMarkImagePos != NULL)
	// 			{
	// 				delete pDisCorMarkImagePos;
	// 				pDisCorMarkImagePos = NULL;
	// 			}
	// 
	// 			for (k=0; k<vpMarkImagePos.size(); k++)
	// 			{
	// 				if (vpMarkImagePos.at(k))
	// 				{
	// 					delete vpMarkImagePos.at(k);
	// 					vpMarkImagePos.at(k) = NULL;
	// 				}
	// 			} 
	// 
	// 			SaveCurAllCameraChannelSearchImg();		
	// 			return FALSE;
	// 		}
	// 	}



	// 	//全局二维码靶标标定时，XYPD平台进行XY标定时，保存计算得到的靶标坐标到平台坐标的旋转缩放关系
	// 	if(nMarkType == 0)
	// 	{
	// 		// 获取系统标定后的所有信息
	// 		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	// 		vpAllCalibratedInfo = GetAllCalibratedInfo();
	// 
	// 		SetCurCalibratedInfo(vpAllCalibratedInfo);	
	// 		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
	// 
	// 		int nExProductIdx = nCalibPos/GetPosNum();
	// 
	// 		if(optionInfo.m_bAutoCopyCalibData && !sysPlatformInfo.m_bDiffPosWithSameCalibInfoEnabled)
	// 		{
	// 			if (!ExecuteCopyCalibrateData(2,nExProductIdx))
	// 			{
	// 				ReportCalibResultFCBS(FALSE);	
	// 				return FALSE;
	// 			}
	// 			
	// 		}
	// 
	// 		// 保存目标定位结果信息
	// 		m_bTargetMarkSearchSucceed = FALSE;	
	// 		m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
	// 		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	// 		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
	// 
	// 	}

	return TRUE;

}

BOOL vcXYDVisionAlign::OnlineCalibrate_CheckByAxisMove(int nCalibPos, int nMarkType)
{
	CString strTempWarningType = _T("");
	CString strCmd = _T("VCLB:");
	GetCommCommandName(strCmd);

	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
	{
		return FALSE;
	}

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);


	// 只考虑标准xyd、UVW、YD、XD 等平台且无移动拍照场景；
	if (optionInfo.m_bEnableCalibrateCheckByAxisMoveOption && 
		(m_pPlatformInfo->m_eMidPlatformType == ePlatformXYD || 
		m_pPlatformInfo->m_eMidPlatformType == ePlatformX1X2Y || 
		m_pPlatformInfo->m_eMidPlatformType ==ePlatformXY1Y2 ||  
		m_pPlatformInfo->m_eMidPlatformType ==ePlatformXY ||  
		m_pPlatformInfo->m_eMidPlatformType ==ePlatformXD ||  
		m_pPlatformInfo->m_eMidPlatformType ==ePlatformYD))
	{
		if (m_bValidObjectSearchTool!=TRUE )
		{
			SetStatusBarInfo(TRUE,_T("标定验证过程中"),GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT));
			PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
		BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
		if (m_bCmdParamAxisPosEanble)
		{
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		if (FALSE == bCommuciateGetPlatformAxisAbsPos)
		{
			if (pPlatformAxisPos!=NULL)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;					
			}

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_CALIBCHECK_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

			return FALSE;
		}

		double dTmpDx = optionInfo.m_dCalibrateCheckAxisMoveRangeX;
		double dTmpDy = optionInfo.m_dCalibrateCheckAxisMoveRangeY;
		double dTmpDd = optionInfo.m_dCalibrateCheckAxisMoveRangeD;

		// 角度
		vector <double> vAxisAngeMove;
		if (m_pPlatformInfo->m_eMidPlatformType ==ePlatformXY)
		{
			vAxisAngeMove.resize(1);
			vAxisAngeMove.at(0) = 0;
		}
		else
		{
			vAxisAngeMove.resize(3);
			vAxisAngeMove.at(0) = 0;
			vAxisAngeMove.at(1) = dTmpDd;
			vAxisAngeMove.at(2) = -dTmpDd;
		}

		// 平移
		vector <double> vAxisXMove;
		vector <double> vAxisYMove;

		switch(m_pPlatformInfo->m_eMidPlatformType)
		{
		case ePlatformXYD:
		case ePlatformX1X2Y:
		case ePlatformXY1Y2:
		case ePlatformXY:
			{
				vAxisXMove.resize(9);
				vAxisXMove.at(0) = 0;
				vAxisXMove.at(1) = dTmpDx;
				vAxisXMove.at(2) = dTmpDx;
				vAxisXMove.at(3) = dTmpDx;
				vAxisXMove.at(4) = 0;
				vAxisXMove.at(5) = -dTmpDx;
				vAxisXMove.at(6) = -dTmpDx;
				vAxisXMove.at(7) = -dTmpDx;
				vAxisXMove.at(8) = 0;

				vAxisYMove.resize(9);
				vAxisYMove.at(0) = 0;
				vAxisYMove.at(1) = dTmpDy;
				vAxisYMove.at(2) = 0;
				vAxisYMove.at(3) = -dTmpDy;
				vAxisYMove.at(4) = -dTmpDy;
				vAxisYMove.at(5) = -dTmpDy;
				vAxisYMove.at(6) = 0;
				vAxisYMove.at(7) = dTmpDy;
				vAxisYMove.at(8) = dTmpDy;
			}
			break;

		case ePlatformXD:
			{
				vAxisXMove.resize(3);
				vAxisYMove.resize(3);

				vAxisXMove.at(0) = 0;
				vAxisXMove.at(1) = dTmpDx;
				vAxisXMove.at(2) = 0;

				vAxisYMove.at(0) = 0;
				vAxisYMove.at(1) = 0;
				vAxisYMove.at(2) = 0;
			}
			break;

		case ePlatformYD:
			{
				vAxisXMove.resize(3);
				vAxisYMove.resize(3);

				vAxisXMove.at(0) = 0;
				vAxisXMove.at(1) = 0;
				vAxisXMove.at(2) = 0;

				vAxisYMove.at(0) = 0;
				vAxisYMove.at(1) = dTmpDy;
				vAxisYMove.at(2) = 0;
			}
			break;

		default:
			{
				return FALSE;
			}
			break;

		}

		double dD0=pPlatformAxisPos->m_dAngle;
		if (optionInfo.m_bCalibSendRelativePos)
		{
			dD0 = 0.0;
		}

		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)(GetAlignTool()->GetPlatformParam());//平台参数

		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//X轴方向为负
		{
			for (int it_X=0;it_X<vAxisXMove.size();it_X++)
			{
				vAxisXMove[it_X] = -vAxisXMove[it_X];
			}
		}

		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//Y轴方向为负
		{
			for (int it_Y=0;it_Y<vAxisYMove.size();it_Y++)
			{
				vAxisYMove[it_Y] = -vAxisYMove[it_Y];
			}
		}

		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
		{
			for (int it_D=0;it_D<vAxisAngeMove.size();it_D++)
			{
				vAxisAngeMove[it_D] = -vAxisAngeMove[it_D];
			}
		}

		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					for (int it_D=0;it_D<vAxisAngeMove.size();it_D++)
					{
						vAxisAngeMove[it_D] =  (sin(scDegree(dStartAngle + vAxisAngeMove[it_D])) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
					}
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					for (int it_D=0;it_D<vAxisAngeMove.size();it_D++)
					{
						vAxisAngeMove[it_D] =   (tan(scDegree(dStartAngle + vAxisAngeMove[it_D])) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
					}
				}
			}
		}


		CPlatformXYDAxisPos* pPlatformXYDAxisPosMove = new CPlatformXYDAxisPos();
		pPlatformXYDAxisPosMove->m_dPosX = pPlatformAxisPos->m_dPosX;
		pPlatformXYDAxisPosMove->m_dPosX = pPlatformAxisPos->m_dPosY;
		pPlatformXYDAxisPosMove->m_dAngle = pPlatformAxisPos->m_dAngle;


		// 考虑单产品扩展
		int nExProductIndex = nCalibPos/m_pPlatformInfo->m_nPositionNum;

		if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
		{
			SetAlignExProductIndex(nExProductIndex);
			GetAlignTool()->m_bEnableMultiCombinationCode = FALSE;
		}


		// 标定结果分析过程日志-标定相关参数
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			int nCurProductIndexFa = 0;
			int nCurProductIndexCh = 0;
			int nExProductIndex = 0;
			int nRemCalibPos = 0;
			m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa, nCurProductIndexCh);
			nExProductIndex = nCalibPos / m_pPlatformInfo->m_nPositionNum;			// 扩展产品序号
			nRemCalibPos	= nCalibPos % m_pPlatformInfo->m_nPositionNum;			// 位置序号

			CString strInfo;
			strInfo.Format(_T("	大品种%d, 小品种%d, 扩展产品%d, 位置%d	\n"),nCurProductIndexFa + 1, nCurProductIndexCh + 1, nExProductIndex + 1, nRemCalibPos + 1);
			VisionAlignLogRecord(m_strCalibrateProcessPath2, strInfo, TRUE);	

		}


		vector<double> XMove;
		vector<double> YMove;
		vector<double> DMove;
		for (int iter_D = 0;iter_D<vAxisAngeMove.size();iter_D++) // 无角度 正转 反转
		{
			// 走九宫格
			for (int iter_XY = 0; iter_XY<vAxisXMove.size() && iter_XY<vAxisYMove.size(); iter_XY++)  
			{
				XMove.push_back(vAxisXMove[iter_XY]);
				YMove.push_back(vAxisYMove[iter_XY]);
				DMove.push_back(vAxisAngeMove[iter_D]);
			}
		}

		//循环走位
		for (int iter_D = 0;iter_D<vAxisAngeMove.size();iter_D++) // 无角度 正转 反转
		{
			// 走九宫格
			for (int iter_XY = 0;iter_XY<vAxisXMove.size()  && iter_XY<vAxisYMove.size() ;iter_XY++)
			{

				pPlatformXYDAxisPosMove->m_dPosX = pPlatformAxisPos->m_dPosX + vAxisXMove[iter_XY];
				pPlatformXYDAxisPosMove->m_dPosY = pPlatformAxisPos->m_dPosY + vAxisYMove[iter_XY];
				pPlatformXYDAxisPosMove->m_dAngle =pPlatformAxisPos->m_dAngle + vAxisAngeMove[iter_D];

				if (optionInfo.m_bCalibSendRelativePos)
				{
					if (iter_XY==0 && iter_D == 0)
					{
						pPlatformXYDAxisPosMove->m_dPosX = XMove[0];
						pPlatformXYDAxisPosMove->m_dPosY = YMove[0];
						pPlatformXYDAxisPosMove->m_dAngle =DMove[0];
					}
					else
					{
						pPlatformXYDAxisPosMove->m_dPosX = XMove[iter_XY +iter_D*(vAxisXMove.size())]-XMove[iter_XY +iter_D*(vAxisXMove.size())-1];
						pPlatformXYDAxisPosMove->m_dPosY = YMove[iter_XY +iter_D*(vAxisXMove.size())]-YMove[iter_XY +iter_D*(vAxisXMove.size())-1];
						pPlatformXYDAxisPosMove->m_dAngle =DMove[iter_XY +iter_D*(vAxisXMove.size())]-DMove[iter_XY +iter_D*(vAxisXMove.size())-1];

					}
				}

				// 执行驱动失败
				if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPosMove))
				{	 
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), iter_XY+1) ;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_CALIBCHECK_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

					return FALSE;
				}

				Sleep(100);

				int nPosNum = (m_pPlatformInfo->m_bTargetObjectCamSeparate) ? m_pPlatformInfo->m_nPositionNum/2 : m_pPlatformInfo->m_nPositionNum;

				int nPosIndex = 0;
				std::vector<int> vnPosIndex;				
				for(nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
				{
					vnPosIndex.push_back(nPosIndex);
				}

				// 采用多位置对象拍照函数执行   默认从对象标准模板开始
				BOOL bSuccess = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, 0);



				CString strInfo = _T("");
				CString strTemp = _T("");
				if (bSuccess)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
					{
						strInfo.Empty();
						strTemp.Empty();

						strInfo.Format(_T("角度:%.3f-移动位置:%d（X:%.3f,Y%.3f）,"),vAxisAngeMove[iter_D],iter_XY+1,vAxisXMove[iter_XY],vAxisYMove[iter_XY]);

						AlignerObjectSizeInfo tmp_AlignerObjectSizeInfo;
						GetAlignerObjectSizeInfo(tmp_AlignerObjectSizeInfo);
						for (int it=0;it<tmp_AlignerObjectSizeInfo.m_vdObjectSize.size() && it<nPosIndex;it++)
						{
							strTemp.Format(_T("%s:%.3f,"),tmp_AlignerObjectSizeInfo.m_vstrObjectSizeName.at(it),tmp_AlignerObjectSizeInfo.m_vdObjectSize.at(it));
							strInfo += strTemp;
						}

						CCoordPos cp;	
						for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum() && i < nPosNum; i++)
						{
							strTemp = _T("");
							cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

							strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

							strInfo += strTemp;
						}

						VisionAlignLogRecord(m_strCalibrateProcessPath2, strInfo, FALSE);
					}
				}
				else
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
					{
						strInfo.Empty();
						strTemp.Empty();

						strInfo.Format(_T("角度:%.3f-移动位置:%d（X:%.3f,Y%.3f）,"),vAxisAngeMove[iter_D],iter_XY+1,vAxisXMove[iter_XY],vAxisYMove[iter_XY]);

						strTemp.Format(_T("搜索定位失败"));
						strInfo += strTemp;

						VisionAlignLogRecord(m_strCalibrateProcessPath2,strInfo, FALSE);
					}

					continue;
				}
			}
		}

		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if (pPlatformXYDAxisPosMove!=NULL)
		{
			delete pPlatformXYDAxisPosMove;
			pPlatformXYDAxisPosMove = NULL;					
		}

	}

	return TRUE;
}


BOOL vcXYDVisionAlign::ExecuteCalibrate_ObjectBench(int nCalibPos, int nMarkType)
{
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	if (!sysPlatformInfo.m_bEnableObjectCalibBench)
	{
		return TRUE;
	}


	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();

	int nExProductIdx = nCalibPos/m_pPlatformInfo->m_nPositionNum;	// 扩展产品序号
	int nRemCalibPos  = nCalibPos%m_pPlatformInfo->m_nPositionNum;	// 位置序号

	int nObjectCalibBenchIndex = sysPlatformInfo.m_nObjectCalibBenchIndex;
	if (sysPlatformInfo.m_bTargetObjectCamSeparate)
	{
		switch(sysPlatformInfo.m_eMidPlatformType)
		{
		case ePlatformXYPD:
			{
				// 后一半
				if (nRemCalibPos >= m_pPlatformInfo->m_nPositionNum/2)
				{
					nObjectCalibBenchIndex = sysPlatformInfo.m_nObjectCalibBenchIndex;
				}
				// 前一半
				else
				{
					return TRUE;
				}
			}
			break;

		default:
			{
				if (sysPlatformInfo.m_bTarObjCamSepAutoCalibTar)
				{
					// 前一半
					if (nRemCalibPos < m_pPlatformInfo->m_nPositionNum/2)
					{
						nObjectCalibBenchIndex = sysPlatformInfo.m_nObjectCalibBenchIndex;
					}
					// 后一半
					else
					{
						nObjectCalibBenchIndex = sysPlatformInfo.m_nObjectCalibBenchIndex + m_pPlatformInfo->m_nPositionNum/2;
					}
				}
				else
				{
					// 前一半
					if (nRemCalibPos < m_pPlatformInfo->m_nPositionNum/2)
					{
						nObjectCalibBenchIndex = sysPlatformInfo.m_nObjectCalibBenchIndex;
					}
					// 后一半
					else
					{
						return TRUE;
					}
				}
			}
			break;

		}		
	}

	if ((nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum != nCalibPos))
	{
		if (nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum] != NULL && vpAllCalibratedInfo[nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->IsValid())
		{
			CPlatformXYDAxisPos* pBenchPlatformAxisPos		= (CPlatformXYDAxisPos* )vpAllCalibratedInfo[nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->GetPlatformAxisPos();
			CPlatformXYDAxisPos* pCurrentPlatformAxisPos	= (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
			CPlatformXYDInfo*    pPlatformParam				= (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 

			double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
			double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;


			//平台各轴的方向	
			int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
			int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

			if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
			if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;

			CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->GetMarkPlatformCoordPos();
			CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();

			currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
			currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;

			vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
			vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
		}

		/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
		SetCurCalibratedInfo(vpAllCalibratedInfo);	

		// 保存标定后信息到当前产品中及配置文件中
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);

	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ExecuteCalibrate_CopyInfo_SingleCamera(int nCalibPos, int nMarkType)
{
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if ((optionInfo.m_bAutoCopyCalibData) && (sysPlatformInfo.m_nCamNum == 1))
	{
		int nExProductIdx=nCalibPos/m_pPlatformInfo->m_nPositionNum;//扩展产品序号

		std::vector<int> vnPos;
		for(int k=nExProductIdx*m_pPlatformInfo->m_nPositionNum;k<(nExProductIdx+1)*m_pPlatformInfo->m_nPositionNum;k++)
		{
			if (k != nCalibPos)
			{
				vnPos.push_back(k);
			}
		}

		BOOL bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
		if (FALSE == bResult)
		{
			ReportCalibResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_COPY_POS_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
		vpAllCalibratedInfo = GetAllCalibratedInfo();		

		// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
		SetCurCalibratedInfo(vpAllCalibratedInfo);	

		// 保存标定后信息到当前产品中及配置文件中
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ExecuteCalibrate_CopyInfo_VirtualMode(int nCalibPos, int nMarkType)
{
	// 			if (sysPlatformInfo.m_bEnableObjectPositionVirtualMode)
	// 			{
	// 				int nExProductIndex = nCalibPos/GetPosNum();
	// 				if (sysPlatformInfo.m_nObjectPositionNum == 2 && sysPlatformInfo.m_nTargetPositionNum == 4)
	// 				{
	// 
	// 					if (sysPlatformInfo.m_nObjectPositionVirtualMode == 0)
	// 					{
	// 						// 将1的标定信息复制到3；将2的标定信息复制到4
	// 						std::vector<int> vnPos;
	// 						for (int i = nExProductIndex*GetPosNum(); i < sysPlatformInfo.m_nObjectPositionNum+nExProductIndex*GetPosNum(); i++)
	// 						{
	// 							if (i == nCalibPos)
	// 							{
	// 								vnPos.push_back(i + sysPlatformInfo.m_nObjectPositionNum);
	// 							}
	// 						}
	// 
	// 						BOOL bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
	// 						if (FALSE == bResult)
	// 						{
	// 							ReportCalibResult(FALSE);
	// 
	// 							m_bStatusBar = FALSE;
	// 							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_COPY_POS_FAILED);
	// 							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	// 							PostMessageUpdateStatusBarInfo();
	// 							strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	// 							AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	// 							return FALSE;
	// 						}
	// 						//////////////////////////////////////////////////////////////////////////
	// 						vpAllCalibratedInfo = GetAllCalibratedInfo();
	// 						//////////////////////////////////////////////////////////////////////////
	// 					}
	// 					else if (sysPlatformInfo.m_nObjectPositionVirtualMode == 1)
	// 					{
	// 						// 将3的标定信息复制到1；将4的标定信息复制到2
	// 						std::vector<int> vnPos;
	// 						for (int i = nExProductIndex*GetPosNum(); i < sysPlatformInfo.m_nObjectPositionNum+nExProductIndex*GetPosNum(); i++)
	// 						{
	// 							if (i + sysPlatformInfo.m_nObjectPositionNum == nCalibPos)
	// 							{
	// 								vnPos.push_back(i);
	// 							}
	// 						}
	// 
	// 						BOOL bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
	// 						if (FALSE == bResult)
	// 						{
	// 							ReportCalibResult(FALSE);
	// 
	// 							m_bStatusBar = FALSE;
	// 							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_COPY_POS_FAILED);
	// 							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	// 							PostMessageUpdateStatusBarInfo();
	// 							strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	// 							AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	// 							return FALSE;
	// 						}
	// 						//////////////////////////////////////////////////////////////////////////
	// 						vpAllCalibratedInfo = GetAllCalibratedInfo();
	// 						//////////////////////////////////////////////////////////////////////////
	// 					}
	// 					else
	// 					{
	// 						ReportCalibResult(FALSE);
	// 
	// 						m_bStatusBar = FALSE;
	// 						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_COPY_POS_FAILED);
	// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	// 						PostMessageUpdateStatusBarInfo();
	// 						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	// 						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	// 						return FALSE;
	// 					}
	// 
	// 				}
	// 			}

	// 函数功能：对象目标虚拟点时，执行标定结果的自动拷贝
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// 没有开启虚拟对象目标点模式时返回
	if(!optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
	{
		return TRUE;
	}

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);

	if (pCurProductData == NULL)
	{
		return FALSE;
	}

	if (pCurProductData->m_pAlignerParam == NULL)
	{
		return FALSE;
	}

	if(!pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode)
	{
		return TRUE;
	}

	pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;

	int nObjectVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;

	int nExProductIdx=nCalibPos/m_pPlatformInfo->m_nPositionNum;//扩展产品序号
	int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum; 
	int nSrcPosIndex = nCalibPos;
	int nDstPosIndex;
	std::vector<int> vnPos;
	switch(nObjectVirtualMode)
	{
	case 0:
		{
			// 位置1、位置2
			if (nRemCalibPos==0)
			{
				nDstPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum +2;
				vnPos.push_back(nDstPosIndex);
			}
			else if(nRemCalibPos==1)
			{
				nDstPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum +3;
				vnPos.push_back(nDstPosIndex);
			}

		}
		break;
	case 1:
		{
			// 位置3、位置4
			if (nRemCalibPos==2)
			{
				nDstPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum +0;
				vnPos.push_back(nDstPosIndex);
			}
			else if(nRemCalibPos==3)
			{
				nDstPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum +1;
				vnPos.push_back(nDstPosIndex);
			}
		}
		break;
	case 2:
		{
			// 位置1、位置3
			if (nRemCalibPos==0)
			{
				nDstPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum +1;
				vnPos.push_back(nDstPosIndex);
			}
			else if(nRemCalibPos==2)
			{
				nDstPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum +3;
				vnPos.push_back(nDstPosIndex);
			}

		}
		break;
	case 3:
		{
			// 位置2、位置4
			if (nRemCalibPos==1)
			{
				nDstPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum +0;
				vnPos.push_back(nDstPosIndex);
			}
			else if(nRemCalibPos==3)
			{
				nDstPosIndex = nExProductIdx*m_pPlatformInfo->m_nPositionNum +2;
				vnPos.push_back(nDstPosIndex);
			}

		}
		break;
	default:
		{
			return FALSE;
		}
		break;
	}


	BOOL bResult = SetSameCalibrateInfo(nSrcPosIndex,vnPos);

	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo =  GetAllCalibratedInfo();	

	SetCurCalibratedInfo(vpAllCalibratedInfo);

	// 6.保存标定信息到磁盘中
	SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);

	return bResult;
}

BOOL vcXYDVisionAlign::ExecuteCalibrate_TargetBench(int nCalibPos, int nMarkType)
{
	// 保存标定位置为目标基准位置

	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	if (TRUE == m_pPlatformInfo->m_bEnableTargetBench)
	{
		int nExProductIdx=nCalibPos/m_pPlatformInfo->m_nPositionNum;//扩展产品序号

		for (int i=0; i<m_pPlatformInfo->m_nPositionNum && (i + nExProductIdx*m_pPlatformInfo->m_nPositionNum)< vpAllCalibratedInfo.size(); i++)
		{
			m_mpTargetMarkImagePos.m_vPos.at(i) = vpAllCalibratedInfo.at(i+ nExProductIdx*m_pPlatformInfo->m_nPositionNum)->GetMarkImgCoordPos();
			m_mpTargetMarkImagePos.m_vbOK.at(i) = TRUE;

			if (m_vpTargetPlatformAxisPos.at(i) != NULL)
			{
				*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i)) = *((CPlatformXYDAxisPos*)vpAllCalibratedInfo.at(i + nExProductIdx*m_pPlatformInfo->m_nPositionNum)->GetPlatformAxisPos());
			}
			else
			{
				m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
				*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i)) = *((CPlatformXYDAxisPos*)vpAllCalibratedInfo.at(i + nExProductIdx*m_pPlatformInfo->m_nPositionNum)->GetPlatformAxisPos());
			}

			SetTargetPlatformPos(m_vpTargetPlatformAxisPos.at(i),i);
			SetTempTargetPlatformAxisPos(i,m_vpTargetPlatformAxisPos.at(i));

		}

		m_bTargetMarkSearchSucceed = TRUE;
		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		SaveTargetPosInfo(nCurProductIndex);

		m_cVisionAlignGui.SetAllPosSearchResult(eTargetSearch);
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineSetPositionVirtualIndex(int nObjectVirtualIndex,int nTargetVirtualIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{
		ReportSetPositionVirtualFVPC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}



	//修改参数
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("切换虚拟位置失败");/*GetSysInfoString(m_psaSysInfoStrings，、_T("切换虚拟位置失败"));*/
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		ReportSetPositionVirtualFVPC(FALSE);
		return FALSE;
	}
	CProductPositionVirtualInfo prodectVirtualInfo;

	CString strObjectPositionVirtual = _T("");
	CString strTargetPositionVirtual = _T("");

	bool bNeedGetProductSize = false;

	// 当系统配置没有启用虚拟点模式时，该指令只能用于设置对象目标尺寸进行对角补偿用
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
	{
		if (nObjectVirtualIndex==0)
		{
			prodectVirtualInfo.m_bEnableObjectPositionVirtualMode = FALSE;
			strObjectPositionVirtual = _T("对象虚拟位置关闭");
		}
		else 
		{
			prodectVirtualInfo.m_bEnableObjectPositionVirtualMode = TRUE;
			prodectVirtualInfo.m_nObjectPositionVirtualMode = nObjectVirtualIndex-1;
			strObjectPositionVirtual.Format(_T("对象虚拟位置开启：%d"),nObjectVirtualIndex);
			bNeedGetProductSize = true;
		}
		if (nTargetVirtualIndex==0)
		{
			prodectVirtualInfo.m_bEnableTargetPositionVirtualMode = FALSE;
			strTargetPositionVirtual = _T("目标虚拟位置关闭");
		}
		else 
		{
			prodectVirtualInfo.m_bEnableTargetPositionVirtualMode = TRUE;
			prodectVirtualInfo.m_nTargetPositionVirtualMode = nTargetVirtualIndex-1;
			strTargetPositionVirtual.Format(_T("目标虚拟位置开启：%d"),nTargetVirtualIndex);
			bNeedGetProductSize = true;
		}

		//SetProductPositionVirtualInfo
		pCurProductData->m_pAlignerParam->SetProductPositionVirtualInfo(prodectVirtualInfo);

		CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
		pAlignerParam->SetProductPositionVirtualInfo(prodectVirtualInfo);
	}
	else
	{
		bNeedGetProductSize = true;
	}

	// 保存产品尺寸
	if (bNeedGetProductSize)
	{
		// 获取产品尺寸信息
		std::vector<CPlatformXYAxisPos*> vpProductSize;	 // 两个一个对象尺寸， 一个目标尺寸
		CPlatformXYAxisPos* pProductSize = NULL;
		for(int i = 0; i < 2 ; i++)
		{
			pProductSize = new CPlatformXYAxisPos;
			vpProductSize.push_back(pProductSize);
		}
		BOOL bCommuciateGetProductSize = FALSE; 

		bCommuciateGetProductSize = CommuciateGetProductSize(vpProductSize);
		if(!bCommuciateGetProductSize)
		{
			for(int i = 0; i < vpProductSize.size(); i++)
			{
				if(vpProductSize.at(i) != NULL)
					delete vpProductSize.at(i);
				vpProductSize.at(i) = NULL;
			}
			// 		m_bStatusBar = FALSE;
			// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_BENCH_FAIL);
			// 		m_strStatusBarInfo2 = _T("");
			// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			ReportCamCalibResult(FALSE);
			return FALSE;
		}
		else
		{
			// 验证数据的有效性
			for(int i = 0; i < vpProductSize.size() ; i++)
			{
				if(vpProductSize.at(i) == NULL)
				{
					m_bStatusBar = FALSE;
					//m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_BENCH_FAIL);
					//m_strStatusBarInfo2 = _T("");
					//SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					ReportCamCalibResult(FALSE);
					for(int i = 0; i < vpProductSize.size(); i++)
					{
						if(vpProductSize.at(i) != NULL)
							delete vpProductSize.at(i);
						vpProductSize.at(i) = NULL;
					}
					return FALSE;
				}
			}
		}

		CProductSizeInfo productSizeInfo;
		productSizeInfo = pCurProductData->m_pAlignerParam->GetProductSizeInfo();

		productSizeInfo.m_dObjectL1 = vpProductSize.at(0)->m_dPosX;
		productSizeInfo.m_dObjectW1 = vpProductSize.at(0)->m_dPosY;
		productSizeInfo.m_dTargetL2 = vpProductSize.at(1)->m_dPosX;
		productSizeInfo.m_dTargetW2 = vpProductSize.at(1)->m_dPosY;
		pCurProductData->m_pAlignerParam->SetProductSizeInfo(productSizeInfo);

		strObjectPositionVirtual +=_T("对象、目标长宽尺寸设置成功");
		for(int i = 0; i < vpProductSize.size(); i++)
		{
			if(vpProductSize.at(i) != NULL)
				delete vpProductSize.at(i);
			vpProductSize.at(i) = NULL;
		}
	}


	//保存参数
	if (!SaveProductDataInfo(nCurProductIndex))
	{
		ReportSetPositionVirtualFVPC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("切换虚拟位置失败"); /*GetSysInfoString(m_psaSysInfoStrings,IDS_SAVE_PRODUCT_FAILE);//_T("保存产品失败");*/
		m_strStatusBarInfo2 = _T("保存参数失败");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	ReportSetPositionVirtualFVPC(TRUE);//SendCommInfo(CMD_TN_SUCCEED);

	//PostMessageUpdateAlignPrecisionInfo();

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 =strObjectPositionVirtual; //GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);
	m_strStatusBarInfo2 = strTargetPositionVirtual;
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

//   设置系统的选项信息
void vcXYDVisionAlign::SetSystemOptionConfig(CSystemOptionConfig *pSystemOptionConfig)
{
  	if (pSystemOptionConfig == NULL)
	{
		return;
	}
	m_pSystempOptionConfig = pSystemOptionConfig;

	m_pSystempOptionConfig->m_nMinute = m_FPMI;
	m_pSystempOptionConfig->m_nMinuteFPMI = m_FPMIMIN;
	/*CommProtocolParam commProtocolParam;
	commProtocolParam.m_nCommTimeOut = m_pSystempOptionConfig->m_nCommTimeOut;
	commProtocolParam.m_nCommReSendTimes = m_pSystempOptionConfig->m_nCommReSendTimes;
	commProtocolParam.m_nCommXYUnitExp = m_pSystempOptionConfig->m_nCommXYUnitExp;
	commProtocolParam.m_nCommDUnitExp = m_pSystempOptionConfig->m_nCommDUnitExp;
	commProtocolParam.m_nCommDataLenType = m_pSystempOptionConfig->m_nCommDataLenType;
	m_XYDCommProtocol.SetCommProtocolParam(commProtocolParam);*/
	m_XYDCommProtocol.SetSystemOptionConfig(*m_pSystempOptionConfig);

}

BOOL vcXYDVisionAlign::SetProductCameraShutter(int nIndex )
{
	CameraParam             cameraParam;
	ImageRoi imageROI;
	BOOL bLoad = FALSE;
	CString strProductIndex;
	CString strPath, strInfo;
	int i = 0, j = 0, nData = 0, nPosNum = 0;
	strProductIndex.Format(_T("%03d"), nIndex+1);
	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath + _T("\\Jobs\\") + strProductIndex + _T("\\Camera.xml");


	CString  strPlatformXMLAdrr;
	strPlatformXMLAdrr  = m_pVisionASMConfig->m_strConfigPath;
	vcXMLConfigurator m_XMLConfigator2;

	m_XMLConfigator2.Load(strPlatformXMLAdrr);

	//加载配置文件
	//BOOL bLoadResult = FALSE;	
	//bLoadResult = m_XMLConfigator2.Load(strPlatformXMLAdrr);

	bLoad = m_XMLConfigator.Load(strPath);
	if (!bLoad) // 修复产品的相机信息xml文件缺失时，切换产品曝光增益时，能够正常载入
	{
		return TRUE;
	}

	if(FALSE == m_XMLConfigator.FindElem(_T("CamParam")))
	{
		return FALSE;
	}
	m_XMLConfigator.EnterElem();

	for (i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{
		cameraParam = m_pVisionASMConfig->m_vCameraParam.at(i);
		strInfo.Format(_T("CamParam%d"),i);

		if(TRUE == m_XMLConfigator.FindElem(strInfo))
		{
			m_XMLConfigator.EnterElem();

			// 曝光时间
			if (m_XMLConfigator.FindElem(_T("Shutter")))
			{
				m_XMLConfigator.GetElemData(cameraParam.m_dShutter);				 
			}
			else
			{
				m_XMLConfigator.LeaveElem();
				return FALSE;
			}

			// 增益
			if (m_XMLConfigator.FindElem(_T("Gain")))
			{
				m_XMLConfigator.GetElemData(cameraParam.m_dGain);				 
			}		
			else
			{
				m_XMLConfigator.LeaveElem();
				return FALSE;
			}

			// GammaEnable
			if (m_XMLConfigator.FindElem(_T("GammaEnable")))
			{
				int nVal = 0;
				m_XMLConfigator.GetElemData(nVal);				 
				cameraParam.m_bGammaEnable = (bool)nVal;
			}		


			// Gamma
			if (m_XMLConfigator.FindElem(_T("Gamma")))
			{
				m_XMLConfigator.GetElemData(cameraParam.m_dGamma);				 
			}


			m_XMLConfigator.LeaveElem();


			scPTGrab2* pPTGrab = m_vpCamera[i];


			BOOL bOk1 , bOk2;
			bOk1 = pPTGrab->SetCurShutter(cameraParam.m_dShutter);
			bOk2 = pPTGrab->SetCurGain(cameraParam.m_dGain);



			///////////////写入环境配置///////////////
			{


				if(FALSE == m_XMLConfigator2.FindElem(_T("WorkStationConfig")))	
				{
					//m_XMLConfigator.AddElem(_T("WorkStationConfig"));
					AlignXmlLog(_T("SaveCameraInfo"), _T("Find:WorkStationConfig"), FALSE);
					return FALSE;
				}

				m_XMLConfigator2.EnterElem();

				// 相机信息：以序列号采集
				//CameraParam cameraParam;;

				if(FALSE == m_XMLConfigator2.FindElem(_T("CamParam")))
				{
					m_XMLConfigator2.AddElem(_T("CamParam"));
				}
				m_XMLConfigator2.EnterElem();

				//for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
				{
					strInfo.Format(_T("CamParam%d"),i);


					if(FALSE == m_XMLConfigator2.FindElem(strInfo))
					{
						m_XMLConfigator2.AddElem(strInfo);
					}
					m_XMLConfigator2.EnterElem();			 

					// 曝光时间
					if(FALSE == m_XMLConfigator2.FindElem(_T("Shutter")))
					{
						m_XMLConfigator2.AddElem(_T("Shutter"));
					}
					m_XMLConfigator2.SetElemData(cameraParam.m_dShutter);				 

					// 增益
					if(FALSE == m_XMLConfigator2.FindElem(_T("Gain")))
					{
						m_XMLConfigator2.AddElem(_T("Gain"));
					}
					m_XMLConfigator2.SetElemData(cameraParam.m_dGain);

					// GammaEnable
					if(FALSE == m_XMLConfigator2.FindElem(_T("GammaEnable")))
					{
						m_XMLConfigator2.AddElem(_T("GammaEnable"));
					}
					m_XMLConfigator2.SetElemData(cameraParam.m_bGammaEnable);

					// Gamma
					if(FALSE == m_XMLConfigator2.FindElem(_T("Gamma")))
					{
						m_XMLConfigator2.AddElem(_T("Gamma"));
					}
					m_XMLConfigator2.SetElemData(cameraParam.m_dGamma);

					m_XMLConfigator2.LeaveElem();
				}

				m_XMLConfigator2.LeaveElem();

				// 保存Gamma

				imageROI = m_pVisionASMConfig->m_vImageRoi.at(i);
				imageROI.m_dGamma = cameraParam.m_dGamma;
				imageROI.m_bGammaCorrectionEnable = cameraParam.m_bGammaEnable;

				if(FALSE == m_XMLConfigator2.FindElem(_T("CamDisp")))
				{
					m_XMLConfigator2.AddElem(_T("CamDisp"));
				}
				m_XMLConfigator2.EnterElem();
				{
					strInfo.Format(_T("CamDisp%d"),i);
					if(FALSE == m_XMLConfigator2.FindElem(strInfo))
					{
						m_XMLConfigator2.AddElem(strInfo);
					}
					m_XMLConfigator2.EnterElem();	
					{
						// GammaCorrectionEnable
						if (FALSE == m_XMLConfigator.FindElem(_T("GammaCorrectionEnable")))
						{
							m_XMLConfigator.AddElem(_T("GammaCorrectionEnable"));			 
						}			
						m_XMLConfigator.SetElemData(imageROI.m_bGammaCorrectionEnable);

						// Gamma
						if (FALSE == m_XMLConfigator.FindElem(_T("Gamma")))
						{
							m_XMLConfigator.AddElem(_T("Gamma"));				 
						}			
						m_XMLConfigator.SetElemData(imageROI.m_dGamma);
					}
					m_XMLConfigator2.LeaveElem();
				}
				m_XMLConfigator2.LeaveElem();


				m_XMLConfigator2.LeaveElem();

				BOOL bOK= m_XMLConfigator2.Save(strPlatformXMLAdrr);


			}
			m_pVisionASMConfig->m_vCameraParam.at(i) = cameraParam;
			m_pVisionASMConfig->m_vImageRoi.at(i) = imageROI;
			SetPosImageROIParam(i, imageROI);
		}
		else
		{
			return FALSE;
		}			
	}

	m_XMLConfigator.LeaveElem();

	m_XMLConfigator.LeaveElem();

	/////////////////////////////////////////////////////////////////////////////



	return TRUE;

}


// void vcXYDVisionAlign::InitTargetPlatformAxisPos()
// {
// 	UnInitTargetPlatformAxisPos();
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	m_vpTargetPlatformAxisPos.resize(nPosNum,NULL);
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
// 	}
// 
// 	for (i=0;i<MUTITARGETMAXNUM;i++)
// 	{
// 		m_vpMutiTargetPlatformAxisPos.at(i).resize(nPosNum,NULL);
// 		for (int j=0;j<nPosNum;j++)
// 		{
// 			m_vpMutiTargetPlatformAxisPos.at(i).at(j)= new CPlatformXYDAxisPos;
// 		}
// 	}
// 	for (i=0;i< m_vvpTargetPlatformAxisPosMultiEx.size();i++)
// 	{
// 		m_vvpTargetPlatformAxisPosMultiEx.at(i).resize(nPosNum,NULL);
// 		for (int j=0;j<nPosNum;j++)
// 		{
// 			m_vvpTargetPlatformAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
// 		}
// 	}
// }

// void vcXYDVisionAlign::InitCrossBenchTargetPlatformAxisPos()
// {
// 	UnInitCrossBenchTargetPlatformAxisPos();
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	m_vpCrossBenchPlatformAxisPos.resize(nPosNum,NULL);
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		m_vpCrossBenchPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
// 	}
// }

// void vcXYDVisionAlign::InitObjectPlatformAxisPos()
// {
// 	UnInitObjectPlatformAxisPos();
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	m_vpObjectPlatformAxisPos.resize(nPosNum,NULL);
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		m_vpObjectPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
// 	}
// 	for (i=0;i<m_vvpObjectPlatformAxisPosMultiEx.size();i++)
// 	{
// 		m_vvpObjectPlatformAxisPosMultiEx.at(i).resize(nPosNum,NULL);
// 		for (int j=0;j<nPosNum;j++)
// 		{
// 			m_vvpObjectPlatformAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
// 		}
// 	}
// }

// void vcXYDVisionAlign::InitObjectCamAxisPos()
// {
// 	UnInitObjectCamAxisPos();
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	m_vpObjectCamAxisPos.resize(nPosNum,NULL);
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		m_vpObjectCamAxisPos.at(i) = new CPlatformXYAxisPos;
// 	}
// 	for (i=0;i< m_vvpObjectCamAxisPosMultiEx.size();i++)
// 	{
// 		m_vvpObjectCamAxisPosMultiEx.at(i).resize(nPosNum,NULL);
// 		for (int j=0;j<nPosNum;j++)
// 		{
// 			m_vvpObjectCamAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
// 		}
// 	}
// 
// }

// void vcXYDVisionAlign::InitObjectCamAxisPlatformAxisPos()
// {
// 	UnInitObjectCamAxisPlatformAxisPos();
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	m_vpObjectCamAxisPlatformAxisPos.resize(nPosNum,NULL);
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		m_vpObjectCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos;
// 	}
// 	for (i=0;i< m_vvpObjectCamAxisPlatformAxisPosMultiEx.size();i++)
// 	{
// 		m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).resize(nPosNum,NULL);
// 		for (int j=0;j<nPosNum;j++)
// 		{
// 			m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
// 		}
// 	}
// }

// void vcXYDVisionAlign::InitTargetCamAxisPos()
// {
// 	UnInitTargetCamAxisPos();
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	m_vpTargetCamAxisPos.resize(nPosNum,NULL);
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		m_vpTargetCamAxisPos.at(i) = new CPlatformXYAxisPos;
// 	}
// 	for (i=0;i< m_vvpTargetCamAxisPosMultiEx.size();i++)
// 	{
// 		m_vvpTargetCamAxisPosMultiEx.at(i).resize(nPosNum,NULL);
// 		for (int j=0;j<nPosNum;j++)
// 		{
// 			m_vvpTargetCamAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
// 		}
// 	}
// }

// void vcXYDVisionAlign::InitTargetCamAxisPlatformAxisPos()
// {
// 	UnInitTargetCamAxisPlatformAxisPos();
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	m_vpTargetCamAxisPlatformAxisPos.resize(nPosNum,NULL);
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		m_vpTargetCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos;
// 	}
// 	for (i=0;i< m_vvpTargetCamAxisPlatformAxisPosMultiEx.size();i++)
// 	{
// 		m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).resize(nPosNum,NULL);
// 		for (int j=0;j<nPosNum;j++)
// 		{
// 			m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j)= new CPlatformXYDAxisPos;
// 		}
// 	}
// }

// void vcXYDVisionAlign::SetTempTargetPlatformAxisPos(int nPosIndex, CPlatformAxisPos* pPlatformAxisPos)
// {
// 
// 	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
// 	{
// 		return;
// 	}	
// 	if (pPlatformAxisPos==NULL)
// 	{
// 		return;
// 	}
// 
// 	if (m_vpTargetPlatformAxisPos.at(nPosIndex) != NULL)
// 	{
// 		*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// 	else
// 	{
// 		m_vpTargetPlatformAxisPos.at(nPosIndex) = new CPlatformXYDAxisPos;
// 		*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// 	if (m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) != NULL)
// 	{
// 		*((CPlatformXYDAxisPos*)m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// 	else
// 	{
// 		m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) = new CPlatformXYDAxisPos;
// 		*((CPlatformXYDAxisPos*)m_vvpTargetPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// }

// void vcXYDVisionAlign::SetTempCrossBenchTargetPlatformAxisPos(int nPosIndex, CPlatformAxisPos* pPlatformAxisPos)
// {
// 
// 	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
// 	{
// 		return;
// 	}	
// 	if (pPlatformAxisPos==NULL)
// 	{
// 		return;
// 	}
// 
// 	if (m_vpCrossBenchPlatformAxisPos.at(nPosIndex) != NULL)
// 	{
// 		*((CPlatformXYDAxisPos*)m_vpCrossBenchPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// 	else
// 	{
// 		m_vpCrossBenchPlatformAxisPos.at(nPosIndex) = new CPlatformXYDAxisPos;
// 		*((CPlatformXYDAxisPos*)m_vpCrossBenchPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// }

// void vcXYDVisionAlign::SetTempObjectPlatformAxisPos(int nPosIndex, CPlatformAxisPos* pPlatformAxisPos)
// {
// 
// 	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
// 	{
// 		return;
// 	}	
// 	if (pPlatformAxisPos==NULL)
// 	{
// 		return;
// 	}
// 
// 	if (m_vpObjectPlatformAxisPos.at(nPosIndex) != NULL)
// 	{
// 		*((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// 	else
// 	{
// 		m_vpObjectPlatformAxisPos.at(nPosIndex) = new CPlatformXYDAxisPos;
// 		*((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// 
// 	if (m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) != NULL)
// 	{
// 		*(CPlatformXYDAxisPos*)m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// 	else
// 	{
// 		m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex) = new CPlatformXYDAxisPos;
// 		*((CPlatformXYDAxisPos*)m_vvpObjectPlatformAxisPosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()).at(nPosIndex)) = *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 	}
// }

// void vcXYDVisionAlign::SetTempTargetCamAxisPos(int nPosIndex,CPlatformXYAxisPos* pCamAxisPos)
// {
// 	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
// 	{
// 		return;
// 	}	
// 	if (pCamAxisPos==NULL)
// 	{
// 		return;
// 	}
// 
// 	if (m_vpTargetCamAxisPos.at(nPosIndex) != NULL)
// 	{
// 		*((CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
// 	}
// 	else
// 	{
// 		m_vpTargetCamAxisPos.at(nPosIndex) = new CPlatformXYAxisPos;
// 		*((CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
// 	}
// }

// void vcXYDVisionAlign::SetTempObjectCamAxisPos(int nPosIndex,CPlatformXYAxisPos* pCamAxisPos)
// {
// 	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
// 	{
// 		return;
// 	}	
// 	if (pCamAxisPos==NULL)
// 	{
// 		return;
// 	}
// 
// 	if (m_vpObjectCamAxisPos.at(nPosIndex) != NULL)
// 	{
// 		*((CPlatformXYAxisPos*)m_vpObjectCamAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
// 	}
// 	else
// 	{
// 		m_vpObjectCamAxisPos.at(nPosIndex) = new CPlatformXYAxisPos;
// 		*((CPlatformXYAxisPos*)m_vpObjectCamAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
// 	}
// }

// void vcXYDVisionAlign::SetTempTargetCamAxisPlatformAxisPos(int nPosIndex,CPlatformXYAxisPos* pCamAxisPos)
// {
// 	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
// 	{
// 		return;
// 	}	
// 	if (pCamAxisPos==NULL)
// 	{
// 		return;
// 	}
// 
// 	if (m_vpTargetCamAxisPlatformAxisPos.at(nPosIndex) != NULL)
// 	{
// 		*((CPlatformXYAxisPos*)m_vpTargetCamAxisPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
// 	}
// 	else
// 	{
// 		m_vpTargetCamAxisPlatformAxisPos.at(nPosIndex) = new CPlatformXYAxisPos;
// 		*((CPlatformXYAxisPos*)m_vpTargetCamAxisPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
// 	}
// }
// void vcXYDVisionAlign::SetTempObjectCamAxisPlatformAxisPos(int nPosIndex,CPlatformXYAxisPos* pCamAxisPos)
// {
// 	if (nPosIndex < 0 || nPosIndex>=GetPosNum())
// 	{
// 		return;
// 	}	
// 	if (pCamAxisPos==NULL)
// 	{
// 		return;
// 	}
// 
// 	if (m_vpObjectCamAxisPlatformAxisPos.at(nPosIndex) != NULL)
// 	{
// 		*((CPlatformXYAxisPos*)m_vpObjectCamAxisPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
// 	}
// 	else
// 	{
// 		m_vpObjectCamAxisPlatformAxisPos.at(nPosIndex) = new CPlatformXYAxisPos;
// 		*((CPlatformXYAxisPos*)m_vpObjectCamAxisPlatformAxisPos.at(nPosIndex)) = *((CPlatformXYAxisPos*)pCamAxisPos);
// 	}
// }

// BOOL vcXYDVisionAlign::LoadTargetPosInfo(int nIndex)
// {
// 	ASSERT(nIndex >= 0);
// 	ASSERT(m_pVisionASMConfig != NULL);
// 	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
// 	ASSERT(m_pPlatformInfo != NULL);
// 
// 	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
// 	{
// 		return FALSE;
// 	}
// 	if (m_pVisionASMConfig == NULL)
// 	{
// 		return FALSE;
// 	}
// 	if (m_pPlatformInfo == NULL)
// 	{
// 		return FALSE;
// 	}
// 	CString strInfo;
// 	double dValue = 0;
// 	int i = 0, j = 0, nData = 0;
// 	CCoordPos pos;
// 	CPlatformXYDAxisPos		*pPlatformAxisPos = NULL;
// 	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
// 	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;
// 
// 	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
// 	strName.Format(_T("%03d"),nIndex+1);
// 	if (strName.IsEmpty())	// 产品名称为空，不合法
// 	{
// 		return FALSE;
// 	}
// 
// 	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
// 		+ _T("\\Jobs\\") + strName + _T("\\SearchData.xml");
// 
// 	vcXMLConfigurator m_XMLConfigator;
// 	m_XMLConfigator.SetDoc(_T(""));
// 	if (!m_XMLConfigator.Load(strDir))
// 	{
// 		return FALSE;
// 	}
// 
// 	if (!m_XMLConfigator.FindElem(_T("SearchData")))// (Root)
// 	{
// 		return FALSE;
// 	}
// 	m_XMLConfigator.EnterElem();
// 
// 	//兼容之前结构  // 
// 
// 	if (FALSE == m_pPlatformInfo->m_bEnableMultiCalibExtension)
// 	{
// 		// 
// 		for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 		{
// 			strInfo.Format(_T("TargetResult%d"),i);
// 			if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
// 			{
// 				m_XMLConfigator.EnterElem();
// 				if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
// 				{
// 					m_XMLConfigator.EnterElem();
// 					CPlatformXYDAxisPos AxisPos;
// 					if (m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("PosD")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
// 					}
// 
// 					if (m_vpTargetPlatformAxisPos.at(i) != NULL)
// 					{
// 						delete m_vpTargetPlatformAxisPos.at(i);
// 						m_vpTargetPlatformAxisPos.at(i)=NULL;
// 
// 						m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos(AxisPos);
// 					}
// 					else
// 					{
// 						m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos(AxisPos);
// 					}
// 
// 					m_XMLConfigator.LeaveElem();
// 				}
// 				if (m_XMLConfigator.FindElem(_T("CamAxisPos")))  // (Level-2) 相机轴位置
// 				{
// 					m_XMLConfigator.EnterElem();
// 					CPlatformXYAxisPos AxisPos;
// 					if (m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 					}
// 
// 					if (m_vpTargetCamAxisPos.at(i) != NULL)
// 					{
// 						delete m_vpTargetCamAxisPos.at(i);
// 						m_vpTargetCamAxisPos.at(i)=NULL;
// 
// 						m_vpTargetCamAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
// 					}
// 					else
// 					{
// 						m_vpTargetCamAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
// 					}
// 
// 					m_XMLConfigator.LeaveElem();
// 				}
// 				if (m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))  // (Level-2) 相机轴位置
// 				{
// 					m_XMLConfigator.EnterElem();
// 					CPlatformXYAxisPos AxisPos;
// 					if (m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 					}
// 
// 					if (m_vpTargetCamAxisPlatformAxisPos.at(i) != NULL)
// 					{
// 						delete m_vpTargetCamAxisPlatformAxisPos.at(i);
// 						m_vpTargetCamAxisPlatformAxisPos.at(i)=NULL;
// 
// 						m_vpTargetCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
// 					}
// 					else
// 					{
// 						m_vpTargetCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
// 					}
// 
// 					m_XMLConfigator.LeaveElem();
// 				}
// 				if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
// 				{
// 					m_XMLConfigator.EnterElem();
// 
// 					nData = 0;
// 					if (m_XMLConfigator.FindElem(_T("Valid")))
// 					{
// 						m_XMLConfigator.GetElemData(nData);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("ImageX")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dPosX);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("ImageY")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dPosY);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("ImageD")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dAngle);
// 					}
// 
// 					int nAuxiliaryIndex = 0;
// 					for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 					{
// 						CString strAuxiliary;
// 						strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 						if (m_XMLConfigator.FindElem(strAuxiliary))
// 						{
// 							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 						}
// 						strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 						if (m_XMLConfigator.FindElem(strAuxiliary))
// 						{
// 							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 						}
// 						strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 						if (m_XMLConfigator.FindElem(strAuxiliary))
// 						{
// 							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 						}
// 					}
// 
// 					if (m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dLineAngle1);
// 					}
// 
// 					if (m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dLineAngle2);
// 					}
// 
// 					m_mpTargetMarkImagePos.SetMarkImagePos(i, nData, pos);
// 
// 					m_XMLConfigator.LeaveElem();
// 				}
// 
// 
// 				m_XMLConfigator.LeaveElem();
// 			}
// 		}
// 	}
// 	else
// 	{
// 		int nNums = 1;
// 		if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
// 		{
// 			nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
// 		}
// 
// 		for (int it =0;it < nNums;it++)
// 		{
// 			strInfo.Format(_T("ProducetMultiExTarget%d"),it);
// 			if(m_XMLConfigator.FindElem(strInfo))//  扩展序号节点
// 			{
// 				m_XMLConfigator.EnterElem();
// 
// 				for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 				{
// 					strInfo.Format(_T("TargetResult%d"),i);
// 					if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
// 					{
// 						m_XMLConfigator.EnterElem();
// 						if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 
// 							if (it<m_vvpTargetPlatformAxisPosMultiEx.size())
// 							{
// 								CPlatformXYDAxisPos AxisPos;
// 								if (m_XMLConfigator.FindElem(_T("PosX")))
// 								{
// 									m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 								}
// 								if (m_XMLConfigator.FindElem(_T("PosY")))
// 								{
// 									m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 								}
// 								if (m_XMLConfigator.FindElem(_T("PosD")))
// 								{
// 									m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
// 								}
// 
// 								if (m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i) != NULL)
// 								{
// 									delete m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i);
// 									m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i)=NULL;
// 
// 									m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYDAxisPos(AxisPos);
// 								}
// 								else
// 								{
// 									m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYDAxisPos(AxisPos);
// 								}
// 							}
// 
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 						if (m_XMLConfigator.FindElem(_T("CamAxisPos")))  // (Level-2) 相机轴位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 							CPlatformXYAxisPos AxisPos;
// 							if (it<m_vvpTargetCamAxisPosMultiEx.size())
// 							{
// 								if (m_XMLConfigator.FindElem(_T("PosX")))
// 								{
// 									m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 								}
// 								if (m_XMLConfigator.FindElem(_T("PosY")))
// 								{
// 									m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 								}
// 
// 								if (m_vvpTargetCamAxisPosMultiEx.at(it).at(i) != NULL)
// 								{
// 									delete m_vvpTargetCamAxisPosMultiEx.at(it).at(i) ;
// 									m_vvpTargetCamAxisPosMultiEx.at(it).at(i) =NULL;
// 
// 									m_vvpTargetCamAxisPosMultiEx.at(it).at(i)  = new CPlatformXYAxisPos(AxisPos);
// 								}
// 								else
// 								{
// 									m_vvpTargetCamAxisPosMultiEx.at(it).at(i)  = new CPlatformXYAxisPos(AxisPos);
// 								}
// 							}
// 							
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 						if (m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))  // (Level-2) 相机轴位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 							if (it<m_vvpTargetCamAxisPlatformAxisPosMultiEx.size())
// 							{
// 								CPlatformXYAxisPos AxisPos;
// 								if (m_XMLConfigator.FindElem(_T("PosX")))
// 								{
// 									m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 								}
// 								if (m_XMLConfigator.FindElem(_T("PosY")))
// 								{
// 									m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 								}
// 
// 								if (m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i) != NULL)
// 								{
// 									delete m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i);
// 									m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i)=NULL;
// 
// 									m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
// 								}
// 								else
// 								{
// 									m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
// 								}
// 							}
// 
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 						if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 
// 							nData = 0;
// 							if (m_XMLConfigator.FindElem(_T("Valid")))
// 							{
// 								m_XMLConfigator.GetElemData(nData);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageX")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dPosX);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageY")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dPosY);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageD")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dAngle);
// 							}
// 
// 							int nAuxiliaryIndex = 0;
// 							for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 							{
// 								CString strAuxiliary;
// 								strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 								}
// 								strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 								}
// 								strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 								}
// 							}
// 
// 							if (m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dLineAngle1);
// 							}
// 
// 							if (m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dLineAngle2);
// 							}
// 
// 							if (it < m_vmpTargetMarkImagePosMultiEx.size())
// 							{
// 								m_vmpTargetMarkImagePosMultiEx.at(it).SetMarkImagePos(i, nData, pos);
// 							}
// 
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 
// 
// 						m_XMLConfigator.LeaveElem();
// 					}
// 				}
// 
// 
// 				m_XMLConfigator.LeaveElem();
// 			}
// 		}
// 	}
// 
// 	//多目标定位储存目标结果
// 	if (1)
// 	{
// 		for(int j=0;j<MUTITARGETMAXNUM;j++)
// 		{
// 			strInfo.Format(_T("MutiTargetResult%d"),j);
// 			if (m_XMLConfigator.FindElem(strInfo))
// 			{
// 				m_XMLConfigator.EnterElem();
// 				for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 				{
// 					strInfo.Format(_T("TargetResult%d"),i);
// 					if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
// 					{
// 						m_XMLConfigator.EnterElem();
// 						if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 							CPlatformXYDAxisPos AxisPos;
// 							if (m_XMLConfigator.FindElem(_T("PosX")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("PosY")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("PosD")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
// 							}
// 
// 							if (m_vpMutiTargetPlatformAxisPos.at(j).at(i) != NULL)
// 							{
// 								delete m_vpMutiTargetPlatformAxisPos.at(j).at(i);
// 								m_vpMutiTargetPlatformAxisPos.at(j).at(i)=NULL;
// 
// 								m_vpMutiTargetPlatformAxisPos.at(j).at(i) = new CPlatformXYDAxisPos(AxisPos);
// 							}
// 							else
// 							{
// 								m_vpMutiTargetPlatformAxisPos.at(j).at(i) = new CPlatformXYDAxisPos(AxisPos);
// 							}
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 
// 						if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 
// 							nData = 0;
// 							if (m_XMLConfigator.FindElem(_T("Valid")))
// 							{
// 								m_XMLConfigator.GetElemData(nData);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageX")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dPosX);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageY")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dPosY);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageD")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dAngle);
// 							}
// 
// 							int nAuxiliaryIndex = 0;
// 							for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 							{
// 								CString strAuxiliary;
// 								strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 								}
// 								strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 								}
// 								strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 								}
// 							}
// 
// 							m_vMutiTargetMarkImagePos.at(j).SetMarkImagePos(i, nData, pos);
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 
// 
// 						m_XMLConfigator.LeaveElem();
// 					}
// 				}
// 				
// 				int nData=0;
// 				if (m_XMLConfigator.FindElem(_T("TargetResultOK")))// (Level-1) 搜索结果
// 				{
// 					m_XMLConfigator.GetElemData(nData);
// 				}
// 				m_vbMutiTargetMarkOK.at(j)=(BOOL)nData;
// 				m_XMLConfigator.LeaveElem();
// 			}
// 
// 
// 		}
// 	}
// 
// 	
// 
// 
// 
// 	m_XMLConfigator.LeaveElem();
// 
// 
// 	return TRUE;
// }

// BOOL vcXYDVisionAlign::SaveTargetPosInfo(int nIndex)
// {
// 	CString strInfo2;
// 	strInfo2.Format("SaveTargetPosInfo- Enter");
// 	VisionAlignLogRecord(m_strAlignProcessData, strInfo2);
// 
// 	ASSERT(nIndex >= 0);
// 	ASSERT(m_pVisionASMConfig != NULL);
// 	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
// 	ASSERT(m_pPlatformInfo != NULL);
// 
// // 	if (m_searchAllResultStatus == eSARSResultNG1 ||m_searchAllResultStatus == eSARSResultNGMore)
// // 	{
// // 		return TRUE;
// // 	}
// 	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
// 	{
// 		return FALSE;
// 	}
// 	if (m_pVisionASMConfig == NULL)
// 	{
// 		return FALSE;
// 	}
// 	if (m_pPlatformInfo == NULL)
// 	{
// 		return FALSE;
// 	}
// 	CString strInfo;
// 	double dValue = 0;
// 	int i = 0, j = 0, nData = 0;
// 	CCoordPos pos;
// 	CPlatformXYDAxisPos		*pPlatformAxisPos = NULL;
// 	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
// 	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;
// 	CPlatformXYAxisPos		*pTargetCamAxisPos = NULL;
// 	CPlatformOptionInfo optionInfo;
// 	GetPlatformOptionInfo(optionInfo);
// 	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
// 	strName.Format(_T("%03d"),nIndex+1);
// 	if (strName.IsEmpty())	// 产品名称为空，不合法
// 	{
// 		return FALSE;
// 	}
// 
// 	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
// 		+ _T("\\Jobs\\") + strName + _T("\\SearchData.xml");
// 
// 	vcXMLConfigurator m_XMLConfigator;
// 	m_XMLConfigator.SetDoc(_T(""));
// 	m_XMLConfigator.Load(strDir);
// 
// 
// 	m_XMLConfigator.ResetDocElemPos();
// 
// 
// 	if(!m_XMLConfigator.FindElem(_T("SearchData")))	// (Root)
// 	{
// 		m_XMLConfigator.AddElem(_T("SearchData"));
// 	}
// 	m_XMLConfigator.EnterElem();
// 
// 	// // 兼容之前保存结构
// 	for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 	{
// 		strInfo.Format("SaveTargetPosInfo-1- %d",i);
// 		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 		strInfo.Format(_T("TargetResult%d"),i);
// 		if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
// 		{
// 			m_XMLConfigator.AddElem(strInfo);
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 		if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
// 		{
// 			m_XMLConfigator.AddElem(_T("PlatAxisPos"));
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 		if (i < m_vpTargetPlatformAxisPos.size() && m_vpTargetPlatformAxisPos.at(i) != NULL)
// 		{
// 			pPlatformAxisPos = (CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosD")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosD"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 
// 		}
// 		else
// 		{
// 			CPlatformXYDAxisPos AxisPos;
// 			pPlatformAxisPos = &AxisPos;
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosD")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosD"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 		}
// 		m_XMLConfigator.LeaveElem();
// 
// 
// 		if(!m_XMLConfigator.FindElem(_T("CamAxisPos")))	// (Level-2) 相机轴位置信息
// 		{
// 			m_XMLConfigator.AddElem(_T("CamAxisPos"));
// 		}
// 
// 		CString strInfo;
// 		strInfo.Format("SaveTargetPosInfo--m_vpTargetCamAxisPos.at(%d):%f,%f",i,((CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(i))->m_dPosX,((CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(i))->m_dPosY);
// 		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 		m_XMLConfigator.EnterElem();
// 
// 		if(m_vpTargetCamAxisPos.at(i) != NULL && i < m_vpTargetCamAxisPos.size())
// 		{ 
// 			pTargetCamAxisPos = (CPlatformXYAxisPos*)m_vpTargetCamAxisPos.at(i);
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
// 		}
// 		else
// 		{
// 			CPlatformXYAxisPos axisPos;
// 			pTargetCamAxisPos = &axisPos;
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
// 		}
// 		m_XMLConfigator.LeaveElem();
// 
// 		if(!m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))	// (Level-2) 相机轴位置信息
// 		{
// 			m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 		if(m_vpTargetCamAxisPlatformAxisPos.at(i) != NULL && i < m_vpTargetCamAxisPlatformAxisPos.size())
// 		{ 
// 			pTargetCamAxisPos = (CPlatformXYAxisPos*)m_vpTargetCamAxisPlatformAxisPos.at(i);
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
// 		}
// 		else
// 		{
// 			CPlatformXYAxisPos axisPos;
// 			pTargetCamAxisPos = &axisPos;
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
// 		}
// 		m_XMLConfigator.LeaveElem();
// 
// 
// 		if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
// 		{
// 			m_XMLConfigator.AddElem(_T("ImagePos"));
// 		}	
// 		m_XMLConfigator.EnterElem();
// 
// 		if(!m_XMLConfigator.FindElem(_T("Valid")))
// 		{
// 			m_XMLConfigator.AddElem(_T("Valid"));
// 		}
// 		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetIsMarkImagePosOK(i));
// 
// 		if(!m_XMLConfigator.FindElem(_T("ImageX")))
// 		{
// 			m_XMLConfigator.AddElem(_T("ImageX"));
// 		}
// 		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dPosX);
// 
// 		if(!m_XMLConfigator.FindElem(_T("ImageY")))
// 		{
// 			m_XMLConfigator.AddElem(_T("ImageY"));
// 		}
// 		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dPosY);
// 
// 		if(!m_XMLConfigator.FindElem(_T("ImageD")))
// 		{
// 			m_XMLConfigator.AddElem(_T("ImageD"));
// 		}		
// 		m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dAngle);
// 	
// 		int nAuxiliaryIndex = 0;
// 		for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 		{
// 			CString strAuxiliary;
// 			strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 			if (!m_XMLConfigator.FindElem(strAuxiliary))
// 			{
// 				m_XMLConfigator.AddElem(strAuxiliary);
// 			}
// 			m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 
// 			strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 			if (!m_XMLConfigator.FindElem(strAuxiliary))
// 			{
// 				m_XMLConfigator.AddElem(strAuxiliary);
// 			}
// 			m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 
// 			strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 			if (!m_XMLConfigator.FindElem(strAuxiliary))
// 			{
// 				m_XMLConfigator.AddElem(strAuxiliary);
// 			}
// 			m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 		}
//        
//         if(!m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
//         {
//             m_XMLConfigator.AddElem(_T("ImageLineAngle1"));
//         }		
//         m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dLineAngle1);
// 
//         if(!m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
//         {
//             m_XMLConfigator.AddElem(_T("ImageLineAngle2"));
//         }		
//         m_XMLConfigator.SetElemData(m_mpTargetMarkImagePos.GetMarkImagePos(i).m_dLineAngle2);
// 
// 		m_XMLConfigator.LeaveElem();
// 
// 
// 		m_XMLConfigator.LeaveElem();
// 	}
// 	// 单产品扩展//
// 	int nNums = 1;
// 	if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
// 	{
// 		nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
// 	}
// 	for (int it=0;it < nNums;it++)
// 	{
// 		strInfo.Format(_T("ProducetMultiExTarget%d"),it);
// 		if(!m_XMLConfigator.FindElem(strInfo))//  扩展序号节点
// 		{
// 			m_XMLConfigator.AddElem(strInfo);
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 
// 		for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 		{
// 			strInfo.Format(_T("TargetResult%d"),i);
// 			if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
// 			{
// 				m_XMLConfigator.AddElem(strInfo);
// 			}
// 			m_XMLConfigator.EnterElem();
// 
// 			if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
// 			{
// 				m_XMLConfigator.AddElem(_T("PlatAxisPos"));
// 			}
// 			m_XMLConfigator.EnterElem();
// 
// 			if (it<m_vvpTargetPlatformAxisPosMultiEx.size())
// 			{
// 				if (i < m_vvpTargetPlatformAxisPosMultiEx.at(it).size() && m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i) != NULL)
// 				{
// 					pPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vvpTargetPlatformAxisPosMultiEx.at(it).at(i));
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosD")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosD"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 
// 				}
// 				else
// 				{
// 					CPlatformXYDAxisPos AxisPos;
// 					pPlatformAxisPos = &AxisPos;
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosD")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosD"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 				}
// 			}
// 
// 			m_XMLConfigator.LeaveElem();
// 
// 			if(!m_XMLConfigator.FindElem(_T("CamAxisPos")))	// (Level-2) 相机轴位置信息
// 			{
// 				m_XMLConfigator.AddElem(_T("CamAxisPos"));
// 			}
// 
// 			m_XMLConfigator.EnterElem();
// 			if (it<m_vvpTargetCamAxisPosMultiEx.size())
// 			{
// 				if(m_vvpTargetCamAxisPosMultiEx.at(it).at(i) != NULL && i < m_vvpTargetCamAxisPosMultiEx.at(it).size())
// 				{ 
// 					pTargetCamAxisPos = (CPlatformXYAxisPos*)m_vvpTargetCamAxisPosMultiEx.at(it).at(i);
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
// 				}
// 				else
// 				{
// 					CPlatformXYAxisPos axisPos;
// 					pTargetCamAxisPos = &axisPos;
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
// 				}
// 			}
// 			
// 			m_XMLConfigator.LeaveElem();
// 			if(!m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))	// (Level-2) 相机轴位置信息
// 			{
// 				m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));
// 			}
// 			m_XMLConfigator.EnterElem();
// 			if (it<m_vvpTargetCamAxisPlatformAxisPosMultiEx.size())
// 			{
// 				if(m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i) != NULL && i < m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).size())
// 				{ 
// 					pTargetCamAxisPos = (CPlatformXYAxisPos*)m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(it).at(i);
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
// 				}
// 				else
// 				{
// 					CPlatformXYAxisPos axisPos;
// 					pTargetCamAxisPos = &axisPos;
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pTargetCamAxisPos->m_dPosY);
// 				}
// 			}
// 			
// 			m_XMLConfigator.LeaveElem();
// 
// 			if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
// 			{
// 				m_XMLConfigator.AddElem(_T("ImagePos"));
// 			}	
// 			m_XMLConfigator.EnterElem();
// 
// 			if (it < m_vmpTargetMarkImagePosMultiEx.size())
// 			{
// 				if(!m_XMLConfigator.FindElem(_T("Valid")))
// 				{
// 					m_XMLConfigator.AddElem(_T("Valid"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetIsMarkImagePosOK(i));
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageX")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageX"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dPosX);
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageY")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageY"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dPosY);
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageD")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageD"));
// 				}		
// 				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dAngle);
// 
// 				int nAuxiliaryIndex = 0;
// 				for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 				{
// 					CString strAuxiliary;
// 					strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 
// 					strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 
// 					strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 				}
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageLineAngle1"));
// 				}		
// 				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dLineAngle1);
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageLineAngle2"));
// 				}		
// 				m_XMLConfigator.SetElemData(m_vmpTargetMarkImagePosMultiEx.at(it).GetMarkImagePos(i).m_dLineAngle2);
// 			}
// 
// 
// 
// 			m_XMLConfigator.LeaveElem();
// 
// 
// 			m_XMLConfigator.LeaveElem();
// 		}
// 
// 		m_XMLConfigator.LeaveElem();
// 	}
// 	if (optionInfo.m_bEnableMutiTarget)
// 	{
// 		for(int j=0;j<MUTITARGETMAXNUM;j++)
// 		{
// 			strInfo.Format(_T("MutiTargetResult%d"),j);
// 			if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
// 			{
// 				m_XMLConfigator.AddElem(strInfo);
// 			}
// 			m_XMLConfigator.EnterElem();
// 			for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 			{
// 				strInfo.Format(_T("TargetResult%d"),i);
// 				if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
// 				{
// 					m_XMLConfigator.AddElem(strInfo);
// 				}
// 				m_XMLConfigator.EnterElem();
// 
// 				if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
// 				{
// 					m_XMLConfigator.AddElem(_T("PlatAxisPos"));
// 				}
// 				m_XMLConfigator.EnterElem();
// 
// 				if (i < m_vpMutiTargetPlatformAxisPos.at(j).size() && m_vpMutiTargetPlatformAxisPos.at(j).at(i) != NULL)
// 				{
// 					pPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vpMutiTargetPlatformAxisPos.at(j).at(i));
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosD")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosD"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 
// 				}
// 				else
// 				{
// 					CPlatformXYDAxisPos AxisPos;
// 					pPlatformAxisPos = &AxisPos;
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosD")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosD"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 				}
// 				m_XMLConfigator.LeaveElem();
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
// 				{
// 					m_XMLConfigator.AddElem(_T("ImagePos"));
// 				}	
// 				m_XMLConfigator.EnterElem();
// 
// 				if(!m_XMLConfigator.FindElem(_T("Valid")))
// 				{
// 					m_XMLConfigator.AddElem(_T("Valid"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetIsMarkImagePosOK(i));
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageX")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageX"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_dPosX);
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageY")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageY"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_dPosY);
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageD")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageD"));
// 				}		
// 				m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_dAngle);
// 
// 				int nAuxiliaryIndex = 0;
// 				for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 				{
// 					CString strAuxiliary;
// 					strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 
// 					strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 
// 					strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vMutiTargetMarkImagePos.at(j).GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 				}
// 
// 				m_XMLConfigator.LeaveElem();
// 
// 
// 				m_XMLConfigator.LeaveElem();
// 			}
// 			if(!m_XMLConfigator.FindElem(_T("TargetResultOK")))
// 			{
// 				m_XMLConfigator.AddElem(_T("TargetResultOK"));
// 			}
// 			m_XMLConfigator.SetElemData(m_vbMutiTargetMarkOK.at(j));
// 			m_XMLConfigator.LeaveElem();
// 		}
// 	}
// 	
// 	
// 	m_XMLConfigator.LeaveElem();
// 
// 	return m_XMLConfigator.Save(strDir);
// }

// BOOL vcXYDVisionAlign::LoadObjectPosInfo(int nIndex)
// {
// 	ASSERT(nIndex >= 0);
// 	ASSERT(m_pVisionASMConfig != NULL);
// 	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
// 	ASSERT(m_pPlatformInfo != NULL);
// 
// 	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
// 	{
// 		return FALSE;
// 	}
// 	if (m_pVisionASMConfig == NULL)
// 	{
// 		return FALSE;
// 	}
// 	if (m_pPlatformInfo == NULL)
// 	{
// 		return FALSE;
// 	}
// 	CString strInfo;
// 	double dValue = 0;
// 	int i = 0, j = 0, nData = 0;
// 	CCoordPos pos;
// 	CPlatformXYDAxisPos		*pPlatformAxisPos = NULL;
// 	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
// 	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;
// 
// 	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
// 	strName.Format(_T("%03d"),nIndex+1);
// 	if (strName.IsEmpty())	// 产品名称为空，不合法
// 	{
// 		return FALSE;
// 	}
// 
// 	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
// 		+ _T("\\Jobs\\") + strName + _T("\\SearchData.xml");
// 
// 	vcXMLConfigurator m_XMLConfigator;
// 	m_XMLConfigator.SetDoc(_T(""));
// 	if (!m_XMLConfigator.Load(strDir))
// 	{
// 		return FALSE;
// 	}
// 
// 	if (!m_XMLConfigator.FindElem(_T("SearchData")))// (Root)
// 	{
// 		return FALSE;
// 	}
// 	m_XMLConfigator.EnterElem();
// 
// 	if (FALSE==m_pPlatformInfo->m_bEnableMultiCalibExtension)
// 	{
// 		//兼容之前结构
// 		// 
// 		for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 		{
// 			strInfo.Format(_T("ObjectResult%d"),i);
// 			if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
// 			{
// 				m_XMLConfigator.EnterElem();
// 				if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
// 				{
// 					m_XMLConfigator.EnterElem();
// 					CPlatformXYDAxisPos AxisPos;
// 					if (m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("PosD")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
// 					}
// 
// 					if (m_vpObjectPlatformAxisPos.at(i) != NULL)
// 					{
// 						delete m_vpObjectPlatformAxisPos.at(i);
// 						m_vpObjectPlatformAxisPos.at(i)=NULL;
// 
// 						m_vpObjectPlatformAxisPos.at(i) = new CPlatformXYDAxisPos(AxisPos);
// 					}
// 					else
// 					{
// 						m_vpObjectPlatformAxisPos.at(i) = new CPlatformXYDAxisPos(AxisPos);
// 					}
// 
// 					m_XMLConfigator.LeaveElem();
// 				}
// 				if (m_XMLConfigator.FindElem(_T("CamAxisPos")))  // (Level-2) 轴位置
// 				{
// 					m_XMLConfigator.EnterElem();
// 					CPlatformXYAxisPos AxisPos;
// 					if (m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 					}
// 
// 					if (m_vpObjectCamAxisPos.at(i) != NULL)
// 					{
// 						delete m_vpObjectCamAxisPos.at(i);
// 						m_vpObjectCamAxisPos.at(i)=NULL;
// 
// 						m_vpObjectCamAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
// 					}
// 					else
// 					{
// 						m_vpObjectCamAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
// 					}
// 
// 					m_XMLConfigator.LeaveElem();
// 				}
// 
// 				if (m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))  // (Level-2) 轴位置
// 				{
// 					m_XMLConfigator.EnterElem();
// 					CPlatformXYAxisPos AxisPos;
// 					if (m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 					}
// 
// 					if (m_vpObjectCamAxisPlatformAxisPos.at(i) != NULL)
// 					{
// 						delete m_vpObjectCamAxisPlatformAxisPos.at(i);
// 						m_vpObjectCamAxisPlatformAxisPos.at(i)=NULL;
// 
// 						m_vpObjectCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
// 					}
// 					else
// 					{
// 						m_vpObjectCamAxisPlatformAxisPos.at(i) = new CPlatformXYAxisPos(AxisPos);
// 					}
// 
// 					m_XMLConfigator.LeaveElem();
// 				}
// 
// 
// 				if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
// 				{
// 					m_XMLConfigator.EnterElem();
// 
// 					nData = 0;
// 					if (m_XMLConfigator.FindElem(_T("Valid")))
// 					{
// 						m_XMLConfigator.GetElemData(nData);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("ImageX")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dPosX);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("ImageY")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dPosY);
// 					}
// 					if (m_XMLConfigator.FindElem(_T("ImageD")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dAngle);
// 					}
// 
// 					int nAuxiliaryIndex = 0;
// 					for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 					{
// 						CString strAuxiliary;
// 						strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 						if (m_XMLConfigator.FindElem(strAuxiliary))
// 						{
// 							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 						}
// 						strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 						if (m_XMLConfigator.FindElem(strAuxiliary))
// 						{
// 							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 						}
// 						strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 						if (m_XMLConfigator.FindElem(strAuxiliary))
// 						{
// 							m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 						}
// 					}
// 
// 					if (m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dLineAngle1);
// 					}
// 
// 					if (m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
// 					{
// 						m_XMLConfigator.GetElemData(pos.m_dLineAngle2);
// 					}
// 
// 					m_mpObjectMarkImagePos.SetMarkImagePos(i, nData, pos);
// 
// 					m_XMLConfigator.LeaveElem();
// 				}
// 
// 
// 				m_XMLConfigator.LeaveElem();
// 			}
// 		}
// 	}
// 	else
// 	{
// 		int nNums = 1;
// 		if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
// 		{
// 			nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
// 		}
// 
// 		for (int it =0;it < nNums;it++)
// 		{
// 			strInfo.Format(_T("ProducetMultiExObject%d"),it);
// 			if(m_XMLConfigator.FindElem(strInfo))//  扩展序号节点
// 			{
// 				m_XMLConfigator.EnterElem();
// 
// 				for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 				{
// 					strInfo.Format(_T("ObjectResult%d"),i);
// 					if (m_XMLConfigator.FindElem(strInfo))// (Level-1) 搜索结果
// 					{
// 						m_XMLConfigator.EnterElem();
// 						if (m_XMLConfigator.FindElem(_T("PlatAxisPos")))  // (Level-2) 轴位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 							CPlatformXYDAxisPos AxisPos;
// 							if (m_XMLConfigator.FindElem(_T("PosX")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("PosY")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("PosD")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dAngle);
// 							}
// 							if (it < m_vvpObjectPlatformAxisPosMultiEx.size())
// 							{
// 								if (m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i) != NULL)
// 								{
// 									delete m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i);
// 									m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i)=NULL;
// 
// 									m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYDAxisPos(AxisPos);
// 								}
// 								else
// 								{
// 									m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYDAxisPos(AxisPos);
// 								}
// 							}
// 
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 						if (m_XMLConfigator.FindElem(_T("CamAxisPos")))  // (Level-2) 轴位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 							CPlatformXYAxisPos AxisPos;
// 							if (m_XMLConfigator.FindElem(_T("PosX")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("PosY")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 							}
// 
// 							if (m_vvpObjectCamAxisPosMultiEx.at(it).at(i) != NULL)
// 							{
// 								delete m_vvpObjectCamAxisPosMultiEx.at(it).at(i);
// 								m_vvpObjectCamAxisPosMultiEx.at(it).at(i)=NULL;
// 
// 								m_vvpObjectCamAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
// 							}
// 							else
// 							{
// 								m_vvpObjectCamAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
// 							}
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 						if (m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))  // (Level-2) 轴位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 							CPlatformXYAxisPos AxisPos;
// 							if (m_XMLConfigator.FindElem(_T("PosX")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dPosX);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("PosY")))
// 							{
// 								m_XMLConfigator.GetElemData(AxisPos.m_dPosY);
// 							}
// 
// 							if (m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i) != NULL)
// 							{
// 								delete m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i);
// 								m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i)=NULL;
// 
// 								m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
// 							}
// 							else
// 							{
// 								m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i) = new CPlatformXYAxisPos(AxisPos);
// 							}
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 
// 
// 						if (m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置
// 						{
// 							m_XMLConfigator.EnterElem();
// 
// 							nData = 0;
// 							if (m_XMLConfigator.FindElem(_T("Valid")))
// 							{
// 								m_XMLConfigator.GetElemData(nData);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageX")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dPosX);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageY")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dPosY);
// 							}
// 							if (m_XMLConfigator.FindElem(_T("ImageD")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dAngle);
// 							}
// 
// 							int nAuxiliaryIndex = 0;
// 							for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 							{
// 								CString strAuxiliary;
// 								strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 								}
// 								strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 								}
// 								strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 								if (m_XMLConfigator.FindElem(strAuxiliary))
// 								{
// 									m_XMLConfigator.GetElemData(pos.m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 								}
// 							}
// 
// 							if (m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dLineAngle1);
// 							}
// 
// 							if (m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
// 							{
// 								m_XMLConfigator.GetElemData(pos.m_dLineAngle2);
// 							}
// 							if (it < m_vmpObjectMarkImagePos_MultiEX.size())
// 							{
// 								m_vmpObjectMarkImagePos_MultiEX.at(it).SetMarkImagePos(i, nData, pos);
// 							}
// 
// 
// 							m_XMLConfigator.LeaveElem();
// 						}
// 
// 
// 						m_XMLConfigator.LeaveElem();
// 					}
// 				}
// 
// 				m_XMLConfigator.LeaveElem();
// 			}
// 		}
//     }
// 
// 	m_XMLConfigator.LeaveElem();
// 
// 
// 	return TRUE;
// }

// BOOL vcXYDVisionAlign::SaveObjectPosInfo(int nIndex)
// {
// 	ASSERT(nIndex >= 0);
// 	ASSERT(m_pVisionASMConfig != NULL);
// 	ASSERT(nIndex < m_pVisionASMConfig->m_TotalProductData.GetCount());
// 	ASSERT(m_pPlatformInfo != NULL);
// 
// 	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalProductData.GetCount()))
// 	{
// 		return FALSE;
// 	}
// 	if (m_pVisionASMConfig == NULL)
// 	{
// 		return FALSE;
// 	}
// 	if (m_pPlatformInfo == NULL)
// 	{
// 		return FALSE;
// 	}
// 	CString strInfo;
// 	double dValue = 0;
// 	int i = 0, j = 0, nData = 0;
// 	CCoordPos pos;
// 	CPlatformXYDAxisPos		*pPlatformAxisPos = NULL;
// 	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
// 	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;
// 	CPlatformXYAxisPos		*pCamAxisPos   = NULL;
// 	CString strName = m_pVisionASMConfig->m_TotalProductData.GetItemName(nIndex);
// 	strName.Format(_T("%03d"),nIndex+1);
// 	if (strName.IsEmpty())	// 产品名称为空，不合法
// 	{
// 		return FALSE;
// 	}
// 
// 	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
// 		+ _T("\\Jobs\\") + strName + _T("\\SearchData.xml");
// 
// 	vcXMLConfigurator m_XMLConfigator;
// 	m_XMLConfigator.SetDoc(_T(""));
// 	m_XMLConfigator.Load(strDir);
// 
// 
// 	m_XMLConfigator.ResetDocElemPos();
// 
// 
// 	if(!m_XMLConfigator.FindElem(_T("SearchData")))	// (Root)
// 	{
// 		m_XMLConfigator.AddElem(_T("SearchData"));
// 	}
// 	m_XMLConfigator.EnterElem();
// 
// 	// 
// 	for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 	{
// 		strInfo.Format(_T("ObjectResult%d"),i);
// 		if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
// 		{
// 			m_XMLConfigator.AddElem(strInfo);
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 		if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
// 		{
// 			m_XMLConfigator.AddElem(_T("PlatAxisPos"));
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 		if (i < m_vpObjectPlatformAxisPos.size() && m_vpObjectPlatformAxisPos.at(i) != NULL)
// 		{
// 			pPlatformAxisPos = (CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(i);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosD")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosD"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 
// 		}
// 		else
// 		{
// 			CPlatformXYDAxisPos AxisPos;
// 			pPlatformAxisPos = &AxisPos;
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosD")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosD"));
// 			}
// 			m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 		}
// 		m_XMLConfigator.LeaveElem();
// 
// 
// 		if(!m_XMLConfigator.FindElem(_T("CamAxisPos")))	// (Level-2) 相机轴位置信息
// 		{
// 			m_XMLConfigator.AddElem(_T("CamAxisPos"));
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 		if(m_vpObjectCamAxisPos.at(i) != NULL && i < m_vpObjectCamAxisPos.size())
// 		{ 
// 			pCamAxisPos = (CPlatformXYAxisPos*)m_vpObjectCamAxisPos.at(i);
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
// 		}
// 		else
// 		{
// 			CPlatformXYAxisPos axisPos;
// 			pCamAxisPos = &axisPos;
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
// 		}
// 		m_XMLConfigator.LeaveElem();
// 
// 
// 		if(!m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))	// (Level-2) 相机轴位置信息
// 		{
// 			m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 		if(m_vpObjectCamAxisPlatformAxisPos.at(i) != NULL && i < m_vpObjectCamAxisPlatformAxisPos.size())
// 		{ 
// 			pCamAxisPos = (CPlatformXYAxisPos*)m_vpObjectCamAxisPlatformAxisPos.at(i);
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
// 		}
// 		else
// 		{
// 			CPlatformXYAxisPos axisPos;
// 			pCamAxisPos = &axisPos;
// 			if(!m_XMLConfigator.FindElem(_T("PosX")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosX"));
// 			}
// 			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);
// 
// 			if(!m_XMLConfigator.FindElem(_T("PosY")))
// 			{
// 				m_XMLConfigator.AddElem(_T("PosY"));
// 			}
// 			m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
// 		}
// 		m_XMLConfigator.LeaveElem();
// 
// 
// 		if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
// 		{
// 			m_XMLConfigator.AddElem(_T("ImagePos"));
// 		}	
// 		m_XMLConfigator.EnterElem();
// 
// 		if(!m_XMLConfigator.FindElem(_T("Valid")))
// 		{
// 			m_XMLConfigator.AddElem(_T("Valid"));
// 		}
// 		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetIsMarkImagePosOK(i));
// 
// 		if(!m_XMLConfigator.FindElem(_T("ImageX")))
// 		{
// 			m_XMLConfigator.AddElem(_T("ImageX"));
// 		}
// 		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dPosX);
// 
// 		if(!m_XMLConfigator.FindElem(_T("ImageY")))
// 		{
// 			m_XMLConfigator.AddElem(_T("ImageY"));
// 		}
// 		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dPosY);
// 
// 		if(!m_XMLConfigator.FindElem(_T("ImageD")))
// 		{
// 			m_XMLConfigator.AddElem(_T("ImageD"));
// 		}		
// 		m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dAngle);
// 
// 		int nAuxiliaryIndex = 0;
// 		for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 		{
// 			CString strAuxiliary;
// 			strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 			if (!m_XMLConfigator.FindElem(strAuxiliary))
// 			{
// 				m_XMLConfigator.AddElem(strAuxiliary);
// 			}
// 			m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 
// 			strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 			if (!m_XMLConfigator.FindElem(strAuxiliary))
// 			{
// 				m_XMLConfigator.AddElem(strAuxiliary);
// 			}
// 			m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 
// 			strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 			if (!m_XMLConfigator.FindElem(strAuxiliary))
// 			{
// 				m_XMLConfigator.AddElem(strAuxiliary);
// 			}
// 			m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 		}
// 
//         if(!m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
//         {
//             m_XMLConfigator.AddElem(_T("ImageLineAngle1"));
//         }		
//         m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dLineAngle1);
// 
//         if(!m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
//         {
//             m_XMLConfigator.AddElem(_T("ImageLineAngle2"));
//         }		
//         m_XMLConfigator.SetElemData(m_mpObjectMarkImagePos.GetMarkImagePos(i).m_dLineAngle2);
// 
// 		m_XMLConfigator.LeaveElem();
// 
// 
// 		m_XMLConfigator.LeaveElem();
// 	}
// 	int nNums = 1;
// 	if (m_pPlatformInfo->m_bEnableMultiCalibExtension && m_pPlatformInfo->m_nMultiCalibExtensionMaxNum>=0)
// 	{
// 		nNums += m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
// 	}
// 
// 	for (int it =0;it < nNums;it++)
// 	{
// 		strInfo.Format(_T("ProducetMultiExObject%d"),it);
// 		if(!m_XMLConfigator.FindElem(strInfo))//  扩展序号节点
// 		{
// 			m_XMLConfigator.AddElem(strInfo);
// 		}
// 		m_XMLConfigator.EnterElem();
// 
// 		for (i = 0; i < m_pPlatformInfo->m_nPositionNum; i++)
// 		{
// 			strInfo.Format(_T("ObjectResult%d"),i);
// 			if(!m_XMLConfigator.FindElem(strInfo))// (Level-1) 结果位置信息
// 			{
// 				m_XMLConfigator.AddElem(strInfo);
// 			}
// 			m_XMLConfigator.EnterElem();
// 
// 			if(!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-2) 轴位置信息
// 			{
// 				m_XMLConfigator.AddElem(_T("PlatAxisPos"));
// 			}
// 			m_XMLConfigator.EnterElem();
// 
// 			if (it<m_vvpObjectPlatformAxisPosMultiEx.size())
// 			{
// 				if(i < m_vvpObjectPlatformAxisPosMultiEx.at(it).size() && m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i) != NULL)
// 				{
// 					pPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vvpObjectPlatformAxisPosMultiEx.at(it).at(i));
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosD")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosD"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 
// 				}
// 				else
// 				{
// 					CPlatformXYDAxisPos AxisPos;
// 					pPlatformAxisPos = &AxisPos;
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dPosY);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosD")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosD"));
// 					}
// 					m_XMLConfigator.SetElemData(pPlatformAxisPos->m_dAngle);
// 				}
// 			}
// 
// 			m_XMLConfigator.LeaveElem();
// 
// 			if(!m_XMLConfigator.FindElem(_T("CamAxisPos")))	// (Level-2) 相机轴位置信息
// 			{
// 				m_XMLConfigator.AddElem(_T("CamAxisPos"));
// 			}
// 			m_XMLConfigator.EnterElem();
// 			if (it<m_vvpObjectCamAxisPosMultiEx.size())
// 			{
// 				if(m_vvpObjectCamAxisPosMultiEx.at(it).at(i) != NULL && i < m_vvpObjectCamAxisPosMultiEx.at(it).size())
// 				{ 
// 					pCamAxisPos = (CPlatformXYAxisPos*)m_vvpObjectCamAxisPosMultiEx.at(it).at(i);
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
// 				}
// 				else
// 				{
// 					CPlatformXYAxisPos axisPos;
// 					pCamAxisPos = &axisPos;
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
// 				}
// 			}
// 			
// 			m_XMLConfigator.LeaveElem();
// 
// 			if(!m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))	// (Level-2) 相机轴位置信息
// 			{
// 				m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));
// 			}
// 			m_XMLConfigator.EnterElem();
// 			if (it<m_vvpObjectCamAxisPlatformAxisPosMultiEx.size())
// 			{
// 				if(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i) != NULL && i < m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).size())
// 				{ 
// 					pCamAxisPos = (CPlatformXYAxisPos*)m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(it).at(i);
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
// 				}
// 				else
// 				{
// 					CPlatformXYAxisPos axisPos;
// 					pCamAxisPos = &axisPos;
// 					if(!m_XMLConfigator.FindElem(_T("PosX")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosX"));
// 					}
// 					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosX);
// 
// 					if(!m_XMLConfigator.FindElem(_T("PosY")))
// 					{
// 						m_XMLConfigator.AddElem(_T("PosY"));
// 					}
// 					m_XMLConfigator.SetElemData(pCamAxisPos->m_dPosY);
// 				}
// 			}
// 			
// 			m_XMLConfigator.LeaveElem();
// 
// 
// 			if(!m_XMLConfigator.FindElem(_T("ImagePos")))// (Level-2) 图像位置信息
// 			{
// 				m_XMLConfigator.AddElem(_T("ImagePos"));
// 			}	
// 			m_XMLConfigator.EnterElem();
// 
// 			if (it<m_vmpObjectMarkImagePos_MultiEX.size())
// 			{
// 				if(!m_XMLConfigator.FindElem(_T("Valid")))
// 				{
// 					m_XMLConfigator.AddElem(_T("Valid"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetIsMarkImagePosOK(i));
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageX")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageX"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dPosX);
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageY")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageY"));
// 				}
// 				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dPosY);
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageD")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageD"));
// 				}		
// 				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dAngle);
// 
// 				int nAuxiliaryIndex = 0;
// 				for (nAuxiliaryIndex = 0; nAuxiliaryIndex < pos.m_vdAuxiliaryPosX.size(); nAuxiliaryIndex++)
// 				{
// 					CString strAuxiliary;
// 					strAuxiliary.Format(_T("ImageAuxiliaryX%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_vdAuxiliaryPosX.at(nAuxiliaryIndex));
// 
// 					strAuxiliary.Format(_T("ImageAuxiliaryY%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_vdAuxiliaryPosY.at(nAuxiliaryIndex));
// 
// 					strAuxiliary.Format(_T("ImageAuxiliaryD%d"), nAuxiliaryIndex);
// 					if (!m_XMLConfigator.FindElem(strAuxiliary))
// 					{
// 						m_XMLConfigator.AddElem(strAuxiliary);
// 					}
// 					m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_vdAuxiliaryAngle.at(nAuxiliaryIndex));
// 				}
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageLineAngle1")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageLineAngle1"));
// 				}		
// 				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dLineAngle1);
// 
// 				if(!m_XMLConfigator.FindElem(_T("ImageLineAngle2")))
// 				{
// 					m_XMLConfigator.AddElem(_T("ImageLineAngle2"));
// 				}		
// 				m_XMLConfigator.SetElemData(m_vmpObjectMarkImagePos_MultiEX.at(it).GetMarkImagePos(i).m_dLineAngle2);
// 
// 				m_XMLConfigator.LeaveElem();
// 			}
// 
// 			m_XMLConfigator.LeaveElem();
// 		}
// 
// 		m_XMLConfigator.LeaveElem();
// 
// 	}
// 	m_XMLConfigator.LeaveElem();
// 
// 	return m_XMLConfigator.Save(strDir);
// }


// S10：加载所有产品标定信息
// BOOL vcXYDVisionAlign::LoadCalibDataInfo(int nIndex, LPCTSTR lpszProductName)
// {
// 	ASSERT(nIndex >= 0);
// 	ASSERT(m_pPlatformInfo != NULL);
// 	CString strProductName = lpszProductName;
// 	//	ASSERT(!strProductName.IsEmpty());
// 
// 	if ((strProductName.IsEmpty()) || (nIndex < 0))
// 	{
// 		return FALSE;
// 	}
// 	if (m_pPlatformInfo == NULL)
// 	{
// 		return FALSE;
// 	}
// 	vcXMLConfigurator m_XMLConfigator;
// 	m_XMLConfigator.SetDoc(_T(""));
// 
// 	BOOL bLoad = FALSE;
// 	BSTR bstrName = NULL;
// 	int i = 0, j = 0, nData = 0, nPosNum = 0;
// 	double dValue = 0;
// 	CString strPath, strInfo;
// 	CCoordPos pos;
// 	CCalibData				 calibData(*m_pPlatformInfo);		// 标定信息
// 	CCalibrateParam			*pCalibrateParam = NULL;			// 显式释放内存
// 	CCalibratedInfo			*pCalibratedInfo = NULL;			// 显式释放内存
// 	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;		// 显式释放内存
// 	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;		// 显式释放内存
// 	CPlatformAxisPos		*pCamAxisPlatformAxisPos = NULL;	// 显式释放内存
// 
// 
// 	// 	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
// 	// 		+ _T("\\JobCalibs\\") + strProductName + _T("\\JobCalib.xml");
// 
// 	CString strProductIndex;
// 	strProductIndex.Format(_T("%03d"), nIndex+1);
// 	strPath = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
// 		+ _T("\\JobCalibs\\") + strProductIndex + _T("\\JobCalib.xml");
// 
// 	bLoad = m_XMLConfigator.Load(strPath);
// 	if (!bLoad)
// 	{
// 		goto LoadFailed;
// 	}
// 	if (!m_XMLConfigator.FindElem(_T("JobCalibConfig")))	// (Root)
// 	{
// 		goto LoadFailed;
// 	}
// 	m_XMLConfigator.EnterElem();  // 1级目录
// 
// 	if (!m_XMLConfigator.FindElem(_T("CalibIndex")))			// (Level-1)产品索引号 
// 	{
// 		goto LoadFailed;
// 	}
// 	m_XMLConfigator.GetElemData(nData);
// 	calibData.SetCalibIndex(nData);
// 
// 	if (!m_XMLConfigator.FindElem(_T("CalibCustomName")))		// (Level-1)产品自定义名称
// 	{
// 		goto LoadFailed;
// 	}
// // 	bstrName = m_XMLConfigator.GetElemData().AllocSysString();
// // 	calibData.SetCalibUserName(bstrName);
// // 	SysFreeString(bstrName);
// 	calibData.SetCalibUserName(CString(m_XMLConfigator.GetElemData()));
// 
// 	if (m_XMLConfigator.FindElem(_T("CalibMarkPatternMode")))		// (Level)
// 	{
// 		m_XMLConfigator.GetElemData(nData);
// 		calibData.SetCalibMarkPatternMode((CalibMarkPatternMode)nData);
// 	}
// 	else
// 	{
// 		calibData.SetCalibMarkPatternMode(eTraditionalCalib);
// 	}
// 
// 	if (m_XMLConfigator.FindElem(_T("CalibHomographyDOF")))		// (Level)
// 	{
// 		m_XMLConfigator.GetElemData(nData);
// 		calibData.SetCalibHomographyDOF((HomographyDOF)nData);
// 	}
// 	else
// 	{
// 		calibData.SetCalibHomographyDOF(eAuto);
// 	}
// 
// 	if (m_XMLConfigator.FindElem(_T("WholeCalibCacuPos")))		// (Level)
// 	{
// 		m_XMLConfigator.GetElemData(nData);
// 		calibData.SetWholeCalibCacuPos(nData);
// 	}
// 	else
// 	{
// 		calibData.SetWholeCalibCacuPos(0);
// 	}
// 
// 	if (m_XMLConfigator.FindElem(_T("WholeCalibCacuPosEnable")))		// (Level)
// 	{
// 		m_XMLConfigator.GetElemData(nData);
// 		calibData.SetWholeCalibCacuPosEnable((BOOL)nData);
// 	}
// 	else
// 	{
// 		calibData.SetWholeCalibCacuPosEnable(FALSE);
// 	}
// 
// 	///////////////////////////////////////////////////////////////////////////
// 	// 标定参数信息
// 	pCalibrateParam = new CCalibrateParam;
// 	if (!m_XMLConfigator.FindElem(_T("CalibParam")))	// (Level-1)
// 	{
// 		goto LoadFailed;
// 	}
// 	m_XMLConfigator.EnterElem();  //2级目录
// 
// //	nPosNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
// 	nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	for (i=0; i<nPosNum; i++)
// 	{
// 		strInfo.Format(_T("CalibParam%d"),i);
// 		if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.EnterElem();  //3级目录
// 
// 		// 标定模板数量
// 		if (m_XMLConfigator.FindElem(_T("CalibPatNum")))
// 		{
// 			m_XMLConfigator.GetElemData(pCalibrateParam->m_nCalibPatternNum);				 
// 		}
// 
// 		// 标定模板ID
// 		CString strInfo;
// 		if (m_XMLConfigator.FindElem(_T("CalibPatID")))
// 		{
// 			m_XMLConfigator.EnterElem();//4级目录打开
// 
// 			CString strID;
// 			for (j=0; j<pCalibrateParam->m_nCalibPatternNum; j++)
// 			{
// 				strInfo.Format(_T("ID%d"),j);
// 
// 				if (m_XMLConfigator.FindElem(strInfo))
// 				{
// 					strID = m_XMLConfigator.GetElemData();
// 					pCalibrateParam->m_vstrCalibPatternIDS.push_back(strID);
// 				}
// 			}
// 
// 			m_XMLConfigator.LeaveElem();//4级目录关闭
// 		}		   
// 
// 		// 平台坐标系标定时各轴运动控制量		  
// 		if (m_XMLConfigator.FindElem(_T("PlatMove")))
// 		{
// 			m_XMLConfigator.EnterElem();//4级目录打开
// 
// 			// DX
// 			if (m_XMLConfigator.FindElem(_T("DX")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dPosX);
// 			}
// 
// 			// DY
// 			if (m_XMLConfigator.FindElem(_T("DY")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dPosY);
// 			}
// 
// 			// DD
// 			if (m_XMLConfigator.FindElem(_T("DD")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dAngle);
// 			}  
// 
// 			m_XMLConfigator.LeaveElem();//4级目录关闭
// 		}
// 
// 		// 相机单独控制时，XY轴运动控制量
// 		if (m_XMLConfigator.FindElem(_T("CamMove")))
// 		{
// 			m_XMLConfigator.EnterElem();//4级目录打开
// 
// 			// DX
// 			if (m_XMLConfigator.FindElem(_T("DX")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_dCameraCalibMovement.m_dPosX);
// 			}
// 
// 			// DY
// 			if (m_XMLConfigator.FindElem(_T("DY")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_dCameraCalibMovement.m_dPosY);
// 			}	   			 
// 
// 			m_XMLConfigator.LeaveElem();//4级目录关闭
// 		}      
// 
// 		// 平台标定是否求精
// 		if (m_XMLConfigator.FindElem(_T("PlatCalibRefine")))
// 		{
// 			m_XMLConfigator.GetElemData(pCalibrateParam->m_bPlatformCalibrateRefine);
// 		}	
// 
// 		if (m_XMLConfigator.FindElem(_T("PlatCalibRefineTime")))
// 		{
// 			m_XMLConfigator.GetElemData(pCalibrateParam->m_nPlatformCalibRefineTime);
// 		}
// 
// 		if (m_XMLConfigator.FindElem(_T("PlatCalibRefineMoveD")))
// 		{
// 			m_XMLConfigator.GetElemData(pCalibrateParam->m_dPlatformCalibRefineMoveD);
// 		}
// 
// 		// 搜索延时
// 		if (m_XMLConfigator.FindElem(_T("SearchDelayTime")))
// 		{
// 			m_XMLConfigator.GetElemData(pCalibrateParam->m_nSearchDelayTime);
// 		}
// 
// 		if (m_XMLConfigator.FindElem(_T("DistorCorrParam")))
// 		{
// 			m_XMLConfigator.EnterElem();//4级目录打开
// 
// 			// TileX
// 			if (m_XMLConfigator.FindElem(_T("TileX")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_dTileX);
// 			}
// 
// 			// TileY
// 			if (m_XMLConfigator.FindElem(_T("TileY")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_dTileY);
// 			}	   		
// 
// 			// EnableOutPoints
// 			if (m_XMLConfigator.FindElem(_T("EnableOutPoints")))
// 			{
// 				int i = 0;
// 				m_XMLConfigator.GetElemData(i);
// 				pCalibrateParam->m_bOutPoints = (bool)i;
// 			}
// 
// 			// Thre
// 			if (m_XMLConfigator.FindElem(_T("Thre")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_iThre);
// 			}	  
// 
// 			// IsEnableDisCor
// 			if (m_XMLConfigator.FindElem(_T("IsEnableDisCor")))
// 			{
// 				m_XMLConfigator.GetElemData(pCalibrateParam->m_nEnableDisCor);
// 			}
// 
// 			m_XMLConfigator.LeaveElem();//4级目录关闭
// 		}
// 
// 		if (m_XMLConfigator.FindElem(_T("CalibMarkPatternMode")))
// 		{
// 			int nData;
// 			m_XMLConfigator.GetElemData(nData);
// 			pCalibrateParam->m_eCalibMarkPatternMode = (CalibMarkPatternMode)nData;
// 		}
// 		else
// 		{
// 			pCalibrateParam->m_eCalibMarkPatternMode = eTraditionalCalib;
// 		}
// 
// 		m_XMLConfigator.LeaveElem(); //3级目录关闭
// 
// 		if (calibData.m_vpCalibrateParam.at(i) != NULL)
// 		{
// 			delete calibData.m_vpCalibrateParam.at(i);
// 			calibData.m_vpCalibrateParam.at(i) = NULL;
// 		}
// 		calibData.m_vpCalibrateParam.at(i) = new CCalibrateParam(*pCalibrateParam);
// 	}
// 	m_XMLConfigator.LeaveElem();  //2级目录关闭
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	// 标定后参数（与平台相关）
// 	pCalibratedInfo = new CCalibratedInfo(m_pPlatformInfo->m_ePlatformType, m_pPlatformInfo->m_eCamPlatformType);
// 	pCalibPlatformAxisPos = new CPlatformXYDAxisPos;
// 	// 	for (i=0; i<product.m_vpCalibratedInfo.size(); i++)
// 	// 	{
// 	// 		if (product.m_vpCalibratedInfo.at(i) != NULL)
// 	// 		{
// 	// 			delete product.m_vpCalibratedInfo.at(i);
// 	// 			product.m_vpCalibratedInfo.at(i) = NULL;
// 	// 		}
// 	// 	}
// 	// 	product.m_vpCalibratedInfo.clear();
// 
// 	if (!m_XMLConfigator.FindElem(_T("CalibedResult")))	// (Level-1)
// 	{
// 		goto LoadFailed;
// 	}
// 	m_XMLConfigator.EnterElem();  //2级目录
// 
// //	nPosNum = (m_pPlatformInfo->m_nCamNum == 1) ? m_pPlatformInfo->m_nPositionNum : m_pPlatformInfo->m_nCamNum;
// 	nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	int nExPosNum = 0;
// 	if (m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		nExPosNum = nPosNum + nPosNum*m_pPlatformInfo->m_nMultiCalibExtensionMaxNum;
// 	}
// 	else
// 	{
// 		nExPosNum = nPosNum;
// 	}
// 
// 	//for (i=0; i<nPosNum; i++)
// 	for (i=0; i<nExPosNum; i++)
// 	{
// 		strInfo.Format(_T("CalibedResult%d"),i);
// 
// 		if (!m_XMLConfigator.FindElem(strInfo))	// (Level-2)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.EnterElem();  //3级目录	
// 
// 		if (!m_XMLConfigator.FindElem(_T("Valid")))	// (Level-3)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibratedInfo->m_bValid);
// 
// 		//  标定时，图像坐标系到平台坐标系之间的变换矩阵
// 		if (!m_XMLConfigator.FindElem(_T("PlatTM")))	// (Level-3)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.EnterElem();  //4级目录
// 
// 		// A00
// 		m_XMLConfigator.FindElem(_T("A00"));	// (Level-4)
// 		m_XMLConfigator.GetElemData(dValue);
// 		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(0,0,dValue);
// 
// 		// A01
// 		m_XMLConfigator.FindElem(_T("A01"));	// (Level-4)
// 		m_XMLConfigator.GetElemData(dValue);
// 		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(0,1,dValue);
// 
// 		// A10
// 		m_XMLConfigator.FindElem(_T("A10"));	// (Level-4)
// 		m_XMLConfigator.GetElemData(dValue);
// 		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(1,0,dValue);
// 
// 		// A11
// 		m_XMLConfigator.FindElem(_T("A11"));	// (Level-4)
// 		m_XMLConfigator.GetElemData(dValue);
// 		pCalibratedInfo->m_PlatformTranferMatrix.SetElement(1,1,dValue);
// 
// 		m_XMLConfigator.LeaveElem();  //4级目录
// 
// 
// 		//  标定时，图像坐标系到平台坐标系之间的变换矩阵H
// 		if (m_XMLConfigator.FindElem(_T("PlatTMH")))
// 		{
// 			m_XMLConfigator.EnterElem();
// 
// 			double h[9];
// 			int j = 0;
// 			for(j = 0; j < 9; j++)
// 			{
// 				h[j] = 0.0;
// 				strInfo.Format(_T("h%d"),j);
// 				m_XMLConfigator.FindElem(strInfo);
// 				m_XMLConfigator.GetElemData(dValue);
// 				h[j] = dValue;						
// 			}
// 			pCalibratedInfo->SetPlatformTransferH(h);
// 
// 			m_XMLConfigator.LeaveElem();
// 		}
// 		else
// 		{
// 			goto LoadFailed;
// 		}
// 
// 		//  全局靶标标定时，图像坐标系到靶标坐标系之间的变换矩阵H1
// 		if (m_XMLConfigator.FindElem(_T("PlatTMH1")))
// 		{
// 			m_XMLConfigator.EnterElem();
// 
// 			double h1[9];
// 			int j = 0;
// 			for(j = 0; j < 9; j++)
// 			{
// 				h1[j] = 0.0;
// 				strInfo.Format(_T("h1%d"),j);
// 				m_XMLConfigator.FindElem(strInfo);
// 				m_XMLConfigator.GetElemData(dValue);
// 				h1[j] = dValue;						
// 			}
// 			pCalibratedInfo->SetPlatformTransferH1(h1);
// 
// 			m_XMLConfigator.LeaveElem();
// 		}
// 		//  全局靶标标定时，靶标坐标系到平台坐标系之间的变换矩阵H1
// 		if (m_XMLConfigator.FindElem(_T("PlatTMH2")))
// 		{
// 			m_XMLConfigator.EnterElem();
// 
// 			double h2[9];
// 			int j = 0;
// 			for(j = 0; j < 9; j++)
// 			{
// 				h2[j] = 0.0;
// 				strInfo.Format(_T("h2%d"),j);
// 				m_XMLConfigator.FindElem(strInfo);
// 				m_XMLConfigator.GetElemData(dValue);
// 				h2[j] = dValue;						
// 			}
// 			pCalibratedInfo->SetPlatformTransferH2(h2);
// 
// 			m_XMLConfigator.LeaveElem();
// 		}
// 		//  畸变校正结果
// 		if (m_XMLConfigator.FindElem(_T("DistorCorrResult")))
// 		{
// 			m_XMLConfigator.EnterElem();
// 
// 			double p[15];
// 			int j = 0;
// 			for(j = 0; j < 15; j++)
// 			{
// 				p[j] = 0.0;
// 				strInfo.Format(_T("p%d"),j);
// 				m_XMLConfigator.FindElem(strInfo);
// 				m_XMLConfigator.GetElemData(dValue);
// 				p[j] = dValue;						
// 			}
// 			pCalibratedInfo->m_result.SetNonlinearProjectResult(p);
// 
// 			strInfo.Format(_T("RMS"),j);
// 			m_XMLConfigator.FindElem(strInfo);
// 			m_XMLConfigator.GetElemData(dValue);
// 			pCalibratedInfo->m_result.SetRMS(dValue);
// 
// 			m_XMLConfigator.LeaveElem();
// 		}
// // 		else
// // 		{
// // 			goto LoadFailed;
// // 		}
// 
// 
// 		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffset")))	// (Level-3)
// 		{
// 			//goto LoadFailed;
// 			pCalibratedInfo->m_cpRefineOffset.m_dPosX = 0;
// 			pCalibratedInfo->m_cpRefineOffset.m_dPosY = 0;
// 		}
// 		else
// 		{
// 			m_XMLConfigator.EnterElem();  //4级目录
// 
// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 			{
// 				//goto LoadFailed;
// 				pCalibratedInfo->m_cpRefineOffset.m_dPosX = 0;
// 			}
// 			else
// 			{
// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_dPosX);
// 			}
// 
// 
// 			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 			{
// 				//goto LoadFailed;
// 				pCalibratedInfo->m_cpRefineOffset.m_dPosY = 0;
// 			}
// 			else
// 			{
// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_dPosY);		
// 			}
// 
// 			//if (GetProductCalibTargetMarkPatternMode(nIndex) == eSinglePatternGuanlian4Point)
// 			{
// 				for (int m=0;m<4;m++)
// 				{
// 					CString str;
// 					str.Format("AuxiliaryPosX-%d",m);
// 					if (m_XMLConfigator.FindElem(str))
// 					{
// 						m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_vdAuxiliaryPosX[m]);
// 					}
// 					str.Format("AuxiliaryPosY-%d",m);
// 					if (m_XMLConfigator.FindElem(str))
// 					{
// 						m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffset.m_vdAuxiliaryPosY[m]);
// 					}
// 				}
// 			}
// 
// 			m_XMLConfigator.LeaveElem();  //4级目录
// 		}
// 
// 		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffsetH1")))	// (Level-3)
// 		{
// 			//goto LoadFailed;
// 			pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX = 0;
// 			pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY = 0;
// 		}
// 		else
// 		{
// 			m_XMLConfigator.EnterElem();  //4级目录
// 
// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 			{
// 				//goto LoadFailed;
// 				pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX = 0;
// 			}
// 			else
// 			{
// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH1.m_dPosX);
// 			}
// 
// 
// 			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 			{
// 				//goto LoadFailed;
// 				pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY = 0;
// 			}
// 			else
// 			{
// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH1.m_dPosY);		
// 			}
// 
// 			m_XMLConfigator.LeaveElem();  //4级目录
// 		}
// 
// 		if (!m_XMLConfigator.FindElem(_T("PlatRefineOffsetH2")))	// (Level-3)
// 		{
// 			//goto LoadFailed;
// 			pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX = 0;
// 			pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY = 0;
// 		}
// 		else
// 		{
// 			m_XMLConfigator.EnterElem();  //4级目录
// 
// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 			{
// 				//goto LoadFailed;
// 				pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX = 0;
// 			}
// 			else
// 			{
// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH2.m_dPosX);
// 			}
// 
// 
// 			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 			{
// 				//goto LoadFailed;
// 				pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY = 0;
// 			}
// 			else
// 			{
// 				m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpRefineOffsetH2.m_dPosY);		
// 			}
// 
// 			m_XMLConfigator.LeaveElem();  //4级目录
// 		}
// 		// 标定时，基准Mark在平台坐标系的坐标值和姿态
// 		if (!m_XMLConfigator.FindElem(_T("MarkPlatCoord")))	// (Level-3)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.EnterElem();  //4级目录
// 		// MarkPltCoordX
// 		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPos.m_dPosX);
// 		// MarkPltCoordY
// 		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPos.m_dPosY);		
// 		m_XMLConfigator.LeaveElem();  //4级目录
// 
// 		// 标定时，基准Mark在图像坐标系中的位置
// 		if (!m_XMLConfigator.FindElem(_T("MarkImgCoord")))	// (Level-3)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.EnterElem();	  //4级目录	
// 		// MarkImgCoordX
// 		if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPos.m_dPosX);
// 		// MarkImgCoordY
// 		if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPos.m_dPosY);
// 		m_XMLConfigator.LeaveElem();  //4级目录
// 
// 
// 		// 标定时，基准Mark在平台坐标系的坐标值和姿态
// 		if (m_XMLConfigator.FindElem(_T("MarkPlatCoordBat")))	// (Level-3)
// 		{
// 			m_XMLConfigator.EnterElem();  //4级目录
// 			// MarkPltCoordX
// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 			{
// 				goto LoadFailed;
// 			}
// 			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPosBat.m_dPosX);
// 			// MarkPltCoordY
// 			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 			{
// 				goto LoadFailed;
// 			}
// 			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkPlatformCoordPosBat.m_dPosY);		
// 			m_XMLConfigator.LeaveElem();  //4级目录;
// 		}
// 
// 
// 		// 标定时，基准Mark在图像坐标系中的位置
// 		if (m_XMLConfigator.FindElem(_T("MarkImgCoordBat")))	// (Level-3)
// 		{
// 			m_XMLConfigator.EnterElem();	  //4级目录	
// 			// MarkImgCoordX
// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 			{
// 				goto LoadFailed;
// 			}
// 			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPosBat.m_dPosX);
// 			// MarkImgCoordY
// 			if (!m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 			{
// 				goto LoadFailed;
// 			}
// 			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpMarkImgCoordPosBat.m_dPosY);
// 			m_XMLConfigator.LeaveElem();  //4级目录;
// 		}
// 
// 
// 
// 		// 标定时，基准Mark在图像坐标系中的位置
// 		// 		if (!m_XMLConfigator.FindElem(_T("ObjectMarkImgCoord")))	// (Level-3)
// 		// 		{
// 		// 			goto LoadFailed;
// 		// 		}
// 		// 		m_XMLConfigator.EnterElem();	  //4级目录	
// 		// 		for (int m=0;m<CALIBMOVEPOSNUM;m++)
// 		// 		{
// 		// 			// MarkImgCoordX
// 		// 			CString strName;
// 		// 			strName.Format("X%d",m);
// 		// 			if (!m_XMLConfigator.FindElem(strName))	// (Level-4)
// 		// 			{
// 		// 				goto LoadFailed;
// 		// 			}
// 		// 			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX);
// 		// 			// MarkImgCoordY
// 		// 			strName.Format("Y%d",m);
// 		// 			if (!m_XMLConfigator.FindElem(strName))	// (Level-4)
// 		// 			{
// 		// 				goto LoadFailed;
// 		// 			}
// 		// 			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY);
// 		// 		}
// 		// 
// 		// 		m_XMLConfigator.LeaveElem();  //4级目录
// 
// 		if (m_XMLConfigator.FindElem(_T("ObjectMarkImgCoord")))	// (Level-3)
// 		{
// 			m_XMLConfigator.EnterElem();	  //4级目录	
// 			if (m_vpMarkImagePos.size()<CALIBMOVEPOSNUM)
// 			{
// 				m_vpMarkImagePos.resize(CALIBMOVEPOSNUM);
// 			}
// 			for (int m=0;m<CALIBMOVEPOSNUM;m++)
// 			{
// 				// MarkImgCoordX
// 				CString strName;
// 				strName.Format("X%d",m);
// 				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX);
// 				}
// 				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX);
// 				// MarkImgCoordY
// 				strName.Format("Y%d",m);
// 				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY);
// 				}
// 				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY);
// 				CCoordPos pos;
// 				pos.m_dPosX = pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosX;
// 				pos.m_dPosY = pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].m_dPosY;
// 
// 
// 				if (m_vpMarkImagePos.at(m)!=NULL)
// 				{
// 					delete m_vpMarkImagePos.at(m);
// 					m_vpMarkImagePos.at(m) = NULL;
// 				}							
// 				CMarkImagePos * markpos = new CMarkImagePos();
// 				markpos->SetMarkImagePosNum(1);
// 				markpos->SetMarkImagePos(0,TRUE,pos);
// 				m_vpMarkImagePos.at(m)=markpos;
// 			}
// 
// 			m_XMLConfigator.LeaveElem();  //4级目录
// 		}
// 
// 
// 
// 		// 标定时，基准Mark在图像坐标系中的位置
// 		// 		if (!m_XMLConfigator.FindElem(_T("TargetMarkImgCoord")))	// (Level-3)
// 		// 		{
// 		// 			goto LoadFailed;
// 		// 		}
// 		// 		m_XMLConfigator.EnterElem();	  //4级目录	
// 		// 		for (int m=0;m<CALIBMOVEPOSNUM;m++)
// 		// 		{
// 		// 			// MarkImgCoordX
// 		// 			CString strName;
// 		// 			strName.Format("X%d",m);
// 		// 			if (!m_XMLConfigator.FindElem(strName))	// (Level-4)
// 		// 			{
// 		// 				goto LoadFailed;
// 		// 			}
// 		// 			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosX);
// 		// 			// MarkImgCoordY
// 		// 			strName.Format("Y%d",m);
// 		// 			if (!m_XMLConfigator.FindElem(strName))	// (Level-4)
// 		// 			{
// 		// 				goto LoadFailed;
// 		// 			}
// 		// 			m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosY);
// 		// 		}
// 		// 
// 		// 		m_XMLConfigator.LeaveElem();  //4级目录
// 
// 		if (m_XMLConfigator.FindElem(_T("TargetMarkImgCoord")))	// (Level-3)
// 		{
// 			m_XMLConfigator.EnterElem();	  //4级目录	
// 			for (int m=0;m<CALIBMOVEPOSNUM;m++)
// 			{
// 				// MarkImgCoordX
// 				CString strName;
// 				strName.Format("X%d",m);
// 				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosX);
// 				}
// 				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosX);
// 				// MarkImgCoordY
// 				strName.Format("Y%d",m);
// 				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosY);
// 				}
// 				//m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].m_dPosY);
// 			}
// 
// 			m_XMLConfigator.LeaveElem();  //4级目录
// 		}
// 
// 		/////////////////////////////////////////iyo
// 
// 		///////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// 		//用靶标关联映射时，标定板上的Mark位置图像坐标
// 		if (m_XMLConfigator.FindElem(_T("CalibBoardMarkImgCoordPos")))	// (Level-3)
// 		{
// 			m_XMLConfigator.EnterElem();	  //4级目录	
// 			for (int m=0;m<CALIBBOARDMARKPOSNUM;m++)
// 			{
// 				// MarkImgCoordX
// 				CString strName;
// 				strName.Format("X%d",m);
// 				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].m_dPosX);
// 				}
// 				// MarkImgCoordY
// 				strName.Format("Y%d",m);
// 				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].m_dPosY);
// 				}
// 			}
// 
// 			m_XMLConfigator.LeaveElem();  //4级目录
// 		}
// 
// 
// 		//用靶标关联映射时，标定板上的Mark位置物理坐标
// 		if (m_XMLConfigator.FindElem(_T("CalibBoardMarkBoardCoordPos")))	// (Level-3)
// 		{
// 			m_XMLConfigator.EnterElem();	  //4级目录	
// 			for (int m=0;m<CALIBBOARDMARKPOSNUM;m++)
// 			{
// 				// MarkImgCoordX
// 				CString strName;
// 				strName.Format("X%d",m);
// 				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].m_dPosX);
// 				}
// 				// MarkImgCoordY
// 				strName.Format("Y%d",m);
// 				if (m_XMLConfigator.FindElem(strName))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].m_dPosY);
// 				}
// 			}
// 
// 			m_XMLConfigator.LeaveElem();  //4级目录
// 		}
// 
// 
// 		//用靶标关联映射时，标定板尺寸
// 		if (m_XMLConfigator.FindElem(_T("CalibBoardSize")))
// 		{
// 			m_XMLConfigator.EnterElem();//4级目录打开
// 			// SizeX
// 			double dSizeX = 1.0;
// 			double dSizeY = 1.0;
// 			CString strName;
// 			strName.Format("SizeX");
// 			if (m_XMLConfigator.FindElem(strName))
// 			{
// 				m_XMLConfigator.GetElemData(dSizeX);
// 			}
// 
// 			// SizeY
// 			strName.Format("SizeY");
// 			if (m_XMLConfigator.FindElem(strName))
// 			{
// 				m_XMLConfigator.GetElemData(dSizeY);
// 			}
// 
// 			pCalibratedInfo->m_vCalibBoardSize = sc2Vector(dSizeX, dSizeY);
// 			m_XMLConfigator.LeaveElem();//4级目录关闭
// 		}
// 
// 
// 
// 		// 标定时，基准位置处平台各个轴的位置
// 		if (!m_XMLConfigator.FindElem(_T("PlatAxisPos")))	// (Level-3)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.EnterElem();	//4级目录	
// 		if (!m_XMLConfigator.FindElem(_T("X")))		// (Level-4)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dPosX);
// 		if (!m_XMLConfigator.FindElem(_T("Y")))		// (Level-4)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dPosY);
// 		if (!m_XMLConfigator.FindElem(_T("D")))		// (Level-4)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibPlatformAxisPos->m_dAngle);
// 		pCalibratedInfo->SetPlatformAxisPos(pCalibPlatformAxisPos);
// 		m_XMLConfigator.LeaveElem();   //4级目录
// 
// 		// 标定时，图像坐标系与平台坐标系之间的角度
// 		if (!m_XMLConfigator.FindElem(_T("Anlge")))	// (Level-3)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(pCalibratedInfo->m_dImageToPlatformAnlge);
// 		// 标定时，相机坐标系到平台坐标系之间的变换矩阵
// 		if (!m_XMLConfigator.FindElem(_T("CamTM")))	// (Level-3)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.EnterElem();  //4级目录
// 		// A00
// 		m_XMLConfigator.FindElem(_T("A00"));	// (Level-4)
// 		m_XMLConfigator.GetElemData(dValue);
// 		pCalibratedInfo->m_CameraTranferMatrix.SetElement(0,0,dValue);
// 		// A01
// 		m_XMLConfigator.FindElem(_T("A01"));	// (Level-4)
// 		m_XMLConfigator.GetElemData(dValue);
// 		pCalibratedInfo->m_CameraTranferMatrix.SetElement(0,1,dValue);
// 		// A10
// 		m_XMLConfigator.FindElem(_T("A10"));	// (Level-4)
// 		m_XMLConfigator.GetElemData(dValue);
// 		pCalibratedInfo->m_CameraTranferMatrix.SetElement(1,0,dValue);
// 		// A11
// 		m_XMLConfigator.FindElem(_T("A11"));	// (Level-4)
// 		m_XMLConfigator.GetElemData(dValue);
// 		pCalibratedInfo->m_CameraTranferMatrix.SetElement(1,1,dValue);
// 		m_XMLConfigator.LeaveElem();   //4级目录
// 
// 		// 标定时，基准位置处相机平台各个轴的位置（XY）
// 		if (!m_XMLConfigator.FindElem(_T("CamPlatAxisPos")))	// (Level-3)
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.EnterElem();  //4级目录
// 		if (!m_XMLConfigator.FindElem(_T("CamPlatType")))
// 		{
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.GetElemData(nData);
// 		if (((CamPlatformType)nData) != m_pPlatformInfo->m_eCamPlatformType)
// 		{
// 			goto LoadFailed;
// 		}
// 
// 		switch((CamPlatformType)nData)
// 		{
//         case eCamPlatformSepFix:
//             break;
// 		case eCamPlatformSepX:
// 			pCamPlatformAxisPos = new CPlatformXYAxisPos;				
// 			// X轴位置
// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 			{
// 				goto LoadFailed;
// 			}
// 			m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
// 			pCalibratedInfo->SetCamPlatformAxisPos(pCamPlatformAxisPos);
// 			break;
// 		case eCamPlatformSepXY:
// 			pCamPlatformAxisPos = new CPlatformXYAxisPos;			
// 			// X轴位置
// 			if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 			{
// 				goto LoadFailed;
// 			}
// 			m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);
// 			// Y轴位置
// 			if (m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 			{
// 				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);
// 			}
// 			pCalibratedInfo->SetCamPlatformAxisPos(pCamPlatformAxisPos);
// 			break;
// 		case eCamPlatformShareX:
// 		default:
// 			goto LoadFailed;
// 		}
// 		m_XMLConfigator.LeaveElem();	// Leave CamPlatformAxisPos //4级目录
// 
// 		if(m_XMLConfigator.FindElem(_T("CamAxisPlatformAxisPos")))
// 		{
// 			m_XMLConfigator.EnterElem();
// 			switch((CamPlatformType)nData)
// 			{
// 			case eCamPlatformSepFix:
// 				break;
// 			case eCamPlatformSepX:
// 				pCamAxisPlatformAxisPos = new CPlatformXYAxisPos;				
// 				// X轴位置
// 				if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 				{
// 					goto LoadFailed;
// 				}
// 				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosX);
// 				pCalibratedInfo->SetCamAxisPlatformAxisPos(pCamAxisPlatformAxisPos);
// 				break;
// 			case eCamPlatformSepXY:
// 				pCamAxisPlatformAxisPos = new CPlatformXYAxisPos;			
// 				// X轴位置
// 				if (!m_XMLConfigator.FindElem(_T("X")))	// (Level-4)
// 				{
// 					goto LoadFailed;
// 				}
// 				m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosX);
// 				// Y轴位置
// 				if (m_XMLConfigator.FindElem(_T("Y")))	// (Level-4)
// 				{
// 					m_XMLConfigator.GetElemData(((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos)->m_dPosY);
// 				}
// 				//pCalibratedInfo->SetCamAxisPlatformAxisPos(pCamPlatformAxisPos);
// 				pCalibratedInfo->SetCamAxisPlatformAxisPos(pCamAxisPlatformAxisPos); // 修复加载相机平台轴错误的BUG
// 				break;
// 			case eCamPlatformShareX:
// 			default:
// 				break;
// 			}
// 			m_XMLConfigator.LeaveElem();
// 		}
// 		m_XMLConfigator.LeaveElem();	// Leave CH%d //3级目录
// 		if (calibData.m_vpCalibratedInfo.at(i) != NULL)
// 		{
// 			delete calibData.m_vpCalibratedInfo.at(i);
// 			calibData.m_vpCalibratedInfo.at(i) = NULL;
// 		}
// 		calibData.m_vpCalibratedInfo.at(i) = new CCalibratedInfo(*pCalibratedInfo);
// 		if (pCamPlatformAxisPos != NULL)
// 		{
// 			delete pCamPlatformAxisPos;
// 			pCamPlatformAxisPos = NULL;
// 		}
// 		if (pCamAxisPlatformAxisPos != NULL)
// 		{
// 			delete pCamAxisPlatformAxisPos;
// 			pCamAxisPlatformAxisPos = NULL;
// 		}
// 	}   
// 	m_XMLConfigator.LeaveElem(); //2级目录
// 	m_XMLConfigator.LeaveElem();  //1级目录
// 	if (calibData.IsValid())
// 	{
// 		m_pVisionASMConfig->m_TotalCalibData.SetItemGrow(nIndex, calibData);
// 	}
// 	else
// 	{
// 		goto LoadFailed;
// 	}
// 
// 	if (pCalibrateParam != NULL)
// 	{
// 		delete pCalibrateParam;
// 		pCalibrateParam = NULL;
// 	}
// 
// 	if (pCalibratedInfo != NULL)
// 	{
// 		delete pCalibratedInfo;
// 		pCalibratedInfo = NULL;
// 	}
// 	if (pCalibPlatformAxisPos != NULL)
// 	{
// 		delete pCalibPlatformAxisPos;
// 		pCalibPlatformAxisPos = NULL;
// 	}
// 	if (pCamPlatformAxisPos != NULL)
// 	{
// 		delete pCamPlatformAxisPos;
// 		pCamPlatformAxisPos = NULL;
// 	}
// 	if (pCamAxisPlatformAxisPos != NULL)
// 	{
// 		delete pCamAxisPlatformAxisPos;
// 		pCamAxisPlatformAxisPos = NULL;
// 	}
// 	return TRUE;
// 
// 	// 加载失败的资源释放
// LoadFailed:
// 	{
// 		if (pCalibrateParam != NULL)
// 		{
// 			delete pCalibrateParam;
// 			pCalibrateParam = NULL;
// 		}
// 
// 		if (pCalibratedInfo != NULL)
// 		{
// 			delete pCalibratedInfo;
// 			pCalibratedInfo = NULL;
// 		}
// 		if (pCalibPlatformAxisPos != NULL)
// 		{
// 			delete pCalibPlatformAxisPos;
// 			pCalibPlatformAxisPos = NULL;
// 		}
// 		if (pCamPlatformAxisPos != NULL)
// 		{
// 			delete pCamPlatformAxisPos;
// 			pCamPlatformAxisPos = NULL;
// 		}
// 		if (pCamAxisPlatformAxisPos != NULL)
// 		{
// 			delete pCamAxisPlatformAxisPos;
// 			pCamAxisPlatformAxisPos = NULL;
// 		}
// 		return FALSE;
// 	}
// }

// BOOL vcXYDVisionAlign::SaveCalibDataInfo(int nIndex)
// {
// 	ASSERT(nIndex >= 0);
// 	ASSERT(m_pVisionASMConfig != NULL);
// 	ASSERT(nIndex < m_pVisionASMConfig->m_TotalCalibData.GetCount());
// 	ASSERT(m_pPlatformInfo != NULL);
// 
// 	if ((nIndex < 0) || (nIndex >= m_pVisionASMConfig->m_TotalCalibData.GetCount()))
// 	{
// 		return FALSE;
// 	}
// 	if (m_pVisionASMConfig == NULL)
// 	{
// 		return FALSE;
// 	}
// 	if (m_pPlatformInfo == NULL)
// 	{
// 		return FALSE;
// 	}
// 	CString strInfo;
// 	double dValue = 0;
// 	int i = 0, j = 0, nData = 0;
// 	CCoordPos pos;
// 	sc2Matrix mat;
// 
// 	CCalibData				calibData = m_pVisionASMConfig->m_TotalCalibData.GetItem(nIndex);
// 	CCalibrateParam			*pCalibrateParam = NULL;			// 显式释放内存
// 	CCalibratedInfo			*pCalibratedInfo = NULL;
// 	CPlatformXYDAxisPos		*pCalibPlatformAxisPos = NULL;
// 	CPlatformAxisPos		*pCamPlatformAxisPos = NULL;
// 
// 	if ((calibData.m_vpCalibrateParam.size() <= 0) || (calibData.m_vpCalibratedInfo.size() <= 0))
// 	{
// 		return FALSE;
// 	}
// 	vcXMLConfigurator m_XMLConfigator;
// 	m_XMLConfigator.SetDoc(_T(""));
// 	m_XMLConfigator.AddElem(_T("JobCalibConfig"));	// (Root)
// 	m_XMLConfigator.EnterElem();
// 
// 	m_XMLConfigator.AddElem(_T("CalibIndex"), calibData.GetCalibIndex());	// (Level-1) 产品标定索引号
// 	//BSTR bstrName = calibData.GetCalibUserName();	// (Level-1) 产品标定用户自定义名称
// 	//m_XMLConfigator.AddElem(_T("CalibCustomName"), (CString)bstrName);
// 	//SysFreeString(bstrName);
// 	m_XMLConfigator.AddElem(_T("CalibCustomName"), calibData.GetCalibUserName());				// (Level-1) 产品标定用户自定义名称
// 	m_XMLConfigator.AddElem(_T("CalibMarkPatternMode"), calibData.GetCalibMarkPatternMode());	// (Level-1) 产品标定模式
// 	m_XMLConfigator.AddElem(_T("CalibHomographyDOF"), calibData.GetCalibHomographyDOF());		// (Level-1) 产品标定模式
// 	m_XMLConfigator.AddElem(_T("WholeCalibCacuPos"), calibData.GetWholeCalibCacuPos());			// (Level-1) 产品标定模式
// 	m_XMLConfigator.AddElem(_T("WholeCalibCacuPosEnable"), (int)calibData.GetWholeCalibCacuPosEnable());// (Level-1) 产品标定模式
// 
// 	m_XMLConfigator.AddElem(_T("CalibParam"));	// (Level-1) 标定参数
// 	m_XMLConfigator.EnterElem(); // 进入2级目录
// 	nData = calibData.m_vpCalibrateParam.size();
// 	for (i=0; i<nData; i++)
// 	{	
// 		pCalibrateParam = calibData.m_vpCalibrateParam.at(i);
// 		if (pCalibrateParam == NULL)
// 		{
// 			continue;
// 		}
// 
// 		strInfo.Format(_T("CalibParam%d"), i);
// 		m_XMLConfigator.AddElem(strInfo); // (Level-2)
// 		m_XMLConfigator.EnterElem();//4级目录打开
// 
// 		// 标定模板数量
// 		m_XMLConfigator.AddElem(_T("CalibPatNum"));		
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_nCalibPatternNum);	
// 
// 		// 标定模板ID
// 		m_XMLConfigator.AddElem(_T("CalibPatID"));		
// 		m_XMLConfigator.EnterElem();		//4级目录打开	
// 		CString strID;
// 		for (j=0; j<pCalibrateParam->m_nCalibPatternNum; j++)
// 		{
// 			strInfo.Format(_T("ID%d"),j);
// 
// 			m_XMLConfigator.AddElem(strInfo);
// 			m_XMLConfigator.SetElemData(pCalibrateParam->m_vstrCalibPatternIDS[j]);	
// 
// 		}			
// 		m_XMLConfigator.LeaveElem();  //4级目录关闭
// 
// 
// 		// 平台坐标系标定时各轴运动控制量		  
// 		m_XMLConfigator.AddElem(_T("PlatMove"));	
// 		m_XMLConfigator.EnterElem();  //4级目录打开
// 
// 		// DX
// 		m_XMLConfigator.AddElem(_T("DX"));	
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dPosX);
// 
// 		// DY
// 		m_XMLConfigator.AddElem(_T("DY"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dPosY);				
// 
// 		// DD
// 		m_XMLConfigator.AddElem(_T("DD"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_dPlatformCalibMovement.m_dAngle);			
// 
// 		m_XMLConfigator.LeaveElem();  //4级目录关闭
// 
// 
// 		// 相机单独控制时，XY轴运动控制量
// 		m_XMLConfigator.AddElem(_T("CamMove"));		
// 		m_XMLConfigator.EnterElem(); //4级目录打开
// 
// 		// DX
// 		m_XMLConfigator.AddElem(_T("DX"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_dCameraCalibMovement.m_dPosX);				
// 
// 		// DY
// 		m_XMLConfigator.AddElem(_T("DY"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_dCameraCalibMovement.m_dPosY);			
// 
// 		m_XMLConfigator.LeaveElem(); //退出XY轴运动控制量  //4级目录关闭
// 
// 		// 平台标定是否求精
// 		m_XMLConfigator.AddElem(_T("PlatCalibRefine"));
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_bPlatformCalibrateRefine);	 
// 
// 		m_XMLConfigator.AddElem(_T("PlatCalibRefineTime"));
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_nPlatformCalibRefineTime);	 
// 
// 		m_XMLConfigator.AddElem(_T("PlatCalibRefineMoveD"));
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_dPlatformCalibRefineMoveD);	
// 
// 		// 搜索延时
// 		m_XMLConfigator.AddElem(_T("SearchDelayTime"));
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_nSearchDelayTime);	
// 
// 
// 		// 畸形校正相关参数
// 		m_XMLConfigator.AddElem(_T("DistorCorrParam"));		
// 		m_XMLConfigator.EnterElem(); //4级目录打开
// 
// 		// TileX
// 		m_XMLConfigator.AddElem(_T("TileX"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_dTileX);				
// 
// 		// TileY
// 		m_XMLConfigator.AddElem(_T("TileY"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_dTileY);		
// 
// 		// EnableOutPoints
// 		m_XMLConfigator.AddElem(_T("EnableOutPoints"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_bOutPoints);				
// 
// 		// Thre
// 		m_XMLConfigator.AddElem(_T("Thre"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_iThre);	
// 
// 		// IsEnableDisCor
// 		m_XMLConfigator.AddElem(_T("IsEnableDisCor"));				
// 		m_XMLConfigator.SetElemData(pCalibrateParam->m_nEnableDisCor);	
// 
// 		m_XMLConfigator.LeaveElem(); //退出XY轴运动控制量  //4级目录关闭
// 
// 
// 
// 		m_XMLConfigator.AddElem(_T("CalibMarkPatternMode"));
// 		m_XMLConfigator.SetElemData((CalibMarkPatternMode)pCalibrateParam->m_eCalibMarkPatternMode);	
// 
// 		m_XMLConfigator.LeaveElem(); //退出标定参数访问  //3级目录关闭	
// 	}
// 	m_XMLConfigator.LeaveElem(); // 关闭2级目录
// 
// 
// 	// 标定后参数（与平台相关）
// 	m_XMLConfigator.AddElem(_T("CalibedResult"));	// (Level-1)
// 	m_XMLConfigator.EnterElem();
// 	nData = calibData.m_vpCalibratedInfo.size();
// 	for (i=0; i<nData; i++)
// 	{
// 		strInfo.Format(_T("CalibedResult%d"), i);
// 		m_XMLConfigator.AddElem(strInfo); // (Level-2)
// 		m_XMLConfigator.EnterElem();
// 		pCalibratedInfo = calibData.m_vpCalibratedInfo.at(i);
// 		m_XMLConfigator.AddElem(_T("Valid"));	
// 		m_XMLConfigator.SetElemData(pCalibratedInfo->m_bValid);
// 		//  标定时，图像坐标系到平台坐标系之间的变换矩阵
// 		m_XMLConfigator.AddElem(_T("PlatTM"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		mat = pCalibratedInfo->GetPlatformTransferMatrix();
// 		m_XMLConfigator.AddElem(_T("A00"), mat.GetElement(0, 0));	// (Level-4)
// 		m_XMLConfigator.AddElem(_T("A01"), mat.GetElement(0, 1));	// (Level-4)
// 		m_XMLConfigator.AddElem(_T("A10"), mat.GetElement(1, 0));	// (Level-4)
// 		m_XMLConfigator.AddElem(_T("A11"), mat.GetElement(1, 1));	// (Level-4)
// 		m_XMLConfigator.LeaveElem();
// 		//  标定时，图像坐标系到平台坐标系之间的变换矩阵
// 		m_XMLConfigator.AddElem(_T("PlatTMH"));	
// 		m_XMLConfigator.EnterElem();  //4级目录打开
// 		{
// 			int j = 0;
// 			for(j = 0; j < 9; j++)
// 			{
// 				strInfo.Format(_T("h%d"), j);				
// 				m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH[j]);			
// 			}
// 		}
// 		m_XMLConfigator.LeaveElem(); //4级目录关闭
// 
// 		//  全局靶标标定时，图像坐标系到靶标坐标系之间的变换矩阵
// 		m_XMLConfigator.AddElem(_T("PlatTMH1"));	
// 		m_XMLConfigator.EnterElem();  //4级目录打开
// 		{
// 			int j = 0;
// 			for(j = 0; j < 9; j++)
// 			{
// 				strInfo.Format(_T("h1%d"), j);				
// 				m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH1[j]);			
// 			}
// 		}
// 		m_XMLConfigator.LeaveElem(); //4级目录关闭
// 
// 		//  全局靶标标定时，靶标坐标系到平台坐标系之间的变换矩阵
// 		m_XMLConfigator.AddElem(_T("PlatTMH2"));	
// 		m_XMLConfigator.EnterElem();  //4级目录打开
// 		{
// 			int j = 0;
// 			for(j = 0; j < 9; j++)
// 			{
// 				strInfo.Format(_T("h2%d"), j);				
// 				m_XMLConfigator.AddElem(strInfo, pCalibratedInfo->m_PlatformTranferH2[j]);			
// 			}
// 		}
// 		m_XMLConfigator.LeaveElem(); //4级目录关闭
// 
// 		//  畸变校正图像结果
// 		m_XMLConfigator.AddElem(_T("DistorCorrResult"));	
// 		m_XMLConfigator.EnterElem();  //4级目录打开
// 		{
// 			int j = 0;
// 			double dResult[15];
// 			pCalibratedInfo->m_result.GetNonlinearProjectResult(dResult);
// 			double dRMS = pCalibratedInfo->m_result.GetRMS();
// 			for(j = 0; j < 15; j++)
// 			{
// 				strInfo.Format(_T("p%d"), j);				
// 				m_XMLConfigator.AddElem(strInfo, dResult[j]);			
// 			}
// 			strInfo.Format(_T("RMS"));
// 			m_XMLConfigator.AddElem(strInfo, dRMS);		
// 		}
// 		m_XMLConfigator.LeaveElem(); //4级目录关闭
// 
// 
// 		m_XMLConfigator.AddElem(_T("PlatRefineOffset"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffset();
// 		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
// 		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 
// 	//	if (GetProductCalibTargetMarkPatternMode(nIndex) == eSinglePatternGuanlian4Point)
// 		{
// 			for (int m=0;m<4;m++)
// 			{
// 				CString str;
// 				str.Format("AuxiliaryPosX-%d",m);
// 				m_XMLConfigator.AddElem(str,pos.GetAuxiliaryPosX(m));
// 				
// 				str.Format("AuxiliaryPosY-%d",m);
// 				m_XMLConfigator.AddElem(str,pos.GetAuxiliaryPosY(m));
// 			}
// 		}
// 
// 		m_XMLConfigator.LeaveElem();
// 
// 		m_XMLConfigator.AddElem(_T("PlatRefineOffsetH1"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffsetH1();
// 		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
// 		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 
// 		m_XMLConfigator.LeaveElem();
// 
// 		m_XMLConfigator.AddElem(_T("PlatRefineOffsetH2"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		pos = pCalibratedInfo->GetMarkPlatformCoordPosRefineOffsetH2();
// 		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) 
// 		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) 
// 		m_XMLConfigator.LeaveElem();
// 
// 		// 标定时，基准Mark在平台坐标系的坐标值和姿态
// 		m_XMLConfigator.AddElem(_T("MarkPlatCoord"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		pos = pCalibratedInfo->GetMarkPlatformCoordPos();
// 		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkPltCoordX
// 		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkPltCoordY
// 		m_XMLConfigator.LeaveElem();
// 		// 标定时，基准Mark在图像坐标系中的位置
// 		m_XMLConfigator.AddElem(_T("MarkImgCoord"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		pos = pCalibratedInfo->GetMarkImgCoordPos();
// 		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkImgCoordX
// 		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkImgCoordY
// 		m_XMLConfigator.LeaveElem();
// 		
// 
// 		// 标定时，基准Mark在平台坐标系的坐标值和姿态
// 		m_XMLConfigator.AddElem(_T("MarkPlatCoordBat"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		pos = pCalibratedInfo->GetMarkPlatformCoordPosBat();
// 		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkPltCoordX
// 		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkPltCoordY
// 		m_XMLConfigator.LeaveElem();
// 		// 标定时，基准Mark在图像坐标系中的位置
// 		m_XMLConfigator.AddElem(_T("MarkImgCoordBat"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		pos = pCalibratedInfo->GetMarkImgCoordPosBat();
// 		m_XMLConfigator.AddElem(_T("X"), pos.GetPosX());	// (Level-4) MarkImgCoordX
// 		m_XMLConfigator.AddElem(_T("Y"), pos.GetPosY());	// (Level-4) MarkImgCoordY
// 		m_XMLConfigator.LeaveElem();
// 
// 
// 		// 标定时，基准Mark在图像坐标系中的位置
// 		m_XMLConfigator.AddElem(_T("ObjectMarkImgCoord"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		for (int m =0;m<CALIBMOVEPOSNUM;m++)
// 		{
// 			CString strName;
// 			strName.Format("X%d",m);
// 			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
// 			strName.Format("Y%d",m);
// 			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpObjectMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
// 		}
// 
// 		m_XMLConfigator.LeaveElem();
// 
// 		// 标定时，基准Mark在图像坐标系中的位置
// 		m_XMLConfigator.AddElem(_T("TargetMarkImgCoord"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		for (int m =0;m<CALIBMOVEPOSNUM;m++)
// 		{
// 			CString strName;
// 			strName.Format("X%d",m);
// 			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
// 			strName.Format("Y%d",m);
// 			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpTargetMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
// 		}
// 
// 		m_XMLConfigator.LeaveElem();
// 
// 		///////////////////////////////////////////////////////iyo
// 
// 		//////////////////////////////////////////////////////////
// 
// 		//用靶标关联映射时，标定板上的Mark位置图像坐标
// 		m_XMLConfigator.AddElem(_T("CalibBoardMarkImgCoordPos"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		for (int m =0;m<CALIBBOARDMARKPOSNUM;m++)
// 		{
// 			CString strName;
// 			strName.Format("X%d",m);
// 			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
// 			strName.Format("Y%d",m);
// 			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkImgCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
// 		}
// 		m_XMLConfigator.LeaveElem();	
// 
// 		//用靶标关联映射时，标定板上的Mark位置物理坐标
// 		m_XMLConfigator.AddElem(_T("CalibBoardMarkBoardCoordPos"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		for (int m =0;m<CALIBBOARDMARKPOSNUM;m++)
// 		{
// 			CString strName;
// 			strName.Format("X%d",m);
// 			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].GetPosX());	// (Level-4) MarkImgCoordX
// 			strName.Format("Y%d",m);
// 			m_XMLConfigator.AddElem(strName, pCalibratedInfo->m_cpCalibBoardMarkBoardCoordPos[m].GetPosY());	// (Level-4) MarkImgCoordY
// 		}
// 		m_XMLConfigator.LeaveElem();
// 
// 		//用靶标关联映射时，标定板尺寸
// 		m_XMLConfigator.AddElem(_T("CalibBoardSize"));
// 		m_XMLConfigator.EnterElem();  //4级目录打开
// 		// SizeX
// 		CString strName;
// 		strName.Format("SizeX");
// 		m_XMLConfigator.AddElem(strName);					 
// 		m_XMLConfigator.SetElemData(pCalibratedInfo->m_vCalibBoardSize.GetX());
// 		// SizeY
// 		strName.Format("SizeY");
// 		m_XMLConfigator.AddElem(strName);					  
// 		m_XMLConfigator.SetElemData(pCalibratedInfo->m_vCalibBoardSize.GetY());
// 		m_XMLConfigator.LeaveElem();  //4级目录关闭
// 
// 
// 		// 标定时，基准位置处平台各个轴的位置
// 		m_XMLConfigator.AddElem(_T("PlatAxisPos"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		pCalibPlatformAxisPos = (CPlatformXYDAxisPos*)pCalibratedInfo->GetPlatformAxisPos();
// 		m_XMLConfigator.AddElem(_T("X"), pCalibPlatformAxisPos->m_dPosX);		// (Level-4) 
// 		m_XMLConfigator.AddElem(_T("Y"), pCalibPlatformAxisPos->m_dPosY);		// (Level-4) 
// 		m_XMLConfigator.AddElem(_T("D"), pCalibPlatformAxisPos->m_dAngle);		// (Level-4)
// 		m_XMLConfigator.LeaveElem();
// 		// 标定时，图像坐标系与平台坐标系之间的角度
// 		m_XMLConfigator.AddElem(_T("Anlge"), pCalibratedInfo->m_dImageToPlatformAnlge);	// (Level-3)
// 		// 标定时，相机坐标系到平台坐标系之间的变换矩阵
// 		m_XMLConfigator.AddElem(_T("CamTM"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		mat = pCalibratedInfo->GetCamPlatformTransferMatrix();
// 		m_XMLConfigator.AddElem(_T("A00"), mat.GetElement(0, 0));	// (Level-4)
// 		m_XMLConfigator.AddElem(_T("A01"), mat.GetElement(0, 1));	// (Level-4)
// 		m_XMLConfigator.AddElem(_T("A10"), mat.GetElement(1, 0));	// (Level-4)
// 		m_XMLConfigator.AddElem(_T("A11"), mat.GetElement(1, 1));	// (Level-4)
// 		m_XMLConfigator.LeaveElem();
// 		// 标定时，基准位置处相机平台各个轴的位置（XY）
// 		m_XMLConfigator.AddElem(_T("CamPlatAxisPos"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 		CamPlatformType eType = m_pVisionASMConfig->m_pCamPlatformInfo->GetCamPlatformType();
// 		m_XMLConfigator.AddElem(_T("CamPlatType"), (int)eType);	// (Level-4)
// 		pCamPlatformAxisPos = pCalibratedInfo->GetCamPlatformAxisPos();
// 		if (pCamPlatformAxisPos != NULL)
// 		{
// 			switch (eType)
// 			{
//             case eCamPlatformSepFix:
//                 break;
// 			case eCamPlatformSepX:
// 				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
// 				break;
// 			case eCamPlatformSepXY:
// 				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
// 				m_XMLConfigator.AddElem(_T("Y"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);	// (Level-4)
// 				break;
// 			case eCamPlatformShareX:
// 			default:
// 				break;
// 			}		
// 		}
// 		m_XMLConfigator.LeaveElem();	// Leave CamPlatformAxisPos
// 
// 		m_XMLConfigator.AddElem(_T("CamAxisPlatformAxisPos"));	// (Level-3)
// 		m_XMLConfigator.EnterElem();
// 
// 		pCamPlatformAxisPos = pCalibratedInfo->GetCamAxisPlatformAxisPos();
// 		if (pCamPlatformAxisPos != NULL)
// 		{
// 			switch (eType)
// 			{
//             case eCamPlatformSepFix:
//                 break;
// 			case eCamPlatformSepX:
// 				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
// 				break;
// 			case eCamPlatformSepXY:
// 				m_XMLConfigator.AddElem(_T("X"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosX);	// (Level-4)
// 				m_XMLConfigator.AddElem(_T("Y"), ((CPlatformXYAxisPos*)pCamPlatformAxisPos)->m_dPosY);	// (Level-4)
// 				break;
// 			case eCamPlatformShareX:
// 			default:
// 				break;
// 			}		
// 		}
// 		m_XMLConfigator.LeaveElem();	// Leave CamPlatformAxisPos
// 
// 
// 		m_XMLConfigator.LeaveElem();	// Leave CH%d
// 	}
// 	m_XMLConfigator.LeaveElem();
// 	m_XMLConfigator.LeaveElem();
// 
// 	CString strName = m_pVisionASMConfig->m_TotalCalibData.GetItemName(nIndex);
// 	strName.Format(_T("%03d"),nIndex+1);
// 	if (strName.IsEmpty())	// 产品名称为空，不合法
// 	{
// 		return FALSE;
// 	}
// 	CString strDir = m_strEXEDir + m_pPlatformInfo->m_strPlatformDetailSavePath 
// 		+ _T("\\JobCalibs\\") + strName;
// 
// 	// 创建产品保存文件夹
// 	DWORD dwAttributes = GetFileAttributes(strDir);
// 	if ((dwAttributes == 0xFFFFFFFF) || ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
// 	{	
// 		// 创建多级目录
// 		int nLen = 0;
// 		DWORD dwLevelXAttrib = 0;
// 		int nSlashIdx = strDir.Find('\\');
// 		CString strDirLevelX = _T("");
// 		CString strTemp = strDir;
// 		while (nSlashIdx != -1)
// 		{
// 			nLen = strDirLevelX.GetLength();
// 			nSlashIdx += (nLen == 0) ? 0 : (nLen + 1);
// 			strDirLevelX = strDir.Left(nSlashIdx);
// 			strTemp = strDir.Mid(nSlashIdx + 1);
// 			dwLevelXAttrib = GetFileAttributes(strDirLevelX);
// 			if ((dwLevelXAttrib == 0xFFFFFFFF) || ((dwLevelXAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0))
// 			{
// 				if (!CreateDirectory(strDirLevelX, NULL))
// 				{
// 					return FALSE;
// 				}
// 			}
// 			nSlashIdx = strTemp.Find('\\');
// 		}
// 		if (!CreateDirectory(strDir, NULL))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	return m_XMLConfigator.Save(strDir + _T("\\JobCalib.xml"));
// }


// S7：初始化相机：根据相机相机信息(个数、序列号、帧数、曝光时间、增益等），初始化相机，设置相机回调函数，准备开始采集图像；
// S7.1：初始化图像对象：根据相机个数初始化用于接收数据的图像类对象；
// S8：初始化通信接口：根据通信接口信息（接口类型及相应的配置信息），初始化通信接口，准备开始接收通信指令信息；
// S9：初始化标定用的定位工具：；
// S10：初始化对位用的定位工具：；
// S11：初始化对位工具的标定功能：；
// S12：初始化对位工具的对位功能：；
// S13：创建平台的对位处理线程：；
// S13.1：


//////////////////////////////////////////////////////////////////////////
// 总体信息：对位平台信息、相机平台信息
// 设置平台信息
// void vcXYDVisionAlign::SetPlatformInfo(CPlatformInfo*	pPlatformInfo)
// {
// 	if ((NULL == pPlatformInfo)||(NULL == m_pVisionASMConfig))
// 	{
// 		return;
// 	}
// 
// 	DeletePlatformInfo();
// 	m_pVisionASMConfig->m_pPlatformInfo = new CPlatformXYDInfo;
// 
// 	CPlatformXYDInfo* pNewPlatformInfo = (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo;;
// 	CPlatformXYDInfo* pOldPlatformInfo = (CPlatformXYDInfo*)pPlatformInfo;	
// 
// 	pNewPlatformInfo->m_nPlatformXCoordType = pOldPlatformInfo->m_nPlatformXCoordType;
// 	pNewPlatformInfo->m_nPlatformYCoordType = pOldPlatformInfo->m_nPlatformYCoordType;
// 	pNewPlatformInfo->m_nPlatformDCoordType = pOldPlatformInfo->m_nPlatformDCoordType;
// 	pNewPlatformInfo->m_nPlatformDDriveType = pOldPlatformInfo->m_nPlatformDDriveType;
// 	pNewPlatformInfo->m_nPlatformDDriveLineType = pOldPlatformInfo->m_nPlatformDDriveLineType;
// 	pNewPlatformInfo->m_dPlatformRotationLength = pOldPlatformInfo->m_dPlatformRotationLength;    
// 
// 	m_pVisionASMConfig->m_pPlatformInfo = pNewPlatformInfo;
// 
// }
// 获取平台信息	
// CPlatformInfo* vcXYDVisionAlign::GetPlatformInfo()
// {
// 	if (NULL == m_pVisionASMConfig)
// 	{
// 		return NULL;
// 	}
// 
// 	return m_pVisionASMConfig->m_pPlatformInfo;
// }

// 设置相机平台信息
// void vcXYDVisionAlign::SetCamPlatformInfo(CCamPlatformInfo* camPlatformInfo)
// {
// 	if ((NULL == camPlatformInfo)||(NULL == m_pVisionASMConfig))
// 	{
// 		return;
// 	}
// 
// 	DeleteCameraPlatformInfo();
// 	m_pVisionASMConfig->m_pCamPlatformInfo = new CCamPlatformInfo(*camPlatformInfo);
// }
// 
// // 获取相机平台信息	
// CCamPlatformInfo* vcXYDVisionAlign::GetCamPlatformInfo()
// {
// 	if (NULL == m_pVisionASMConfig)
// 	{
// 		return NULL;
// 	}
// 
// 	return m_pVisionASMConfig->m_pCamPlatformInfo;
// }

//////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
// 对位工具：标定

// 初始化对位工具（定义new AlignerTool+初始化标定时的nIndex定位工具对象+下面三个参数设置+初始化对位用的定位工具对象+下面两个参数设置）
BOOL vcXYDVisionAlign::InitAlignTool()
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
	{
		return FALSE;
	}

	BOOL bResult = FALSE;

	int nCurProductIndex = 0;
	nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	bResult = InitAlignTool(nCurProductIndex);
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pProduct == NULL)
	{
		return FALSE;
	}

	//	bResult = InitAlignTool(nCurProductIndex);

	return bResult;

	// 	if ((NULL == m_pPlatformInfo) || (NULL == m_pVisionASMConfig))
	// 	{
	// 		return FALSE;
	// 	}
	// 
	// 	if (m_pPlatformInfo->m_ePlatformType!=ePlatformXYD)
	// 	{
	// 		return FALSE;
	// 	}
	// 
	// 	// 释放内存
	// 	vcBaseVisionAlign::UnInitAlignTool();
	// 
	// 	// 创建对位工具, 并根据当前产品信息设置相关参数
	// 	m_pAlignerTool = new vcXYDAlignTool;
	// 
	// 	int nNum = m_pPlatformInfo->m_nCamNum;
	// 	if(1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;
	// 
	// 	m_pAlignerTool->SetMarkNum(nNum);
	// 
	// 	// 标定相关设置
	// 	m_pAlignerTool->SetPlatformParam(m_pVisionASMConfig->m_pPlatformInfo);
	// 	m_pAlignerTool->SetCamPlatformParam(m_pVisionASMConfig->m_pCamPlatformInfo);	
	// 	m_pAlignerTool->SetCalibParam(&m_pVisionASMConfig->m_CalibrateParam);
	// 
	// 	// 对位相关设置（根据当前产品信息设置） 
	// 	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();	
	// 	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	// 	{
	// 		return FALSE;
	// 	}	
	// 	CProductData curProduct = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);
	// 	if (!curProduct.IsValid())
	// 	{
	// 		return FALSE;
	// 	}
	// 	m_pAlignerTool->SetProductAlignerParam(*(curProduct.m_pAlignerParam)); 
	// 	m_pAlignerTool->SetProductCalibratedInfo(curProduct.m_vpCalibratedInfo);
	// 
	// 
	// 	return TRUE;
}		



// 初始化对位工具（定义new AlignerTool+初始化标定时的nIndex定位工具对象+下面三个参数设置+初始化对位用的定位工具对象+下面两个参数设置）
BOOL vcXYDVisionAlign::InitAlignTool(int nProductIndex)
{	
	if ((NULL == m_pPlatformInfo) || (NULL == m_pVisionASMConfig))
	{
		return FALSE;
	}

	if (m_pPlatformInfo->m_ePlatformType!=ePlatformXYD)
	{
		return FALSE;
	}

	// 0.0 初始化协议
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	m_XYDCommProtocol.SetMidPlatformInfo(sysPlatformInfo.m_eMidPlatformType, GetMidPlatformInfo());

	// 释放内存
	// vcBaseVisionAlign::UnInitAlignTool();

	// 创建对位工具, 并根据当前产品信息设置相关参数
	if (m_pAlignerTool == NULL)
	{
		m_pAlignerTool = new vcXYDAlignTool;
		m_pAlignerTool->m_pVisionAlignerTool = this;

		// 		m_pAlignerTool->m_nObjectPositionNum = sysPlatformInfo.m_nObjectPositionNum;
		// 		m_pAlignerTool->m_nTargetPositionNum = sysPlatformInfo.m_nTargetPositionNum;
		// 		m_pAlignerTool->m_nTargetPositionVirtualMode = sysPlatformInfo.m_nTargetPositionVirtualMode;
		// 		m_pAlignerTool->m_nObjectPositionVirtualMode = sysPlatformInfo.m_nObjectPositionVirtualMode;
		// 		m_pAlignerTool->m_bEnableTargetPositionVirtualMode = sysPlatformInfo.m_bEnableTargetPositionVirtualMode;
		// 		m_pAlignerTool->m_bEnableObjectPositionVirtualMode = sysPlatformInfo.m_bEnableObjectPositionVirtualMode;
		// 		m_pAlignerTool->m_bTargetPositionDirectionMode = sysPlatformInfo.m_bTargetPositionDirectionMode;
		// 		m_pAlignerTool->m_bObjectPositionDirectionMode = sysPlatformInfo.m_bObjectPositionDirectionMode;
	}

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	int nNum = m_pPlatformInfo->m_nCamNum;
	//	if(1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;
	nNum = m_pPlatformInfo->m_nPositionNum;
// 	BOOL bLogRecordEnable = m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage 
// 							&& m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo
// 							&& m_pVisionASMConfig->m_DataRecord.m_bCommunication;
	BOOL bLogRecordEnable = m_pVisionASMConfig->m_DataRecord.m_bAlignToolLog;
	m_pAlignerTool->SetLogRecordEnable(bLogRecordEnable);
	m_pAlignerTool->SetPlatformIndex(m_pPlatformInfo->m_nPlatformIndex);
	m_pAlignerTool->SetMidPlatformType(sysPlatformInfo.m_eMidPlatformType);
	//	m_pAlignerTool->SetDiffPosWithSameCalibInfo(sysPlatformInfo.m_bDiffPosWithSameCalibInfoEnabled);
	m_pAlignerTool->SetAlignerTargetMoveType(m_pPlatformInfo->m_eAlignerTargetMoveType);
	m_pAlignerTool->SetAlignerObjectMoveType(m_pPlatformInfo->m_eAlignerObjectMoveType);
	m_pAlignerTool->SetTargetObjectCamSeparate(m_pPlatformInfo->m_bTargetObjectCamSeparate);
	//	m_pAlignerTool->SetTargetGuanLianUse4Points(m_pPlatformInfo->m_bTargetGuanLianUse4Points);
	m_pAlignerTool->SetUseAlignFAHLex(m_pPlatformInfo->m_bUseAlignFAHLex); //iyo
	m_pAlignerTool->SetTargetCalibUseBoard(m_pPlatformInfo->m_bTargetCalibUseBoard);

	m_pAlignerTool->SetTargetUseFixedVirtualCoordinates(optionInfo.m_bTargetUseFixedVirtualCoordinates);

	m_pAlignerTool->SetTarObjCamSepNoAxisCalib(m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib);
	m_pAlignerTool->SetTarObjCamSepAutoCalibTar(m_pPlatformInfo->m_bTarObjCamSepAutoCalibTar);
	m_pAlignerTool->SetTarAutoCalibAlignMode(optionInfo.m_eTarAutoCalibAlignMode);
	m_pAlignerTool->SetPlatformPick(m_pPlatformInfo->m_bPlatformPick);
	m_pAlignerTool->SetPickCamPlatformType(m_pPlatformInfo->m_ePickCamPlatformType);
	m_pAlignerTool->SetEnableMultiCalibExtension(m_pPlatformInfo->m_bEnableMultiCalibExtension);
	m_pAlignerTool->SetMultiCalibExtensionMaxNum(m_pPlatformInfo->m_nMultiCalibExtensionMaxNum);
	//	m_pAlignerTool->SetPlatformAlignTarCamWithDiffObjCam(m_pPlatformInfo->m_bTarCamWithDiffObjCam);
	m_pAlignerTool->SetMarkNum(nNum);
	m_pAlignerTool->SetCamNum(m_pPlatformInfo->m_nCamNum);

	m_pAlignerTool->m_bEnableKeyenceCode = m_pPlatformInfo->m_bEnableKeyenceCode;

	//lzk 0407
	m_pAlignerTool->SetEnablePositionVirtualMode(optionInfo.m_bEnableTargetAndObjectPositionVirtualMode);

	// 标定相关设置
	m_pAlignerTool->SetPlatformParam(m_pVisionASMConfig->m_pPlatformInfo);
	m_pAlignerTool->SetCamPlatformParam(m_pVisionASMConfig->m_pCamPlatformInfo);
	m_pAlignerTool->SetCalibrateChangeXYDDirection(optionInfo.m_bCalibrateChangeXDirection,optionInfo.m_bCalibrateChangeYDirection,optionInfo.m_bCalibrateChangeDDirection);
	//m_pAlignerTool->SetCalibSendAbsPos(optionInfo.m_bCalibSendAbsPos);
	m_pAlignerTool->SetCalibSendRelativePos(optionInfo.m_bCalibSendRelativePos);

	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
	if (pCalibData == NULL || !pCalibData->IsValid())
	{
		return FALSE;
	}
	m_pAlignerTool->SetHomographyDOF(pCalibData->GetCalibHomographyDOF());
	m_pAlignerTool->SetCalibParams(pCalibData->m_vpCalibrateParam);
	m_pAlignerTool->InitCalibratedInfos(pCalibData->m_vpCalibratedInfo);
	m_pAlignerTool->SetProductCalibratedInfo(pCalibData->m_vpCalibratedInfo);
	LoadCalibMoveImagePosInfo();


	// 对位相关设置（根据当前产品信息设置） 
	CProductData *pProduct = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nProductIndex);
	if (pProduct == NULL || !pProduct->IsValid())
	{
		return FALSE;
	}


	m_pAlignerTool->SetProductAlignerParam(*(pProduct->m_pAlignerParam)); 
	//	m_pAlignerTool->SetProductCalibratedInfo(pProduct->m_vpCalibratedInfo);

	if (!SetCameraShutterByProduct(*pProduct))
	{
		return FALSE;
	}

	// Bug修复：产品切换新产品时,新产品初始化时,对象目标拍照成功失败状态内存中未清理，
	// 而LoadTargetPosInfo，LoadObjectPosInfo也未进行返回判定，导致新产品对象目标拍照成功失败状态为之前产品的状态,存在此时不拍照直接对位导致偏位风险
	{
		// 将各位置对象目标状态设置为默认；

		//SetDefaultObjectSearchMarkPos(FALSE);
		//SetDefaultTargetSearchMarkPos(FALSE);

		for (int it=0;it<m_mpObjectMarkImagePos.m_vbOK.size();it++)
		{
			m_mpObjectMarkImagePos.m_vbOK.at(it) = FALSE;
		}

		for (int it=0;it<m_mpTargetMarkImagePos.m_vbOK.size();it++)
		{
			m_mpTargetMarkImagePos.m_vbOK.at(it) = FALSE;
		}


		for (int it=0;it<m_vmpObjectMarkImagePos_MultiEX.size();it++)
		{
			m_vmpObjectMarkImagePos_MultiEX.at(it) = m_mpObjectMarkImagePos;
		}
		for (int it=0;it<m_vmpTargetMarkImagePosMultiEx.size();it++)
		{
			m_vmpTargetMarkImagePosMultiEx.at(it) = m_mpTargetMarkImagePos;
		}
	}


	//if (!m_bObjectAndTargetPosInited)
	{
		LoadTargetPosInfo(nProductIndex);
		LoadObjectPosInfo(nProductIndex);
		//m_bObjectAndTargetPosInited = TRUE;
	}
	vector<CPlatformAxisPos*> tmpObjectPlatformAxisPos;
	vector<CPlatformAxisPos*> tmpTargetPlatformAxisPos;
	tmpObjectPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);
	tmpTargetPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);

	if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
	{
		for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
		{
			tmpObjectPlatformAxisPos.at(jt) = m_vvpObjectPlatformAxisPosMultiEx.at(0).at(jt);
			tmpTargetPlatformAxisPos.at(jt) = m_vvpTargetPlatformAxisPosMultiEx.at(0).at(jt);
		}

		m_mpObjectMarkImagePos = m_vmpObjectMarkImagePos_MultiEX.at(0);
		m_mpTargetMarkImagePos = m_vmpTargetMarkImagePosMultiEx.at(0);
	}
	else
	{
		tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
		tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
	}

	m_pAlignerTool->SetTargetPlatformPos(tmpTargetPlatformAxisPos);
	m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

	m_pAlignerTool->SetObjectPlatformPos(tmpObjectPlatformAxisPos);
	m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

	m_pAlignerTool->SetObjectCameraPos(m_vpObjectCamAxisPos);
	m_pAlignerTool->SetTargetCameraPos(m_vpTargetCamAxisPos);

	m_pAlignerTool->SetTargetCamAxisPlatformAxisPos(m_vpTargetCamAxisPlatformAxisPos);
	m_pAlignerTool->SetObjectCamAxisPlatformAxisPos(m_vpObjectCamAxisPlatformAxisPos);
	m_pAlignerTool->SetObjectCamAxisPos_MultiEx(m_vvpObjectCamAxisPosMultiEx);
	m_pAlignerTool->SetTargetCamAxisPos_MultiEx(m_vvpTargetCamAxisPosMultiEx);

	m_pAlignerTool->SetObjectCamAxisPlatformAxisPos_MultiEx(m_vvpObjectCamAxisPlatformAxisPosMultiEx);
	m_pAlignerTool->SetTargetCamAxisPlatformAxisPos_MultiEx(m_vvpTargetCamAxisPlatformAxisPosMultiEx);

	m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
	m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();

	// 	CString StrTmp = _T("");
	// 
	// 	if ((NULL !=m_pVisionASMConfig))
	// 	{
	// 		if (sysPlatformInfo.m_bProductFaChd)
	// 		{
	// 			int nCurProductIndexFa;
	// 			int nCurProductIndexCh;
	// 			m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
	// 			StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_"),sysPlatformInfo.m_nPlatformIndex+1,
	// 				nCurProductIndexFa+1,nCurProductIndexCh+1);
	// 		}
	// 		else
	// 		{
	// 			StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_"),sysPlatformInfo.m_nPlatformIndex+1,
	// 				m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
	// 		}
	// 		
	// 	}
	// 	m_pAlignerTool->strRecordFileFullPathLog = StrTmp;

	// 	SetAllGuiAlnTargetImageMarkPos();
	// 	SetAllGuiAlnObjectImageMarkPos();
	// 	SetAllGuiAlnInspectImageMarkPos();
	// 	SetAllGuiAlnExtraPos();
	// 	SetAllGuiAlnExtraLine();
	// 	SetAllGuiAlnExtraLineSeg();
	// 	SetAllGuiAlnExtraRect();
	// 	SetAllGuiAlnExtraAfffineRect();
	// 	SetAllGuiAlnExtraCircle();
	// 	SetAllGuiAlnExtraText();
	// 	SetAllGuiAlnExtraConstText();
	// 
	// 	SetAllGuiAlnTargetLineImageMarkPos();
	// 	SetAllGuiAlnObjectLineImageMarkPos();
	// 
	// 	SetAllShowGuiTargetImageMarkPos();
	// 	SetAllShowGuiObjectImageMarkPos();


	m_cVisionAlignGui.SetAllPosSearchResult(eObjectSearch);
	m_cVisionAlignGui.SetAllPosSearchResult(eTargetSearch);


	return TRUE;
}	




// 将这三个参数设置到m_pVisionASMConfig中对位的对应成员中（与主界面交互）
// void vcXYDVisionAlign::SetCalibrateToolParam(CPlatformInfo* pPlatformInfo, CCamPlatformInfo* pCamPlatformInfo, CCalibrateParam* sysCalibParam)
// {
// 	if ((NULL == pPlatformInfo) || (NULL == pCamPlatformInfo) || (NULL == sysCalibParam) || (NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
// 	{
// 		return;
// 	}
// 
// 	// 设置平台参数
// 	CPlatformXYDInfo* pPlatformXYDInfo = NULL;
// 	if (pPlatformInfo != m_pVisionASMConfig->m_pPlatformInfo )
// 	{
// 		DeletePlatformInfo();    
// 		pPlatformXYDInfo = new CPlatformXYDInfo;
// 	}
// 	else
// 	{
// 		pPlatformXYDInfo = (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo;
// 	} 
// 
// 	CPlatformXYDInfo* pPlatformXYDInfoInput = (CPlatformXYDInfo*)pPlatformInfo; 
// 
// 	pPlatformXYDInfo->m_nPlatformXCoordType = pPlatformXYDInfoInput->m_nPlatformXCoordType;
// 	pPlatformXYDInfo->m_nPlatformYCoordType = pPlatformXYDInfoInput->m_nPlatformYCoordType;
// 	pPlatformXYDInfo->m_nPlatformDCoordType = pPlatformXYDInfoInput->m_nPlatformDCoordType;
// 	pPlatformXYDInfo->m_nPlatformDDriveType = pPlatformXYDInfoInput->m_nPlatformDDriveType;
// 	pPlatformXYDInfo->m_nPlatformDDriveLineType = pPlatformXYDInfoInput->m_nPlatformDDriveLineType;
// 	pPlatformXYDInfo->m_dPlatformRotationLength = pPlatformXYDInfoInput->m_dPlatformRotationLength;
// 
// 	m_pVisionASMConfig->m_pPlatformInfo = pPlatformXYDInfo;
// 
// 	// 设置相机平台参数
// 	if (m_pPlatformInfo->m_eCamPlatformType!=pCamPlatformInfo->GetCamPlatformType())
// 	{
// 		return;
// 	}
// 
// 	CCamPlatformInfo* pCamPlatformInfoNew = NULL;
// 	if (pCamPlatformInfo!=m_pVisionASMConfig->m_pCamPlatformInfo)
// 	{
// 		DeleteCameraPlatformInfo();
// 		pCamPlatformInfoNew = new CCamPlatformInfo;
// 	}
// 	else
// 	{
// 		pCamPlatformInfoNew = m_pVisionASMConfig->m_pCamPlatformInfo;
// 	}
// 
// 	pCamPlatformInfoNew->SetCamNumPlatformType(pCamPlatformInfo->GetCamNum(), pCamPlatformInfo->GetCamPlatformType());
// 
// 	switch (pCamPlatformInfo->GetCamPlatformType())
// 	{
// 	case eCamPlatformSepFix:
// 		{
// 			break;
// 		}
// 		break;
// 	case eCamPlatformSepX:
// 		{
// 			for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
// 			{
// 				pCamPlatformInfoNew->SetCamDirectX(i, pCamPlatformInfo->GetCamDirectX(i));
// 			}
// 		}
// 		break;
// 	case eCamPlatformSepXY:
// 		{
// 			for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
// 			{
// 				pCamPlatformInfoNew->SetCamDirectX(i, pCamPlatformInfo->GetCamDirectX(i));
// 				pCamPlatformInfoNew->SetCamDirectY(i, pCamPlatformInfo->GetCamDirectY(i));
// 			}
// 		}
// 		break;
// 	case eCamPlatformShareX:	
// 		break;
// 	default:
// 		{
// 			return;
// 		}
// 		break;
// 	}
// 
// 	m_pVisionASMConfig->m_pCamPlatformInfo = pCamPlatformInfoNew;
// 
// 
// 	// 设置标定参数
// 	int nNum = m_pPlatformInfo->m_nCamNum;
// 	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;
// 	nNum = m_pPlatformInfo->m_nPositionNum;
// 
// 	if (nNum!=sysCalibParam->m_nCalibPatternNum)
// 	{
// 		return;
// 	}
// 
// 	CCalibrateParam calibrateParam;
// 
// 	calibrateParam.m_nCalibPatternNum = sysCalibParam->m_nCalibPatternNum;
// 
// 	for (int i=0; i<nNum; i++)
// 	{
// 		calibrateParam.m_vstrCalibPatternIDS.push_back(sysCalibParam->m_vstrCalibPatternIDS[i]);
// 	}
// 
// 	calibrateParam.m_dPlatformCalibMovement = sysCalibParam->m_dPlatformCalibMovement;
// 	calibrateParam.m_dCameraCalibMovement = sysCalibParam->m_dCameraCalibMovement;	
// 
// 	m_pVisionASMConfig->m_CalibrateParam = calibrateParam;
// 
// 	calibrateParam.m_dTileX = sysCalibParam->m_dTileX;
// 	calibrateParam.m_dTileY = sysCalibParam->m_dTileY;
// 	calibrateParam.m_bOutPoints = sysCalibParam->m_bOutPoints;
// 	calibrateParam.m_iThre = sysCalibParam->m_iThre;
// 	calibrateParam.m_nEnableDisCor = sysCalibParam->m_nEnableDisCor;
// 	calibrateParam.m_eCalibMarkPatternMode = sysCalibParam->m_eCalibMarkPatternMode;
// 
// 	// 并将设置好的数据传送给对位工具m_pAlignerTool
// 	if (NULL == m_pAlignerTool)
// 	{
// 		return;
// 	}    
// 
// 	// 标定相关设置（平台信息、相机平台相机、标定参数）
// 	m_pAlignerTool->SetPlatformParam(m_pVisionASMConfig->m_pPlatformInfo);
// 	m_pAlignerTool->SetCamPlatformParam(m_pVisionASMConfig->m_pCamPlatformInfo);
// 	m_pAlignerTool->SetCalibParam(&m_pVisionASMConfig->m_CalibrateParam);
// 
// }

// 获取m_pVisionASMConfig中对位的对应成员（与主界面交互）								
// void vcXYDVisionAlign::GetCalibrateToolParam(CPlatformInfo** ppPlatformInfo, CCamPlatformInfo** ppCamPlatformInfo, CCalibrateParam** ppCalibParam)
// {
// 	if (NULL == m_pVisionASMConfig)
// 	{
// 		return;
// 	}
// 
// 	*ppPlatformInfo    = m_pVisionASMConfig->m_pPlatformInfo;
// 	*ppCamPlatformInfo = m_pVisionASMConfig->m_pCamPlatformInfo;
// 	*ppCalibParam	   = &m_pVisionASMConfig->m_CalibrateParam;
// }

// 将这三个参数设置到m_pVisionASMConfig中对位的对应成员中（与主界面交互）
// void vcXYDVisionAlign::SetCalibrateToolParam(CPlatformInfo* pPlatformInfo, CCamPlatformInfo* pCamPlatformInfo)
// {
// 	if ((NULL == pPlatformInfo) || (NULL == pCamPlatformInfo) || (NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo))
// 	{
// 		return;
// 	}
// 
// 	// 设置平台参数
// 	CPlatformXYDInfo* pPlatformXYDInfo = NULL;
// 	if (pPlatformInfo != m_pVisionASMConfig->m_pPlatformInfo )
// 	{
// 		DeletePlatformInfo();    
// 		pPlatformXYDInfo = new CPlatformXYDInfo;
// 	}
// 	else
// 	{
// 		pPlatformXYDInfo = (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo;
// 	} 
// 
// 	CPlatformXYDInfo* pPlatformXYDInfoInput = (CPlatformXYDInfo*)pPlatformInfo; 
// 
// 	pPlatformXYDInfo->m_nPlatformXCoordType = pPlatformXYDInfoInput->m_nPlatformXCoordType;
// 	pPlatformXYDInfo->m_nPlatformYCoordType = pPlatformXYDInfoInput->m_nPlatformYCoordType;
// 	pPlatformXYDInfo->m_nPlatformDCoordType = pPlatformXYDInfoInput->m_nPlatformDCoordType;
// 	pPlatformXYDInfo->m_nPlatformDDriveType = pPlatformXYDInfoInput->m_nPlatformDDriveType;
// 	pPlatformXYDInfo->m_nPlatformDDriveLineType = pPlatformXYDInfoInput->m_nPlatformDDriveLineType;
// 	pPlatformXYDInfo->m_dPlatformRotationLength = pPlatformXYDInfoInput->m_dPlatformRotationLength;
// 
// 	m_pVisionASMConfig->m_pPlatformInfo = pPlatformXYDInfo;
// 
// 	// 设置相机平台参数
// 	if (m_pPlatformInfo->m_eCamPlatformType!=pCamPlatformInfo->GetCamPlatformType())
// 	{
// 		return;
// 	}
// 
// 	CCamPlatformInfo* pCamPlatformInfoNew = NULL;
// 	if (pCamPlatformInfo!=m_pVisionASMConfig->m_pCamPlatformInfo)
// 	{
// 		DeleteCameraPlatformInfo();
// 		pCamPlatformInfoNew = new CCamPlatformInfo;
// 	}
// 	else
// 	{
// 		pCamPlatformInfoNew = m_pVisionASMConfig->m_pCamPlatformInfo;
// 	}
// 
// 	pCamPlatformInfoNew->SetCamNumPlatformType(pCamPlatformInfo->GetCamNum(), pCamPlatformInfo->GetCamPlatformType());
// 
// 	switch (pCamPlatformInfo->GetCamPlatformType())
// 	{
// 	case eCamPlatformSepFix:
// 		{
// 			break;
// 		}
// 		break;
// 	case eCamPlatformSepX:
// 		{
// 			for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
// 			{
// 				pCamPlatformInfoNew->SetCamDirectX(i, pCamPlatformInfo->GetCamDirectX(i));
// 			}
// 		}
// 		break;
// 	case eCamPlatformSepXY:
// 		{
// 			for (int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
// 			{
// 				pCamPlatformInfoNew->SetCamDirectX(i, pCamPlatformInfo->GetCamDirectX(i));
// 				pCamPlatformInfoNew->SetCamDirectY(i, pCamPlatformInfo->GetCamDirectY(i));
// 			}
// 		}
// 		break;
// 	case eCamPlatformShareX:	
// 		break;
// 	default:
// 		{
// 			return;
// 		}
// 		break;
// 	}
// 
// 	m_pVisionASMConfig->m_pCamPlatformInfo = pCamPlatformInfoNew;
// 
// 
// 	// 并将设置好的数据传送给对位工具m_pAlignerTool
// 	if (NULL == m_pAlignerTool)
// 	{
// 		return;
// 	}    
// 
// 	// 标定相关设置（平台信息、相机平台相机、标定参数）
// 	m_pAlignerTool->SetPlatformParam(m_pVisionASMConfig->m_pPlatformInfo);
// 	m_pAlignerTool->SetCamPlatformParam(m_pVisionASMConfig->m_pCamPlatformInfo);
// 
// }

// 获取m_pVisionASMConfig中对位的对应成员（与主界面交互）								
// void vcXYDVisionAlign::GetCalibrateToolParam(CPlatformInfo** ppPlatformInfo, CCamPlatformInfo** ppCamPlatformInfo)
// {
// 	if (NULL == m_pVisionASMConfig)
// 	{
// 		return;
// 	}
// 
// 	*ppPlatformInfo    = m_pVisionASMConfig->m_pPlatformInfo;
// 	*ppCamPlatformInfo = m_pVisionASMConfig->m_pCamPlatformInfo;
// }

// 平台标定求精（nIndex为相机索引值）
BOOL vcXYDVisionAlign::ExcutePlatformCalibrateRefine( int nCalibPos )
{
	CString strTempWarningType = _T("");
	CString strCmd = _T("");
	GetCommCommandName(strCmd);
	if (!CheckAlignerSearchTool(strCmd)/*NULL == m_pAlignerTool*/)
	{
		return FALSE;
	}

	int nRemCalibPos = nCalibPos%m_pPlatformInfo->m_nPositionNum;

	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
	vpPlatformAxisPos = m_pAlignerTool->GetCalibPlatformRefineMovePos(nCalibPos);

	if (vpPlatformAxisPos.size() != 3)
	{
		return FALSE;
	}
	else
	{
		// 记录平台标定时平台需移动的3个位置各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);

			CPlatformXYDAxisPos* pAxisPos;
			for (int i=0; i<vpPlatformAxisPos.size(); i++)
			{
				strTemp.Empty();
				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           

				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
				strInfo = strInfo + strTemp;
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);


			strInfo.Empty();
			strTemp.Empty();
			strTemp.Format(_T("......标定求精三个轴位置:\n"));
			strInfo += strTemp;
			for (int i=0; i<vpPlatformAxisPos.size(); i++)
			{
				strTemp.Empty();
				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           

				strTemp.Format(_T("......位置%d: X轴:%.2f; Y轴:%.2f; D轴:%.2f;\n"), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
				strInfo = strInfo + strTemp;
			}

			VisionAlignLogRecord(m_strCalibrateProcessPath1,strInfo,FALSE);

		}
	}



	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
	if (pCalibData == NULL || !pCalibData->IsValid())
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
	if (pCalibrateParam == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	// 3. 驱动平台到位并定位
	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	CMarkImagePos* pMarkImagePos = NULL;
	CMarkImagePos* pDisCorMarkImagePos = NULL;
	std::vector<CMarkImagePos*> vpMarkImagePos;

	int k=0;
	for (k=0; k<3; k++)
	{         
		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		pMarkImagePos = NULL;
		pDisCorMarkImagePos = NULL;

		// 驱动到位
		pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);

		if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
		{
			ReportCalibResult(FALSE);

			OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);
			return FALSE;
		}


		Sleep(500);
		// 将相机移动到多个位置，逐个定位
		pMarkImagePos = new CMarkImagePos;
		pMarkImagePos->SetMarkImagePosNum(1);

		pDisCorMarkImagePos = new CMarkImagePos;
		pDisCorMarkImagePos->SetMarkImagePosNum(1);

		// 等待搜索延时
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nRemCalibPos);		// nCalibPos	
		vsmSearchMode.push_back(eCalibSearch);	// 标定搜索

		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{
			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}

			return OnFailedSnapSearchImage(strCmd);
		}

		// 定位
		m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
		m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;
		BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

		// 分析定位结果，发送指令响应
		if (FALSE == bSearchSucceed)
		{
			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			}

			if(pDisCorMarkImagePos != NULL)
			{
				delete pDisCorMarkImagePos;
				pDisCorMarkImagePos = NULL;
			}

			for (int p=0; p<vpMarkImagePos.size(); p++)
			{
				if (vpMarkImagePos.at(p))
				{
					delete vpMarkImagePos.at(p);
					vpMarkImagePos.at(p) = NULL;
				}
			}  

			return OnFailedCalibSearch(strCmd, k, nRemCalibPos);
		}

		if(pCalibrateParam->m_nEnableDisCor)
		{
			CCoordPos OutPutPoint;
			m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
			pDisCorMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
		}

		// 保存定位结果		
		pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	

		if(pCalibrateParam->m_nEnableDisCor)
		{
			CMarkImagePos * markpos = new CMarkImagePos(*pDisCorMarkImagePos);
			vpMarkImagePos.push_back(markpos); 
		}
		else
		{
			CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
			vpMarkImagePos.push_back(markpos);
		} 

		// 记录图像搜索数据
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp = _T("");
			CString strOut;
			CCoordPos cp;
			strOut = strTemp + _T("CalibSearch: ");		
			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = pMarkImagePos->GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

				strOut += strTemp;
			}

			if(pCalibrateParam->m_nEnableDisCor)
			{
				for (int i=0; i<pDisCorMarkImagePos->GetMarkImagePosNum(); i++)
				{
					strTemp = _T("");
					cp = pDisCorMarkImagePos->GetMarkImagePos(i);

					strTemp.Format(_T("DisCorMarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

					strOut += strTemp;
				}
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}	

		if (pMarkImagePos!=NULL)
		{
			delete pMarkImagePos;
			pMarkImagePos = NULL;
		}  

		if(pDisCorMarkImagePos != NULL)
		{
			delete pDisCorMarkImagePos;
			pDisCorMarkImagePos = NULL;
		}
	}

	if (pMarkImagePos!=NULL)
	{
		delete pMarkImagePos;
		pMarkImagePos = NULL;
	}     

	if(pDisCorMarkImagePos != NULL)
	{
		delete pDisCorMarkImagePos;
		pDisCorMarkImagePos = NULL;
	}

	// 4. 将平台3个位置的所有图像搜索结果，设置入对位工具

	m_pAlignerTool->SetCalibPlatformRefineMoveSearchResult(vpMarkImagePos);
	if(FALSE == m_pAlignerTool->ExecuteCalibratePlatformRefine(nCalibPos))
	{	
		for (k=0; k<vpMarkImagePos.size(); k++)
		{
			if (vpMarkImagePos.at(k))
			{
				delete vpMarkImagePos.at(k);
				vpMarkImagePos.at(k) = NULL;
			}
		} 

		//		SaveCurAllCameraChannelSearchImg();		
		return FALSE;
	}


	// 求精记录
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{	
		CString strInfo;
		CString strTemp;

		strTemp.Empty();
		strInfo.Empty();
		strTemp.Format(_T("......平台求精时图像坐标:\n"));
		strInfo += strTemp;
		CCoordPos cp;
		for (int i=0; i<vpMarkImagePos.size(); i++)
		{
			strTemp = _T("");
			cp = vpMarkImagePos.at(i)->GetMarkImagePos(0);

			strTemp.Format(_T("......MarkPos%d: X: %.2f; Y: %.2f; D: %.3f;\n"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

			strInfo += strTemp;
		}

		VisionAlignLogRecord(m_strCalibrateProcessPath1,strInfo,FALSE);
	}




	// 5. 释放内存
	for (k=0; k<vpMarkImagePos.size(); k++)
	{
		if (vpMarkImagePos.at(k))
		{
			delete vpMarkImagePos.at(k);
			vpMarkImagePos.at(k) = NULL;
		}
	}   

	return TRUE;

}				

BOOL vcXYDVisionAlign::ExecuteTargetBenchMarkFixed()
{
	if (FALSE == m_bValidComm || NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig || NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	if (FALSE == m_pPlatformInfo->m_bBenchMarkAmend)
	{
		return FALSE;
	}

	if (m_CalibPlatformAxisAbsPos.size()!=2)
	{
		return FALSE;
	}

	std::vector<CCoordPos> BenchTargetMarkPos;
	BenchTargetMarkPos.resize(2);

	CCoordPos pos;

	pos.m_dPosX=m_vImageInput.at(0).Width()/2;
	pos.m_dPosY=m_vImageInput.at(0).Height()/2;

	BenchTargetMarkPos.at(0)=pos;
	BenchTargetMarkPos.at(1)=pos;

	// 3. 将基准修正点的图像坐标、平台及相机平台的绝对位置设置入对位工具，进行目标Mark修正计算 
	std::vector<CPlatformAxisPos*> vpPlatformPos;
	for (int p=0; p<m_CalibPlatformAxisAbsPos.size(); p++)
	{
		vpPlatformPos.push_back(&m_CalibPlatformAxisAbsPos.at(p));
		// 		CString str;
		// 		str.Format("CalibPlatformAxis%d X=%f,Y=%f,D=%f",p,m_CalibPlatformAxisAbsPos.at(p).m_dPosX,m_CalibPlatformAxisAbsPos.at(p).m_dPosY,m_CalibPlatformAxisAbsPos.at(p).m_dAngle);
		// 		AlignLogRecord(str);
	}
	CBenchTargetMarkFixInfo* pBenchTargetMarkFixInfo = m_pAlignerTool->ExacuteBenchMarkFix(BenchTargetMarkPos, vpPlatformPos);

	// 4. 保存修正结果到当前产品及配置文件中
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		// 释放内存
		return FALSE;
	}


	CProductData curProduct = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);   

	curProduct.m_pAlignerParam->SetBenchTargetMarkFixInfo(pBenchTargetMarkFixInfo);
	m_pVisionASMConfig->m_TotalProductData.SetItem(nCurProductIndex, curProduct);
	SaveProductDataInfo(nCurProductIndex);

	// 释放内存


	return TRUE;

}

// 执行基准目标Mark修正 
BOOL vcXYDVisionAlign::ExecuteBenchMarkFixed( std::vector<CCoordPos> vPtMarkImageBench )
{
	if (FALSE == m_bValidComm || NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig || NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	if (FALSE == m_pPlatformInfo->m_bBenchMarkAmend)
	{
		return FALSE;
	} 

	// 注：单相机对位系统，暂时不支持基准Mark修正
	if (1 == m_pPlatformInfo->m_nCamNum) 
		return FALSE;


	// 1. 通信获取当前平台各个轴的绝对位置
	int i = 0;
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}    

	// 2. 通信获取当前个各相机平台所在的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{
		pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
		vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);      
	}	

	if ((m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX))
	{		
		if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos))
		{			
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_CAM_PLATFORM_POS_FAILED));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


			// 释放内存
			if (pPlatformAxisPos!=NULL)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;					
			}

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}	

	}    

	// 3. 将基准修正点的图像坐标、平台及相机平台的绝对位置设置入对位工具，进行目标Mark修正计算 
	std::vector<CPlatformAxisPos*> vpPlatformPos;
	for (int p=0; p<vpCamPlatformXYAxisPos.size(); p++)
	{
		vpPlatformPos.push_back((CPlatformAxisPos*)vpCamPlatformXYAxisPos.at(p));
	}
	CBenchTargetMarkFixInfo* pBenchTargetMarkFixInfo = m_pAlignerTool->ExacuteBenchMarkFix(vPtMarkImageBench, pPlatformAxisPos, vpPlatformPos);

	// 4. 保存修正结果到当前产品及配置文件中
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		// 释放内存
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			if (vpCamPlatformXYAxisPos.at(i)!=NULL)
			{
				delete vpCamPlatformXYAxisPos.at(i);
				vpCamPlatformXYAxisPos.at(i) = NULL;
			}
		}

		return FALSE;
	}


	CProductData curProduct = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);   

	curProduct.m_pAlignerParam->SetBenchTargetMarkFixInfo(pBenchTargetMarkFixInfo);
	m_pVisionASMConfig->m_TotalProductData.SetItem(nCurProductIndex, curProduct);
	SaveProductDataInfo(nCurProductIndex);

	// 释放内存
	if (pPlatformAxisPos!=NULL)
	{ 
		delete pPlatformAxisPos;
		pPlatformAxisPos = NULL;					
	}

	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	{
		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
		{
			delete vpCamPlatformXYAxisPos.at(i);
			vpCamPlatformXYAxisPos.at(i) = NULL;
		}
	}	

	return TRUE;
}						

//////////////////////////////////////////////////////////////////////////
// 对位工具：对位
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// 平台工作线程
// 创建平台工作线程
BOOL vcXYDVisionAlign::CreateWorkThread()
{
	int nfortest = 1;
	auto ff = nfortest;
	//vector<int> Fortest{1,2,3};
	// 创建工作线程
	m_bExitWorkThreaded = FALSE;
	m_bExitWorkThread = FALSE;
	m_pWorkThread = NULL;

	if(m_pPlatformInfo->m_bEnableKeyenceCode)
	{
		m_pWorkThread = AfxBeginThread(WorkThreadEx,                     // 平台工作线程执行函数
			this,                         // 传入线程的参数
			THREAD_PRIORITY_NORMAL,             // 线程的优先级,一般设置为 0 .让它和主线程具有共同的优先级
			0,                           // 指定新创建的线程的栈的大小.如果为 0,新创建的线程具有和主线程一样的大小的栈 
			CREATE_SUSPENDED,                 // CREATE_SUSPENDED : 线程创建以后,会处于挂起状态,直到调用:ResumeThread；0：线程创建后立即运行
			NULL                          // 指向一个 SECURITY_ATTRIBUTES 的结构体,用它来标志新创建线程的安全性.如果为 NULL，那么新创建的线程就具有和主线程一样的安全性
			);	
	}
	else
	{
		m_pWorkThread = AfxBeginThread(WorkThread,                     // 平台工作线程执行函数
			this,                         // 传入线程的参数
			THREAD_PRIORITY_NORMAL,             // 线程的优先级,一般设置为 0 .让它和主线程具有共同的优先级
			0,                           // 指定新创建的线程的栈的大小.如果为 0,新创建的线程具有和主线程一样的大小的栈 
			CREATE_SUSPENDED,                 // CREATE_SUSPENDED : 线程创建以后,会处于挂起状态,直到调用:ResumeThread；0：线程创建后立即运行
			NULL                          // 指向一个 SECURITY_ATTRIBUTES 的结构体,用它来标志新创建线程的安全性.如果为 NULL，那么新创建的线程就具有和主线程一样的安全性
			);	
	}


	// 创建手动搜索线程
	m_bExitManualSearchThread = FALSE;
	m_pManualSearchThread = NULL;
	m_pManualSearchThread = AfxBeginThread(ManualSearchThread, this);	

	BOOL		bExitSearchThread;  // 搜素结果线程是否退出
	CWinThread*	pSearchThread;  
	for(int i = 0; i < m_vpSearchObject.size(); i++)
	{
		bExitSearchThread = FALSE;  
		pSearchThread = NULL;  
		pSearchThread = AfxBeginThread(SearchThread,  // 平台工作线程执行函数
			m_vpSearchObject[i],                      // 传入线程的参数
			THREAD_PRIORITY_NORMAL,          // 线程的优先级,一般设置为 0 .让它和主线程具有共同的优先级
			0,                        // 指定新创建的线程的栈的大小.如果为 0,新创建的线程具有和主线程一样的大小的栈 
			CREATE_SUSPENDED,              // CREATE_SUSPENDED : 线程创建以后,会处于挂起状态,直到调用:ResumeThread；0：线程创建后立即运行
			NULL                        // 指向一个 SECURITY_ATTRIBUTES 的结构体,用它来标志新创建线程的安全性.如果为 NULL，那么新创建的线程就具有和主线程一样的安全性
			);

		//m_vbExitSearchThread.push_back(bExitSearchThread);
		m_vpSearchThread.push_back(pSearchThread);

		if (NULL == pSearchThread)
		{
			return FALSE;
		}
	}


	// 存图线程
	for (int i = 0; i < m_vpSaveImageObject.size(); i++)
	{
		CWinThread* pSearchThread =  AfxBeginThread(SaveImageThread, 
			m_vpSaveImageObject[i], 
			THREAD_PRIORITY_NORMAL,          // 线程的优先级,一般设置为 0 .让它和主线程具有共同的优先级
			0,                        // 指定新创建的线程的栈的大小.如果为 0,新创建的线程具有和主线程一样的大小的栈 
			CREATE_SUSPENDED,              // CREATE_SUSPENDED : 线程创建以后,会处于挂起状态,直到调用:ResumeThread；0：线程创建后立即运行
			NULL                  
			);

		m_vpSaveImageThread.push_back(pSearchThread);
		if (NULL == pSearchThread)
		{
			return FALSE;
		}
	}


	// 曝光线程
	BOOL		bExitCameraExposureThread;
	CWinThread*	pCameraExposureThread;  
	for(int i = 0; i < m_vpCameraExposureObject.size(); i++)
	{
		bExitCameraExposureThread = FALSE;  
		pCameraExposureThread = NULL;  
		pCameraExposureThread = AfxBeginThread(CameraExposureThread,  // 平台工作线程执行函数
			m_vpCameraExposureObject[i],     // 传入线程的参数
			THREAD_PRIORITY_NORMAL,          // 线程的优先级,一般设置为 0 .让它和主线程具有共同的优先级
			0,								 // 指定新创建的线程的栈的大小.如果为 0,新创建的线程具有和主线程一样的大小的栈 
			CREATE_SUSPENDED,				 // CREATE_SUSPENDED : 线程创建以后,会处于挂起状态,直到调用:ResumeThread；0：线程创建后立即运行
			NULL							 // 指向一个 SECURITY_ATTRIBUTES 的结构体,用它来标志新创建线程的安全性.如果为 NULL，那么新创建的线程就具有和主线程一样的安全性
			);

		//m_vbExitCameraExposureThread.push_back(bExitCameraExposureThread);
		m_vpCameraExposureThread.push_back(pCameraExposureThread);

		if (NULL == pCameraExposureThread)
		{
			return FALSE;
		}
	}

	// 创建检查删除文件夹路径线程
	m_bExitCheckRemoveFolderThread = FALSE;
	m_pCheckRemoveFolderThread = NULL;

	m_pCheckRemoveFolderThread = AfxBeginThread(CheckRemoveFolderThread, this);
	m_bCheckRemoveFolderThreadSuspend = FALSE;
	// 如果不启用按时刻存图和文件，初始化时挂起删除文件夹线程
	if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
	{
		// 挂起删除文件夹线程
		if (m_bCheckRemoveFolderThreadSuspend == FALSE)
		{
			m_pCheckRemoveFolderThread->SuspendThread();
			m_bCheckRemoveFolderThreadSuspend = TRUE;
		}

	}


	//光源切换使用线程
	for (int i = 0; i < MAXLightControl; i++)
	{
		CWinThread* pLightCtrlThread =  AfxBeginThread(LightCtrlThread, 
			m_vpLightCtrlObject[i], 
			THREAD_PRIORITY_NORMAL,          // 线程的优先级,一般设置为 0 .让它和主线程具有共同的优先级
			0,                        // 指定新创建的线程的栈的大小.如果为 0,新创建的线程具有和主线程一样的大小的栈 
			/*CREATE_SUSPENDED*/0,              // CREATE_SUSPENDED : 线程创建以后,会处于挂起状态,直到调用:ResumeThread；0：线程创建后立即运行
			NULL                  
			);

		m_vpLightCtrlThread.push_back(pLightCtrlThread);
		if (NULL == pLightCtrlThread)
		{
			return FALSE;
		}
	}

	return TRUE;

}	

// 工作线程
UINT vcXYDVisionAlign::WorkThread(LPVOID pParam)
{
	vcXYDVisionAlign* pOwner = (vcXYDVisionAlign*)pParam;

	CString strReceive;
	SysWorkCmdType sysWorkCmdType;

	std::vector<int> vnReceivedData;
	std::vector<int> nParam;
	std::vector<double> dParam;
	CString strInfo;
	BOOL bWrtWorkStatus = FALSE;

	BOOL bSpecialCommSuccess = FALSE;
	pOwner->m_bExitWorkThreaded = FALSE;
	Sleep(2000);
	CPlatformOptionInfo optionInfo;
	pOwner->GetPlatformOptionInfo(optionInfo);


	// 默认先获取
	BOOL bReLoadPlatformOptionInfo = TRUE;

	while (FALSE == pOwner->m_bExitWorkThread)
	{
		if (pOwner->m_bExitWorkThread)
			break; // 跳出while循环体


		vnReceivedData.clear();

		//pOwner->GetCameraNum();
		////VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		////VisionAlignLogRecord(m_strAlignProcessData, strOut);


		pOwner->m_bCurThreadWorkFinished = FALSE;
		if (pOwner->m_bIsExecuteFixTargetCheck || pOwner->m_bIsExecuteSizeCheck)  //执行标定关联验证过程时 避免PLC获取轴数据出现冲突
		{
			pOwner->m_bCurThreadWorkFinished = TRUE;
			Sleep(2);
			continue;
		}

		if (!pOwner->m_bSuspendWorkThread)
		{
			// 重新Load配置
			if (bReLoadPlatformOptionInfo)
			{
				bReLoadPlatformOptionInfo = FALSE;
				pOwner->GetPlatformOptionInfo(optionInfo);
			}

			if (pOwner->m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime)
			{
				CTime tCurrent = CTime::GetCurrentTime();
				if (tCurrent.GetYear()!=pOwner->m_nYear || tCurrent.GetMonth()!=pOwner->m_nMonth ||
					tCurrent.GetDay()!=pOwner->m_nDay || tCurrent.GetHour()!=pOwner->m_nHour)
				{
					pOwner->UpdateDataRecordTxtAddrTime();
				}

				pOwner->m_nYear = tCurrent.GetYear();
				pOwner->m_nMonth = tCurrent.GetMonth();
				pOwner->m_nDay = tCurrent.GetDay();
				pOwner->m_nHour = tCurrent.GetHour();
			}

			if (pOwner->m_bStopNow)
			{
				Sleep(2);
				continue;
			}

			bWrtWorkStatus = FALSE;


			if (pOwner->m_XYDCommProtocol.IsPlcProtocolType())	// 如果是PLC直接读取存储寄存器协议
			{
				pOwner->m_XYDCommProtocol.m_bCmdAxisPosReady = FALSE;//已获取指令中的轴位置标志复位
				pOwner->m_XYDCommProtocol.EnableReadWriteAxisPosWithCmd(pOwner->IsReadWriteAxisPosWithCmd());
				// 如果是共享的通信接口，共享源的通信comm
				if (eShareCommSrc == pOwner->GetShareCommType())
				{
					if (pOwner->IsShareCommPlatformParalle()		// 如果是并行的共享通信
						|| (!pOwner->IsShareCommPlatformParalle() && pOwner->IsShareCommCurPlatform())) // 如果是非并行的共享通信，且是得到通信令牌
					{
						if (pOwner->ReOpenComm())
						{
							if (TRUE == optionInfo.m_bVisionOnLineStatus)
							{
								pOwner->SendCommConnectStatus();
							}
						}
					}
				}
				else if (eShareCommNo == pOwner->GetShareCommType())
				{
					if (pOwner->ReOpenComm())
					{
						if (TRUE == optionInfo.m_bVisionOnLineStatus)
						{
							pOwner->SendCommConnectStatus();
						}
					}
				}

			}
			else
			{
				if (pOwner->ReOpenComm())
				{
					if (TRUE == optionInfo.m_bVisionOnLineStatus)
					{
						pOwner->SendCommConnectStatus();
					}
				}
			}


			BOOL bReceived = FALSE;

			// 查询通信接口收到的数据
			if (pOwner->m_XYDCommProtocol.IsPlcProtocolType())	// 如果是PLC直接读取存储寄存器协议
			{
				// 				pOwner->m_XYDCommProtocol.m_dstrTranlateResultInfo.clear();  //清空指令
				// 				bReceived = pOwner->ReceiveCommPlcReg(sysWorkCmdType);

				// 如果是共享的通信接口
				if (eShareCommNo != pOwner->GetShareCommType())
				{
					if (pOwner->IsShareCommPlatformParalle()
						||(!pOwner->IsShareCommPlatformParalle() && pOwner->IsShareCommCurPlatform()))	// 如果得到令牌
					{
						pOwner->m_XYDCommProtocol.m_dstrTranlateResultInfo.clear();  //清空指令
						bReceived = pOwner->ReceiveCommPlcReg(sysWorkCmdType);
						if (bReceived == FALSE)
						{
							//// 如果未收到触发指令，则交出令牌给下一个平台
							if (!pOwner->IsShareCommPlatformParalle())
							{
								pOwner->ShareCommNextPlatform();
							}

							Sleep(1);
							continue;
						}
						else
						{
							// 如果收到触发指令，则根据指令进行处理
						}
					}				
					else // 如果未得到令牌
					{
						Sleep(1);
						continue;
					}
				}
				else
				{					
					// 如果不是共享的通信接口
					pOwner->m_XYDCommProtocol.m_dstrTranlateResultInfo.clear();  //清空指令
					bReceived = pOwner->ReceiveCommPlcReg(sysWorkCmdType);

				}
			}
			else // 如果通用无协议
			{
				bReceived = pOwner->ReceiveCommInfo(strReceive);
			}

			if (pOwner->m_nManualSearchMarkMode != eNoSearch || pOwner->m_bExecuteProductManage == TRUE || pOwner->m_bIsSetShutterInMain)
			{
				Sleep(2);
				continue;
			}

			//Sleep(5000);
			if (bReceived)
			{
				pOwner->m_bCurThreadWorkFinished = FALSE;

				if (pOwner->m_XYDCommProtocol.IsPlcProtocolType())
				{
				}
				else
				{
					sysWorkCmdType = pOwner->m_XYDCommProtocol.AnalyzeSysWorkCmdReceived(strReceive);
				}

				SysPlatformInfo sysPlatformInfo;
				pOwner->GetSysPlatformInfo(sysPlatformInfo);
				//if (sysPlatformInfo.m_bExpireWarningEnabled)
				{
					//if (sysPlatformInfo.m_bUseSpecialComm)
					if (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_bUseSpecialComm)
					{
						if (!bSpecialCommSuccess) //通讯没有成功
						{

							if (eCmdSpecialCommFCHK == sysWorkCmdType)
							{
								int nRecNum = pOwner->m_XYDCommProtocol.m_FCHKParam.P1;
								if (nRecNum ==10)
								{
									bSpecialCommSuccess = TRUE;
									pOwner->SendCommResultFCHK();
								}
							}
							else // 握手未成功报警
							{
								CString strTmp =  GetSysInfoString(pOwner->m_psaSysInfoStrings, IDS_COMM_HAND_TO_HAND_FAILE);	//PLC握手通讯失败
								bool TmpStatusBar = FALSE;
								pOwner->SetStatusBarInfo(TmpStatusBar,strTmp,_T(""));
								pOwner->PostMessageUpdateStatusBarInfo();
								pOwner->AddWarningInfo(strTmp, strTmp);

							}
							Sleep(5);
							continue;
						}
					}


					if (!sysPlatformInfo.m_bRegisterSuccess) //如果没有注册，继续循环
					{
						Sleep(5);						
						continue;
					}
				}
				if (pOwner->m_bIsAutoCalibrating && (sysWorkCmdType != eCmdCalibrateFCBP))
				{
					pOwner->ShowAllGuiCalibrateGraphics(FALSE);
					pOwner->m_bIsAutoCalibrating = FALSE;
				}

				nParam.clear();
				dParam.clear();
				strInfo.Empty();
				switch (sysWorkCmdType)
				{
				case eCmdSetProductIndexFSPC:     //  FSPC：产品切换的设定，将产品切换至指定的产品No.
					{
						int nCurProductIndexFa = pOwner->m_XYDCommProtocol.m_FSPCParam.P1 -1; // 大品种索引，从1递增
						int nCurProductIndexChd = pOwner->m_XYDCommProtocol.m_FSPCParam.P2 - 1; // 小品种索引，从1递增
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSPCParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSPCParam.P2);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FSPCParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FSPCParam.m_strCmd, eCmdSetProductIndexFSPC);
						int nCurProductIndex = 0; // 全部品种索引
						if(sysPlatformInfo.m_bProductFaChd)
						{
							nCurProductIndex = pOwner->m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nCurProductIndexFa, nCurProductIndexChd);
						}
						else
						{
							nCurProductIndex = pOwner->m_XYDCommProtocol.m_FSPCParam.P1 - 1;
						}
						pOwner->OnlineSetProductIndex(nCurProductIndex);
					}
					break;	
					// 将指定产品No.保存到配置文件中
					//lzk 复制标定信息
				case eCmdCopyCalibrateInfoFCCI:    //  FCCI
					{
						int nCopiedCalibrateIndex = pOwner->m_XYDCommProtocol.m_FCCIParam.P1-1; 
						int nCopyToCalibrateIndex = pOwner->m_XYDCommProtocol.m_FCCIParam.P2-1; 
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCCIParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCCIParam.P2);

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCCIParam.m_strCmd,nParam,dParam);
						pOwner->OnlineCopyCalibrateInfo(nCopiedCalibrateIndex,nCopyToCalibrateIndex);
					}
					break;
					//lzk 0408  易天覆膜机-位置虚拟-指令交互
				case eCmdFVPC:                    //  FVPC
					{
						int nObjectPositionVirtualIndex = pOwner->m_XYDCommProtocol.m_FVPCParam.P1; 
						int nTargetPositionVirtualIndex = pOwner->m_XYDCommProtocol.m_FVPCParam.P2; 
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FVPCParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FVPCParam.P2);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FVPCParam.m_strCmd,nParam,dParam);

						//对参数进行限制
						if (nObjectPositionVirtualIndex<0 || nObjectPositionVirtualIndex>4)
						{
							nObjectPositionVirtualIndex = 0;
						}

						if (nTargetPositionVirtualIndex<0 || nTargetPositionVirtualIndex>4)
						{
							nTargetPositionVirtualIndex = 0;
						}

						pOwner->OnlineSetPositionVirtualIndex(nObjectPositionVirtualIndex,nTargetPositionVirtualIndex);
					}
					break;	
				case eCmdSaveProductIndexFSSV:     // FSSV：指定产品No.的保存，将目前使用的产品数据保存在指定的产品No.并保存在CF 记忆卡中
					{
						int nCurProductIndexFa = pOwner->m_XYDCommProtocol.m_FSSVParam.P1 - 1; // 大品种索引，从1递增
						int nCurProductIndexChd = pOwner->m_XYDCommProtocol.m_FSSVParam.P2 - 1; // 小品种索引，从1递增
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSSVParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSSVParam.P2);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FSSVParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FSSVParam.m_strCmd, eCmdSaveProductIndexFSSV);
						int nProductIndex = 0; // 全部品种索引
						if(sysPlatformInfo.m_bProductFaChd)
						{
							nProductIndex = pOwner->m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nCurProductIndexFa, nCurProductIndexChd);
						}
						else
						{
							nProductIndex = pOwner->m_XYDCommProtocol.m_FSSVParam.P1 - 1;
						}
						pOwner->OnlineSaveProductIndex(nProductIndex);
					}
					break;	
					// GSP: Get System Product
				case eCmdGetProductIndexFGSP:     // FGSP：产品No.的取得，即：取得目前正在执行的产品No.
					{	

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGSPParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGSPParam.m_strCmd, eCmdGetProductIndexFGSP);
						pOwner->OnlineGetProductIndex();
					}
					break;
				case eCmdSetProductVirtualAlnFVAS:     //  FSPC：产品虚拟Mark设置.
					{				   
						int nValnStatus = pOwner->m_XYDCommProtocol.m_FVASParam.P1;
						nParam.push_back(nValnStatus);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FVASParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FVASParam.m_strCmd, eCmdSetProductVirtualAlnFVAS);
						BOOL bValnStatus = FALSE;
						if (nValnStatus!=0)
						{
							bValnStatus = TRUE;
						}
						pOwner->OnlineSetProductVirtualAln(bValnStatus);
					}
					break;
				case eCmdGetAlignPrecisionFGAL:    // 1、FGAL:对准精度判定设定的取得，取得对准精度的判定设定
					{	
						// ０：对准精度判定取得 １：最终精度判定取得
						int nPrecisionType = pOwner->m_XYDCommProtocol.m_FGALParam.P1;
						nParam.push_back(nPrecisionType);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGALParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGALParam.m_strCmd, eCmdGetAlignPrecisionFGAL);
						pOwner->OnlineGetAlignPrecisionFGAL(nPrecisionType);
					}
					break;	
				case eCmdSetAlignPrecisionFALL:     // 2、FALL:对准精度判定的更新，更新对准时的对准精度的判定
					{	
						int nPrecisionType = pOwner->m_XYDCommProtocol.m_FALLParam.P1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FALLParam.P1);

						if (pOwner->m_XYDCommProtocol.m_FALLParam.m_nPType == 4)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALLParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALLParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALLParam.P4);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FALLParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FALLParam.m_strCmd, eCmdSetAlignPrecisionFALL);
						pOwner->OnlineSetAlignPrecisionFALL(nPrecisionType);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;				
					}
					break;	
				case eCmdGetAlignTimeFGAC:    // 3、FGAC:对准最多次数的取得，取得设定对准最多次数
					{	

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGACParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGACParam.m_strCmd, eCmdGetAlignTimeFGAC);
						pOwner->OnlineGetAlignTimeFGAC();
					}
					break;	
				case eCmdSetAlignTimeFALC:     // 4、FALC:对准最多次数的更新，执行自动对准时，容许最多对准次数的更新
					{		
						int nAlignTime = pOwner->m_XYDCommProtocol.m_FALCParam.P1;
						nParam.push_back(nAlignTime);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FALCParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FALCParam.m_strCmd, eCmdSetAlignTimeFALC);
						pOwner->OnlineSetAlignTimeFALC(nAlignTime);
					}
					break;	
				case eCmdGetAlignOffsetFGOF:     // 2、FGOF:补偿量值的取得，取得设定的补偿量值
					{				   
						int nOffsetIndex = pOwner->m_XYDCommProtocol.m_FGOFParam.P1;
						nParam.push_back(nOffsetIndex);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGOFParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGOFParam.m_strCmd, eCmdGetAlignOffsetFGOF);
						pOwner->OnlineGetAlignOffsetFGOF(nOffsetIndex-1);
					}
					break;	
					// 				case eCmdSetAlignOffsetFOFS:    // 3、FOFS:补偿量值的设定，设定补偿量值
					// 					{	
					// 						int nOffsetIndex;
					// 						CCoordPos cpAlignOffset;
					// 						BOOL bReGetOffsetIndex = TRUE;
					// 						nOffsetIndex = pOwner->m_XYDCommProtocol.m_FOFSParam.P1-1;
					// 						cpAlignOffset.m_dPosX = pOwner->m_XYDCommProtocol.m_FOFSParam.P2;
					// 						cpAlignOffset.m_dPosY = pOwner->m_XYDCommProtocol.m_FOFSParam.P3;
					// 						cpAlignOffset.m_dAngle = pOwner->m_XYDCommProtocol.m_FOFSParam.P4;
					// 
					// 						if (pOwner->m_XYDCommProtocol.m_FOFSParam.m_nType==4)
					// 						{
					// 							nParam.push_back(nOffsetIndex);
					// 							bReGetOffsetIndex= FALSE;
					// 						}						
					// 						dParam.push_back(cpAlignOffset.m_dPosX);
					// 						dParam.push_back(cpAlignOffset.m_dPosY);
					// 						dParam.push_back(cpAlignOffset.m_dAngle);
					// 						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FOFSParam.m_strCmd,nParam,dParam);
					// 
					// 						pOwner->OnlineSetAlignOffsetFOFS(nOffsetIndex,cpAlignOffset,bReGetOffsetIndex);
					// 					}
					// 					break;	
				case eCmdSetAlignOffsetFOFS:    // 3、FOFS:补偿量值的设定，设定补偿量值
					{	
						int nOffsetIndex = pOwner->m_XYDCommProtocol.m_FOFSParam.P1-1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FOFSParam.P1);

						if (pOwner->m_XYDCommProtocol.m_FOFSParam.m_nPType == 4)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOFSParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOFSParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOFSParam.P4);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FOFSParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FOFSParam.m_strCmd, eCmdSetAlignOffsetFOFS);
						pOwner->OnlineSetAlignOffsetFOFS(nOffsetIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
					}
					break;	
				case eCmdFGPO:
					{
						pOwner->PackAndAddCommSimpleInfo(strInfo, pOwner->m_XYDCommProtocol.m_FGPOParam.m_strCmd, nParam, dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGPOParam.m_strCmd, eCmdFGPO);
						pOwner->OnlineGetPlatformOffsetFGPO();
					}
					break;
				case eCmdCalibrateFCLB:     // 1、FCLB:Calibration 的执行 执行Calibration
					{			   
						int nMarkType = pOwner->m_XYDCommProtocol.m_FCLBParam.P1;   // 标定目标（0）or对象（1）
						int nCalibIndex = pOwner->m_XYDCommProtocol.m_FCLBParam.P2;   // 标定第n个靶标
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						nParam.push_back(nMarkType);
						nParam.push_back(nCalibIndex);

						if (5 == pOwner->m_XYDCommProtocol.m_FCLBParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCLBParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCLBParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCLBParam.P5);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCLBParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCLBParam.m_strCmd, eCmdCalibrateFCLB);
						//						pOwner->OnlineCalibrateEx(nCalibIndex-1, nMarkType);
						pOwner->OnlineCalibrateFCLB(nCalibIndex-1, nMarkType);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
					}
					break;	
				case eCmdCalibrateFCBS:     // 1、FCBS:Calibration 的执行 执行Calibration
					{				   
						int nMarkType   = pOwner->m_XYDCommProtocol.m_FCBSParam.P1;//1为压头目标，0 为玻璃对象，2为计算
						int nCalibIndex = pOwner->m_XYDCommProtocol.m_FCBSParam.P2;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						nParam.push_back(nMarkType);
						nParam.push_back(nCalibIndex);
						if (5 == pOwner->m_XYDCommProtocol.m_FCBSParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBSParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBSParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBSParam.P5);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}


						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCBSParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCBSParam.m_strCmd, eCmdCalibrateFCBS);

						//						pOwner->OnlineFCBSCalibrate(nCalibIndex-1, nMarkType);
						pOwner->OnlineCalibrateFCBS(nCalibIndex-1, nMarkType);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
					}
					break;
				case eCmdCalibrateFCBP:     // 1、FCLB:Calibration 的执行 执行Calibration
					{				   
						int nType = pOwner->m_XYDCommProtocol.m_FCBPParam.P1;   // 类型
						int nCalibIndex = pOwner->m_XYDCommProtocol.m_FCBPParam.P2;   // 标定第n个靶标
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_nCalibTargetMovePosIndex = pOwner->m_XYDCommProtocol.m_FCBPParam.P3-1;//移动位置序号
						pOwner->m_bIsAutoCalibrating = TRUE;
						int nExProductIndex = 0;
						nParam.push_back(nType);
						nParam.push_back(nCalibIndex);
						nParam.push_back(pOwner->m_nCalibTargetMovePosIndex);
						if(!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							if((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
							{
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);						
								if (7 == pOwner->m_XYDCommProtocol.m_FCBPParam.m_nPType)	// 指令参数包含轴位置
								{
									if (optionInfo.m_bAlignExProduct)
									{
										nExProductIndex = pOwner->m_XYDCommProtocol.m_FCBPParam.nP4-1;
									}						
									nParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.nP4);
									pOwner->m_bCmdParamAxisPosEanble = TRUE;
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.P4);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.P5);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.P6);
								}
								if (4 == pOwner->m_XYDCommProtocol.m_FCBPParam.m_nPType)	// 指令参数不包含轴位置
								{
									if (optionInfo.m_bAlignExProduct)
									{
										nExProductIndex = pOwner->m_XYDCommProtocol.m_FCBPParam.nP4-1;
									}							
									nParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.nP4);
									pOwner->m_bCmdParamAxisPosEanble = FALSE;							
								}

							}
							else if (6 == pOwner->m_XYDCommProtocol.m_FCBPParam.m_nPType)	// 不扩展产品且指令参数包含轴位置
							{
								pOwner->m_bCmdParamAxisPosEanble = TRUE;
								dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.P4);
								dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.P5);
								dParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.P6);
							}
							else // 不扩展产品且指令参数不包含轴位置
							{
								pOwner->m_bCmdParamAxisPosEanble = FALSE;
							}
						}
						else
						{
							if((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
							{
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								if (optionInfo.m_bAlignExProduct)
								{
									nExProductIndex = pOwner->m_XYDCommProtocol.m_FCBPParam.nP4-1;
								}
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FCBPParam.nP4);
							}
						}
						if(nExProductIndex<0 || nExProductIndex>pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum)
						{
							nExProductIndex = 0;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCBPParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCBPParam.m_strCmd, eCmdCalibrateFCBP);
						pOwner->OnlineFCBPCalibrate(nCalibIndex-1, nType,nExProductIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
					}
					break;
				case eCmdCalibrateFCPR:
					{
						int nCalibIndex = pOwner->m_XYDCommProtocol.m_FCPRParam.P1;
						int nCalibType = pOwner->m_XYDCommProtocol.m_FCPRParam.P2;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						nParam.push_back(nCalibIndex);
						nParam.push_back(nCalibType);
						if(4 == pOwner->m_XYDCommProtocol.m_FCPRParam.m_nPType)
						{
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCPRParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCPRParam.P4);
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCPRParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCPRParam.m_strCmd, eCmdCalibrateFCPR);
						pOwner->OnlineFCPRCalibrate(nCalibIndex-1,nCalibType);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
					}
					break;
				case eCmdTargetSearchFTGT:  // 执行实时目标搜索: FTGT  
					{
						pOwner->m_bTargetSearchTest = TRUE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FTGTParam.P1 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.P1);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
						pOwner->SetAlignExProductIndex(0);

						if(!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							//1. 无协议通信,根据参数数据从后往前依次解析参数；FTGT参数格式为 FTGT P1 nP2 nP3 nP4 X Y D
							//2. 仅有P1参数分为带轴位置和不带轴位置两种，加入其它参数均必须带轴位置
							/*3. 其中nP2,nP3,nP4参数若不需要后面的参数，则可不发（如不需要nP4,则可发FTGT P1 nP2 nP3 XYD）;若需要后面的参数
							不需要前面的参数，前面的参数也要发（发什么随意）（如需要nP4不需要nP3,nP3仍然要发送，格式为FTGT P1 nP2 nP3 nP4 XYD,
							nP3可发任意值） */
							std::vector<int> nParamEx;
							switch(pOwner->m_XYDCommProtocol.m_FTGTParam.m_nPType)
							{
							case 7://参数数目为7时，解析是否拍照并对位
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.nP4);
									CPlatformOptionInfo optionInfo;
									pOwner->GetPlatformOptionInfo(optionInfo);
									if (optionInfo.m_bEnableAlignAfterSearch)
									{
										if (pOwner->m_XYDCommProtocol.m_FTGTParam.nP4 > 0 && pOwner->m_XYDCommProtocol.m_FTGTParam.nP4 < 100)
										{
											pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FTGTParam.nP4-1;
											pOwner->m_nAlignType = 1;
										}
										else if (pOwner->m_XYDCommProtocol.m_FTGTParam.nP4 > 100)
										{
											pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FTGTParam.nP4-101;
											pOwner->m_nAlignType = 2;
										}
										else
										{
											pOwner->m_nAlignType = -1;
										}
									}
								}
							case 6://参数数目为7、6时，解析扩展产品序号
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.nP3);
									if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
									{
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										if (optionInfo.m_bTargetSearchExProduct)
										{
											if (pOwner->m_XYDCommProtocol.m_FTGTParam.nP3-1>=0 &&  pOwner->m_XYDCommProtocol.m_FTGTParam.nP3-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
											{					
												// 启用扩展且参数包含扩展序号
												pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FTGTParam.nP3-1);
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

											}
											else if (pOwner->m_XYDCommProtocol.m_FTGTParam.nP3 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FTGTParam.nP3-1 <= 103)
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FTGTParam.nP3 -1;
											}
											else //参数异常默认参数
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
												pOwner->SetAlignExProductIndex(0);
											}
										}
										else
										{
											if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
											pOwner->SetAlignExProductIndex(0);
										}
									}

								}
							case 5://参数数量为7、6、5时，解析是否拍照并检测或多目标对位
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.nP2);
									if (optionInfo.m_bEnableMutiTarget)
									{	
										pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FTGTParam.nP2-1;											
									}
									else//是否检测//这两者不兼容 //占位
									{
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FTGTParam.nP2 && optionInfo.m_bSearchWithDistanceInspect;
									}
								}
							case 4://参数数量为7、6、5、4时，解析轴位置
								{
									pOwner->m_bCmdParamAxisPosEanble = TRUE;
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.P2);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.P3);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.P4);
								}

							}
							std::reverse(nParamEx.begin(),nParamEx.end());//因为参数是从后往前排的，这里需要反序
							nParam.insert(nParam.end(),nParamEx.begin(),nParamEx.end());
						}
						else
						{
							//1. 寄存器通信时，每个参数都需要占一个寄存器参数位置，即使该参数不用
							//2. PLC设置参数时，在需要的参数位置设置值即可，不要的参数位置默认就行
							CPlatformOptionInfo optionInfo;
							pOwner->GetPlatformOptionInfo(optionInfo);
							//解析是否检测或者多目标对位序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.nP2);
							if (optionInfo.m_bEnableMutiTarget)
							{		
								pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FTGTParam.nP2-1;											
							}
							else//是否检测//这两者不兼容
							{
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FTGTParam.nP2 && optionInfo.m_bSearchWithDistanceInspect;
							}

							//解析扩展产品序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.nP3);
							if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
							{	
								if (optionInfo.m_bTargetSearchExProduct)
								{
									if (pOwner->m_XYDCommProtocol.m_FTGTParam.nP3-1>=0 &&  pOwner->m_XYDCommProtocol.m_FTGTParam.nP3-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
									{					
										// 启用扩展且参数包含扩展序号

										pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FTGTParam.nP3-1);
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;


									}
									else if (pOwner->m_XYDCommProtocol.m_FTGTParam.nP3 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FTGTParam.nP3-1 <= 103)
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FTGTParam.nP3 -1;
									}
									else //参数异常默认参数
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
										pOwner->SetAlignExProductIndex(0);
									}
								}
								else
								{
									if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
									pOwner->SetAlignExProductIndex(0);
								}
							}


							//解析是否对位参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGTParam.nP4);
							if (optionInfo.m_bEnableAlignAfterSearch)
							{
								if (pOwner->m_XYDCommProtocol.m_FTGTParam.nP4 > 0 && pOwner->m_XYDCommProtocol.m_FTGTParam.nP4 < 100)
								{
									pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FTGTParam.nP4-1;
									pOwner->m_nAlignType = 1;
								}
								else if (pOwner->m_XYDCommProtocol.m_FTGTParam.nP4 > 100)
								{
									pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FTGTParam.nP4-101;
									pOwner->m_nAlignType = 2;
								}
								else
								{
									pOwner->m_nAlignType = -1;
								}
							}
						}


						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FTGTParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FTGTParam.m_strCmd, eCmdTargetSearchFTGT);
						pOwner->OnlineAlnTargetSearchExFTGT(nPosIndex);		
						pOwner->m_bCmdParamAxisPosEanble = FALSE;

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;

						pOwner->m_bTargetSearchTest = FALSE;
					}
					break;
				case eCmdTargetSearchFTGM:  // 执行实时目标手动搜索: FTGM  
					{
						pOwner->m_bTargetSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FTGMParam.P1 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGMParam.P1);
						if (optionInfo.m_bEnableMutiTarget)
						{
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGMParam.P2);
							pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FTGMParam.P2-1;
						}

						if (4 == pOwner->m_XYDCommProtocol.m_FTGMParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGMParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGMParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGMParam.P4);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FTGMParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FTGMParam.m_strCmd, eCmdTargetSearchFTGM);
						pOwner->OnlineAlnTargetSearchExFTGM(nPosIndex);		
						pOwner->m_bCmdParamAxisPosEanble = FALSE;

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;
						pOwner->m_bTargetSearchTest = FALSE;
					}
					break;
				case eCmdTargetSearchFTGS:  // 执行实时目标搜索: FTGS
					{
						pOwner->m_bTargetSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FTGSParam.P1 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGSParam.P1);
						if (optionInfo.m_bEnableMutiTarget)
						{
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGSParam.P2);
							pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FTGSParam.P2-1;
						}

						if (4 == pOwner->m_XYDCommProtocol.m_FTGSParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGSParam.P1);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGSParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGSParam.P3);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FTGSParam.m_strCmd,nParam,dParam);

						pOwner->OnlineAlnTargetSearchExFTGS(nPosIndex);		

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;
						pOwner->m_bTargetSearchTest = FALSE;
					}
					break;
				case eCmdGetImagePosFGAP:  // 执行实时对象搜索（相对于图像中心点的图像坐标偏差）: FGAP
					{
						pOwner->m_bObjectSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = 0;
						if (5 == pOwner->m_XYDCommProtocol.m_FGAPParam.m_nPType)	// 指令参数包含候轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGAPParam.P1 - 1;
							int nPatIndex = pOwner->m_XYDCommProtocol.m_FGAPParam.P2 - 1;

							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGAPParam.P1);
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGAPParam.P2);
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGAPParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGAPParam.m_strCmd, eCmdGetImagePosFGAP);
							if (nPatIndex < 0)
							{
								pOwner->OnlineAlnSearchExFGAP(nPosIndex, 0);
							}
							else
							{
								pOwner->OnlineAlnSearchExFGAP(nPosIndex, nPatIndex);
							}
						}
						else if (2 == pOwner->m_XYDCommProtocol.m_FGAPParam.m_nPType)	// 指令参数不包含候轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGAPParam.P1 - 1;
							int nPatIndex = pOwner->m_XYDCommProtocol.m_FGAPParam.P2 - 1;	

							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGAPParam.P1);
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGAPParam.P2);
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGAPParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGAPParam.m_strCmd, eCmdGetImagePosFGAP);
							if (nPatIndex < 0)
							{
								pOwner->OnlineAlnSearchExFGAP(nPosIndex, 0);
							}
							else
							{
								pOwner->OnlineAlnSearchExFGAP(nPosIndex, nPatIndex);
							}
						}
						else // 指令参数不包含候补模板编号
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGAPParam.P1 - 1;
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGAPParam.P1);
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGAPParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGAPParam.m_strCmd, eCmdGetImagePosFGAP);
							pOwner->OnlineAlnSearchExFGAP(nPosIndex, 0);
						}

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bObjectSearchTest = FALSE;

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;

					}
					break;
				case eCmdGetImagePosFGTC:
					{
						//						pOwner->m_bObjectSearchTest = TRUE;
						pOwner->m_bTargetSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = 0;
						if (5 == pOwner->m_XYDCommProtocol.m_FGTCParam.m_nPType)	// 指令参数包含候轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGTCParam.P1 - 1;
							int nPatIndex = pOwner->m_XYDCommProtocol.m_FGTCParam.P2 - 1;

							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTCParam.P1);
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTCParam.P2);
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGTCParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGTCParam.m_strCmd, eCmdGetImagePosFGTC);
							if (nPatIndex < 0)
							{
								pOwner->OnlineAlnSearchExFGTC(nPosIndex, 0);
							}
							else
							{
								pOwner->OnlineAlnSearchExFGTC(nPosIndex, nPatIndex);
							}
						}
						else if (2 == pOwner->m_XYDCommProtocol.m_FGTCParam.m_nPType)	// 指令参数不包含候轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGTCParam.P1 - 1;
							int nPatIndex = pOwner->m_XYDCommProtocol.m_FGTCParam.P2 - 1;	

							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTCParam.P1);
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTCParam.P2);
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGTCParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGTCParam.m_strCmd, eCmdGetImagePosFGTC);
							if (nPatIndex < 0)
							{
								pOwner->OnlineAlnSearchExFGTC(nPosIndex, 0);
							}
							else
							{
								pOwner->OnlineAlnSearchExFGTC(nPosIndex, nPatIndex);
							}
						}
						else // 指令参数不包含候补模板编号
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGTCParam.P1 - 1;
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTCParam.P1);
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGTCParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGTCParam.m_strCmd, eCmdGetImagePosFGTC);
							pOwner->OnlineAlnSearchExFGTC(nPosIndex, 0);
						}

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						//						pOwner->m_bObjectSearchTest = FALSE;
						pOwner->m_bTargetSearchTest = FALSE;

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;
					}
					break;
				case eCmdTargetSearchFTGC:  // 执行实时目标搜索: 目标候补搜索 FTGC
					{
						pOwner->m_bTargetSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FTGCParam.P1 - 1;
						int nStartPatIndex = pOwner->m_XYDCommProtocol.m_FTGCParam.P2 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.P2);
						if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
						if(!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							//1. 无协议通信,根据参数数据从后往前依次解析参数；FAAL参数格式为 FAAL P1 nP2 nP3 nP4 X Y D
							//2. 仅有P1参数分为带轴位置和不带轴位置两种，加入其它参数均必须带轴位置
							/*3. 其中nP2,nP3,nP4参数若不需要后面的参数，则可不发（如不需要nP4,则可发FAAL P1 nP2 nP3 XYD）;若需要后面的参数
							不需要前面的参数，前面的参数也要发（发什么随意）（如需要nP4不需要nP3,nP3仍然要发送，格式为FAAL P1 nP2 nP3 nP4 XYD,
							nP3可发任意值） */
							std::vector<int> nParamEx;
							switch(pOwner->m_XYDCommProtocol.m_FTGCParam.m_nPType)
							{
							case 8://参数数目为8时，解析是否拍照并对位
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.nP5);
									CPlatformOptionInfo optionInfo;
									pOwner->GetPlatformOptionInfo(optionInfo);
									if (optionInfo.m_bEnableAlignAfterSearch)
									{
										if (pOwner->m_XYDCommProtocol.m_FTGCParam.nP5 > 0 && pOwner->m_XYDCommProtocol.m_FTGCParam.nP5 < 100)
										{
											pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FTGCParam.nP5-1;
											pOwner->m_nAlignType = 1;
										}
										else if (pOwner->m_XYDCommProtocol.m_FTGCParam.nP5 > 100)
										{
											pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FTGCParam.nP5-101;
											pOwner->m_nAlignType = 2;
										}
										else
										{
											pOwner->m_nAlignType = -1;
										}
									}
								}
							case 7://参数数目为8、7时，解析扩展产品序号
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.nP4);
									if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
									{	
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										if (optionInfo.m_bTargetSearchExProduct)
										{
											if (pOwner->m_XYDCommProtocol.m_FTGCParam.nP4-1>=0 &&  pOwner->m_XYDCommProtocol.m_FTGCParam.nP4-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
											{					
												// 启用扩展且参数包含扩展序号
												pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FTGCParam.nP4-1);
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

											}
											else if (pOwner->m_XYDCommProtocol.m_FTGCParam.nP4 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FTGCParam.nP4-1 <= 103)
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FTGCParam.nP4 -1;
											}
											else //参数异常默认参数
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
												pOwner->SetAlignExProductIndex(0);
											}
										}
										else
										{
											if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
											pOwner->SetAlignExProductIndex(0);
										}
									}

								}
							case 6://参数数量为8、7、6时，解析是否拍照并检测或多目标对位
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.nP3);
									if (optionInfo.m_bEnableMutiTarget)
									{	
										pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FTGCParam.nP3-1;											
									}
									else//是否检测//这两者不兼容 //占位
									{
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FTGCParam.nP3 && optionInfo.m_bSearchWithDistanceInspect;
									}
								}
							case 5://参数数量为8、7、6、5时，解析轴位置
								{
									pOwner->m_bCmdParamAxisPosEanble = TRUE;
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.P3);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.P4);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.P5);
								}

							}
							std::reverse(nParamEx.begin(),nParamEx.end());//因为参数是从后往前排的，这里需要反序
							nParam.insert(nParam.end(),nParamEx.begin(),nParamEx.end());
						}
						else
						{
							//1. 寄存器通信时，每个参数都需要占一个寄存器参数位置，即使该参数不用
							//2. PLC设置参数时，在需要的参数位置设置值即可，不要的参数位置默认就行
							CPlatformOptionInfo optionInfo;
							pOwner->GetPlatformOptionInfo(optionInfo);
							//解析是否检测或者多目标对位序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.nP3);
							if (optionInfo.m_bEnableMutiTarget)
							{		
								pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FTGCParam.nP3-1;											
							}
							else//是否检测//这两者不兼容 //占位
							{
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FTGCParam.nP3 && optionInfo.m_bSearchWithDistanceInspect;
							}

							//解析扩展产品序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.nP4);						
							if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
							{	
								if (optionInfo.m_bTargetSearchExProduct)
								{
									if (pOwner->m_XYDCommProtocol.m_FTGCParam.nP4-1>=0 &&  pOwner->m_XYDCommProtocol.m_FTGCParam.nP4-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
									{					
										// 启用扩展且参数包含扩展序号	
										pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FTGCParam.nP4-1);
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

									}
									else if (pOwner->m_XYDCommProtocol.m_FTGCParam.nP4 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FTGCParam.nP4-1 <= 103)
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FTGCParam.nP4 -1;
									}
									else //参数异常默认参数
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
										pOwner->SetAlignExProductIndex(0);
									}
								}
								else
								{
									if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
									pOwner->SetAlignExProductIndex(0);
								}
							}


							//解析是否对位参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGCParam.nP5);								
							if (optionInfo.m_bEnableAlignAfterSearch)
							{
								if (pOwner->m_XYDCommProtocol.m_FTGCParam.nP5 > 0 && pOwner->m_XYDCommProtocol.m_FTGCParam.nP5 < 100)
								{
									pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FTGCParam.nP5-1;
									pOwner->m_nAlignType = 1;
								}
								else if (pOwner->m_XYDCommProtocol.m_FTGCParam.nP5 > 100)
								{
									pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FTGCParam.nP5-101;
									pOwner->m_nAlignType = 2;
								}
								else
								{
									pOwner->m_nAlignType = -1;
								}
							}
						}
						if(pOwner->m_nMutiTargetCurIndex < 0 || pOwner->m_nMutiTargetCurIndex >= MUTITARGETMAXNUM)
						{//TT201029 防止多目标序号溢出
							pOwner->m_nMutiTargetCurIndex = 0;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FTGCParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FTGCParam.m_strCmd, eCmdTargetSearchFTGC);
						pOwner->OnlineAlnTargetSearchCandidateExFTGC(nPosIndex, nStartPatIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;

						// 设置手动对象搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;
						pOwner->m_bTargetSearchTest = FALSE;
						pOwner->m_nAlignType = -1;
					}
					break;
				case eCmdObjectSearchFOBJ:  // 执行实时对象搜索: OBG （仅测试用） // FOBJ
					{
						//
						pOwner->m_bObjectSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FOBJParam.P1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.P1);
						if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
						if(!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							//1. 无协议通信,根据参数数据从后往前依次解析参数；FOBJ参数格式为 FOBJ P1 nP2 nP3 nP4 X Y D
							//2. 仅有P1参数分为带轴位置和不带轴位置两种，加入其它参数均必须带轴位置
							/*3. 其中nP2,nP3,nP4参数若不需要后面的参数，则可不发（如不需要nP4,则可发FOBJ P1 nP2 nP3 XYD）;若需要后面的参数
							不需要前面的参数，前面的参数也要发（发什么随意）（如需要nP4不需要nP3,nP3仍然要发送，格式为FOBJ P1 nP2 nP3 nP4 XYD,
							nP3可发任意值） */
							std::vector<int> nParamEx;
							switch(pOwner->m_XYDCommProtocol.m_FOBJParam.m_nPType)
							{
							case 7://参数数目为7时，解析是否拍照并对位
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.nP4);
									CPlatformOptionInfo optionInfo;
									pOwner->GetPlatformOptionInfo(optionInfo);
									if (optionInfo.m_bEnableAlignAfterSearch)
									{
										if (pOwner->m_XYDCommProtocol.m_FOBJParam.nP4 > 0 && pOwner->m_XYDCommProtocol.m_FOBJParam.nP4 < 100)
										{
											pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOBJParam.nP4-1;
											pOwner->m_nAlignType = 1;
										}
										else if (pOwner->m_XYDCommProtocol.m_FOBJParam.nP4 > 100)
										{
											pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOBJParam.nP4-101;
											pOwner->m_nAlignType = 2;
										}
										else
										{
											pOwner->m_nAlignType = -1;
										}
									}
								}
							case 6://参数数目为7、6时，解析扩展产品序号
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.nP3);
									if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
									{		
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										if (optionInfo.m_bObjectSearchExProduct)
										{
											if (pOwner->m_XYDCommProtocol.m_FOBJParam.nP3-1>=0 &&  pOwner->m_XYDCommProtocol.m_FOBJParam.nP3-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
											{					
												// 启用扩展且参数包含扩展序号
												pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FOBJParam.nP3-1);
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

											}
											else if (pOwner->m_XYDCommProtocol.m_FOBJParam.nP3 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FOBJParam.nP3-1 <= 103)
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FOBJParam.nP3 -1;
											}
											else //参数异常默认参数
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
												pOwner->SetAlignExProductIndex(0);
											}
										}
										else
										{
											if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
											pOwner->SetAlignExProductIndex(0);
										}
									}

								}
							case 5://参数数量为7、6、5时，解析是否拍照并检测
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.nP2);												
									CPlatformOptionInfo optionInfo;
									pOwner->GetPlatformOptionInfo(optionInfo);
									pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FOBJParam.nP2 && optionInfo.m_bSearchWithDistanceInspect;

								}
							case 4://参数数量为7、6、5、4时，解析轴位置
								{
									pOwner->m_bCmdParamAxisPosEanble = TRUE;
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.P2);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.P3);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.P4);
								}

							}
							std::reverse(nParamEx.begin(),nParamEx.end());//因为参数是从后往前排的，这里需要反序
							nParam.insert(nParam.end(),nParamEx.begin(),nParamEx.end());
						}
						else
						{
							//1. 寄存器通信时，每个参数都需要占一个寄存器参数位置，即使该参数不用
							//2. PLC设置参数时，在需要的参数位置设置值即可，不要的参数位置默认就行

							//解析是否检测参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.nP2);
							CPlatformOptionInfo optionInfo;
							pOwner->GetPlatformOptionInfo(optionInfo);
							pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FOBJParam.nP2 && optionInfo.m_bSearchWithDistanceInspect;

							//解析扩展产品序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.nP3);
							if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
							{	
								if (optionInfo.m_bObjectSearchExProduct)
								{
									if (pOwner->m_XYDCommProtocol.m_FOBJParam.nP3-1>=0 &&  pOwner->m_XYDCommProtocol.m_FOBJParam.nP3-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
									{					
										// 启用扩展且参数包含扩展序号				
										pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FOBJParam.nP3-1);
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

									}
									else if (pOwner->m_XYDCommProtocol.m_FOBJParam.nP3 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FOBJParam.nP3-1 <= 103)
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FOBJParam.nP3 -1;
									}
									else //参数异常默认参数
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
										pOwner->SetAlignExProductIndex(0);
									}
								}
								else
								{
									if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
									pOwner->SetAlignExProductIndex(0);
								}
							}


							//解析是否对位参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBJParam.nP4);
							if (optionInfo.m_bEnableAlignAfterSearch)
							{
								if (pOwner->m_XYDCommProtocol.m_FOBJParam.nP4 > 0 && pOwner->m_XYDCommProtocol.m_FOBJParam.nP4 < 100)
								{
									pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOBJParam.nP4-1;
									pOwner->m_nAlignType = 1;
								}
								else if (pOwner->m_XYDCommProtocol.m_FOBJParam.nP4 > 100)
								{
									pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOBJParam.nP4-101;
									pOwner->m_nAlignType = 2;
								}
								else
								{
									pOwner->m_nAlignType = -1;
								}
							}
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FOBJParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FOBJParam.m_strCmd, eCmdObjectSearchFOBJ);
						pOwner->OnlineAlnObjectSearchExFOBJ(nPosIndex-1);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bObjectSearchTest = FALSE;

						// 设置手动对象搜索序号
						pOwner->m_nManualObjectSearchIndex = nPosIndex-1;
					}
					break;
				case eCmdObjectSearchFCNT:  // 对象定位同时将目标位置设为图像中心
					{
						//
						pOwner->m_bObjectSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FCNTParam.P1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCNTParam.P1);
						if (4 == pOwner->m_XYDCommProtocol.m_FCNTParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCNTParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCNTParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCNTParam.P4);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCNTParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCNTParam.m_strCmd, eCmdObjectSearchFCNT);
						pOwner->OnlineAlnObjectSearchExFCNT(nPosIndex-1);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bObjectSearchTest = FALSE;

						// 设置手动对象搜索序号
						pOwner->m_nManualObjectSearchIndex = nPosIndex;

					}
					break;
				case eCmdTargetSearchFCNO:  // 目标定位同时将对象位置设为图像中心
					{

						pOwner->m_bTargetSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FCNOParam.P1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCNOParam.P1);

						if ( (4 == pOwner->m_XYDCommProtocol.m_FCNOParam.m_nPType))	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCNOParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCNOParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FCNOParam.P4);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCNOParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCNOParam.m_strCmd, eCmdTargetSearchFCNO);
						pOwner->OnlineAlnTargetSearchExFCNO(nPosIndex-1);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bTargetSearchTest = FALSE;

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;

					}
					break;

				case eCmdObjectSearchFOBM:  // 执行实时对象手动搜索：FOBM
					{
						//
						pOwner->m_bObjectSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FOBMParam.P1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBMParam.P1);
						if (4 == pOwner->m_XYDCommProtocol.m_FOBMParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBMParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBMParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBMParam.P4);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FOBMParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FOBMParam.m_strCmd, eCmdObjectSearchFOBM);
						pOwner->OnlineAlnObjectSearchExFOBM(nPosIndex-1);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bObjectSearchTest = FALSE;

						// 设置手动对象搜索序号
						pOwner->m_nManualObjectSearchIndex = nPosIndex;
					}
					break;
				case eCmdObjectSearchFOBC:  // 执行实时对象搜索: OBG （仅测试用） // FOBC
					{
						//
						pOwner->m_bObjectSearchTest = TRUE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FOBCParam.P1;
						int nStartPatIndex = pOwner->m_XYDCommProtocol.m_FOBCParam.P2;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.P2);
						if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
						if(!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							//1. 无协议通信,根据参数数据从后往前依次解析参数；FOBC参数格式为 FOBC P1 P2 nP3 nP4 nP5 X Y D
							//2. 仅有P1 P2参数分为带轴位置和不带轴位置两种，加入其它参数均必须带轴位置
							/*3. 其中nP3,nP4,nP5参数若不需要后面的参数，则可不发（如不需要nP4/nP5,则可发FOBC P1 P2 nP3 XYD）;若需要后面的参数
							不需要前面的参数，前面的参数也要发（发什么随意）（如需要nP4不需要nP3、nP5,nP3仍然要发送，格式为FTOBC P1 P2 nP3 nP4 XYD,
							nP3可发任意值） */
							std::vector<int> nParamEx;
							switch(pOwner->m_XYDCommProtocol.m_FOBCParam.m_nPType)
							{
							case 8://参数数目为8时，解析是否拍照并对位
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.nP5);
									CPlatformOptionInfo optionInfo;
									pOwner->GetPlatformOptionInfo(optionInfo);
									if (optionInfo.m_bEnableAlignAfterSearch)
									{
										if (pOwner->m_XYDCommProtocol.m_FOBCParam.nP5 > 0 && pOwner->m_XYDCommProtocol.m_FOBCParam.nP5 < 100)
										{
											pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOBCParam.nP5-1;
											pOwner->m_nAlignType = 1;
										}
										else if (pOwner->m_XYDCommProtocol.m_FOBCParam.nP5 > 100)
										{
											pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOBCParam.nP5-101;
											pOwner->m_nAlignType = 2;
										}
										else
										{
											pOwner->m_nAlignType = -1;
										}
									}
								}
							case 7://参数数目为8、7时，解析扩展产品序号
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.nP4);
									if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
									{		
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										if (optionInfo.m_bObjectSearchExProduct)
										{
											if (pOwner->m_XYDCommProtocol.m_FOBCParam.nP4-1>=0 &&  pOwner->m_XYDCommProtocol.m_FOBCParam.nP4-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
											{					
												// 启用扩展且参数包含扩展序号
												pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FOBCParam.nP4-1);
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

											}
											else if (pOwner->m_XYDCommProtocol.m_FOBCParam.nP4 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FOBCParam.nP4-1 <= 103)
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FOBCParam.nP4 -1;
											}
											else //参数异常默认参数
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
												pOwner->SetAlignExProductIndex(0);
											}
										}
										else
										{
											if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
											pOwner->SetAlignExProductIndex(0);
										}
									}

								}
							case 6://参数数量为8、7、6时，解析是否拍照并检测
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.nP3);												
									CPlatformOptionInfo optionInfo;
									pOwner->GetPlatformOptionInfo(optionInfo);
									pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FOBCParam.nP3 && optionInfo.m_bSearchWithDistanceInspect;

								}
							case 5://参数数量为8、7、6、5时，解析轴位置
								{
									pOwner->m_bCmdParamAxisPosEanble = TRUE;
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.P3);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.P4);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.P5);
								}

							}
							std::reverse(nParamEx.begin(),nParamEx.end());//因为参数是从后往前排的，这里需要反序
							nParam.insert(nParam.end(),nParamEx.begin(),nParamEx.end());
						}
						else
						{
							//1. 寄存器通信时，每个参数都需要占一个寄存器参数位置，即使该参数不用
							//2. PLC设置参数时，在需要的参数位置设置值即可，不要的参数位置默认就行

							//解析是否检测或者多目标对位序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.nP3);
							CPlatformOptionInfo optionInfo;
							pOwner->GetPlatformOptionInfo(optionInfo);
							if (optionInfo.m_bEnableMutiTarget)
							{		
								pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FOBCParam.nP3-1;											
							}
							else
							{
								pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FOBCParam.nP3 && optionInfo.m_bSearchWithDistanceInspect;
							}

							//解析扩展产品序号参数;
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.nP4);
							if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
							{	
								if (optionInfo.m_bObjectSearchExProduct)
								{
									if (pOwner->m_XYDCommProtocol.m_FOBCParam.nP4-1>=0 &&  pOwner->m_XYDCommProtocol.m_FOBCParam.nP4-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
									{					
										// 启用扩展且参数包含扩展序号				
										pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FOBCParam.nP4-1);
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

									}
									else if (pOwner->m_XYDCommProtocol.m_FOBCParam.nP4 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FOBCParam.nP4-1 <= 103)
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FOBCParam.nP4 -1;
									}
									else //参数异常默认参数
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
										pOwner->SetAlignExProductIndex(0);
									}
								}
								else
								{
									if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
									pOwner->SetAlignExProductIndex(0);
								}
							}


							//解析是否对位参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBCParam.nP5);
							if (optionInfo.m_bEnableAlignAfterSearch)
							{
								if (pOwner->m_XYDCommProtocol.m_FOBCParam.nP5 > 0 && pOwner->m_XYDCommProtocol.m_FOBCParam.nP5 < 100)
								{
									pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOBCParam.nP5-1;
									pOwner->m_nAlignType = 1;
								}
								else if (pOwner->m_XYDCommProtocol.m_FOBCParam.nP5 > 100)
								{
									pOwner->m_nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOBCParam.nP5-101;
									pOwner->m_nAlignType = 2;
								}
								else
								{
									pOwner->m_nAlignType = -1;
								}
							}
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FOBCParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FOBCParam.m_strCmd, eCmdObjectSearchFOBC);
						pOwner->OnlineAlnObjectSearchCandidateExFOBC(nPosIndex-1, nStartPatIndex - 1);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bObjectSearchTest = FALSE;
						pOwner->m_bSearchWithInspect = FALSE;

						// 设置手动对象搜索序号
						pOwner->m_nManualObjectSearchIndex = nPosIndex;
						pOwner->m_nAlignType = -1;

					}
					break;
				case eCmdGetTargetImagePosFTGG:  // 获取目标指定位置的图像坐标 FTGG
					{
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FTGGParam.P1 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FTGGParam.P1);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FTGGParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FTGGParam.m_strCmd, eCmdGetTargetImagePosFTGG);
						pOwner->OnlineGetTargetImagePosFTGG(nPosIndex);

						// 设置手动对象搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;
					}
					break;
				case eCmdGetObjectImagePosFOBG:  // 获取对象指定位置的图像坐标 FOBG
					{
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FOBGParam.P1 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FOBGParam.P1);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FOBGParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FOBGParam.m_strCmd, eCmdGetObjectImagePosFOBG);
						pOwner->OnlineGetObjectImagePosFOBG(nPosIndex);

						// 设置手动对象搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;
					}
					break;
				case eCmdGetTargetObjectOffsetFACO:   // 执行在线对位: AAE    // 计算偏差量 Fast：FACO
					{				
						//pOwner->OnlineAlign();
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FACOParam.P1 - 1;	

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FACOParam.P1);

						int nReservedIndex = 10;
						int nBenchOffsetIndex = -1;
						int nExProductIndex = 0;
						int nTarFixOffsetIndex = 0;

						BOOL bExProduct = FALSE;

						//多目标对位序号与保留参数共用一个参数，所以扩展产品与多目标对位不兼容
						if (optionInfo.m_bEnableMutiTarget)
						{
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FACOParam.nP2);
							pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FACOParam.nP2-1;
						}
						else if ( ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension  == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
							/* ||((pOwner->m_pPlatformInfo->m_bTarCamWithDiffObjCam      == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))*/ )
						{
							CPlatformOptionInfo optionInfo;
							pOwner->GetPlatformOptionInfo(optionInfo);
							if (optionInfo.m_bAlignExProduct)
							{
								nBenchOffsetIndex = pOwner->m_XYDCommProtocol.m_FACOParam.nP2-1;
								nExProductIndex = pOwner->m_XYDCommProtocol.m_FACOParam.nP3-1;

								nParam.push_back(pOwner->m_XYDCommProtocol.m_FACOParam.nP2);
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FACOParam.nP3);
								bExProduct = TRUE;
							}

						}

						/*扩展产品序号与目标固定补偿序号共用参数，若启用扩展产品，则目标固定补偿序号与扩展产品序号为同一值，否则
						该参数单独用于目标固定补偿*/
						if (pOwner->m_pPlatformInfo->m_bTargetCalibUseBoard  == TRUE)
						{
							nTarFixOffsetIndex = pOwner->m_XYDCommProtocol.m_FACOParam.nP3-1;
							if (!bExProduct)
							{
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FACOParam.nP3);
							}

						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FACOParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FACOParam.m_strCmd, eCmdGetTargetObjectOffsetFACO);
						pOwner->OnlineAlignFACO(nOffsetIndex, nBenchOffsetIndex, nExProductIndex,nTarFixOffsetIndex);
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}
					}
					break;
				case eCmdGetObjectTargetOffsetFAAO:
					{
						int OffsetIndex = pOwner->m_XYDCommProtocol.m_FAAOParam.P1-1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAAOParam.P1);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						if(pOwner->m_XYDCommProtocol.m_FAAOParam.m_nPType == 4)
						{
							pOwner->m_bCmdParamAxisPosEanble = true;

							double dPosX  = pOwner->m_XYDCommProtocol.m_FAAOParam.P2;
							double dPosY  = pOwner->m_XYDCommProtocol.m_FAAOParam.P3;
							double dAngle = pOwner->m_XYDCommProtocol.m_FAAOParam.P4;

							dParam.push_back(dPosX);
							dParam.push_back(dPosY);
							dParam.push_back(dAngle);
						}
						else
						{
							pOwner->m_bCmdParamAxisPosEanble = false;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FAAOParam.m_strCmd,nParam,dParam);

						pOwner->OnlineAlignExFAAO(OffsetIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
					}
					break;
				case eCmdGetTargetObjectOffsetFOLC:   // 执行在线对位: AAE    // 计算偏差量 Fast：FOLC
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FOLCParam.P1 - 1;	
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FOLCParam.P1);
						if (4 == pOwner->m_XYDCommProtocol.m_FOLCParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOLCParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOLCParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FOLCParam.P4);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FOLCParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FOLCParam.m_strCmd, eCmdGetTargetObjectOffsetFOLC);
						pOwner->OnlineAlignExFOLC(nOffsetIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}						

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;
				case eCmdGetTargetObjectOffsetFABO:   // 执行在线对位: AAE    // 计算偏差量 Fast：FACO
					{				
						//pOwner->OnlineAlign();
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FABOParam.P1 - 1;	

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FABOParam.P1);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FABOParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FABOParam.m_strCmd, eCmdGetTargetObjectOffsetFABO);
						pOwner->OnlineAlignExFABO(nOffsetIndex);
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}
					}
					break;
				case eCmdOnceAlignMoveFALG:   // 执行在线对位: AAE    // 一次对位
					{				
						//pOwner->OnlineAlign();
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FALGParam.P1 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FALGParam.P1) ;

						int nReservedIndex = 10;
						int nBenchOffsetIndex = -1;
						int nExProductIndex = 0;
						int nTarFixOffsetIndex = 0;
						BOOL bExProduct = FALSE;

						//多目标对位序号与保留参数共用一个参数，所以扩展产品与多目标对位不兼容
						if (optionInfo.m_bEnableMutiTarget)
						{

							nParam.push_back(pOwner->m_XYDCommProtocol.m_FALGParam.nP2);
							pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FALGParam.nP2-1;
						}
						else if ( ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
							/*||  ((pOwner->m_pPlatformInfo->m_bTarCamWithDiffObjCam      == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))*/ )
						{
							CPlatformOptionInfo optionInfo;
							pOwner->GetPlatformOptionInfo(optionInfo);
							if (optionInfo.m_bAlignExProduct)
							{
								nReservedIndex = pOwner->m_XYDCommProtocol.m_FALGParam.nP2;
								nBenchOffsetIndex = pOwner->m_XYDCommProtocol.m_FALGParam.nP3-1;
								nExProductIndex = pOwner->m_XYDCommProtocol.m_FALGParam.nP4-1;

								nParam.push_back(pOwner->m_XYDCommProtocol.m_FALGParam.nP2);
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FALGParam.nP3);
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FALGParam.nP4);

								bExProduct = TRUE;
							}

						}

						/*扩展产品序号与目标固定补偿序号共用参数，若启用扩展产品，则目标固定补偿序号与扩展产品序号为同一值，否则
						该参数单独用于目标固定补偿*/
						if (pOwner->m_pPlatformInfo->m_bTargetCalibUseBoard  == TRUE)
						{
							nTarFixOffsetIndex = pOwner->m_XYDCommProtocol.m_FALGParam.nP4-1;
							if (!bExProduct)
							{
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FALGParam.nP4);
							}

						}
						if(pOwner->m_nMutiTargetCurIndex < 0 || pOwner->m_nMutiTargetCurIndex >= MUTITARGETMAXNUM)
						{//TT201029 防止多目标序号溢出
							pOwner->m_nMutiTargetCurIndex = 0;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FALGParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FALGParam.m_strCmd, eCmdOnceAlignMoveFALG);
						pOwner->OnlineAlignExFALG(nOffsetIndex, nReservedIndex, nBenchOffsetIndex, nExProductIndex,nTarFixOffsetIndex);
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}
					}
					break;						
				case eCmdAutoAlignFAAL:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FAAL
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;

						int nOffsetIndex = 0;
						int nReservedIndex = 10;
						int nBenchOffsetIndex = -1;
						int nExProductIndex = 0;
						int nTarFixOffsetIndex = 0;

						nOffsetIndex		= pOwner->m_XYDCommProtocol.m_FAALParam.P1 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.P1);	
						BOOL bExProduct = FALSE;
						if (!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							//1. 无协议通信,根据参数数据从后往前依次解析参数；FAAL参数格式为 FAAL P1 nP2 nP3 nP4 X Y D
							//2. 仅有P1参数分为带轴位置和不带轴位置两种，加入其它参数均必须带轴位置
							/*3. 其中nP3,nP4,nP5参数若不需要后面的参数，则可不发（如不需要nP4/nP5,则可发FAAL P1 nP2 nP3 XYD）;若需要后面的参数
							不需要前面的参数，前面的参数也要发（发什么随意）（如需要nP4不需要nP3,nP3仍然要发送，格式为FAAL P1 nP2 nP3 nP4 XYD,
							nP3可发任意值） */
							std::vector<int> nParamEx;
							switch(pOwner->m_XYDCommProtocol.m_FAALParam.m_nPType)
							{
							case 7://参数数目为7时，解析扩展产品序号、下料补偿序号和目标固定补偿序号等
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP4);
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP3);
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP2);
									// 扩展协议
									if ( ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
										/*||  ((pOwner->m_pPlatformInfo->m_bTarCamWithDiffObjCam      == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))*/ )
									{
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										if (optionInfo.m_bAlignExProduct)
										{
											nReservedIndex		= pOwner->m_XYDCommProtocol.m_FAALParam.nP2;
											nBenchOffsetIndex	= pOwner->m_XYDCommProtocol.m_FAALParam.nP3 - 1;
											nExProductIndex		= pOwner->m_XYDCommProtocol.m_FAALParam.nP4 - 1;
											bExProduct = TRUE;
										}


									}

									/*扩展产品序号与目标固定补偿序号共用参数，若启用扩展产品，则目标固定补偿序号与扩展产品序号为同一值，否则
									该参数单独用于目标固定补偿*/
									if (pOwner->m_pPlatformInfo->m_bTargetCalibUseBoard  == TRUE)
									{
										nTarFixOffsetIndex = pOwner->m_XYDCommProtocol.m_FAALParam.nP4-1;
										if (!bExProduct)
										{
											nParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP4);
										}

									}
								}
							case 5://参数数目为5时，解析多目标对位序号
								{
									if (!bExProduct)
									{
										nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP2);
										if (optionInfo.m_bEnableMutiTarget)
										{	
											pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FAALParam.nP2-1;											
										}
									}

								}
							case 4://参数数目为4时，解析拍照轴位置
								{
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.P2);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.P3);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.P4);

									pOwner->m_bCmdParamAxisPosEanble = TRUE;
								}
							}
							std::reverse(nParamEx.begin(),nParamEx.end());
							nParam.insert(nParam.end(),nParamEx.begin(),nParamEx.end());
						}
						else
						{
							//1. 寄存器通信时，每个参数都需要占一个寄存器参数位置，即使该参数不用
							//2. PLC设置参数时，在需要的参数位置设置值即可，不要的参数位置默认就行

							//多目标对位序号与其它功能共用参数，不兼容
							//解析多目标对位序号
							if (optionInfo.m_bEnableMutiTarget)
							{	
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP2);
								pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FAALParam.nP2-1;											
							}
							//解析扩展产品序号、下料补偿序号和目标固定补偿序号等
							else
							{
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP2);
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP3);
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP4);
								// 扩展协议
								if ( ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
									/*||  ((pOwner->m_pPlatformInfo->m_bTarCamWithDiffObjCam      == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))*/ )
								{
									CPlatformOptionInfo optionInfo;
									pOwner->GetPlatformOptionInfo(optionInfo);
									if (optionInfo.m_bAlignExProduct)
									{
										nReservedIndex		= pOwner->m_XYDCommProtocol.m_FAALParam.nP2;
										nBenchOffsetIndex	= pOwner->m_XYDCommProtocol.m_FAALParam.nP3 - 1;
										nExProductIndex		= pOwner->m_XYDCommProtocol.m_FAALParam.nP4 - 1;
										bExProduct = TRUE;
									}

								}

								/*扩展产品序号与目标固定补偿序号共用参数，若启用扩展产品，则目标固定补偿序号与扩展产品序号为同一值，否则
								该参数单独用于目标固定补偿*/
								if ( (pOwner->m_pPlatformInfo->m_bTargetCalibUseBoard  == TRUE) && (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate  == TRUE))
								{
									nTarFixOffsetIndex = pOwner->m_XYDCommProtocol.m_FAALParam.nP4-1;
									if (!bExProduct)
									{
										nParam.push_back(pOwner->m_XYDCommProtocol.m_FAALParam.nP4);
									}
								}
							}
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FAALParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FAALParam.m_strCmd, eCmdAutoAlignFAAL);
						pOwner->OnlineAlignExFAAL_Base(nOffsetIndex, nReservedIndex, nBenchOffsetIndex, nExProductIndex,nTarFixOffsetIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;	
				case eCmdAutoAlignFXYA:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FXYA
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FXYAParam.P1 - 1;
						int nStartPatIndex=pOwner->m_XYDCommProtocol.m_FXYAParam.P2 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FXYAParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FXYAParam.P2);

						if (5 == pOwner->m_XYDCommProtocol.m_FXYAParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FXYAParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FXYAParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FXYAParam.P5);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						if (optionInfo.m_bEnableMutiTarget)
						{
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FXYAParam.P3);
							pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FXYAParam.P3-1;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FXYAParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FXYAParam.m_strCmd, eCmdAutoAlignFXYA);
						pOwner->OnlineAlignExFXYA(nOffsetIndex,nStartPatIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;
				case eCmdOnceAlignMovePickFALP:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FALP
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FALPParam.P1 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.P1);
						pOwner->m_nPickMutiExMode = 0;/*20201020 多吸头应用多扩展模式:
													  nP2 == 0，-多吸头应用多扩展关闭；
													  nP2 == 1-99，-多吸头应用多扩展关闭，切换扩展序号；
													  nP2 == 1xx(100-199)，-多吸头应用多扩展开启；每个扩展最多计算并输出xx个结果给PLC，结果数量少于xx时，扩展拾取数据地址整体前移，xx == 00时,xx=扩展数；
													  xx == 04，2扩展3结果时的输出数据
													  地址:	0	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	32	34	36	38	40	42	44	46	48	50	52	54	56	58	
													  数据:	3	1	AX1	AY1	AD1	2	AX2	AY2	AD2	3	AX3	AY3	AD3	3	1	BX1	BY1	BD1	2	BX2	BY2	BD2	3	BX3	BY3	BD3	*	*	*	*
													  xx == 00，2扩展3结果时的输出数据(即软件配置2个扩展，拍照搜索到3个结果)
													  地址:	0	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	32	34	36	38	40	42	44	46	48	50	52	54	56	58
													  数据:	2	1	AX1	AY1	AD1	2	AX2	AY2	AD2	2	1	BX1	BY1	BD1	2	BX2	BY2	BD2	*	*	*	*	*	*	*	*	*	*	*	*	
													  xx == 00，2扩展1结果时的输出数据
													  地址:	0	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	32	34	36	38	40	42	44	46	48	50	52	54	56	58
													  数据:	1	1	AX1	AY1	AD1	1	1	BX1	BY1	BD1	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	
													  nP2 == 2xx(200-299)，-多吸头应用多扩展开启；每个扩展最多计算并输出xx个结果给PLC，结果数量少于xx时，缺失数据以0填充，扩展拾取数据地址不变，xx == 00时,xx=扩展数；
													  xx == 04，2扩展3结果时的输出数据
													  地址:	0	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	32	34	36	38	40	42	44	46	48	50	52	54	56	58	
													  数据:	3	1	AX1	AY1	AD1	2	AX2	AY2	AD2	3	AX3	AY3	AD3	0	0	0	0	3	1	BX1	BY1	BD1	2	BX2	BY2	BD2	3	BX3	BY3	BD3
													  xx == 00，2扩展3结果时的输出数据
													  地址:	0	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	32	34	36	38	40	42	44	46	48	50	52	54	56	58
													  数据:	2	1	AX1	AY1	AD1	2	AX2	AY2	AD2	2	1	BX1	BY1	BD1	2	BX2	BY2	BD2	*	*	*	*	*	*	*	*	*	*	*	*	
													  xx == 00，2扩展1结果时的输出数据
													  地址:	0	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	32	34	36	38	40	42	44	46	48	50	52	54	56	58
													  数据:	1	1	AX1	AY1	AD1	0	0	0	0	1	1	BX1	BY1	BD1	0	0	0	0	*	*	*	*	*	*	*	*	*	*	*	*	
													  nP2 == 300，-多吸头应用多扩展开启，每个扩展仅计算对应序号的搜索结果并输出，即扩展1计算输出结果1的拾取数据，扩展2计算输出结果2的拾取数据
													  2扩展3结果时的输出数据
													  地址:	0	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	32	34	36	38	40	42	44	46	48	50	52	54	56	58
													  数据:	2	1	AX1	AY1	AD1	2	BX2	BY2	BD2	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	
													  2扩展1结果时的输出数据
													  地址:	0	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	32	34	36	38	40	42	44	46	48	50	52	54	56	58
													  数据:	1	1	AX1	AY1	AD1	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*	*
													  ****AX1表示A吸头(使用扩展0标定)拾取第一个结果的轴坐标X，BY2表示B吸头(使用扩展1标定)拾取第二个结果的轴坐标Y
													  ****对于寄存器协议输出数据起始地址为备用地址+100
													  */

						if (4 == pOwner->m_XYDCommProtocol.m_FALPParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.P4);
						}
						else if (5 == pOwner->m_XYDCommProtocol.m_FALPParam.m_nPType)	// 指令参数包含轴位置
						{
							if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
							{
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								if (optionInfo.m_bAlignExProduct)
								{
									if (pOwner->m_XYDCommProtocol.m_FALPParam.nP2-1>=0 &&  pOwner->m_XYDCommProtocol.m_FALPParam.nP2-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
									{					
										// 启用扩展且参数包含扩展序号
										pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FALPParam.nP2-1);
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

									}
									else //参数异常默认参数
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
										pOwner->SetAlignExProductIndex(0);
									}
									if(pOwner->m_XYDCommProtocol.m_FALPParam.nP2 >= 100)
									{//P2大于100，多吸头应用多扩展模式
										pOwner->m_nPickMutiExMode = pOwner->m_XYDCommProtocol.m_FALPParam.nP2;
									}
								}
								else
								{
									if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
									pOwner->SetAlignExProductIndex(0);
								}
							}
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.nP2);
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.P4);
						}
						else if (2 == pOwner->m_XYDCommProtocol.m_FALPParam.m_nPType)
						{
							if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE)&& (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
							{
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								if (optionInfo.m_bAlignExProduct)
								{
									if (pOwner->m_XYDCommProtocol.m_FALPParam.nP2-1>=0 &&  pOwner->m_XYDCommProtocol.m_FALPParam.nP2-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
									{					
										// 启用扩展且参数包含扩展序号
										pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FALPParam.nP2-1);
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

									}
									else //参数异常默认参数
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
										pOwner->SetAlignExProductIndex(0);
									}
									if(pOwner->m_XYDCommProtocol.m_FALPParam.nP2 >= 100)
									{//P2大于100，多吸头应用多扩展模式
										pOwner->m_nPickMutiExMode = pOwner->m_XYDCommProtocol.m_FALPParam.nP2;
									}
								}
								else
								{
									if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
									pOwner->SetAlignExProductIndex(0);
								}
							}
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FALPParam.nP2);
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						if(pOwner->m_nPickMutiExMode == 100 ||pOwner->m_nPickMutiExMode == 200)
						{
							pOwner->m_nPickMutiExMode += sysPlatformInfo.m_nMultiCalibExtensionMaxNum + 1;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FALPParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FALPParam.m_strCmd, eCmdOnceAlignMovePickFALP);
						//						pOwner->OnlineAlignExFALP(nOffsetIndex);
						pOwner->OnlineAlignPickExFALP(nOffsetIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;
				case eCmdAutoAlignFAAB:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FAAL(增加了图像十字中心基准对位)
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FAABParam.P1 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAABParam.P1);
						if (4 == pOwner->m_XYDCommProtocol.m_FAABParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAABParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAABParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAABParam.P4);
						}
						else// 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						if (optionInfo.m_bEnableMutiTarget)
						{
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FAABParam.P2);
							pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FAABParam.P2-1;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FAABParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FAABParam.m_strCmd, eCmdAutoAlignFAAB);

						pOwner->OnlineAlignExFAAB(nOffsetIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;	
				case eCmdAutoAlignFAAC:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FAAC，对象候补搜索
					{	
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex = 0;
						int nStartPatIndex = 0;
						int nBenchOffsetIndex = -1;
						int nExProductIndex = 0;
						int nTarFixOffsetIndex = 0;
						nOffsetIndex		= pOwner->m_XYDCommProtocol.m_FAACParam.P1 - 1;
						nStartPatIndex = pOwner->m_XYDCommProtocol.m_FAACParam.P2 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.P1);	
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.P2);
						BOOL bExProduct = FALSE;
						if (!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							//1. 无协议通信,根据参数数据从后往前依次解析参数；FAAC参数格式为 FAAC P1 P2 nP3 nP4 X Y D
							//2. 仅有P1 P2参数分为带轴位置和不带轴位置两种，加入其它参数均必须带轴位置
							/*3. 其中nP3,nP4参数若不需要后面的参数，则可不发（如不需要nP4,则可发FTGC P1 P2 nP3 XYD）;若需要后面的参数
							不需要前面的参数，前面的参数也要发（发什么随意）（如需要nP4不需要nP3,nP3仍然要发送，格式为FAAC P1 P2 nP3 nP4 XYD,
							nP3可发任意值） */
							std::vector<int> nParamEx;
							switch(pOwner->m_XYDCommProtocol.m_FAACParam.m_nPType)
							{
							case 7://参数数目为7时，解析扩展产品序号、下料补偿序号和目标固定补偿序号等
								{

									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.nP4);
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.nP3);
									// 扩展协议
									if ( ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
										/*||  ((pOwner->m_pPlatformInfo->m_bTarCamWithDiffObjCam      == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))*/ )
									{
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										if (optionInfo.m_bAlignExProduct)
										{
											nBenchOffsetIndex = pOwner->m_XYDCommProtocol.m_FAACParam.nP3-1;
											nExProductIndex = pOwner->m_XYDCommProtocol.m_FAACParam.nP4-1;
											bExProduct = TRUE;
										}

									}
									/*扩展产品序号与目标固定补偿序号共用参数，若启用扩展产品，则目标固定补偿序号与扩展产品序号为同一值，否则
									该参数单独用于目标固定补偿*/
									if (pOwner->m_pPlatformInfo->m_bTargetCalibUseBoard  == TRUE)
									{
										nTarFixOffsetIndex = pOwner->m_XYDCommProtocol.m_FAACParam.nP4-1;
										if (!bExProduct)
										{
											nParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.nP4);
										}

									}
								}
							case 6://参数数目为5时，解析多目标对位序号
								{
									if (!bExProduct)
									{
										nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.nP3);
										if (optionInfo.m_bEnableMutiTarget)
										{	
											pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FAACParam.nP3-1;											
										}
									}

								}
							case 5://参数数目为4时，解析拍照轴位置
								{
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.P3);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.P4);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.P5);

									pOwner->m_bCmdParamAxisPosEanble = TRUE;
								}
							}
							std::reverse(nParamEx.begin(),nParamEx.end());
							nParam.insert(nParam.end(),nParamEx.begin(),nParamEx.end());
						}
						//解析扩展产品序号、下料补偿序号和目标固定补偿序号等
						else
						{
							//1. 寄存器通信时，每个参数都需要占一个寄存器参数位置，即使该参数不用
							//2. PLC设置参数时，在需要的参数位置设置值即可，不要的参数位置默认就行

							//多目标对位序号与其它功能共用参数，不兼容
							//解析多目标对位序号
							if (optionInfo.m_bEnableMutiTarget)
							{	
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.nP3);
								pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FAALParam.nP3-1;											
							}
							else
							{

								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.nP3);
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.nP4);
								// 扩展协议
								if ( ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
									/*||  ((pOwner->m_pPlatformInfo->m_bTarCamWithDiffObjCam      == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))*/ )
								{
									CPlatformOptionInfo optionInfo;
									pOwner->GetPlatformOptionInfo(optionInfo);
									if (optionInfo.m_bAlignExProduct)
									{
										nBenchOffsetIndex = pOwner->m_XYDCommProtocol.m_FAACParam.nP3-1;
										nExProductIndex = pOwner->m_XYDCommProtocol.m_FAACParam.nP4-1;
										bExProduct = TRUE;
									}

								}

								/*扩展产品序号与目标固定补偿序号共用参数，若启用扩展产品，则目标固定补偿序号与扩展产品序号为同一值，否则
								该参数单独用于目标固定补偿*/
								if (pOwner->m_pPlatformInfo->m_bTargetCalibUseBoard  == TRUE)
								{
									nTarFixOffsetIndex = pOwner->m_XYDCommProtocol.m_FAACParam.nP4-1;
									if (!bExProduct)
									{
										nParam.push_back(pOwner->m_XYDCommProtocol.m_FAACParam.nP4);
									}

								}
							}


						}
						if(pOwner->m_nMutiTargetCurIndex < 0 || pOwner->m_nMutiTargetCurIndex >= MUTITARGETMAXNUM)
						{//TT201029 防止多目标序号溢出
							pOwner->m_nMutiTargetCurIndex = 0;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FAACParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FAACParam.m_strCmd, eCmdAutoAlignFAAC);
						pOwner->OnlineAlignExFAAC(nOffsetIndex, nStartPatIndex, nBenchOffsetIndex, nExProductIndex,nTarFixOffsetIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;	
				case eCmdAutoAlignFAOT:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FAAC，对象候补搜索，目标候补搜索
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FAOTParam.P1 - 1;
						int nStartPatIndex=pOwner->m_XYDCommProtocol.m_FAOTParam.P2 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAOTParam.P1 );
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAOTParam.P2 );

						if (5 == pOwner->m_XYDCommProtocol.m_FAOTParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAOTParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAOTParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAOTParam.P5);
						}
						else// 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FAOTParam.m_strCmd,nParam,dParam);

						pOwner->OnlineAlignExFAOT(nOffsetIndex, nStartPatIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;	
				case eCmdAutoAlignFALX:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FALX，对象候补搜索
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FALXParam.P1 - 1;
						int nStartPatIndex=pOwner->m_XYDCommProtocol.m_FALXParam.P2 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FALXParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FALXParam.P2);

						if (5 == pOwner->m_XYDCommProtocol.m_FALXParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALXParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALXParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FALXParam.P5);
						}
						else// 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FALXParam.m_strCmd,nParam,dParam);

						pOwner->OnlineAlignExFALX(nOffsetIndex, nStartPatIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;	
				case eCmdAutoAlignFACB:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FAAC，对象候补搜索
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FACBParam.P1 - 1;
						int nStartPatIndex=pOwner->m_XYDCommProtocol.m_FACBParam.P2 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FACBParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FACBParam.P2);

						if (5 == pOwner->m_XYDCommProtocol.m_FACBParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FACBParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FACBParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FACBParam.P5);
						}
						else// 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FACBParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FACBParam.m_strCmd, eCmdAutoAlignFACB);
						if (pOwner->m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
						{
							CString strTemp;
							CString strOut;
							strOut.Format("P1:%d,P2:%d,%f,%f,%f,Type:%d",pOwner->m_XYDCommProtocol.m_FACBParam.P1,pOwner->m_XYDCommProtocol.m_FACBParam.P2,pOwner->m_XYDCommProtocol.m_FACBParam.P3,
								pOwner->m_XYDCommProtocol.m_FACBParam.P4,pOwner->m_XYDCommProtocol.m_FACBParam.P5,pOwner->m_XYDCommProtocol.m_FACBParam.m_nPType);
							strOut = strTemp + strOut;

							// 					FILE *stream;
							// 					CString strPath = m_strAlignProcessData;
							// 					stream = fopen(strPath, _T("a+t")); 					
							// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
							// 					fclose(stream);VCRemoveFile(strPath);	

							pOwner->VisionAlignLogRecord(pOwner->m_strAlignProcessData, _T("\n"), FALSE);
							pOwner->VisionAlignLogRecord(pOwner->m_strAlignProcessData, strOut);
						}

						pOwner->OnlineAlignExFACB(nOffsetIndex, nStartPatIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}

						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;	
				case eCmdAutoAlignFAHL:   // 执行在线对位: AAE	   // 自动连续对位 Fast:FAHL
					{				
						//pOwner->OnlineAlign();
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex=pOwner->m_XYDCommProtocol.m_FAHLParam.P1 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAHLParam.P1);

						if (4 == pOwner->m_XYDCommProtocol.m_FAHLParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAHLParam.P2);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAHLParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAHLParam.P4);
						}
						else // 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FAHLParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FAHLParam.m_strCmd, eCmdAutoAlignFAHL);
						////////////////////////////////bai///////////////////////
						// 这里需要判断一下执行函数是不是一次对位，
						if (pOwner->m_pPlatformInfo->m_bUseAlignFAHLex == TRUE)
						{
							// 这里根据FOBC的命令获取移动拍照代码；这里是因为PLC并没有发送对象拍照位置的数据；
							int nPosIndex = pOwner->m_XYDCommProtocol.m_FOBCParam.P1;

							pOwner->OnlineAlignExFAHLex(nOffsetIndex,nPosIndex-1);  // ture，一次对位
						}
						else
						{
							pOwner->OnlineAlignExFAHL(nOffsetIndex);    // false，不直接对位，需要先拍照
						}
						///////////////////////////////bai///////////////////////
						//pOwner->OnlineAlignExFAHL(nOffsetIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
						// 						if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
						// 						{  
						// 							if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行完对位，使用新的目标位置
						// 						}


						// 设置手动对象搜索序号
						if (pOwner->m_pPlatformInfo != NULL)
						{
							if (pOwner->m_pPlatformInfo->m_bTargetObjectCamSeparate == TRUE)
							{
								pOwner->m_nManualObjectSearchIndex = 11;
							}
							else
							{
								pOwner->m_nManualObjectSearchIndex = 4;
							}
						}
					}
					break;		
				case eCmdGetAlignResult:
					{
						CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
						pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(pOwner->GetAlignPlatformMovementResults());
						pOwner->SendDrivePlatformAxisMoveEx(pPlatformXYDAxisPos);

					}
					break;
				case eCmdResetFRST:			// 2、FRST:重新设定（清除错误等），清除各种错误及显示重新设定
					{
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FRSTParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FRSTParam.m_strCmd, eCmdResetFRST);
						pOwner->SendResetResult();
					}
					break;
				case eCmdACFInspectFCHB:  // ACF检测 FCHB
					{												
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FCHBParam.P1;
						int nStartPatIndex = pOwner->m_XYDCommProtocol.m_FCHBParam.P2;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCHBParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCHBParam.P2);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCHBParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCHBParam.m_strCmd, eCmdACFInspectFCHB);
						CPlatformOptionInfo optionInfo;
						pOwner->GetPlatformOptionInfo(optionInfo);
						pOwner->m_bSearchWithInspect = optionInfo.m_bSearchWithDistanceInspect;

						pOwner->OnlineACFInspectCandidateExFCHB(nPosIndex-1, nStartPatIndex - 1);		

						pOwner->m_bSearchWithInspect = FALSE;
					}
					break;
				case eCmdACFInspectFCHC:  // 候补ACF检测 FCHC
					{									
						pOwner->m_bObjectSearchTest = TRUE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FCHCParam.P1;
						int nStartPatIndex = pOwner->m_XYDCommProtocol.m_FCHCParam.P2;
						int nEndPatIndex = pOwner->m_XYDCommProtocol.m_FCHCParam.P3;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCHCParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCHCParam.P2);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCHCParam.P3);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCHCParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCHCParam.m_strCmd, eCmdACFInspectFCHC);
						CPlatformOptionInfo optionInfo;
						pOwner->GetPlatformOptionInfo(optionInfo);
						pOwner->m_bSearchWithInspect = optionInfo.m_bSearchWithDistanceInspect;
						pOwner->OnlineACFInspectCandidateExFCHC(nPosIndex-1, nStartPatIndex - 1, nEndPatIndex - 1);		
						pOwner->m_bObjectSearchTest = FALSE;
						pOwner->m_bSearchWithInspect = FALSE;
					}
					break;
				case eCmdFDRP:  // 计算基准拾取位置
					{												
						int nAngleIndex = pOwner->m_XYDCommProtocol.m_FDRPParam.P1;
						int nExProductIndex = 0;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						if((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension  == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
						{
							nExProductIndex = pOwner->m_XYDCommProtocol.m_FDRPParam.P2 -1;
						}

						if(nExProductIndex<0 || nExProductIndex>pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum)
						{
							nExProductIndex = 0;
						}

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FDRPParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FDRPParam.P2);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FDRPParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FDRPParam.m_strCmd, eCmdFDRP);
						pOwner->OnlineExFDRP(nAngleIndex,nExProductIndex);		
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
					}
					break;
				case eCmdSetProductExposureFSPE:     //  设置产品曝光时间 FSPE
					{	
						// 1：对象相机曝光设置；0：目标相机曝光设置；
						int nMarkType = pOwner->m_XYDCommProtocol.m_FSPEParam.P1;
						int nPosIndex= pOwner->m_XYDCommProtocol.m_FSPEParam.P2;
						int nCandIndex= pOwner->m_XYDCommProtocol.m_FSPEParam.P3;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSPEParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSPEParam.P2);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSPEParam.P3);

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FSPEParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FSPEParam.m_strCmd, eCmdSetProductExposureFSPE);
						pOwner->OnlineSetProductExposureFSPE(nMarkType, nPosIndex-1, nCandIndex-1);						

					}
					break;
				case eCmdAutoAlignFWEL:			// 专用焊接指令,,小FPC:XY,大FPC:XYD
					{
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex	= pOwner->m_XYDCommProtocol.m_FWELParam.P1 - 1;
						int nStartPatIndex	= pOwner->m_XYDCommProtocol.m_FWELParam.P2 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FWELParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FWELParam.P2);

						if (5 == pOwner->m_XYDCommProtocol.m_FWELParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;

							dParam.push_back(pOwner->m_XYDCommProtocol.m_FWELParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FWELParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FWELParam.P5);

						}
						else// 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo, pOwner->m_XYDCommProtocol.m_FWELParam.m_strCmd, nParam, dParam);
						pOwner->OnlineAlignExFWEL(nOffsetIndex, nStartPatIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;

					}
					break;
				case eCmdAutoAlignFSOL:			// 专用焊接指令,小FPC:XYD,大FPC:XY
					{
						pOwner->m_bAutoAlign = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nOffsetIndex	= pOwner->m_XYDCommProtocol.m_FSOLParam.P1 - 1;
						int nStartPatIndex	= pOwner->m_XYDCommProtocol.m_FSOLParam.P2 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSOLParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FSOLParam.P2);

						if (5 == pOwner->m_XYDCommProtocol.m_FSOLParam.m_nPType)	// 指令参数包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;

							dParam.push_back(pOwner->m_XYDCommProtocol.m_FSOLParam.P3);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FSOLParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FSOLParam.P5);

						}
						else// 指令参数不包含轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo, pOwner->m_XYDCommProtocol.m_FSOLParam.m_strCmd, nParam, dParam);
						pOwner->OnlineAlignExFSOL(nOffsetIndex, nStartPatIndex);

						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bAutoAlign = FALSE;
					}
					break;
				case eCmdInspectFINS:     //  检测产品有无
					{	
						// 1：对象相机产品检测；0：目标相机产品检测；
						int nMarkType = pOwner->m_XYDCommProtocol.m_FINSParam.P1;
						int nPosIndex= pOwner->m_XYDCommProtocol.m_FINSParam.P2;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FINSParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FINSParam.P2);

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FINSParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FINSParam.m_strCmd, eCmdInspectFINS);
						pOwner->OnlineProductInspectFINS(nMarkType, nPosIndex-1, 0);						

					}
					break;
				case eCmdSetProductName:
					{
						pOwner->OnlineSetProductName(strReceive);
					}
					break;
				case eCmdSetProductIndex:
					{
						pOwner->OnlineSetProductIndex(strReceive);
					}
					break;

				case eCmdSetTargetBench:
					{
						pOwner->ExecuteTargetBenchMarkFixed();
					}
					break;
				case  eCmdSpecialCommFCHK:
					{
						int nRecNum = pOwner->m_XYDCommProtocol.m_FCHKParam.P1;
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCHKParam.m_strCmd, eCmdSpecialCommFCHK);
						if (nRecNum ==10)
						{
							bSpecialCommSuccess = TRUE;
							pOwner->SendCommResultFCHK();
						}
					}
					break;
				case eCmdGetSearchWorldPosFWLD:
					{
						int nMarkType = pOwner->m_XYDCommProtocol.m_FWLDParam.P1;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FWLDParam.P2 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FWLDParam.P1 );
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FWLDParam.P2 );
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FWLDParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FWLDParam.m_strCmd, eCmdGetSearchWorldPosFWLD);
						pOwner->OnlineGetSearchWorldPosFWLD(nPosIndex, nMarkType);
					}
					break;
				case eCmdFWDR:
					{
						int nMarkType = pOwner->m_XYDCommProtocol.m_FWDRParam.P1;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FWDRParam.P2 - 1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FWDRParam.P1 );
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FWDRParam.P2 );
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FWDRParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FWDRParam.m_strCmd, eCmdFWDR);
						pOwner->OnlineGetSearchWorldRadiusFWDR(nPosIndex, nMarkType);
					}
					break;
				case eCmdGetObjectWorldPosFGOW:  // FGOW:拍照取得对象（对象靶标）的平台坐标上的位置
					{
						pOwner->m_bObjectSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = 0;
						if (5 == pOwner->m_XYDCommProtocol.m_FGOWParam.m_nPType)	// 指令参数包含候轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGOWParam.P1 - 1;
							int nPatIndex = pOwner->m_XYDCommProtocol.m_FGOWParam.P2 - 1;
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGOWParam.P1 );
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGOWParam.P2 );
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGOWParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGOWParam.m_strCmd, eCmdGetObjectWorldPosFGOW);
							if (nPatIndex < 0)
							{
								pOwner->OnlineAlnSearchExFGOW(nPosIndex, 0);
							}
							else
							{
								pOwner->OnlineAlnSearchExFGOW(nPosIndex, nPatIndex);
							}
						}
						else if (2 == pOwner->m_XYDCommProtocol.m_FGOWParam.m_nPType)	// 指令参数不包含候轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGOWParam.P1 - 1;
							int nPatIndex = pOwner->m_XYDCommProtocol.m_FGOWParam.P2 - 1;	
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGOWParam.P1 );
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGOWParam.P2 );
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGOWParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGOWParam.m_strCmd, eCmdGetObjectWorldPosFGOW);
							if (nPatIndex < 0)
							{
								pOwner->OnlineAlnSearchExFGOW(nPosIndex, 0);
							}
							else
							{
								pOwner->OnlineAlnSearchExFGOW(nPosIndex, nPatIndex);
							}
						}
						else // 指令参数不包含候补模板编号
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;

							nPosIndex = pOwner->m_XYDCommProtocol.m_FGOWParam.P1 - 1;
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGOWParam.P1 );
							//nParam.push_back(pOwner->m_XYDCommProtocol.m_FGOWParam.P2 );
							pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGOWParam.m_strCmd,nParam,dParam);
							pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGOWParam.m_strCmd, eCmdGetObjectWorldPosFGOW);
							pOwner->OnlineAlnSearchExFGOW(nPosIndex, 0);
						}



						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						pOwner->m_bObjectSearchTest = FALSE;

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;

					}
					break;
				case eCmdGetTargetPlatformPosFGTW:  // FGTW:拍照取得目标（目标靶标）的平台坐标和轴位置
					{
						pOwner->m_bTargetSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FGTWParam.P1 - 1;
						int nStartPatIndex = pOwner->m_XYDCommProtocol.m_FGTWParam.P2 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.P1 );
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.P2 );
						if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
						if(!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							//1. 无协议通信,根据参数数据从后往前依次解析参数；FGTW参数格式为 FGTW P1 P2 nP3 nP4 nP5 X Y D
							//2. 仅有P1 P2参数分为带轴位置和不带轴位置两种，加入其它参数均必须带轴位置
							/*3. 其中nP3,nP4,nP5参数若不需要后面的参数，则可不发（如不需要nP4/nP5,则可发FGTW P1 P2 nP3 XYD）;若需要后面的参数
							不需要前面的参数，前面的参数也要发（发什么随意）（如需要nP4不需要nP3、nP5,nP3仍然要发送，格式为FGTW P1 P2 nP3 nP4 XYD,
							nP3可发任意值） */
							std::vector<int> nParamEx;
							switch(pOwner->m_XYDCommProtocol.m_FGTWParam.m_nPType)
							{
							case 8://参数数目为8时，最后一个参数为保留参数，暂未使用
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.nP5);
									if (0/*保留*/)//占位
									{
									}
								}
							case 7://参数数目为8、7时，解析扩展产品序号
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.nP4);
									if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1) )
									{		
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										if (optionInfo.m_bTargetSearchExProduct)
										{
											if (pOwner->m_XYDCommProtocol.m_FGTWParam.nP4-1>=0 &&  pOwner->m_XYDCommProtocol.m_FGTWParam.nP4-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
											{					
												// 启用扩展且参数包含扩展序号
												pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FGTWParam.nP4-1);
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

											}
											else if (pOwner->m_XYDCommProtocol.m_FGTWParam.nP4 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FGTWParam.nP4-1 <= 103)
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FGTWParam.nP4 -1;
											}
											else //参数异常默认参数
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
												pOwner->SetAlignExProductIndex(0);
											}
										}
										else
										{
											if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
											pOwner->SetAlignExProductIndex(0);
										}
									}

								}
							case 6://参数数量为8、7、6时，解析是否拍照并检测或多目标对位
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.nP3);
									if (optionInfo.m_bEnableMutiTarget)
									{	
										pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FGTWParam.nP3-1;											
									}
									else//是否检测//这两者不兼容 
									{
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FGTWParam.nP3 && optionInfo.m_bSearchWithDistanceInspect;
									}
								}
							case 5://参数数量为8、7、6、5时，解析轴位置
								{
									pOwner->m_bCmdParamAxisPosEanble = TRUE;
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.P3);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.P4);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.P5);
								}

							}
							std::reverse(nParamEx.begin(),nParamEx.end());//因为参数是从后往前排的，这里需要反序
							nParam.insert(nParam.end(),nParamEx.begin(),nParamEx.end());
						}
						else
						{
							//1. 寄存器通信时，每个参数都需要占一个寄存器参数位置，即使该参数不用
							//2. PLC设置参数时，在需要的参数位置设置值即可，不要的参数位置默认就行

							//解析是否检测或者多目标对位序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.nP3);
							if (optionInfo.m_bEnableMutiTarget)
							{		
								pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FGTWParam.nP3-1;											
							}
							else//是否检测//这两者不兼容 //占位
							{
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FGTWParam.nP3 && optionInfo.m_bSearchWithDistanceInspect;
							}

							//解析扩展产品序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.nP4);
							if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
							{	
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								if (optionInfo.m_bTargetSearchExProduct)
								{
									if (pOwner->m_XYDCommProtocol.m_FGTWParam.nP4-1>=0 &&  pOwner->m_XYDCommProtocol.m_FGTWParam.nP4-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
									{					
										// 启用扩展且参数包含扩展序号	
										pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FGTWParam.nP4-1);
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

									}
									else if (pOwner->m_XYDCommProtocol.m_FGTWParam.nP4 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FGTWParam.nP4-1 <= 103)
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FGTWParam.nP4 -1;
									}
									else //参数异常默认参数
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
										pOwner->SetAlignExProductIndex(0);
									}
								}
								else
								{
									if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
									pOwner->SetAlignExProductIndex(0);
								}
							}


							//保留参数，暂未使用
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTWParam.nP5);
							if (0/*保留*/)//
							{
							}
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGTWParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGTWParam.m_strCmd, eCmdGetTargetPlatformPosFGTW);
						pOwner->OnlineAlnSearchExFGTW(nPosIndex,nStartPatIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;
						pOwner->m_bTargetSearchTest = FALSE;

					}
					break;
				case eCmdGetTargetImagePosFGTP:  // FGTW:拍照取得目标（目标靶标）的图像坐标和轴位置
					{
						pOwner->m_bTargetSearchTest = TRUE;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FGTPParam.P1 - 1;
						int nStartPatIndex = pOwner->m_XYDCommProtocol.m_FGTPParam.P2 - 1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.P1 );
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.P2 );

						if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
						if(!pOwner->m_XYDCommProtocol.IsPlcProtocolType())
						{
							//1. 无协议通信,根据参数数据从后往前依次解析参数；FGTP参数格式为 FGTP P1 P2 nP3 nP4 nP5 X Y D
							//2. 仅有P1 P2参数分为带轴位置和不带轴位置两种，加入其它参数均必须带轴位置
							/*3. 其中nP3,nP4,nP5参数若不需要后面的参数，则可不发（如不需要nP4/nP5,则可发FGTP P1 P2 nP3 XYD）;若需要后面的参数
							不需要前面的参数，前面的参数也要发（发什么随意）（如需要nP4不需要nP3、nP5,nP3仍然要发送，格式为FGTP P1 P2 nP3 nP4 XYD,
							nP3可发任意值） */
							std::vector<int> nParamEx;
							switch(pOwner->m_XYDCommProtocol.m_FGTPParam.m_nPType)
							{
							case 8://参数数目为8时，最后一个参数为保留参数，暂未使用
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.nP5);
									if (0/*保留*/)//占位
									{
									}
								}
							case 7://参数数目为8、7时，解析扩展产品序号
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.nP4);
									if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
									{	
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										if (optionInfo.m_bTargetSearchExProduct)
										{
											if (pOwner->m_XYDCommProtocol.m_FGTPParam.nP4-1>=0 &&  pOwner->m_XYDCommProtocol.m_FGTPParam.nP4-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
											{					
												// 启用扩展且参数包含扩展序号
												pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FGTPParam.nP4-1);
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

											}
											else if (pOwner->m_XYDCommProtocol.m_FGTPParam.nP4 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FGTPParam.nP4-1 <= 103)
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FGTPParam.nP4 -1;
											}
											else //参数异常默认参数
											{
												if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
												pOwner->SetAlignExProductIndex(0);
											}
										}
										else
										{
											if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
											pOwner->SetAlignExProductIndex(0);
										}
									}

								}
							case 6://参数数量为8、7、6时，解析是否拍照并检测或多目标对位
								{
									nParamEx.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.nP3);
									if (optionInfo.m_bEnableMutiTarget)
									{	
										pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FGTPParam.nP3-1;											
									}
									else//是否检测//这两者不兼容 
									{
										CPlatformOptionInfo optionInfo;
										pOwner->GetPlatformOptionInfo(optionInfo);
										pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FGTPParam.nP3 && optionInfo.m_bSearchWithDistanceInspect;
									}
								}
							case 5://参数数量为8、7、6、5时，解析轴位置
								{
									pOwner->m_bCmdParamAxisPosEanble = TRUE;
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.P3);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.P4);
									dParam.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.P5);
								}

							}
							std::reverse(nParamEx.begin(),nParamEx.end());//因为参数是从后往前排的，这里需要反序
							nParam.insert(nParam.end(),nParamEx.begin(),nParamEx.end());
						}
						else
						{
							//1. 寄存器通信时，每个参数都需要占一个寄存器参数位置，即使该参数不用
							//2. PLC设置参数时，在需要的参数位置设置值即可，不要的参数位置默认就行

							//解析是否检测或者多目标对位序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.nP3);
							if (optionInfo.m_bEnableMutiTarget)
							{		
								pOwner->m_nMutiTargetCurIndex=pOwner->m_XYDCommProtocol.m_FGTPParam.nP3-1;											
							}
							else//是否检测//这两者不兼容 //占位
							{
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								pOwner->m_bSearchWithInspect = pOwner->m_XYDCommProtocol.m_FGTPParam.nP3 && optionInfo.m_bSearchWithDistanceInspect;
							}

							//解析扩展产品序号参数
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.nP4);							
							if ((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1))
							{	
								CPlatformOptionInfo optionInfo;
								pOwner->GetPlatformOptionInfo(optionInfo);
								if (optionInfo.m_bTargetSearchExProduct)
								{
									if (pOwner->m_XYDCommProtocol.m_FGTPParam.nP4-1>=0 &&  pOwner->m_XYDCommProtocol.m_FGTPParam.nP4-1 <= pOwner->m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1)
									{					
										// 启用扩展且参数包含扩展序号	
										pOwner->SetAlignExProductIndex(pOwner->m_XYDCommProtocol.m_FGTPParam.nP4-1);
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;

									}
									else if (pOwner->m_XYDCommProtocol.m_FGTPParam.nP4 -1>=99 &&  pOwner->m_XYDCommProtocol.m_FGTPParam.nP4-1 <= 103)
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = TRUE;
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_nCombinationCode = pOwner->m_XYDCommProtocol.m_FGTPParam.nP4 -1;
									}
									else //参数异常默认参数
									{
										if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
										pOwner->SetAlignExProductIndex(0);
									}
								}
								else
								{
									if (NULL != pOwner->m_pAlignerTool) pOwner->m_pAlignerTool->m_bEnableMultiCombinationCode = FALSE;
									pOwner->SetAlignExProductIndex(0);
								}
							}


							//保留参数，暂未使用
							nParam.push_back(pOwner->m_XYDCommProtocol.m_FGTPParam.nP5);
							if (0/*保留*/)//
							{
							}
						}

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FGTPParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FGTPParam.m_strCmd, eCmdGetTargetImagePosFGTP);
						pOwner->OnlineAlnSearchExFGTP(nPosIndex,nStartPatIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;

						// 设置手动目标搜索序号
						pOwner->m_nManualTargetSearchIndex = nPosIndex;
						pOwner->m_bTargetSearchTest = FALSE;

					}
					break;
				case eCmdCalibrateFCBR:     // 1、FCBR:关联Calibration 的执行 执行Calibration
					{
						double dPlatformPos1X = pOwner->m_XYDCommProtocol.m_FCBRParam.P1;
						double dPlatformPos1Y = pOwner->m_XYDCommProtocol.m_FCBRParam.P2;
						double dPlatformPos2X = pOwner->m_XYDCommProtocol.m_FCBRParam.P3;
						double dPlatformPos2Y = pOwner->m_XYDCommProtocol.m_FCBRParam.P4;

						dParam.push_back(dPlatformPos1X);
						dParam.push_back(dPlatformPos1Y);
						dParam.push_back(dPlatformPos2X);
						dParam.push_back(dPlatformPos2Y);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCBRParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCBRParam.m_strCmd, eCmdCalibrateFCBR);
						pOwner->OnlineFCBRCalibrate(dPlatformPos1X, dPlatformPos1Y, dPlatformPos2X, dPlatformPos2Y);
					}
					break;
				case eCmdObjTarSearchFPCB: 
					{
						// 1：对象相机定位；2：目标相机定位；3：目标、对象同时定位
						int nMarkType= pOwner->m_XYDCommProtocol.m_FPCBParam.P1;	

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPCBParam.P1);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FPCBParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FPCBParam.m_strCmd, eCmdObjTarSearchFPCB);
						pOwner->OnSerialObjTarSearchCandidateExFPCB(nMarkType);


						// 						// 设置手动对象搜索序号
						// 						pOwner->m_nManualObjectSearchIndex = 5;
						// 						pOwner->m_nManualTargetSearchIndex = 5;

					}
					break;

				case eCmdPCBPrecisionFPIS:
					{
						// 						int nInspectIndex= pOwner->m_XYDCommProtocol.m_FPISParam.P1-1;
						// 						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPISParam.P1);
						// 
						// 						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FPISParam.m_strCmd,nParam,dParam);
						// 						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FPISParam.m_strCmd, eCmdPCBPrecisionFPIS);
						// 						pOwner->OnlineSetPCBPrecisionFPIS(nInspectIndex);	

					}
					break;
				case eCmdChangePlatformIndex:     //  切换工位号
					{				   
						int nPlatformIndex = pOwner->m_XYDCommProtocol.m_FCPIParam.P1;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FCPIParam.P1);

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FCPIParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FCPIParam.m_strCmd, eCmdChangePlatformIndex);
						pOwner->OnlineSetPCBPrecisionFCPI(nPlatformIndex);					

					}
					break;
				case eCmdSaveQRCode:
					{
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FQRCParam.m_strCmd,nParam,dParam);
						pOwner->OnlineSaveQRCode();
					}					
					break;
				case eCmdInspectQRCode:
					{
						int nPosIndex= pOwner->m_XYDCommProtocol.m_FQRIParam.P1;
						int nPatIndex = pOwner->m_XYDCommProtocol.m_FQRIParam.P2;

						nParam.push_back(pOwner->m_XYDCommProtocol.m_FQRIParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FQRIParam.P2);

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FQRIParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FQRIParam.m_strCmd, eCmdInspectQRCode);
						pOwner->OnlineInspectQRCode(nPosIndex-1, nPatIndex-1);	

					}
					break;
				case eCmdFAFO:
					{
						int nType = pOwner->m_XYDCommProtocol.m_FAFOParam.P1;
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
						int nPosIndex = pOwner->m_XYDCommProtocol.m_FAFOParam.P2;
						int nOffsetIndex = pOwner->m_XYDCommProtocol.m_FAFOParam.P3;
						int nExProductIndex = 0;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P2);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P3);
						if((pOwner->m_pPlatformInfo->m_bEnableMultiCalibExtension == TRUE) && (pOwner->m_pVisionASMConfig->m_CommParamInfo.m_eExProtocolType == eExProReserved1)) 
						{
							if (4 == pOwner->m_XYDCommProtocol.m_FAFOParam.m_nPType)	// 指令参数包含候轴位置
							{
								pOwner->m_bCmdParamAxisPosEanble = FALSE;
								nExProductIndex = pOwner->m_XYDCommProtocol.m_FAFOParam.nP4-1;
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.nP4);

							}
							if (7 == pOwner->m_XYDCommProtocol.m_FAFOParam.m_nPType)	// 指令参数包含候轴位置
							{
								pOwner->m_bCmdParamAxisPosEanble = TRUE;
								nExProductIndex = pOwner->m_XYDCommProtocol.m_FAFOParam.nP4-1;
								nParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.nP4);
								dParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P4);
								dParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P5);
								dParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P6);
							}

						}
						if (6 == pOwner->m_XYDCommProtocol.m_FAFOParam.m_nPType)	// 指令参数包含候轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = TRUE;

							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P4);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P5);
							dParam.push_back(pOwner->m_XYDCommProtocol.m_FAFOParam.P6);
						}
						else// 指令参数不包含候轴位置
						{
							pOwner->m_bCmdParamAxisPosEanble = FALSE;

						}
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FAFOParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FAFOParam.m_strCmd, eCmdFAFO);
						pOwner->OnlineCalTargetFixOffsetFAFO(nType,nPosIndex-1,nOffsetIndex-1,nExProductIndex);
						pOwner->m_bCmdParamAxisPosEanble = FALSE;
					}
					break;
				case eCmdGetTargetObjectOffsetFMCO:
					{
						int nOffsetCount= pOwner->m_XYDCommProtocol.m_FMCOParam.P1;
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FMCOParam.P1);

						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FMCOParam.m_strCmd,nParam,dParam);

						// 对指令参数进行限制 处理负数指令参数
						if (nOffsetCount<1)
						{
							nOffsetCount = abs(nOffsetCount);
						}

						pOwner->OnlineAlignExFMCO(nOffsetCount);	

					}
					break;
				case eCmdProductEmptyPEP: // 产品清空
					{
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPEPParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPEPParam.P2);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FPEPParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FPEPParam.m_strCmd, eCmdProductEmptyPEP);

						int nProductIndexFa = pOwner->m_XYDCommProtocol.m_FPEPParam.P1 -1;
						int nProductIndexChd = pOwner->m_XYDCommProtocol.m_FPEPParam.P2 - 1;
						pOwner->OnlineProductEmptyFPEP(nProductIndexFa, nProductIndexChd);
					}
					break;
				case eCmdProductCopyFPCP: // 产品复制
					{
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPCPParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPCPParam.P2);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPCPParam.P3);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPCPParam.P4);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FPCPParam.m_strCmd,nParam,dParam);
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_FPCPParam.m_strCmd, eCmdProductCopyFPCP);

						int nSrcProductIndexFa = pOwner->m_XYDCommProtocol.m_FPCPParam.P1 - 1;
						int nSrcProductIndexChd = pOwner->m_XYDCommProtocol.m_FPCPParam.P2 - 1;
						int nDstProductIndexFa = pOwner->m_XYDCommProtocol.m_FPCPParam.P3 - 1;
						int nDstProductIndexChd = pOwner->m_XYDCommProtocol.m_FPCPParam.P4 - 1;
						pOwner->OnlineProductCopyFPCP(nSrcProductIndexFa, nSrcProductIndexChd, nDstProductIndexFa, nDstProductIndexChd);
					}
					break;
				case eCmdProductRenameFPRN: // 产品重命名
					{
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPRNParam.P1);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPRNParam.P2);
						nParam.push_back(pOwner->m_XYDCommProtocol.m_FPRNParam.P3);
						pOwner->PackAndAddCommSimpleInfo(strInfo,pOwner->m_XYDCommProtocol.m_FPRNParam.m_strCmd,nParam,dParam);

						int nProductIndexFa = pOwner->m_XYDCommProtocol.m_FPRNParam.P1 -1;
						int nProductIndexChd = pOwner->m_XYDCommProtocol.m_FPRNParam.P2 - 1;
						int nProductNameLength = pOwner->m_XYDCommProtocol.m_FPRNParam.P3;
						pOwner->OnlineProductRenameFPRN(nProductIndexFa, nProductIndexChd, nProductNameLength);

					}
					break;
				case eCmdUnknow:
					{
						pOwner->m_strStatusBarInfo1 = GetSysInfoString(pOwner->m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
						pOwner->m_strStatusBarInfo2 = GetSysInfoString(pOwner->m_psaSysInfoStrings, IDS_WARNING_COMMUNICATION_UNKNOWN);;
						pOwner->SetStatusBarInfo(FALSE, pOwner->m_strStatusBarInfo1, pOwner->m_strStatusBarInfo2);
						pOwner->PostMessageUpdateStatusBarInfo();
						pOwner->SetCommCommandName(pOwner->m_XYDCommProtocol.m_strCmdName, eCmdUnknow);
						CString strCmdName = _T("");
						pOwner->GetCommCommandName(strCmdName);
						pOwner->AddWarningInfo(pOwner->m_strStatusBarInfo1, (strCmdName + pOwner->m_strStatusBarInfo2));
					}
					break;

				default:
					break;
				}			
				pOwner->SaveImageIndexInfo();
				if (pOwner->m_XYDCommProtocol.IsPlcProtocolType())	// 如果是PLC直接读取存储寄存器协议
				{
					// 如果是共享的通信接口
					if (eShareCommNo != pOwner->GetShareCommType())
					{

						if (!pOwner->IsShareCommPlatformParalle() && pOwner->IsShareCommCurPlatform())	// 如果得到令牌
						{
							// 如果收到触发指令，根据指令进行处理完成后，交出令牌给下一个平台
							pOwner->ShareCommNextPlatform();
						}	
					}
				}				


			} // if
		}
		else
		{
			// 设置重新运行时，加载配置
			bReLoadPlatformOptionInfo = TRUE;

			if (pOwner->m_XYDCommProtocol.IsPlcProtocolType() && FALSE == bWrtWorkStatus 
				&& TRUE == optionInfo.m_bVisionOnLineStatus)	// 如果是PLC直接读取存储寄存器协议
			{
				////设定软件挂起标识
				//CString strSend;
				//pOwner->m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend,eVsDisconneted);
				//CommStatus nCommStatus = eCommSucceed;
				//CString strInfoStatus;
				//pOwner->CommunicateSendWriteRegStr(strSend, strInfoStatus, nCommStatus);
				//bWrtWorkStatus = TRUE;

				//设定软件挂起标识
				// 如果是共享的通信接口
				if (eShareCommSrc == pOwner->GetShareCommType())
				{
					if (pOwner->IsShareCommPlatformParalle())
					{
						//设定软件挂起标识
						CString strSend;
						pOwner->m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend,eVsDisconneted);
						CommStatus nCommStatus = eCommSucceed;
						CString strInfoStatus;
						pOwner->CommunicateSendWriteRegStr(strSend, strInfoStatus, nCommStatus);
					}
					else
					{
						pOwner->m_ShareCommInfoArray.SetCurCommPlatformIndex(pOwner->GetSysPlatformIndex(), pOwner->GetSysPlatformIndex(), FALSE);
						if (pOwner->IsShareCommCurPlatform())	// 如果得到令牌
						{
							//设定软件挂起标识
							CString strSend;
							pOwner->m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend,eVsDisconneted);
							CommStatus nCommStatus = eCommSucceed;
							CString strInfoStatus;
							pOwner->CommunicateSendWriteRegStr(strSend, strInfoStatus, nCommStatus);
						}
						pOwner->m_ShareCommInfoArray.SetCurCommPlatformIndex(pOwner->GetSysPlatformIndex(), pOwner->GetSysPlatformIndex(), TRUE);
					}
				}
				else if (eShareCommNo == pOwner->GetShareCommType())
				{
					//设定软件挂起标识
					CString strSend;
					pOwner->m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend,eVsDisconneted);
					CommStatus nCommStatus = eCommSucceed;
					CString strInfoStatus;
					pOwner->CommunicateSendWriteRegStr(strSend, strInfoStatus, nCommStatus);
				}
				bWrtWorkStatus = TRUE;
			}
		}
		pOwner->m_bCurThreadWorkFinished = TRUE;
		Sleep(1);
		//WaitForSingleObject(hEvent,1);

	}// while

	if (pOwner->m_XYDCommProtocol.IsPlcProtocolType() && TRUE == optionInfo.m_bVisionOnLineStatus)	// 如果是PLC直接读取存储寄存器协议
	{
		////设定软件退出标识
		//CString strSend;
		//pOwner->m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend,eVsCloseSoft);
		//CommStatus nCommStatus = eCommSucceed;
		//CString strInfoStatus;
		//pOwner->CommunicateSendWriteRegStr(strSend, strInfoStatus, nCommStatus);

		//设定软件挂起标识
		// 如果是共享的通信接口
		if (eShareCommSrc == pOwner->GetShareCommType())
		{
			if (pOwner->IsShareCommPlatformParalle())
			{
				//设定软件退出标识
				CString strSend;
				pOwner->m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend,eVsCloseSoft);
				CommStatus nCommStatus = eCommSucceed;
				CString strInfoStatus;
				pOwner->CommunicateSendWriteRegStr(strSend, strInfoStatus, nCommStatus);
			}
			else
			{
				pOwner->m_ShareCommInfoArray.SetCurCommPlatformIndex(pOwner->GetSysPlatformIndex(), pOwner->GetSysPlatformIndex(), FALSE);
				if (pOwner->IsShareCommCurPlatform())	// 如果得到令牌
				{
					//设定软件退出标识
					CString strSend;
					pOwner->m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend,eVsCloseSoft);
					CommStatus nCommStatus = eCommSucceed;
					CString strInfoStatus;
					pOwner->CommunicateSendWriteRegStr(strSend, strInfoStatus, nCommStatus);
				}
				pOwner->m_ShareCommInfoArray.SetCurCommPlatformIndex(pOwner->GetSysPlatformIndex(), pOwner->GetSysPlatformIndex(), TRUE);
			}
		}
		else if (eShareCommNo == pOwner->GetShareCommType())
		{
			//设定软件退出标识
			CString strSend;
			pOwner->m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend,eVsCloseSoft);
			CommStatus nCommStatus = eCommSucceed;
			CString strInfoStatus;
			pOwner->CommunicateSendWriteRegStr(strSend, strInfoStatus, nCommStatus);
		}
	}
	// 	CloseHandle(hEvent);
	// 	hEvent = NULL;
	pOwner->m_bExitWorkThreaded = TRUE;


	return 0;	
}

// 工作线程：提取通信接口的命令信息，解析命令信息，执行相应的处理（对象搜索、目标搜索、标定、对位、错误命令）
// 在处理过程中，还会有其他一些命令（命令包括命令及命令响应，指定平台运动的命令、获取平台位置的命令、指定相机平台运动的命令、获取相机平台位置的命令）

// 挂起工作线程(一个流程走完，再进入等待状态)（与主界面交互）
BOOL vcXYDVisionAlign::SuspendWorkThread()
{
	BOOL bRet = vcBaseVisionAlign::SuspendWorkThread();
	// 等待线程挂起之后再修改相机属性，在配置为触发模式时，修改相机为非触发模式（连续采集模式）
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	if (sysPlatformInfo.m_bCameraHardTriggerMode)
	{
		SetCameraTriggerMode(ePTNotTrigger);
	}
	return bRet;
}

// 恢复工作线程（与主界面交互）
BOOL vcXYDVisionAlign::ResumeWorkThread()
{
	// 平台配置为硬触发模式时，线程启动前，先将相机修改为硬触发模式
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	if (sysPlatformInfo.m_bCameraHardTriggerMode)
	{
		SetCameraTriggerMode(ePTHardwareTrigger);
	}
	return vcBaseVisionAlign::ResumeWorkThread();
}

// 平台的处理控制运动流程如何抽象呢？


// 接收命令，进行相应的定位操作（定位、定位结果图形显示、状态显示，记录目标位置到对位工具），返回命令响应
BOOL vcXYDVisionAlign::OnlineAlnTargetSearchExFTGT(int nPosIndex)
{
	CString strCmd = _T("VTGT:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	m_nCheckTargetDistanceIndex = 0;

	// 	if (m_pPlatformInfo->m_bTarCamWithDiffObjCam && m_pPlatformInfo->m_bTargetObjectCamSeparate)
	// 	{
	// // 		if (nPosIndex>=0 && nPosIndex <= 3)	//编号0～3的相机中的一个
	// // 		{
	// // 			m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFTGT(nPosIndex);
	// // 		}
	// 
	// 		// 目标位置5+位置6
	// 		if (nPosIndex == 19)
	// 		{
	// 			// 计算产品尺寸的时候用到该参数
	// 			SetAlignExProductIndex(0);
	// 
	// 			// 隐藏对象1、对象2结果图形			
	// 			int nPosNum = m_pPlatformInfo->m_nPositionNum;
	// 			std::vector<int> vnObjectPosIndex;
	// 			int nObjectPosIndex = 0;
	// 			int i = 0;
	// 			for(i = 0; i < nPosNum/4; i++)
	// 			{
	// 				nObjectPosIndex = i;
	// 				vnObjectPosIndex.push_back(nObjectPosIndex);
	// 			}	
	// // 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// // 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
	// 			m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);
	// 
	// 			SetDefaultTargetSearchMarkPos(TRUE, nPosIndex);
	// 
	// 			std::vector<int> vnPosIndex;
	// 			int nPosIndex = 0;
	// 			for(int i = 0; i < GetPosNum()/4; i++)
	// 			{
	// 				nPosIndex = i + GetPosNum()/2;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT(vnPosIndex);
	// 		}
	// 		// 目标位置7+位置8
	// 		else if (nPosIndex == 20)
	// 		{
	// 			// 计算产品尺寸的时候用到该参数
	// 			SetAlignExProductIndex(1);
	// 
	// 			// 隐藏对象结果图形			
	// 			int nPosNum = m_pPlatformInfo->m_nPositionNum;
	// 			std::vector<int> vnObjectPosIndex;
	// 			int nObjectPosIndex = 0;
	// 			int i = 0;
	// 			for(i = nPosNum/4; i < nPosNum/2; i++)
	// 			{
	// 				nObjectPosIndex = i;
	// 				vnObjectPosIndex.push_back(nObjectPosIndex);
	// 			}	
	// // 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// // 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
	// 			m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);
	// 
	// 
	// 			SetDefaultTargetSearchMarkPos(TRUE, nPosIndex);
	// 
	// 			std::vector<int> vnPosIndex;
	// 			int nPosIndex = 0;
	// 			for(int i = 0; i < GetPosNum()/4; i++)
	// 			{
	// 				nPosIndex = (i+GetPosNum()/4) + GetPosNum()/2;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT(vnPosIndex);
	// 		}
	// 
	// 		return m_bTargetMarkSearchSucceed;
	// 	}

	// 隐藏对象结果图形			
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	std::vector<int> vnObjectPosIndex;
	int nObjectPosIndex = 0;
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nObjectPosIndex = i;
		vnObjectPosIndex.push_back(nObjectPosIndex);
	}	
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// //	if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnObjectPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);


	if (nPosIndex == 19)
	{
		m_nCheckTargetDistanceIndex = 19;
	}
	else if (nPosIndex == 20)
	{
		m_nCheckTargetDistanceIndex = 20;
	}
	SetDefaultTargetSearchMarkPos(TRUE);

	if (nPosIndex>=0 && nPosIndex <= 3)	//编号0～3的相机中的一个
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFTGT(nPosIndex);
	}
	else if(nPosIndex==4)	// 所有相机
	{
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT();
	}
	else if (nPosIndex>=9 && nPosIndex<=10 ) //编号2～3的相机中的一个
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFTGT(nPosIndex - 7);
	}
	else if (nPosIndex==11) // 所有相机中的后一半编号
	{
		// 兼容凯达扬2VS4的拍照模式
		if (optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
		{
			int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);

			if (pCurProductData == NULL)
			{
				return FALSE;
			}


			std::vector<int> vnPosIndex;
			int nTargetVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode;
			BOOL bEnableTargetPositionVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode;

			if (bEnableTargetPositionVirtualMode)
			{
				switch(nTargetVirtualMode)
				{
				case 0:
					{
						// 位置5、位置6
						vnPosIndex.push_back(4);
						vnPosIndex.push_back(5);

					}
					break;

				case 1:
					{
						// 位置7、位置8
						vnPosIndex.push_back(6);
						vnPosIndex.push_back(7);
					}
					break;

				case 2:
					{
						// 位置5、位置7
						vnPosIndex.push_back(4);
						vnPosIndex.push_back(6);
					}
					break;

				case 3:
					{
						// 位置6、位置8
						vnPosIndex.push_back(5);
						vnPosIndex.push_back(7);
					}
					break;

				default:
					{
						return FALSE;
					}
					break;
				}
			}
			else
			{
				vnPosIndex.push_back(4);
				vnPosIndex.push_back(5);
				vnPosIndex.push_back(6);
				vnPosIndex.push_back(7);
			}

			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT(vnPosIndex);
		}
		else
		{
			std::vector<int> vnPosIndex;
			int nPosIndex = 0;
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i + GetPosNum()/2;
				vnPosIndex.push_back(nPosIndex);
			}

			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT(vnPosIndex);
		}

	}	
	//目标对象分离，目标单个位置拍照的情况
	else if (nPosIndex >= 14 && nPosIndex <= 17)
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFTGT(nPosIndex-10);
	}
	// 针对联得2对4项目增加:对象4相机，目标2相机
	// 目标位置5+位置6
	else if (nPosIndex == 19)
	{
		m_nCheckTargetDistanceIndex = 19;

		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		for(i = 0; i < GetPosNum()/4; i++)
		{
			nPosIndex = i + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT(vnPosIndex);
	}
	// 目标位置7+位置8
	else if (nPosIndex == 20)
	{
		m_nCheckTargetDistanceIndex = 20;

		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		for(i = 0; i < GetPosNum()/4; i++)
		{
			nPosIndex = (i+GetPosNum()/4) + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT(vnPosIndex);
	}
	else if (nPosIndex>=256)
	{
		std::vector<int> vnPosIndex;
		nPosIndex = nPosIndex - 255;

		int nMask = 1;
		for (int i=0; i<GetPosNum(); i++)
		{
			int nMaskResult = nMask<<i;

			if ( (nPosIndex & nMaskResult) == nMaskResult )
			{
				vnPosIndex.push_back(i);
			}
		}

		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT(vnPosIndex);
	}

	m_nCheckTargetDistanceIndex = 0;

	return m_bTargetMarkSearchSucceed;

}

BOOL vcXYDVisionAlign::OnlineAlnTargetSearchExFTGM(int nPosIndex)
{
	CString strCmd = _T("VTGM:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) /*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	SetDefaultTargetSearchMarkPos(TRUE);

	std::vector<int> vnPosIndex;
	if (nPosIndex>=0 && nPosIndex <= 3)	//编号0～3的相机中的一个
	{
		vnPosIndex.push_back(nPosIndex);
	}
	else if(nPosIndex==4)	// 所有相机
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum(); i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else if (nPosIndex>=9 && nPosIndex<=10 ) //编号2～3的相机中的一个
	{
		vnPosIndex.push_back(nPosIndex - 7);
	}
	else if (nPosIndex==11) // 所有相机中的后一半编号
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else if (nPosIndex==12) // 所有相机中的前一半编号
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else
	{
		return FALSE;
	}

	if (vnPosIndex.size() == 1)
	{
		CDlgManualSearchPos1 dlgManualSearch;
		dlgManualSearch.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex;
		dlgManualSearch.m_nMarkType = 1;
		dlgManualSearch.SetSysInfoStringsRef(m_psaSysInfoStrings);
		dlgManualSearch.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		dlgManualSearch.SetVisionAlignerRef(this, vnPosIndex);

		// 定义全部位置向量，包含0/1对象和2/3目标
		std::vector<int> vnAllPosIndex;
		int nAllPosIndex = 0;	


		if (dlgManualSearch.DoModal() == IDOK)
		{
			for (int i=0; i<vnPosIndex.size(); i++)
			{
				CCoordPos pos = dlgManualSearch.m_vCoordPos.at(i);
				m_mpTargetMarkImagePos.SetMarkImagePos(vnPosIndex.at(i),TRUE,pos);

				if (vnPosIndex.at(i)>=GetPosNum()/2)
				{
					nAllPosIndex = vnPosIndex.at(i)- GetPosNum()/2;
					vnAllPosIndex.push_back(nAllPosIndex);

					nAllPosIndex = vnPosIndex.at(i);
					vnAllPosIndex.push_back(nAllPosIndex);
				}
			}

			// 如果目标和对象分离，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				int nHomoPosIndex = 0;
				std::vector<int> vnHomoPosIndex;			// 源目标位置
				vnHomoPosIndex.push_back(nPosIndex);		

				// 对目标2和3循环进行映射
				for (int i = 0; i<vnHomoPosIndex.size(); i++)
				{
					nHomoPosIndex = vnHomoPosIndex.at(i);
					if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
					{
						CCoordPos ObjImgPos;
						CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

						// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
						if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
						{
							//	ReportTargetSearchResultFTGM(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
							m_strStatusBarInfo2.Format(_T(""));
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();
							strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
							AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
							//return FALSE;
						}

						// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
						m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
					}
				}

				// 设定、显示目标定位结果十字，全部0/1/2/3图像
				m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
				// 				SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// 设定、显示目标定位结果文字，全部0/1/2/3图像
				// 				SetShowGuiTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
			}
			else
			{
				// 设定、显示结果图形
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

				// 				SetGuiAlnTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// SY
				// 				SetShowGuiTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
			}


			// 5. 设置对位工具
			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
				m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
			}
			m_bTargetMarkSearchSucceed = TRUE;

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_SUCCESS);//_T("实时目标Mark手动定位成功");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			if(m_bTargetSearchTest) ReportTargetSearchResultFTGM(TRUE);

			return TRUE;
		}
		else
		{
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_FAIL);//_T("实时目标Mark手动定位失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGM(FALSE);

			return FALSE;
		}
	}
	else if (vnPosIndex.size() == 2)
	{
		CDlgManualSearchPos2 dlgManualSearch;
		dlgManualSearch.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex;
		dlgManualSearch.m_nMarkType = 1;
		dlgManualSearch.SetSysInfoStringsRef(m_psaSysInfoStrings);
		dlgManualSearch.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		dlgManualSearch.SetVisionAlignerRef(this, vnPosIndex);

		std::vector<int> vnAllPosIndex;
		int nAllPosIndex = 0;

		if (dlgManualSearch.DoModal() == IDOK)
		{
			for (int i=0; i<vnPosIndex.size(); i++)
			{
				CCoordPos pos = dlgManualSearch.m_vCoordPos.at(i);
				m_mpTargetMarkImagePos.SetMarkImagePos(vnPosIndex.at(i),TRUE,pos);

				//显示当前位置及关联位置
				if (vnPosIndex.at(i)>=GetPosNum()/2)
				{
					nAllPosIndex = vnPosIndex.at(i)- GetPosNum()/2;
					vnAllPosIndex.push_back(nAllPosIndex);

					nAllPosIndex = vnPosIndex.at(i);
					vnAllPosIndex.push_back(nAllPosIndex);
				}
			}

			// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				int nHomoPosIndex = 0;
				std::vector<int> vnHomoPosIndex;			// 源目标位置
				vnHomoPosIndex.push_back(nPosIndex);		

				// 对目标2和3循环进行映射
				for (int i = 0; i<vnHomoPosIndex.size(); i++)
				{
					nHomoPosIndex = vnHomoPosIndex.at(i);
					if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
					{
						CCoordPos ObjImgPos;
						CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

						// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
						if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
						{
							//	ReportTargetSearchResultFTGM(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
							m_strStatusBarInfo2.Format(_T(""));
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();
							strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
							AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
							//return FALSE;
						}

						// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
						m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
					}
				}

				// 设定、显示目标定位结果十字，全部0/1/2/3图像
				m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
				// 				SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// 设定、显示目标定位结果文字，全部0/1/2/3图像
				// 				SetShowGuiTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
			}
			else
			{
				// 设定、显示结果图形
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

				// 				SetGuiAlnTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 
				// 				SetShowGuiTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
			}


			// 5. 设置对位工具
			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
				m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
			}
			m_bTargetMarkSearchSucceed = TRUE;

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_SUCCESS);//_T("实时目标Mark手动定位成功");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			if(m_bTargetSearchTest) ReportTargetSearchResultFTGM(TRUE);

			return TRUE;
		}
		else
		{
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_FAIL);//_T("实时目标Mark手动定位失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGM(FALSE);

			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

// 接收命令，进行相应的定位操作（定位、定位结果图形显示、状态显示，记录目标位置到对位工具），返回命令响应
BOOL vcXYDVisionAlign::OnlineAlnTargetSearchExFTGS(int nPosIndex)
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}
	// 隐藏对象结果图形			
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	std::vector<int> vnObjectPosIndex;
	int nObjectPosIndex = 0;
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nObjectPosIndex = i;
		vnObjectPosIndex.push_back(nObjectPosIndex);
	}	
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// //	if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnObjectPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);


	SetDefaultTargetSearchMarkPos(TRUE);

	if (nPosIndex>=0 && nPosIndex <= 3)	//编号0～3的相机中的一个
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFTGS(nPosIndex);
	}
	else if(nPosIndex==4)	// 所有相机
	{
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGS();
	}
	else if (nPosIndex>=9 && nPosIndex<=10 ) //编号2～3的相机中的一个
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFTGS(nPosIndex - 7);
	}
	else if (nPosIndex==11) // 所有相机中的后一半编号
	{
		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGS(vnPosIndex);

	}
	else if (nPosIndex>=256)
	{
		std::vector<int> vnPosIndex;
		nPosIndex = nPosIndex - 255;

		int nMask = 1;
		for (int i=0; i<GetPosNum(); i++)
		{
			int nMaskResult = nMask<<i;

			if ( (nPosIndex & nMaskResult) == nMaskResult )
			{
				vnPosIndex.push_back(nPosIndex);
			}
		}

		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGS(vnPosIndex);
	}

	return m_bTargetMarkSearchSucceed;

}

BOOL vcXYDVisionAlign::OnlineAlnSearchExFGTC(int nPosIndex, int nPatIndex)
{
	CString strCmd = _T("VGTC:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	BOOL bSuccess = FALSE;


	if (nPosIndex>=0 && nPosIndex <= nPosNum-1)	//编号0～3的相机中的一个
	{
		bSuccess = OnSingleCameraAlignerSearchExFGTC(nPosIndex, nPatIndex);
	}

	return bSuccess;
}

BOOL vcXYDVisionAlign::OnlineAlnSearchExFGAP(int nPosIndex, int nPatIndex)
{
	CString strCmd = _T("VGAP:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	BOOL bSuccess = FALSE;


	if (nPosIndex>=0 && nPosIndex <= nPosNum-1)	//编号0～3的相机中的一个
	{
		bSuccess = OnSingleCameraAlignerSearchExFGAP(nPosIndex, nPatIndex);
	}

	return bSuccess;

}

// 接收命令，进行相应的定位操作（定位、定位结果图形显示、状态显示，记录目标位置到对位工具），返回命令响应
BOOL vcXYDVisionAlign::OnlineAlnTargetSearchCandidateExFTGC(int nPosIndex, int nStartPatIndex)
{
	CString strCmd = _T("VTGC:");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	m_nCheckTargetDistanceIndex = 0;

	// 	if (m_pPlatformInfo->m_bTarCamWithDiffObjCam && m_pPlatformInfo->m_bTargetObjectCamSeparate)
	// 	{
	// // 		if (nPosIndex>=0 && nPosIndex <= 3)	//编号0～3的相机中的一个
	// // 		{
	// // 			m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFTGT(nPosIndex);
	// // 		}
	// 
	// 		// 目标位置4+位置5
	// 		if (nPosIndex == 19)
	// 		{
	// 			// 计算产品尺寸的时候用到该参数
	// 			SetAlignExProductIndex(0);
	// 
	// 			// 隐藏对象1、对象2结果图形			
	// 			int nPosNum = m_pPlatformInfo->m_nPositionNum;
	// 			std::vector<int> vnObjectPosIndex;
	// 			int nObjectPosIndex = 0;
	// 			int i = 0;
	// 			for(i = 0; i < nPosNum/4; i++)
	// 			{
	// 				nObjectPosIndex = i;
	// 				vnObjectPosIndex.push_back(nObjectPosIndex);
	// 			}	
	// // 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// // 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
	// 			m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);
	// 
	// 			SetDefaultTargetSearchMarkPos(TRUE, nPosIndex);
	// 
	// 			std::vector<int> vnPosIndex;
	// 			int nPosIndex = 0;
	// 			for(i = 0; i < GetPosNum()/4; i++)
	// 			{
	// 				nPosIndex = i + GetPosNum()/2;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);
	// 
	// 
	// 		}
	// 		// 目标位置6+位置7
	// 		else if (nPosIndex == 20)
	// 		{
	// 			// 计算产品尺寸的时候用到该参数
	// 			SetAlignExProductIndex(1);
	// 
	// 			// 隐藏对象结果图形			
	// 			int nPosNum = m_pPlatformInfo->m_nPositionNum;
	// 			std::vector<int> vnObjectPosIndex;
	// 			int nObjectPosIndex = 0;
	// 			int i = 0;
	// 			for(i = nPosNum/4; i < nPosNum/2; i++)
	// 			{
	// 				nObjectPosIndex = i;
	// 				vnObjectPosIndex.push_back(nObjectPosIndex);
	// 			}	
	// // 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// // 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
	// 			m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);
	// 
	// 			SetDefaultTargetSearchMarkPos(TRUE, nPosIndex);
	// 
	// 			std::vector<int> vnPosIndex;
	// 			int nPosIndex = 0;
	// 			for(i = 0; i < GetPosNum()/4; i++)
	// 			{
	// 				nPosIndex = (i+GetPosNum()/4) + GetPosNum()/2;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);
	// 
	// 		}
	// 
	// 		return m_bTargetMarkSearchSucceed;
	// 	}

	// 隐藏对象结果图形			
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	std::vector<int> vnObjectPosIndex;
	int nObjectPosIndex = 0;
	int i = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nObjectPosIndex = i;
		vnObjectPosIndex.push_back(nObjectPosIndex);
	}	
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// 
	// //	if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnObjectPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);


	if (nPosIndex == 19)
	{
		//m_nCheckTargetDistanceIndex = 19;
	}
	else if (nPosIndex == 20)
	{
		//m_nCheckTargetDistanceIndex = 20;
	}
	SetDefaultTargetSearchMarkPos(TRUE);


	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CAlignerParam* pAlignerParam = GetProductAlignerParam();
	if (NULL != pAlignerParam && optionInfo.m_bEnableMultiMarkMode)//如果启用多标记点功能，默认只搜目标搜后一半的第一个位置。
	{
		nPosIndex = 0;
		if (sysPlatformInfo.m_bTargetObjectCamSeparate)
		{
			nPosIndex = sysPlatformInfo.m_nPositionNum/2 ;
		}

		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchCandidateExFTGC(nPosIndex, nStartPatIndex);
		m_nCheckTargetDistanceIndex = 0;
		return m_bTargetMarkSearchSucceed;
	}



	if (nPosIndex>=0 && nPosIndex <= 3)	//编号0～3的相机中的一个
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchCandidateExFTGC(nPosIndex, nStartPatIndex);
	}
	else if(nPosIndex==4)	// 所有相机
	{
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex);
	}
	else if (nPosIndex>=9 && nPosIndex<=10 ) //编号2～3的相机中的一个
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchCandidateExFTGC(nPosIndex - 7, nStartPatIndex);
	}
	else if (nPosIndex==11) // 所有相机中的后一半编号
	{
		// 兼容凯达扬2VS4的拍照模式
		if (optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
		{
			int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);

			if (pCurProductData == NULL)
			{
				return FALSE;
			}

			std::vector<int> vnPosIndex;
			int nTargetVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode;
			BOOL bEnableTargetPositionVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode;

			if (bEnableTargetPositionVirtualMode)
			{
				switch(nTargetVirtualMode)
				{
				case 0:
					{
						// 位置5、位置6
						vnPosIndex.push_back(4);
						vnPosIndex.push_back(5);

					}
					break;

				case 1:
					{
						// 位置7、位置8
						vnPosIndex.push_back(6);
						vnPosIndex.push_back(7);
					}
					break;

				case 2:
					{
						// 位置5、位置7
						vnPosIndex.push_back(4);
						vnPosIndex.push_back(6);
					}
					break;

				case 3:
					{
						// 位置6、位置8
						vnPosIndex.push_back(5);
						vnPosIndex.push_back(7);
					}
					break;

				default:
					{
						return FALSE;
					}
					break;
				}
			}
			else
			{
				vnPosIndex.push_back(4);
				vnPosIndex.push_back(5);
				vnPosIndex.push_back(6);
				vnPosIndex.push_back(7);
			}

			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);

		}
		else
		{
			std::vector<int> vnPosIndex;
			int nPosIndex = 0;
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i + GetPosNum()/2;
				vnPosIndex.push_back(nPosIndex);
			}

			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);
		}

	}
	//目标对象分离，目标单个位置拍照的情况
	else if (nPosIndex >= 14 && nPosIndex <= 17)
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchCandidateExFTGC(nPosIndex-10, nStartPatIndex);
	}
	// 针对联得2对4项目增加:对象4相机，目标2相机
	// 目标位置5+位置6
	else if (nPosIndex == 19)
	{
		//m_nCheckTargetDistanceIndex = 19;

		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		for(i = 0; i < GetPosNum()/4; i++)
		{
			nPosIndex = i + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);
	}
	// 目标位置7+位置8
	else if (nPosIndex == 20)
	{
		//m_nCheckTargetDistanceIndex = 20;  

		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		for(i = 0; i < GetPosNum()/4; i++)
		{
			nPosIndex = (i+GetPosNum()/4) + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);
	}
	//目标57拍照
	else if (nPosIndex == 21)
	{
		std::vector<int> vnPosIndex;
		vnPosIndex.push_back(4);
		vnPosIndex.push_back(6);
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);
	}
	////目标68拍照
	else if (nPosIndex == 22)
	{
		std::vector<int> vnPosIndex;
		vnPosIndex.push_back(5);
		vnPosIndex.push_back(7);
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);
	}
	else if (nPosIndex>=256)
	{
		std::vector<int> vnPosIndex;
		nPosIndex = nPosIndex - 255;

		int nMask = 1;
		for (int i=0; i<GetPosNum(); i++)
		{
			int nMaskResult = nMask<<i;

			if ( (nPosIndex & nMaskResult) == nMaskResult )
			{
				vnPosIndex.push_back(i);
			}
		}

		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex);
	}

	m_nCheckTargetDistanceIndex = 0;

	return m_bTargetMarkSearchSucceed;

}

// 接收命令，进行相应的定位操作（定位、定位结果图形显示、状态显示，记录目标位置到对位工具），返回命令响应
BOOL vcXYDVisionAlign::OnlineAlnObjectSearchExFOBJ(int nPosIndex)
{
	CString strCmd = _T("VOBJ:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	m_nCheckObjectDistanceIndex = 0;

	// 	if (m_pPlatformInfo->m_bTarCamWithDiffObjCam && m_pPlatformInfo->m_bTargetObjectCamSeparate)
	// 	{
	// 		SetDefaultObjectSearchMarkPos(TRUE, nPosIndex);
	// 
	// 
	// 		// 对象两个相机同时定位，位置1+位置2
	// 		if (nPosIndex==19)
	// 		{
	// 			// 计算产品尺寸的时候用到该参数
	// 			SetAlignExProductIndex(0);
	// 
	// 			std::vector<int> vnPosIndex;
	// 			int nPosIndex = 0;
	// 			int i = 0;
	// 			for(i = 0; i < GetPosNum()/4; i++)
	// 			{
	// 				nPosIndex = i;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex);
	// 		}
	// 		// 对象两个相机同时定位，位置3+位置4
	// 		else if (nPosIndex==20)
	// 		{
	// 			// 计算产品尺寸的时候用到该参数
	// 			SetAlignExProductIndex(1);
	// 
	// 			std::vector<int> vnPosIndex;
	// 			int nPosIndex = 0;
	// 			int i = 0;
	// 			for(i = 0; i < GetPosNum()/4; i++)
	// 			{
	// 				nPosIndex = i+GetPosNum()/4;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex);
	// 		}
	// 
	// 		return m_bObjectMarkSearchSucceed;
	// 
	// 	}

	SetDefaultObjectSearchMarkPos(TRUE);

	if (nPosIndex>=0 && nPosIndex<=3)
	{
		m_bObjectMarkSearchSucceed = OnSingleCameraAlignerObjectSearchExFOBJ(nPosIndex);
	}
	else if(nPosIndex==4)
	{
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ();
	}
	else if (nPosIndex==11) // 所有相机中的前一半编号
	{
		// 兼容凯达扬2VS4的拍照模式
		if (optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
		{
			int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);

			if (pCurProductData == NULL)
			{
				return FALSE;
			}

			std::vector<int> vnPosIndex;

			int nObjectVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;
			BOOL bEnableObjectPositionVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;

			if (bEnableObjectPositionVirtualMode)
			{
				switch(nObjectVirtualMode)
				{
				case 0:
					{
						// 位置1、位置2
						vnPosIndex.push_back(0);
						vnPosIndex.push_back(1);

					}
					break;

				case 1:
					{
						// 位置3、位置4
						vnPosIndex.push_back(2);
						vnPosIndex.push_back(3);
					}
					break;

				case 2:
					{
						// 位置1、位置3
						vnPosIndex.push_back(0);
						vnPosIndex.push_back(2);
					}
					break;

				case 3:
					{
						// 位置2、位置4
						vnPosIndex.push_back(1);
						vnPosIndex.push_back(3);
					}
					break;

				default:
					{
						return FALSE;
					}
					break;
				}
			}
			else
			{
				vnPosIndex.push_back(0);
				vnPosIndex.push_back(1);
				vnPosIndex.push_back(2);
				vnPosIndex.push_back(3);
			}

			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex);
		}
		else
		{
			std::vector<int> vnPosIndex;
			int nPosIndex = 0;
			int i = 0;
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
			}
			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex);
		}

	}	
	// 针对联得2对4项目增加:对象2相机，目标4相机
	// 对象两个相机同时定位，位置1+位置2
	else if (nPosIndex==19)
	{
		m_nCheckObjectDistanceIndex = 19;

		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/4; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex);
	}
	// 对象两个相机同时定位，位置3+位置4
	else if (nPosIndex==20)
	{
		m_nCheckObjectDistanceIndex = 20;

		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/4; i++)
		{
			nPosIndex = i+GetPosNum()/4;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex);
	}
	else if (nPosIndex>=256)
	{
		std::vector<int> vnPosIndex;
		nPosIndex = nPosIndex - 255;

		int nMask = 1;
		for (int i=0; i<GetPosNum(); i++)
		{
			int nMaskResult = nMask<<i;

			if ( (nPosIndex & nMaskResult) == nMaskResult )
			{
				vnPosIndex.push_back(i);
			}
		}

		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex);
	}

	m_nCheckObjectDistanceIndex = 0;

	return m_bObjectMarkSearchSucceed;

}

BOOL vcXYDVisionAlign::OnlineAlnTargetSearchExFCNO(int nPosIndex)
{
	CString strCmd = _T("VCNO:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}

	SetDefaultObjectSearchMarkPos(TRUE);
	SetDefaultTargetSearchMarkPos(TRUE);

	if (nPosIndex>=0 && nPosIndex<=3)
	{
		m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFCNO(nPosIndex);
		m_bObjectMarkSearchSucceed = m_bTargetMarkSearchSucceed;
	}
	else if(nPosIndex==4)
	{
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFCNO();
		m_bObjectMarkSearchSucceed = m_bTargetMarkSearchSucceed;
	}
	else if (nPosIndex==11) // 所有相机中的前一半编号
	{
		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i+GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFCNO(vnPosIndex);
		m_bObjectMarkSearchSucceed = m_bTargetMarkSearchSucceed;
	}
	else if (nPosIndex>=256)
	{
		std::vector<int> vnPosIndex;
		nPosIndex = nPosIndex - 255;

		int nMask = 1;
		for (int i=0; i<GetPosNum(); i++)
		{
			int nMaskResult = nMask<<i;

			if ( (nPosIndex & nMaskResult) == nMaskResult )
			{
				vnPosIndex.push_back(i);
			}
		}

		m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFCNO(vnPosIndex);
		m_bObjectMarkSearchSucceed = m_bTargetMarkSearchSucceed;
	}

	return m_bTargetMarkSearchSucceed;
}

BOOL vcXYDVisionAlign::OnlineAlnObjectSearchExFCNT(int nPosIndex)
{
	CString strCmd = _T("VCNT:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}

	SetDefaultObjectSearchMarkPos(TRUE);
	SetDefaultTargetSearchMarkPos(TRUE);

	if (nPosIndex>=0 && nPosIndex<=3)
	{
		m_bObjectMarkSearchSucceed = OnSingleCameraAlignerObjectSearchExFCNT(nPosIndex);
		m_bTargetMarkSearchSucceed = m_bObjectMarkSearchSucceed;
	}
	else if(nPosIndex==4)
	{
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFCNT();
		m_bTargetMarkSearchSucceed = m_bObjectMarkSearchSucceed;
	}
	else if (nPosIndex==11) // 所有相机中的前一半编号
	{
		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFCNT(vnPosIndex);
		m_bTargetMarkSearchSucceed = m_bObjectMarkSearchSucceed;
	}
	else if (nPosIndex>=256)
	{
		std::vector<int> vnPosIndex;
		nPosIndex = nPosIndex - 255;

		int nMask = 1;
		for (int i=0; i<GetPosNum(); i++)
		{
			int nMaskResult = nMask<<i;

			if ( (nPosIndex & nMaskResult) == nMaskResult )
			{
				vnPosIndex.push_back(i);
			}
		}

		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFCNT(vnPosIndex);
		m_bTargetMarkSearchSucceed = m_bObjectMarkSearchSucceed;
	}

	return m_bObjectMarkSearchSucceed;

}

BOOL vcXYDVisionAlign::OnlineAlnObjectSearchExFOBM(int nPosIndex)
{
	CString strCmd = _T("VOBM:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}

	SetDefaultObjectSearchMarkPos(TRUE);

	std::vector<int> vnPosIndex;
	if (nPosIndex>=0 && nPosIndex<=3)
	{
		vnPosIndex.push_back(nPosIndex);
	}
	else if (nPosIndex==4)
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum(); i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else if (nPosIndex==11) // 所有相机中的前一半编号
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else if (nPosIndex==12) // 所有相机中的后一半编号
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else
	{
		return FALSE;
	}

	if (vnPosIndex.size() == 1)
	{
		CDlgManualSearchPos1 dlgManualSearch;
		dlgManualSearch.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex;
		dlgManualSearch.m_nMarkType = 0;
		dlgManualSearch.SetSysInfoStringsRef(m_psaSysInfoStrings);
		dlgManualSearch.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		dlgManualSearch.SetVisionAlignerRef(this, vnPosIndex);

		if (dlgManualSearch.DoModal() == IDOK)
		{
			for (int i=0; i<vnPosIndex.size(); i++)
			{
				CCoordPos pos = dlgManualSearch.m_vCoordPos.at(i);
				m_mpObjectMarkImagePos.SetMarkImagePos(vnPosIndex.at(i),TRUE,pos);
			}

			// 设定、显示结果图形
			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
			// 			SetGuiAlnObjectImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
			// 
			// 			if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
			// 			{
			// 				SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
			// 				PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
			// 			}
			// 			// SY
			// 			SetShowGuiObjectImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

			// 5. 设置对位工具
			SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

			m_bObjectMarkSearchSucceed = TRUE;

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_SUCCESS);//_T("实时对象Mark手动定位成功");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			ReportObjectSearchResultFOBM(TRUE);

			return TRUE;
		}
		else
		{
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_FAIL);//_T("实时对象Mark手动定位失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			ReportObjectSearchResultFOBM(FALSE);
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}
	else if (vnPosIndex.size() == 2)
	{
		CDlgManualSearchPos2 dlgManualSearch;
		dlgManualSearch.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex;
		dlgManualSearch.m_nMarkType = 0;
		dlgManualSearch.SetSysInfoStringsRef(m_psaSysInfoStrings);
		dlgManualSearch.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		dlgManualSearch.SetVisionAlignerRef(this, vnPosIndex);

		if (dlgManualSearch.DoModal() == IDOK)
		{
			for (int i=0; i<vnPosIndex.size(); i++)
			{
				CCoordPos pos = dlgManualSearch.m_vCoordPos.at(i);
				m_mpObjectMarkImagePos.SetMarkImagePos(vnPosIndex.at(i),TRUE,pos);
			}

			// 设定、显示结果图形
			// 			SetGuiAlnObjectImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
			// 
			// 			if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
			// 			{
			// 				SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
			// 				PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
			// 			}
			// 
			// 			// SY
			// 			SetShowGuiObjectImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

			// 5. 设置对位工具
			SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

			m_bObjectMarkSearchSucceed = TRUE;

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_SUCCESS);//_T("实时对象Mark手动定位成功");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			ReportObjectSearchResultFOBM(TRUE);

			return TRUE;
		}
		else
		{
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_FAIL);//_T("实时对象Mark手动定位失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			ReportObjectSearchResultFOBM(FALSE);

			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return m_bObjectMarkSearchSucceed;
}


// 接收命令，进行相应的定位操作（定位、定位结果图形显示、状态显示，记录目标位置到对位工具），返回命令响应
BOOL vcXYDVisionAlign::OnlineAlnObjectSearchCandidateExFOBC(int nPosIndex, int nStartPatIndex)
{
	// 	if (NULL == m_pPlatformInfo)
	// 	{
	// 		return FALSE;
	// 	}
	CString strCmd = _T("VOBC:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd))
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	m_nCheckObjectDistanceIndex = 0;

	// 	if (m_pPlatformInfo->m_bTarCamWithDiffObjCam && m_pPlatformInfo->m_bTargetObjectCamSeparate)
	// 	{
	// 		SetDefaultObjectSearchMarkPos(TRUE, nPosIndex);
	// 
	// 		// 对象两个相机同时定位，位置1+位置2
	// 		if (nPosIndex==19)
	// 		{
	// 			// 计算产品尺寸的时候用到该参数
	// 			SetAlignExProductIndex(0);
	// 
	// 			std::vector<int> vnPosIndex;
	// 			int nPosIndex = 0;
	// 			int i = 0;
	// 			for(i = 0; i < GetPosNum()/4; i++)
	// 			{
	// 				nPosIndex = i;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 
	// 			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
	// 		}
	// 		// 对象两个相机同时定位，位置3+位置4
	// 		else if (nPosIndex==20)
	// 		{
	// 			// 计算产品尺寸的时候用到该参数
	// 			SetAlignExProductIndex(1);
	// 
	// 			std::vector<int> vnPosIndex;
	// 			int nPosIndex = 0;
	// 			int i = 0;
	// 			for(i = 0; i < GetPosNum()/4; i++)
	// 			{
	// 				nPosIndex = i+GetPosNum()/4;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
	// 		}
	// 
	// 
	// 		return m_bObjectMarkSearchSucceed;
	// 	}

	SetDefaultObjectSearchMarkPos(TRUE);


	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CAlignerParam* pAlignerParam = GetProductAlignerParam();

	if (optionInfo.m_bEnableMultiMarkMode)//如果启用多标记点功能，默认只搜第一个位置。
	{
		nPosIndex = 0;
	}

	if (nPosIndex>=0 && nPosIndex<=3)
	{
		m_bObjectMarkSearchSucceed = OnSingleCameraAlignerObjectSearchCandidateExFOBC(nPosIndex, nStartPatIndex);
	}
	else if(nPosIndex==4)
	{
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex);
	}
	else if (nPosIndex==11) // 所有相机中的前一半编号
	{
		// 兼容凯达扬2VS4的拍照模式
		if (optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
		{
			int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);

			if (pCurProductData == NULL)
			{
				return FALSE;
			}

			std::vector<int> vnPosIndex;

			int nObjectVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;
			BOOL bEnableObjectPositionVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;

			if (bEnableObjectPositionVirtualMode)
			{
				switch(nObjectVirtualMode)
				{
				case 0:
					{
						// 位置1、位置2
						vnPosIndex.push_back(0);
						vnPosIndex.push_back(1);

					}
					break;

				case 1:
					{
						// 位置3、位置4
						vnPosIndex.push_back(2);
						vnPosIndex.push_back(3);
					}
					break;

				case 2:
					{
						// 位置1、位置3
						vnPosIndex.push_back(0);
						vnPosIndex.push_back(2);
					}
					break;

				case 3:
					{
						// 位置2、位置4
						vnPosIndex.push_back(1);
						vnPosIndex.push_back(3);
					}
					break;

				default:
					{
						return FALSE;
					}
					break;
				}
			}
			else
			{
				vnPosIndex.push_back(0);
				vnPosIndex.push_back(1);
				vnPosIndex.push_back(2);
				vnPosIndex.push_back(3);
			}

			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
		}
		else
		{
			if (m_pPlatformInfo->m_bUseAlignFAHLex == TRUE)  // 山本集银-叠片机
			{
				m_nCheckObjectDistanceIndex = 19;
			}
			std::vector<int> vnPosIndex;
			int nPosIndex = 0;
			int i = 0;
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
			}
			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
		}

	}
	// 针对联得2对4项目增加:对象2相机，目标4相机
	// 对象两个相机同时定位，位置1+位置2
	else if (nPosIndex==19)
	{
		//m_nCheckObjectDistanceIndex = 19;

		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/4; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
	}
	// 对象两个相机同时定位，位置3+位置4
	else if (nPosIndex==20)
	{
		//m_nCheckObjectDistanceIndex = 20;

		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/4; i++)
		{
			nPosIndex = i+GetPosNum()/4;
			vnPosIndex.push_back(nPosIndex);
		}
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
	}
	//对象13拍照
	else if (nPosIndex==21)
	{
		std::vector<int> vnPosIndex;
		vnPosIndex.push_back(0);
		vnPosIndex.push_back(2);
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
	}
	//对象24拍照
	else if (nPosIndex==22)
	{
		std::vector<int> vnPosIndex;
		vnPosIndex.push_back(1);
		vnPosIndex.push_back(3);
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
	}
	else if (nPosIndex==23)  // 集银叠片机，目标、对象同时拍照
	{
		m_nCheckObjectDistanceIndex = 23;   // iyo
		std::vector<int> vnObjPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)  //0，1
		{
			nPosIndex = i;
			vnObjPosIndex.push_back(nPosIndex);
		}
		std::vector<int> vnTarPosIndex;


		for(i = 0; i < GetPosNum()/2; i++)  //2，3
		{
			nPosIndex = i+GetPosNum()/2;
			vnTarPosIndex.push_back(nPosIndex);
		}
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerTargetAndObjectSearchFOBC(vnTarPosIndex, vnObjPosIndex,0);

	}
	else if (nPosIndex==24)  // 集银叠片机，目标、对象同时拍照
	{
		m_nCheckObjectDistanceIndex = 24;   // iyo
		std::vector<int> vnObjPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)  //0，1
		{
			nPosIndex = i;
			vnObjPosIndex.push_back(nPosIndex);
		}
		std::vector<int> vnTarPosIndex;


		for(i = 0; i < GetPosNum()/2; i++)  //0，1
		{
			nPosIndex = i;
			vnTarPosIndex.push_back(nPosIndex);
		}
		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerTargetAndObjectSearchFOBC(vnTarPosIndex, vnObjPosIndex,1);

	}
	else if (nPosIndex>=256)
	{
		std::vector<int> vnPosIndex;
		nPosIndex = nPosIndex - 255;

		int nMask = 1;
		for (int i=0; i<GetPosNum(); i++)
		{
			int nMaskResult = nMask<<i;

			if ( (nPosIndex & nMaskResult) == nMaskResult )
			{
				vnPosIndex.push_back(i);
			}
		}

		m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex);
	}

	m_nCheckObjectDistanceIndex = 0;

	return m_bObjectMarkSearchSucceed;

}

// 单相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSingleCameraAlignerTargetSearchExFTGT(int nPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VTGT:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd)/*m_bValidTargetSearchTool!=TRUE*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_SEARCH_FAILE);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}
	// 
	// 	if (NULL == m_pPlatformInfo)
	// 	{
	// 		ReportTargetSearchResultFTGT(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
	// 		return FALSE;
	// 	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0;
	CString strTempCamPos = _T("");
	CString strTempCam = _T("");
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			strTempCamPos.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_CPFAST_STR_POS), i + 1);
			strTempCam += strTempCamPos;;	//zzc报警 相机x掉线，1,2,3,4
			if (i == nCamNum - 1)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION), strTempCam);
				SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);// SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
				return FALSE;
			}
		}    	
	}

	scTimer stSearchTimer;
	stSearchTimer.Reset();


	//////////////////////////////////////////////////////////////////////////
	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		CameraParamEnable cameraParamEnable = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(0);

		//			if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable))
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eTargetSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////


	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (nPosIndex >= m_vpTargetPlatformAxisPos.size() || m_vpTargetPlatformAxisPos.at(nPosIndex) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))		
	if (!bCommuciateGetPlatformAxisAbsPos)	
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);//	SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		SetTargetPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
		SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
		SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		if (optionInfo.m_bEnableMutiTarget)
		{
			SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	int nNum = m_pPlatformInfo->m_nCamNum;
	//	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;
	// 2. 等待相机移动到不同位置，并定位
	//	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	//	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	if (0/*(m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX)*/)
	{

		{
			pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
			vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);      
		}

		if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos))
		{
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_GET_CAMERA_PLATFORM_POS_FAILED_II);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
		else
		{
			//SetTargetCamPlatformPos(vpCamPlatformXYAxisPos,nPosIndex);

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strInfo;
				strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_CAM_PLATFORM_POS);
				strInfo = strTemp + strInfo;

				for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
				{
					strTemp = _T("");
					strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
					strInfo = strInfo + strTemp;
				}

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));
				// 				fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}
		}	
	}

	CMarkImagePos* pTemMarkImagePos = NULL;
	{
		{ 	
			// 等待搜索延时
			int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
			Sleep(nDelayTime);

			// 准备开始定位			
			std::vector<int> vnPosIndex;
			std::vector<SearchMode> vsmSearchMode;	
			vnPosIndex.push_back(nPosIndex);		// 	
			vsmSearchMode.push_back(eTargetSearch);	// 

			std::vector<int> vnAllPosIndex;
			int nAllPosIndex = 0;
			if (nPosIndex>=GetPosNum()/2)
			{
				nAllPosIndex = nPosIndex- GetPosNum()/2;
				vnAllPosIndex.push_back(nAllPosIndex);

				nAllPosIndex = nPosIndex;
				vnAllPosIndex.push_back(nAllPosIndex);
			}

			// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate /*&&  m_pSystempOptionConfig->m_bShowSepTargetPos*/ /* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				// 隐藏目标定位结果十字，全部0/1/2/3图像
				m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
				// 				// 隐藏目标定位结果文字，全部0/1/2/3图像
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
				// 
				// 				//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
				// 				}
				// 
				// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
				// 				}
			}
			else
			{
				// 隐藏目标定位结果十字，目标2/3图像
				m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
				// 				// 隐藏目标定位结果文字，目标2/3图像
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
				// 
				// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
				// 				}
				// 				//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
				// 				}

			}

			if (!SnapSearchImage(vnPosIndex))
			{
				if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
				// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedSnapSearchImage(strCmd);
				return FALSE;
			}

			// 定位
			BOOL bSearchSucceed = FALSE;
			if(optionInfo.m_bEnableSearchCindidate)
			{
				BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
				if (bTargetSearchCandidate == FALSE)
				{
					m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
					m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
				else
				{
					m_vnTargetSearchStartPatIndex[nPosIndex] = 0;		
					m_vnTargetSearchEndPatIndex[nPosIndex] = TARGETCANDIDATENUM-1;
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
			}
			else
			{
				m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
				m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}


			if (FALSE == bSearchSucceed)
			{
				if (optionInfo.m_bSearchTimes)
				{
					for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
					{
						//定位延时	 m_nSearchDelayTime
						Sleep(optionInfo.m_nSearchDelayTime);
						// 采集搜索图像
						if (!SnapSearchImage(vnPosIndex))
						{
							if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();
							OnFailedSnapSearchImage(strCmd);
							return FALSE;
						}

						// 定位
						if(optionInfo.m_bEnableSearchCindidate)
						{
							BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
							if (bTargetSearchCandidate == FALSE)
							{
								m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
								m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
							}
							else
							{
								m_vnTargetSearchStartPatIndex[nPosIndex] = 0;		
								m_vnTargetSearchEndPatIndex[nPosIndex] = TARGETCANDIDATENUM-1;
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
							}
						}
						else
						{
							m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
							m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}

						if (bSearchSucceed)
						{
							break;
						}
					}
				}
			}

			if(TRUE == bSearchSucceed)
			{
				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
				m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			}
			else
			{
				if (optionInfo.m_bManualAfTarSearchFail)
				{
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉弹出手动搜索框
						SetPlcManualSearch(TRUE);
					}

					if (FALSE == ExcuteManualSearch(0,vnPosIndex))
					{
						if (optionInfo.m_bSetVisionManualSearchToPLC)
						{
							// 通知PLC，视觉关闭手动搜索框
							SetPlcManualSearch(FALSE);
						}

					}
					else
					{
						bSearchSucceed = TRUE;
					}
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉关闭手动搜索框
						SetPlcManualSearch(FALSE);
					}


				}

			}

			// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				int nHomoPosIndex = 0;
				std::vector<int> vnHomoPosIndex;			// 源目标位置
				vnHomoPosIndex.push_back(nPosIndex);		

				// 对目标2和3循环进行映射
				for (int i = 0; i<vnHomoPosIndex.size(); i++)
				{
					nHomoPosIndex = vnHomoPosIndex.at(i);
					if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
					{
						CCoordPos ObjImgPos;
						CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

						// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
						if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
						{
							//	ReportTargetSearchResultFTGM(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
							m_strStatusBarInfo2.Format(_T(""));
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

							//return FALSE;
						}

						// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
						m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
					}
				}

				// 设定、显示目标定位结果十字，全部0/1/2/3图像
				m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
				// 				if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
				// 				{
				//                 	SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
				//                 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
				// 				}
				// 
				//                 if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				//                 {
				//                     SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				//                     PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				//                 }
				//                 // 设定、显示目标定位结果文字，全部0/1/2/3图像
				//                 SetShowGuiTargetImageMarkPos(vnAllPosIndex);
				//                 PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
			}
			else
			{
				// 设定、显示结果图形
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

				// 				if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
				// 				{
				//                 	SetGuiAlnTargetImageMarkPos(vnPosIndex);
				//                	    PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				//                 if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				//                 {
				//                     SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				//                     PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				//                 }
				//                 // SY
				//                 SetShowGuiTargetImageMarkPos(vnPosIndex);
				//                 PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
			}
			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile&&m_pVisionASMConfig->m_DataRecord.m_bSaveTargetSnapVDBFile)
			{
				//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
				ExeSaveVDBFile(vnPosIndex,eTargetSearch);
			}

			if (bSearchSucceed)
			{


			}
			else
			{
				if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);//SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_TARGET_SEARCH_FAILED), nPosIndex+1);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}

		}	
	}

	// 3. 设置对位工具
	//	if (pTemMarkImagePos)
	{
		//m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
		SetMultiEXTargetMarkSearchResultsWithCombinationCode(m_mpTargetMarkImagePos);
		SetTargetMarkSearchResults(m_mpTargetMarkImagePos); // ?
		if (optionInfo.m_bEnableMutiTarget)
		{
			m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
			m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
		}


		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}   

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");

		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1)
	{
		return ExecuteAlignAfterFOBJAndFTGT(2);
	}

	if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(TRUE);//SendCommInfo(CMD_TGG_SEARCH_SUCCEED);

	/*m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();*/

	return TRUE;
}

// 单相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSingleCameraAlignerTargetSearchExFTGS(int nPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if (m_bValidTargetSearchTool!=TRUE)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	if (NULL == m_pPlatformInfo)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	if (NULL == m_pPlatformInfo)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_SEARCH_FAILE);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;

	// 	if (nCamNum != 1)
	// 	{
	// 		SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
	// 		return FALSE;
	// 	}
	// 	
	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);// SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;
	stSearchTimer.Reset();
	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (nPosIndex >= m_vpTargetPlatformAxisPos.size() || m_vpTargetPlatformAxisPos.at(nPosIndex) == NULL)
	{
		bCommuciateGetPlatformAxisAbsPos = FALSE;
	}
	else
	{
		*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex));
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}		

	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//	SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{ 
		SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
		SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		if (optionInfo.m_bEnableMutiTarget)
		{
			SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
		}
		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	int nNum = m_pPlatformInfo->m_nCamNum;
	//	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;
	// 2. 等待相机移动到不同位置，并定位
	//	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	//	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	if (0/*(m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX)*/)
	{

		{
			pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
			vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);      
		}

		if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos))
		{
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_GET_CAMERA_PLATFORM_POS_FAILED_II);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
		else
		{
			//SetTargetCamPlatformPos(vpCamPlatformXYAxisPos,nPosIndex);

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strInfo;
				strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_CAM_PLATFORM_POS);
				strInfo = strTemp + strInfo;

				for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
				{
					strTemp = _T("");
					strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
					strInfo = strInfo + strTemp;
				}

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));
				// 				fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);		

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}
		}	
	}




	CMarkImagePos* pTemMarkImagePos = NULL;
	{
		{ 	
			// 等待搜索延时
			int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
			Sleep(nDelayTime);

			// 准备开始定位			
			std::vector<int> vnPosIndex;
			std::vector<SearchMode> vsmSearchMode;	
			vnPosIndex.push_back(nPosIndex);		// 	
			vsmSearchMode.push_back(eTargetSearch);	// 

			std::vector<int> vnAllPosIndex;
			int nAllPosIndex = 0;
			if (nPosIndex>=GetPosNum()/2)
			{
				nAllPosIndex = nPosIndex- GetPosNum()/2;
				vnAllPosIndex.push_back(nAllPosIndex);

				nAllPosIndex = nPosIndex;
				vnAllPosIndex.push_back(nAllPosIndex);
			}

			// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate /*&&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				// 隐藏目标定位结果十字，全部0/1/2/3图像
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
				// 				// 隐藏目标定位结果文字，全部0/1/2/3图像
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
				// 
				// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
				// 				}
				// //				if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
				// 				}

				m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);

			}
			else
			{
				// 隐藏目标定位结果十字，目标2/3图像
				m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
				// 				// 隐藏目标定位结果文字，目标2/3图像
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
				// 
				// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
				// 				}
				// //				if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
				// 				}

			}

			// 采集搜索图像
			if (!SnapSearchImage(vnPosIndex))
			{
				if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			// 定位
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
			BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);


			// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				int nHomoPosIndex = 0;
				std::vector<int> vnHomoPosIndex;			// 源目标位置
				vnHomoPosIndex.push_back(nPosIndex);		

				// 对目标2和3循环进行映射
				for (int i = 0; i<vnHomoPosIndex.size(); i++)
				{
					nHomoPosIndex = vnHomoPosIndex.at(i);
					if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
					{
						CCoordPos ObjImgPos;
						CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

						// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
						if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
						{
							//	ReportTargetSearchResultFTGM(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
							m_strStatusBarInfo2.Format(_T(""));
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

							//return FALSE;
						}

						// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
						m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
					}
				}

				// 设定、显示目标定位结果十字，全部0/1/2/3图像
				m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
				// 				SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// 设定、显示目标定位结果文字，全部0/1/2/3图像
				// 				SetShowGuiTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
			}
			else
			{
				// 设定、显示结果图形
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

				// 				SetGuiAlnTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// SY
				// 				SetShowGuiTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
			}

			if (FALSE == bSearchSucceed)
			{
				if (optionInfo.m_bSearchTimes)
				{
					for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
					{
						//定位延时	 m_nSearchDelayTime
						Sleep(optionInfo.m_nSearchDelayTime);
						// 采集搜索图像
						if (!SnapSearchImage(vnPosIndex))
						{
							if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

							return FALSE;
						}

						// 定位
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

						// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
						if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
						{
							int nHomoPosIndex = 0;
							std::vector<int> vnHomoPosIndex;			// 源目标位置
							vnHomoPosIndex.push_back(nPosIndex);		

							// 对目标2和3循环进行映射
							for (int i = 0; i<vnHomoPosIndex.size(); i++)
							{
								nHomoPosIndex = vnHomoPosIndex.at(i);
								if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
								{
									CCoordPos ObjImgPos;
									CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

									// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
									if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
									{
										//	ReportTargetSearchResultFTGM(FALSE);

										m_bStatusBar = FALSE;
										m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
										m_strStatusBarInfo2.Format(_T(""));
										SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

										//return FALSE;
									}

									// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
									m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
								}
							}

							// 设定、显示目标定位结果十字，全部0/1/2/3图像
							m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
							// 							SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
							// 							PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
							// 
							// 							if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
							// 							{
							// 								SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
							// 								PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
							// 							}
							// 							// 设定、显示目标定位结果文字，全部0/1/2/3图像
							// 							SetShowGuiTargetImageMarkPos(vnAllPosIndex);
							// 							PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
						}
						else
						{
							// 设定、显示结果图形
							m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

							// 							SetGuiAlnTargetImageMarkPos(vnPosIndex);
							// 							PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
							// 							if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
							// 							{
							// 								SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
							// 								PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
							// 							}
							// 							// SY
							// 							SetShowGuiTargetImageMarkPos(vnPosIndex);
							// 							PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
						}


						if (bSearchSucceed)
						{
							break;
						}
					}
				}
			}
			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
			{
				//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
				ExeSaveVDBFile(vnPosIndex,eTargetSearch);
			}

			if (FALSE == bSearchSucceed)
			{
				if (optionInfo.m_bManualAfTarSearchFail)
				{
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉弹出手动搜索框
						SetPlcManualSearch(TRUE);
					}

					if (FALSE == ExcuteManualSearch(0,vnPosIndex))
					{
						if (optionInfo.m_bSetVisionManualSearchToPLC)
						{
							// 通知PLC，视觉关闭手动搜索框
							SetPlcManualSearch(FALSE);
						}

						if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_TARGET_SEARCH_FAILED), nPosIndex+1);
						m_strStatusBarInfo2 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						return FALSE;

					}
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉关闭手动搜索框
						SetPlcManualSearch(FALSE);
					}


				}
				else
				{
					if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_TARGET_SEARCH_FAILED), nPosIndex+1);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

			}

		}	


	}

	// 3. 设置对位工具
	//	if (pTemMarkImagePos)
	{
		SetTargetMarkSearchResults(m_mpTargetMarkImagePos); // ?
		if (optionInfo.m_bEnableMutiTarget)
		{
			m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
			m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
		}
		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}   

	// 4. 设置相机平台的绝对位置
	//SetTargetCamPlatformPos(vpCamPlatformXYAxisPos);

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");
		// 		if (pTemMarkImagePos)
		// 		{
		// 			for (int i=0; i<pTemMarkImagePos->GetMarkImagePosNum(); i++)
		// 			{
		// 				strTemp = _T("");
		// 				cp = pTemMarkImagePos->GetMarkImagePos(i);
		// 
		// 				strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
		// 
		// 				strOut += strTemp;
		// 			}	
		// 		}

		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	


		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录当前相机平台各个轴的绝对位置


	// 释放内存
	// 	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	// 	{
	// 		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
	// 		{
	// 			delete vpCamPlatformXYAxisPos.at(i);
	// 			vpCamPlatformXYAxisPos.at(i) = NULL;
	// 		}
	// 	}	

	// 	if (pTemMarkImagePos!=NULL)
	// 	{
	// 		delete pTemMarkImagePos;
	// 		pTemMarkImagePos = NULL;
	// 	}

	if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(TRUE);//SendCommInfo(CMD_TGG_SEARCH_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

// 单相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSingleCameraAlignerTargetSearchCandidateExFTGC(int nPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VTGC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd)/*m_bValidTargetSearchTool!=TRUE*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);;//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_SEARCH_FAILE);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;

	// 	if (nCamNum != 1)
	// 	{
	// 		SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
	// 		return FALSE;
	// 	}
	// 	
	int i=0;
	CString strTempCamPos = _T("");
	CString strTempCam = _T("");
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			strTempCamPos.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_CPFAST_STR_POS), i + 1);
			strTempCam += strTempCamPos;;	//zzc报警 相机x掉线，1,2,3,4

			if (i == nCamNum - 1)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION), strTempCam);
				SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);;// SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
				return FALSE;
			}
		}    	
	}

	scTimer stSearchTimer;
	stSearchTimer.Reset();


	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		CameraParamEnable cameraParamEnable = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nStartPatIndex);

		BOOL bTargetShutter =(cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//			if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)			
		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter /*&& (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eTargetSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType, nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (nPosIndex >= m_vpTargetPlatformAxisPos.size() || m_vpTargetPlatformAxisPos.at(nPosIndex) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))		
	if (!bCommuciateGetPlatformAxisAbsPos)	
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);;//	SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		SetTargetPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
		SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
		SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		if (optionInfo.m_bEnableMutiTarget)
		{
			SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
		}

		// 多标记点模式，设置各个位置的轴位置
		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if (NULL !=pAlignerParam && optionInfo.m_bEnableMultiMarkMode
			&& ((sysPlatformInfo.m_bTargetObjectCamSeparate && nPosIndex== sysPlatformInfo.m_nPositionNum/2) || (sysPlatformInfo.m_bTargetObjectCamSeparate==FALSE && nPosIndex== 0) ))
		{
			int nStartPos = 0;
			if (sysPlatformInfo.m_bTargetObjectCamSeparate)
			{
				nStartPos = sysPlatformInfo.m_nPositionNum/2;
			}

			for (int nTempIndex = nStartPos; nTempIndex < sysPlatformInfo.m_nPositionNum; nTempIndex++)
			{
				SetTargetPlatformPos_MultiEx(pPlatformAxisPos,nTempIndex);
				SetTargetPlatformPos(pPlatformAxisPos,nTempIndex);
				SetTempTargetPlatformAxisPos(nTempIndex,pPlatformAxisPos);
				if (optionInfo.m_bEnableMutiTarget)
				{
					SetMutiTargetPlatformPos(pPlatformAxisPos,nTempIndex);
				}
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	int nNum = m_pPlatformInfo->m_nCamNum;
	//	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;
	// 2. 等待相机移动到不同位置，并定位
	//	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	//	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	if (0/*(m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX)*/)
	{

		{
			pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
			vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);      
		}

		if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos))
		{
			if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_GET_CAMERA_PLATFORM_POS_FAILED_II);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
		else
		{
			//SetTargetCamPlatformPos(vpCamPlatformXYAxisPos,nPosIndex);

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strInfo;
				strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_CAM_PLATFORM_POS);
				strInfo = strTemp + strInfo;

				for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
				{
					strTemp = _T("");
					strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
					strInfo = strInfo + strTemp;
				}

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));
				// 				fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);		

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}
		}	
	}




	CMarkImagePos* pTemMarkImagePos = NULL;
	{
		//	pTemMarkImagePos = new CMarkImagePos;
		//	pTemMarkImagePos->SetMarkImagePosNum(nNum);


		{ 	
			// 等待搜索延时
			int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
			Sleep(nDelayTime);

			// 准备开始定位			
			std::vector<int> vnPosIndex;
			std::vector<SearchMode> vsmSearchMode;	
			vnPosIndex.push_back(nPosIndex);		//
			//ShowExtraGuiToDisplay(vnPosIndex, FALSE);
			vsmSearchMode.push_back(eTargetSearch);	// 

			// 定义全部位置向量，包含0/1对象和2/3目标
			std::vector<int> vnAllPosIndex;
			int nAllPosIndex = 0;
			if (nPosIndex>=GetPosNum()/2)
			{
				nAllPosIndex = nPosIndex- GetPosNum()/2;
				vnAllPosIndex.push_back(nAllPosIndex);

				nAllPosIndex = nPosIndex;
				vnAllPosIndex.push_back(nAllPosIndex);
			}


			// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				// 隐藏目标定位结果十字，全部0/1/2/3图像
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
				// 				// 隐藏目标定位结果文字，全部0/1/2/3图像
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
				// 
				// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
				// 				}
				// 
				// //				if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
				// 				}

				m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);

			}
			else
			{
				// 隐藏目标定位结果十字，目标2/3图像
				m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
				// 				// 隐藏目标定位结果文字，目标2/3图像
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
				// 
				// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
				// 				}
				// 
				// //				if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
				// 				{
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
				// 				}

			}


			// 采集搜索图像
			if (!SnapSearchImage(vnPosIndex))
			{
				if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
				// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedSnapSearchImage(strCmd);
				return FALSE;
			}

			// 定位
			BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
			BOOL bSearchSucceed = FALSE;
			if (bTargetSearchCandidate == FALSE)
			{
				m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
				m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
			else
			{
				if (nStartPatIndex >= 0 && nStartPatIndex < TARGETCANDIDATENUM)
				{
					m_vnTargetSearchStartPatIndex[nPosIndex] = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					m_vnTargetSearchStartPatIndex[nPosIndex] = m_vnTargetSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
				}			
				m_vnTargetSearchEndPatIndex[nPosIndex] = TARGETCANDIDATENUM;
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}

			if (FALSE == bSearchSucceed)
			{
				if (optionInfo.m_bSearchTimes)
				{
					for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
					{
						//定位延时	 m_nSearchDelayTime
						Sleep(optionInfo.m_nSearchDelayTime);
						// 采集搜索图像
						if (!SnapSearchImage(vnPosIndex))
						{
							if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

							// 							m_bStatusBar = FALSE;
							// 							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
							// 							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
							// 							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							// 							PostMessageUpdateStatusBarInfo();
							OnFailedSnapSearchImage(strCmd);
							return FALSE;
						}

						// 定位
						BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
						if (bTargetSearchCandidate == FALSE)
						{
							m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
							m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
						else
						{
							if (nStartPatIndex >= 0 && nStartPatIndex < TARGETCANDIDATENUM)
							{
								m_vnTargetSearchStartPatIndex[nPosIndex] = nStartPatIndex;
							}
							else if (nStartPatIndex == 9)
							{
								m_vnTargetSearchStartPatIndex[nPosIndex] = m_vnTargetSearchSuccessPatIndex[nPosIndex];
							}
							else
							{
								m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
							}			
							m_vnTargetSearchEndPatIndex[nPosIndex] = TARGETCANDIDATENUM;
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}

						if (bSearchSucceed)
						{
							break;
						}
					}
				}
			}

			if (TRUE == bSearchSucceed)
			{
				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
				m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			}
			else
			{
				if (optionInfo.m_bManualAfTarSearchFail  && optionInfo.m_bEnableMultiMarkMode==FALSE)
				{
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉弹出手动搜索框
						SetPlcManualSearch(TRUE);
					}

					if (FALSE == ExcuteManualSearch(0,vnPosIndex))
					{
						if (optionInfo.m_bSetVisionManualSearchToPLC)
						{
							// 通知PLC，视觉关闭手动搜索框
							SetPlcManualSearch(FALSE);
						}

					}
					else
					{
						bSearchSucceed = TRUE;
					}
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉关闭手动搜索框
						SetPlcManualSearch(FALSE);
					}


				}

			}

			// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				int nHomoPosIndex = 0;
				std::vector<int> vnHomoPosIndex;			// 源目标位置
				vnHomoPosIndex.push_back(nPosIndex);		

				// 对目标2和3循环进行映射
				for (int i = 0; i<vnHomoPosIndex.size(); i++)
				{
					nHomoPosIndex = vnHomoPosIndex.at(i);
					if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
					{
						CCoordPos ObjImgPos;
						CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

						// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
						if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
						{
							//	ReportTargetSearchResultFTGM(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
							m_strStatusBarInfo2.Format(_T(""));
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

							//return FALSE;
						}

						// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
						m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
					}
				}

				// 设定、显示目标定位结果十字，全部0/1/2/3图像
				//                 SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
				//                 PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
				m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
				// 				if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
				// 				{
				// 					SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
				// 					PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
				// 				}
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				//                 {
				//                     SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				//                     PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				//                 }
				//                 // 设定、显示目标定位结果文字，全部0/1/2/3图像
				//                 SetShowGuiTargetImageMarkPos(vnAllPosIndex);
				//                 PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
			}
			else
			{
				// 设定、显示结果图形
				//                 SetGuiAlnTargetImageMarkPos(vnPosIndex);
				//                 PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
				// 				if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
				// 				{
				// 					SetGuiAlnTargetImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				//                 {
				//                     SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				//                     PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				//                 }
				//                 // SY
				//                 SetShowGuiTargetImageMarkPos(vnPosIndex);
				//                 PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
			}

			//			ShowExtraGuiToDisplay(vnPosIndex, TRUE,0);

			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
			{
				//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
				ExeSaveVDBFile(vnPosIndex,eTargetSearch);
			}
			if (bSearchSucceed)
			{

			}
			else
			{
				if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);//SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_TARGET_SEARCH_FAILED), nPosIndex+1);
				m_strStatusBarInfo2 = m_StrSearchErrorInfo;
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
				m_strStatusBarInfo1 += m_StrSearchErrorInfo;
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

				return FALSE;
			}
		}	

	}

	// 3. 设置对位工具
	//	if (pTemMarkImagePos)
	{
		//m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
		SetMultiEXTargetMarkSearchResultsWithCombinationCode(m_mpTargetMarkImagePos);
		SetTargetMarkSearchResults(m_mpTargetMarkImagePos); // ?
		if (optionInfo.m_bEnableMutiTarget)
		{
			m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
			m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
		}
		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}   

	// 4. 设置相机平台的绝对位置
	//SetTargetCamPlatformPos(vpCamPlatformXYAxisPos);

	// 5.多标记点模式下 检查尺寸
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CAlignerParam* pAlignerParam = GetProductAlignerParam();
	if (NULL !=pAlignerParam && optionInfo.m_bEnableMultiMarkMode &&  optionInfo.m_bEnableMultiMarkMode)
	{
		// 计算目标距离
		//		CalculateTargetDistance(); 
		if (!CheckTargetDistance())
		{
			if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
			//m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_StrSearchErrorInfo;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			//			RecordTargetSizeIndfo(TRUE, FALSE);

			return FALSE;
		}

		//		RecordTargetSizeIndfo(TRUE, TRUE);


		if (!CheckTargetAngle())
		{
			if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("目标角度超过设定标准，目标定位结果可能出错");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");
		// 		if (pTemMarkImagePos)
		// 		{
		// 			for (int i=0; i<pTemMarkImagePos->GetMarkImagePosNum(); i++)
		// 			{
		// 				strTemp = _T("");
		// 				cp = pTemMarkImagePos->GetMarkImagePos(i);
		// 
		// 				strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
		// 
		// 				strOut += strTemp;
		// 			}	
		// 		}

		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录当前相机平台各个轴的绝对位置


	// 释放内存
	// 	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	// 	{
	// 		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
	// 		{
	// 			delete vpCamPlatformXYAxisPos.at(i);
	// 			vpCamPlatformXYAxisPos.at(i) = NULL;
	// 		}
	// 	}	

	// 	if (pTemMarkImagePos!=NULL)
	// 	{
	// 		delete pTemMarkImagePos;
	// 		pTemMarkImagePos = NULL;
	// 	}
	std::vector<int> vnPosIndex;
	vnPosIndex.push_back(nPosIndex);
	/*for (int i=0;i<vnPosIndex.size();i++)
	{
	int nIndx=vnPosIndex.at(i);
	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
	m_vbIsTargetPosSearchFinished.at(nIndx-GetPosNum()/2)=TRUE;
	}
	else
	{
	m_vbIsTargetPosSearchFinished.at(nIndx)=TRUE;
	}

	}

	BOOL bAllTargetPosSearch=TRUE;
	for (int i=0;i<m_vbIsTargetPosSearchFinished.size();i++)
	{
	bAllTargetPosSearch=bAllTargetPosSearch && m_vbIsTargetPosSearchFinished.at(i);
	}
	m_bAllTargetPosSearchSuccess=bAllTargetPosSearch;*/


	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1 /*&& m_bAllObjectPosSearchSuccess && m_bAllTargetPosSearchSuccess*/)
	{
		/*for (int i=0;i<m_vbIsTargetPosSearchFinished.size();i++)
		{
		m_vbIsTargetPosSearchFinished.at(i) = FALSE;
		}
		m_bAllTargetPosSearchSuccess = FALSE;*/
		return ExecuteAlignAfterFOBCAndFTGC(vnPosIndex,2);
	}


	if(m_bTargetSearchTest) ReportTargetSearchResult(TRUE, m_vnTargetSearchSuccessPatIndex[nPosIndex]);//SendCommInfo(CMD_TGG_SEARCH_SUCCEED);

	/*m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();*/

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportCalTargetFixOffsetFAFO(BOOL bResult,std::vector<int> vnPosIndex,std::vector<CCoordPos> &vCoordPos,std::vector<CPlatformXYDAxisPos>& vPlatformAixs,std::vector<CCoordPos> &vBoardPos)
{
	if (bResult)
	{
		if (vnPosIndex.size()!= vCoordPos.size() && vnPosIndex.size()!=vPlatformAixs.size() && vnPosIndex.size()!=vBoardPos.size())
		{
			return FALSE;
		}
	}

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReCalTargetFixOffsetFAFO(strSimpleInfo,bResult,vnPosIndex,vCoordPos,vPlatformAixs,vBoardPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (bResult)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcCalTargetFixOffsetFAFOPos(strSend, bResult,vnPosIndex,vCoordPos,vPlatformAixs,vBoardPos))
			{
				return FALSE;
			}
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			//if (FALSE == m_XYDCommProtocol.PackRePlcCalTargetFixOffsetFAFOBoardPos(strSend, bResult,vnPosIndex,vBoardPos))
			//{
			//	return FALSE;
			//}
			//bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			//if (bReceived == FALSE || nCommStatus != eCommSucceed)
			//{
			//	return FALSE;
			//}
		}
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCalTargetFixOffsetFAFO(strSend,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}
		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCalTargetFixOffsetFAFO(strInfo,bResult,vnPosIndex,vCoordPos,vPlatformAixs,vBoardPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}
	return TRUE;
}

BOOL vcXYDVisionAlign::ReportGetTargetImagePosFGTP(BOOL bResult,std::vector<int> vnPosIndex,std::vector<CCoordPos> &vImagePos,std::vector<CPlatformXYDAxisPos>& vPlatformAixs)
{
	if (bResult)
	{
		if (vnPosIndex.size()!= vImagePos.size() && vnPosIndex.size()!=vPlatformAixs.size())
		{
			return FALSE;
		}
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetTargetImagePosFGTP(strSimpleInfo,bResult,vnPosIndex,vImagePos,vPlatformAixs);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (bResult)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcGetTargetImagePosFGTPPos(strSend, bResult,vnPosIndex,vImagePos,vPlatformAixs))
			{
				return FALSE;
			}
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetTargetImagePosFGTP(strSend,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}
		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetTargetImagePosFGTP(strInfo,bResult,vnPosIndex,vImagePos,vPlatformAixs))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}
	return TRUE;
}

BOOL vcXYDVisionAlign::ReportGetTargetPlatformPosFGTW(BOOL bResult,std::vector<int> vnPosIndex,std::vector<CCoordPos> &vCoordPos,std::vector<CPlatformXYDAxisPos>& vPlatformAixs)
{
	if (bResult)
	{
		if (vnPosIndex.size()!= vCoordPos.size() && vnPosIndex.size()!=vPlatformAixs.size())
		{
			return FALSE;
		}
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetTargetPlatformPosFGTW(strSimpleInfo,bResult,vnPosIndex,vCoordPos,vPlatformAixs);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (bResult)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcGetTargetPlartformPosFGTWPos(strSend, bResult,vnPosIndex,vCoordPos,vPlatformAixs))
			{
				return FALSE;
			}
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetTargetPlartformPosFGTW(strSend,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}
		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetTargetPlatformPosFGTW(strInfo,bResult,vnPosIndex,vCoordPos,vPlatformAixs))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}
	return TRUE;
}

// 单相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSingleCameraAlignerObjectSearchExFOBJ(int nPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOBJ:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_SEARCH_FAILE);//_T("对象拍照失败");;
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	CString strTempCamPos = _T("");
	CString strTempCam = _T("");
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			strTempCamPos.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_CPFAST_STR_POS), i + 1);
			strTempCam += strTempCamPos;;	//zzc报警 相机x掉线，1,2,3,4
			if (i == nCamNum - 1)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION), strTempCam);
				SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				if(m_bObjectSearchTest)ReportObjectSearchResult(FALSE);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
				return FALSE;
			}
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(0);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eObjectSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}

		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (nPosIndex >= m_vpObjectPlatformAxisPos.size() || m_vpObjectPlatformAxisPos.at(nPosIndex) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}	
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}


	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
			}
			//D角度不累加
		}
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		if(m_bObjectSearchTest)ReportObjectSearchResult(FALSE);
		return FALSE;
	}
	else
	{ 
		SetObjectPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
		SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		}

		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		//CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
		{
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex+1);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex+1,pPlatformAxisPos);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 等待相机移动到不同位置，并定位
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;	

	int nNum = m_pPlatformInfo->m_nPositionNum;
	//	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;	


	{

		// 等待搜索延时
		// 		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		// 		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
		// 		Sleep(nDelayTime);

		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
		int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
		BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

		// 自动对位过程中
		if (m_bAutoAlign == TRUE)
		{
			// 使用对象搜索延时2
			if (TRUE == bEnableDelayTime2)
			{
				if (1 == m_nAlignTime)
				{
					Sleep(nDelayTime);
				}
				else
				{
					Sleep(nDelayTime2);
				}
			}
			else
			{
				// 不使用对象搜索延时2，按照第一个搜索延时设置
				Sleep(nDelayTime);
			}

		}
		else
		{
			// 如果只接收到定位指令，按第一个对象搜索延时进行设置
			Sleep(nDelayTime);
		}

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eObjectSearch);	// 


		// 隐藏结果图形
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// 
		// //		if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 
		// 		// SY
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);

		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		//CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
		{
			std::vector<int> vnPosIndex1;
			vnPosIndex1.push_back(nPosIndex+1);
			// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex1, FALSE);
			// //			if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
			// 			{
			// 				PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex1, FALSE);
			// 			}
			// 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex1, FALSE);
			m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex1, eObjectSearch);

		}



		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{
			if(m_bObjectSearchTest)ReportObjectSearchResult(FALSE);

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
			// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();
			OnFailedSnapSearchImage(strCmd);
			return FALSE;
		}

		if ((m_pPlatformInfo->m_nPositionNum>1) && (optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (m_pSystempOptionConfig->m_nDisplayMode == 1))
		{
			std::vector<int> vnPosIndex1;
			vnPosIndex1.push_back(nPosIndex+1);
			SnapSearchImage(vnPosIndex1);
		}

		//定位
		BOOL bSearchSucceed = FALSE;
		if(optionInfo.m_bEnableSearchCindidate)
		{
			BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
			if (bObjectSearchCandidate == FALSE)
			{
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
				m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
			else
			{
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
				m_vnObjectSearchEndPatIndex[nPosIndex] = OBJECTCANDIDATENUM-1;
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
		else
		{
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}

		if (FALSE == bSearchSucceed)
		{
			if (optionInfo.m_bSearchTimes)
			{
				for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
				{
					//定位延时	 m_nSearchDelayTime
					Sleep(optionInfo.m_nSearchDelayTime);
					// 采集搜索图像
					if (!SnapSearchImage(vnPosIndex))
					{
						if(m_bObjectSearchTest)ReportObjectSearchResult(FALSE);

						// 						m_bStatusBar = FALSE;
						// 						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
						// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
						// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						// 						PostMessageUpdateStatusBarInfo();
						OnFailedSnapSearchImage(strCmd);
						return FALSE;
					}

					// 帧有效显示时，刷新位置1图像
					if ((m_pPlatformInfo->m_nPositionNum>1) && (optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (m_pSystempOptionConfig->m_nDisplayMode == 1))
					{
						std::vector<int> vnPosIndex1;
						vnPosIndex1.push_back(nPosIndex+1);
						SnapSearchImage(vnPosIndex1);
					}


					//定位
					if(optionInfo.m_bEnableSearchCindidate)
					{
						BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
						if (bObjectSearchCandidate == FALSE)
						{
							m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
							m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
						else
						{
							m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
							m_vnObjectSearchEndPatIndex[nPosIndex] = OBJECTCANDIDATENUM-1;
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
					else
					{
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}

					if (bSearchSucceed)
					{
						break;
					}
				}
			}
		}

		if(TRUE == bSearchSucceed)
		{
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
			if (optionInfo.m_bManualAfObjSearchFail)
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉弹出手动搜索框
					SetPlcManualSearch(TRUE);
				}

				if (FALSE ==ExcuteManualSearch(1,vnPosIndex))
				{
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉关闭手动搜索框
						SetPlcManualSearch(FALSE);
					}

					for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
					{
						if (vpCamPlatformXYAxisPos.at(i)!=NULL)
						{
							delete vpCamPlatformXYAxisPos.at(i);
							vpCamPlatformXYAxisPos.at(i) = NULL;
						}
					}

					/*return FALSE;*/
				}
				else
				{
					if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
					{
						std::vector<int> vnPosIndex1;
						vnPosIndex1.push_back(nPosIndex+1);

						if (FALSE ==ExcuteManualSearch(1,vnPosIndex1))
						{
							if (optionInfo.m_bSetVisionManualSearchToPLC)
							{
								// 通知PLC，视觉关闭手动搜索框
								SetPlcManualSearch(FALSE);
							}

							for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
							{
								if (vpCamPlatformXYAxisPos.at(i)!=NULL)
								{
									delete vpCamPlatformXYAxisPos.at(i);
									vpCamPlatformXYAxisPos.at(i) = NULL;
								}
							}

						}
						else
						{
							bSearchSucceed = TRUE;
						}
					}
					else
					{
						bSearchSucceed = TRUE;
					}
				}

				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

			}
		}
		// 设定、显示结果图形
		//         SetGuiAlnObjectImageMarkPos(vnPosIndex);
		//         PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
		// 
		//         if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
		//         {
		//             SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // SY
		//         SetShowGuiObjectImageMarkPos(vnPosIndex);
		//         PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

		//CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
		{
			std::vector<int> vnPosIndex1;
			vnPosIndex1.push_back(nPosIndex+1);
			// 
			//             SetGuiAlnObjectImageMarkPos(vnPosIndex1);
			//             PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex1, TRUE);
			// 
			//             if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
			//             {
			//                 SetGuiAlnObjectLineImageMarkPos(vnPosIndex1);
			//                 PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex1, TRUE);
			//             }
			// 
			//             SetShowGuiObjectImageMarkPos(vnPosIndex1);
			//             PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex1, TRUE);
			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex1, eObjectSearch);

		}

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile&&m_pVisionASMConfig->m_DataRecord.m_bSaveObjectSnapVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
			ExeSaveVDBFile(vnPosIndex,eObjectSearch);
		}
		if (bSearchSucceed)
		{

		}
		else
		{
			if(m_bObjectSearchTest)ReportObjectSearchResult(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_OBJECT_SEARCH_FAILED),nPosIndex+1);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
	}

	// 3. 设置对位工具
	//	if (pTemMarkImagePos)
	{
		SetMultiEXObjectMarkSearchResultsWithCombinationCode(m_mpObjectMarkImagePos);
		SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
		}
	}

	// 4. 设置相机平台的绝对位置
	//SetObjectCamPlatformPos(vpCamPlatformXYAxisPos);

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");
		//	if (pTemMarkImagePos)
		{
			for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

				strOut += strTemp;
			}		
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录当前相机平台各个轴的绝对位置
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strInfo;
		strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_CAM_PLATFORM_POS);
		strInfo = strTemp + strInfo;

		for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));
		// 		fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
	}

	// 释放内存
	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	{
		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
		{
			delete vpCamPlatformXYAxisPos.at(i);
			vpCamPlatformXYAxisPos.at(i) = NULL;
		}
	}	

	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1 )
	{
		return ExecuteAlignAfterFOBJAndFTGT(1);
	}
	//m_bStatusBar = TRUE;
	//m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
	//m_strStatusBarInfo2 = _T("");
	//m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	//SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	if(m_bObjectSearchTest)ReportObjectSearchResult(TRUE);
	return TRUE;

}

BOOL vcXYDVisionAlign::OnSingleCameraAlignerTargetSearchExFCNO(int nPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCNO:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (!CheckAlignerSearchTool(strCmd)/*m_bValidTargetSearchTool!=TRUE*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
		return FALSE;
	}

	if (!CheckCommuciation(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
		return FALSE;
	}

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_SEARCH_FAILE);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}


	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));
			if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;
	stSearchTimer.Reset();

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(0);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eTargetSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////


	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (nPosIndex >= m_vpTargetPlatformAxisPos.size() || m_vpTargetPlatformAxisPos.at(nPosIndex) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (!bCommuciateGetPlatformAxisAbsPos)	
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);//	SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	else
	{ 
		SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
		SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);

		// 		if (m_bIsMutiTarget && m_pSystempOptionConfig->m_bEnableMutiTarget)
		// 		{
		// 			SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
		// 		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;

			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	int nNum = m_pPlatformInfo->m_nCamNum;

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	vnPosIndex.push_back(nPosIndex);
	vsmSearchMode.push_back(eTargetSearch);

	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;
	if (nPosIndex>=GetPosNum()/2)
	{
		nAllPosIndex = nPosIndex- GetPosNum()/2;
		vnAllPosIndex.push_back(nAllPosIndex);

		nAllPosIndex = nPosIndex;
		vnAllPosIndex.push_back(nAllPosIndex);
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate /*&&  m_pSystempOptionConfig->m_bShowSepTargetPos*/ /* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// //		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);
	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (m_pSystempOptionConfig->m_bShowCornerTool && m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);

	}

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		if (bTargetSearchCandidate == FALSE)
		{
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;		
			m_vnTargetSearchEndPatIndex[nPosIndex] = TARGETCANDIDATENUM-1;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
	}
	else
	{
		m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
		m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				if(optionInfo.m_bEnableSearchCindidate)
				{
					BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
					if (bTargetSearchCandidate == FALSE)
					{
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;		
						m_vnTargetSearchEndPatIndex[nPosIndex] = TARGETCANDIDATENUM-1;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
				}
				else
				{
					m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
					m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}


			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}

		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		vnHomoPosIndex.push_back(nPosIndex);		

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		// 		SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);

		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);

		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// 设定、显示目标定位结果文字，全部0/1/2/3图像
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
		// 
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, TRUE, 0);
	}
	else
	{
		// 设定、显示结果图形
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

		// 		SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// SY
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, TRUE, 0);
	}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}

	if (bSearchSucceed)
	{


	}
	else
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);//SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_TARGET_SEARCH_FAILED), nPosIndex+1);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	// 	if (m_bIsMutiTarget && m_pSystempOptionConfig->m_bEnableMutiTarget)
	// 	{
	// 		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
	// 		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	// 	}
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex()); 




	// 设置对象位置为图像中心
	for(i = 0; i < vnPosIndex.size(); i++)
	{
		int nPosIndex = vnPosIndex.at(i);

		CCoordPos cpImageMarkPos;
		cpImageMarkPos.m_dPosX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
		cpImageMarkPos.m_dPosY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;
		cpImageMarkPos.m_dAngle = 0;

		m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpImageMarkPos);
	}

	// 	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	// 	{
	// 		SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 
	// 	if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	// 	{
	// 		SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 
	// 	// SY
	// 	SetShowGuiObjectImageMarkPos(vnPosIndex);
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
	// 
	// 	ShowExtraGuiToDisplay(vnPosIndex, TRUE, 1);
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);


	SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 
	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}


	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;
		CCoordPos cp;

		strOut = strTemp + _T("TargetSearch: ");

		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(TRUE);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::OnSingleCameraAlignerObjectSearchExFCNT(int nPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCNT:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckObjectSearchTool(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_SEARCH_FAILE);//_T("对象拍照失败");;
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));
			if(m_bObjectSearchTest)ReportObjectSearchResultFCNT(FALSE);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(0);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eObjectSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (nPosIndex >= m_vpObjectPlatformAxisPos.size() || m_vpObjectPlatformAxisPos.at(nPosIndex) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}	
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
			}
			//D角度不累加
		}
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		if(m_bObjectSearchTest)ReportObjectSearchResultFCNT(FALSE);
		return FALSE;
	}
	else
	{ 
		SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		}

		// 目标对象分离时设置当前轴位置到3/4位置
		if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
		{
			int nPosSeparate = nPosIndex+GetPosNum()/2;
			if (nPosSeparate < 0 || nPosSeparate >= GetPosNum())
			{
				if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_SEARCH_FAILE);//_T("对象拍照失败");;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				return FALSE;
			}
			SetTargetPlatformPos(pPlatformAxisPos,nPosSeparate);
			SetTempTargetPlatformAxisPos(nPosSeparate,pPlatformAxisPos);
		}
		else
		{
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		}


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 等待相机移动到不同位置，并定位
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;	

	int nNum = m_pPlatformInfo->m_nPositionNum;
	//	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;	

	//   CMarkImagePos* pTemMarkImagePos = NULL;	
	{
		// 等待搜索延时
		// 		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		// 		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
		// 		Sleep(nDelayTime);

		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
		int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
		BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

		// 自动对位过程中
		if (m_bAutoAlign == TRUE)
		{
			// 使用对象搜索延时2
			if (TRUE == bEnableDelayTime2)
			{
				if (1 == m_nAlignTime)
				{
					Sleep(nDelayTime);
				}
				else
				{
					Sleep(nDelayTime2);
				}
			}
			else
			{
				// 不使用对象搜索延时2，按照第一个搜索延时设置
				Sleep(nDelayTime);
			}

		}
		else
		{
			// 如果只接收到定位指令，按第一个对象搜索延时进行设置
			Sleep(nDelayTime);
		}

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nPosIndex);
		vsmSearchMode.push_back(eObjectSearch);	

		// 隐藏结果图形
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// 
		// //		if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		// SY
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);

		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);


		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{
			if(m_bObjectSearchTest)ReportObjectSearchResultFCNT(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}

		// 定位
		m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
		m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

		if (FALSE == bSearchSucceed)
		{
			if (optionInfo.m_bSearchTimes)
			{
				for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
				{
					// 使用对象搜索延时2
					if (TRUE == bEnableDelayTime2)
					{
						Sleep(nDelayTime2);
					}

					// 采集搜索图像
					if (!SnapSearchImage(vnPosIndex))
					{
						if(m_bObjectSearchTest)ReportObjectSearchResultFCNT(FALSE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

						return FALSE;
					}

					// 定位
					m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
					m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

					if (bSearchSucceed)
					{
						break;
					}
				}
			}
		}


		if (FALSE == bSearchSucceed)
		{
			if (optionInfo.m_bManualAfObjSearchFail)
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉弹出手动搜索框
					SetPlcManualSearch(TRUE);
				}

				if (FALSE ==ExcuteManualSearch(1,vnPosIndex))
				{
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉关闭手动搜索框
						SetPlcManualSearch(FALSE);
					}
				}
				else
				{
					bSearchSucceed = TRUE;
				}
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

			}
		}

		// 设定、显示结果图形
		//         SetGuiAlnObjectImageMarkPos(vnPosIndex);
		//         PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
		// 		if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnObjectImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		//         if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
		//         {
		//             SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		// 
		//         // SY
		//         SetShowGuiObjectImageMarkPos(vnPosIndex);
		//         PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);



		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
			ExeSaveVDBFile(vnPosIndex,eObjectSearch);
		}
		if (bSearchSucceed)
		{

		}
		else
		{
			//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_SEARCH_ERR);
			if(m_bObjectSearchTest)ReportObjectSearchResultFCNT(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_OBJECT_SEARCH_FAILED),nPosIndex+1);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}


		// 设置目标位置为图像中心
		for(i = 0; i < vnPosIndex.size(); i++)
		{
			int nPosIndex = vnPosIndex.at(i);

			// 目标对象分离时设置图像中心为3/4位置
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				int nPosSeparate = nPosIndex+GetPosNum()/2;
				CCoordPos cpImageMarkPos;
				cpImageMarkPos.m_dPosX = GetPosDisplay(nPosSeparate)->GetImageWidth()/2;
				cpImageMarkPos.m_dPosY = GetPosDisplay(nPosSeparate)->GetImageHeight()/2;
				cpImageMarkPos.m_dAngle = 0;

				m_mpTargetMarkImagePos.SetMarkImagePos(nPosSeparate, TRUE, cpImageMarkPos);
			}
			else
			{
				CCoordPos cpImageMarkPos;
				cpImageMarkPos.m_dPosX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
				cpImageMarkPos.m_dPosY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;
				cpImageMarkPos.m_dAngle = 0;

				m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpImageMarkPos);
			}
		}		

		// 定义全部位置向量，包含0/1对象和2/3目标
		std::vector<int> vnAllPosIndex;
		int nAllPosIndex = 0;
		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex- GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);
		}
		// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
		if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
		{
			int nHomoPosIndex = 0;
			std::vector<int> vnHomoPosIndex;			// 源目标位置
			vnHomoPosIndex.push_back(nPosIndex);		

			// 对目标2和3循环进行映射
			for (int i = 0; i<vnHomoPosIndex.size(); i++)
			{
				nHomoPosIndex = vnHomoPosIndex.at(i);
				if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
				{
					CCoordPos ObjImgPos;
					CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

					// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
					if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
					{
						//	ReportTargetSearchResultFTGM(FALSE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
						m_strStatusBarInfo2.Format(_T(""));
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						//return FALSE;
					}

					// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
					m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
				}
			}

			// 设定、显示目标定位结果十字，全部0/1/2/3图像
			// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
			// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);

			m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);

			// 			if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
			// 			{
			// 				SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
			// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
			// 			}
			// 
			// 			if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
			// 			{
			// 				SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
			// 				PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
			// 			}
			// 			// 设定、显示目标定位结果文字，全部0/1/2/3图像
			// 			SetShowGuiTargetImageMarkPos(vnAllPosIndex);
			// 			PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
		}
		else
		{
			// 设置目标显示
			// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);

			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);


			// 			if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
			// 			{
			// 				SetGuiAlnTargetImageMarkPos(vnPosIndex);
			// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
			// 			}
			// 
			// 			if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
			// 			{
			// 				SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
			// 				PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
			// 			}
			// 			// SY
			// 			SetShowGuiTargetImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
		}

	}


	// 3. 设置对位工具
	//	if (pTemMarkImagePos)
	{
		SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 
		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
		}
	}

	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 4. 设置相机平台的绝对位置
	//SetObjectCamPlatformPos(vpCamPlatformXYAxisPos);

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");
		//	if (pTemMarkImagePos)
		{
			for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

				strOut += strTemp;
			}		
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录当前相机平台各个轴的绝对位置
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strInfo;
		strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_CAM_PLATFORM_POS);
		strInfo = strTemp + strInfo;

		for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));
		// 		fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
	}

	// 释放内存
	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	{
		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
		{
			delete vpCamPlatformXYAxisPos.at(i);
			vpCamPlatformXYAxisPos.at(i) = NULL;
		}
	}	

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	if(m_bObjectSearchTest)ReportObjectSearchResultFCNT(TRUE);

	return TRUE;

}


CMarkImagePos vcXYDVisionAlign::GetObjectMarkImagePos()
{
	return m_mpObjectMarkImagePos;
}

// 目标图像坐标相对于图像中心的像素偏移量
BOOL vcXYDVisionAlign::OnSingleCameraAlignerSearchExFGTC(int nPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VGTC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	double dImagePosX = 0;
	double dImagePosY = 0;
	double dImagePosD = 0;
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = _T("");
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);

		return FALSE;
	}

	if (NULL == GetPosDisplay(nPosIndex))
	{
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = _T("");
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_GETDISPLAYPOINTERFAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);

		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);

			return FALSE;
		}    	
	}

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		//		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);;//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);
		if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_SEARCH_FAILE);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nStartPatIndex);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//			if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)			
		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter /*&& (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eTargetSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType, nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}



	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	vnPosIndex.push_back(nPosIndex); 	
	vsmSearchMode.push_back(eTargetSearch);

	// 隐藏目标定位结果十字，目标2/3图像
	// 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
	// 	// 隐藏目标定位结果文字，目标2/3图像
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
	// 
	// //	if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
	// 	{
	// 		PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	// 
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		//		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
		if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
	BOOL bSearchSucceed = FALSE;
	if (bTargetSearchCandidate == FALSE)
	{
		m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
		m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (nStartPatIndex >= 0 && nStartPatIndex < TARGETCANDIDATENUM)
		{
			m_vnTargetSearchStartPatIndex[nPosIndex] = nStartPatIndex;
		}
		else if (nStartPatIndex == 9)
		{
			m_vnTargetSearchStartPatIndex[nPosIndex] = m_vnTargetSearchSuccessPatIndex[nPosIndex];
		}
		else
		{
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
		}	

		m_vnTargetSearchEndPatIndex[nPosIndex] = TARGETCANDIDATENUM;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	// 设定、显示结果图形
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
	// 	SetGuiAlnTargetImageMarkPos(vnPosIndex);
	// 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
	// 	if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
	// 	{
	// 		SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 	// SY
	// 	SetShowGuiTargetImageMarkPos(vnPosIndex);
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);


	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				Sleep(nDelayTime);

				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
				if (bTargetSearchCandidate == FALSE)
				{
					m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
					m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
				else
				{
					if (nStartPatIndex >= 0 && nStartPatIndex < TARGETCANDIDATENUM)
					{
						m_vnTargetSearchStartPatIndex[nPosIndex] = nStartPatIndex;
					}
					else if (nStartPatIndex == 9)
					{
						m_vnTargetSearchStartPatIndex[nPosIndex] = m_vnTargetSearchSuccessPatIndex[nPosIndex];
					}
					else
					{
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
					}			
					m_vnTargetSearchEndPatIndex[nPosIndex] = TARGETCANDIDATENUM;
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				// 设定、显示结果图形
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
				// 				SetGuiAlnTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 
				// 				// SY
				// 				SetShowGuiTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bManualAfObjSearchFail)
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉弹出手动搜索框
					SetPlcManualSearch(TRUE);
				}


				// 弹出手动搜索框
				if (TRUE ==ExcuteManualSearch(0,vnPosIndex))
				{
					bSearchSucceed = TRUE;
				}

				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

			}
		}
	}

	if (FALSE == bSearchSucceed)
	{
		if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_OBJECT_SEARCH_FAILED),nPosIndex+1);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	SetTargetMarkSearchResults(m_mpTargetMarkImagePos); 
	SetMultiEXTargetMarkSearchResultsWithCombinationCode(m_mpTargetMarkImagePos);
	//	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());	
	if ((optionInfo.m_bSaveAlignPos && m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (optionInfo.m_bSaveAlignPos && m_bAutoAlign == FALSE))
	{
		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;
		CCoordPos cp;

		strOut = strTemp + _T("TargetSearch: ");

		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}


	BOOL bSucced = FALSE;
	bSucced = m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nPosIndex);

	if (bSucced)
	{
		// SY
		// 图像中心点
		double dImageCenterX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
		double dImageCenterY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;

		dImagePosX = m_mpTargetMarkImagePos.GetMarkImagePos(nPosIndex).m_dPosX;
		dImagePosY = m_mpTargetMarkImagePos.GetMarkImagePos(nPosIndex).m_dPosY;
		//		dImagePosD = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex).m_dAngle;

		dImagePosX = dImagePosX - dImageCenterX;
		dImagePosY = dImagePosY - dImageCenterY;
		dImagePosD = 0;


		if (fabs(dImagePosX) > dImageCenterX * 2 || fabs(dImagePosY) > dImageCenterY * 2)
		{
			if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
		else
		{
			if(m_bTargetSearchTest) ReportSearchResultFGTC(TRUE,dImagePosX,dImagePosY,dImagePosD);

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

		}

		return TRUE;

	}
	else
	{
		if(m_bTargetSearchTest) ReportSearchResultFGTC(FALSE,dImagePosX,dImagePosY,dImagePosD);
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;

	}

	return FALSE;

}


// 单相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSingleCameraAlignerSearchExFGAP(int nPosIndex, int nPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VGAP:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	double dImagePosX = 0;
	double dImagePosY = 0;
	double dImagePosD = 0;
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (!CheckObjectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = _T("");
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		if(m_bObjectSearchTest) ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	if (NULL == GetPosDisplay(nPosIndex))
	{
		m_bStatusBar = FALSE;
		//m_strStatusBarInfo1 = _T("");
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_GETDISPLAYPOINTERFAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		if(m_bObjectSearchTest) ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest)ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nPatIndex);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);


		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter/* && (0 == nPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eObjectSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nPatIndex))
			{
				// 					m_bStatusBar = FALSE;
				// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 					m_strStatusBarInfo2 = _T("");
				// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 					PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}


	// 等待搜索延时
	// 		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	// 		Sleep(nDelayTime);

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	vnPosIndex.push_back(nPosIndex); 	
	vsmSearchMode.push_back(eObjectSearch);	 

	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;
	if (nPosIndex>=GetPosNum()/2)
	{
		nAllPosIndex = nPosIndex- GetPosNum()/2;
		vnAllPosIndex.push_back(nAllPosIndex);

		nAllPosIndex = nPosIndex;
		vnAllPosIndex.push_back(nAllPosIndex);
	}
	if (0 == m_pPlatformInfo->m_nShowMode)
	{
		// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
		if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
		{

			// 隐藏目标定位结果十字，全部0/1/2/3图像
			// 				PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
			// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
			// 
			// //				if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
			// 				{
			// 					PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
			// 				}
			// //				if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
			// 				{
			// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
			// 				}
			// 
			// 				// 隐藏目标定位结果文字，全部0/1/2/3图像
			// 				PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
			// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
			// 
			// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
			// 				{
			// 					PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
			// 				}
			m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
			// 隐藏目标定位结果十字，全部0/1/2/3图像
			// 隐藏目标定位结果文字，全部0/1/2/3图像
			m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);

		}
		else
		{
			// 				PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
			// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
			// 
			// //				if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
			// 				{
			// 					PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
			// 				}
			// //				if (/*m_pSystempOptionConfig->m_bShowCornerTool && */m_bIsTargetCornerSearchTool)
			// 				{
			// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
			// 				}
			// 
			// 				// SY
			// 				PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
			// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
			// 
			// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
			// 				{
			// 					PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
			// 				}
			m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
			m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);
		}
	}
	else if(1 == m_pPlatformInfo->m_nShowMode)
	{
		//                 PostMessageUpdateAllGuiAlnObjectImagePosGraphics(FALSE);
		//                 PostMessageUpdateAllGuiAlnTargetImagePosGraphics(FALSE);
		// 
		// //				if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 				{
		// 					PostMessageUpdateAllGuiAlnObjectLineImagePosGraphics(FALSE);
		// 				}
		// //				if (/*m_pSystempOptionConfig->m_bShowCornerTool && */m_bIsTargetCornerSearchTool)
		// 				{
		// 					PostMessageUpdateAllGuiAlnTargetLineImagePosGraphics(FALSE);
		// 				}
		// 
		// 				// SY
		//                 PostMessageUpdateAllShowGuiObjectImagePosToDisplay(FALSE);
		//                 PostMessageUpdateAllShowGuiTargetImagePosToDisplay(FALSE);
		// 
		// 				if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 				{
		// 					PostMessageUpdateAllGuiAlnTargetRotatedImagePosGraphics(FALSE);
		// 				}
		std::vector<int> vnNull;
		m_cVisionAlignGui.SetPosGuiInvisible(vnNull, eObjectSearch);
		m_cVisionAlignGui.SetPosGuiInvisible(vnNull, eTargetSearch);
	}


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bObjectSearchTest)ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);

		// 			m_bStatusBar = FALSE;
		// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 			PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bSearchSucceed = FALSE;
	if (bObjectSearchCandidate == FALSE)
	{
		if (nPatIndex == 0)
		{
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			if(m_bObjectSearchTest)ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
			return FALSE;
		}
	}
	else
	{
		if (nPatIndex >= 1 && nPatIndex < OBJECTCANDIDATENUM)
		{
			m_vnObjectSearchStartPatIndex[nPosIndex] = nPatIndex;
			m_vnObjectSearchEndPatIndex[nPosIndex] = nPatIndex;
		}
		else
		{
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}


	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				// 使用对象搜索延时2
				if (TRUE == bEnableDelayTime2)
				{
					Sleep(nDelayTime2);
				}

				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bObjectSearchTest)ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);

					// 						m_bStatusBar = FALSE;
					// 						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 						PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

				if (bObjectSearchCandidate == FALSE)
				{
					if (nPatIndex == 0)
					{
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
						if(m_bObjectSearchTest)ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
						return FALSE;
					}
				}
				else
				{
					if (nPatIndex >= 1 && nPatIndex < OBJECTCANDIDATENUM)
					{
						m_vnObjectSearchStartPatIndex[nPosIndex] = nPatIndex;
						m_vnObjectSearchEndPatIndex[nPosIndex] = nPatIndex;
					}
					else
					{
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}


			// 弹出手动搜索框
			if (TRUE ==ExcuteManualSearch(1,vnPosIndex))
			{
				bSearchSucceed = TRUE;
			}

			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}

		}

	}

	// 设定、显示结果图形
	//         SetGuiAlnObjectImageMarkPos(vnPosIndex);
	//         PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	//         if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	//         {
	//             SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	//             PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	//         }
	//         // SY
	//         SetShowGuiObjectImageMarkPos(vnPosIndex);
	//         PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
		ExeSaveVDBFile(vnPosIndex,eObjectSearch);
	}
	if (bSearchSucceed)
	{


	}
	else
	{
		if(m_bObjectSearchTest)ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_OBJECT_SEARCH_FAILED),nPosIndex+1);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 

	if ((optionInfo.m_bSaveAlignPos && m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (optionInfo.m_bSaveAlignPos && m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 			CTime t = CTime::GetCurrentTime();
		// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");

		strTemp = _T("");
		cp = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex);

		strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), nPosIndex, cp.GetPosX(), cp.GetPosY());

		strOut += strTemp;

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);

		// 			FILE *stream;
		// 			CString strPath = m_strAlignProcessData;
		// 			stream = fopen(strPath, _T("a+t"));               
		// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 			fclose(stream);VCRemoveFile(strPath);
	}	


	BOOL bSucced = FALSE;
	bSucced = m_mpObjectMarkImagePos.GetIsMarkImagePosOK(nPosIndex);

	if (bSucced)
	{
		// SY
		// 图像中心点
		double dImageCenterX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
		double dImageCenterY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;

		dImagePosX = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex).m_dPosX;
		dImagePosY = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex).m_dPosY;
		//		dImagePosD = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex).m_dAngle;

		dImagePosX = dImagePosX - dImageCenterX;
		dImagePosY = dImagePosY - dImageCenterY;
		dImagePosD = 0;


		if (fabs(dImagePosX) > dImageCenterX * 2 || fabs(dImagePosY) > dImageCenterY * 2)
		{
			if(m_bObjectSearchTest)ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}
		else
		{
			if(m_bObjectSearchTest)ReportSearchResultFGAP(TRUE,dImagePosX,dImagePosY,dImagePosD);
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

		}


		return TRUE;

	}
	else
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		if(m_bObjectSearchTest)ReportSearchResultFGAP(FALSE,dImagePosX,dImagePosY,dImagePosD);
		return FALSE;

	}

	return FALSE;

}


CMarkImagePos vcXYDVisionAlign::GetTargetMarkImagePos()
{
	return m_mpTargetMarkImagePos;
}

CMarkImagePos vcXYDVisionAlign::GetVirtualObjectMarkImagePos()
{
	return m_mpVirtualMarkImagePos;
}

// 设置默认的目标模板Mark的平台轴位置和图像
void vcXYDVisionAlign::SetDefaultTargetSearchMarkPos(BOOL bOK, int nIndex/* = 0*/)
{
	if (m_pPlatformInfo == NULL || m_pAlignerTool == NULL)
	{
		return;
	}

	// 	if (m_pPlatformInfo->m_bTarCamWithDiffObjCam &&m_pPlatformInfo->m_bTargetObjectCamSeparate)
	// 	{
	// 		int nPosIndex; 
	// 		CPlatformXYDAxisPos patformXYDAxisPos;
	// 		CCoordPos cpImageMarkPos;
	// 
	// 		// 目标4、目标5
	// 		if (nIndex == 19)
	// 		{
	// 			for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
	// 			{
	// 				if (nPosIndex == 0 || nPosIndex == 1 || nPosIndex == 2 || nPosIndex == 3/* || nPosIndex == 6 || nPosIndex == 7*/)
	// //				if (nPosIndex == 0 || nPosIndex == 1)
	// 				{
	// 					m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
	// 					SetTargetPlatformPos(&patformXYDAxisPos, nPosIndex);
	// 					SetTempTargetPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
	// 				}
	// 			}		
	// 			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);	
	// 		}
	// 		// 目标6、目标7
	// 		else if (nIndex == 20)
	// 		{
	// 			for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
	// 			{
	// 				if (nPosIndex == 0 || nPosIndex == 1 || nPosIndex == 2 || nPosIndex == 3/* || nPosIndex == 4 || nPosIndex == 5*/)
	// //				if (nPosIndex == 2 || nPosIndex == 3)
	// 				{
	// 					m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
	// 					SetTargetPlatformPos(&patformXYDAxisPos, nPosIndex);
	// 					SetTempTargetPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
	// 				}
	// 			}		
	// 			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);	
	// 		}
	// 	
	// 
	// 		return;
	// 	}

	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		int nPosIndex; 
		CPlatformXYDAxisPos patformXYDAxisPos;
		CCoordPos cpImageMarkPos;

		if (m_nCheckTargetDistanceIndex == 19)
		{
			for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
			{
				if (nPosIndex < GetPosNum()/4)
				{
					m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
					SetTargetPlatformPos(&patformXYDAxisPos, nPosIndex);
					SetTempTargetPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
				}
			}
		}
		else if (m_nCheckTargetDistanceIndex == 20)
		{
			for(nPosIndex = GetPosNum()/4; nPosIndex < GetPosNum(); nPosIndex++)
			{
				if (nPosIndex < GetPosNum()/2)
				{
					m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
					SetTargetPlatformPos(&patformXYDAxisPos, nPosIndex);
					SetTempTargetPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
				}
			}
		}
		else
		{
			for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
			{
				if (nPosIndex < GetPosNum()/2)
				{
					m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
					SetTargetPlatformPos(&patformXYDAxisPos, nPosIndex);
					SetTempTargetPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
				}
			}
		}


		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);		
	}

}


// 设置默认的十字中心模板Mark的平台轴位置和图像
void vcXYDVisionAlign::SetDefaultCrossBenchTargetSearchMarkPos(BOOL bOK,BOOL bZeroAngle)	
{
	if (m_pPlatformInfo == NULL || m_pAlignerTool == NULL)
	{
		return;
	}

	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		int nPosIndex; 
		CPlatformXYDAxisPos patformXYDAxisPos;
		// CCoordPos cpImageMarkPos;
		BOOL bSuccess = FALSE;
		int nPatIndex = 0;	
		CSearchResult result;
		CCoordPos cp;
		for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
		{
			if (nPosIndex >= GetPosNum()/2)
			{
				bSuccess = ExecuteAlnCrossBenchSearch(nPosIndex, nPatIndex, result);
				if (bSuccess)
				{
					cp.m_dPosX  = result.m_dPosX;
					cp.m_dPosY  = result.m_dPosY;
					cp.m_dAngle = result.m_dAngle;
					m_mpCrossBenchMarkImagePos.SetMarkImagePos(nPosIndex, bSuccess, cp);
				}
				else
				{
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_mpCrossBenchMarkImagePos.SetMarkImagePos(nPosIndex, bSuccess, cp);
				}

				// m_mpCrossBenchMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
				// SetTargetPlatformPos(&patformXYDAxisPos, nPosIndex);
				SetTempCrossBenchTargetPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
			}
		}	
		// SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);
	}

	else
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL bEnableFWEL  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_bEnableWeld;

		if (bEnableFWEL)
		{
			int nPosIndex; 
			CPlatformXYDAxisPos patformXYDAxisPos;
			// CCoordPos cpImageMarkPos;
			BOOL bSuccess = FALSE;
			int nPatIndex = 0;	
			CSearchResult result;
			CCoordPos cp;
			for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
			{		
				{
					bSuccess = ExecuteAlnCrossBenchSearch(nPosIndex, nPatIndex, result,bZeroAngle);
					if (bSuccess)
					{
						cp.m_dPosX  = result.m_dPosX;
						cp.m_dPosY  = result.m_dPosY;
						cp.m_dAngle = result.m_dAngle;
						m_mpCrossBenchMarkImagePos.SetMarkImagePos(nPosIndex, bSuccess, cp);
					}
					else
					{
						cp.m_dPosX  = 0;
						cp.m_dPosY  = 0;
						cp.m_dAngle = 0;
						m_mpCrossBenchMarkImagePos.SetMarkImagePos(nPosIndex, bSuccess, cp);
					}

					// m_mpCrossBenchMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
					// SetTargetPlatformPos(&patformXYDAxisPos, nPosIndex);
					SetTempCrossBenchTargetPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
				}
			}	
			// SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);
		}



	}
}

BOOL vcXYDVisionAlign::IsObjectMarksZeroAngle()
{   
	CCoordPos cpObject1;
	CCoordPos cpObject2;
	BOOL bZeroAngle = FALSE;
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	if (2 == nPosNum && 1 == nCamNum)
	{
		cpObject1 = m_mpObjectMarkImagePos.GetMarkImagePos(0);
		cpObject2 = m_mpObjectMarkImagePos.GetMarkImagePos(1);

		// 对象直线
		scLine LineObject;
		scLineSeg lineSegTarget(sc2Vector(cpObject1.m_dPosX, cpObject1.m_dPosY), sc2Vector(cpObject2.m_dPosX, cpObject2.m_dPosY));
		LineObject.SetFromLineSeg(lineSegTarget);

		// 对象直线角度
		scRadian LineObjectRad = LineObject.GetRotation().SignedNormMod180();
		double dLineObjectAngle = scDegree(scRadian(LineObjectRad)).ToDouble();

		// 对象为水平直线
		double dImageCenterAngle = 0;
		if (fabs(dLineObjectAngle) <= 45)
		{
			bZeroAngle = TRUE;
		}
		// 对象为垂直直线
		else if (fabs(dLineObjectAngle) > 45)
		{
			bZeroAngle = FALSE;
		}
	}

	return bZeroAngle;

}
BOOL vcXYDVisionAlign::IsTargetMarksZeroAngle()
{
	CCoordPos cpTarget1;
	CCoordPos cpTarget2;
	BOOL bZeroAngle = FALSE;
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	if (2 == nPosNum && 1 == nCamNum)
	{
		cpTarget1 = m_mpTargetMarkImagePos.GetMarkImagePos(0);
		cpTarget2 = m_mpTargetMarkImagePos.GetMarkImagePos(1);

		// 目标直线
		scLine LineTarget;
		scLineSeg lineSegTarget(sc2Vector(cpTarget1.m_dPosX, cpTarget1.m_dPosY), sc2Vector(cpTarget2.m_dPosX, cpTarget2.m_dPosY));
		LineTarget.SetFromLineSeg(lineSegTarget);

		// 目标直线角度
		scRadian LineTargetRad = LineTarget.GetRotation().SignedNormMod180();
		double dLineTargetAngle = scDegree(scRadian(LineTargetRad)).ToDouble();

		// 目标为水平直线
		if (fabs(dLineTargetAngle) <= 45)
		{
			bZeroAngle = TRUE;
		}
		// 目标为垂直直线
		else if (fabs(dLineTargetAngle) > 45)
		{
			bZeroAngle = FALSE;
		}

	}
	return bZeroAngle;
}


// 设置默认的对象模板Mark的平台轴位置和图像
void vcXYDVisionAlign::SetDefaultObjectSearchMarkPos(BOOL bOK, int nIndex)	
{
	if (m_pPlatformInfo == NULL || m_pAlignerTool == NULL)
	{
		return;
	}

	// 	if (m_pPlatformInfo->m_bTarCamWithDiffObjCam && m_pPlatformInfo->m_bTargetObjectCamSeparate)
	// 	{
	// 		// 对象0、对象1
	// 		if (nIndex == 19)
	// 		{
	// 			int nPosIndex; 
	// 			CPlatformXYDAxisPos patformXYDAxisPos;
	// 			CCoordPos cpImageMarkPos;
	// 
	// 			for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
	// 			{
	// 				if (nPosIndex == 2 || nPosIndex == 3 || nPosIndex == 4 || nPosIndex == 5 || nPosIndex == 6 || nPosIndex == 7)
	// //				if (nPosIndex == 4 || nPosIndex == 5)
	// 				{
	// 					m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
	// 					SetObjectPlatformPos(&patformXYDAxisPos, nPosIndex);
	// 					SetTempObjectPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
	// 				}
	// 			}	
	// 			SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	// 
	// 		}
	// 		// 对象2、对象3
	// 		else if (nIndex == 20)
	// 		{
	// 			int nPosIndex; 
	// 			CPlatformXYDAxisPos patformXYDAxisPos;
	// 			CCoordPos cpImageMarkPos;
	// 
	// 			for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
	// 			{
	// 				if (nPosIndex == 0 || nPosIndex == 1 || nPosIndex == 4 || nPosIndex == 5 || nPosIndex == 6 || nPosIndex == 7)
	// //				if (nPosIndex == 6 || nPosIndex == 7)
	// 				{
	// 					m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
	// 					SetObjectPlatformPos(&patformXYDAxisPos, nPosIndex);
	// 					SetTempObjectPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
	// 				}
	// 			}	
	// 			SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	// 
	// 		}
	// 		else if (nIndex == 11)
	// 		{
	// 			int nPosIndex; 
	// 			CPlatformXYDAxisPos patformXYDAxisPos;
	// 			CCoordPos cpImageMarkPos;
	// 
	// 			for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
	// 			{
	// 				if (nPosIndex >= GetPosNum()/2)
	// 				{
	// 					m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
	// 					SetObjectPlatformPos(&patformXYDAxisPos, nPosIndex);
	// 					SetTempObjectPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
	// 				}
	// 			}	
	// 			SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	// 		}
	// 
	// 		return;
	// 	}

	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		int nPosIndex; 
		CPlatformXYDAxisPos patformXYDAxisPos;
		CCoordPos cpImageMarkPos;

		for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
		{
			if (nPosIndex >= GetPosNum()/2)
			{
				m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
				SetObjectPlatformPos(&patformXYDAxisPos, nPosIndex);
				SetTempObjectPlatformAxisPos(nPosIndex, &patformXYDAxisPos);
			}
		}	
		SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	}
}

// 设置默认的虚拟模板Mark的平台轴位置和图像
void vcXYDVisionAlign::SetDefaultVirtualObjectSearchMarkPos(BOOL bOK)		
{
	if (m_pPlatformInfo == NULL || m_pAlignerTool == NULL)
	{
		return;
	}

	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		int nPosIndex; 
		CPlatformXYDAxisPos patformXYDAxisPos;
		CCoordPos cpImageMarkPos;

		for(nPosIndex = 0; nPosIndex < GetPosNum(); nPosIndex++)
		{
			if (nPosIndex >= GetPosNum()/2)
			{
				m_mpVirtualMarkImagePos.SetMarkImagePos(nPosIndex, bOK, cpImageMarkPos);
				SetVirtualPlatformPos(&patformXYDAxisPos, nPosIndex);

			}
		}	
		SetVirtualMarkSearchResults(m_mpVirtualMarkImagePos);
	}
}


// 当目标相机和对象相机是独立时，标定目标相机时，进行目标和对象的Mark定位搜索
BOOL vcXYDVisionAlign::SingleCameraCalibAlignerTargetSearchExFTGT(int nCalibPos, int nMoveIndex)
{
	CString strCmd = _T("");	//关联操作，没有指令，格式统一，指令为空
	CString strTempWarningType = _T("");

	if(!CheckVisionASMConfig(strCmd) || !CheckPlatformInfo(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		return FALSE;
	}

	if (nMoveIndex < 0 || nMoveIndex >= m_vpmpCalibMarkImagePos.size())
	{
		return FALSE;
	}

	// 通信是否正常
	if(!CheckCommuciationValid(strCmd))
	{
		return FALSE; 
	}


	// 相机是否处于连续采集状态
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);

			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}    	
	}

	// 当前产品索引
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{			
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{			
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;

	}


	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	int nCamPos = m_pPlatformInfo->m_nPositionNum;

	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);


	// 1. 获取当前轴位置
	if (sysPlatformInfo.m_bTarObjCamSepNoAxisCalib == TRUE)
	{
		// 不用取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	}
	else
	{
		// 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
		CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

		BOOL bGetPlatformAxis = FALSE;

		if(m_pPlatformInfo->m_bEnableKeyenceCode)
		{
			bGetPlatformAxis = CommuciateGetPlatformAxisAbsPosEx(pPlatformAxisPos);
		}
		else
		{
			bGetPlatformAxis = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		if (FALSE == bGetPlatformAxis)
		{
			if (pPlatformAxisPos!=NULL)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;					
			}

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		else
		{
			SetTargetPlatformPos(pPlatformAxisPos, nCalibPos);		
			SetTempTargetPlatformAxisPos(nCalibPos,pPlatformAxisPos);

			if (NULL != GetTotalProuductData())
			{
				SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
			}


			// 记录当前平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				CString strInfo;
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
				strInfo = strTemp + strInfo;

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);

			}

			if (pPlatformAxisPos)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;
			}
		}
	}



	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	//	std::vector<CMarkImagePos*> vpMarkImagePos;
	CMarkImagePos* pMarkImagePos = m_vpmpCalibMarkImagePos.at(nMoveIndex);
	if (pMarkImagePos == NULL)
	{
		return FALSE;
	}
	CCoordPos pos;
	pMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, pos);


	{         
		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), nMoveIndex);
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		CPlatformOptionInfo optionInfo;
		GetPlatformOptionInfo(optionInfo);

		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

		//		BOOL SystempOptionSearchShutter = m_pSystempOptionConfig->m_bEnableSearchShutter;
		//		BOOL bCalibTargetShutter = pCurProductData->m_pAlignerParam->GetEnableCalibTargetSearchShutter(nMoveIndex);

		CameraParamEnable cameraParamEnable;
		cameraParamEnable = pCurProductData->m_pAlignerParam->GetEnableCalibTargetSearchShutter(nMoveIndex);
		BOOL bCalibTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		// 2. 图像采集
		BOOL bCalibTargetMarkEnable = pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable();
		if (SystempOptionSearchShutter && bCalibTargetShutter && bCalibTargetMarkEnable)
		{
			if (eDoublePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
			{
				SwitchToCalibTargetSearchShutter(nCalibPos,nMoveIndex);
			}
			else
			{
				SwitchToCalibTargetSearchShutter(nCalibPos);
			}

			Sleep(200);

			// 采集图像
			std::vector<int> vnPosIndex;
			vnPosIndex.push_back(nCalibPos);

			if (!SnapSearchImage(vnPosIndex))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);

				if (!m_boIsSnapImgSucceed)
				{
					m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
				}
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
				AddWarningInfo(strTempWarningType, m_strStatusBarInfo2);

				return FALSE;
			}

			Sleep(200);

		}
		else
		{
			// 设置图像
			EnterCriticalSection(&m_vcsResource.at(nCalibPos));
			m_vImageSearch[nCalibPos] = m_vImageInput[nCalibPos];
			LeaveCriticalSection(&m_vcsResource.at(nCalibPos));
		}



		// 3. 执行定位
		if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE)
		{
			// 标定用定位工具是否正常 
			if (m_bValidCalibTargetSearchTool!=TRUE)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			// 用关联标定模板执行标定搜索
			if (eSinglePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
			{
				// 用第0组关联标定模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
					{
						m_bStatusBar = TRUE;
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
						m_strStatusBarInfo1 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						return TRUE;
					}

					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
					{
						SYSTEMTIME sys; 
						GetLocalTime(&sys); 
						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
						}

						CString strPath = m_strDataRecord + _T("\\AlignTool");
						SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));
						//						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));

						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
						{
							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
						}
					}

					return FALSE;
				}
			}
			else if (eDoublePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
			{
				// 用第0、1组关联标定模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, nMoveIndex);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,nMoveIndex);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{

					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex,1))
					{

						m_bStatusBar = TRUE;
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
						m_strStatusBarInfo1 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						return TRUE;
					}

					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
					{
						SYSTEMTIME sys; 
						GetLocalTime(&sys); 
						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
						}

						CString strPath = m_strDataRecord + _T("\\AlignTool");
						SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));
						//						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));

						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
						{
							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
						}
					}
					return FALSE;
				}
			}
			else if (eSinglePatternMultiMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
			{
				// 用第0组关联标定模板执行标定搜索，单模板双标记点
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);

					int nTempMoveIndex = 0;
					CMarkImagePos* pTempMarkImagePos = NULL;
					CCoordPos posTemp;

					// 移动位置0或标记点0
					nTempMoveIndex = 0;
					pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
					if (pTempMarkImagePos == NULL)
					{
						return FALSE;
					}

					pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					if (nMoveIndex == nTempMoveIndex)
					{
						pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					}


					// 移动位置1或标记点1
					nTempMoveIndex = 1;
					pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
					if (pTempMarkImagePos == NULL)
					{
						return FALSE;
					}

					pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(0);
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(0);
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(0);
					pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					if (nMoveIndex == nTempMoveIndex)
					{
						pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					}

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
					{
						m_bStatusBar = TRUE;
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
						m_strStatusBarInfo1 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						return TRUE;
					}

					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
					{
						SYSTEMTIME sys; 
						GetLocalTime(&sys); 
						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;	

						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
						}

						CString strPath = m_strDataRecord + _T("\\AlignTool");
						SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));
						//						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));

						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
						{
							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
						}
					}

					return FALSE;
				}

			}
			else if (eSinglePatternGuanlian4Point == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
			{
				// 用第0组关联标定模板执行标定搜索，单模板双标记点
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);

					int nTempMoveIndex = 0;
					CMarkImagePos* pTempMarkImagePos = NULL;
					CCoordPos posTemp;

					if (nMoveIndex == 0)
					{
						cp.m_vdAuxiliaryPosX.at(0)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(0);
						cp.m_vdAuxiliaryPosY.at(0)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(0);
						cp.m_vdAuxiliaryAngle.at(0) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(0);

						cp.m_vdAuxiliaryPosX.at(1)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(1);
						cp.m_vdAuxiliaryPosY.at(1)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(1);
						cp.m_vdAuxiliaryAngle.at(1) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(1);
					}
					else
					{
						cp.m_vdAuxiliaryPosX.at(2)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(2);
						cp.m_vdAuxiliaryPosY.at(2)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(2);
						cp.m_vdAuxiliaryAngle.at(2) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(2);

						cp.m_vdAuxiliaryPosX.at(3)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(3);
						cp.m_vdAuxiliaryPosY.at(3)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(3);
						cp.m_vdAuxiliaryAngle.at(3) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(3);
					}

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;

					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
					{
						SYSTEMTIME sys; 
						GetLocalTime(&sys); 
						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
						}

						CString strPath = m_strDataRecord + _T("\\AlignTool");
						SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));
						//						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));

						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
						{
							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
						}
					}
					return FALSE;
				}
			}
		} 
		else
		{
			if (0 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
			{
				// 目标定位工具是否正常 
				if (m_bValidTargetSearchTool!=TRUE)
				{
					//ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				// 用目标模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,0);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					////////////////////////////////////////////////////
					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
					{

						m_bStatusBar = TRUE;
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
						m_strStatusBarInfo1 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						return TRUE;
					}
					////////////////////////////////////////////////////
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
					{		
						CTime t = CTime::GetCurrentTime();	
						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
							t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);

						SYSTEMTIME sys; 
						GetLocalTime(&sys); 
						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
						}

						CString strPath = m_strDataRecord + _T("\\AlignTool");
						SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));

						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
						{
							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
						}
					}	
					return FALSE;
				}

			}	
			else if (1 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
			{
				// 对象定位工具是否正常 
				if (m_bValidObjectSearchTool!=TRUE)
				{
					//ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				// 用对象模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnObjectSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnObjectSearchResult(nCalibPos,0);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					////////////////////////////////////////////////////
					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
					{

						m_bStatusBar = TRUE;
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
						m_strStatusBarInfo1 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						return TRUE;
					}
					////////////////////////////////////////////////////
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
					{		
						CTime t = CTime::GetCurrentTime();	
						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
							t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);

						SYSTEMTIME sys; 
						GetLocalTime(&sys); 
						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
						{
							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
						}

						CString strPath = m_strDataRecord + _T("\\AlignTool");
						SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));

						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
						{
							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
						}
					}
					return FALSE;
				}
			}
			else if (2 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
			{
				// 标定定位工具是否正常 
				if (m_bValidCalibSearchTool!=TRUE)
				{
					//ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				// 用目标模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteCalibTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetCalibSearchResult(nCalibPos,0);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					////////////////////////////////////////////////////
					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
					{

						m_bStatusBar = TRUE;
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
						m_strStatusBarInfo1 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						return TRUE;
					}
					////////////////////////////////////////////////////
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

			}
		}


		// 		// 记录图像搜索数据
		// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		// 		{
		// 			CString strTemp;
		// 			CString strOut;
		// 			CCoordPos cp;
		// 			strOut = strTemp + _T("CalibSearch: ");		
		// 			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
		// 			{
		// 				strTemp = _T("");
		// 				cp = pMarkImagePos->GetMarkImagePos(i);
		// 
		// 				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
		// 
		// 				strOut += strTemp;
		// 			}
		// 
		// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		// 			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		// 		}

		// 记录图像搜索数据
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strInfo;
			CString strTemp;

			CCoordPos cp;
			cp = pMarkImagePos->GetMarkImagePos(nCalibPos);

			strTemp.Format(_T("CalibTargetSearch: MoveIndex%d MarkPos%d( %.2f , %.2f , %.3f )"), nMoveIndex, nCalibPos, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
			strInfo += strTemp;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);

		}


//		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage && m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo && m_pVisionASMConfig->m_DataRecord.m_bCommunication)
		if (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage)
		{
			SYSTEMTIME sys; 
			GetLocalTime(&sys); 
			m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearch.bmp"),
				sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

			m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) + 1;																			
			if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
			{
				m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearch-CH%02d-%03d.bmp"), 
					nCalibPos,m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos));
			}

			CString strPath = m_strDataRecord + _T("\\AlignTool");
			SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));

			if(m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
				m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) = 0;
			}
		}			
	}  

	return TRUE;
}
// BOOL vcXYDVisionAlign::SingleCameraCalibAlignerTargetSearchExFTGT(int nCalibPos, int nMoveIndex)
// {
// 	CString strCmd = _T("");	//关联操作，没有指令，格式统一，指令为空
// 	CString strTempWarningType = _T("");
// 	//if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
// 	if(!CheckVisionASMConfig(strCmd) || !CheckPlatformInfo(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
// 	{
// 		//ReportCalibResult(FALSE);
// 		return FALSE;
// 	}
// 	CPlatformOptionInfo optionInfo;
// 	GetPlatformOptionInfo(optionInfo);
// 	if (nMoveIndex < 0 || nMoveIndex >= m_vpmpCalibMarkImagePos.size())
// 	{
// 		return FALSE;
// 	}
// 
// 	// 通信是否正常
// 	//if (FALSE == m_bValidComm)
// 	if(!CheckCommuciationValid(strCmd))
// 	{
// 		//ReportCalibResult(FALSE);
// 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 		PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE; 
// 	}
// 
// // 	// 标定用定位工具是否正常 
// // 	if (m_bValidTargetSearchTool!=TRUE)
// // 	{
// // 		//ReportCalibResult(FALSE);
// // 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 		return FALSE;
// // 	}
// 
// 	// 相机是否处于连续采集状态
// 	int nCamNum = m_pPlatformInfo->m_nCamNum;
// 
// 	// 	if (nCamNum!=1)
// 	// 	{
// 	// 		ReportCalibResult(FALSE);
// 	// 		return FALSE;
// 	// 	}	
// 	int i=0;
// 	for(i=0; i<nCamNum; i++)
// 	{		 
// 		if (FALSE == m_vbCameraLiveGrab[i])
// 		{      
// 			//ReportCalibResult(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
// 			CString strTemp = _T("");
// 			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
// 			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
// 			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
// 
// 			return FALSE;
// 		}    	
// 	}
// 
// 	// 标定开始    
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
// 	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 	int nCamPos = m_pPlatformInfo->m_nPositionNum;
// 
// 	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
// 	SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);
// 	CString strCorrelationLogPath;
// 	//strCorrelationLogPath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 	//	m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex()+1);
// 
// 	vcBaseAlignTool* tmpAlignTool = GetAlignTool();
// 	CString StrTmp = _T("");
// 	if (tmpAlignTool !=NULL)
// 	{
// 
// 		if (sysPlatformInfo.m_bProductFaChd)
// 		{
// 			int nCurProductIndexFa;
// 			int nCurProductIndexCh;
// 			m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 			StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 				nCurProductIndexFa+1,nCurProductIndexCh+1);
// 		}
// 		else
// 		{
// 			StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 				m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 		}
// 		
// 	}
// 
// 	strCorrelationLogPath =StrTmp;
// 
// 	if (sysPlatformInfo.m_bTarObjCamSepNoAxisCalib == TRUE)
// 	{
// 		// 不用取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
// 	}
// 	else
// 	{
// 		// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
// 		CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
// 
// 		if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
// 		{
// 			if (pPlatformAxisPos!=NULL)
// 			{
// 				delete pPlatformAxisPos;
// 				pPlatformAxisPos = NULL;					
// 			}
// 
// 			//ReportCalibResult(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
// 			m_strStatusBarInfo2 = _T("");
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 
// 			return FALSE;
// 		}
// 		else
// 		{
// 			SetTargetPlatformPos(pPlatformAxisPos, nCalibPos);		
// 			SetTempTargetPlatformAxisPos(nCalibPos,pPlatformAxisPos);
// 			
// 			if (NULL != GetTotalProuductData())
// 			{
// 				SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
// 			}
// 			
// 			// 
// 			// 		if (m_CalibPlatformAxisAbsPos.size()<nCalibPos+1)
// 			// 		{
// 			// 			m_CalibPlatformAxisAbsPos.resize(nCalibPos+1);
// 			// 		}
// 			// 		m_CalibPlatformAxisAbsPos.at(nCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 
// 			// 记录当前平台各个轴的绝对位置
// 			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 			{
// 				CString strTemp;
// 	// 			CTime t = CTime::GetCurrentTime();
// 	// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 				CString strInfo;
// 				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 				strInfo = strTemp + strInfo;
// 
// 	// 			FILE *stream;
// 	// 			CString strPath = m_strAlignProcessData;
// 	// 			stream = fopen(strPath, _T("a+t"));
// 	// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 	// 			fclose(stream);VCRemoveFile(strPath);	
// 
// 				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 
// 				////GYM-关联日志存储
// 				strInfo.Empty();
// 				strTemp.Format(_T("......位置%d第%d次移动到拍照位的轴位置: X: %.2f; Y: %.2f; D: %.2f;"),nCalibPos+1,nMoveIndex+1,pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 				strInfo += strTemp;
// 				CorrelationMoveAxisAngle.push_back(pPlatformAxisPos->m_dAngle);
// 				VisionAlignLogRecord(strCorrelationLogPath,strInfo,FALSE);
// 				///GYM
// 				
// 			}
// 
// 			if (pPlatformAxisPos)
// 			{
// 				delete pPlatformAxisPos;
// 				pPlatformAxisPos = NULL;
// 			}
// 		}
// 	}
// 
// 	// 	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
// 	// 	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
// 	// 	vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nCalibPos);
// 	// 
// 	// 	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum())
// 	// 	{
// 	// 		ReportCalibResult(FALSE);
// 	// 
// 	// 		m_bStatusBar = FALSE;
// 	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_EIGHT_PLATFORM_POS_FAILED);
// 	// 		m_strStatusBarInfo2 = _T("");
// 	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 	// 
// 	// 		return FALSE;
// 	// 	}
// 	// 	else
// 	// 	{
// 	// 		// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
// 	// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 	// 		{
// 	// 			CString strTemp;
// 	// 			CTime t = CTime::GetCurrentTime();
// 	// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 	// 
// 	// 			CString strInfo;
// 	// 			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
// 	// 			strInfo = strTemp + strInfo;
// 	// 
// 	// 			CPlatformXYDAxisPos* pAxisPos;
// 	// 			for (int i=0; i<vpPlatformAxisPos.size(); i++)
// 	// 			{
// 	// 				strTemp.Empty();
// 	// 				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
// 	// 
// 	// 				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
// 	// 				strInfo = strInfo + strTemp;
// 	// 			}
// 	// 
// 	// 			FILE *stream;
// 	// 			CString strPath = m_strAlignProcessData;
// 	// 			stream = fopen(strPath, _T("a+t"));
// 	// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 	// 			fclose(stream);VCRemoveFile(strPath);				
// 	// 		}
// 	// 	}
// 
// 	// 3. 驱动平台到位并定位
// 	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
// 	std::vector<CMarkImagePos*> vpMarkImagePos;
// 	CMarkImagePos* pMarkImagePos = m_vpmpCalibMarkImagePos.at(nMoveIndex);
// 	if (pMarkImagePos == NULL)
// 	{
// 		return FALSE;
// 	}
// 	CCoordPos pos;
// 	pMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, pos);
// 
// 	// 	int k=0;
// 	// 	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum() - 1; k++)
// 	{         
// 		//		//EnterCriticalSection(&m_csResource);
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), nMoveIndex);
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		//		//LeaveCriticalSection(&m_csResource);
// 
// 		//		pMarkImagePos = NULL;
// 
// 		// 		// 驱动到位
// 		// 		pPlatformXYDAxisPos = NULL;
// 		// 		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);
// 		// 
// 		// 		if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
// 		// 		{
// 		// 			ReportCalibResult(FALSE);
// 		// 
// 		// 			m_bStatusBar = FALSE;
// 		// 			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), k) ;
// 		// 			m_strStatusBarInfo2 = _T("");
// 		// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		// 
// 		// 			return FALSE;
// 		// 		}
// 
// 
// 		{
// 			
// 			int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 			BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
// 			//BOOL bCalibTargetShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex)->m_pAlignerParam->GetEnableCalibTargetSearchShutter(nMoveIndex);
// 
// 			CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
// 			if (pCurProductData == NULL)
// 			{			
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
// 				m_strStatusBarInfo2 = _T("");
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
// 
// 				return FALSE;
// 			}
// 
// 			// 判定m_pAlignerParam是否为NULL
// 			if (pCurProductData->m_pAlignerParam == NULL)
// 			{
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
// 				m_strStatusBarInfo2 = _T("");
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
// 			}
// 
// 			CameraParamEnable cameraParamEnable;
// 			cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex)->m_pAlignerParam->GetEnableCalibTargetSearchShutter(nMoveIndex);
// 			BOOL bCalibTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);
// 
// 			BOOL bCalibTargetMarkEnable = pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable();
// 
// 			if (SystempOptionSearchShutter && bCalibTargetShutter && bCalibTargetMarkEnable)
// 			{
// 				if (eDoublePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
// 				{
// 					SwitchToCalibTargetSearchShutter(nCalibPos,nMoveIndex);
// 				}
// 				else
// 				{
// 					SwitchToCalibTargetSearchShutter(nCalibPos);
// 				}
// 
// 				Sleep(200);
// 
// 				// 采集图像
// 				std::vector<int> vnPosIndex;
// 				vnPosIndex.push_back(nCalibPos);
// 
// 				if (!SnapSearchImage(vnPosIndex))
// 				{
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					if (!m_boIsSnapImgSucceed)
// 					{
// 						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
// 					}
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
// 					AddWarningInfo(strTempWarningType, m_strStatusBarInfo2);
// 					return FALSE;
// 				}
// 
// 				Sleep(200);
// 				
// 			}
// 			else
// 			{
// 				// 设置图像
// 				EnterCriticalSection(&m_vcsResource.at(nCalibPos));
// 				m_vImageSearch[nCalibPos] = m_vImageInput[nCalibPos];
// 				LeaveCriticalSection(&m_vcsResource.at(nCalibPos));
// 			}
// 
// 		}
// 
// // 		// 设置图像
// // 		EnterCriticalSection(&m_vcsResource.at(nCalibPos));
// // 		m_vImageSearch[nCalibPos] = m_vImageInput[nCalibPos];
// // 		LeaveCriticalSection(&m_vcsResource.at(nCalibPos));
// 
// 
// 
// 		// 		// 执行定位
// 		// 		CCoordPos cp;
// 		// 		BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 0);
// 		// 		if(bSearchSucceed)
// 		// 		{			
// 		// 			m_vbSearchSucceed[nCalibPos] = TRUE;
// 		// 			m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,0);
// 		// 
// 		// 			cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
// 		// 			cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
// 		// 			cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
// 		// 			pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 		// 
// 		// 			m_bStatusBar = TRUE;
// 		// 			m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
// 		// 			m_strStatusBarInfo1 = _T("");
// 		// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		// 		}
// 		// 		else
// 		// 		{
// 		// 			cp.m_dPosX  = 0;
// 		// 			cp.m_dPosY  = 0;
// 		// 			cp.m_dAngle = 0;
// 		// 			m_vbSearchSucceed[nCalibPos] =FALSE;
// 		// 			pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 		// 			m_bStatusBar = FALSE;
// 		// 			m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
// 		// 			m_strStatusBarInfo1 = _T("");
// 		// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		// 			return FALSE;
// 		// 		}
// 
// 		//
// 		
// 
// 		// 执行定位
// 		// 获取当前产品信息
// 		int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 
// 		if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
// 		{			
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
// 			m_strStatusBarInfo2 = _T("");
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
// 
// 			return FALSE;
// 		}
// 
// 
// 		// 设置补偿量索引
// 		CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
// 		if (pCurProductData == NULL)
// 		{			
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
// 			m_strStatusBarInfo2 = _T("");
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
// 
// 			return FALSE;
// 		}
// 
// 		if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE)
// 		{
// 			// 标定用定位工具是否正常 
// 			if (m_bValidCalibTargetSearchTool!=TRUE)
// 			{
// 				//ReportCalibResult(FALSE);
// 
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 				return FALSE;
// 			}
// 	
// 			// 用关联标定模板执行标定搜索
// 			if (eSinglePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
// 			{
// 				// 用第0组关联标定模板执行标定搜索
// 				CCoordPos cp;
// 				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
// 				if(bSearchSucceed)
// 				{			
// 					m_vbSearchSucceed[nCalibPos] = TRUE;
// 					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);
// 
// 					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
// 					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
// 					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 
// 					m_bStatusBar = TRUE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 				}
// 				else
// 				{
// 					////////////////////////////////////////////////////
// 					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
// 					{
// 
// 						m_bStatusBar = TRUE;
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 						m_strStatusBarInfo1 = _T("");
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 						return TRUE;
// 					}
// 					////////////////////////////////////////////////////
// 					cp.m_dPosX  = 0;
// 					cp.m_dPosY  = 0;
// 					cp.m_dAngle = 0;
// 					m_vbSearchSucceed[nCalibPos] =FALSE;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
// 					{		
// 						CTime t = CTime::GetCurrentTime();	
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 						SYSTEMTIME sys; 
// 						GetLocalTime(&sys); 
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
// 						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 						{
// 							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
// 								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
// 						}
// 						/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 						m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 						{
// 							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
// 						}
// 					}
// 					return FALSE;
// 				}
// 			}
// 			else if (eDoublePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
// 			{
// 				// 用第0、1组关联标定模板执行标定搜索
// 				CCoordPos cp;
// 				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, nMoveIndex);
// 				if(bSearchSucceed)
// 				{			
// 					m_vbSearchSucceed[nCalibPos] = TRUE;
// 					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,nMoveIndex);
// 
// 					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
// 					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
// 					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 
// 					m_bStatusBar = TRUE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 				}
// 				else
// 				{
// 					////////////////////////////////////////////////////
// 					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex,1))
// 					{
// 
// 						m_bStatusBar = TRUE;
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 						m_strStatusBarInfo1 = _T("");
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 						return TRUE;
// 					}
// 					////////////////////////////////////////////////////
// 					cp.m_dPosX  = 0;
// 					cp.m_dPosY  = 0;
// 					cp.m_dAngle = 0;
// 					m_vbSearchSucceed[nCalibPos] =FALSE;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
// 					{		
// 						CTime t = CTime::GetCurrentTime();	
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 						SYSTEMTIME sys; 
// 						GetLocalTime(&sys); 
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
// 						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 						{
// 							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
// 								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
// 						}
// 						/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 						m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 						{
// 							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
// 						}
// 					}
// 					return FALSE;
// 				}
// 			}
// 			else if (eSinglePatternMultiMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
// 			{
// 				
// 				{
// 					// 用第0组关联标定模板执行标定搜索，单模板双标记点
// 					CCoordPos cp;
// 					BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
// 					if(bSearchSucceed)
// 					{			
// 						m_vbSearchSucceed[nCalibPos] = TRUE;
// 						m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);
// 
// 						int nTempMoveIndex = 0;
// 						CMarkImagePos* pTempMarkImagePos = NULL;
// 						CCoordPos posTemp;
// 
// 						// 移动位置0或标记点0
// 						nTempMoveIndex = 0;
// 						pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
// 						if (pTempMarkImagePos == NULL)
// 						{
// 							return FALSE;
// 						}					
// 						pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
// 						cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
// 						cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
// 						cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
// 						pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 						if (nMoveIndex == nTempMoveIndex)
// 						{
// 							pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 						}
// 
// 						// 移动位置1或标记点1
// 						nTempMoveIndex = 1;
// 						pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
// 						if (pTempMarkImagePos == NULL)
// 						{
// 							return FALSE;
// 						}					
// 						pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
// 						cp.m_dPosX  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(0);
// 						cp.m_dPosY  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(0);
// 						cp.m_dAngle = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(0);
// 						pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 						if (nMoveIndex == nTempMoveIndex)
// 						{
// 							pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 						}
// 
// 						m_bStatusBar = TRUE;
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
// 						m_strStatusBarInfo1 = _T("");
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 					}
// 					else
// 					{
// 						////////////////////////////////////////////////////
// 						if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
// 						{
// 
// 							m_bStatusBar = TRUE;
// 							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 							m_strStatusBarInfo1 = _T("");
// 							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 							return TRUE;
// 						}
// 						////////////////////////////////////////////////////
// 						cp.m_dPosX  = 0;
// 						cp.m_dPosY  = 0;
// 						cp.m_dAngle = 0;
// 						m_vbSearchSucceed[nCalibPos] =FALSE;
// 						pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 						m_bStatusBar = FALSE;
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
// 						m_strStatusBarInfo1 = _T("");
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 						if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
// 						{		
// 							CTime t = CTime::GetCurrentTime();	
// 							m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 								t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 							SYSTEMTIME sys; 
// 							GetLocalTime(&sys); 
// 							m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 								sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
// 							if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 							{
// 								m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
// 									nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
// 							}
// 							/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 							m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 							SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 							if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 							{
// 								m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
// 							}
// 						}
// 						return FALSE;
// 					}
// 				}
// 
// 			}
//             else if (eSinglePatternGuanlian4Point == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
//             {
//                 // 用第0组关联标定模板执行标定搜索，单模板双标记点
//                 CCoordPos cp;
//                 BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
//                 if(bSearchSucceed)
//                 {			
//                     m_vbSearchSucceed[nCalibPos] = TRUE;
//                     m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);
// 
// 
// 
//                     int nTempMoveIndex = 0;
//                     CMarkImagePos* pTempMarkImagePos = NULL;
//                     CCoordPos posTemp;
// 
//                     //将当前位置的图像定位坐标的前两个点存储到移动位置1中的辅助点0和1中；后两个点存储到移动位置2的辅助点2和3中
//                     // 移动位置0或标记点0
//                     // 						nTempMoveIndex = 0;
//                     // 						pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
//                     // 						if (pTempMarkImagePos == NULL)
//                     // 						{
//                     // 							return FALSE;
//                     // 						}					
//                     //						pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
// 
//                     if (nMoveIndex == 0)
//                     {
//                         cp.m_vdAuxiliaryPosX.at(0)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(0);
//                         cp.m_vdAuxiliaryPosY.at(0)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(0);
//                         cp.m_vdAuxiliaryAngle.at(0) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(0);
// 
//                         cp.m_vdAuxiliaryPosX.at(1)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(1);
//                         cp.m_vdAuxiliaryPosY.at(1)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(1);
//                         cp.m_vdAuxiliaryAngle.at(1) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(1);
//                     }
//                     else
//                     {
//                         cp.m_vdAuxiliaryPosX.at(2)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(2);
//                         cp.m_vdAuxiliaryPosY.at(2)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(2);
//                         cp.m_vdAuxiliaryAngle.at(2) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(2);
// 
//                         cp.m_vdAuxiliaryPosX.at(3)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(3);
//                         cp.m_vdAuxiliaryPosY.at(3)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(3);
//                         cp.m_vdAuxiliaryAngle.at(3) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(3);
//                     }
//                     cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
//                     cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
//                     cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
// 
//                     // 						pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
//                     // 						if (nMoveIndex == nTempMoveIndex)
//                     {
//                         pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
//                     }
// 
//                     // 						// 移动位置1或标记点1
//                     // 						nTempMoveIndex = 1;
//                     // 						pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
//                     // 						if (pTempMarkImagePos == NULL)
//                     // 						{
//                     // 							return FALSE;
//                     // 						}					
//                     // 						pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
//                     // 
//                     // 						cp.m_vdAuxiliaryPosX.at(2)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(2);
//                     // 						cp.m_vdAuxiliaryPosY.at(2)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(2);
//                     // 						cp.m_vdAuxiliaryAngle.at(2) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(2);
//                     // 
//                     // 						cp.m_vdAuxiliaryPosX.at(3)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(3);
//                     // 						cp.m_vdAuxiliaryPosY.at(3)  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(3);
//                     // 						cp.m_vdAuxiliaryAngle.at(3) = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(3);
//                     // 						pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
//                     // 						if (nMoveIndex == nTempMoveIndex)
//                     // 						{
//                     // 							pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
//                     // 						}
// 
//                     //{
//                     //	CString strtmp;
//                     //	if (nMoveIndex == 0)
//                     //	{
//                     //		for (int i=0;i<2;i++)
//                     //		{
//                     //			strtmp.Format("SeachResults位置%d 移动位置%d的图像坐标:%f,%f\n",nCalibPos+1,nMoveIndex+1,m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(i),m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(i));
//                     //			FILE *stream;
//                     //			CString strPath;
//                     //			strPath.Format("D:\\VisionASMLog\\1.txt");
//                     //			stream = fopen(strPath, _T("a+t"));
//                     //			if (stream != NULL)
//                     //			{
//                     //				fwrite(strtmp, sizeof(TCHAR), strtmp.GetLength(), stream);
//                     //				fclose(stream);	
//                     //			}
//                     //		}
//                     //	}
//                     //	else
//                     //	{
//                     //		for (int i=2;i<4;i++)
//                     //		{
//                     //			strtmp.Format("SeachResults位置%d 移动位置%d的图像坐标:%f,%f\n",nCalibPos+1,nMoveIndex+1,m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(i),m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(i));
//                     //			FILE *stream;
//                     //			CString strPath;
//                     //			strPath.Format("D:\\VisionASMLog\\1.txt");
//                     //			stream = fopen(strPath, _T("a+t"));
//                     //			if (stream != NULL)
//                     //			{
//                     //				fwrite(strtmp, sizeof(TCHAR), strtmp.GetLength(), stream);
//                     //				fclose(stream);	
//                     //			}
//                     //		}
//                     //	}
//                     //	
// 
//                     //}
//                     //{
//                     //	CString strtmp;
//                     //	if (nMoveIndex == 0)
//                     //	{
//                     //		for (int i=0;i<2;i++)
//                     //		{
//                     //			strtmp.Format("CalibMarkImagePos位置%d 移动位置%d的图像坐标:%f,%f\n",nCalibPos+1,nMoveIndex+1,m_vpmpCalibMarkImagePos.at(nMoveIndex)->m_vPos.at(nCalibPos).GetAuxiliaryPosX(i),m_vpmpCalibMarkImagePos.at(nMoveIndex)->m_vPos.at(nCalibPos).GetAuxiliaryPosY(i));
//                     //			FILE *stream;
//                     //			CString strPath;
//                     //			strPath.Format("D:\\VisionASMLog\\1.txt");
//                     //			stream = fopen(strPath, _T("a+t"));
//                     //			if (stream != NULL)
//                     //			{
//                     //				fwrite(strtmp, sizeof(TCHAR), strtmp.GetLength(), stream);
//                     //				fclose(stream);	
//                     //			}
//                     //		}
//                     //	}
//                     //	else
//                     //	{
//                     //		for (int i=2;i<4;i++)
//                     //		{
//                     //			strtmp.Format("CalibMarkImagePos位置%d 移动位置%d的图像坐标:%f,%f\n",nCalibPos+1,nMoveIndex+1,m_vpmpCalibMarkImagePos.at(nMoveIndex)->m_vPos.at(nCalibPos).GetAuxiliaryPosX(i),m_vpmpCalibMarkImagePos.at(nMoveIndex)->m_vPos.at(nCalibPos).GetAuxiliaryPosY(i));
//                     //			FILE *stream;
//                     //			CString strPath;
//                     //			strPath.Format("D:\\VisionASMLog\\1.txt");
//                     //			stream = fopen(strPath, _T("a+t"));
//                     //			if (stream != NULL)
//                     //			{
//                     //				fwrite(strtmp, sizeof(TCHAR), strtmp.GetLength(), stream);
//                     //				fclose(stream);	
//                     //			}
//                     //		}
//                     //	}
//                     //	
// 
//                     //}
//                     m_bStatusBar = TRUE;
//                     m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
//                     m_strStatusBarInfo1 = _T("");
//                     SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
//                 }
//                 else
//                 {
// 					//////////////////////////////////////////////////////
// 			  //  	if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex,2))
// 					//{
// 
// 					//	m_bStatusBar = TRUE;
// 					//	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 					//	m_strStatusBarInfo1 = _T("");
// 					//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 					//	return TRUE;
// 					//}
// 					//////////////////////////////////////////////////////
//                     cp.m_dPosX  = 0;
//                     cp.m_dPosY  = 0;
//                     cp.m_dAngle = 0;
//                     m_vbSearchSucceed[nCalibPos] =FALSE;
//                     pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
//                     m_bStatusBar = FALSE;
//                     m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
//                     m_strStatusBarInfo1 = _T("");
//                     SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
// 					{		
// 						CTime t = CTime::GetCurrentTime();	
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 						SYSTEMTIME sys; 
// 						GetLocalTime(&sys); 
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
// 						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 						{
// 							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
// 								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
// 						}
// 						/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 						m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 						{
// 							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
// 						}
// 					}
//                     return FALSE;
//                 }
//             }
// 		} 
// 		else
// 		{
// 			if (0 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
// 			{
// 				// 目标定位工具是否正常 
// 				if (m_bValidTargetSearchTool!=TRUE)
// 				{
// 					//ReportCalibResult(FALSE);
// 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 					return FALSE;
// 				}
// 
// 				// 用目标模板执行标定搜索
// 				CCoordPos cp;
// 				BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 0);
// 				if(bSearchSucceed)
// 				{			
// 					m_vbSearchSucceed[nCalibPos] = TRUE;
// 					m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,0);
// 
// 					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
// 					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
// 					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 
// 					m_bStatusBar = TRUE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 				}
// 				else
// 				{
// 					////////////////////////////////////////////////////
// 					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
// 					{
// 
// 						m_bStatusBar = TRUE;
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 						m_strStatusBarInfo1 = _T("");
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 						return TRUE;
// 					}
// 					////////////////////////////////////////////////////
// 					cp.m_dPosX  = 0;
// 					cp.m_dPosY  = 0;
// 					cp.m_dAngle = 0;
// 					m_vbSearchSucceed[nCalibPos] =FALSE;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
// 					{		
// 						CTime t = CTime::GetCurrentTime();	
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 						SYSTEMTIME sys; 
// 						GetLocalTime(&sys); 
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
// 						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 						{
// 							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
// 								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
// 						}
// 						/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 						m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 						{
// 							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
// 						}
// 					}	
// 					return FALSE;
// 				}
// 
// 			}	
// 			else if (1 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
// 			{
// 				// 对象定位工具是否正常 
// 				if (m_bValidObjectSearchTool!=TRUE)
// 				{
// 					//ReportCalibResult(FALSE);
// 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 					return FALSE;
// 				}
// 
// 				// 用对象模板执行标定搜索
// 				CCoordPos cp;
// 				BOOL bSearchSucceed = ExecuteAlnObjectSearch(nCalibPos, 0);
// 				if(bSearchSucceed)
// 				{			
// 					m_vbSearchSucceed[nCalibPos] = TRUE;
// 					m_vSeachResults[nCalibPos] = GetAlnObjectSearchResult(nCalibPos,0);
// 
// 					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
// 					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
// 					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 
// 					m_bStatusBar = TRUE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 				}
// 				else
// 				{
// 					////////////////////////////////////////////////////
// 					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
// 					{
// 
// 						m_bStatusBar = TRUE;
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 						m_strStatusBarInfo1 = _T("");
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 						return TRUE;
// 					}
// 					////////////////////////////////////////////////////
// 					cp.m_dPosX  = 0;
// 					cp.m_dPosY  = 0;
// 					cp.m_dAngle = 0;
// 					m_vbSearchSucceed[nCalibPos] =FALSE;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 					if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
// 					{		
// 						CTime t = CTime::GetCurrentTime();	
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 						SYSTEMTIME sys; 
// 						GetLocalTime(&sys); 
// 						m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
// 						if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 						{
// 							m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
// 								nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
// 						}
// 						/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 						m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 						SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 						if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 						{
// 							m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
// 						}
// 					}
// 					return FALSE;
// 				}
// 			}
// 			else if (2 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
// 			{
// 				// 标定定位工具是否正常 
// 				if (m_bValidCalibSearchTool!=TRUE)
// 				{
// 					//ReportCalibResult(FALSE);
// 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 					return FALSE;
// 				}
// 
// 				// 用目标模板执行标定搜索
// 				CCoordPos cp;
// 				BOOL bSearchSucceed = ExecuteCalibTargetSearch(nCalibPos, 0);
// 				if(bSearchSucceed)
// 				{			
// 					m_vbSearchSucceed[nCalibPos] = TRUE;
// 					m_vSeachResults[nCalibPos] = GetCalibSearchResult(nCalibPos,0);
// 
// 					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
// 					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
// 					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 
// 					m_bStatusBar = TRUE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 				}
// 				else
// 				{
// 					////////////////////////////////////////////////////
// 					if (TRUE == ExcuteManualSearch(2,nCalibPos,nMoveIndex))
// 					{
// 
// 						m_bStatusBar = TRUE;
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
// 						m_strStatusBarInfo1 = _T("");
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 						return TRUE;
// 					}
// 					////////////////////////////////////////////////////
// 					cp.m_dPosX  = 0;
// 					cp.m_dPosY  = 0;
// 					cp.m_dAngle = 0;
// 					m_vbSearchSucceed[nCalibPos] =FALSE;
// 					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
// 					m_strStatusBarInfo1 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 					return FALSE;
// 				}
// 
// 			}
// 		}
// 
// 
// 
// 
// 
// 		// 		Sleep(500);
// 		// 		// 		// 将相机移动到多个位置，逐个定位
// 		// 		// 		pMarkImagePos = new CMarkImagePos;
// 		// 		// 		pMarkImagePos->SetMarkImagePosNum(1);
// 		// 
// 		// 		//for (int n=0; n<nCamPos; n++)
// 		// 		{
// 		// 
// 		// 
// 		// 			// 			if (nCamNum==1)
// 		// 			// 			{
// 		// 			// 				// 调整该单相机的回调参数索引
// 		// 			// 				m_vpCamera.at(0)->Freeze();
// 		// 			// 				m_vpCamOwner.at(0)->m_nCamIndex = nCalibPos;
// 		// 			// 				m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 		// 			// 				m_vpCamera.at(0)->Grab();
// 		// 			// 			}
// 		// 
// 		// 			// 等待搜索延时
// 		// 			int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 		// 			Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nCalibPos]->m_nSearchDelayTime);
// 		// 
// 		// 			// 准备开始定位			
// 		// 			std::vector<int> vnPosIndex;
// 		// 			std::vector<SearchMode> vsmSearchMode;	
// 		// 			vnPosIndex.push_back(nCalibPos);		// nCalibPos	
// 		// 			vsmSearchMode.push_back(eTargetSearch);	// 标定搜索
// 		// 
// 		// 			// 采集搜索图像
// 		// 			if (!SnapSearchImage(vnPosIndex))
// 		// 			{
// 		// 				//ReportCalibResult(FALSE);
// 		// 
// 		// 				// 				if (pMarkImagePos!=NULL)
// 		// 				// 				{
// 		// 				// 					delete pMarkImagePos;
// 		// 				// 					pMarkImagePos = NULL;
// 		// 				// 				}
// 		// 				// 
// 		// 				// 				for (int p=0; p<vpMarkImagePos.size(); p++)
// 		// 				// 				{
// 		// 				// 					if (vpMarkImagePos.at(p))
// 		// 				// 					{
// 		// 				// 						delete vpMarkImagePos.at(p);
// 		// 				// 						vpMarkImagePos.at(p) = NULL;
// 		// 				// 					}
// 		// 				// 				}  
// 		// 
// 		// 				m_bStatusBar = FALSE;
// 		// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// 		// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// 		// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		// 
// 		// 				return FALSE;
// 		// 			}
// 		// 
// 		// 			// 定位
// 		// 			m_vnTargetSearchStartPatIndex[nCalibPos] = 0;
// 		// 			m_vnTargetSearchEndPatIndex[nCalibPos] = 0;
// 		// 			BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
// 		// 
// 		// 			// 分析定位结果，发送指令响应
// 		// 			if (FALSE == bSearchSucceed)
// 		// 			{
// 		// 				//ReportCalibResult(FALSE);
// 		// 
// 		// 				m_bStatusBar = FALSE;
// 		// 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_MOVE_ROTATE_POS_SEARCH_FAILED), nMoveIndex);
// 		// 				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAM_MOVE_THEN_SEARCH_FAILED), nCalibPos); 
// 		// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		// 
// 		// 				// 				if (pMarkImagePos!=NULL)
// 		// 				// 				{
// 		// 				// 					delete pMarkImagePos;
// 		// 				// 					pMarkImagePos = NULL;
// 		// 				// 				}
// 		// 				// 
// 		// 				// 				for (int p=0; p<vpMarkImagePos.size(); p++)
// 		// 				// 				{
// 		// 				// 					if (vpMarkImagePos.at(p))
// 		// 				// 					{
// 		// 				// 						delete vpMarkImagePos.at(p);
// 		// 				// 						vpMarkImagePos.at(p) = NULL;
// 		// 				// 					}
// 		// 				// 				}  
// 		// 				return FALSE;
// 		// 			}
// 		// 
// 		// 			// 保存定位结果		
// 		// 			pMarkImagePos->SetMarkImagePos(nCalibPos, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nCalibPos));	
// 		// 
// 		// 		}
// 		// 
// 		// 		CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
// 		// 		vpMarkImagePos.push_back(markpos); 
// 
// 		// 记录图像搜索数据
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// // 			CTime t = CTime::GetCurrentTime();
// // 			strTemp.Format(_T("\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strOut;
// 			CCoordPos cp;
// 			strOut = strTemp + _T("CalibSearch: ");		
// 			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
// 			{
// 				strTemp = _T("");
// 				cp = pMarkImagePos->GetMarkImagePos(i);
// 
// 				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 				strOut += strTemp;
// 			}
// 
// // 			FILE *stream;
// // 			CString strPath = m_strAlignProcessData;
// // 			stream = fopen(strPath, _T("a+t"));               
// // 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
// // 			fclose(stream);VCRemoveFile(strPath);
// 
// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 			VisionAlignLogRecord(m_strAlignProcessData, strOut);
// 			////GYM-关联日志存储
// 			strOut.Empty();
// 			cp = pMarkImagePos->GetMarkImagePos(nCalibPos);
// 			strTemp.Format(_T("......位置%d第%d次移动到拍照位的图像定位坐标: X: %.2f; Y: %.2f; D: %.2f;\n"),nCalibPos+1,nMoveIndex+1,cp.m_dPosX, cp.m_dPosY, cp.m_dAngle);
// 			strOut += strTemp;
// 			VisionAlignLogRecord(strCorrelationLogPath,strOut,FALSE);
// 			///GYM
// 		}	
// 		if (m_pVisionASMConfig->m_DataRecord.m_bImgData && m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo
// 						&& m_pVisionASMConfig->m_DataRecord.m_bCommunication)
// 		{		
// 					CTime t = CTime::GetCurrentTime();	
// 					m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearch.bmp"),
// 							t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 					SYSTEMTIME sys; 
// 					GetLocalTime(&sys); 
// 					m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearch.bmp"),
// 							sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 					m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) + 1;																			
// 					if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 					{
// 						m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearch-CH%02d-%03d.bmp"), 
// 							nCalibPos,m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos));
// 					}
// 					/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
// 					m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
// 					SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 					if(m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 					{
// 						m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) = 0;
// 					}
// 		}			
// 	}    	
// 	// 	if (pMarkImagePos!=NULL)
// 	// 	{
// 	// 		delete pMarkImagePos;
// 	// 		pMarkImagePos = NULL;
// 	// 	}     
// 	// 
// 	// 	// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具
// 	// 	if(FALSE == ExecuteCalibrate(vpMarkImagePos,nCalibPos))
// 	// 	{
// 	// 		ReportCalibResult(FALSE);
// 	// 
// 	// 		m_bStatusBar = FALSE;
// 	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 	// 		m_strStatusBarInfo2 = _T("");
// 	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 	// 
// 	// 		for (k=0; k<vpMarkImagePos.size(); k++)
// 	// 		{
// 	// 			if (vpMarkImagePos.at(k))
// 	// 			{
// 	// 				delete vpMarkImagePos.at(k);
// 	// 				vpMarkImagePos.at(k) = NULL;
// 	// 			}
// 	// 		} 
// 	// 
// 	// 		SaveCurAllCameraChannelSearchImg();		
// 	// 		return FALSE;
// 	// 	}
// 	// 
// 	// 
// 	// 	// 5. 释放内存
// 	// 	for (k=0; k<vpMarkImagePos.size(); k++)
// 	// 	{
// 	// 		if (vpMarkImagePos.at(k))
// 	// 		{
// 	// 			delete vpMarkImagePos.at(k);
// 	// 			vpMarkImagePos.at(k) = NULL;
// 	// 		}
// 	// 	}   
// 	return TRUE;
// }

// FGTW:拍照取得目标（目标靶标）的平台坐标上的位置
BOOL vcXYDVisionAlign::OnlineAlnSearchExFGTW(int nPosIndex, int nPatIndex)
{
	CString strCmd = _T("VGTW:");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}

	std::vector<int> vnPosIndex;
	if (nPosIndex == 4)
	{
		for (int i=0;i<GetPosNum();i++)
		{
			vnPosIndex.push_back(i);
		}
	}
	else if (nPosIndex == 11)
	{
		for (int i=0;i<GetPosNum()/2;i++)
		{
			vnPosIndex.push_back(i+GetPosNum()/2);
		}
	}
	else if (nPosIndex>=14 && nPosIndex<=17)
	{
		vnPosIndex.push_back(nPosIndex - 10);
	}

	m_bTargetMarkSearchSucceed = OnSerialCameraAlignerSearchExFGTW(vnPosIndex,nPatIndex);

	return m_bTargetMarkSearchSucceed;
}

BOOL vcXYDVisionAlign::OnSerialCameraAlignerSearchExFGTW(std::vector<int> vnPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VGTW:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	std::vector<CCoordPos> vCoordPos;
	std::vector<CPlatformXYDAxisPos> vPlatformXYDAxisPos;
	GetCommCommandName(strCmd);
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);
		return FALSE;
	}
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nStartPatIndex);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		if (SystempOptionSearchShutter && bTargetShutter)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (m_vpTargetPlatformAxisPos.size() <= 0 
			|| m_vpTargetPlatformAxisPos.at(vnPosIndex[0]) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(vnPosIndex[0]));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
	}

	if (!bCommuciateGetPlatformAxisAbsPos)	
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			nPosIndex = vnPosIndex[i];
			SetTargetPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;
			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<SearchMode> vsmSearchMode;	
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		vsmSearchMode.push_back(eTargetSearch);	// 

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex-GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);
		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 		//if (m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);
	}
	else
	{
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//if (m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}
	// 定位
	BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
	BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (bTargetSearchCandidate == FALSE)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bTargetSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[vnPosIndex[0]];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = TARGETCANDIDATENUM-1;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{
				if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
				{
					continue;
				}

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					m_vnTargetSearchStartPatIndex[nPosIndex] = j;
					m_vnTargetSearchEndPatIndex[nPosIndex] = j;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				if (bSearchSucceed)
				{
					break;
				}
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
				BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
				if (bTargetSearchCandidate == FALSE)
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
				else
				{
					if (bTargetSearchSync == TRUE)
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
						{
							nTempStartPatIndex = nStartPatIndex;
						}
						else if (nStartPatIndex == 9)
						{
							nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[vnPosIndex[0]];
						}
						else
						{
							nTempStartPatIndex = 0;
						}
						nTempEndPatIndex = TARGETCANDIDATENUM-1;

						int j = 0;
						for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
						{
							if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
							{
								continue;
							}

							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								m_vnTargetSearchStartPatIndex[nPosIndex] = j;
								m_vnTargetSearchEndPatIndex[nPosIndex] = j;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
							if (bSearchSucceed)
							{
								break;
							}
						}
					}
					else
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
							{
								nTempStartPatIndex = nStartPatIndex;
							}
							else if (nStartPatIndex == 9)
							{
								nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
							}
							else
							{
								nTempStartPatIndex = 0;
							}
							nTempEndPatIndex = TARGETCANDIDATENUM-1;

							m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
							m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
				}
				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}
		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		vnHomoPosIndex = vnPosIndex;

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
	}
	else
	{
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
	}
	//ShowExtraGuiToDisplay(vnPosIndex, TRUE,0);



	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(FALSE, FALSE);
		return FALSE;
	}

	//for (i = 0; i < m_mpTargetMarkImagePos.m_vbOK.size(); i++)
	//{
	//	m_mpTargetMarkImagePos.m_vbOK.at(i) = true;	
	//}

	// 5. 设置对位工具
	m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}
	// 计算目标距离
	if ((m_pPlatformInfo->m_bTargetObjectCamSeparate && vnPosIndex.size()==GetPosNum()/2)||(!m_pPlatformInfo->m_bTargetObjectCamSeparate && vnPosIndex.size()==GetPosNum()))
	{
		//		CalculateTargetDistance(); 
		if (!CheckTargetDistance())
		{
			if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			//			RecordTargetSizeIndfo(TRUE, FALSE);

			return FALSE;
		}
		//		RecordTargetSizeIndfo(TRUE, TRUE);

		if (!CheckTargetAngle())
		{
			if(m_bTargetSearchTest) ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}

	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	if(m_pAlignerTool == NULL)
	{
		if(m_bObjectSearchTest)ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	CMarkPlatformPos mpTargetMarkPos;
	//mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPosForCheck();
	mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPosForAlign();
	BOOL bSucceed = TRUE;
	for (int i=0;i<vnPosIndex.size();i++)
	{
		nPosIndex = vnPosIndex.at(i);
		bSucceed = bSucceed && mpTargetMarkPos.GetIsMarkPlatformPosOK(nPosIndex);
	}

	// 记录图像搜索数据平台坐标
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");
		strTemp = _T("");
		for (int i=0;i<vnPosIndex.size();i++)
		{
			nPosIndex = vnPosIndex.at(i);
			cp = mpTargetMarkPos.GetMarkPlatformPos(nPosIndex);
			strTemp.Format(_T("MarkPlatPos%d(%.2f,%.2f) "), nPosIndex, cp.GetPosX(), cp.GetPosY());
			strOut += strTemp;
		}
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}	

	if (bSucceed)
	{
		for (int i=0;i<vnPosIndex.size();i++)
		{
			nPosIndex = vnPosIndex.at(i);
			vCoordPos.push_back(mpTargetMarkPos.GetMarkPlatformPos(nPosIndex));
			vPlatformXYDAxisPos.push_back(*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex)));
		}
		if(m_bTargetSearchTest)ReportGetTargetPlatformPosFGTW(TRUE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return TRUE;
	}
	else
	{
		if(m_bTargetSearchTest)ReportGetTargetPlatformPosFGTW(FALSE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	return FALSE;
}


BOOL vcXYDVisionAlign::OnlineAlignExFACOAfterSearch(int nOffsetIndex, int nBenchOffsetIndex/* = -1*/, int nExProductIndex/* = 0*/,int nTarFixOffsetIndex/* = 0 */)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


	SetAlignBenchOffsetIndex(nBenchOffsetIndex);
	SetAlignExProductIndex(nExProductIndex);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	// start 直接根据searchdata中图像坐标和轴位置 设置进对位工具中；
	{
		int nSize1 = m_vvpTargetPlatformAxisPosMultiEx.size();
		int nSize2 = m_vvpObjectPlatformAxisPosMultiEx.size();
		int nSize3 = m_vmpObjectMarkImagePos_MultiEX.size();
		int nSize4 = m_vmpTargetMarkImagePosMultiEx.size();
		bool bTmp = (nExProductIndex >=0) &&  (nExProductIndex <nSize1) &&  (nExProductIndex <nSize2) &&  (nExProductIndex <nSize3)  &&  (nExProductIndex <nSize4);

		if (bTmp)
		{

			vector<CPlatformAxisPos*> tmpObjectPlatformAxisPos;
			vector<CPlatformAxisPos*> tmpTargetPlatformAxisPos;
			tmpObjectPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);
			tmpTargetPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);

			if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
			{

				if (optionInfo.m_bObjectSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{
						tmpObjectPlatformAxisPos.at(jt) = m_vvpObjectPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpObjectMarkImagePos = m_vmpObjectMarkImagePos_MultiEX.at(nExProductIndex);
				}
				else
				{
					tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				}

				if (optionInfo.m_bTargetSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{					
						tmpTargetPlatformAxisPos.at(jt) = m_vvpTargetPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}		
					m_mpTargetMarkImagePos = m_vmpTargetMarkImagePosMultiEx.at(nExProductIndex);
				}
				else
				{
					tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
				}

			}
			else
			{
				tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
			}


			m_pAlignerTool->SetTargetPlatformPos(tmpTargetPlatformAxisPos);
			//m_pAlignerTool->SetTargetMarkSearchResultsInit(tmpTargetImagePos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			m_pAlignerTool->SetObjectPlatformPos(tmpObjectPlatformAxisPos);
			//m_pAlignerTool->SetObjectMarkSearchResultsAll(tmpObjectImagePos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);


			m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
			m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();

		}
	}
	// end  直接根据searchdata中图像坐标和轴位置 设置进对位工具中；

	m_AlignerTargetSizeInfo.m_nExProductIndex = nExProductIndex;
	CCoordPos platOffset;


	if (optionInfo.m_bEnableMutiTarget)
	{
		m_bTargetMarkSearchSucceed=m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
		if (m_bTargetMarkSearchSucceed)
		{
			SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
			m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			for (int i=0;i<nPosNum;i++)
			{
				SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
			}
			PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
		}	
	}

	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (FALSE == m_bValidAlignerTool)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerBenchOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerBenchOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();


	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);


	if (optionInfo.m_nTarInfoCommModeInDiffPC == 2)//通过PLC交换目标图像坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetImgPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetImagePos(vnPosIndex,vTargetImgPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(_T("通信获取目标图像坐标失败"));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = _T("通信获取目标图像坐标失败");// 
					m_strStatusBarInfo2 = _T("");//
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex,TRUE,vTargetImgPos.at(i));
			}
			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		}
	}
	else if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetCoordPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(TRUE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetPlatformPos(vnPosIndex,vTargetCoordPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(_T("通信获取目标平台坐标失败"));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			CMarkPlatformPos mpTargetMarkPos;
			mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();
			for (int i=0;i<mpTargetMarkPos.m_vbOK.size();i++)
			{
				mpTargetMarkPos.m_vbOK.at(i) = TRUE;
			}
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = _T("通信获取目标平台坐标失败");// 
					m_strStatusBarInfo2 = _T("");//
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				mpTargetMarkPos.SetMarkPlatformPos(nPosIndex,TRUE,vTargetCoordPos.at(i));
			}
			m_pAlignerTool->SetTargetMarkPlatformPos(mpTargetMarkPos);
		}
	}
	else
	{
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		// 检查目标Mark是否已成功定位
		if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
		{
			if (FALSE == m_bTargetMarkSearchSucceed)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;
			}
		}
	}
	// 检查对象Mark是否已成功定位
	if (eObjectBench != curProductData.m_pAlignerParam->m_eObjectMarkType)
	{
		if (FALSE == m_bObjectMarkSearchSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

			return FALSE;
		}	

		//		CalculateObjectDistance(); 
		if (!CheckObjectDistance())
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_DIS_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
	}

	//	CalculateTargetDistance(); 
	if (!CheckTargetDistance())
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	if (!CheckTargetAngle())
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	// 执行对位计算
	CCoordPos cpBenchOffset;
	CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos = NULL;
	if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
	{
		// 执行对位计算
		// 设置图像中心十字基准目标
		SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
		m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

		// 执行对位
		m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
		if(FALSE == ExecuteAlign())
		{
			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}
		pBenchPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
		cpBenchOffset = GetAlignPlatformPosOffset();


		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效
		// 设置实时的目标
		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);		
	}

	// 执行对位计算
	if(FALSE == ExecuteAlign())
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
		//		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		//		SaveCurAllCameraChannelSearchImg();
		return FALSE;     
	}


	// 更新主界面对位精度、次数、对位总时间
	CCoordPos cpProduct = GetAlignProductOffset();
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
	}

	m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;
	m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
	m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

	CCoordPos cp = GetAlignPlatformOffset();
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
	}

	m_apAlignerProcesInfo.nTimes  = 1;

	m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
	m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
	m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
	m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

	dAlignTime=m_apAlignerProcesInfo.dTime;

	PostMessageUpdateAlignerProcessInfo();	


	/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
	|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
	|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
	//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
	//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
	//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
	if(IsAxisMoveOverRun(cp))
	{

		CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();


		CCoordPos cpOffset;
		cpOffset = GetAlignPlatformPosOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
		}

		// ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
		m_strStatusBarInfo2.Format(_T(""));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();				

	// 记录对位精度
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;					
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录对位时间
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;						
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}	
	// 
	// 	ReportAlignResultFACO(cp,TRUE);

	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

	CCoordPos cpOffset;
	cpOffset = GetAlignPlatformPosOffset();

	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

		AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
	}

	return TRUE;  

}

BOOL vcXYDVisionAlign::OnlineAlignExFACO(int nOffsetIndex, int nBenchOffsetIndex/* = -1*/, int nExProductIndex/* = 0*/,int nTarFixOffsetIndex/* = 0 */)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


	SetAlignBenchOffsetIndex(nBenchOffsetIndex);
	SetAlignExProductIndex(nExProductIndex);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// start 直接根据searchdata中图像坐标和轴位置 设置进对位工具中；
	{
		int nSize1 = m_vvpTargetPlatformAxisPosMultiEx.size();
		int nSize2 = m_vvpObjectPlatformAxisPosMultiEx.size();
		int nSize3 = m_vmpObjectMarkImagePos_MultiEX.size();
		int nSize4 = m_vmpTargetMarkImagePosMultiEx.size();
		bool bTmp = (nExProductIndex >=0) &&  (nExProductIndex <nSize1) &&  (nExProductIndex <nSize2) &&  (nExProductIndex <nSize3)  &&  (nExProductIndex <nSize4);

		if (bTmp)
		{

			vector<CPlatformAxisPos*> tmpObjectPlatformAxisPos;
			vector<CPlatformAxisPos*> tmpTargetPlatformAxisPos;
			tmpObjectPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);
			tmpTargetPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);

			if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
			{
				if (optionInfo.m_bObjectSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{
						tmpObjectPlatformAxisPos.at(jt) = m_vvpObjectPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpObjectMarkImagePos = m_vmpObjectMarkImagePos_MultiEX.at(nExProductIndex);
				}
				else
				{
					tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				}

				if (optionInfo.m_bTargetSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{
						tmpTargetPlatformAxisPos.at(jt) = m_vvpTargetPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpTargetMarkImagePos = m_vmpTargetMarkImagePosMultiEx.at(nExProductIndex);
				}
				else
				{
					tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
				}

			}
			else
			{
				tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
			}


			m_pAlignerTool->SetTargetPlatformPos(tmpTargetPlatformAxisPos);
			//m_pAlignerTool->SetTargetMarkSearchResultsInit(tmpTargetImagePos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			m_pAlignerTool->SetObjectPlatformPos(tmpObjectPlatformAxisPos);
			//m_pAlignerTool->SetObjectMarkSearchResultsAll(tmpObjectImagePos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);


			//lzk 0417
			std::vector<int> nObjectPosIndex;
			std::vector<int> nTargetPosIndex;
			CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
			BOOL bObjectPositionVirtualMod = pAlignerParam->GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;
			BOOL bTargetPositionVirtualMod = pAlignerParam->GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode;
			BOOL bTargetAndObjectPositionVirtualMod = m_pAlignerTool->GetEnablePositionVirtualMode();
			int nObjectPositionVirtual = pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;
			int nTargetPositionVirtual = pAlignerParam->GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode;
			//对象位置虚拟
			if (bTargetAndObjectPositionVirtualMod && bObjectPositionVirtualMod)
			{
				//对象位置虚拟模式：12拍照34虚拟(BOOL)
				if (nObjectPositionVirtual == 0)
				{
					nObjectPosIndex.push_back(0);
					nObjectPosIndex.push_back(1);
				}
				//对象位置虚拟模式：34拍照12虚拟
				else if (nObjectPositionVirtual == 1)
				{
					nObjectPosIndex.push_back(2);
					nObjectPosIndex.push_back(3);
				}
				//对象位置虚拟模式：13拍照24虚拟
				else if (nObjectPositionVirtual == 2)
				{
					nObjectPosIndex.push_back(0);
					nObjectPosIndex.push_back(2);
				}
				//对象位置虚拟模式：24拍照13虚拟
				else if (nObjectPositionVirtual == 3)
				{
					nObjectPosIndex.push_back(1);
					nObjectPosIndex.push_back(3);
				}

				m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK(nObjectPosIndex);
			}
			else
			{
				m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();
			}

			//目标位置虚拟
			if (bTargetAndObjectPositionVirtualMod && bTargetPositionVirtualMod)
			{
				//目标位置虚拟模式：56拍照78虚拟
				if (nTargetPositionVirtual == 0)
				{
					nTargetPosIndex.push_back(4);
					nTargetPosIndex.push_back(5);
				}
				//目标位置虚拟模式：78拍照56虚拟
				else if (nTargetPositionVirtual == 1)
				{
					nTargetPosIndex.push_back(6);
					nTargetPosIndex.push_back(7);
				}
				//目标位置虚拟模式：57拍照68虚拟
				else if (nTargetPositionVirtual == 2)
				{
					nTargetPosIndex.push_back(4);
					nTargetPosIndex.push_back(6);
				}
				//目标位置虚拟模式：68拍照57虚拟
				else if (nTargetPositionVirtual == 3)
				{
					nTargetPosIndex.push_back(5);
					nTargetPosIndex.push_back(7);
				}
				m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK(nTargetPosIndex);
			}
			else
			{
				m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
			}

		}		
	}
	// end  直接根据searchdata中图像坐标和轴位置 设置进对位工具中；

	m_AlignerTargetSizeInfo.m_nExProductIndex = nExProductIndex;

	if (optionInfo.m_bEnableMutiTarget)
	{
		m_bTargetMarkSearchSucceed=m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
		if (m_bTargetMarkSearchSucceed)
		{
			SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
			m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			for (int i=0;i<nPosNum;i++)
			{
				SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
			}
			PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
		}	
	}

	CCoordPos platOffset;
	CString strCmd = _T("VACO:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFACO(platOffset,FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd) /*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFACO(platOffset,FALSE);

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFACO(platOffset,FALSE);

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFACO(platOffset,FALSE);

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);

			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerBenchOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerBenchOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);

	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	if (optionInfo.m_nTarInfoCommModeInDiffPC == 2)//通过PLC交换目标图像坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetImgPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetImagePos(vnPosIndex,vTargetImgPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARIMGPOS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					ReportAlignResultFACO(platOffset,FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARIMGPOS);
					m_strStatusBarInfo2 = _T("");//
					SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}

				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex,TRUE,vTargetImgPos.at(i));

			}

			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		}
	}
	else if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetCoordPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(TRUE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetPlatformPos(vnPosIndex,vTargetCoordPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARPLATFORMPOS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			CMarkPlatformPos mpTargetMarkPos;
			mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();
			for (int i=0;i<mpTargetMarkPos.m_vbOK.size();i++)
			{
				mpTargetMarkPos.m_vbOK.at(i) = TRUE;
			}
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					ReportAlignResultFACO(platOffset,FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARPLATFORMPOS);
					m_strStatusBarInfo2 = _T("");//
					SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					return FALSE;
				}

				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				mpTargetMarkPos.SetMarkPlatformPos(nPosIndex,TRUE,vTargetCoordPos.at(i));

			}

			m_pAlignerTool->SetTargetMarkPlatformPos(mpTargetMarkPos);
		}
	}
	else
	{
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		// 检查目标Mark是否已成功定位
		if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
		{
			if (!m_bIsExecuteFixTargetCheck && !m_bIsExecuteSizeCheck)  //执行标定关联验证过程时
			{
				if (FALSE == m_bTargetMarkSearchSucceed)
				{
					ReportAlignResultFACO(platOffset,FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}
			}
		}
	}

	// 检查对象Mark是否已成功定位
	if (eObjectBench != curProductData.m_pAlignerParam->m_eObjectMarkType)
	{
		if (!m_bIsExecuteFixTargetCheck && !m_bIsExecuteSizeCheck)  //执行标定关联验证过程时
		{
			if (FALSE == m_bObjectMarkSearchSucceed)
			{
				ReportAlignResultFACO(platOffset,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );
				m_strStatusBarInfo2 = _T("");

				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();	

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}	
		}

		if (!m_bIsExecuteFixTargetCheck) // 固定目标对位 执行标定检查时  对位时不进行对象目标尺寸检测 
		{
			//			CalculateObjectDistance(); 
			if (!CheckObjectDistance())
			{
				ReportAlignResultFACO(platOffset,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_DIS_OUT_RANGE);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

				return FALSE;
			}


			if (!CheckObjectAngle())
			{
				ReportAlignResultFACO(platOffset,FALSE);

				m_bStatusBar = FALSE;
				//				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_ANGLE_OUT_RANGE);
				m_strStatusBarInfo1 = _T("对象角度超过设定标准，对象定位结果可能出错");
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

				return FALSE;
			}


		}
	}

	if (!m_bIsExecuteFixTargetCheck) // 固定目标对位 执行标定检查时  对位时不进行对象目标尺寸检测 
	{
		//		CalculateTargetDistance(); 
		if (!CheckTargetDistance())
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}

		if (!CheckTargetAngle())
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");

			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}
	}

	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	// 执行对位计算
	CCoordPos cpBenchOffset;
	CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos = NULL;	
	if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
	{
		// 执行对位计算
		// 设置图像中心十字基准目标
		SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
		m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

		// 执行对位
		m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
		if(FALSE == ExecuteAlign())
		{
			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}

		pBenchPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
		cpBenchOffset = GetAlignPlatformPosOffset();


		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效
		// 设置实时的目标
		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);		
	}

	// 执行对位计算
	if(FALSE == ExecuteAlign())
	{
		ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
		m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));

		//		SaveCurAllCameraChannelSearchImg();
		return FALSE;     
	}


	// 更新主界面对位精度、次数、对位总时间
	CCoordPos cpProduct = GetAlignProductOffset();

	// 一次对位时，勾选目标补偿时出现异常情况
	double dPosX = pAlignerParam->GetAlnTargetOffsetX();
	double dPosY = pAlignerParam->GetAlnTargetOffsetY();
	CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pPlatformInfo);
	int iPlatformYCoordType = platformXYDInfo->m_nPlatformYCoordType;
	int iPlatformXCoordType = platformXYDInfo->m_nPlatformXCoordType;
	if (eDirectNegative == iPlatformXCoordType) dPosX = -1*dPosX;
	if (eDirectNegative == iPlatformYCoordType) dPosY = -1*dPosY;


	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		//cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		//cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		cpProduct.m_dPosX+=dPosX;
		cpProduct.m_dPosY+=dPosY;

	}

	m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
	m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
	m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

	CCoordPos cp = GetAlignPlatformOffset();
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		//cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		//cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		cp.m_dPosX+=dPosX;
		cp.m_dPosY+=dPosY;
	}

	m_apAlignerProcesInfo.nTimes  = 1;

	m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
	m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
	m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
	m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

	dAlignTime=m_apAlignerProcesInfo.dTime;

	PostMessageUpdateAlignerProcessInfo();	

	if(IsAxisMoveOverRun(cp))
	{
		CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

		CCoordPos cpOffset;
		cpOffset = GetAlignPlatformPosOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
		}

		ReportAlignResultFACO(cpOffset,FALSE,pPlatformXYDAxisPos);

		// ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
		m_strStatusBarInfo2.Format(_T(""));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();				

	// 记录对位精度
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;					
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录对位时间
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;						
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}	
	// 
	// 	ReportAlignResultFACO(cp,TRUE);

	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

	CCoordPos cpOffset;
	cpOffset = GetAlignPlatformPosOffset();

	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		//cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		//cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

		cpOffset.m_dPosX += dPosX;
		cpOffset.m_dPosY += dPosY;

		AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
	}


	if (!pAlignerParam->GetAlignAccordingToPickPlatformEnable())
	{
		ReportAlignResultFACO(cpOffset,TRUE,pPlatformXYDAxisPos, cpBenchOffset, pBenchPlatformXYDAxisPos);
	}
	else
	{
		CCoordPos cpOffsetPickResive;
		cpOffsetPickResive = GetAlignPlatformPickRevise();
		ReportAlignResultFACO(cpOffset, cpOffsetPickResive, TRUE, pPlatformXYDAxisPos, cpBenchOffset, pBenchPlatformXYDAxisPos);
	}

	// 对位完成后 清理拍照状态；避免没有更新拍照，以旧的Mark点去执行对位
	if(optionInfo.m_bAlignFinishClearSnapStatus)
	{
		for (int it=0;it<m_mpObjectMarkImagePos.m_vbOK.size();it++)
		{
			m_mpObjectMarkImagePos.m_vbOK.at(it) = FALSE;
		}

		for (int it=0;it<m_mpTargetMarkImagePos.m_vbOK.size();it++)
		{
			m_mpTargetMarkImagePos.m_vbOK.at(it) = FALSE;
		}

		if (nExProductIndex< m_vmpObjectMarkImagePos_MultiEX.size() && nExProductIndex<m_vmpTargetMarkImagePosMultiEx.size())
		{
			m_vmpObjectMarkImagePos_MultiEX.at(nExProductIndex) = m_mpObjectMarkImagePos;
			m_vmpTargetMarkImagePosMultiEx.at(nExProductIndex) = m_mpTargetMarkImagePos;
		}
	}

	return TRUE;  

}


BOOL vcXYDVisionAlign::OnlineAlnSearchExFGTP(int nPosIndex, int nPatIndex)
{
	CString strCmd = _T("VGTP:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}

	std::vector<int> vnPosIndex;
	if (nPosIndex == 4)
	{
		for (int i=0;i<GetPosNum();i++)
		{
			vnPosIndex.push_back(i);
		}
	}
	else if (nPosIndex == 11)
	{
		for (int i=0;i<GetPosNum()/2;i++)
		{
			vnPosIndex.push_back(i+GetPosNum()/2);
		}
	}
	else if (nPosIndex>=14 && nPosIndex<=17)
	{
		vnPosIndex.push_back(nPosIndex - 10);
	}

	m_bTargetMarkSearchSucceed = OnSerialCameraAlignerSearchExFGTP(vnPosIndex,nPatIndex);

	return m_bTargetMarkSearchSucceed;
}

BOOL vcXYDVisionAlign::OnSerialCameraAlignerSearchExFGTP(std::vector<int> vnPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VGTP:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	std::vector<CCoordPos> vImagePos;
	std::vector<CPlatformXYDAxisPos> vPlatformXYDAxisPos;
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (!CheckAlignerSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bTargetSearchTest) ReportGetTargetImagePosFGTP(FALSE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);
		return FALSE;
	}

	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bTargetSearchTest) ReportGetTargetImagePosFGTP(FALSE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);
		return FALSE;
	}
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bTargetSearchTest) ReportGetTargetImagePosFGTP(FALSE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nStartPatIndex);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		if (SystempOptionSearchShutter && bTargetShutter)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (m_vpTargetPlatformAxisPos.size() <= 0 
			|| m_vpTargetPlatformAxisPos.at(vnPosIndex[0]) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(vnPosIndex[0]));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
	}

	if (!bCommuciateGetPlatformAxisAbsPos)	
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportGetTargetImagePosFGTP(FALSE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			nPosIndex = vnPosIndex[i];
			SetTargetPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;
			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<SearchMode> vsmSearchMode;	
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		vsmSearchMode.push_back(eTargetSearch);	// 

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex-GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);
		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 		//if (m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);
	}
	else
	{
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//if (m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportGetTargetImagePosFGTP(FALSE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}
	// 定位
	BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
	BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (bTargetSearchCandidate == FALSE)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bTargetSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[vnPosIndex[0]];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = TARGETCANDIDATENUM-1;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{
				if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
				{
					continue;
				}

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					m_vnTargetSearchStartPatIndex[nPosIndex] = j;
					m_vnTargetSearchEndPatIndex[nPosIndex] = j;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				if (bSearchSucceed)
				{
					break;
				}
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportGetTargetImagePosFGTP(FALSE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
				BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
				if (bTargetSearchCandidate == FALSE)
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
				else
				{
					if (bTargetSearchSync == TRUE)
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
						{
							nTempStartPatIndex = nStartPatIndex;
						}
						else if (nStartPatIndex == 9)
						{
							nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[vnPosIndex[0]];
						}
						else
						{
							nTempStartPatIndex = 0;
						}
						nTempEndPatIndex = TARGETCANDIDATENUM-1;

						int j = 0;
						for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
						{
							if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
							{
								continue;
							}

							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								m_vnTargetSearchStartPatIndex[nPosIndex] = j;
								m_vnTargetSearchEndPatIndex[nPosIndex] = j;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
							if (bSearchSucceed)
							{
								break;
							}
						}
					}
					else
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
							{
								nTempStartPatIndex = nStartPatIndex;
							}
							else if (nStartPatIndex == 9)
							{
								nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
							}
							else
							{
								nTempStartPatIndex = 0;
							}
							nTempEndPatIndex = TARGETCANDIDATENUM-1;

							m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
							m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
				}
				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}
		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		vnHomoPosIndex = vnPosIndex;

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
	}
	else
	{
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
	}
	//	ShowExtraGuiToDisplay(vnPosIndex, TRUE,0);
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		if(m_bTargetSearchTest) ReportGetTargetImagePosFGTP(FALSE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(FALSE, FALSE);
		return FALSE;
	}

	// 5. 设置对位工具
	m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}
		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	if(m_pAlignerTool == NULL)
	{
		if(m_bObjectSearchTest)ReportGetTargetImagePosFGTP(FALSE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	if (bSearchSucceed)
	{
		for (int i=0;i<vnPosIndex.size();i++)
		{
			nPosIndex = vnPosIndex.at(i);
			vImagePos.push_back(m_mpTargetMarkImagePos.GetMarkImagePos(nPosIndex));
			vPlatformXYDAxisPos.push_back(*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex)));
		}
		if(m_bTargetSearchTest)ReportGetTargetImagePosFGTP(TRUE,vnPosIndex,vImagePos,vPlatformXYDAxisPos);
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return TRUE;
	}
	return FALSE;
}

BOOL vcXYDVisionAlign::SerialCameraCalibAlignerTargetSearch(std::vector<int> vnCalibPos)
{

	std::vector<int> vnPosIndex;
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		for (int i=0;i<GetPosNum()/2;i++)
		{
			vnPosIndex.push_back(i);
		}
		// 隐藏结果图形
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// 		//if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		// SY
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		// 		//HideExtraGraphics(vnPosIndex);
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);

		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);

		for (int i=0;i<GetPosNum()/2;i++)
		{
			vnPosIndex.push_back(i+GetPosNum()/2);
		}
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//HideExtraGraphics(vnAllPosIndex);
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}
	else
	{
		for (int i=0;i<GetPosNum();i++)
		{
			vnPosIndex.push_back(i);
		}

		// 隐藏结果图形
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// 		//if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		// SY
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		//HideExtraGraphics(vnPosIndex);

		// 隐藏目标定位结果十字，目标2/3图像
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);

		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//HideExtraGraphics(vnPosIndex);
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}



	if (GetCalibTargetMarkPatternMode() == eDmCodeCalib)
	{
		return SerialCameraCalibAlignerTargetSearchExDmCode(vnCalibPos);
	}
	else
	{
		return SerialCameraCalibAlignerTargetSearchEx(vnCalibPos);
	}
}
BOOL vcXYDVisionAlign::SingleCameraCalibAlignerTargetSearchEx(int nPosIndex)
{

	PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,FALSE);
	if (GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point)
	{
		if (nPosIndex < 0 || nPosIndex >= GetPosNum())
		{
			return FALSE;
		}

		scDegree tempDegree[2]={scDegree(45),scDegree(0)};
		COLORREF lineColor[2]={RGB(255,0,0),RGB(0,0,255)};
		for (int nMovePosIndex = 0;nMovePosIndex<2;nMovePosIndex++)
		{		
			if (TRUE == SingleCameraCalibAlignerTargetSearchExFTGT(nPosIndex, nMovePosIndex))
			{				
				if (nMovePosIndex < m_vpmpCalibMarkImagePos.size()
					&& TRUE == m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetIsMarkImagePosOK(nPosIndex))
				{
					CCoordPos pos;
					pos =  m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetMarkImagePos(nPosIndex);
					CGuiGraphics* tempDmCodeGraphics = m_vpGuiCalibrateGraphics.at(nPosIndex);

					if(nMovePosIndex == 0)
					{
						tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetCenterRotationLengths(
							sc2Vector(pos.GetAuxiliaryPosX(0),pos.GetAuxiliaryPosY(0)),tempDegree[nMovePosIndex],100,100);

						tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex+2)->SetCenterRotationLengths(
							sc2Vector(pos.GetAuxiliaryPosX(1),pos.GetAuxiliaryPosY(1)),tempDegree[nMovePosIndex],100,100);
					}
					else if(nMovePosIndex == 1)
					{
						tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetCenterRotationLengths(
							sc2Vector(pos.GetAuxiliaryPosX(2),pos.GetAuxiliaryPosY(2)),tempDegree[nMovePosIndex],100,100);

						tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex+2)->SetCenterRotationLengths(
							sc2Vector(pos.GetAuxiliaryPosX(3),pos.GetAuxiliaryPosY(3)),tempDegree[nMovePosIndex],100,100);
					}

					tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetLineWidth(2);
					tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetLineColor(lineColor[nMovePosIndex]);
					tempDmCodeGraphics->m_vbShowObjectCoordCross.at(nMovePosIndex) = TRUE;

					tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex+2)->SetLineWidth(2);
					tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex+2)->SetLineColor(lineColor[nMovePosIndex]);
					tempDmCodeGraphics->m_vbShowObjectCoordCross.at(nMovePosIndex+2) = TRUE;
				}
			}
			else
			{
				return FALSE;
			}
		}
		PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,TRUE);
		return TRUE;

	}
	else
	{
		if (nPosIndex < 0 || nPosIndex >= GetPosNum())
		{
			return FALSE;
		}

		scDegree tempDegree[2]={scDegree(45),scDegree(0)};
		COLORREF lineColor[2]={RGB(255,0,0),RGB(0,0,255)};
		for (int nMovePosIndex = 0;nMovePosIndex<2;nMovePosIndex++)
		{		
			if (TRUE == SingleCameraCalibAlignerTargetSearchExFTGT(nPosIndex, nMovePosIndex))
			{				
				if (nMovePosIndex < m_vpmpCalibMarkImagePos.size()
					&& TRUE == m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetIsMarkImagePosOK(nPosIndex))
				{
					CCoordPos pos;
					pos =  m_vpmpCalibMarkImagePos.at(nMovePosIndex)->GetMarkImagePos(nPosIndex);
					CGuiGraphics* tempDmCodeGraphics = m_vpGuiCalibrateGraphics.at(nPosIndex);
					tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetCenterRotationLengths(
						sc2Vector(pos.GetPosX(),pos.GetPosY()),tempDegree[nMovePosIndex],100,100);
					tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetLineWidth(2);
					tempDmCodeGraphics->m_vGuiObjectCoordCross.at(nMovePosIndex)->SetLineColor(lineColor[nMovePosIndex]);
					tempDmCodeGraphics->m_vbShowObjectCoordCross.at(nMovePosIndex) = TRUE;
				}
			}
			else
			{
				return FALSE;
			}
		}
		PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,TRUE);
		return TRUE;
	}
	return TRUE;

}
BOOL vcXYDVisionAlign::SerialCameraCalibAlignerTargetSearchEx(std::vector<int> vnCalibPos)
{
	//if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
	CString strCmd = _T("");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if(!CheckVisionASMConfig(strCmd) || !CheckPlatformInfo(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		return FALSE;
	}

	// 通信是否正常
	//if (FALSE == m_bValidComm)
	if(!CheckCommuciationValid(strCmd))
	{
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE; 
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;
	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}    	
	}

	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_IS_SEARCHING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	for (int i=0;i<vnCalibPos.size();i++)
	{
		int nCalibPos=vnCalibPos.at(i);
		PostMessageUpdateGuiCalibrateTargetGraphics(nCalibPos,FALSE);
	}

	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableCalibTargetSearchShutter(0);
		BOOL bCalibTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		int nPosNum = vnCalibPos.size();
		if (SystempOptionSearchShutter  && bCalibTargetShutter)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eCalibTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType,0))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = _T("切换关联模板曝光失败");
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	if (sysPlatformInfo.m_bTarObjCamSepNoAxisCalib == TRUE)
	{
		// 不用取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	}
	else
	{
		// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
		CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

		BOOL bGetPlatformAxis = FALSE;

		if(m_pPlatformInfo->m_bEnableKeyenceCode)
		{
			bGetPlatformAxis = CommuciateGetPlatformAxisAbsPosEx(pPlatformAxisPos);
		}
		else
		{
			bGetPlatformAxis = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		if (FALSE ==bGetPlatformAxis )
		{
			if (pPlatformAxisPos!=NULL)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;					
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));	
			return FALSE;
		}
		else
		{
			for (int i=0;i<vnCalibPos.size();i++)
			{
				int nCalibPos=vnCalibPos.at(i);
				SetTargetPlatformPos(pPlatformAxisPos, nCalibPos);	
				SetTempTargetPlatformAxisPos(nCalibPos,pPlatformAxisPos);
			}

			if (NULL != GetTotalProuductData())
			{
				SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
			}

			// 记录当前平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				CString strInfo;
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
				strInfo = strTemp + strInfo;
				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			if (pPlatformAxisPos)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;
			}
		}
	}

	// 标定用定位工具是否正常 
	if (m_bValidCalibTargetSearchTool!=TRUE)
	{

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{			
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{			
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}
	std::vector<SearchMode> vsmSearchMode;
	std::vector<int> vnPosIndex;

	for (int i=0;i<vnCalibPos.size();i++)
	{
		int nCalibPos=vnCalibPos.at(i);
		vnPosIndex.push_back(nCalibPos);
		vsmSearchMode.push_back(eAutoCalibTargetSearch);
	}

	if (!SnapSearchImage(vnCalibPos))
	{
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SNAP_IMAGE_FAIL);
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	CString strInfo;
	//if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() != TRUE)
	//{
	//	strInfo=_T("搜索失败");
	//	m_bStatusBar = FALSE;
	//	m_strStatusBarInfo1 = strInfo ;
	//	m_strStatusBarInfo2 = _T("请开启关联模板");
	//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	//	return FALSE;
	//}
	//
	//if (GetCalibTargetMarkPatternMode() == eSinglePatternSingleMark)
	//{
	//	strInfo=_T("搜索失败");
	//	m_bStatusBar = FALSE;
	//	m_strStatusBarInfo1 = strInfo ;
	//	m_strStatusBarInfo2 = _T("请使用其他关联方式");
	//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	//	return FALSE;
	//}

	if (!SearchMark(vnPosIndex,vsmSearchMode))
	{
		strInfo=GetSysInfoString(m_psaSysInfoStrings,IDS_STR_POS);
		for (int i=0;i<vnPosIndex.size();i++)
		{
			if (!m_vbSearchSucceed[vnPosIndex.at(i)])
			{
				CString tempInfo;
				tempInfo.Format(_T("%d "),vnPosIndex.at(i)+1);
				strInfo+=tempInfo;
			}
		}
		strInfo+=GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SEARCH_FAIL);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_CALIB_TARGET_SEARCH_FAIL);
		m_strStatusBarInfo2 = strInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eAutoCalibTargetSearch);
			ExeSaveVDBFile(vnPosIndex,eAutoCalibTargetSearch);
		}
		return FALSE;
	}
	else
	{

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_CALIB_TARGET_SEARCH_SUCCESS);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eAutoCalibTargetSearch);
			ExeSaveVDBFile(vnPosIndex,eAutoCalibTargetSearch);
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::SingleCameraCalibAlignerTargetSearchExDmCode(int nCalibPos)
{
	CString strCmd = _T("");
	CString strTempWarningType = _T("");
	if(!CheckVisionASMConfig(strCmd) || !CheckPlatformInfo(strCmd) || !CheckAlignerSearchTool(strCmd) || !CheckCommuciation(strCmd))
	{
		return FALSE;
	}

	// 通信是否正常
	if(!CheckCommuciationValid(strCmd))
	{
		return FALSE; 
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;
	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}    	
	}

	// 	CString strOutLog;
	// 	strOutLog.Format(_T("----------------------------位置%d二维码搜索开始------------------------------"),nCalibPos);
	// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{			
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		// 		strOutLog.Format(_T("产品不存在"));
		// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
		// 
		// 		strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
		// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

		return FALSE;
	}

	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{			
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

		// 		strOutLog.Format(_T("产品不存在"));
		// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
		// 
		// 		strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
		// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

		return FALSE;
	}

	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_IS_SEARCHING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	PostMessageUpdateGuiCalibrateTargetGraphics(nCalibPos,FALSE);

	// 	strOutLog.Format(_T("隐藏搜索图形成功"));
	// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

	int nCamPos = m_pPlatformInfo->m_nPositionNum;


	//////////////////////////////////////// 平台标定/////////////////////////////////////////////

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	// 1. 获取当前轴位置
	if (sysPlatformInfo.m_bTarObjCamSepNoAxisCalib == TRUE)
	{
		// 不用取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	}
	else
	{
		// 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
		CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

		if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
		{
			if (pPlatformAxisPos!=NULL)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			// 			strOutLog.Format(_T("获取平台轴位置失败"));
			// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
			// 			strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
			// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);


			return FALSE;
		}
		else
		{
			SetTargetPlatformPos(pPlatformAxisPos, nCalibPos);		

			// 记录当前平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				CString strInfo;
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
				strInfo = strTemp + strInfo;
				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);

			}

			if (pPlatformAxisPos)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;
			}
		}
	}

	// 	strOutLog.Format(_T("获取平台轴位置成功"));
	// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);


	// 2. 设置二维码参数信息
	scDMCodeParam DmCodeParam;
	DmCodeParam = pCurProductData->m_vDMcodeCalib.at(nCalibPos);
	m_vDmCodeCalibTool.at(nCalibPos).SetDmCodeParam(DmCodeParam);

	// 	strOutLog.Format(_T("二维码搜索参数设置成功"));
	// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);


	// 3. 设置图像
	EnterCriticalSection(&m_vcsResource.at(nCalibPos));
	m_vImageSearch[nCalibPos] = m_vImageInput[nCalibPos];
	LeaveCriticalSection(&m_vcsResource.at(nCalibPos));

	// 	strOutLog.Format(_T("获取搜索图像成功"));
	// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

	// 4. 二维码图像定位
	CString strInfo;
	if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE)
	{
		m_vDmCodeCalibTool.at(nCalibPos).SetSearchImage(m_vImageSearch[nCalibPos]);

		if (!m_vDmCodeCalibTool.at(nCalibPos).SearchDmCode())
		{
			strInfo.Format(_T("%s"),m_vDmCodeCalibTool.at(nCalibPos).GetErrorString());

			// 			strOutLog.Format(_T("搜索失败：%s"),strInfo);
			// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
			m_strStatusBarInfo2 = strInfo;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			// 			strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
			// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

			if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
			{
				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

				m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;		

				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
						nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
				}

				CString strPath = m_strDataRecord + _T("\\AlignTool");
				SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));
				//				SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));

				if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
				}
			}	

			return FALSE;
		}
		else
		{
			if (m_vDmCodeCalibTool.at(nCalibPos).GetCornersNum() < 2)
			{
				// 				strInfo = _T("角点个数少于2个");
				// 				strOutLog.Format(_T("搜索失败：%s"),strInfo);
				// 				VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
				m_strStatusBarInfo2 = strInfo;
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				// 				strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
				// 				VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

				if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
				{
					SYSTEMTIME sys; 
					GetLocalTime(&sys); 
					m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

					m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;	

					if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
					{
						m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
							nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
					}

					CString strPath = m_strDataRecord + _T("\\AlignTool");
					SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));
					//					SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));

					if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
					{
						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
					}
				}	

				return FALSE;
			}

			Code2DResult tmpResult;
			m_vDmCodeCalibTool.at(nCalibPos).GetDmCodeResult(tmpResult);
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_CORNERS),m_vDmCodeCalibTool.at(nCalibPos).GetCornersNum()
				,tmpResult.m_CodeString);

			// 			strOutLog.Format(_T("搜索成功：%s"),strInfo);
			// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_SUCCESS);
			m_strStatusBarInfo2 = strInfo;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


			PostMessageUpdateGuiCalibrateTargetGraphics(nCalibPos,TRUE);

			// 			strOutLog.Format(_T("显示搜索结果成功"));
			// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
			// 
			// 			strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
			// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

// 			if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage && m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo
// 				&& m_pVisionASMConfig->m_DataRecord.m_bCommunication)
			if (m_pVisionASMConfig->m_DataRecord.m_bSaveAllImage)
			{
				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearch.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);

				m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) + 1;		

				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearch-CH%02d-%03d.bmp"), 
						nCalibPos,m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos));
				}

				CString strPath = m_strDataRecord + _T("\\AlignTool");
				SaveImage(nCalibPos,m_vImageSearch[nCalibPos], strPath + _T("\\") + m_vstrTemp.at(nCalibPos));
				//				SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));

				if(m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) = 0;
				}
			}	

		}
	}
	else
	{
		strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_STR_PLEASE_OPEN_CALIB_TARGET));
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
		m_strStatusBarInfo2 = strInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		// 		strOutLog.Format(_T("未开启关联模板"));
		// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
		// 
		// 		strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
		// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);

		return FALSE;
	}

	return TRUE;
}

// BOOL vcXYDVisionAlign::SingleCameraCalibAlignerTargetSearchExDmCode(int nCalibPos)
// {
// 	CString strCmd = _T("");
// 	CString strTempWarningType = _T("");
//     //if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
//     if(!CheckVisionASMConfig(strCmd) || !CheckPlatformInfo(strCmd) || !CheckAlignerSearchTool(strCmd) || !CheckCommuciation(strCmd))
//     {
//         return FALSE;
//     }
// 
//     // 通信是否正常
//     //if (FALSE == m_bValidComm)
//     if(!CheckCommuciationValid(strCmd))
//     {
// //         m_bStatusBar = FALSE;
// //         m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// //         m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// //         SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 		PostMessageUpdateStatusBarInfo();
// 
//         return FALSE; 
//     }
// 
//     int nCamNum = m_pPlatformInfo->m_nCamNum;
//     int i=0;
//     for(i=0; i<nCamNum; i++)
//     {		 
//         if (FALSE == m_vbCameraLiveGrab[i])
//         {      
//             m_bStatusBar = FALSE;
//             m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
// //             m_strStatusBarInfo2 = _T("");
// //             SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 			PostMessageUpdateStatusBarInfo();
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
// 			CString strTemp = _T("");
// 			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
// 			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
// 			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
//             return FALSE;
//         }    	
//     }
// 
//     // 标定开始    
//     m_bStatusBar = TRUE;
//     m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_IS_SEARCHING);
//     m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
//     SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 	CString strOutLog;
// 	strOutLog.Format(_T("----------------------------位置%d二维码搜索开始------------------------------"),nCalibPos);
// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 	PostMessageUpdateGuiCalibrateTargetGraphics(nCalibPos,FALSE);
// 
// 	strOutLog.Format(_T("隐藏搜索图形成功"));
// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
//     int nCamPos = m_pPlatformInfo->m_nPositionNum;
// 
// 
//     //////////////////////////////////////// 平台标定/////////////////////////////////////////////
// 
//     SysPlatformInfo sysPlatformInfo;
//     GetSysPlatformInfo(sysPlatformInfo);
// 
//     if (sysPlatformInfo.m_bTarObjCamSepNoAxisCalib == TRUE)
//     {
//         // 不用取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
//     }
//     else
//     {
//         // 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
//         CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
// 
//         if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
//         {
//             if (pPlatformAxisPos!=NULL)
//             {
//                 delete pPlatformAxisPos;
//                 pPlatformAxisPos = NULL;					
//             }
//             m_bStatusBar = FALSE;
//             m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
//             m_strStatusBarInfo2 = _T("");
//             SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 			strOutLog.Format(_T("获取平台轴位置失败"));
// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 			strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 
//             return FALSE;
//         }
//         else
//         {
//             SetTargetPlatformPos(pPlatformAxisPos, nCalibPos);		
// 
//             // 记录当前平台各个轴的绝对位置
//             if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
//             {
//                 CString strTemp;
//                 CString strInfo;
//                 strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
//                 strInfo = strTemp + strInfo;
//                 VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
//                 VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 				////GYM-关联日志存储
// 				CString strCorrelationLogPath;
// 				SysPlatformInfo sysPlatformInfo;
// 				GetSysPlatformInfo(sysPlatformInfo);
// 
// 
// 				/*strCorrelationLogPath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 				m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex()+1);*/
// 
// 				vcBaseAlignTool* tmpAlignTool = GetAlignTool();
// 				CString StrTmp = _T("");
// 				if (tmpAlignTool !=NULL)
// 				{
// 					if (sysPlatformInfo.m_bProductFaChd)
// 					{
// 						int nCurProductIndexFa;
// 						int nCurProductIndexCh;
// 						m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 						StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 							nCurProductIndexFa+1,nCurProductIndexCh+1);
// 					}
// 					else
// 					{
// 						StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 							m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 					}
// 					
// 				}
// 				
// 				strCorrelationLogPath= StrTmp;
// 
// 				strInfo.Empty();
// 				strTemp.Format(_T("......关联时在位置%d拍照时的平台轴位置: X: %.2f; Y: %.2f; D: %.2f;\n"),nCalibPos+1,pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 				strInfo += strTemp;
// 				CorrelationMoveAxisAngle.push_back(pPlatformAxisPos->m_dAngle);
// 				VisionAlignLogRecord(strCorrelationLogPath,strInfo,FALSE);
// 				///GYM
// 
//             }
// 
//             if (pPlatformAxisPos)
//             {
//                 delete pPlatformAxisPos;
//                 pPlatformAxisPos = NULL;
//             }
//         }
//     }
// 
// 	strOutLog.Format(_T("获取平台轴位置成功"));
// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
//     int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 
//     CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
//     if (pCurProductData == NULL)
//     {			
//         m_bStatusBar = FALSE;
//         m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
//         m_strStatusBarInfo2 = _T("");
//         SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
// 
// 		strOutLog.Format(_T("产品不存在"));
// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 		strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
//         return FALSE;
//     }
// 
// 	scDMCodeParam DmCodeParam;
// 	DmCodeParam = pCurProductData->m_vDMcodeCalib.at(nCalibPos);
// 	m_vDmCodeCalibTool.at(nCalibPos).SetDmCodeParam(DmCodeParam);
// 
// 	strOutLog.Format(_T("二维码搜索参数设置成功"));
// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 
//           // 设置图像
//     EnterCriticalSection(&m_vcsResource.at(nCalibPos));
//     m_vImageSearch[nCalibPos] = m_vImageInput[nCalibPos];
//     LeaveCriticalSection(&m_vcsResource.at(nCalibPos));
// 
// 	strOutLog.Format(_T("获取搜索图像成功"));
// 	VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 	if (m_vImageSearch[nCalibPos].IsValid())
// 	{
// 		scDIB cDIB;
// 		HStatus hStatus;
// 		hStatus = cDIB.Init(m_vImageSearch[nCalibPos]);
// 		if (IsSuccess(hStatus))
// 		{
// 			CString strPath;
// // 			strPath.Format(_T("D:\\DmCodeCalibrateImage\\Pos%dDmCodeImage.bmp"),nCalibPos);
// // 			hStatus = cDIB.Write(strPath);
// 
// 			//二维码关联图像记录
// 			CString strDir;
// 			CFileFind findFile;
// 			BOOL IsFild, IsDir;
// 			IsFild = FALSE;
// 			IsDir = FALSE;
// 			SysPlatformInfo sysPlatformInfo;
// 			GetSysPlatformInfo(sysPlatformInfo);
// 			strDir.Format(_T("D:\\VisionASMLog"));
// 			IsFild = findFile.FindFile(strDir);
// 			while (IsFild)
// 			{
// 				IsFild = findFile.FindNextFile();
// 				IsDir = findFile.IsDirectory();
// 				if(IsDir) break;
// 			}	
// 			if (!IsDir)
// 			{
// 				if (!CreateDirectory(strDir, NULL))// 创建文件夹
// 				{
// 
// 					return FALSE;
// 				}
// 			}
// 			IsDir = FALSE;
// 			strDir.Format(_T("D:\\VisionASMLog\\工位%d"),sysPlatformInfo.m_nPlatformIndex+1);
// 			IsFild = findFile.FindFile(strDir);
// 			while (IsFild)
// 			{
// 				IsFild = findFile.FindNextFile();
// 				IsDir = findFile.IsDirectory();
// 				if(IsDir) break;
// 			}	
// 			if (!IsDir)
// 			{
// 				if (!CreateDirectory(strDir, NULL))// 创建文件夹
// 				{
// 
// 					return FALSE;
// 				}
// 			}
// 			IsDir = FALSE;
// 			strDir.Format(_T("D:\\VisionASMLog\\工位%d\\品种%03d"),sysPlatformInfo.m_nPlatformIndex+1,m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex()+1);
// 			IsFild = findFile.FindFile(strDir);
// 			while (IsFild)
// 			{
// 				IsFild = findFile.FindNextFile();
// 				IsDir = findFile.IsDirectory();
// 				if(IsDir) break;
// 			}	
// 			if (!IsDir)
// 			{
// 				if (!CreateDirectory(strDir, NULL))// 创建文件夹
// 				{
// 
// 					return FALSE;
// 				}
// 			}
// 			IsDir = FALSE;
// 			strDir.Format(_T("D:\\VisionASMLog\\工位%d\\品种%03d\\关联存图"),sysPlatformInfo.m_nPlatformIndex+1,m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex()+1);
// 			IsFild = findFile.FindFile(strDir);
// 			while (IsFild)
// 			{
// 				IsFild = findFile.FindNextFile();
// 				IsDir = findFile.IsDirectory();
// 				if(IsDir) break;
// 			}	
// 			if (!IsDir)
// 			{
// 				if (!CreateDirectory(strDir, NULL))// 创建文件夹
// 				{
// 
// 					return FALSE;
// 				}
// 			}
// 
// 
// 
// 			strPath.Format(_T("D:\\VisionASMLog\\工位%d\\品种%03d\\关联存图\\Pos%dDmCodeImage.bmp"),sysPlatformInfo.m_nPlatformIndex+1,
// 				m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex()+1,nCalibPos);
// 			hStatus = cDIB.Write(strPath);
// 			//
// 		}		
// 	}
// 
//     CString strInfo;
//     if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE)
//     {
//         m_vDmCodeCalibTool.at(nCalibPos).SetSearchImage(m_vImageSearch[nCalibPos]);
//         if (!m_vDmCodeCalibTool.at(nCalibPos).SearchDmCode())
//         {
//             strInfo.Format(_T("%s"),m_vDmCodeCalibTool.at(nCalibPos).GetErrorString());
// 
// 			strOutLog.Format(_T("搜索失败：%s"),strInfo);
// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
//             m_bStatusBar = FALSE;
//             m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
//             m_strStatusBarInfo2 = strInfo;
//             SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 			strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 			if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
// 			{		
// 				CTime t = CTime::GetCurrentTime();	
// 				m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 				SYSTEMTIME sys; 
// 				GetLocalTime(&sys); 
// 				m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 				m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
// 				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 				{
// 					m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
// 						nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
// 				}
// 				/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 				m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 				SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 				if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 				{
// 					m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
// 				}
// 			}	
// 
//             return FALSE;
//         }
//         else
//         {
// 			if (m_vDmCodeCalibTool.at(nCalibPos).GetCornersNum() < 2)
// 			{
// 				strInfo = _T("角点个数少于2个");
// 				strOutLog.Format(_T("搜索失败：%s"),strInfo);
// 				VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
// 				m_strStatusBarInfo2 = strInfo;
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 				strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
// 				VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 				if (m_pVisionASMConfig->m_DataRecord.m_bImgData)
// 				{		
// 					CTime t = CTime::GetCurrentTime();	
// 					m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 						t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 					SYSTEMTIME sys; 
// 					GetLocalTime(&sys); 
// 					m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearchFailed.bmp"),
// 						sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 					m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) + 1;																			
// 					if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 					{
// 						m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearchFailed-CH%02d-%03d.bmp"), 
// 							nCalibPos,m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos));
// 					}
// 					/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 					m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 					SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 					if(m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 					{
// 						m_vSaveAlignerCalibTargetSearchImageFailIndex.at(nCalibPos) = 0;
// 					}
// 				}	
// 
// 				return FALSE;
// 			}
// 
//             Code2DResult tmpResult;
//             m_vDmCodeCalibTool.at(nCalibPos).GetDmCodeResult(tmpResult);
//             strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_CORNERS),m_vDmCodeCalibTool.at(nCalibPos).GetCornersNum()
//                 ,tmpResult.m_CodeString);
// 
// 			strOutLog.Format(_T("搜索成功：%s"),strInfo);
// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
//             m_bStatusBar = TRUE;
//             m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_SUCCESS);
//             m_strStatusBarInfo2 = strInfo;
//             SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 
// 			PostMessageUpdateGuiCalibrateTargetGraphics(nCalibPos,TRUE);
// 
// 			strOutLog.Format(_T("显示搜索结果成功"));
// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 			strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
// 			VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 			if (m_pVisionASMConfig->m_DataRecord.m_bImgData && m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo
// 				&& m_pVisionASMConfig->m_DataRecord.m_bCommunication)
// 			{		
// 				CTime t = CTime::GetCurrentTime();	
// 				m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageCalibTargetSearch.bmp"),
// 					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nCalibPos);
// 
// 				SYSTEMTIME sys; 
// 				GetLocalTime(&sys); 
// 				m_vstrTemp.at(nCalibPos).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageCalibTargetSearch.bmp"),
// 					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nCalibPos);
// 
// 				m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) = m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) + 1;																			
// 				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
// 				{
// 					m_vstrTemp.at(nCalibPos).Format(_T("ImageCalibTargetSearch-CH%02d-%03d.bmp"), 
// 						nCalibPos,m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos));
// 				}
// 				/*m_vDibTemp.at(nCalibPos).Init(m_vImageSearch[nCalibPos]);
// 				m_vDibTemp.at(nCalibPos).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));*/
// 				SaveImage(nCalibPos,m_vImageSearch[nCalibPos],m_strDataRecord + _T("\\") + m_vstrTemp.at(nCalibPos));
// 				if(m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
// 				{
// 					m_vSaveAlignerCalibTargetSearchImageIndex.at(nCalibPos) = 0;
// 				}
// 			}	
// 
//         }
//     }
//     else
//     {
//         strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_STR_PLEASE_OPEN_CALIB_TARGET));
//         m_bStatusBar = FALSE;
//         m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
//         m_strStatusBarInfo2 = strInfo;
//         SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		strOutLog.Format(_T("未开启关联模板"));
// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
// 
// 		strOutLog.Format(_T("----------------------------位置%d二维码搜索结束------------------------------"),nCalibPos);
// 		VisionAlignLogRecord(_T("D:\\DmCodeCalibrateProcess.txt"), strOutLog);
//         return FALSE;
//     }
//     return TRUE;
// }


BOOL vcXYDVisionAlign::SerialCameraCalibAlignerTargetSearchExDmCode(std::vector<int> vnCalibPos)
{
	CString strCmd = _T("");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	//if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
	if(!CheckVisionASMConfig(strCmd) || !CheckPlatformInfo(strCmd) || !CheckAlignerSearchTool(strCmd) || !CheckCommuciation(strCmd))
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// 通信是否正常
	//if (FALSE == m_bValidComm)
	if(!CheckCommuciationValid(strCmd))
	{
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE; 
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;
	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}    	
	}

	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_IS_SEARCHING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	for (int i=0;i<vnCalibPos.size();i++)
	{
		int nCalibPos=vnCalibPos.at(i);
		PostMessageUpdateGuiCalibrateTargetGraphics(nCalibPos,FALSE);
	}


	int nCamPos = m_pPlatformInfo->m_nPositionNum;


	{
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		int nPosNum = vnCalibPos.size();
		if (SystempOptionSearchShutter)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eDmCodeSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = _T("切换二维码曝光失败");
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	if (sysPlatformInfo.m_bTarObjCamSepNoAxisCalib == TRUE)
	{
		// 不用取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	}
	else
	{
		// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
		CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

		BOOL bGetPlatformAxis = FALSE;
		if(m_pPlatformInfo->m_bEnableKeyenceCode)
		{
			bGetPlatformAxis = CommuciateGetPlatformAxisAbsPosEx(pPlatformAxisPos);
		}
		else
		{
			bGetPlatformAxis = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		if (FALSE ==bGetPlatformAxis )
		{
			if (pPlatformAxisPos!=NULL)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;					
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		else
		{
			for (int i=0;i<vnCalibPos.size();i++)
			{
				int nCalibPos=vnCalibPos.at(i);
				SetTargetPlatformPos(pPlatformAxisPos, nCalibPos);	
				SetTempTargetPlatformAxisPos(nCalibPos,pPlatformAxisPos);
			}

			if (NULL != GetTotalProuductData())
			{
				SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
			}


			// 记录当前平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				CString strInfo;
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
				strInfo = strTemp + strInfo;
				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			if (pPlatformAxisPos)
			{
				delete pPlatformAxisPos;
				pPlatformAxisPos = NULL;
			}
		}
	}

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{			
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
		return FALSE;
	}

	scDMCodeParam DmCodeParam;
	for (int i=0;i<vnCalibPos.size();i++)
	{
		int nCalibPos=vnCalibPos.at(i);
		DmCodeParam = pCurProductData->m_vDMcodeCalib.at(nCalibPos);
		m_vDmCodeCalibTool.at(nCalibPos).SetDmCodeParam(DmCodeParam);
	}


	if (!SnapSearchImage(vnCalibPos))
	{
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SNAP_IMAGE_FAIL);
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}
	CString strInfo;
	if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE)
	{
		std::vector<SearchMode> vsmSearchMode;
		std::vector<int> vnPosIndex;

		for (int i=0;i<vnCalibPos.size();i++)
		{
			int nCalibPos=vnCalibPos.at(i);
			vnPosIndex.push_back(nCalibPos);
			vsmSearchMode.push_back(eAutoCalibTargetSearch);
		}

		if (!SearchMark(vnPosIndex,vsmSearchMode))
		{
			strInfo=GetSysInfoString(m_psaSysInfoStrings,IDS_STR_POS);
			for (int i=0;i<vnPosIndex.size();i++)
			{
				if (!m_vbSearchSucceed[vnPosIndex.at(i)])
				{
					CString tempInfo;
					tempInfo.Format(_T("%d "),vnPosIndex.at(i)+1);
					strInfo+=tempInfo;
				}
			}
			strInfo+=GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SEARCH_FAIL);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
			m_strStatusBarInfo2 = strInfo;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
			{
				//PostMessageSaveVDBFile(vnPosIndex,eAutoCalibTargetSearch);
				ExeSaveVDBFile(vnPosIndex,eAutoCalibTargetSearch);
			}
			return FALSE;
		}
		else
		{

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_SUCCESS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
			{
				//PostMessageSaveVDBFile(vnPosIndex,eAutoCalibTargetSearch);
				ExeSaveVDBFile(vnPosIndex,eAutoCalibTargetSearch);
			}
		}
	}
	else
	{
		strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_STR_PLEASE_OPEN_CALIB_TARGET));
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
		m_strStatusBarInfo2 = strInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}
	return TRUE;
}
// 当目标相机和对象相机是独立时2对4方案中，通过靶标标定目标位置4、位置5相机时，进行目标Mark定位搜索
BOOL vcXYDVisionAlign::SingleCameraCalibBoardAlignerTargetSearchExFTGT(int nCalibPos, int nMoveIndex)
{
	//if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
	CString strCmd = _T("");	//此为关联函数，没有指令，格式统一，指令为空
	CString strTempWarningType = _T("");
	if(!CheckVisionASMConfig(strCmd) || !CheckPlatformInfo(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		//ReportCalibResult(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (nMoveIndex < 0 || nMoveIndex >= m_vpmpCalibMarkImagePos.size())
	{
		return FALSE;
	}

	// 通信是否正常
	//if (FALSE == m_bValidComm)
	if(!CheckCommuciationValid(strCmd))
	{
		//ReportCalibResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE; 
	}

	// 	// 标定用定位工具是否正常 
	// 	if (m_bValidTargetSearchTool!=TRUE)
	// 	{
	// 		//ReportCalibResult(FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
	// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 		return FALSE;
	// 	}

	// 相机是否处于连续采集状态
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	// 	if (nCamNum!=1)
	// 	{
	// 		ReportCalibResult(FALSE);
	// 		return FALSE;
	// 	}	
	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			//ReportCalibResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}    	
	}

	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	int nCamPos = m_pPlatformInfo->m_nPositionNum;

	//////////////////////////////////////// 平台标定/////////////////////////////////////////////

	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	// 	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	// 
	// 	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	// 	{
	// 		if (pPlatformAxisPos!=NULL)
	// 		{
	// 			delete pPlatformAxisPos;
	// 			pPlatformAxisPos = NULL;					
	// 		}
	// 
	// 		//ReportCalibResult(FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
	// 		m_strStatusBarInfo2 = _T("");
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 		return FALSE;
	// 	}
	// 	else
	// 	{
	// 		SetTargetPlatformPos(pPlatformAxisPos, nCalibPos);		
	// 		// 
	// 		// 		if (m_CalibPlatformAxisAbsPos.size()<nCalibPos+1)
	// 		// 		{
	// 		// 			m_CalibPlatformAxisAbsPos.resize(nCalibPos+1);
	// 		// 		}
	// 		// 		m_CalibPlatformAxisAbsPos.at(nCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);
	// 
	// 		// 记录当前平台各个轴的绝对位置
	// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	// 		{
	// 			CString strTemp;
	// 			// 			CTime t = CTime::GetCurrentTime();
	// 			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
	// 
	// 			CString strInfo;
	// 			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
	// 			strInfo = strTemp + strInfo;
	// 
	// 			// 			FILE *stream;
	// 			// 			CString strPath = m_strAlignProcessData;
	// 			// 			stream = fopen(strPath, _T("a+t"));
	// 			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
	// 			// 			fclose(stream);VCRemoveFile(strPath);	
	// 
	// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	// 			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
	// 		}
	// 
	// 		if (pPlatformAxisPos)
	// 		{
	// 			delete pPlatformAxisPos;
	// 			pPlatformAxisPos = NULL;
	// 		}
	// 	}

	// 	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
	// 	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
	// 	vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nCalibPos);
	// 
	// 	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum())
	// 	{
	// 		ReportCalibResult(FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_EIGHT_PLATFORM_POS_FAILED);
	// 		m_strStatusBarInfo2 = _T("");
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 		return FALSE;
	// 	}
	// 	else
	// 	{
	// 		// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
	// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	// 		{
	// 			CString strTemp;
	// 			CTime t = CTime::GetCurrentTime();
	// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
	// 
	// 			CString strInfo;
	// 			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
	// 			strInfo = strTemp + strInfo;
	// 
	// 			CPlatformXYDAxisPos* pAxisPos;
	// 			for (int i=0; i<vpPlatformAxisPos.size(); i++)
	// 			{
	// 				strTemp.Empty();
	// 				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
	// 
	// 				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
	// 				strInfo = strInfo + strTemp;
	// 			}
	// 
	// 			FILE *stream;
	// 			CString strPath = m_strAlignProcessData;
	// 			stream = fopen(strPath, _T("a+t"));
	// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
	// 			fclose(stream);VCRemoveFile(strPath);				
	// 		}
	// 	}

	// 3. 驱动平台到位并定位
	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	std::vector<CMarkImagePos*> vpMarkImagePos;
	CMarkImagePos* pMarkImagePos = m_vpmpCalibMarkImagePos.at(nMoveIndex);
	if (pMarkImagePos == NULL)
	{
		return FALSE;
	}
	CCoordPos pos;
	pMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, pos);

	// 	int k=0;
	// 	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum() - 1; k++)
	{         
		//		//EnterCriticalSection(&m_csResource);
		// 		m_bStatusBar = TRUE;
		// 		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), nMoveIndex);
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		//		//LeaveCriticalSection(&m_csResource);

		//		pMarkImagePos = NULL;

		// 		// 驱动到位
		// 		pPlatformXYDAxisPos = NULL;
		// 		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);
		// 
		// 		if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
		// 		{
		// 			ReportCalibResult(FALSE);
		// 
		// 			m_bStatusBar = FALSE;
		// 			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), k) ;
		// 			m_strStatusBarInfo2 = _T("");
		// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		// 
		// 			return FALSE;
		// 		}


		{

			int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

			CameraParamEnable cameraParamEnable;
			cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex)->m_pAlignerParam->GetEnableCalibTargetSearchShutter(nMoveIndex);
			BOOL bCalibTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

			CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
			if (pCurProductData == NULL)
			{			
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;
			}

			BOOL bCalibTargetMarkEnable = pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable();

			if (SystempOptionSearchShutter && bCalibTargetShutter && bCalibTargetMarkEnable)
			{
				if (eDoublePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
				{
					SwitchToCalibTargetSearchShutter(nCalibPos,nMoveIndex);
				}
				else
				{
					SwitchToCalibTargetSearchShutter(nCalibPos);
				}

				Sleep(200);

				// 采集图像
				std::vector<int> vnPosIndex;
				vnPosIndex.push_back(nCalibPos);

				if (!SnapSearchImage(vnPosIndex))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = /*m_strStatusBarInfo2 + _T(",") + */m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
					AddWarningInfo(strTempWarningType, m_strStatusBarInfo2);	
					return FALSE;
				}

				Sleep(200);


			}
			else
			{
				// 设置图像
				EnterCriticalSection(&m_vcsResource.at(nCalibPos));
				m_vImageSearch[nCalibPos] = m_vImageInput[nCalibPos];
				LeaveCriticalSection(&m_vcsResource.at(nCalibPos));
			}

		}

		// 设置图像
		// 		EnterCriticalSection(&m_vcsResource.at(nCalibPos));
		// 		m_vImageSearch[nCalibPos] = m_vImageInput[nCalibPos];
		// 		LeaveCriticalSection(&m_vcsResource.at(nCalibPos));



		// 		// 执行定位
		// 		CCoordPos cp;
		// 		BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 0);
		// 		if(bSearchSucceed)
		// 		{			
		// 			m_vbSearchSucceed[nCalibPos] = TRUE;
		// 			m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,0);
		// 
		// 			cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
		// 			cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
		// 			cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
		// 			pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		// 
		// 			m_bStatusBar = TRUE;
		// 			m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
		// 			m_strStatusBarInfo1 = _T("");
		// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		// 		}
		// 		else
		// 		{
		// 			cp.m_dPosX  = 0;
		// 			cp.m_dPosY  = 0;
		// 			cp.m_dAngle = 0;
		// 			m_vbSearchSucceed[nCalibPos] =FALSE;
		// 			pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		// 			m_bStatusBar = FALSE;
		// 			m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
		// 			m_strStatusBarInfo1 = _T("");
		// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		// 			return FALSE;
		// 		}


		/*
		// 执行定位
		if (0 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{
		// 0：用目标模板关联标定目标位置，默认值
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 0);
		if(bSearchSucceed)
		{			
		m_vbSearchSucceed[nCalibPos] = TRUE;
		m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,0);

		cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
		cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
		cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
		cp.m_dPosX  = 0;
		cp.m_dPosY  = 0;
		cp.m_dAngle = 0;
		m_vbSearchSucceed[nCalibPos] =FALSE;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
		}

		}
		else if (1 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{

		// 1：用对象模板关联标定目标位置
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnObjectSearch(nCalibPos, 0);
		if(bSearchSucceed)
		{			
		m_vbSearchSucceed[nCalibPos] = TRUE;
		m_vSeachResults[nCalibPos] = GetAlnObjectSearchResult(nCalibPos,0);

		cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
		cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
		cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
		cp.m_dPosX  = 0;
		cp.m_dPosY  = 0;
		cp.m_dAngle = 0;
		m_vbSearchSucceed[nCalibPos] =FALSE;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
		}
		}
		// 执行定位
		else if (2 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{

		// 2：用目标模板候选模板1关联标定目标位置
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 1);
		if(bSearchSucceed)
		{			
		m_vbSearchSucceed[nCalibPos] = TRUE;
		m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,1);

		cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
		cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
		cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
		cp.m_dPosX  = 0;
		cp.m_dPosY  = 0;
		cp.m_dAngle = 0;
		m_vbSearchSucceed[nCalibPos] =FALSE;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
		}

		}
		else if (3 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{

		// 3：用对象模板候选模板1关联标定目标位置
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnObjectSearch(nCalibPos, 1);
		if(bSearchSucceed)
		{			
		m_vbSearchSucceed[nCalibPos] = TRUE;
		m_vSeachResults[nCalibPos] = GetAlnObjectSearchResult(nCalibPos,1);

		cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
		cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
		cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
		cp.m_dPosX  = 0;
		cp.m_dPosY  = 0;
		cp.m_dAngle = 0;
		m_vbSearchSucceed[nCalibPos] =FALSE;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
		}
		}
		// 执行定位
		else if (4 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{

		// 4：用目标模板候选模板1、候选模板2关联标定目标位置
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, nMoveIndex + 1);
		if(bSearchSucceed)
		{			
		m_vbSearchSucceed[nCalibPos] = TRUE;
		m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos, nMoveIndex + 1);

		cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
		cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
		cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
		cp.m_dPosX  = 0;
		cp.m_dPosY  = 0;
		cp.m_dAngle = 0;
		m_vbSearchSucceed[nCalibPos] =FALSE;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
		}

		}
		else if (5 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
		{

		// 5：用对象模板候选模板1、候选模板2关联标定目标位置
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnObjectSearch(nCalibPos, nMoveIndex + 1);
		if(bSearchSucceed)
		{			
		m_vbSearchSucceed[nCalibPos] = TRUE;
		m_vSeachResults[nCalibPos] = GetAlnObjectSearchResult(nCalibPos, nMoveIndex + 1);

		cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
		cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
		cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
		cp.m_dPosX  = 0;
		cp.m_dPosY  = 0;
		cp.m_dAngle = 0;
		m_vbSearchSucceed[nCalibPos] =FALSE;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
		}
		}
		else
		{
		// 用目标模板执行标定搜索
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 0);
		if(bSearchSucceed)
		{			
		m_vbSearchSucceed[nCalibPos] = TRUE;
		m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,0);

		cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
		cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
		cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索成功!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
		cp.m_dPosX  = 0;
		cp.m_dPosY  = 0;
		cp.m_dAngle = 0;
		m_vbSearchSucceed[nCalibPos] =FALSE;
		pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo2.Format(_T("标定目标搜索失败!"));
		m_strStatusBarInfo1 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
		}

		}
		*/

		// 获取当前产品信息
		int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

		if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
		{			
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}


		// 设置补偿量索引
		CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
		if (pCurProductData == NULL)
		{			
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}
		if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE)
		{
			// 标定用定位工具是否正常 
			if (m_bValidCalibTargetSearchTool!=TRUE)
			{
				//ReportCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			// 用关联标定模板执行标定搜索
			if (eSinglePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
			{
				// 用第0组关联标定模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
			}
			else if (eDoublePatternSingleMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
			{
				// 用第0、1组关联标定模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, nMoveIndex);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,nMoveIndex);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
			}
			else if (eSinglePatternMultiMark == pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode())
			{
				// 用第0组关联标定模板执行标定搜索，单模板双标记点
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnCalibTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnCalibTargetSearchResult(nCalibPos,0);

					int nTempMoveIndex = 0;
					CMarkImagePos* pTempMarkImagePos = NULL;
					CCoordPos posTemp;

					// 移动位置0或标记点0
					nTempMoveIndex = 0;
					pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
					if (pTempMarkImagePos == NULL)
					{
						return FALSE;
					}					
					pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					if (nMoveIndex == nTempMoveIndex)
					{
						pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					}

					// 移动位置1或标记点1
					nTempMoveIndex = 1;
					pTempMarkImagePos = m_vpmpCalibMarkImagePos.at(nTempMoveIndex);
					if (pTempMarkImagePos == NULL)
					{
						return FALSE;
					}					
					pTempMarkImagePos->SetMarkImagePos(nCalibPos, FALSE, posTemp);
					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosX.at(0);
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_vdAuxiliaryPosY.at(0);
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_vdAuxiliaryAngle.at(0);
					pTempMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					if (nMoveIndex == nTempMoveIndex)
					{
						pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					}

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_SUCCESS);//.Format(_T("关联模板搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALIB_TARGET_SEARCH_FAILED);//.Format(_T("关联模板搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
			}
		} 
		else
		{
			if (0 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
			{
				// 目标定位工具是否正常 
				if (m_bValidTargetSearchTool!=TRUE)
				{
					//ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				// 用目标模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnTargetSearchResult(nCalibPos,0);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

			}	
			else if (1 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
			{
				// 对象定位工具是否正常 
				if (m_bValidObjectSearchTool!=TRUE)
				{
					//ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				// 用对象模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteAlnObjectSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetAlnObjectSearchResult(nCalibPos,0);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
			}
			else if (2 == m_pSystempOptionConfig->m_nSepCamCalibTargetModelType)
			{
				// 标定定位工具是否正常 
				if (m_bValidCalibSearchTool!=TRUE)
				{
					//ReportCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				// 用目标模板执行标定搜索
				CCoordPos cp;
				BOOL bSearchSucceed = ExecuteCalibTargetSearch(nCalibPos, 0);
				if(bSearchSucceed)
				{			
					m_vbSearchSucceed[nCalibPos] = TRUE;
					m_vSeachResults[nCalibPos] = GetCalibSearchResult(nCalibPos,0);

					cp.m_dPosX  = m_vSeachResults[nCalibPos].m_dPosX;
					cp.m_dPosY  = m_vSeachResults[nCalibPos].m_dPosY;
					cp.m_dAngle = m_vSeachResults[nCalibPos].m_dAngle;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);

					m_bStatusBar = TRUE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_SUCCESS);//.Format(_T("标定目标搜索成功!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}
				else
				{
					cp.m_dPosX  = 0;
					cp.m_dPosY  = 0;
					cp.m_dAngle = 0;
					m_vbSearchSucceed[nCalibPos] =FALSE;
					pMarkImagePos->SetMarkImagePos(nCalibPos, m_vbSearchSucceed[nCalibPos], cp);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_CAL_TARGET_SEARCH_FAILE);//.Format(_T("标定目标搜索失败!"));
					m_strStatusBarInfo1 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

			}
		}



		// 记录图像搜索数据
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strOut;
			CCoordPos cp;
			strOut = strTemp + _T("CalibSearch: ");		
			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = pMarkImagePos->GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

				strOut += strTemp;
			}

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));               
			// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}	
	}    	


	return TRUE;
}

// 获取标定所有的移动定位结果
std::vector<CMarkImagePos*> vcXYDVisionAlign::GetCalibMarkImagPos()
{
	return m_vpmpCalibMarkImagePos;
}

BOOL vcXYDVisionAlign::GetCalibAlignerTargetPlatformAxisPos(int nIndex)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
	{
		return FALSE;
	}

	// 通信是否正常
	if (FALSE == m_bValidComm)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE; 
	}

	// 标定用定位工具是否正常 
	if (m_bValidTargetSearchTool!=TRUE)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 相机是否处于连续采集状态
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}    	
	}

	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	int nCamPos = m_pPlatformInfo->m_nPositionNum;

	//////////////////////////////////////// 平台标定/////////////////////////////////////////////

	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bGetPlatformAxis = FALSE;

	if(m_pPlatformInfo->m_bEnableKeyenceCode)
	{
		bGetPlatformAxis = CommuciateGetPlatformAxisAbsPosEx(pPlatformAxisPos);
	}
	else
	{
		bGetPlatformAxis = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	if (FALSE ==bGetPlatformAxis )
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{

		//		SetCalibPlatformPos(pPlatformAxisPos, nIndex);		

		// 		if (m_pPlatformInfo->m_bTarCamWithDiffObjCam)
		// 		{
		// 			if (nIndex == 0)
		// 			{
		// 				SetCalibPlatformPos(pPlatformAxisPos, 0, TRUE);	
		// 				SetCalibPlatformPos(pPlatformAxisPos, 1 ,TRUE);	
		// 			}
		// 			else if (nIndex == 1)
		// 			{
		// 				SetCalibPlatformPos(pPlatformAxisPos, 2, TRUE);	
		// 				SetCalibPlatformPos(pPlatformAxisPos, 3, TRUE);
		// 			}
		// 			else
		// 			{
		// 				return FALSE;
		// 			}
		// 		}
		// 		else
		{
			SetCalibPlatformPos(pPlatformAxisPos);	
		}

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_COMM_GET_AXIS_POS_SUCCESS);//.Format(_T("通信获取当前平台各个轴的绝对位置成功" ));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);

		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	return TRUE;
}

// BOOL vcXYDVisionAlign::GetCalibAlignerTargetPlatformAxisPos(int nIndex)
// {
// 	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
// 	{
// 		//ReportCalibResult(FALSE);
// 		return FALSE;
// 	}
// 
// 	// 通信是否正常
// 	if (FALSE == m_bValidComm)
// 	{
// 		//ReportCalibResult(FALSE);
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE; 
// 	}
// 
// 	// 标定用定位工具是否正常 
// 	if (m_bValidTargetSearchTool!=TRUE)
// 	{
// 		//ReportCalibResult(FALSE);
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE;
// 	}
// 
// 	// 相机是否处于连续采集状态
// 	int nCamNum = m_pPlatformInfo->m_nCamNum;
// 
// 	// 	if (nCamNum!=1)
// 	// 	{
// 	// 		ReportCalibResult(FALSE);
// 	// 		return FALSE;
// 	// 	}	
// 	int i=0;
// 	for(i=0; i<nCamNum; i++)
// 	{		 
// 		if (FALSE == m_vbCameraLiveGrab[i])
// 		{      
// 			//ReportCalibResult(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
// 			m_strStatusBarInfo2 = _T("");
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 			return FALSE;
// 		}    	
// 	}
// 
// 	// 标定开始    
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
// 	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 	int nCamPos = m_pPlatformInfo->m_nPositionNum;
// 
// 	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
// 
// 	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
// 	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
// 
// 	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
// 	{
// 		if (pPlatformAxisPos!=NULL)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;					
// 		}
// 
// 		//ReportCalibResult(FALSE);
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
// 		m_strStatusBarInfo2 = _T("");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE;
// 	}
// 	else
// 	{
// 
// //		SetCalibPlatformPos(pPlatformAxisPos, nIndex);		
// 
// 		if (m_pPlatformInfo->m_bTarCamWithDiffObjCam)
// 		{
// 			if (nIndex == 0)
// 			{
// 				SetCalibPlatformPos(pPlatformAxisPos, 0, TRUE);	
// 				SetCalibPlatformPos(pPlatformAxisPos, 1 ,TRUE);	
// 			}
// 			else if (nIndex == 1)
// 			{
// 				SetCalibPlatformPos(pPlatformAxisPos, 2, TRUE);	
// 				SetCalibPlatformPos(pPlatformAxisPos, 3, TRUE);
// 			}
// 			else
// 			{
// 				return FALSE;
// 			}
// 		}
// 		else
// 		{
// 			SetCalibPlatformPos(pPlatformAxisPos);	
// 		}
// 
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_COMM_GET_AXIS_POS_SUCCESS);//.Format(_T("通信获取当前平台各个轴的绝对位置成功" ));
// 		m_strStatusBarInfo2 = _T("");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		// 记录当前平台各个轴的绝对位置
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// // 			CTime t = CTime::GetCurrentTime();
// // 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strInfo;
// 			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 			strInfo = strTemp + strInfo;
// 
// // 			FILE *stream;
// // 			CString strPath = m_strAlignProcessData;
// // 			stream = fopen(strPath, _T("a+t"));
// // 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// // 			fclose(stream);VCRemoveFile(strPath);	
// 
// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 			////GYM-关联日志存储
// 			CString strCorrelationLogPath;
// 			SysPlatformInfo sysPlatformInfo;
// 			GetSysPlatformInfo(sysPlatformInfo);
// 
// 			//strCorrelationLogPath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 			//	m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex()+1);
// 			vcBaseAlignTool* tmpAlignTool = GetAlignTool();
// 			CString StrTmp = _T("");
// 			if (tmpAlignTool !=NULL)
// 			{
// 				if (sysPlatformInfo.m_bProductFaChd)
// 				{
// 					int nCurProductIndexFa;
// 					int nCurProductIndexCh;
// 					m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 					StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 						nCurProductIndexFa+1,nCurProductIndexCh+1);
// 				}
// 				else
// 				{
// 					StrTmp.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CorrelationLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 						m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 				}
// 				
// 			}
// 
// 			strCorrelationLogPath = StrTmp;
// 
// 			strInfo.Empty();
// 			strTemp.Format(_T("关联数据记录如下:\n"));
// 			strInfo += strTemp;
// 			strTemp.Format(_T("......关联时在对象拍照位获取的平台绝对位置: X: %.2f; Y: %.2f; D: %.2f;\n"),pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 			strInfo += strTemp;
// 			CorrelationMoveAxisAngle.push_back(pPlatformAxisPos->m_dAngle);
// 			VisionAlignLogRecord(strCorrelationLogPath,strInfo,FALSE);
// 			///GYM
// 			
// 		}
// 
// 		if (pPlatformAxisPos)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;
// 		}
// 	}
// 
// 	return TRUE;
// }



// 基准拾取相关
// 通信获取基准拾取轴位置
BOOL vcXYDVisionAlign::GetCalibAlignerBenchPickPlatformAxisPos()
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
	{
		//ReportCalibResult(FALSE);
		return FALSE;
	}

	// 通信是否正常
	if (FALSE == m_bValidComm)
	{
		//ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		PostMessageUpdateStatusBarInfo();

		return FALSE; 
	}

	// 	// 标定用定位工具是否正常 
	// 	if (m_bValidTargetSearchTool!=TRUE)
	// 	{
	// 		//ReportCalibResult(FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
	// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 		PostMessageUpdateStatusBarInfo();
	// 
	// 		return FALSE;
	// 	}

	// 相机是否处于连续采集状态
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	// 	if (nCamNum!=1)
	// 	{
	// 		ReportCalibResult(FALSE);
	// 		return FALSE;
	// 	}	
	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			//ReportCalibResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}    	
	}

	// 标定开始    
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();

	int nCamPos = m_pPlatformInfo->m_nPositionNum;

	//////////////////////////////////////// 平台标定/////////////////////////////////////////////

	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;	
	if(m_pPlatformInfo->m_bEnableKeyenceCode)
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPosEx(pPlatformAxisPos);
	}
	else
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}
	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		//ReportCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{
		m_BenchPickPlatformAxisPos = *pPlatformAxisPos;

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_COMM_GET_AXIS_POS_SUCCESS);//.Format(_T("通信获取当前平台各个轴的绝对位置成功" ));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CTime t = CTime::GetCurrentTime();
			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			FILE *stream;
			CString strPath = m_strAlignProcessData;
			stream = fopen(strPath, _T("a+t"));
			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			fclose(stream);VCRemoveFile(strPath);				
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	return TRUE;
}

// 执行基准拾取Mark 
BOOL vcXYDVisionAlign::ExecuteBenchMarkPick(int nIndex,int nExProductIndex)
{
	if (FALSE == m_bValidComm || NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig || NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	if (!m_mpObjectMarkImagePos.IsAllMarkImagePosOK())
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
	if (pCalibData == NULL || !pCalibData->IsValid())
	{
		return FALSE;
	}

	std::vector<CCoordPos> vObjectMarkImagePos;
	int i = 0;
	for (i = 0; i < m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
	{
		/*CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(i);
		if (pCalibrateParam == NULL)
		{
		return FALSE;
		}

		if(pCalibrateParam->m_nEnableDisCor)
		{
		CCoordPos OutPutPoint;
		m_pAlignerTool->ExecuteDisCorPoint(i+nExProductIndex*GetPosNum(), m_mpObjectMarkImagePos.GetMarkImagePos(i), OutPutPoint);
		vObjectMarkImagePos.push_back(OutPutPoint);
		}
		else*/
		{
			vObjectMarkImagePos.push_back(m_mpObjectMarkImagePos.GetMarkImagePos(i));
		}
	}

	m_pAlignerTool->SetEnablePickPosUpdate(optionInfo.m_bEnablePickPosUpdate);


	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}
	CProductData curProduct = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);  
	CBenchTargetMarkPickInfo* pTempBenchMarkPickInfo = curProduct.m_pAlignerParam->GetBenchTargetMarkPickInfo();
	CBenchTargetMarkPickInfo* pBenchMarkPickInfo = m_pAlignerTool->ExacuteBenchMarkPick(vObjectMarkImagePos, m_vpObjectPlatformAxisPos, 
		&m_BenchPickPlatformAxisPos, nIndex, pTempBenchMarkPickInfo,nExProductIndex);


	if (pBenchMarkPickInfo == NULL)
	{
		return FALSE;
	}


	curProduct.m_pAlignerParam->SetBenchTargetMarkPickInfo(pBenchMarkPickInfo);
	curProduct.m_pAlignerParam->SetBenchTargetMarkPickEnable(TRUE);
	m_pVisionASMConfig->m_TotalProductData.SetItem(nCurProductIndex, curProduct);
	m_pBenchMarkPickInfo = pBenchMarkPickInfo;

	m_pAlignerTool->SetProductAlignerParam(*curProduct.m_pAlignerParam);

	SaveProductDataInfo(nCurProductIndex);


	return TRUE;

}

// 保存基准拾取Mark 
BOOL vcXYDVisionAlign::SaveBenchMarkPick()
{
	if (FALSE == m_bValidComm || NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig || NULL == m_pAlignerTool)
	{
		return FALSE;
	}

	if (m_pBenchMarkPickInfo == NULL)
	{
		return FALSE;
	}


	// 2. 保存修正结果到当前产品及配置文件中
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		return FALSE;
	}
	CProductData curProduct = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);   
	curProduct.m_pAlignerParam->SetBenchTargetMarkPickInfo(m_pBenchMarkPickInfo);
	curProduct.m_pAlignerParam->SetBenchTargetMarkPickEnable(TRUE);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (optionInfo.m_bEnablePickPosUpdate)
	{
		for (int i = 0; i < m_pBenchMarkPickInfo->m_vCalibratedInfo.size(); i++)
		{
			//		*curProduct.m_vpCalibratedInfo.at(i) = *m_pBenchMarkPickInfo->m_vCalibratedInfo.at(i);   
			(*curProduct.m_vpCalibratedInfo.at(i)).m_cpMarkPlatformCoordPos = (*m_pBenchMarkPickInfo->m_vCalibratedInfo.at(i)).m_cpMarkPlatformCoordPos;   
		}
	}


	m_pVisionASMConfig->m_TotalProductData.SetItem(nCurProductIndex, curProduct);
	SaveProductDataInfo(nCurProductIndex);

	m_pAlignerTool->SetProductAlignerParam(*curProduct.m_pAlignerParam);

	if (optionInfo.m_bEnablePickPosUpdate)
	{
		CCalibData* pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProductIndex);	  
		if (pCalibData == NULL)
		{
			return FALSE;
		}
		for (int i=0; i< m_pBenchMarkPickInfo->m_vCalibratedInfo.size() ; i++)
		{
			//		*pCalibData->m_vpCalibratedInfo.at(i) = *vCalibratedInfo.at(i);  
			(*pCalibData->m_vpCalibratedInfo.at(i)).m_cpMarkPlatformCoordPos = (*m_pBenchMarkPickInfo->m_vCalibratedInfo.at(i)).m_cpMarkPlatformCoordPos;   
		}
		SaveCalibDataInfo(nCurProductIndex);
	}

	return TRUE;
}

// 单相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::SingleCameraAlignerObjectSearchExFOBJ(int nPosIndex)
{
	if (m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo)
	{	
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();
	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;	
	if(m_pPlatformInfo->m_bEnableKeyenceCode)
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPosEx(pPlatformAxisPos);
	}
	else
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{ 
		SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		}

		CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
		{
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex+1);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex+1,pPlatformAxisPos);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 等待相机移动到不同位置，并定位
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;	

	int nNum = m_pPlatformInfo->m_nPositionNum;
	//	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;	

	//   CMarkImagePos* pTemMarkImagePos = NULL;	
	{
		// 相机曝光设置
		// 对象模板曝光切换
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(0);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		if (SystempOptionSearchShutter && bObjectShutter)
		{
			// 更新相机曝光
			SwitchToObjectSearchShutter(nPosIndex);

			Sleep(200);

			// 采集图像
			std::vector<int> vnPosIndex;
			vnPosIndex.push_back(nPosIndex);

			if (!SnapSearchImage(vnPosIndex))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			//Sleep(200);
		}
		else
		{
			// 设置图像
			EnterCriticalSection(&m_vcsResource.at(nPosIndex));
			m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
			LeaveCriticalSection(&m_vcsResource.at(nPosIndex));
		}

		// 		// 设置图像
		// 		EnterCriticalSection(&m_vcsResource.at(nPosIndex));
		// 		m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
		// 		LeaveCriticalSection(&m_vcsResource.at(nPosIndex));



		// 执行定位
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnObjectSearch(nPosIndex, 0);
		if(bSearchSucceed)
		{			
			m_vbSearchSucceed[nPosIndex] = TRUE;
			m_vSeachResults[nPosIndex] = GetAlnObjectSearchResult(nPosIndex,0);

			cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
			cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
			cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
			m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	

			CAlignerParam* pAlignerParam = GetProductAlignerParam();
			if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
			{
				cp.m_dPosX  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosX.at(0);
				cp.m_dPosY  = m_vSeachResults[nPosIndex].m_vdAuxiliaryPosY.at(0);
				cp.m_dAngle = m_vSeachResults[nPosIndex].m_vdAuxiliaryAngle.at(0);
				m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex+1, m_vbSearchSucceed[nPosIndex], cp);	
			}
		}
		else
		{
			cp.m_dPosX  = 0;
			cp.m_dPosY  = 0;
			cp.m_dAngle = 0;
			m_vbSearchSucceed[nPosIndex] =FALSE;
			m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);

			CAlignerParam* pAlignerParam = GetProductAlignerParam();
			if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
			{
				cp.m_dPosX  = 0;
				cp.m_dPosY  = 0;
				cp.m_dAngle = 0;
				m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex+1, m_vbSearchSucceed[nPosIndex], cp);	
			}

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


			return FALSE;
		}

		// 3. 设置对位工具
		//	if (pTemMarkImagePos)
		{
			SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
			}
		}

		// 4. 设置相机平台的绝对位置
		//SetObjectCamPlatformPos(vpCamPlatformXYAxisPos);

		for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			if (vpCamPlatformXYAxisPos.at(i)!=NULL)
			{
				delete vpCamPlatformXYAxisPos.at(i);
				vpCamPlatformXYAxisPos.at(i) = NULL;
			}
		}
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");
		//	if (pTemMarkImagePos)
		{
			for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

				strOut += strTemp;
			}		
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录当前相机平台各个轴的绝对位置
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strInfo;
		strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_CAM_PLATFORM_POS);
		strInfo = strTemp + strInfo;

		for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));
		// 		fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
	}

	// 释放内存
	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	{
		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
		{
			delete vpCamPlatformXYAxisPos.at(i);
			vpCamPlatformXYAxisPos.at(i) = NULL;
		}
	}	



	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;

}



// 单相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::SingleCameraAlignerVirtualObjectSearchExFVOJ(int nPosIndex)
{
	if (m_bValidVirtualSearchTool!=TRUE || NULL == m_pPlatformInfo)
	{	
		return FALSE;
	}

	// 检查是否支持虚拟对象对位
	if (m_pPlatformInfo->m_eAlignerObjectType!=eObjectVirtual)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_NOT_SUPPORT_VIRTUAL_SEARCH);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	// 若支持虚拟Mark定位，则首先进行虚拟对象与实时对象的定位，以确定二者相对位置关系
	if (FALSE == curProductData.m_pAlignerParam->GetVirtualObjectMarkEnable())
	{
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();
	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;	
	bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{ 
		SetVirtualPlatformPos(pPlatformAxisPos,nPosIndex);

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_VIRTUAL_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 等待相机移动到不同位置，并定位
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;	

	int nNum = m_pPlatformInfo->m_nPositionNum;
	//	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;	

	//   CMarkImagePos* pTemMarkImagePos = NULL;	
	{
		// 相机曝光设置
		// 对象模板曝光切换
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableVirtualObjectSearchShutter(0);
		BOOL bVirtualObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		if (SystempOptionSearchShutter && bVirtualObjectShutter)
		{
			// 更新相机曝光
			SwitchToVirtualObjectSearchShutter(nPosIndex);

			Sleep(200);

			// 采集图像
			std::vector<int> vnPosIndex;
			vnPosIndex.push_back(nPosIndex);

			if (!SnapSearchImage(vnPosIndex))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			//Sleep(200);

		}
		else
		{
			// 设置图像
			EnterCriticalSection(&m_vcsResource.at(nPosIndex));
			m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
			LeaveCriticalSection(&m_vcsResource.at(nPosIndex));
		}

		// 执行定位
		CCoordPos cp;
		BOOL bSearchSucceed = ExecuteAlnVirtualObjectSearch(nPosIndex, 0);
		if(bSearchSucceed)
		{			
			m_vbSearchSucceed[nPosIndex] = TRUE;
			m_vSeachResults[nPosIndex] = GetAlnVirtualObjectSearchResult(nPosIndex,0);

			cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
			cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
			cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
			m_mpVirtualMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	
		}
		else
		{
			cp.m_dPosX  = 0;
			cp.m_dPosY  = 0;
			cp.m_dAngle = 0;
			m_vbSearchSucceed[nPosIndex] =FALSE;
			m_mpVirtualMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);


			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_VIRTUAL_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		// 3. 设置对位工具
		//	if (pTemMarkImagePos)
		{
			SetVirtualMarkSearchResults(m_mpVirtualMarkImagePos); 
		}

		// 4. 设置相机平台的绝对位置
		SetVirtualCamPlatformPos(vpCamPlatformXYAxisPos);

		for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			if (vpCamPlatformXYAxisPos.at(i)!=NULL)
			{
				delete vpCamPlatformXYAxisPos.at(i);
				vpCamPlatformXYAxisPos.at(i) = NULL;
			}
		}
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("VirtualObjectSearch: ");
		//	if (pTemMarkImagePos)
		{
			for (int i=0; i<m_mpVirtualMarkImagePos.GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = m_mpVirtualMarkImagePos.GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

				strOut += strTemp;
			}		
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录当前相机平台各个轴的绝对位置
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strInfo;
		strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_VIRTUAL_SEARCH_CAM_PLATFORM_POS);
		strInfo = strTemp + strInfo;

		for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));
		// 		fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
	}

	// 释放内存
	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	{
		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
		{
			delete vpCamPlatformXYAxisPos.at(i);
			vpCamPlatformXYAxisPos.at(i) = NULL;
		}
	}	



	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_VIRTUAL_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;

}


// 设置保存虚拟对象的偏移量
BOOL vcXYDVisionAlign::SetAndSaveVirtualMarkOffset(std::vector<CCoordPos>& vObjectToVirtualOffsets, int nExProductIndex/* = 0*/)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{
		return FALSE;
	}	

	// 检查是否支持虚拟对象对位
	if (m_pPlatformInfo->m_eAlignerObjectType!=eObjectVirtual)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_NOT_SUPPORT_VIRTUAL_SEARCH);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	if (FALSE == m_bValidVirtualSearchTool)
	{

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_VIRTUAL_SEARCH_TOOL_VALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	// 若支持虚拟Mark定位，则首先进行虚拟对象与实时对象的定位，以确定二者相对位置关系
	if (TRUE == curProductData.m_pAlignerParam->m_bVirtualObjectMarkEnable)
	{		
		int nNum = m_pPlatformInfo->m_nCamNum;		
		if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;
		nNum = m_pPlatformInfo->m_nPositionNum;

		if (vObjectToVirtualOffsets.size() != nNum)
		{
			return FALSE;
		}

		for (int k=0; k<nNum; k++)
		{
			curProductData.m_pAlignerParam->SetVirtualObjectMarkOffset(k + nNum*nExProductIndex, vObjectToVirtualOffsets.at(k));
		}       

		// 保存二者关系
		m_pVisionASMConfig->m_TotalProductData.SetItem(nCurProductIndex, curProductData);
		SaveProductDataInfo(nCurProductIndex);

		// 设置好对位工具
		SetObjectMarkToVirtualMarkOffset(curProductData.m_pAlignerParam->m_vObjectVirtualMarkOffset/*vObjectToVirtualOffsets*/);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CONNECT_OBJECT_MARK_AND_VIRTUAL_MARK_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnSingleCameraMulAlignerPosObjectSearchCandidateExFOBC(int nPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if (m_bValidObjectSearchTool != TRUE || NULL == m_pPlatformInfo)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_SEARCH_FAILE);//_T("对象拍照失败");;
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nStartPatIndex);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eObjectSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (nPosIndex >= m_vpObjectPlatformAxisPos.size() || m_vpObjectPlatformAxisPos.at(nPosIndex) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
			}
			//D角度不累加
		}
	}

	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);//
		return FALSE;
	}
	else
	{ 
		SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		}

		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
		{
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex+1);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex+1,pPlatformAxisPos);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 等待相机移动到不同位置，并定位
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;	

	int nNum = m_pPlatformInfo->m_nPositionNum;

	{

		// 等待搜索延时
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
		int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
		BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

		// 自动对位过程中
		if (m_bAutoAlign == TRUE)
		{
			// 使用对象搜索延时2
			if (TRUE == bEnableDelayTime2)
			{
				if (1 == m_nAlignTime)
				{
					Sleep(nDelayTime);
				}
				else
				{
					Sleep(nDelayTime2);
				}
			}
			else
			{
				// 不使用对象搜索延时2，按照第一个搜索延时设置
				Sleep(nDelayTime);
			}

		}
		else
		{
			// 如果只接收到定位指令，按第一个对象搜索延时进行设置
			Sleep(nDelayTime);
		}

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nPosIndex);
		vsmSearchMode.push_back(eObjectSearch);


		// 隐藏结果图形
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// //		if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		//  		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);

		// 		隐藏额外图形
		// 				for (i=0; i<vnPosIndex.size(); i++)
		// 				{
		// 					int nPosIndex = vnPosIndex.at(i);
		// 					int nTemp=0;
		// 					int j=0;
		// 		
		// 					for (j=0; j<EXTRA_GRAPHICS_NUM_POS; j++)
		// 					{
		// 						nTemp = EXTRA_GRAPHICS_NUM_POS*nPosIndex + j;
		// 						m_vbVisibleGuiAlnExtraPos.at(nTemp) = FALSE;
		// 					}
		// 		
		// 					for (j=0; j<EXTRA_GRAPHICS_NUM_LINE; j++)
		// 					{
		// 						nTemp = EXTRA_GRAPHICS_NUM_LINE*nPosIndex + j;
		// 						m_vbVisibleGuiAlnExtraLine.at(nTemp) = FALSE;
		// 					}
		// 		
		// 					for (j=0; j<EXTRA_GRAPHICS_NUM_LINESEG; j++)
		// 					{
		// 						nTemp = EXTRA_GRAPHICS_NUM_LINESEG*nPosIndex + j;
		// 						m_vbVisibleGuiAlnExtraLineSeg.at(nTemp) = FALSE;
		// 					}
		// 		
		// 					for (j=0; j<EXTRA_GRAPHICS_NUM_CIRCLE; j++)
		// 					{
		// 						nTemp = EXTRA_GRAPHICS_NUM_CIRCLE*nPosIndex + j;
		// 						m_vbVisibleGuiAlnExtraCircle.at(nTemp) = FALSE;
		// 					}
		// 		
		// 					for (j=0; j<EXTRA_GRAPHICS_NUM_TEXT; j++)
		// 					{
		// 						nTemp = EXTRA_GRAPHICS_NUM_TEXT*nPosIndex + j;
		// 						m_vbVisibleGuiAlnExtraText.at(nTemp) = FALSE;
		// 					}
		// 		
		// 				}
		// 		
		// 				PostMessageUpdateGuiAlnExtraPosGraphics(vnPosIndex);
		// 				PostMessageUpdateGuiAlnExtraLineGraphics(vnPosIndex);
		// 				PostMessageUpdateGuiAlnExtraLineSegGraphics(vnPosIndex);
		// 				PostMessageUpdateGuiAlnExtraCircleGraphics(vnPosIndex);
		// 				PostMessageUpdateGuiAlnExtraTextGraphics(vnPosIndex);


		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (sysPlatformInfo.m_bPlatformPick))
		{
			std::vector<int> vnPosIndex1;
			vnPosIndex1.push_back(nPosIndex+1);	
			m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex1, eObjectSearch);

			// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex1, FALSE);
			// //			if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
			// 			{
			// 				PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex1, FALSE);
			// 			}
			//  			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex1, FALSE);

			// 			for (i=0; i<vnPosIndex1.size(); i++)
			// 			{
			// 				int nPosIndex = vnPosIndex1.at(i);
			// 				int nTemp=0;
			// 				int j=0;
			// 
			// 				for (j=0; j<EXTRA_GRAPHICS_NUM_POS; j++)
			// 				{
			// 					nTemp = EXTRA_GRAPHICS_NUM_POS*nPosIndex + j;
			// 					m_vbVisibleGuiAlnExtraPos.at(nTemp) = FALSE;
			// 				}
			// 
			// 				for (j=0; j<EXTRA_GRAPHICS_NUM_LINE; j++)
			// 				{
			// 					nTemp = EXTRA_GRAPHICS_NUM_LINE*nPosIndex + j;
			// 					m_vbVisibleGuiAlnExtraLine.at(nTemp) = FALSE;
			// 				}
			// 
			// 				for (j=0; j<EXTRA_GRAPHICS_NUM_LINESEG; j++)
			// 				{
			// 					nTemp = EXTRA_GRAPHICS_NUM_LINESEG*nPosIndex + j;
			// 					m_vbVisibleGuiAlnExtraLineSeg.at(nTemp) = FALSE;
			// 				}
			// 
			// 				for (j=0; j<EXTRA_GRAPHICS_NUM_CIRCLE; j++)
			// 				{
			// 					nTemp = EXTRA_GRAPHICS_NUM_CIRCLE*nPosIndex + j;
			// 					m_vbVisibleGuiAlnExtraCircle.at(nTemp) = FALSE;
			// 				}
			// 
			// 			}
			// 
			// 			PostMessageUpdateGuiAlnExtraPosGraphics(vnPosIndex1);
			// 			PostMessageUpdateGuiAlnExtraLineGraphics(vnPosIndex1);
			// 			PostMessageUpdateGuiAlnExtraLineSegGraphics(vnPosIndex1);
			// 			PostMessageUpdateGuiAlnExtraCircleGraphics(vnPosIndex1);
		}

		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{
			if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		// 定位
		BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
		BOOL bSearchSucceed = FALSE;
		if (bObjectSearchCandidate == FALSE)
		{
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (nStartPatIndex >= 0 && nStartPatIndex < TARGETCANDIDATENUM)
			{
				m_vnObjectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				m_vnObjectSearchStartPatIndex[nPosIndex] = m_vnObjectSearchSuccessPatIndex[nPosIndex];
			}
			else
			{
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			}			
			m_vnObjectSearchEndPatIndex[nPosIndex] = OBJECTCANDIDATENUM;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}

		if (FALSE == bSearchSucceed)
		{
			if (optionInfo.m_bSearchTimes)
			{
				for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
				{
					//定位延时	 m_nSearchDelayTime
					Sleep(optionInfo.m_nSearchDelayTime);
					// 采集搜索图像
					if (!SnapSearchImage(vnPosIndex))
					{
						if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);//

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

						return FALSE;
					}

					// 定位
					BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
					if (bObjectSearchCandidate == FALSE)
					{
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (nStartPatIndex >= 0 && nStartPatIndex < TARGETCANDIDATENUM)
						{
							m_vnObjectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
						}
						else if (nStartPatIndex == 9)
						{
							m_vnObjectSearchStartPatIndex[nPosIndex] = m_vnObjectSearchSuccessPatIndex[nPosIndex];
						}
						else
						{
							m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						}			
						m_vnObjectSearchEndPatIndex[nPosIndex] = OBJECTCANDIDATENUM;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}

					if (bSearchSucceed)
					{
						break;
					}
				}
			}
		}


		if (bSearchSucceed)
		{

			int nSuccessPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
			std::vector<CSearchResult> vTempSeachResults = GetAlnObjectSearchResults(nPosIndex,nSuccessPatIndex);
			int nSearchNum = GetAlnObjectSearchResultNumber(nPosIndex,nSuccessPatIndex);

			// 			if (nSearchNum > EXTRA_GRAPHICS_NUM_POS)
			// 			{
			// 				return FALSE;
			// 			}

			//// 圆定位工具
			//if (m_bIsObjectCircleSearchTool[nPosIndex] && (m_pSystempOptionConfig->m_bShowCircleTool))
			//{
			//	for (int m = 0; (m < nSearchNum) && (m < EXTRA_GRAPHICS_NUM_POS); m++)
			//	{
			//		sc2Vector scCircleCenter = vTempSeachResults.at(m).m_resultCircleSearchTool.m_scCircleCircle;
			//		double dCircleRadius = vTempSeachResults.at(m).m_resultCircleSearchTool.m_dRadius;
			//		scCircle Circle(scCircleCenter, dCircleRadius);

			//		int nTemp = EXTRA_GRAPHICS_NUM_POS*nPosIndex + m;
			//		m_vGuiAlnExtraCircle.at(nTemp) = Circle;
			//		m_vbVisibleGuiAlnExtraCircle.at(nTemp) = TRUE;
			//		
			//	}
			//}
			//// 角定位工具
			//else if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
			//{
			//	SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
			//	PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
			//}
			//else
			{
				// 				for (int m = 0; (m < nSearchNum) && (m < EXTRA_GRAPHICS_NUM_POS); m++)
				// 				{
				// 					sc2Vector vSearchPos;
				// 					vSearchPos.SetX(vTempSeachResults.at(m).m_dPosX);
				// 					vSearchPos.SetY(vTempSeachResults.at(m).m_dPosY);
				// 					
				// 					int nTemp = EXTRA_GRAPHICS_NUM_POS*nPosIndex + m;
				// 					m_vGuiAlnExtraPos.at(nTemp) = vSearchPos;
				// 
				// 					// 拾取一次发送多个结果 显示拾取顺序编号
				// 					m_vbVisibleGuiAlnExtraPos.at(nTemp) = TRUE;
				// 					CString StrInfo = _T("");
				// 					StrInfo.Format("%d",m+1);
				// 					// 显示内容
				// 					m_vGuiAlnExtraText.at(nTemp) = StrInfo;
				// 					// 显示位置
				// 					m_vGuiAlnExtraTextPos.at(nTemp) = sc2Vector(vTempSeachResults.at(m).m_dPosX,vTempSeachResults.at(m).m_dPosY+5);
				// 					// 字体大小调整
				// 					LOGFONT* pFont = m_vpGuiAlnExtraText.at(nTemp)->GetTextFont();
				// 					int nFontSize = 5+m_pSystempOptionConfig->m_ObjSearchResultCrossSize.nLineLength/10;
				// 					if (nFontSize<5 || nFontSize>40)
				// 					{
				// 						nFontSize = 10;
				// 					}
				// 					pFont->lfHeight = nFontSize;
				// 					pFont->lfWidth = nFontSize;
				// 
				// 					// 显示或隐藏
				// 					m_vbVisibleGuiAlnExtraText.at(nTemp) = TRUE;
				// 
				// 					// 文本颜色
				// 					COLORREF nColor =  m_pSystempOptionConfig->m_ObjSearchResultCrossSize.nLineColor;
				// 					// 凸显拾取第一片
				// 					if (m==0)
				// 					{
				// 						nColor = RGB(255,0,255);
				// 					}
				// 					m_vcColorGuiAlnExtraText.at(nTemp) = nColor;
				// 				}
			}

			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

			// 			SetGuiAlnExtraPos(vnPosIndex);
			// 			SetGuiAlnExtraLine(vnPosIndex);
			// 			SetGuiAlnExtraLineSeg(vnPosIndex);
			// 			SetGuiAlnExtraCircle(vnPosIndex);
			// 			SetGuiAlnExtraText(vnPosIndex);
			// 
			// 			PostMessageUpdateGuiAlnExtraPosGraphics(vnPosIndex);
			// 			PostMessageUpdateGuiAlnExtraLineGraphics(vnPosIndex);
			// 			PostMessageUpdateGuiAlnExtraLineSegGraphics(vnPosIndex);
			// 			PostMessageUpdateGuiAlnExtraCircleGraphics(vnPosIndex);
			// 			PostMessageUpdateGuiAlnExtraTextGraphics(vnPosIndex);
			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
			{
				//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
				ExeSaveVDBFile(vnPosIndex,eObjectSearch);
			}

			if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (sysPlatformInfo.m_bPlatformPick))
			{
				std::vector<int> vnPosIndex1;
				vnPosIndex1.push_back(nPosIndex+1);
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex1, eObjectSearch);

				//// 圆定位工具
				//if (m_bIsObjectCircleSearchTool[nPosIndex+1] && (m_pSystempOptionConfig->m_bShowCircleTool))
				//{
				//}
				//// 角定位工具
				//else if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
				//{
				//	SetGuiAlnObjectLineImageMarkPos(vnPosIndex1);
				//	PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex1, TRUE);
				//}
				//else
				{
					// 					for (int m = 0; (m < nSearchNum)&&(m < EXTRA_GRAPHICS_NUM_POS); m++)
					// 					{
					// 						sc2Vector vSearchAuxiliaryPos;
					// 						vSearchAuxiliaryPos.SetX(vTempSeachResults.at(m).m_vdAuxiliaryPosX.at(0));
					// 						vSearchAuxiliaryPos.SetY(vTempSeachResults.at(m).m_vdAuxiliaryPosY.at(0));
					// 
					// 						int nTemp = EXTRA_GRAPHICS_NUM_POS*(nPosIndex+1) + m;
					// 						m_vGuiAlnExtraPos.at(nTemp) = vSearchAuxiliaryPos;
					// 						m_vbVisibleGuiAlnExtraPos.at(nTemp) = TRUE;
					// 
					// 					}
					// 
					// 					SetGuiAlnExtraPos(vnPosIndex1);
					// 					SetGuiAlnExtraLine(vnPosIndex1);
					// 					SetGuiAlnExtraLineSeg(vnPosIndex1);
					// 					SetGuiAlnExtraCircle(vnPosIndex1);
					// 
					// 					PostMessageUpdateGuiAlnExtraPosGraphics(vnPosIndex1);
					// 					PostMessageUpdateGuiAlnExtraLineGraphics(vnPosIndex1);
					// 					PostMessageUpdateGuiAlnExtraLineSegGraphics(vnPosIndex1);
					// 					PostMessageUpdateGuiAlnExtraCircleGraphics(vnPosIndex1);
				}
				if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
				{
					//PostMessageSaveVDBFile(vnPosIndex1,eObjectSearch);
					ExeSaveVDBFile(vnPosIndex1,eObjectSearch);
				}
			}
		}
		else
		{
			if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_OBJECT_SEARCH_FAILED),nPosIndex);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
	}

	// 3. 设置对位工具
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 
	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 4. 设置相机平台的绝对位置
	//SetObjectCamPlatformPos(vpCamPlatformXYAxisPos);

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;
		CCoordPos cp;

		strOut = strTemp + _T("ObjectSearch: ");

		{
			for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

				strOut += strTemp;
			}		
		}

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录当前相机平台各个轴的绝对位置
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strInfo;
		strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_CAM_PLATFORM_POS);
		strInfo = strTemp + strInfo;

		for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
		}

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
	}

	// 释放内存
	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	{
		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
		{
			delete vpCamPlatformXYAxisPos.at(i);
			vpCamPlatformXYAxisPos.at(i) = NULL;
		}
	}	


	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(TRUE, m_vnObjectSearchSuccessPatIndex[nPosIndex]);
	return TRUE;

}

// 单相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSingleCameraAlignerObjectSearchCandidateExFOBC(int nPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOBC:");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckObjectSearchTool(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_SEARCH_FAILE);//_T("对象拍照失败");;
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nStartPatIndex);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eObjectSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (nPosIndex >= m_vpObjectPlatformAxisPos.size() || m_vpObjectPlatformAxisPos.at(nPosIndex) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
			}
			//D角度不累加
		}
	}
	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);//
		return FALSE;
	}
	else
	{ 
		SetObjectPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
		SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		}

		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if (pAlignerParam!=NULL  && (nPosIndex == 0) && optionInfo.m_bEnableMultiMarkMode==TRUE)
		{
			// 多标记点模式应用，设置轴位置到对应的位置
			int nSetPosNum = sysPlatformInfo.m_nPositionNum;
			// 对象目标分离情况
			if (sysPlatformInfo.m_bTargetObjectCamSeparate)
			{
				nSetPosNum = sysPlatformInfo.m_nPositionNum/2;
			}

			// 循环设置到所有位置
			for (int nTempIndex = 1; nTempIndex < nSetPosNum; nTempIndex++)
			{
				SetObjectPlatformPos_MultiEx(pPlatformAxisPos,nTempIndex);
				SetObjectPlatformPos(pPlatformAxisPos,nTempIndex);
				if ((m_bAutoAlign == TRUE && m_nAlignTime == 1) || (m_bAutoAlign == FALSE))
				{
					SetTempObjectPlatformAxisPos(nTempIndex,pPlatformAxisPos);
				}
			}
		}


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 2. 等待相机移动到不同位置，并定位
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;	

	int nNum = m_pPlatformInfo->m_nPositionNum;
	//	if (1 == nNum) nNum = m_pPlatformInfo->m_nPositionNum;	

	//   CMarkImagePos* pTemMarkImagePos = NULL;	
	{

		// 等待搜索延时
		// 		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		// 		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
		// 		Sleep(nDelayTime);

		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
		int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
		BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

		// 自动对位过程中
		if (m_bAutoAlign == TRUE)
		{
			// 使用对象搜索延时2
			if (TRUE == bEnableDelayTime2)
			{
				if (1 == m_nAlignTime)
				{
					Sleep(nDelayTime);
				}
				else
				{
					Sleep(nDelayTime2);
				}
			}
			else
			{
				// 不使用对象搜索延时2，按照第一个搜索延时设置
				Sleep(nDelayTime);
			}

		}
		else
		{
			// 如果只接收到定位指令，按第一个对象搜索延时进行设置
			Sleep(nDelayTime);
		}

		// 准备开始定位			
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eObjectSearch);	// 


		// 隐藏结果图形
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// //		if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		// SY
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		//         ShowExtraGuiToDisplay(vnPosIndex,FALSE);
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);

		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
		{
			std::vector<int> vnPosIndex1;
			vnPosIndex1.push_back(nPosIndex+1);	

			// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex1, FALSE);
			// //			if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
			// 			{
			// 				PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex1, FALSE);
			// 			}
			// 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex1, FALSE);
			//             ShowExtraGuiToDisplay(vnPosIndex1,FALSE);

			m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex1, eObjectSearch);
		}


		// 采集搜索图像
		if (!SnapSearchImage(vnPosIndex))
		{
			if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);//

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
			// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();
			OnFailedSnapSearchImage(strCmd);
			return FALSE;
		}

		// 帧有效显示时，刷新位置1图像
		if ((m_pPlatformInfo->m_nPositionNum>1) && (optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (m_pSystempOptionConfig->m_nDisplayMode == 1))
		{
			std::vector<int> vnPosIndex1;
			vnPosIndex1.push_back(nPosIndex+1);
			SnapSearchImage(vnPosIndex1);
		}

		// 定位
		BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
		BOOL bSearchSucceed = FALSE;
		if (bObjectSearchCandidate == FALSE)
		{
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (nStartPatIndex >= 0 && nStartPatIndex < TARGETCANDIDATENUM)
			{
				m_vnObjectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				m_vnObjectSearchStartPatIndex[nPosIndex] = m_vnObjectSearchSuccessPatIndex[nPosIndex];
			}
			else
			{
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			}			
			m_vnObjectSearchEndPatIndex[nPosIndex] = OBJECTCANDIDATENUM;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}

		if (FALSE == bSearchSucceed)
		{
			if (optionInfo.m_bSearchTimes)
			{
				for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
				{
					//定位延时	 m_nSearchDelayTime
					Sleep(optionInfo.m_nSearchDelayTime);
					// 采集搜索图像
					if (!SnapSearchImage(vnPosIndex))
					{
						if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);//

						// 						m_bStatusBar = FALSE;
						// 						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
						// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
						// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						// 						PostMessageUpdateStatusBarInfo();
						OnFailedSnapSearchImage(strCmd);
						return FALSE;
					}

					// 帧有效显示时，刷新位置1图像
					if ((m_pPlatformInfo->m_nPositionNum>1) && (optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (m_pSystempOptionConfig->m_nDisplayMode == 1))
					{
						std::vector<int> vnPosIndex1;
						vnPosIndex1.push_back(nPosIndex+1);
						SnapSearchImage(vnPosIndex1);
					}

					// 定位
					BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
					if (bObjectSearchCandidate == FALSE)
					{
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (nStartPatIndex >= 0 && nStartPatIndex < TARGETCANDIDATENUM)
						{
							m_vnObjectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
						}
						else if (nStartPatIndex == 9)
						{
							m_vnObjectSearchStartPatIndex[nPosIndex] = m_vnObjectSearchSuccessPatIndex[nPosIndex];
						}
						else
						{
							m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						}			
						m_vnObjectSearchEndPatIndex[nPosIndex] = OBJECTCANDIDATENUM;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}

					if (bSearchSucceed)
					{
						break;
					}
				}
			}
		}

		if (TRUE == bSearchSucceed)
		{
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
		else
		{
			if (optionInfo.m_bManualAfObjSearchFail && optionInfo.m_bEnableMultiMarkMode==FALSE)
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉弹出手动搜索框
					SetPlcManualSearch(TRUE);
				}

				if (FALSE ==ExcuteManualSearch(1,vnPosIndex))
				{
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉关闭手动搜索框
						SetPlcManualSearch(FALSE);
					}

					for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
					{
						if (vpCamPlatformXYAxisPos.at(i)!=NULL)
						{
							delete vpCamPlatformXYAxisPos.at(i);
							vpCamPlatformXYAxisPos.at(i) = NULL;
						}
					}

				}
				else
				{
					if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (GetPosNum()==2))
					{
						std::vector<int> vnPosIndex1;
						vnPosIndex1.push_back(nPosIndex+1);

						if (FALSE ==ExcuteManualSearch(1,vnPosIndex1))
						{
							if (optionInfo.m_bSetVisionManualSearchToPLC)
							{
								// 通知PLC，视觉关闭手动搜索框
								SetPlcManualSearch(FALSE);
							}

							for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
							{
								if (vpCamPlatformXYAxisPos.at(i)!=NULL)
								{
									delete vpCamPlatformXYAxisPos.at(i);
									vpCamPlatformXYAxisPos.at(i) = NULL;
								}
							}

							//	return FALSE;
						}
						else
						{
							bSearchSucceed = TRUE;
						}
					}
					else
					{
						bSearchSucceed = TRUE;
					}
				}

				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}


			}

		}

		// 设定、显示结果图形
		//         SetGuiAlnObjectImageMarkPos(vnPosIndex);
		//         PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
		// 		if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnObjectImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
		//         {
		//             SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // SY
		//         SetShowGuiObjectImageMarkPos(vnPosIndex);
		//         PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
		//         ShowExtraGuiToDisplay(vnPosIndex,TRUE,1);

		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
			ExeSaveVDBFile(vnPosIndex,eObjectSearch);
		}
		//CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0) && (GetPosNum()==2))
		{
			std::vector<int> vnPosIndex1;
			vnPosIndex1.push_back(nPosIndex+1);

			//             SetGuiAlnObjectImageMarkPos(vnPosIndex1);
			//             PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex1, TRUE);
			// 			if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
			// 			{
			// 				SetGuiAlnObjectImageMarkPos(vnPosIndex1);
			// 				PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex1, TRUE);
			// 			}
			// 
			// 			if (/*m_bIsObjectCornerSearchTool && */ (m_pSystempOptionConfig->m_bShowCornerTool))
			//             {
			//                 SetGuiAlnObjectLineImageMarkPos(vnPosIndex1);
			//                 PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex1, TRUE);
			//             }
			//             SetShowGuiObjectImageMarkPos(vnPosIndex1);
			//             PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex1, TRUE);
			//             ShowExtraGuiToDisplay(vnPosIndex1,TRUE,1);

			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex1, eObjectSearch);

			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
			{
				//PostMessageSaveVDBFile(vnPosIndex1,eObjectSearch);
				ExeSaveVDBFile(vnPosIndex1,eObjectSearch);
			}
		}


		if (bSearchSucceed)
		{
		}
		else
		{
			if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(FALSE);//

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_OBJECT_SEARCH_FAILED),nPosIndex+1);
			m_strStatusBarInfo2 = m_StrSearchErrorInfo;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
			m_strStatusBarInfo1 += m_StrSearchErrorInfo;
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
	}

	// 3. 设置对位工具
	//	if (pTemMarkImagePos)
	{
		SetMultiEXObjectMarkSearchResultsWithCombinationCode(m_mpObjectMarkImagePos);
		SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
		}
	}

	// 4. 设置相机平台的绝对位置
	//SetObjectCamPlatformPos(vpCamPlatformXYAxisPos);

	// 5.多标记点模式下检查对象尺寸
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CAlignerParam* pAlignerParam = GetProductAlignerParam();
	if (pAlignerParam != NULL && optionInfo.m_bEnableMultiMarkMode)
	{
		// 计算对象距离
		//		CalculateObjectDistance(); 
		if (!CheckObjectDistance())
		{
			if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //__T("对象距离超过设定标准，对象定位结果可能出错");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			//		RecordObjectSizeIndfo(TRUE,FALSE);

			return FALSE;
		}

		//		RecordObjectSizeIndfo(TRUE, TRUE);
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");
		//	if (pTemMarkImagePos)
		{
			for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

				strOut += strTemp;
			}		
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录当前相机平台各个轴的绝对位置
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strInfo;
		strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_CAM_PLATFORM_POS);
		strInfo = strTemp + strInfo;

		for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));
		// 		fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
	}

	// 释放内存
	for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	{
		if (vpCamPlatformXYAxisPos.at(i)!=NULL)
		{
			delete vpCamPlatformXYAxisPos.at(i);
			vpCamPlatformXYAxisPos.at(i) = NULL;
		}
	}	
	std::vector<int> vnPosIndex;
	vnPosIndex.push_back(nPosIndex);
	//for (int i=0;i<vnPosIndex.size();i++)
	//{
	//	int nIndx=vnPosIndex.at(i);
	//	m_vbIsObjectPosSearchFinished.at(nIndx)=TRUE;
	//}

	//BOOL bAllObjectPosSearch=TRUE;
	//for (int i=0;i<m_vbIsObjectPosSearchFinished.size();i++)
	//{
	//	bAllObjectPosSearch=bAllObjectPosSearch && m_vbIsObjectPosSearchFinished.at(i);
	//}
	//m_bAllObjectPosSearchSuccess=bAllObjectPosSearch;


	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1 /*&& m_bAllObjectPosSearchSuccess && m_bAllTargetPosSearchSuccess*/)
	{
		/*for (int i=0;i<m_vbIsObjectPosSearchFinished.size();i++)
		{
		m_vbIsObjectPosSearchFinished.at(i) = FALSE;
		}
		m_bAllObjectPosSearchSuccess = FALSE;*/
		return ExecuteAlignAfterFOBCAndFTGC(vnPosIndex,1);
	}

	//m_bStatusBar = TRUE;
	//m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
	//m_strStatusBarInfo2 = _T("");
	//m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	//SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	if(m_bObjectSearchTest)ReportObjectSearchResultFOBC(TRUE, m_vnObjectSearchSuccessPatIndex[nPosIndex]);
	return TRUE;

}

//  等待相机移动到位（仅单相机用）
BOOL vcXYDVisionAlign::CommuciateWaitCamMove()
{
	if(NULL == m_pComm) 
	{
		return FALSE;
	}

	// 发送信号
	if (FALSE == SendCommInfo(_T("&WAT")))
	{               			
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_WAIT_CAM_PLATFORM_ARRIVED_CMD_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	BOOL bReceived;
	CString strReceived;

	m_tTimer.Reset();
	bReceived = ReceiveCommInfo(strReceived);

	if(bReceived)
	{
		AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
	}

	// 调试用
#ifdef BE_MANUAL
	AfxMessageBox(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_PLEASE_PLC_SEND_SINGLE_CAM_ARRIVED_CMD));
#endif

	while (FALSE == bReceived)
	{
		if (TRUE == m_bStopNow)
			return FALSE;

		bReceived = ReceiveCommInfo(strReceived);

		if(bReceived)
		{
			AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
		}

		if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
		{	
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_PLATFORM_ARRIVED_ASW_OUTTIME);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}    

		Sleep(2);
	}

	if(eAswSucceed!= m_XYDCommProtocol.AnalyzeAswWaitCamPltMove(strReceived))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_CAM_PLATFORM_ARRIVED_ASW_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}          

	return TRUE;

}


// 命令获取平台备用各轴的绝对位置
BOOL vcXYDVisionAlign::CommuciateGetPlatformAxisAbsPosBackup(CPlatformXYDAxisPos* pPlatformXYDAxisPos)
{
	CString strCmd = m_XYDCommProtocol.m_MPSBParam.m_strCmd;
	CString strTempWarningType = _T("");
	if (NULL == pPlatformXYDAxisPos)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_AXISPOSERROR);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	if(m_XYDCommProtocol.IsPlcProtocolType())
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackGetPlatformAbsPosBackup(strSimpleInfo);
		AddCommCommandInfo(TRUE, strSimpleInfo, FALSE, FALSE);
		//////////////////////////////////////////////////////////////////////////
		// 读取寄存器
		CString strSend;

		// 打包读取寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcGetPlatformAbsPosBackup(strSend))
		{
			return FALSE;
		}

		// 发送读取命令，接收PLC回复
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}

		// 解析收到的响应
		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetGetPlatformAbsPosBackup(strInfo, pPlatformXYDAxisPos);
		if (answeredStatus != eAswSucceed)
		{
			m_CommStatus = eCommUnConnect;
			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				// 读取寄存器
				CString strSend;

				// 打包读取寄存器指令
				if (FALSE == m_XYDCommProtocol.PackPlcGetPlatformAbsPosBackup(strSend))
				{
					return FALSE;
				}

				// 发送读取命令，接收PLC回复
				BOOL bReceived;
				CString strInfo;
				CommStatus nCommStatus = eCommSucceed;
				bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;
				}

				// 解析收到的响应
				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetGetPlatformAbsPosBackup(strInfo, pPlatformXYDAxisPos);
				std::vector<int> nParam;
				std::vector<double> dParam;
				nParam.push_back(0);
				dParam.push_back(pPlatformXYDAxisPos->m_dPosX);
				dParam.push_back(pPlatformXYDAxisPos->m_dPosY);
				dParam.push_back(pPlatformXYDAxisPos->m_dAngle);
				PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MPSBParam.m_strCmd,nParam,dParam);
				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_GET_PLATFORM_POS_ASW_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}
		else
		{
			std::vector<int> nParam;
			std::vector<double> dParam;
			nParam.push_back(0);
			dParam.push_back(pPlatformXYDAxisPos->m_dPosX);
			dParam.push_back(pPlatformXYDAxisPos->m_dPosY);
			dParam.push_back(pPlatformXYDAxisPos->m_dAngle);
			PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MPSBParam.m_strCmd,nParam,dParam);
		}
	}
	else
	{
		scTimer stPackandSendTimer; double dPackandSendTime(0.0);	
		stPackandSendTimer.Reset();

		if (NULL == pPlatformXYDAxisPos)
		{
			return FALSE;
		}

		CString strInfo;
		m_XYDCommProtocol.PackGetPlatformAbsPosBackup(strInfo);
		if(FALSE == SendCommInfo(strInfo))
		{		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_GET_PLATFORM_POS_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}			

		CString str;
		dPackandSendTime=stPackandSendTimer.GetTimeMilli(FALSE);

		BOOL bReceived;
		CString strReceived;

		m_tTimer.Reset();
		bReceived = ReceiveCommInfo(strReceived);

		while (FALSE == bReceived)
		{
			if (TRUE == m_bStopNow)
				return FALSE;

			bReceived = ReceiveCommInfo(strReceived);

			if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
			{			
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				return FALSE;
			}        

			Sleep(2);
		}	

		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswGetGetPlatformAbsPosBackup(strReceived, pPlatformXYDAxisPos);

		if (answeredStatus!=eAswSucceed)
		{		
			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)		
			{
				CString strInfo;
				m_XYDCommProtocol.PackGetPlatformAbsPosBackup(strInfo);
				if(FALSE == SendCommInfo(strInfo))
				{		
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_GET_PLATFORM_POS_CMD_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;
				}			

				CString str;
				dPackandSendTime=stPackandSendTimer.GetTimeMilli(FALSE);
				BOOL bReceived;
				CString strReceived;

				m_tTimer.Reset();
				bReceived = ReceiveCommInfo(strReceived);

				while (FALSE == bReceived)
				{
					if (TRUE == m_bStopNow)
						return FALSE;

					bReceived = ReceiveCommInfo(strReceived);

					if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
					{			
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
						return FALSE;
					}        

					Sleep(2);
				}	

				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswGetGetPlatformAbsPosBackup(strReceived, pPlatformXYDAxisPos);
				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}

			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_GET_PLATFORM_POS_ASW_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}
	}

	return TRUE;
}

// 获取平台备用各轴的绝对位置参数
BOOL vcXYDVisionAlign::CommParamGetPlatformAxisAbsPosBackup(CPlatformXYDAxisPos* pPlatformXYDAxisPos)
{
	if (NULL == pPlatformXYDAxisPos)
	{
		return FALSE;
	}

	*pPlatformXYDAxisPos = m_XYDCommProtocol.m_CurPlatformXYDAxisPosBackup;

	return TRUE;
}

// 获取平台各轴的绝对位置
BOOL  vcXYDVisionAlign::CommParamGetPlatformAxisAbsPos(CPlatformXYDAxisPos* pPlatformXYDAxisPos)    
{
	if (NULL == pPlatformXYDAxisPos)
	{
		return FALSE;
	}

	*pPlatformXYDAxisPos = m_XYDCommProtocol.m_CurPlatformXYDAxisPos;

	return TRUE;
}

BOOL  vcXYDVisionAlign::CommuciateGetDmCodeBoardAbsPos(std::vector<int> &vnPosIndex,std::vector<CCoordPos> &vImagePos,std::vector<CCoordPos> &vBoardPos)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
	{
		return FALSE;
	}

	// 通信是否正常
	if (FALSE == m_bValidComm)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE; 
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;
	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}    	
	}
	std::vector<CCoordPos> vImageSize;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		vnPosIndex.clear();
		vBoardPos.clear();

		//////////////////////////////////////////////////////////////////////////
		// 读取寄存器
		CString strSend;

		// 打包读取寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcGetDmCodeBoardAbsPos(strSend))
		{
			return FALSE;
		}

		// 发送读取命令，接收PLC回复
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("通信获取目标平台坐标超时");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		// 解析收到的响应
		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetDmCodeBoardAbsPos(strInfo,vnPosIndex,vImageSize,vBoardPos);
		if (answeredStatus != eAswSucceed)
		{
			m_CommStatus = eCommUnConnect;
			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				// 读取寄存器
				CString strSend;

				// 打包读取寄存器指令
				if (FALSE == m_XYDCommProtocol.PackPlcGetDmCodeBoardAbsPos(strSend))
				{
					return FALSE;
				}

				// 发送读取命令，接收PLC回复
				BOOL bReceived;
				CString strInfo;
				CommStatus nCommStatus = eCommSucceed;
				bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = _T("通信获取目标平台坐标超时");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

				// 解析收到的响应
				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetDmCodeBoardAbsPos(strInfo,vnPosIndex,vImageSize,vBoardPos);

				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("解析获取目标靶标坐标失败");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		else
		{
			// 获取时间	
			SYSTEMTIME tm;
			GetLocalTime(&tm);
			CString strTime;
			strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);

			CString strTranslateResultInfo;
			if (m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
			{
				strTranslateResultInfo = _T("输入:") + strTime  + strTranslateResultInfo;
				VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strCommunicationSimpleData, strTranslateResultInfo);
			}
		}

		double dImageWidth;
		double dImageHeight;
		int nPosIndex = 0;
		sc2Vector tmpVec;
		CCoordPos pos;
		for (int k=0;k<vnPosIndex.size();k++)
		{
			dImageWidth = vImageSize.at(k).GetPosX();
			dImageHeight = vImageSize.at(k).GetPosY();
			for (int i=0;i<3;i++)
			{
				for (int j=0;j<3;j++)
				{
					tmpVec.SetX(dImageWidth/4 + dImageWidth/4*j);
					tmpVec.SetY(dImageHeight/4 + dImageHeight/4*i);
					pos.SetPos(tmpVec);
					vImagePos.push_back(pos);
				}
			}
		}

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL  vcXYDVisionAlign::CommuciateSendDmCodeBoardAbsPos(std::vector<int> vnPosIndex,std::vector<CCoordPos> &vBoardPos)
{
	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
	{
		return FALSE;
	}

	// 通信是否正常
	if (FALSE == m_bValidComm)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE; 
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;
	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}    	
	}

	double dImageWidth,dImageHeight ;
	int nPosIndex;
	std::vector<CCoordPos> vImageSize;
	CCoordPos imgPos;
	for (int i=0;i<vnPosIndex.size();i++)
	{
		nPosIndex = vnPosIndex.at(i);
		dImageWidth  = m_vImageInput.at(nPosIndex).Width();
		dImageHeight = m_vImageInput.at(nPosIndex).Height();
		imgPos.SetPos(sc2Vector(dImageWidth,dImageHeight));
		vImageSize.push_back(imgPos);
	}
	if (m_XYDCommProtocol.IsPlcProtocolType())
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcSendDmCodeBoardAbsPos(strSend,vnPosIndex,vBoardPos,vImageSize))
		{
			return FALSE;
		}
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

	}
	else
	{
		return FALSE;
	}
	return TRUE;
}




//执行全局二维码标定拾取的计算（求旋转中心），相机在随XY轴运动时使用
BOOL vcXYDVisionAlign::ExecuteCalibWholeDmCodeBoardPick(int nCalibPos,int nMarkType)
{
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	CString strTempWarningType = _T("");
	CString strCmd = _T("VCLB:");
	GetCommCommandName(strCmd);
	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType)/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/)
	{
		ReportCalibResult(FALSE);
		return FALSE;
	}

	// 	BOOL bFlag;
	// 	if (!sysPlatformInfo.m_bEnableMultiCalibExtension)
	// 	{
	// 		bFlag = (nCalibPos >= sysPlatformInfo.m_nPositionNum);
	// 	}
	// 	else
	// 	{
	// 		int nExPosNum = sysPlatformInfo.m_nPositionNum*(sysPlatformInfo.m_nMultiCalibExtensionMaxNum+1);
	// 		bFlag = (nCalibPos >= nExPosNum);
	// 	}

	// 	if(nCalibPos < 0 || bFlag)
	// 	{
	// 		ReportCalibResult(FALSE);
	// 		return FALSE;
	// 	}

	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;

	//if (nMarkType !=5)
	//{
	//	return FALSE;
	//}

	{
		if (!(optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
		{
			ReportCalibResult(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_CHOOSE_WHOLE_DMCODE_CALIB_MODE);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}
		if ( (sysPlatformInfo.m_eMidPlatformType != ePlatformX) && (sysPlatformInfo.m_eMidPlatformType != ePlatformXY) && (sysPlatformInfo.m_eMidPlatformType != ePlatformY) )
		{
			BOOL bSuccess = ExecuteCalibWholeDmCodeBoard(nCalibPos);
			if (!bSuccess)
			{
				ReportCalibResult(FALSE);
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				return FALSE;
			}
			else
			{
				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = _T("");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_SUCCESS);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			}
		}
	}

	//////////////////////////////////////// 获取标定结果///////////////////////////////////////////


	// 获取系统标定后的所有信息
	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();	

	if(optionInfo.m_bAutoCopyCalibData)
	{
		//复制标定
		int nExProductIdx = nCalibPos/GetPosNum();
		ExecuteCopyCalibrateData(1,nExProductIdx);
	}
	else
	{
		/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
		SetCurCalibratedInfo(vpAllCalibratedInfo);	

		// 保存标定后信息到当前产品中及配置文件中
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
	}
	return TRUE;
}

// 单相机对位系统标定
// BOOL vcXYDVisionAlign::OnSingleCameraAlignerCalibrateEx(int nCalibPos, int nMarkType)
// {
// 	SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);
// 
// //	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
// //	{		
// //		ReportCalibResult(FALSE);
// //		return FALSE;
// //	}
// 	CString strTempWarningType = _T("");
// 	CString strCmd = _T("VCLB:");
// 	GetCommCommandName(strCmd);
// 	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
// 	{
// 		return FALSE;
// 	}
// 	
// 	BOOL bFlag;
// 	if (!sysPlatformInfo.m_bEnableMultiCalibExtension)
// 	{
// 		bFlag = (nCalibPos >= sysPlatformInfo.m_nPositionNum);
// 	}
// 	else
// 	{
// 		int nExPosNum = sysPlatformInfo.m_nPositionNum*(sysPlatformInfo.m_nMultiCalibExtensionMaxNum+1);
// 		bFlag = (nCalibPos >= nExPosNum);
// 	}
// 
// 	if(nCalibPos < 0 || bFlag)
// 	{
// 		ReportCalibResult(FALSE);
// 		return FALSE;
// 	}		
// 
// 	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;
// 	
// 	if((nMarkType < 0 || nMarkType > 1) && nMarkType !=5)
// 	{
// 		ReportCalibResult(FALSE);
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CALIBTYPE);
// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}	
// 
// // 	// 通信是否正常
// // 	if (FALSE == m_bValidComm)
// // 	{
// // 
// // 
// // 		ReportCalibResult(FALSE);
// // 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 		return FALSE; 
// // 	}
// 
// 	// 标定用定位工具是否正常 
// // 	if (m_bValidCalibSearchTool!=TRUE)
// // 	{
// // 
// // 		ReportCalibResult(FALSE);
// // 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 		return FALSE;
// // 	}
// 
// 	// 相机是否处于连续采集状态
// //	int nCamNum = m_pPlatformInfo->m_nCamNum;
// 
// 	// 	if (nCamNum!=1)
// 	// 	{
// 	// 		ReportCalibResult(FALSE);
// 	// 		return FALSE;
// 	// 	}	
// 	int i=0;
// // 	for(i=0; i<nCamNum; i++)
// // 	{		 
// // 		if (FALSE == m_vbCameraLiveGrab[i])
// // 		{      
// // 
// // 
// // 			ReportCalibResult(FALSE);
// // 
// // 			m_bStatusBar = FALSE;
// // 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
// // 			m_strStatusBarInfo2 = _T("");
// // 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 			return FALSE;
// // 		}    	
// // 	}
// 
// 	CPlatformOptionInfo optionInfo;
// 	GetPlatformOptionInfo(optionInfo);
// 	// 只考虑标准xyd、UVW、YD、XD 等平台且无移动拍照场景；
// 	if (optionInfo.m_bEnableCalibrateCheckByAxisMoveOption && 
// 		(m_pPlatformInfo->m_eMidPlatformType == ePlatformXYD || 
// 		m_pPlatformInfo->m_eMidPlatformType == ePlatformX1X2Y || 
// 		m_pPlatformInfo->m_eMidPlatformType ==ePlatformXY1Y2 ||  
// 		m_pPlatformInfo->m_eMidPlatformType ==ePlatformXY ||  
// 		m_pPlatformInfo->m_eMidPlatformType ==ePlatformXD ||  
// 		m_pPlatformInfo->m_eMidPlatformType ==ePlatformYD))
// 	{
// 		// 采用对象模板进行尺寸验证
// 		if (m_bValidObjectSearchTool!=TRUE )
// 		{
// 			SetStatusBarInfo(TRUE,_T("标定验证过程中"),GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT));
// 			PostMessageUpdateStatusBarInfo();
// 			return FALSE;
// 		}
// 
// 
// 		// 1. 获取平台当前各轴的绝对位置（基准位置）
// 		CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
// 		BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
// 		if (m_bCmdParamAxisPosEanble)
// 		{
// 			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
// 		}
// 		else
// 		{
// 			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
// 		}
// 
// 		if (FALSE == bCommuciateGetPlatformAxisAbsPos)
// 		{
// 			if (pPlatformAxisPos!=NULL)
// 			{
// 				delete pPlatformAxisPos;
// 				pPlatformAxisPos = NULL;					
// 			}
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_CALIBCHECK_FAILED);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 			return FALSE;
// 		}
// 		//else
// 		//{
// 		//	// 设置标定检查的基准轴位置
// 		//}
// 
// 		//计算需要走位的轴位置；
// 
// 		// 执行走位  暂时只考虑XYD
// 		double dTmpDx = optionInfo.m_dCalibrateCheckAxisMoveRangeX;
// 		double dTmpDy = optionInfo.m_dCalibrateCheckAxisMoveRangeY;
// 		double dTmpDd = optionInfo.m_dCalibrateCheckAxisMoveRangeD;
// 
// 		vector <double> vAxisAngeMove;
// 
// 		if (m_pPlatformInfo->m_eMidPlatformType ==ePlatformXY)
// 		{
// 			vAxisAngeMove.resize(1);
// 			vAxisAngeMove.at(0) = 0;
// 		}
// 		else
// 		{
// 			vAxisAngeMove.resize(3);
// 			vAxisAngeMove.at(0) = 0;
// 			vAxisAngeMove.at(1) = dTmpDd;
// 			vAxisAngeMove.at(2) = -dTmpDd;
// 		}
// 
// 
// 
// 		vector <double> vAxisXMove;
// 		vector <double> vAxisYMove;
// 
// 		if (m_pPlatformInfo->m_eMidPlatformType == ePlatformXYD || m_pPlatformInfo->m_eMidPlatformType ==	ePlatformX1X2Y || m_pPlatformInfo->m_eMidPlatformType ==ePlatformXY1Y2 ||  m_pPlatformInfo->m_eMidPlatformType ==ePlatformXY)
// 		{
// 			vAxisXMove.resize(9);
// 			vAxisXMove.at(0) = 0;
// 			vAxisXMove.at(1) = dTmpDx;
// 			vAxisXMove.at(2) = dTmpDx;
// 			vAxisXMove.at(3) = dTmpDx;
// 			vAxisXMove.at(4) = 0;
// 			vAxisXMove.at(5) = -dTmpDx;
// 			vAxisXMove.at(6) = -dTmpDx;
// 			vAxisXMove.at(7) = -dTmpDx;
// 			vAxisXMove.at(8) = 0;
// 
// 			vAxisYMove.resize(9);
// 			vAxisYMove.at(0) = 0;
// 			vAxisYMove.at(1) = dTmpDy;
// 			vAxisYMove.at(2) = 0;
// 			vAxisYMove.at(3) = -dTmpDy;
// 			vAxisYMove.at(4) = -dTmpDy;
// 			vAxisYMove.at(5) = -dTmpDy;
// 			vAxisYMove.at(6) = 0;
// 			vAxisYMove.at(7) = dTmpDy;
// 			vAxisYMove.at(8) = dTmpDy;
// 		}
// 		else if (m_pPlatformInfo->m_eMidPlatformType == ePlatformXD)
// 		{
// 			vAxisXMove.resize(3);
// 			vAxisYMove.resize(3);
// 
// 			vAxisXMove.at(0) = 0;
// 			vAxisXMove.at(1) = dTmpDx;
// 			vAxisXMove.at(2) = 0;
// 
// 			vAxisYMove.at(0) = 0;
// 			vAxisYMove.at(1) = 0;
// 			vAxisYMove.at(2) = 0;
// 		}
// 		else if (m_pPlatformInfo->m_eMidPlatformType == ePlatformYD)
// 		{
// 			vAxisXMove.resize(3);
// 			vAxisYMove.resize(3);
// 
// 			vAxisXMove.at(0) = 0;
// 			vAxisXMove.at(1) = 0;
// 			vAxisXMove.at(2) = 0;
// 
// 			vAxisYMove.at(0) = 0;
// 			vAxisYMove.at(1) = dTmpDy;
// 			vAxisYMove.at(2) = 0;
// 		}
// 
// 		// 根据平台轴方向调整走位轴 并考虑直线驱动等因素
// 		double dD0=pPlatformAxisPos->m_dAngle;
// 		if (optionInfo.m_bCalibSendRelativePos)
// 		{
// 			dD0 = 0.0;
// 		}
// 		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)(GetAlignTool()->GetPlatformParam());//平台参数
// 		//将平台坐标移动量转化为实际轴移动量
// 		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//X轴方向为负
// 		{
// 			for (int it_X=0;it_X<vAxisXMove.size();it_X++)
// 			{
// 				vAxisXMove[it_X] = -vAxisXMove[it_X];
// 			}
// 		}
// 
// 		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//Y轴方向为负
// 		{
// 			for (int it_Y=0;it_Y<vAxisYMove.size();it_Y++)
// 			{
// 				vAxisYMove[it_Y] = -vAxisYMove[it_Y];
// 			}
// 		}
// 		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
// 		{
// 			for (int it_D=0;it_D<vAxisAngeMove.size();it_D++)
// 			{
// 				vAxisAngeMove[it_D] = -vAxisAngeMove[it_D];
// 			}
// 		}
// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
// 		{
// 			double dStartAngle = 0;
// 			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
// 			{
// 				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
// 				{
// 					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
// 					for (int it_D=0;it_D<vAxisAngeMove.size();it_D++)
// 					{
// 						vAxisAngeMove[it_D] =  (sin(scDegree(dStartAngle + vAxisAngeMove[it_D])) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
// 					}
// 				}
// 				else
// 				{
// 					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
// 					for (int it_D=0;it_D<vAxisAngeMove.size();it_D++)
// 					{
// 						vAxisAngeMove[it_D] =   (tan(scDegree(dStartAngle + vAxisAngeMove[it_D])) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
// 					}
// 				}
// 			}
// 		}
// 
// 
// 		CPlatformXYDAxisPos* pPlatformXYDAxisPosMove = new CPlatformXYDAxisPos();
// 		pPlatformXYDAxisPosMove->m_dPosX = pPlatformAxisPos->m_dPosX;
// 		pPlatformXYDAxisPosMove->m_dPosX = pPlatformAxisPos->m_dPosY;
// 		pPlatformXYDAxisPosMove->m_dAngle = pPlatformAxisPos->m_dAngle;
// 
// 		CString strLogSummary = _T("");
// 		CString strTmpSummaryItem = _T("");
// 
// 		// 日志记录路径初始化
// 		CString SaveFilePath = _T("D:\\VisionASMLog\\");
// 		CString SaveFilePathSummary = _T("");
// 		DWORD dwRet = GetFileAttributes(SaveFilePath);	
// 		if ((dwRet == 0xFFFFFFFF) || ((dwRet & FILE_ATTRIBUTE_DIRECTORY) == 0)) // 路径不存在或不是路径
// 		{
// 			// 暂时不考虑创建文件夹失败情况
// 			CreateDirectory(SaveFilePath, NULL);
// 		}
// 
// 
// 		SysPlatformInfo platformInfo;
// 		GetSysPlatformInfo(platformInfo);
// 
// 
// 		// 考虑单产品扩展
// 		int nExProductIndex = nCalibPos/m_pPlatformInfo->m_nPositionNum;
// 
// 		if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
// 		{
// 			SetAlignExProductIndex(nExProductIndex);
// 			GetAlignTool()->m_bEnableMultiCombinationCode = FALSE;
// 		}
// 
// 
// 		CString StrTmpFilePath = _T(""); 
// 
// 		
// 
// 		if (sysPlatformInfo.m_bProductFaChd)
// 		{
// 			int nCurProductIndexFa;
// 			int nCurProductIndexCh;
// 			m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 			StrTmpFilePath.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CalibrationVerificationLog_ByAxisMove.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 				nCurProductIndexFa+1,nCurProductIndexCh+1);
// 		}
// 		else
// 		{
// 			StrTmpFilePath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CalibrationVerificationLog_ByAxisMove.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 				m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 		}
// 			
// 
// 		SaveFilePathSummary = SaveFilePath;
// 		SaveFilePath = StrTmpFilePath;
// 
// 		if (sysPlatformInfo.m_bProductFaChd)
// 		{
// 			int nCurProductIndexFa;
// 			int nCurProductIndexCh;
// 			m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 			StrTmpFilePath.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CalibrationVerificationLog_ByAxisMove_Summary.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 				nCurProductIndexFa+1,nCurProductIndexCh+1);
// 		}
// 		else
// 		{
// 			StrTmpFilePath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CalibrationVerificationLog_ByAxisMove_Summary.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 				m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 		}
// 			
// 		
// 
// 
// 
// 
// 		SaveFilePathSummary = StrTmpFilePath;
// 		vector<double> XMove;
// 		vector<double> YMove;
// 		vector<double> DMove;
// 		for (int iter_D = 0;iter_D<vAxisAngeMove.size();iter_D++) // 无角度 正转 反转
// 		{
// 			// 走九宫格
// 			for (int iter_XY = 0;iter_XY<vAxisXMove.size()  && iter_XY<vAxisYMove.size() ;iter_XY++)  
// 			{
// 				XMove.push_back(vAxisXMove[iter_XY]);
// 				YMove.push_back(vAxisYMove[iter_XY]);
// 				DMove.push_back(vAxisAngeMove[iter_D]);
// 			}
// 		}
// 		
// 		CString StrTmp2 = _T(""); 
// 		StrTmp2.Format(_T("当前扩展序号:%d"),nCalibPos/GetPosNum()+1);
// 		VisionAlignLogRecord(SaveFilePath,StrTmp2);
// 		VisionAlignLogRecord(SaveFilePathSummary,StrTmp2);
// 		//循环走位
// 		for (int iter_D = 0;iter_D<vAxisAngeMove.size();iter_D++) // 无角度 正转 反转
// 		{
// 			// 走九宫格
// 			for (int iter_XY = 0;iter_XY<vAxisXMove.size()  && iter_XY<vAxisYMove.size() ;iter_XY++)
// 			{
// 
// 
// 				// 设定驱动到位轴位置
// 
// 				pPlatformXYDAxisPosMove->m_dPosX =pPlatformAxisPos->m_dPosX+ vAxisXMove[iter_XY];
// 				pPlatformXYDAxisPosMove->m_dPosY = pPlatformAxisPos->m_dPosY +vAxisYMove[iter_XY];
// 				pPlatformXYDAxisPosMove->m_dAngle =pPlatformAxisPos->m_dAngle+ vAxisAngeMove[iter_D];
// 
// 				if (optionInfo.m_bCalibSendRelativePos)
// 				{
// 
// 					if (iter_XY==0 && iter_D == 0)
// 					{
// 						pPlatformXYDAxisPosMove->m_dPosX = XMove[0];
// 						pPlatformXYDAxisPosMove->m_dPosY = YMove[0];
// 						pPlatformXYDAxisPosMove->m_dAngle =DMove[0];
// 					}
// 					else
// 					{
// 						pPlatformXYDAxisPosMove->m_dPosX = XMove[iter_XY +iter_D*(vAxisXMove.size())]-XMove[iter_XY +iter_D*(vAxisXMove.size())-1];
// 						pPlatformXYDAxisPosMove->m_dPosY = YMove[iter_XY +iter_D*(vAxisXMove.size())]-YMove[iter_XY +iter_D*(vAxisXMove.size())-1];
// 						pPlatformXYDAxisPosMove->m_dAngle =DMove[iter_XY +iter_D*(vAxisXMove.size())]-DMove[iter_XY +iter_D*(vAxisXMove.size())-1];
// 
// 					}
// 				}
// 
// 				//执行驱动失败
// 				if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPosMove))
// 				{	 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), iter_XY+1) ;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_CALIBCHECK_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					return FALSE;
// 				}
// 				//驱动成功后
// 
// 				Sleep(100);
// 				// 执行定位
// 				int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 				int nSearchObjectNums = nPosNum/2;
// 				if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
// 				{
// 					nSearchObjectNums = nPosNum/2;
// 				}
// 				else
// 				{
// 					nSearchObjectNums =  nPosNum;
// 				}
// 
// 				std::vector<int> vnPosIndex;
// 				for(int it = 0; it < nSearchObjectNums; it++)
// 				{
// 					vnPosIndex.push_back(it);
// 				}
// 
// 				// 采用多位置对象拍照函数执行   默认从对象标准模板开始
// 
// 
// 
// 				BOOL bTmpSearchSuss = OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, 0);
// 
// 				CString strLog = _T("");
// 				CString StrTmp = _T(""); 
// 				strLog.Format(_T("角度:%.3f-移动位置:%d（X:%.3f,Y%.3f）时,产品尺寸信息:"),vAxisAngeMove[iter_D],iter_XY+1,vAxisXMove[iter_XY],vAxisYMove[iter_XY]);
// 
// 				if (bTmpSearchSuss)
// 				{
// 					// 日志记录；
// 					// 记录距离尺寸
// 
// 
// 					AlignerObjectSizeInfo tmp_AlignerObjectSizeInfo;  // 对位对象距离信息
// 					GetAlignerObjectSizeInfo(tmp_AlignerObjectSizeInfo);
// 					for (int it=0;it<tmp_AlignerObjectSizeInfo.m_vdObjectSize.size() && it<nSearchObjectNums;it++)
// 					{
// 						StrTmp.Format(_T("%s:%.3f,"),tmp_AlignerObjectSizeInfo.m_vstrObjectSizeName.at(it),tmp_AlignerObjectSizeInfo.m_vdObjectSize.at(it));
// 						strLog += StrTmp;
// 					}
// 
// 					strLog += _T("\n");
// 					strLogSummary +=strLog;
// 					// 记录各位置值的平台坐标和图像坐标
// 					CMarkPlatformPos mpTargetMarkPos;
// 					mpTargetMarkPos =GetAlignTool()->GetObjectMarkPlatformPos();
// 
// 					for (int it=0;it<nSearchObjectNums;it++)
// 					{
// 						StrTmp .Format( _T("标定轴移动位置拍照验证--对象位置%d:\n图像坐标:"),it+1);
// 						strLog += StrTmp;
// 						GetObjectMarkImagePos().GetMarkImagePos(it).ToString(StrTmp);
// 						strLog += StrTmp;
// 						StrTmp=_T("平台坐标:");
// 						strLog += StrTmp;
// 						mpTargetMarkPos.GetMarkPlatformPos(it).ToString(StrTmp);
// 						strLog += StrTmp;
// 					}
// 
// 					VisionAlignLogRecord(SaveFilePath,strLog);
// 
// 				} 
// 				else // 搜索失败时
// 				{
// 					StrTmp.Format(_T("搜索定位失败\n"));
// 					strLog += StrTmp;
// 					strLogSummary += strLog;
// 					VisionAlignLogRecord(SaveFilePath,strLog);
// 					// 继续下一个位置搜索
// 					continue; 
// 				}
// 			}
// 		}
// 
// 		if (pPlatformAxisPos!=NULL)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;					
// 		}
// 
// 		if (pPlatformXYDAxisPosMove!=NULL)
// 		{
// 			delete pPlatformXYDAxisPosMove;
// 			pPlatformXYDAxisPosMove = NULL;					
// 		}
// 		// 汇总信息
// 		VisionAlignLogRecord(SaveFilePathSummary,strLogSummary);
// 
// 	}
// 	else
// 	{
// 
// 		// 对位标定工具是否正常
// 		if (m_bValidCalibSearchTool!=TRUE)
// 		{		
// 			ReportCalibResult(FALSE);	
// 
// 			return FALSE;
// 		}
// 
// 		// 标定开始    
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		CPlatformOptionInfo optionInfo;
// 		GetPlatformOptionInfo(optionInfo);
// 	
// 		if (nMarkType == 5)
// 		{
// 			if (!(optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode()== eWholeDmcodeBoardCalib))
// 			{
// 				ReportCalibResult(FALSE);
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_CHOOSE_WHOLE_DMCODE_CALIB_MODE);
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 				PostMessageUpdateStatusBarInfo();
// 				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 				return FALSE;
// 			}
// 			if ( (sysPlatformInfo.m_eMidPlatformType != ePlatformX) && (sysPlatformInfo.m_eMidPlatformType != ePlatformXY) && (sysPlatformInfo.m_eMidPlatformType != ePlatformY) )
// 			{
// 				BOOL bSuccess = ExecuteCalibWholeDmCodeBoard(nCalibPos);//执行全局旋转中心计算
// 				if (!bSuccess)
// 				{
// 					ReportCalibResult(FALSE);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					return FALSE;
// 				}
// 			}
// 
// 			std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 			vpAllCalibratedInfo = GetAllCalibratedInfo();
// 			int nExProductIdx=nCalibPos/m_pPlatformInfo->m_nPositionNum;//扩展产品序号
// 			if (sysPlatformInfo.m_bEnableObjectCalibBench && (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum != nCalibPos))
// 			{
// 				if (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[m_pPlatformInfo->m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum] != NULL && vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->IsValid())
// 				{
// 					CPlatformXYDAxisPos*  pBenchPlatformAxisPos = (CPlatformXYDAxisPos* )vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->GetPlatformAxisPos();
// 					CPlatformXYDAxisPos * pCurrentPlatformAxisPos = (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
// 					CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 
// 
// 					double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
// 					double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;
// 
// 
// 					//平台各轴的方向	
// 					int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
// 					int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
// 
// 					if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
// 					if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;
// 
// 					CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->GetMarkPlatformCoordPos();
// 					CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();
// 
// 					currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
// 					currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;
// 
// 
// 
// 					vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
// 					vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
// 				}
// 
// 
// 			}
// 
// 			if(optionInfo.m_bAutoCopyCalibData)
// 			{
// 				//复制标定
// 
// 				ExecuteCopyCalibrateData(1,nExProductIdx);
// 			}
// 			else
// 			{
// 				/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 				SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 				// 保存标定后信息到当前产品中及配置文件中
// 				SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 			}
// 			return TRUE;
// 		}
// 	
// 		//标定开始
// 		//{//  [5/7/2020 zzc]
// 			int nCamPos = m_pPlatformInfo->m_nPositionNum;
// 
// 			//切换曝光时间
// 			{
// 				BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
// 				if (SystempOptionSearchShutter && optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 				{
// 					int nPosNum = 1;
// 					std::vector<int> vnCalibPos;
// 					vnCalibPos.push_back(nRemCalibPos);
// 					std::vector<CameraExposureType> vsmCameraExposureType;
// 
// 					for(i = 0; i < nPosNum; i++)
// 					{
// 						vsmCameraExposureType.push_back(eDmCodeSearchCameraExposure);
// 					}
// 
// 					if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType))
// 					{
// 						m_bStatusBar = FALSE;
// 						m_strStatusBarInfo1 = _T("切换二维码曝光失败");
// 						m_strStatusBarInfo2 = _T("");
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 						PostMessageUpdateStatusBarInfo();
// 					}
// 				}
// 			}
// 		
// 		
// 		
// 			////GYM---标定日志目录
// 			sc2Vector CalibrateMoveRange;
// 			CalibrateMoveRange = sc2Vector(0,0);
// 			vector<CString> AnalysisResult;
// 			AnalysisResult.clear();
// 			CString strCalibLogPath;
// 
// 			// 默认D:\\VisionASMLog路径存在
// 			
// 			if (sysPlatformInfo.m_bProductFaChd)
// 			{
// 				int nCurProductIndexFa;
// 				int nCurProductIndexCh;
// 				m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 				strCalibLogPath.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CalibrateLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 					nCurProductIndexFa+1,nCurProductIndexCh+1);
// 			}
// 			else
// 			{
// 				strCalibLogPath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CalibrateLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 					m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 			}
// 			
// 
// 			VisionAlignLogRecord(strCalibLogPath,_T(""),1);					// 标定日志开始记录
// 			// 标定参数记录
// 			CString StrCalibrate_Param = _T("");
// 			 // 获取标定参数字符串
// 			CalibrateLogRecord_Param(nCalibPos,StrCalibrate_Param);
// 			// 写入日志
// 			VisionAlignLogRecord(strCalibLogPath,StrCalibrate_Param,FALSE);
// 			// 标定参数记录
// 			////GYM
// 
// 
// 		
// 			//////////////////////////////////////// 平台标定/////////////////////////////////////////////
// 			// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
// 			CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
// 			BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
// 			if (m_bCmdParamAxisPosEanble)
// 			{
// 				bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
// 			}
// 			else
// 			{
// 				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
// 			}
// 
// 			//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
// 			if (FALSE == bCommuciateGetPlatformAxisAbsPos)
// 			{
// 				if (pPlatformAxisPos!=NULL)
// 				{
// 					delete pPlatformAxisPos;
// 					pPlatformAxisPos = NULL;					
// 				}
// 
// 
// 
// 				ReportCalibResult(FALSE);
// 
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED);
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 				PostMessageUpdateStatusBarInfo();
// 				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 				return FALSE;
// 			}
// 			else
// 			{
// 				SetCalibPlatformPos(pPlatformAxisPos/*, nCalibPos, FALSE*/);		
// 
// 				if (m_CalibPlatformAxisAbsPos.size()<nRemCalibPos+1)
// 				{
// 					m_CalibPlatformAxisAbsPos.resize(nRemCalibPos+1);
// 				}
// 				m_CalibPlatformAxisAbsPos.at(nRemCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 
// 
// 
// 				// 记录当前平台各个轴的绝对位置
// 				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 				{
// 					CString strTemp;
// 					// 			CTime t = CTime::GetCurrentTime();
// 					// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 					CString strInfo;
// 					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 					strInfo = strTemp + strInfo;
// 
// 					// 			FILE *stream;
// 					// 			CString strPath = m_strAlignProcessData;
// 					// 			stream = fopen(strPath, _T("a+t"));
// 					// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 					// 			fclose(stream);VCRemoveFile(strPath);		
// 
// 					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 					/////GYM-标定日志记录
// 					strInfo.Format(_T(""));
// 					strTemp.Format(_T("平台标定时平台的绝对位置:\n"));
// 					strInfo += strTemp;
// 					strTemp.Format(_T("......X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"),pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 					strInfo += strTemp;
// 					VisionAlignLogRecord(strCalibLogPath,strInfo,FALSE);
// 					/////GYM
// 				}
// 
// 				if (pPlatformAxisPos)
// 				{
// 					delete pPlatformAxisPos;
// 					pPlatformAxisPos = NULL;
// 				}
// 			}
// 
// 			//全局二维码靶标标定时，计算图像坐标到靶标坐标之间的映射关系
// 			if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
// 			{
// 				if (!ExecuteCalibWholeDmCodeBoardImgToBoard(nCalibPos))
// 				{
// 					ReportCalibResult(FALSE);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					return FALSE;
// 				}
// 			}
// 
// 			// 2. 获取平移标定和旋转标定时平台各轴的移动位置
// 			std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
// 			vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nRemCalibPos,nMarkType);
// 
// 			if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType))
// 			{	
// 
// 				ReportCalibResult(FALSE);
// 				return OnFailedGetCalibPlatformAxisMovePos(strCmd);
// //				m_bStatusBar = FALSE;
// //				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_EIGHT_PLATFORM_POS_FAILED);
// //				m_strStatusBarInfo2 = _T("");
// //				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// //				return FALSE;
// 			}
// 			else
// 			{
// 				/////GYM-标定日志记录
// 				CString strInfo = _T("");
// 				CString strTemp = _T("");
// 				strTemp.Format(_T("平台标定时所需要移动的绝对轴位置:\n"));
// 				strInfo += strTemp;
// 				CPlatformXYDAxisPos* pAxisPos;
// 				for (int i=0; i<vpPlatformAxisPos.size(); i++)
// 				{
// 					strTemp.Empty();
// 					pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
// 					strTemp.Format(_T("......平台位置%d: X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
// 					strInfo = strInfo + strTemp;
// 
// 				}
// 				VisionAlignLogRecord(strCalibLogPath,strInfo,FALSE);
// 				/////GYM
// 
// 				// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
// 				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 				{
// 					CString strTemp;
// 					// 			CTime t = CTime::GetCurrentTime();
// 					// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 					CString strInfo;
// 					strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
// 					strInfo = strTemp + strInfo;
// 
// 					CPlatformXYDAxisPos* pAxisPos;
// 					for (int i=0; i<vpPlatformAxisPos.size(); i++)
// 					{
// 						strTemp.Empty();
// 						pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
// 
// 						strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
// 						strInfo = strInfo + strTemp;
// 					}
// 
// 					// 			FILE *stream;
// 					// 			CString strPath = m_strAlignProcessData;
// 					// 			stream = fopen(strPath, _T("a+t"));
// 					// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 					// 			fclose(stream);VCRemoveFile(strPath);	
// 
// 					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 				}
// 			}
// 
// 			// 3. 驱动平台到位并定位
// 			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
// 			std::vector<CMarkImagePos*> vpMarkImagePos;
// 			CMarkImagePos* pMarkImagePos = NULL;
// 			CMarkImagePos* pDisCorMarkImagePos = NULL;
// 
// 			int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 			CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
// 			if (pCalibData == NULL || !pCalibData->IsValid())
// 			{
// 				ReportCalibResult(FALSE);
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 				PostMessageUpdateStatusBarInfo();
// 				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 				return FALSE;
// 			}
// 			CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
// 			if (pCalibrateParam == NULL)
// 			{
// 				ReportCalibResult(FALSE);
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 				PostMessageUpdateStatusBarInfo();
// 				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 				return FALSE;
// 			}
// 
// 			int k=0;
// 			//	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum() - 1; k++)
// 			for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType); k++)
// 			{ 
// 
// 				CString strInfo;
// 				strInfo.Format(_T("位置%d移动位置%d标定搜索开始"),nCalibPos,k);
// 				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 				//EnterCriticalSection(&m_csResource);
// 				m_bStatusBar = TRUE;
// 				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 				//LeaveCriticalSection(&m_csResource);
// 
// 				pMarkImagePos = NULL;
// 				pDisCorMarkImagePos = NULL;
// 
// 				// 驱动到位
// 				pPlatformXYDAxisPos = NULL;
// 				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);
// 
// 				if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
// 				{	 
// 
// 					ReportCalibResult(FALSE);			
// 					return OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);
// //					m_bStatusBar = FALSE;
// //					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), k) ;
// //					m_strStatusBarInfo2 = _T("");
// //					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// //					return FALSE;
// 				}
// 
// 
// 				Sleep(100);
// 				// 将相机移动到多个位置，逐个定位
// 				pMarkImagePos = new CMarkImagePos;
// 				pMarkImagePos->SetMarkImagePosNum(1);
// 
// 				pDisCorMarkImagePos = new CMarkImagePos;
// 				pDisCorMarkImagePos->SetMarkImagePosNum(1);
// 
// 				{
// 
// 					// 等待搜索延时
// 					int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 					Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);
// 
// 					// 准备开始定位			
// 					std::vector<int> vnPosIndex;
// 					std::vector<SearchMode> vsmSearchMode;	
// 					vnPosIndex.push_back(nRemCalibPos);		// nCalibPos	
// 
// 
// 					vsmSearchMode.push_back(eCalibSearch);	// 标定搜索		
// 
// 
// 
// 					// 采集搜索图像
// 					if (!SnapSearchImage(vnPosIndex))
// 					{				
// 						ReportCalibResult(FALSE);				
// 
// 						if (pMarkImagePos!=NULL)
// 						{
// 							delete pMarkImagePos;
// 							pMarkImagePos = NULL;
// 						}
// 
// 						if(pDisCorMarkImagePos != NULL)
// 						{
// 							delete pDisCorMarkImagePos;
// 							pDisCorMarkImagePos = NULL;
// 						}
// 
// 						for (int p=0; p<vpMarkImagePos.size(); p++)
// 						{
// 							if (vpMarkImagePos.at(p))
// 							{
// 								delete vpMarkImagePos.at(p);
// 								vpMarkImagePos.at(p) = NULL;
// 							}
// 						}  
// 
// //						m_bStatusBar = FALSE;
// //						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// //						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// //						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// //						PostMessageUpdateStatusBarInfo();
// 						return OnFailedSnapSearchImage(strCmd);
// //						return FALSE;
// 					}
// 
// 					// 定位	
// 
// 					m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
// 					m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;			
// 
// 					if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 					{
// 						if (k==0)
// 						{
// 							m_bIsFirstCalibPos = TRUE;
// 						}
// 						else
// 						{
// 							m_bIsFirstCalibPos = FALSE;
// 						}
// 					}
// 
// 					BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
// 
// 					if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
// 					{
// 						//PostMessageSaveVDBFile(vnPosIndex,eCalibSearch);
// 						ExeSaveVDBFile(vnPosIndex,eCalibSearch);
// 					}
// 					// 分析定位结果，发送指令响应
// 					if (FALSE == bSearchSucceed)
// 					{
// 
// 
// 						ReportCalibResult(FALSE);				
// 
// //						m_bStatusBar = FALSE;
// //						m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_MOVE_ROTATE_POS_SEARCH_FAILED), k);
// //						m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAM_MOVE_THEN_SEARCH_FAILED), nCalibPos); 
// //						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 						if (pMarkImagePos!=NULL)
// 						{
// 							delete pMarkImagePos;
// 							pMarkImagePos = NULL;
// 						}
// 
// 						if(pDisCorMarkImagePos != NULL)
// 						{
// 							delete pDisCorMarkImagePos;
// 							pDisCorMarkImagePos = NULL;
// 						}
// 
// 						for (int p=0; p<vpMarkImagePos.size(); p++)
// 						{
// 							if (vpMarkImagePos.at(p))
// 							{
// 								delete vpMarkImagePos.at(p);
// 								vpMarkImagePos.at(p) = NULL;
// 							}
// 						} 						 
// //						return FALSE;
// 						return OnFailedCalibSearch(strCmd, k, nCalibPos);
// 					}
// 
// 					if(pCalibrateParam->m_nEnableDisCor)
// 					{
// 						CCoordPos OutPutPoint;
// 						m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
// 						pDisCorMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
// 					}
// 
// 					// 保存定位结果			
// 					pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	
// 
// 
// 
// 
// 				}
// 
// 				if(pCalibrateParam->m_nEnableDisCor)
// 				{
// 					CMarkImagePos * markpos = new CMarkImagePos(*pDisCorMarkImagePos);
// 					vpMarkImagePos.push_back(markpos); 
// 				}
// 				else
// 				{
// 					CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
// 					vpMarkImagePos.push_back(markpos); 
// 				}
// 
// 				// 记录图像搜索数据
// 				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 				{
// 					CString strTemp;
// 					// 			CTime t = CTime::GetCurrentTime();
// 					// 			strTemp.Format(_T("\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 					CString strOut;
// 					CCoordPos cp;
// 					strOut = strTemp + _T("CalibSearch: ");		
// 					for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
// 					{
// 						strTemp = _T("");
// 						cp = pMarkImagePos->GetMarkImagePos(i);
// 
// 						strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 						strOut += strTemp;
// 					}
// 
// 					if(pCalibrateParam->m_nEnableDisCor)
// 					{
// 						for (int i=0; i<pDisCorMarkImagePos->GetMarkImagePosNum(); i++)
// 						{
// 							strTemp = _T("");
// 							cp = pDisCorMarkImagePos->GetMarkImagePos(i);
// 
// 							strTemp.Format(_T("DisCorMarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 							strOut += strTemp;
// 						}
// 					}
// 
// 					// 			FILE *stream;
// 					// 			CString strPath = m_strAlignProcessData;
// 					// 			stream = fopen(strPath, _T("a+t"));               
// 					// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
// 					// 			fclose(stream);VCRemoveFile(strPath);
// 
// 					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 					VisionAlignLogRecord(m_strAlignProcessData, strOut);
// 				}
// 
// 				strInfo.Format(_T("位置%d移动位置%d标定搜索结束"),nCalibPos,k);
// 				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 				if (pMarkImagePos!=NULL)
// 				{
// 					delete pMarkImagePos;
// 					pMarkImagePos = NULL;
// 				}  
// 
// 				if(pDisCorMarkImagePos != NULL)
// 				{
// 					delete pDisCorMarkImagePos;
// 					pDisCorMarkImagePos = NULL;
// 				}
// 			}    	
// 			if (pMarkImagePos!=NULL)
// 			{
// 				delete pMarkImagePos;
// 				pMarkImagePos = NULL;
// 			}  
// 
// 			if(pDisCorMarkImagePos != NULL)
// 			{
// 				delete pDisCorMarkImagePos;
// 				pDisCorMarkImagePos = NULL;
// 			}
// 
// 			// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具
// 		
// 			//全局二维码靶标标定时，计算靶标坐标到平台坐标的旋转缩放关系
// 			if (GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib && optionInfo.m_bEnableDmCodeCalib)
// 			{
// 				if(FALSE == ExecuteCalibrateWholeDmcodeBoardBoardToPlat(vpMarkImagePos,nCalibPos,nMarkType))
// 				{		
// 					ReportCalibResult(FALSE);		
// 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					for (k=0; k<vpMarkImagePos.size(); k++)
// 					{
// 						if (vpMarkImagePos.at(k))
// 						{
// 							delete vpMarkImagePos.at(k);
// 							vpMarkImagePos.at(k) = NULL;
// 						}
// 					} 
// 
// 					SaveCurAllCameraChannelSearchImg();		
// 					return FALSE;
// 				}
// 			}
// 			else
// 			{
// 				if(FALSE == ExecuteCalibrate(vpMarkImagePos,nCalibPos,nMarkType))
// 				{		
// 					ReportCalibResult(FALSE);		
// 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					for (k=0; k<vpMarkImagePos.size(); k++)
// 					{
// 						if (vpMarkImagePos.at(k))
// 						{
// 							delete vpMarkImagePos.at(k);
// 							vpMarkImagePos.at(k) = NULL;
// 						}
// 					} 
// 
// 					SaveCurAllCameraChannelSearchImg();		
// 					return FALSE;
// 				}
// 			}
// 
// 
// 			// GYM-标定日志记录
// 			{
// 				CString strOut = _T("");		
// 				CString strTemp = _T("");	
// 				strOut.Empty();
// 				strTemp.Empty();
// 				strTemp.Format(_T("平台标定时图像坐标:\n"));
// 				strOut += strTemp;
// 				for (int i=0; i<vpMarkImagePos.size(); i++)
// 				{
// 					strTemp.Empty();
// 					CCoordPos cp;
// 					cp = vpMarkImagePos.at(i)->GetMarkImagePos(0);
// 					strTemp.Format(_T("......MarkPos%d: X: %.2f; Y: %.2f; D: %.3f;\n"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 					strOut += strTemp;
// 					
// 				}
// 				VisionAlignLogRecord(strCalibLogPath,strOut, FALSE);
// 			}
// 			//GYM
// 
// 
// 		// GYM-标定日志记录-图像坐标分析
// 		CString strOut = _T("");	
// 		CalibrateLogRecord_ImagePos(nCalibPos,nMarkType,vpMarkImagePos,strOut,AnalysisResult,CalibrateMoveRange);
// 		VisionAlignLogRecord(strCalibLogPath,strOut, FALSE);
// 		// GYM
// 
// 
// 
// 
// 		// 5. 释放内存
// 			for (k=0; k<vpMarkImagePos.size(); k++)
// 			{
// 				if (vpMarkImagePos.at(k))
// 				{
// 					delete vpMarkImagePos.at(k);
// 					vpMarkImagePos.at(k) = NULL;
// 				}
// 			} 
// 
// 
// 			/////////////////////////////////////// 平台标定求精//////////////////////////////////////////
// 			// 判断是否需要进行平台标定求精，若是，则对单个相机进行平台标定求精
// 			//
// 		
// 			//若为全局二维码靶标标定，则不进行求精计算
// 			if (!(optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 			{
// 				if (nMarkType == 0)
// 				{
// 				}
// 																																																																																else
// 			{
// 				SysPlatformInfo sysPlatformInfo;
// 				GetSysPlatformInfo(sysPlatformInfo);
// 				if (ePlatformXD == sysPlatformInfo.m_eMidPlatformType)
// 				{
// 				}
// 				else if (ePlatformYD == sysPlatformInfo.m_eMidPlatformType)
// 				{
// 				}
// 				else if (ePlatformXDPY == sysPlatformInfo.m_eMidPlatformType)
// 				{
// 				}
// 				else if (ePlatformXDPY1 == sysPlatformInfo.m_eMidPlatformType)
// 				{
// 				}
// 				else if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
// 				{
// 				}
// 				else if (ePlatformXY == sysPlatformInfo.m_eMidPlatformType)
// 				{
// 				}
// 				else if (ePlatformX == sysPlatformInfo.m_eMidPlatformType)
// 				{
// 				}
// 				else if (ePlatformY == sysPlatformInfo.m_eMidPlatformType)
// 				{
// 				}
// 				else
// 				{
// 					int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 					int nCalibRefineTime = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->GetPlatformCalibRefineTime();
// 					/////GYM-标定日志记录
// 					/////求精记录
// 					CString strInfo = _T("");		
// 					CString strTemp = _T("");	
// 					strTemp.Empty();
// 					strInfo.Empty();
// 					strTemp.Format(_T("求精记录:\n"));
// 					strInfo += strTemp;
// 					VisionAlignLogRecord(strCalibLogPath,strInfo,FALSE);
// 					/////GYM-
// 					for (i = 0; i < nCalibRefineTime; i++)
// 					{
// 						strInfo.Empty();
// 						strTemp.Format(_T("......第%d次求精;"),i+1);
// 						strInfo += strTemp;
// 						VisionAlignLogRecord(strCalibLogPath,strInfo,FALSE);
// 
// 						std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 						vpAllCalibratedInfo = GetAllCalibratedInfo();
// 						/////GYM-标定日志记录
// 						/////求精基准坐标记录
// 						CString strOut = _T("");
// 						CString strTemp = _T("");
// 						strTemp.Format(_T("第%d次求精前后基准平台坐标对比:\n"),i+1);
// 						strOut += strTemp;
// 						strTemp.Format(_T("......求精前基准平台坐标:\n"));
// 						strOut += strTemp;
// 						strTemp.Format(_T("......PlatformPos: X: %.2f; Y: %.2f;\n"),vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos().m_dPosX,vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos().m_dPosY);
// 						strOut += strTemp;
// 
// 						if (FALSE == ExcutePlatformCalibrateRefine(nCalibPos))	//20180501hk修改 nRemCalibPos
// 						{
// 							ReportCalibResult(FALSE);
// 
// 							m_bStatusBar = FALSE;
// 							m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_BENCH_POS_CALIB_REFINE_FAILED), nRemCalibPos);
// 							//m_strStatusBarInfo2 = _T("");
// 							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 							strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 							AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 							PostMessageUpdateStatusBarInfo();
// 							SaveCurAllCameraChannelSearchImg();
// 							return FALSE;
// 						}
// 
// 						vpAllCalibratedInfo = GetAllCalibratedInfo();
// 						strTemp.Format(_T("......求精后基准平台坐标:\n"));
// 						strOut += strTemp;
// 						strTemp.Format(_T("......PlatformPos: X: %.2f; Y: %.2f;\n"),vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos().m_dPosX,vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos().m_dPosY);
// 						strOut += strTemp;
// 						strTemp.Format(_T("......前后差值: X: %.2f; Y: %.2f;\n"),vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPosRefineOffset().GetPosX(),vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPosRefineOffset().GetPosY());
// 						strOut += strTemp;
// 						VisionAlignLogRecord(strCalibLogPath,strOut,FALSE);
// 						/////GYM
// 					}
// 				}
// 
// 			}
// 																																																																																																																																																																																																																																																																																																																																																																																																																																					// 	// 判断是否需要进行平台标定求精，若是，则对单个相机进行平台标定求精
// 			// 	if (TRUE == IsExcutePlatformCalibrateRefine())
// 			// 	{
// 			// 		//	for (int n=0; n<nCamPos; n++)
// 			// 		{              
// 			// 			if (FALSE == ExcutePlatformCalibrateRefine(nCalibPos))
// 			// 			{
// 			// 				ReportCalibResult(FALSE);
// 			// 
// 			// 				m_bStatusBar = FALSE;
// 			// 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_BENCH_POS_CALIB_REFINE_FAILED), nCalibPos);
// 			// 				m_strStatusBarInfo2 = _T("");
// 			// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 			// 
// 			// 				SaveCurAllCameraChannelSearchImg();
// 			// 				return FALSE;
// 			// 			}
// 			// 		}
// 			// 	}
// 
// 			//////////////////////////////////////// 相机标定/////////////////////////////////////////////
// 
// 
// 			//	// 所有相机平台同时进行相机平台标定
// 			//	switch (m_pPlatformInfo->m_eCamPlatformType)
// 			//	{
// 			//	case eCamPlatformSepFix:
// 			//		break;
// 			//	case eCamPlatformSepX:
// 			//	case eCamPlatformSepXY:
// 			//		{
// 			//			std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
// 			//			CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;
// 			//
// 			//			for(i=0; i<nCamPos; i++)
// 			//			{
// 			//				pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
// 			//				vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);		
// 			//			}
// 			//
// 			//			// 1. 通信获取相机平台各个基准位置, 并设置入对位工具
// 			//			std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPosTemp; 
// 			//			for (i=0; i<nCamPos; i++)
// 			//			{
// 			//				// 等待相机移动到位
// 			//				if (FALSE == CommuciateWaitCamMove())
// 			//				{           
// 			//					ReportCalibResult(FALSE);
// 			//
// 			//					m_bStatusBar = FALSE;
// 			//					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_WAIT_CAMERA_ARRIVED), i);
// 			//					m_strStatusBarInfo2 = _T("");
// 			//					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 			//
// 			//					// 释放内存
// 			//					for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 			//					{
// 			//						if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 			//						{
// 			//							delete vpCamPlatformXYAxisPos.at(i);
// 			//							vpCamPlatformXYAxisPos.at(i) = NULL;
// 			//						}
// 			//					}
// 			//					SaveCurAllCameraChannelSearchImg();
// 			//					return FALSE;
// 			//				}
// 			//
// 			//				vpCamPlatformXYAxisPosTemp.clear();
// 			//				vpCamPlatformXYAxisPosTemp.push_back(vpCamPlatformXYAxisPos.at(i));
// 			//
// 			//				// 通信获取当前位置相机平台各轴的绝对位置
// 			//				if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPosTemp))
// 			//				{
// 			//					ReportCalibResult(FALSE);
// 			//
// 			//					m_bStatusBar = FALSE;
// 			//					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_CAM_PLATFORM_POS_FAILED));
// 			//					m_strStatusBarInfo2 = _T("");
// 			//					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 			//
// 			//					// 释放内存
// 			//					for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 			//					{
// 			//						if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 			//						{
// 			//							delete vpCamPlatformXYAxisPos.at(i);
// 			//							vpCamPlatformXYAxisPos.at(i) = NULL;
// 			//						}
// 			//					}
// 			//
// 			//					SaveCurAllCameraChannelSearchImg();
// 			//					return FALSE;
// 			//				}
// 			//				else
// 			//				{
// 			//					vpCamPlatformXYAxisPos.at(i) = vpCamPlatformXYAxisPosTemp.at(0);
// 			//				}
// 			//
// 			//			}
// 			//
// 			//			SetCalibCamPlatformPos(vpCamPlatformXYAxisPos);
// 			//
// 			//			// 记录当前相机平台各个轴的绝对位置
// 			//			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 			//			{
// 			//				CString strTemp;
// 			//// 				CTime t = CTime::GetCurrentTime();
// 			//// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 			//
// 			//				CString strInfo;
// 			//				strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SINGLE_CAM_CALIB_ALL_BENCH_POS);
// 			//				strInfo = strTemp + strInfo;
// 			//
// 			//				for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 			//				{
// 			//					strTemp = _T("");
// 			//					strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
// 			//					strInfo = strInfo + strTemp;
// 			//				}
// 			//
// 			//// 				FILE *stream;
// 			//// 				CString strPath = m_strAlignProcessData;
// 			//// 				stream = fopen(strPath, _T("a+t"));
// 			//// 				fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 			//// 				fclose(stream);VCRemoveFile(strPath);	
// 			//
// 			//				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 			//				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 			//			}		
// 			//
// 			//			// 2. 获取相机平台标定时，各个基准位置处相机平台要移动的绝对位置
// 			//			std::vector< std::vector<CPlatformXYAxisPos*> > vppCameraMoveAxisPos;
// 			//			std::vector<CPlatformXYAxisPos*> vpCameraMoveAxisPos;
// 			//			int nPos = 0;
// 			//
// 			//			for (i=0; i<nCamPos; i++)
// 			//			{
// 			//				vpCameraMoveAxisPos.clear();
// 			//				GetCalibCamPlatformMovePos(i, vpCameraMoveAxisPos);
// 			//				vppCameraMoveAxisPos.push_back(vpCameraMoveAxisPos);
// 			//
// 			//				nPos = vpCameraMoveAxisPos.size();
// 			//			}
// 			//
// 			//			// 3. 单个相机平台在各个位置同时进行标定
// 			//			std::vector<CPlatformXYAxisPos*> vpAllCameraMoveAbsInThisPos;
// 			//			std::vector<CMarkImagePos*> vpAllCalibCameraSearchResult;
// 			//			std::vector<CPlatformXYAxisPos*> vpTemp;
// 			//			CMarkImagePos* pTemMarkImagePos = NULL;
// 			//
// 			//			vpAllCalibCameraSearchResult.clear();
// 			//
// 			//			for (int n=0; n<nPos; n++)
// 			//			{
// 			//				vpAllCameraMoveAbsInThisPos.clear();
// 			//
// 			//				// 获取各个相机在第n次移动时所对应的绝对位置
// 			//				for (k=0; k<nCamPos; k++)
// 			//				{
// 			//					vpAllCameraMoveAbsInThisPos.push_back(vppCameraMoveAxisPos[k].at(n));
// 			//				}					
// 			//
// 			//				pTemMarkImagePos = new CMarkImagePos;
// 			//				pTemMarkImagePos->SetMarkImagePosNum(nCamPos);
// 			//				for (k=0; k<nCamPos; k++)
// 			//				{
// 			//					vpTemp.clear();
// 			//					vpTemp.push_back(vpAllCameraMoveAbsInThisPos.at(k));
// 			//
// 			//					// 通信驱动相机平台移动到指定位置
// 			//					if (FALSE == CommuciateDriveCamPlatformAxisMove(vpTemp))
// 			//					{
// 			//						ReportCalibResult(FALSE);
// 			//
// 			//						m_bStatusBar = FALSE;
// 			//						m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_DRIVE_CAMERA_PLATFORM_TO_POS_FAILED), k);
// 			//						m_strStatusBarInfo2 = _T("");
// 			//						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 			//
// 			//						// 释放内存
// 			//						for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 			//						{
// 			//							if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 			//							{
// 			//								delete vpCamPlatformXYAxisPos.at(i);
// 			//								vpCamPlatformXYAxisPos.at(i) = NULL;
// 			//							}
// 			//						}
// 			//
// 			//						return FALSE;
// 			//					}
// 			//
// 			//					if (4 == n)
// 			//					{
// 			//						continue;
// 			//					}
// 			//
// 			//					// 调整该单相机的回调参数索引
// 			//					m_vpCamera.at(0)->Freeze();
// 			//					m_vpCamOwner.at(0)->m_nCamIndex = k;
// 			//					m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 			//					m_vpCamera.at(0)->Grab();
// 			//
// 			//					// 开启定位		
// 			//					// 					m_vbSearchSucceed[k]  = FALSE;
// 			//					// 					m_vbSearchFinished[k] = FALSE;	
// 			//					// 
// 			//					// 					StartSearch(eCalibSearch);
// 			//
// 			//					int nCameraIndex = k;
// 			//					std::vector<int> vCamIndex;
// 			//					std::vector<SearchMode> vsmSearchMode;
// 			//
// 			//					vCamIndex.push_back(nCameraIndex);
// 			//					vsmSearchMode.push_back(eCalibSearch);
// 			//
// 			//					StartSearch(vCamIndex,vsmSearchMode);
// 			//
// 			//					// 等待定位结束		
// 			//					while (FALSE == m_vbSearchFinished[k])
// 			//					{					
// 			//						// 等待定位结束时判断各相机是否在线，避免相机掉线后出现死循环
// 			//						if (!m_vpCamera.at(0)->IsOnline())
// 			//						{
// 			//							//CloseSearch();
// 			//							CloseSearch(vCamIndex);
// 			//							m_bStatusBar = FALSE;
// 			//							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// 			//							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// 			//							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 			//							return FALSE;
// 			//						}
// 			//						Sleep(10);
// 			//					}
// 			//
// 			//					// 分析定位结果，发送指令响应
// 			//					BOOL bSearchSucceed = FALSE;
// 			//
// 			//					bSearchSucceed = m_vbSearchSucceed[k];
// 			//
// 			//					if (FALSE == bSearchSucceed)
// 			//					{
// 			//						ReportCalibResult(FALSE);
// 			//
// 			//						m_bStatusBar = FALSE;
// 			//						m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_PLATFORM_POS_CALIB_SEARCH_FAILED), k);
// 			//						m_strStatusBarInfo2 = _T("");
// 			//						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 			//
// 			//						if (pTemMarkImagePos!=NULL)
// 			//						{
// 			//							delete pTemMarkImagePos;
// 			//							pTemMarkImagePos = NULL;
// 			//						}
// 			//
// 			//						for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 			//						{
// 			//							if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 			//							{
// 			//								delete vpCamPlatformXYAxisPos.at(i);
// 			//								vpCamPlatformXYAxisPos.at(i) = NULL;
// 			//							}
// 			//						}
// 			//
// 			//						// 关闭定位
// 			//						// CloseSearch();
// 			//						CloseSearch(vCamIndex);
// 			//						// 恢复该单相机的回调参数索引
// 			//						m_vpCamera.at(0)->Freeze();
// 			//						m_vpCamOwner.at(0)->m_nCamIndex = 0;
// 			//						m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 			//						m_vpCamera.at(0)->Grab();
// 			//
// 			//						return FALSE;
// 			//					}
// 			//
// 			//					// 关闭定位
// 			//					// CloseSearch();			
// 			//					CloseSearch(vCamIndex);		
// 			//					// 暂存定位结果
// 			//					pTemMarkImagePos->SetMarkImagePos(k, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(k), m_mpCalibMarkImagePos.GetMarkImagePos(k));
// 			//
// 			//				} 	
// 			//
// 			//				// 恢复该单相机的回调参数索引
// 			//				m_vpCamera.at(0)->Freeze();
// 			//				m_vpCamOwner.at(0)->m_nCamIndex = 0;
// 			//				m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0),GrabImageFinishedCallback);
// 			//				m_vpCamera.at(0)->Grab();
// 			//
// 			//				vpAllCalibCameraSearchResult.push_back(pTemMarkImagePos);
// 			//
// 			//				// 记录当前相机平台各个轴的绝对位置
// 			//				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 			//				{
// 			//					CString strTemp;
// 			//// 					CTime t = CTime::GetCurrentTime();
// 			//// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 			//
// 			//					CString strInfo;
// 			//					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CALIB_CAM_PLATFORM_CERTAIN_POS), n);
// 			//					strInfo = strTemp + strInfo;
// 			//
// 			//					for (int i=0; i<vpAllCameraMoveAbsInThisPos.size(); i++)
// 			//					{
// 			//						strTemp = _T("");
// 			//						strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpAllCameraMoveAbsInThisPos.at(i)->m_dPosX, vpAllCameraMoveAbsInThisPos.at(i)->m_dPosY);
// 			//						strInfo = strInfo + strTemp;
// 			//					}
// 			//
// 			//// 					FILE *stream;
// 			//// 					CString strPath = m_strAlignProcessData;
// 			//// 					stream = fopen(strPath, _T("a+t"));
// 			//// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 			//// 					fclose(stream);VCRemoveFile(strPath);	
// 			//
// 			//					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 			//					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 			//				}
// 			//
// 			//				// 记录图像搜索数据
// 			//				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 			//				{
// 			//					CString strTemp;
// 			//// 					CTime t = CTime::GetCurrentTime();
// 			//// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 			//
// 			//					CString strOut;
// 			//					CCoordPos cp;
// 			//					strOut = strTemp + _T("CalibSearch: ");	
// 			//					if (pTemMarkImagePos)
// 			//					{
// 			//						for (int i=0; i<pTemMarkImagePos->GetMarkImagePosNum(); i++)
// 			//						{
// 			//							strTemp = _T("");
// 			//							cp = pTemMarkImagePos->GetMarkImagePos(i);
// 			//
// 			//							strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
// 			//
// 			//							strOut += strTemp;
// 			//						}			
// 			//					}
// 			//
// 			//// 					FILE *stream;
// 			//// 					CString strPath = m_strAlignProcessData;
// 			//// 					stream = fopen(strPath, _T("a+t"));               
// 			//// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
// 			//// 					fclose(stream);VCRemoveFile(strPath);
// 			//
// 			//					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 			//					VisionAlignLogRecord(m_strAlignProcessData, strOut);
// 			//				}
// 			//
// 			//			}            
// 			//
// 			//			// 4. 将所有相机平台的所有定位结果设置入对位工具
// 			//			if(vpAllCalibCameraSearchResult.size() <= 0 ) 
// 			//			{
// 			//				ReportCalibResult(FALSE);
// 			//
// 			//				// 释放内存
// 			//				for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 			//				{
// 			//					if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 			//					{
// 			//						delete vpCamPlatformXYAxisPos.at(i);
// 			//						vpCamPlatformXYAxisPos.at(i) = NULL;
// 			//					}
// 			//				}
// 			//
// 			//				SaveCurAllCameraChannelSearchImg();
// 			//				return FALSE;
// 			//			}
// 			//			else
// 			//			{
// 			//				SetCalibCameraMoveSearchResult(vpAllCalibCameraSearchResult); 
// 			//			}	
// 			//
// 			//			// 5. 执行相机平台的标定计算
// 			//			if(FALSE == ExecuteCamPlatformCalibrate())
// 			//			{
// 			//				ReportCalibResult(FALSE);
// 			//
// 			//				m_bStatusBar = FALSE;
// 			//				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CAM_PLATFORM_CALCULATE_FAILED);
// 			//				m_strStatusBarInfo2 = _T("");
// 			//				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 			//
// 			//				// 释放内存
// 			//				for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 			//				{
// 			//					if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 			//					{
// 			//						delete vpCamPlatformXYAxisPos.at(i);
// 			//						vpCamPlatformXYAxisPos.at(i) = NULL;
// 			//					}
// 			//				}
// 			//
// 			//				SaveCurAllCameraChannelSearchImg();
// 			//				return FALSE;
// 			//			}
// 			//
// 			//
// 			//			// 释放内存
// 			//			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 			//			{
// 			//				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 			//				{
// 			//					delete vpCamPlatformXYAxisPos.at(i);
// 			//					vpCamPlatformXYAxisPos.at(i) = NULL;
// 			//				}
// 			//			}
// 			//		}
// 			//		break;
// 			//	case eCamPlatformShareX:
// 			//		break;
// 			//	default:
// 			//		break;				
// 			//	}
// 
// 			//////////////////////////////////////// 获取标定结果///////////////////////////////////////////
// 
// 			// 获取系统标定后的所有信息
// 			}
// 		//}//  [5/7/2020 zzc]
// 
// 		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 		vpAllCalibratedInfo = GetAllCalibratedInfo();
// 		//GYM-标定日志记录
// 		strOut = _T("");
// 		CalibrateLogRecord_Result(nCalibPos,CalibrateMoveRange,strOut,AnalysisResult);
// 		VisionAlignLogRecord(strCalibLogPath,strOut,FALSE);
// 		//GYM
// 
// 		//GYM-标定日志记录
// 		//标定数据汇总分析结果
// 		if (AnalysisResult.size()>6)
// 		{
// 			strOut.Empty();
// 			CString strTemp = _T("");
// 			strTemp.Format(_T("位置%d标定数据汇总分析结果:\n"),nRemCalibPos+1);
// 			strOut += strTemp;
// 			strTemp.Format(_T("%s"),AnalysisResult[0]);
// 			strOut += strTemp;
// 			strTemp.Format(_T("%s"),AnalysisResult[1]);
// 			strOut += strTemp;
// 			strTemp.Format(_T("......是否存在轴X重复性精度问题和反向间隙: %s"),AnalysisResult[2]);	//X方向最大距离差
// 			strOut += strTemp;
// 			strTemp.Format(_T("......是否存在轴Y重复性精度问题和反向间隙: %s"),AnalysisResult[3]);	//Y方向最大距离差
// 			strOut += strTemp;
// 			strTemp.Format(_T("......是否存在轴D重复性精度问题和反向间隙: %s"),AnalysisResult[4]);	//D方向最大距离差
// 			strOut += strTemp;
// 			strTemp.Format(_T("......是否存在细分问题: %s"),AnalysisResult[5]);
// 			strOut += strTemp;
// 			strTemp.Format(_T("%s"),AnalysisResult[6]);     // 标定时X、Y分别占相机视野的比例
// 			strOut += strTemp;
// 			VisionAlignLogRecord(strCalibLogPath,strOut,FALSE);
// 			/////GYM
// 		}
// 
// 
// 
// 		int nExProductIdx=nCalibPos/m_pPlatformInfo->m_nPositionNum;//扩展产品序号
// 
// 		if (!(optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode()== eWholeDmcodeBoardCalib && (sysPlatformInfo.m_eMidPlatformType != ePlatformX && sysPlatformInfo.m_eMidPlatformType != ePlatformXY && sysPlatformInfo.m_eMidPlatformType != ePlatformY)))
// 		{
// 			if (sysPlatformInfo.m_bEnableObjectCalibBench && (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum != nCalibPos))
// 			{
// 				if (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[m_pPlatformInfo->m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum] != NULL && vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->IsValid())
// 				{
// 					CPlatformXYDAxisPos*  pBenchPlatformAxisPos = (CPlatformXYDAxisPos* )vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->GetPlatformAxisPos();
// 					CPlatformXYDAxisPos * pCurrentPlatformAxisPos = (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
// 					CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 
// 
// 					double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
// 					double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;
// 
// 
// 					//平台各轴的方向	
// 					int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
// 					int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
// 
// 					if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
// 					if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;
// 
// 					CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->GetMarkPlatformCoordPos();
// 					CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();
// 
// 					currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
// 					currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;
// 
// 
// 
// 					vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
// 					vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
// 				}
// 
// 
// 			}
// 
// 			
// 		}
// 
// 		if(optionInfo.m_bAutoCopyCalibData)
// 		{
// 			//复制标定
// 
// 			ExecuteCopyCalibrateData(1,nExProductIdx);
// 		}
// 		else
// 		{
// 			/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 			SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 			// 保存标定后信息到当前产品中及配置文件中
// 			SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 		}
// 		// 保存目标定位结果信息
// 		m_bTargetMarkSearchSucceed = FALSE;	
// 		m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
// 		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
// 		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
// 
// 		// 保存标定位置为目标基准位置
// 		int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 		CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);
// 		if (TRUE == m_pPlatformInfo->m_bEnableTargetBench)
// 		{
// 			/*for (i = 0; i < vpAllCalibratedInfo.size(); i++)*/
// 			for (i=0; i<m_pPlatformInfo->m_nPositionNum && (i + nExProductIdx*m_pPlatformInfo->m_nPositionNum)< vpAllCalibratedInfo.size(); i++)
// 			{
// 				m_mpTargetMarkImagePos.m_vPos.at(i) = vpAllCalibratedInfo.at(i+ + nExProductIdx*m_pPlatformInfo->m_nPositionNum)->GetMarkImgCoordPos();
// 				m_mpTargetMarkImagePos.m_vbOK.at(i) = TRUE;
// 
// 				if (m_vpTargetPlatformAxisPos.at(i) != NULL)
// 				{
// 					*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i)) = *((CPlatformXYDAxisPos*)vpAllCalibratedInfo.at(i + nExProductIdx*m_pPlatformInfo->m_nPositionNum)->GetPlatformAxisPos());
// 					//				m_vpTargetPlatformAxisPos.at(i) = vpAllCalibratedInfo.at(i)->GetPlatformAxisPos();
// 				}
// 				else
// 				{
// 					m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
// 					*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i)) = *((CPlatformXYDAxisPos*)vpAllCalibratedInfo.at(i + nExProductIdx*m_pPlatformInfo->m_nPositionNum)->GetPlatformAxisPos());
// 				}
// 				{
// 					SetTargetPlatformPos(m_vpTargetPlatformAxisPos.at(i),i);
// 					SetTempTargetPlatformAxisPos(i,m_vpTargetPlatformAxisPos.at(i));
// 				}
// 			}
// 
// 			m_bTargetMarkSearchSucceed = TRUE;
// 			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
// 			SaveTargetPosInfo(nCurProductIndex);
// 
// 			// 设定、显示结果图形
// 			m_cVisionAlignGui.SetAllPosSearchResult(eTargetSearch);
// // 			SetAllGuiAlnTargetImageMarkPos();
// // 			PostMessageUpdateAllGuiAlnTargetImagePosGraphics(TRUE);
// // 
// // 			SetAllShowGuiTargetImageMarkPos();
// // 			PostMessageUpdateAllShowGuiTargetImagePosToDisplay(TRUE);
// 		}
// 
// 		//全局二维码标定时，当标定位置为选择的计算位置时，执行全局旋转中心计算
// 		if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode()== eWholeDmcodeBoardCalib && GetWholeCalibCacuPosEnable() && nRemCalibPos == GetWholeCalibCacuPos())
// 		{
// 			if (sysPlatformInfo.m_eMidPlatformType != ePlatformX && sysPlatformInfo.m_eMidPlatformType != ePlatformXY && sysPlatformInfo.m_eMidPlatformType != ePlatformY)
// 			{
// 
// 				BOOL bSuccess = ExecuteCalibWholeDmCodeBoard(nCalibPos);//执行全局旋转中心计算
// 				if (!bSuccess)
// 				{
// 					ReportCalibResult(FALSE);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					return FALSE;
// 				}
// 				else
// 				{
// 					m_bStatusBar = TRUE;
// 					m_strStatusBarInfo1 = _T("");
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_SUCCESS);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 				}
// 			}
// 			{
// 				std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 				vpAllCalibratedInfo = GetAllCalibratedInfo();
// 
// 				if (sysPlatformInfo.m_bEnableObjectCalibBench && (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum != nCalibPos))
// 				{
// 					if (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[m_pPlatformInfo->m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum] != NULL && vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->IsValid())
// 					{
// 						CPlatformXYDAxisPos*  pBenchPlatformAxisPos = (CPlatformXYDAxisPos* )vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->GetPlatformAxisPos();
// 						CPlatformXYDAxisPos * pCurrentPlatformAxisPos = (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
// 						CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 
// 
// 						double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
// 						double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;
// 
// 
// 						//平台各轴的方向	
// 						int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
// 						int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
// 
// 						if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
// 						if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;
// 
// 						CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*m_pPlatformInfo->m_nPositionNum]->GetMarkPlatformCoordPos();
// 						CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();
// 
// 						currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
// 						currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;
// 
// 
// 
// 						vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
// 						vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
// 					}
// 
// 
// 				}
// 
// 				if(optionInfo.m_bAutoCopyCalibData)
// 				{
// 					//复制标定
// 
// 					ExecuteCopyCalibrateData(1,nExProductIdx);
// 				}
// 				else
// 				{
// 					/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 					SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 					// 保存标定后信息到当前产品中及配置文件中
// 					SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 				}
// 			}
// 		
// 		}
// 	
// 	}
// 	return TRUE;
// }

//全局二维码靶标标定时，计算全局旋转中心
// BOOL vcXYDVisionAlign::ExecuteCalibWholeDmCodeBoard(int nCalibPos)
// {
// 	if (m_pAlignerTool == NULL)
// 	{
// 		return FALSE;
// 	}
// 	int nExProductIdx= nCalibPos/m_pPlatformInfo->m_nPositionNum;
// 	SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);
// 	BOOL bPickDiffPosSameCalib = sysPlatformInfo.m_bPlatformPick && sysPlatformInfo.m_bDiffPosWithSameCalibInfoEnabled && (sysPlatformInfo.m_nCamNum == 1);
// 	return m_pAlignerTool->ExecuteCalibWholeDmCodeBoard(nExProductIdx,bPickDiffPosSameCalib);
// }

//全局二维码靶标标定时，计算图像坐标到靶标坐标之间的映射关系
// BOOL vcXYDVisionAlign::ExecuteCalibWholeDmCodeBoardImgToBoard(int nPosIndex)
// {
// 	CString strInfo;
// 	strInfo.Format(_T("Pos%d执行全局二维码靶标图像到靶标映射开始-----------------------------"),nPosIndex);
// 	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 	VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 	int nRemCalibPos = nPosIndex%m_pPlatformInfo->m_nPositionNum;
// 	// 等待搜索延时
// 	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 	Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);
// 
// 	// 准备开始定位			
// 	std::vector<int> vnPosIndex;
// 	std::vector<SearchMode> vsmSearchMode;	
// 	vnPosIndex.push_back(nRemCalibPos);		// nCalibPos	
// 
// 
// 	vsmSearchMode.push_back(eCalibWholeDmcodeBoard);	// 标定搜索		
// 
// 
// 
// 	// 采集搜索图像
// 	if (!SnapSearchImage(vnPosIndex))
// 	{				
// 		ReportCalibResult(FALSE);				
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		strInfo.Format(_T("采集搜索图像失败"));
// 		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 		return FALSE;
// 	}
// 
// 	strInfo.Format(_T("采集搜索图像成功"));
// 	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 	VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 	// 定位	
// 
// 	m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
// 	m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;			
// 
// 	BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
// 	// 分析定位结果，发送指令响应
// 	if (FALSE == bSearchSucceed)
// 	{
// 		ReportCalibResult(FALSE);				
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = _T("");
// 		m_strStatusBarInfo2 = _T("二维码搜索失败"); 
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		strInfo.Format(_T("二维码搜索失败"));
// 		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 		return FALSE;
// 	}
// 
// 	strInfo.Format(_T("二维码搜索成功"));
// 	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 	VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 	std::vector<sc2Vector> vImagePos;
// 	std::vector<sc2Vector> vBoardPos;
// 	strInfo = _T("二维码角点图像坐标：");
// 	CString strTmp;
// 	
// 	m_vDmCodeCalibTool.at(nRemCalibPos).GetCornersImagePos(vImagePos);
// 	m_vDmCodeCalibTool.at(nRemCalibPos).GetCornersLabelPos(vBoardPos);
// 
// 	for (int i=0;i<vImagePos.size();i++)
// 	{
// 		strTmp.Format(_T(" %.3f,%.3f"),vImagePos.at(i).GetX(),vImagePos.at(i).GetY());
// 		strInfo += strTmp;
// 	}
// 	
// 	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 	VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 
// 	strInfo = _T("二维码角点靶标坐标：");
// 	for (int i=0;i<vBoardPos.size();i++)
// 	{
// 		strTmp.Format(_T(" %.3f,%.3f"),vBoardPos.at(i).GetX(),vBoardPos.at(i).GetY());
// 		strInfo += strTmp;
// 	}
// 	
// 	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 	VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 	//执行映射关系计算
// 	if (m_pAlignerTool == NULL || !m_pAlignerTool->ExecuteCalibrateWholeDmCodeBoardImgToBoard(nPosIndex,vImagePos,vBoardPos))
// 	{
// 		strInfo.Format(_T("图像到靶标坐标映射计算失败"));
// 		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 		VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 		return FALSE;
// 	}
// 
// 	strInfo.Format(_T("图像到靶标坐标映射计算成功"));
// 	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 	VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 	strInfo.Format(_T("Pos%d执行全局二维码靶标图像到靶标映射结束-----------------------------"),nPosIndex);
// 	VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 	VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 	return TRUE;
// }

BOOL  vcXYDVisionAlign::CommuciateGetBoardPosForTarFixOffset(std::vector<int> &vnPosIndex,std::vector<CCoordPos>& vBoardPos)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		vnPosIndex.clear();
		vBoardPos.clear();

		//////////////////////////////////////////////////////////////////////////
		// 读取寄存器
		CString strSend;

		// 打包读取寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcGetBoardPosForTarFixOffset(strSend))
		{
			return FALSE;
		}

		// 发送读取命令，接收PLC回复
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("通信获取目标平台坐标超时");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		// 解析收到的响应
		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetBoardPosForTarFixOffset(strInfo,vnPosIndex,vBoardPos);
		if (answeredStatus != eAswSucceed)
		{
			m_CommStatus = eCommUnConnect;

			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				// 读取寄存器
				CString strSend;

				// 打包读取寄存器指令
				if (FALSE == m_XYDCommProtocol.PackPlcGetBoardPosForTarFixOffset(strSend))
				{
					return FALSE;
				}

				// 发送读取命令，接收PLC回复
				BOOL bReceived;
				CString strInfo;
				CommStatus nCommStatus = eCommSucceed;
				bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = _T("通信获取目标平台坐标超时");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

				// 解析收到的响应
				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetBoardPosForTarFixOffset(strInfo,vnPosIndex,vBoardPos);

				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("解析获取目标平台坐标失败");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		else
		{
			// 获取时间	
			SYSTEMTIME tm;
			GetLocalTime(&tm);
			CString strTime;
			strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);

			CString strTranslateResultInfo;
			if (m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
			{
				strTranslateResultInfo = _T("输入:") + strTime  + strTranslateResultInfo;
				VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strCommunicationSimpleData, strTranslateResultInfo);
			}
		}

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL  vcXYDVisionAlign::CommuciateGetTargetImagePos(std::vector<int> &vnPosIndex,std::vector<CCoordPos>& vImagePos,std::vector<CPlatformXYDAxisPos> &vPlatformAxis)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		vnPosIndex.clear();
		vImagePos.clear();
		vPlatformAxis.clear();

		//////////////////////////////////////////////////////////////////////////
		// 读取寄存器
		CString strSend;

		// 打包读取寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcGetTargetImagePos(strSend))
		{
			return FALSE;
		}

		// 发送读取命令，接收PLC回复
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("通信获取目标平台坐标超时");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		// 解析收到的响应
		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetTargetImagePos(strInfo,vnPosIndex,vImagePos,vPlatformAxis);
		if (answeredStatus != eAswSucceed)
		{
			m_CommStatus = eCommUnConnect;

			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				// 读取寄存器
				CString strSend;

				// 打包读取寄存器指令
				if (FALSE == m_XYDCommProtocol.PackPlcGetTargetImagePos(strSend))
				{
					return FALSE;
				}

				// 发送读取命令，接收PLC回复
				BOOL bReceived;
				CString strInfo;
				CommStatus nCommStatus = eCommSucceed;
				bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = _T("通信获取目标平台坐标超时");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

				// 解析收到的响应
				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetTargetImagePos(strInfo,vnPosIndex,vImagePos,vPlatformAxis);

				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("解析获取目标平台坐标失败");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
BOOL  vcXYDVisionAlign::CommuciateGetTargetPlatformPos(std::vector<int> &vnPosIndex,std::vector<CCoordPos>& vCoordPos,std::vector<CPlatformXYDAxisPos> &vPlatformAxis)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		vnPosIndex.clear();
		vCoordPos.clear();
		vPlatformAxis.clear();

		//////////////////////////////////////////////////////////////////////////
		// 读取寄存器
		CString strSend;

		// 打包读取寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcGetTargetPlatformPos(strSend))
		{
			return FALSE;
		}

		// 发送读取命令，接收PLC回复
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("通信获取目标平台坐标超时");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		// 解析收到的响应
		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetTargetPlatformPos(strInfo,vnPosIndex,vCoordPos,vPlatformAxis);
		if (answeredStatus != eAswSucceed)
		{
			m_CommStatus = eCommUnConnect;


			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				// 读取寄存器
				CString strSend;

				// 打包读取寄存器指令
				if (FALSE == m_XYDCommProtocol.PackPlcGetTargetPlatformPos(strSend))
				{
					return FALSE;
				}

				// 发送读取命令，接收PLC回复
				BOOL bReceived;
				CString strInfo;
				CommStatus nCommStatus = eCommSucceed;
				bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = _T("通信获取目标平台坐标超时");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

				// 解析收到的响应
				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetTargetPlatformPos(strInfo,vnPosIndex,vCoordPos,vPlatformAxis);

				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("解析获取目标平台坐标失败");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

// 获取平台各轴的绝对位置
BOOL vcXYDVisionAlign::CommuciateGetPlatformAxisAbsPos(CPlatformXYDAxisPos* pPlatformXYDAxisPos,BOOL  bForceReadPlcReg /* = FALSE*/)
{
	CString strCmd = _T("");
	GetCommCommandName(strCmd);
	if (m_bIsExecuteFixTargetCheck || m_bIsExecuteSizeCheck)  //执行标定关联验证过程时,不算做指令报警
	{
		strCmd = _T("");
	}
	CString strTempWarningType = _T("");
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		if (NULL == pPlatformXYDAxisPos)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_AXISPOSERROR);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}

		CString strSimpleInfo;
		m_XYDCommProtocol.PackGetPlatformAbsPos(strSimpleInfo);;
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CmdAnsweredStatus answeredStatus;
		if(IsReadWriteAxisPosWithCmd() && m_XYDCommProtocol.m_bCmdAxisPosReady && !bForceReadPlcReg)
		{
			//TT 如果已经成功通过指令获取轴位置，则跳过通信
			*pPlatformXYDAxisPos = m_XYDCommProtocol.m_CurPlatformXYDAxisPos;
			m_XYDCommProtocol.m_bCmdAxisPosReady = FALSE;//已经获取了指令轴位置标志复位
			answeredStatus = eAswSucceed;
		}
		else
		{
			//TT 如果不是通过指令获取轴位置或者没有成功通过指令获取轴位置，则需要通过通信获取
			//////////////////////////////////////////////////////////////////////////
			// 读取寄存器
			CString strSend;

			// 打包读取寄存器指令
			if (FALSE == m_XYDCommProtocol.PackPlcGetPlatformAbsPos(strSend))
			{
				return FALSE;
			}

			// 发送读取命令，接收PLC回复
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}

			// 解析收到的响应
			/*CmdAnsweredStatus */answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetGetPlatformAbsPos(strInfo, pPlatformXYDAxisPos);
		}

		if (answeredStatus != eAswSucceed)
		{
			m_CommStatus = eCommUnConnect;
			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				// 读取寄存器
				CString strSend;

				// 打包读取寄存器指令
				if (FALSE == m_XYDCommProtocol.PackPlcGetPlatformAbsPos(strSend))
				{
					return FALSE;
				}

				// 发送读取命令，接收PLC回复
				BOOL bReceived;
				CString strInfo;
				CommStatus nCommStatus = eCommSucceed;
				bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;
				}

				// 解析收到的响应
				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetGetPlatformAbsPos(strInfo, pPlatformXYDAxisPos);
				std::vector<int> nParam;
				std::vector<double> dParam;
				nParam.push_back(0);
				dParam.push_back(pPlatformXYDAxisPos->m_dPosX);
				dParam.push_back(pPlatformXYDAxisPos->m_dPosY);
				dParam.push_back(pPlatformXYDAxisPos->m_dAngle);
				PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MNPSParam.m_strCmd,nParam,dParam);
				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_GET_PLATFORM_POS_ASW_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}
		else
		{
			std::vector<int> nParam;
			std::vector<double> dParam;
			nParam.push_back(0);
			dParam.push_back(pPlatformXYDAxisPos->m_dPosX);
			dParam.push_back(pPlatformXYDAxisPos->m_dPosY);
			dParam.push_back(pPlatformXYDAxisPos->m_dAngle);
			PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MNPSParam.m_strCmd,nParam,dParam);
		}
	}
	else
	{
		scTimer stPackandSendTimer; double dPackandSendTime(0.0);	
		stPackandSendTimer.Reset();

		if (NULL == pPlatformXYDAxisPos)
		{
			return FALSE;
		}

		CString strInfo;
		m_XYDCommProtocol.PackGetPlatformAbsPos(strInfo);
		if(FALSE == SendCommInfo(strInfo))
		{		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_GET_PLATFORM_POS_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

			return FALSE;
		}			

		CString str;
		dPackandSendTime=stPackandSendTimer.GetTimeMilli(FALSE);
		// 	str.Format("Get Position Pack and send time= %f",dPackandSendTime);
		// 	AlignLogRecord(str);
		BOOL bReceived;
		CString strReceived;

		m_tTimer.Reset();
		//	 Sleep(500);
		bReceived = ReceiveCommInfo(strReceived);

		if(bReceived)
		{
			AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
		}

		// 调试用
#ifdef BE_MANUAL
		AfxMessageBox(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_PLEASE_PLC_SEND_CUR_PLATFORM_POS));
#endif

		while (FALSE == bReceived)
		{
			if (TRUE == m_bStopNow)
				return FALSE;

			bReceived = ReceiveCommInfo(strReceived);

			if(bReceived)
			{
				AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
			}

			if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
			{			
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}        

			Sleep(2);
		}	

		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswGetGetPlatformAbsPos(strReceived, pPlatformXYDAxisPos);

		if (answeredStatus!=eAswSucceed)
		{		
			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				CString strInfo;
				m_XYDCommProtocol.PackGetPlatformAbsPos(strInfo);
				if(FALSE == SendCommInfo(strInfo))
				{		
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_GET_PLATFORM_POS_CMD_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

					return FALSE;
				}			

				CString str;
				dPackandSendTime=stPackandSendTimer.GetTimeMilli(FALSE);
				// 	str.Format("Get Position Pack and send time= %f",dPackandSendTime);
				// 	AlignLogRecord(str);
				BOOL bReceived;
				CString strReceived;

				m_tTimer.Reset();
				//	 Sleep(500);
				bReceived = ReceiveCommInfo(strReceived);

				if(bReceived)
				{
					AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
				}

				// 调试用
#ifdef BE_MANUAL
				AfxMessageBox(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_PLEASE_PLC_SEND_CUR_PLATFORM_POS));
#endif

				while (FALSE == bReceived)
				{
					if (TRUE == m_bStopNow)
						return FALSE;

					bReceived = ReceiveCommInfo(strReceived);

					if(bReceived)
					{
						AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
					}

					if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
					{			
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();

						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

						return FALSE;
					}        

					Sleep(2);
				}	

				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswGetGetPlatformAbsPos(strReceived, pPlatformXYDAxisPos);
				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}

			}

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_GET_PLATFORM_POS_ASW_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

			return FALSE;
		}		
	}

	// 	str.Format(" Get position Communicate Get answered Status time= %f",m_tTimer.GetTimeMilli(FALSE));
	// 	AlignLogRecord(str);
	return TRUE;

}

// 驱动平台各轴到指定位置
BOOL vcXYDVisionAlign::CommuciateDrivePlatformAxisMove2( CPlatformXYDAxisPos* pPlatformXYDAxisPos )
{  
	CString strCmd = _T("");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		if (NULL == pPlatformXYDAxisPos)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_AXISPOSERROR);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		//////////////////////////////////////////////////////////////////////////
		// 写要运动到轴位置
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcWriteDrivePlatformMoveToAbsPos(strSend, pPlatformXYDAxisPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DATA_PROCESS_INVALID);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PACK_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}	
	}
	else
	{
		;
	}
	// 	str.Format(" drive to  position Communicate Get answered Status time= %f",m_tTimer.GetTimeMilli(FALSE));
	// 	AlignLogRecord(str);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFALP(int nOffsetIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	CString str;
	CString strCmd = _T("VALP:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	CPlatformXYDAxisPos *pPlatformXYDAxisPos=NULL;
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());

	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

		//         m_bStatusBar = FALSE;
		//         m_strStatusBarInfo1 = _T("");
		//         m_strStatusBarInfo2 = _T("");
		//         SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
	{

		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

		//         m_bStatusBar = FALSE;
		//         m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		//         m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		//         SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		//         PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

		//         m_bStatusBar = FALSE;
		//         m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		//         m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		//         SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		//         PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{

		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

		//         m_bStatusBar = FALSE;
		//         m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		//         m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		//         SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		//         PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

			//             m_bStatusBar = FALSE;
			//             m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			//             m_strStatusBarInfo2 = _T("");
			//             SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			//             PostMessageUpdateStatusBarInfo();		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);

	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	// 	// 检查目标Mark是否已成功定位
	// 	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	// 	{
	// 		if (FALSE == m_bTargetMarkSearchSucceed)
	// 		{
	// 			ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);
	// 
	// 			m_bStatusBar = FALSE;
	// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
	// 			m_strStatusBarInfo2 = _T("");
	// 			PostMessageUpdateStatusBarInfo();		
	// 
	// 			return FALSE;
	// 		}
	// 	}

	//m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchExFOBJ();
	//m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(0);
	SysPlatformInfo platformInfo;
	GetSysPlatformInfo(platformInfo);
	//	CAlignerParam* pAlignerParam = GetProductAlignerParam();
	if( m_vpTargetPlatformAxisPos.size()==2 && platformInfo.m_bTargetPick)
	{
		if(optionInfo.m_bEnableMultiMarkMode)
		{
			m_bTargetMarkSearchSucceed = OnSingleCameraAlignerTargetSearchExFTGT(0);
		}
		else
		{
			std::vector<int> vnPosIndex;
			int nPosIndex = 0;
			for(int i = 0; i < GetPosNum(); i++)
			{
				vnPosIndex.push_back(i);
			}
			m_bTargetMarkSearchSucceed = OnSerialCameraAlignerTargetSearchExFTGT(vnPosIndex);
		}

	}

	if (((m_vpObjectPlatformAxisPos.size()== 2) && (*(CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0) == *(CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(1))/*&& m_bObjectMarkSearchSucceed == FALSE*/)
		|| (m_vpObjectPlatformAxisPos.size()== 2 && platformInfo.m_bTargetPick))
	{
		// 对于固定相机拾取模式和相机随轴运动一次拍照拾取模式，实际上没不会执行先FOBC再FALP，直接一次进行FALP，因此必须在FALP内部拍照对象
		// 如果增加m_bObjectMarkSearchSucceed为真的判断，当重新退出软件再打开或者切换产品时，InitAlignTool会将m_bObjectMarkSearchSucceed设置为真，上述判断会直接跳过，导致FALP时不再拍照
		// 对于相机随轴运动分位置拍照拾取模式，如果前面没有FOBC两次，在FALP再拍一次，实际上也是错的，因此必须在FALP前，先进行两次FOBC


		if (optionInfo.m_bEnableMultiMarkMode)
		{
			m_bObjectMarkSearchSucceed = OnSingleCameraAlignerObjectSearchCandidateExFOBC(0,0);
			if (m_bObjectMarkSearchSucceed)  //  jjh 0113
			{
				//				CalculateObjectDistance();
				if (!CheckObjectDistance())
				{
					ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //__T("对象距离超过设定标准，对象定位结果可能出错");
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					//					RecordObjectSizeIndfo(TRUE, FALSE);
					return FALSE;

				}

			}

			//
		}
		else
		{
			m_bObjectMarkSearchSucceed = OnSerialCameraAlignerObjectSearchCandidateExFOBC(0);
		}
	}

	if (FALSE ==m_bObjectMarkSearchSucceed )
	{
		CPlatformOptionInfo optionInfo;
		GetPlatformOptionInfo(optionInfo);
		/*if (TRUE == m_pSystempOptionConfig->m_bOmitRePickObjectEnable)*/
		if (TRUE == optionInfo.m_bOmitRePickObjectEnable)
		{
			// 如果搜索失败，且开启了忽略拾取失败功能，那么清空已有的搜索结果
			m_vObjectSearchedSeachResults.clear();
		}

		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;     			
	}
	if( m_vpTargetPlatformAxisPos.size()==2 && platformInfo.m_bTargetPick)
	{
		if(FALSE == m_bTargetMarkSearchSucceed)
		{
			ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}



	// 检查对象Mark是否已成功定位
	// 	if (FALSE == m_bObjectMarkSearchSucceed)
	// 	{
	// 
	// 		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
	// 		m_strStatusBarInfo2 = _T("");
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	// 		PostMessageUpdateStatusBarInfo();	
	// 
	// 		return FALSE;
	// 	}	


	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	// 执行对位计算
	if(platformInfo.m_bTargetPick)
	{
		m_pAlignerTool->SetPlatformPick(FALSE);
	}

	if(FALSE == ExecuteAlign())
	{

		ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
		//      m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
		//        SaveCurAllCameraChannelSearchImg();

		m_bObjectMarkSearchSucceed = FALSE;
		return FALSE;     
	}


	m_bObjectMarkSearchSucceed = FALSE;
	// 更新主界面对位精度、次数、对位总时间
	CCoordPos cp = GetAlignPlatformOffset();


	m_apAlignerProcesInfo.nTimes  = 1;

	m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
	m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
	m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
	m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

	dAlignTime=m_apAlignerProcesInfo.dTime;


	PostMessageUpdateAlignerProcessInfo();	

	MotionControlType TmpMotionControlType = eMCNo;
	CVisionASMConfig *vsConfig;
	GetVSconfig(vsConfig);
	if (NULL != vsConfig)
	{
		TmpMotionControlType = vsConfig->m_CommParamInfo.m_eMotionControlType;
	}
	// 针对于叠膜机出双模拾取应用，带运动控制的Yamaha机器人定制，将拾取绝对位置控制在一个小范围内（P101或P103）
	if (TmpMotionControlType == eMCYamahaRobot || TmpMotionControlType == eMCYamahaRobot340)
	{

	}
	else
	{
		CPlatformOptionInfo optionInfo;
		GetPlatformOptionInfo(optionInfo);
		//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
		//    || fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
		//    || fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
		if(IsAxisMoveOverRun(cp))
		{
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());   //chaiyongqiang20181022 修改在本次拾取超出最大移动量时返回的是上一次绝对位置的bug,获取最新对位位置
			ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
			m_strStatusBarInfo2.Format(_T(""));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
	}

	// 记录对位精度
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	{
		CString strTemp;
		CTime t = CTime::GetCurrentTime();
		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;					
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
		strOut = strTemp + strOut;

		FILE *stream;
		CString strPath = m_strAlignProcessData;
		stream = fopen(strPath, _T("a+t"));               
		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		fclose(stream);VCRemoveFile(strPath);	
	}

	// 记录对位时间
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
	{
		CString strTemp;
		CTime t = CTime::GetCurrentTime();
		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;						
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
		strOut = strTemp + strOut;

		FILE *stream;
		CString strPath = m_strAlignProcessData;
		stream = fopen(strPath, _T("a+t"));               
		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		fclose(stream);VCRemoveFile(strPath);					
	}	

	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());

	// 针对于叠膜机出双模拾取应用，带运动控制的Yamaha机器人定制，将拾取绝对位置控制在一个小范围内（P101或P103）
	if (TmpMotionControlType == eMCYamahaRobot || TmpMotionControlType == eMCYamahaRobot340)
	{
		BOOL bInTeachPosRange0 = FALSE;
		BOOL bInTeachPosRange1 = FALSE;
		if (pCurProductData->m_RobotTeachInfo.m_vbRobotTearchPosValid.size()>0 && pCurProductData->m_RobotTeachInfo.m_vbRobotTearchPosValid.at(0))
		{
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			// P101:拾取位置1
			/*if (fabs(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosX-pPlatformXYDAxisPos->m_dPosX) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosY-pPlatformXYDAxisPos->m_dPosY) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(scDegree(scDegree(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosR).Norm()-scDegree(pPlatformXYDAxisPos->m_dAngle).Norm()).SignedNorm().ToDouble()) > m_pSystempOptionConfig->m_dAxisMoveMaxD
			)*/
			//if (fabs(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosX-pPlatformXYDAxisPos->m_dPosX) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosY-pPlatformXYDAxisPos->m_dPosY) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(scDegree(scDegree(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosR).Norm()-scDegree(pPlatformXYDAxisPos->m_dAngle).Norm()).SignedNorm().ToDouble()) > optionInfo.m_dAxisMoveMaxD
			//	)
			if ((pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosX-pPlatformXYDAxisPos->m_dPosX) > optionInfo.m_dAxisMoveMaxX
				|| (pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosY-pPlatformXYDAxisPos->m_dPosY) > optionInfo.m_dAxisMoveMaxY
				|| (scDegree(scDegree(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosR).Norm()-scDegree(pPlatformXYDAxisPos->m_dAngle).Norm()).SignedNorm().ToDouble()) > optionInfo.m_dAxisMoveMaxD
				|| (pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosX-pPlatformXYDAxisPos->m_dPosX) < optionInfo.m_dAxisMoveMaxX_LowerLimit
				|| (pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosY-pPlatformXYDAxisPos->m_dPosY) < optionInfo.m_dAxisMoveMaxY_LowerLimit
				|| (scDegree(scDegree(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(0).m_dPosR).Norm()-scDegree(pPlatformXYDAxisPos->m_dAngle).Norm()).SignedNorm().ToDouble()) < optionInfo.m_dAxisMoveMaxD_LowerLimit
				)
			{
				bInTeachPosRange0 = FALSE;
			}
			else
			{
				bInTeachPosRange0 = TRUE;
			}
		}

		if (pCurProductData->m_RobotTeachInfo.m_vbRobotTearchPosValid.size()>1 && pCurProductData->m_RobotTeachInfo.m_vbRobotTearchPosValid.at(1))
		{
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			// P103:拾取位置2
			/*if (fabs(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosX-pPlatformXYDAxisPos->m_dPosX) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosY-pPlatformXYDAxisPos->m_dPosY) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(scDegree(scDegree(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosR).Norm()-scDegree(pPlatformXYDAxisPos->m_dAngle).Norm()).SignedNorm().ToDouble()) > m_pSystempOptionConfig->m_dAxisMoveMaxD
			)*/
			//if (fabs(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosX-pPlatformXYDAxisPos->m_dPosX) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosY-pPlatformXYDAxisPos->m_dPosY) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(scDegree(scDegree(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosR).Norm()-scDegree(pPlatformXYDAxisPos->m_dAngle).Norm()).SignedNorm().ToDouble()) > optionInfo.m_dAxisMoveMaxD
			//	)
			if ((pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosX-pPlatformXYDAxisPos->m_dPosX) > optionInfo.m_dAxisMoveMaxX
				|| (pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosY-pPlatformXYDAxisPos->m_dPosY) > optionInfo.m_dAxisMoveMaxY
				|| (scDegree(scDegree(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosR).Norm()-scDegree(pPlatformXYDAxisPos->m_dAngle).Norm()).SignedNorm().ToDouble()) > optionInfo.m_dAxisMoveMaxD
				|| (pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosX-pPlatformXYDAxisPos->m_dPosX) < optionInfo.m_dAxisMoveMaxX_LowerLimit
				|| (pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosY-pPlatformXYDAxisPos->m_dPosY) < optionInfo.m_dAxisMoveMaxY_LowerLimit
				|| (scDegree(scDegree(pCurProductData->m_RobotTeachInfo.m_vrpRobotTeachPos.at(2).m_dPosR).Norm()-scDegree(pPlatformXYDAxisPos->m_dAngle).Norm()).SignedNorm().ToDouble()) < optionInfo.m_dAxisMoveMaxD_LowerLimit
				)
			{
				bInTeachPosRange1 = FALSE;
			}
			else
			{
				bInTeachPosRange1 = TRUE;
			}
		}

		if (bInTeachPosRange0 || bInTeachPosRange1)
		{
			ReportAlignResultFALP(pPlatformXYDAxisPos,TRUE);

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			return TRUE;
		}
		else
		{
			ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
			m_strStatusBarInfo2.Format(_T(""));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;

		}
	}
	if(platformInfo.m_bTargetPick)
	{
		//如果拾取目标，提供产品相对偏移量
		CCoordPos coordPos = GetAlignProductOffset();

		m_apAlignerProcesInfo.dXOffset = coordPos.m_dPosX;
		m_apAlignerProcesInfo.dYOffset = coordPos.m_dPosY;
		m_apAlignerProcesInfo.dDOffset = coordPos.m_dAngle;

		m_apAlignerProcesInfo.dXMove = cp.m_dPosX;
		m_apAlignerProcesInfo.dYMove = cp.m_dPosY;
		m_apAlignerProcesInfo.dDMove = cp.m_dAngle;
		pPlatformXYDAxisPos->m_dPosX = cp.m_dPosX;
		pPlatformXYDAxisPos->m_dPosY = cp.m_dPosY;
		pPlatformXYDAxisPos->m_dAngle = cp.m_dAngle;

		m_apAlignerProcesInfo.nTimes = 1;
		PostMessageUpdateAlignerProcessInfo();


	}

	//	ReportAlignResultFALP(pPlatformXYDAxisPos,TRUE);
	if (TRUE == optionInfo.m_bLastPickSetting)
	{
		BOOL bLastPick = FALSE;
		int i = 0;
		for(i = 0; i < m_vnObjectSearchResultNumber.size(); i++)
		{
			if (m_vnObjectSearchResultNumber[i] == 1)
			{
				bLastPick = TRUE;
			}
			else
			{
				bLastPick = FALSE;
				break;
			}
		}
		//if (m_vnObjectSearchResultNumber[0] == 1 && m_vnObjectSearchResultNumber[1] == 1)
		if(bLastPick == TRUE)
		{
			ReportAlignResultNumberFALP(pPlatformXYDAxisPos,1);
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (TRUE == m_pSystempOptionConfig->m_bOmitRePickObjectEnable)*/
			if (TRUE == optionInfo.m_bOmitRePickObjectEnable)
			{
				// 如果搜索失败，且开启了忽略拾取失败功能，那么清空已有的搜索结果
				m_vObjectSearchedSeachResults.clear();
			}

		}
		else
		{
			ReportAlignResultFALP(pPlatformXYDAxisPos,TRUE);
		}
	}
	else
	{
		ReportAlignResultFALP(pPlatformXYDAxisPos,TRUE);
	}
	return TRUE;  


}

// 驱动平台各轴到指定位置
BOOL vcXYDVisionAlign::CommuciateDrivePlatformAxisMove( CPlatformXYDAxisPos* pPlatformXYDAxisPos )
{  
	CString strCmd = _T("");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		if (NULL == pPlatformXYDAxisPos)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_AXISPOSERROR);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}

		CString strSimpleInfo;
		m_XYDCommProtocol.PackDrivePlatformMoveToAbsPos(strSimpleInfo, pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		//////////////////////////////////////////////////////////////////////////
		// 写要运动到轴位置
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcWriteDrivePlatformMoveToAbsPos(strSend, pPlatformXYDAxisPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DATA_PROCESS_INVALID);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PACK_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}

		//////////////////////////////////////////////////////////////////////////
		// 写要开始运动指令
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcWriteDrivePlatformMove(strSend))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DATA_PROCESS_INVALID);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PACK_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

			return FALSE;
		}

		//////////////////////////////////////////////////////////////////////////
		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("设置视觉指令触发失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}


		//////////////////////////////////////////////////////////////////////////
		// 查询是否运动完整指令
		scTimer stTimer;
		stTimer.Reset();
		BOOL bMoveCompleted = FALSE;
		BOOL bMoveSuccess = FALSE;
		while(!bMoveCompleted)
		{
			if (TRUE == m_bStopNow)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = _T("软件停止运行！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				return FALSE;
			}


			//////////////////////////////////////////////////////////////////////////
			// 
			// 读取寄存器
			CString strSend;

			// 打包读取寄存器指令
			if (FALSE == m_XYDCommProtocol.PackPlcReadDrivePlatformMoveCompleted(strSend))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = _T("打包读取驱动平台移动指令失败!");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				return FALSE;
			}

			// 获取时间	
			SYSTEMTIME tm;
			GetLocalTime(&tm);
			CString strTime;	
			CString strSendLog;
			CString strRecLog;
			strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
			strSendLog = strTime + strSend;

			// 发送读取命令
			LockShareComm(); //加锁共享通信
			if (FALSE == SendCommInfo(strSend, FALSE))	
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = _T("发送平台移动指令失败！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				UnlockShareComm(); //解锁共享通信
				return FALSE;
			}

			// 接收PLC回复
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = ReceiveCommRepeat(strInfo, nCommStatus, FALSE);
			UnlockShareComm(); //解锁共享通信

			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
				strSendLog = strTime + strSend;

				// 再发一次
				// 发送读取命令
				LockShareComm(); //加锁共享通信
				if (FALSE == SendCommInfo(strSend, FALSE))	
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

					UnlockShareComm(); //解锁共享通信
					return FALSE;
				}

				// 接收PLC回复
				nCommStatus = eCommSucceed;
				bReceived = ReceiveCommRepeat(strInfo, nCommStatus, FALSE);
				UnlockShareComm(); //解锁共享通信

				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

					return FALSE;
				}
			}

			GetLocalTime(&tm);
			strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
			strRecLog = strTime + strInfo;

			// 解析收到的响应
			CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcDrivePlatformMoveCompleted(strInfo);
			if (answeredStatus == eAswSucceed)
			{	
				AddCommCommandInfo(TRUE, strSendLog, TRUE,TRUE);
				AddCommCommandInfo(FALSE, strRecLog, TRUE,TRUE);

				if (m_pVisionASMConfig)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
					{	
						CString strTemp;
						CString strOut =strTemp + _T("Receive:") + strInfo;

						strOut = _T("Send:") + strSendLog;
						VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationData, strOut);

						strOut = _T("Receive:") + strRecLog;
						VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationData, strOut);
					}
				}

				bMoveCompleted = TRUE;	
				bMoveSuccess = TRUE;
			}
			else if (answeredStatus == eAswUnkown)
			{
				AddCommCommandInfo(TRUE, strSendLog, TRUE,TRUE);
				AddCommCommandInfo(FALSE, strRecLog, TRUE,TRUE);

				if (m_pVisionASMConfig)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
					{	
						CString strTemp;
						CString strOut =strTemp + _T("Receive:") + strInfo;

						strOut = _T("Send:") + strSendLog;
						VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationData, strOut);

						strOut = _T("Receive:") + strRecLog;
						VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationData, strOut);
					}
				}

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				//m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_DRIVER_AXIS_FAILE);//_T("驱动平台轴移动失败");


				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_DRIVER_AXIS_RETURN_FAILE);//_T("驱动平台轴移动失败-返回非VMVA指令");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_DRIVER_AXIS_FAILE);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				bMoveCompleted = TRUE;	
				bMoveSuccess = FALSE;

			} 

			// 超时
			if (stTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
			{			

				AddCommCommandInfo(TRUE, strSendLog, TRUE,TRUE);
				AddCommCommandInfo(FALSE, strRecLog, TRUE,TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_DRIVE_PLATFORM_ARRIVED_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}  

			Sleep(1);
		}


		// 置Plc指令触发寄存器为0
		if (!ClearPlcPlatformTrigger())
		{	
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = _T("置Plc指令触发寄存器为0失败！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));




			return FALSE;
		}

		std::vector<int> nParam;
		std::vector<double>dParam;

		if (bMoveSuccess == FALSE)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_DRIVER_AXIS_FAILE);//_T("驱动平台轴移动失败");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_DRIVER_AXIS_FAILE);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			nParam.push_back(-1);
			PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MMVAParam.m_strCmd,nParam,dParam);
			return FALSE;
		}		

		nParam.push_back(0);
		PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MMVAParam.m_strCmd,nParam,dParam);
	}
	else
	{
		scTimer stPackandSendTimer; double dPackandSendTime(0.0);	
		stPackandSendTimer.Reset();

		if (NULL == pPlatformXYDAxisPos)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_AXISPOSERROR);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}

		CString strData;

		if (FALSE == m_XYDCommProtocol.PackDrivePlatformMoveToAbsPos(strData, pPlatformXYDAxisPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DATA_PROCESS_INVALID);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PACK_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}

		if (FALSE == SendCommInfo(strData))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}

		// 	if (TRUE == m_pSystempOptionConfig->m_bAlignOneTime)
		// 	{
		// 		return TRUE;
		// 	}

		CString str;
		dPackandSendTime=stPackandSendTimer.GetTimeMilli(FALSE);
		// 	str.Format("Dirve to position Pack and send time= %f",dPackandSendTime);
		// 	AlignLogRecord(str);

		BOOL bReceived;
		CString strReceived;

		m_tTimer.Reset();
		bReceived = ReceiveCommInfo(strReceived);

		if(bReceived)
		{
			AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
		}

		// 调试用
#ifdef BE_MANUAL
		AfxMessageBox(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_PLEASE_PLC_SEND_PLATFORM_ARRIVED_CMD));
#endif

		while (FALSE == bReceived)
		{
			if (TRUE == m_bStopNow)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = _T("软件停止运行！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;
			}
			bReceived = ReceiveCommInfo(strReceived);

			if(bReceived)
			{
				AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
			}

			if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
			{			
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_DRIVE_PLATFORM_ARRIVED_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				return FALSE;
			}  

			Sleep(2);
		}	

		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswDrivePlatformMoveToAbsPos(strReceived);

		if (answeredStatus!=eAswSucceed)
		{		
			int i = 0; 
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				CString strData;

				if (FALSE == m_XYDCommProtocol.PackDrivePlatformMoveToAbsPos(strData, pPlatformXYDAxisPos))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DATA_PROCESS_INVALID);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PACK_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;
				}

				if (FALSE == SendCommInfo(strData))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;
				}

				// 			if (TRUE == m_pSystempOptionConfig->m_bAlignOneTime)
				// 			{
				// 				return TRUE;
				// 			}

				CString str;
				dPackandSendTime=stPackandSendTimer.GetTimeMilli(FALSE);
				// 	str.Format("Dirve to position Pack and send time= %f",dPackandSendTime);
				// 	AlignLogRecord(str);

				BOOL bReceived;
				CString strReceived;

				m_tTimer.Reset();
				bReceived = ReceiveCommInfo(strReceived);

				if(bReceived)
				{
					AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
				}

				// 调试用
#ifdef BE_MANUAL
				AfxMessageBox(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_PLEASE_PLC_SEND_PLATFORM_ARRIVED_CMD));
#endif

				while (FALSE == bReceived)
				{
					if (TRUE == m_bStopNow)
						return FALSE;

					bReceived = ReceiveCommInfo(strReceived);

					if(bReceived)
					{
						AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
					}

					if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
					{			
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_DRIVE_PLATFORM_ARRIVED_ASW_OUTTIME);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
						return FALSE;
					}  

					Sleep(2);
				}	

				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswDrivePlatformMoveToAbsPos(strReceived);
				if (answeredStatus == eAswSucceed)
				{
					return TRUE;
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_DRIVE_PLATFORM_ARRIVED_ASW_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}		
	}


	// 	str.Format(" drive to  position Communicate Get answered Status time= %f",m_tTimer.GetTimeMilli(FALSE));
	// 	AlignLogRecord(str);
	return TRUE;
}


BOOL vcXYDVisionAlign::CommuciateGetProductSize(std::vector<CPlatformXYAxisPos*> vpProductSize)			 // 获取产品尺寸
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		if (0 == vpProductSize.size())
		{
			return FALSE;
		}

		CString strSimpleInfo;
		// 读取备份轴位置地址数据
		m_XYDCommProtocol.PackGetPlatformAbsPosBackup(strSimpleInfo);;
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		//////////////////////////////////////////////////////////////////////////
		// 读取寄存器
		CString strSend;

		// 打包读取寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcGetCamPlatformAbsInfo(strSend))
		{
			return FALSE;
		}

		// 发送读取命令，接收PLC回复
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PRODUCT_SIZE_ASW_OUTTIME);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		// 解析收到的响应
		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetCamPlatformAbsPos(strInfo, vpProductSize);
		if (answeredStatus != eAswSucceed)
		{
			m_CommStatus = eCommUnConnect;
			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				// 读取寄存器
				CString strSend;

				// 打包读取寄存器指令
				if (FALSE == m_XYDCommProtocol.PackPlcGetCamPlatformAbsInfo(strSend))
				{
					return FALSE;
				}

				// 发送读取命令，接收PLC回复
				BOOL bReceived;
				CString strInfo;
				CommStatus nCommStatus = eCommSucceed;
				bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PRODUCT_SIZE_ASW_OUTTIME);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

				// 解析收到的响应
				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetCamPlatformAbsPos(strInfo, vpProductSize);

				if (answeredStatus == eAswSucceed)
				{
					std::vector<int> nParam;
					std::vector<double> dParam;
					nParam.push_back(0);
					dParam.push_back(vpProductSize.at(0)->m_dPosX);
					dParam.push_back(vpProductSize.at(0)->m_dPosY);
					dParam.push_back(vpProductSize.at(1)->m_dPosX);
					dParam.push_back(vpProductSize.at(1)->m_dPosY);
					PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MPSBParam.m_strCmd,nParam,dParam);
					return TRUE;					
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_GET_PRODUCT_SIZE_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		else
		{
			std::vector<int> nParam;
			std::vector<double> dParam;
			nParam.push_back(0);
			dParam.push_back(vpProductSize.at(0)->m_dPosX);
			dParam.push_back(vpProductSize.at(0)->m_dPosY);
			dParam.push_back(vpProductSize.at(1)->m_dPosX);
			dParam.push_back(vpProductSize.at(1)->m_dPosY);
			PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MPSBParam.m_strCmd,nParam,dParam);
		}
	}
	else
	{
		CString strInfo;
		if (0 == vpProductSize.size())
		{
			return FALSE;
		}

		for (int i=0; i<vpProductSize.size(); i++)
		{
			if (NULL == vpProductSize.at(i))
			{
				return FALSE;
			}
		}
		m_XYDCommProtocol.PackGetPlatformAbsPosBackup(strInfo);

		if(FALSE == SendCommInfo(strInfo))
		{		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_GET_PRODUCT_SIZE_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}			

		BOOL bReceived;
		CString strReceived;

		m_tTimer.Reset();
		bReceived = ReceiveCommInfo(strReceived);

		if(bReceived)
		{
			AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
		}

		// 调试用
#ifdef BE_MANUAL
		AfxMessageBox(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_PLEASE_PLC_SEND_CUR_CAM_PLATFORM_POS));
#endif

		while (FALSE == bReceived)
		{
			if (TRUE == m_bStopNow)
				return FALSE;

			bReceived = ReceiveCommInfo(strReceived);

			if(bReceived)
			{
				AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
			}

			if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
			{			
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PRODUCT_SIZE_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}       

			Sleep(2);
		}	

		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswGetCamPlatformAbsPos(strReceived, vpProductSize);

		if (answeredStatus!=eAswSucceed)
		{				
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PRODUCT_SIZE_ASW_OUTTIME);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}			
	}

	return TRUE;
}

// 获取所有相机平台各轴的绝对位置
BOOL vcXYDVisionAlign::CommuciateGetCamPlatformAxisAbsPos( std::vector<CPlatformXYAxisPos*>& vpCamPlatformXYAxisPos )
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		if (0 == vpCamPlatformXYAxisPos.size())
		{
			return FALSE;
		}

		CString strSimpleInfo;
		m_XYDCommProtocol.PackGetPlatformAbsPosBackup(strSimpleInfo);;
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		//////////////////////////////////////////////////////////////////////////
		// 读取寄存器
		CString strSend;

		// 打包读取寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcGetCamPlatformAbsInfo(strSend))
		{
			return FALSE;
		}

		// 发送读取命令，接收PLC回复
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		// 解析收到的响应
		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetCamPlatformAbsPos(strInfo, vpCamPlatformXYAxisPos);
		if (answeredStatus != eAswSucceed)
		{
			m_CommStatus = eCommUnConnect;

			int i = 0;
			CCommOptionInfo commOptionInfo;
			GetCommOptionInfo(commOptionInfo);
			/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
			for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
			{
				// 读取寄存器
				CString strSend;

				// 打包读取寄存器指令
				if (FALSE == m_XYDCommProtocol.PackPlcGetCamPlatformAbsInfo(strSend))
				{
					return FALSE;
				}

				// 发送读取命令，接收PLC回复
				BOOL bReceived;
				CString strInfo;
				CommStatus nCommStatus = eCommSucceed;
				bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}

				// 解析收到的响应
				CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetCamPlatformAbsPos(strInfo, vpCamPlatformXYAxisPos);

				if (answeredStatus == eAswSucceed)
				{
					std::vector<int> nParam;
					std::vector<double> dParam;
					nParam.push_back(0);
					dParam.push_back(vpCamPlatformXYAxisPos.at(0)->m_dPosX);
					dParam.push_back(vpCamPlatformXYAxisPos.at(0)->m_dPosY);
					dParam.push_back(vpCamPlatformXYAxisPos.at(1)->m_dPosX);
					dParam.push_back(vpCamPlatformXYAxisPos.at(1)->m_dPosY);
					PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MPSBParam.m_strCmd,nParam,dParam);
					return TRUE;					
				}
			}
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_GET_PLATFORM_POS_ASW_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
		else
		{
			std::vector<int> nParam;
			std::vector<double> dParam;
			nParam.push_back(0);
			dParam.push_back(vpCamPlatformXYAxisPos.at(0)->m_dPosX);
			dParam.push_back(vpCamPlatformXYAxisPos.at(0)->m_dPosY);
			dParam.push_back(vpCamPlatformXYAxisPos.at(1)->m_dPosX);
			dParam.push_back(vpCamPlatformXYAxisPos.at(1)->m_dPosY);
			PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MPSBParam.m_strCmd,nParam,dParam);
		}
	}
	else
	{
		CString strInfo;
		if (0 == vpCamPlatformXYAxisPos.size())
		{
			return FALSE;
		}

		for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
		{
			if (NULL == vpCamPlatformXYAxisPos.at(i))
			{
				return FALSE;
			}
		}
		m_XYDCommProtocol.PackGetPlatformAbsPosBackup(strInfo);

		if(FALSE == SendCommInfo(strInfo))
		{		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_GET_CAM_PLATFORM_POS_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}			

		BOOL bReceived;
		CString strReceived;

		m_tTimer.Reset();
		bReceived = ReceiveCommInfo(strReceived);

		if(bReceived)
		{
			AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
		}

		// 调试用
#ifdef BE_MANUAL
		AfxMessageBox(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_PLEASE_PLC_SEND_CUR_CAM_PLATFORM_POS));
#endif

		while (FALSE == bReceived)
		{
			if (TRUE == m_bStopNow)
				return FALSE;

			bReceived = ReceiveCommInfo(strReceived);

			if(bReceived)
			{
				AddCommCommandInfo(FALSE,strReceived,FALSE,FALSE);
			}

			if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
			{			
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_CAM_PLATFORM_POS_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}       

			Sleep(2);
		}	

		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswGetCamPlatformAbsPos(strReceived, vpCamPlatformXYAxisPos);

		if (answeredStatus!=eAswSucceed)
		{				
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_GET_CAM_PLATFORM_POS_ASW_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}			
	}


	return TRUE;
}

// 驱动所有相机平台各轴到指定位置
BOOL vcXYDVisionAlign::CommuciateDriveCamPlatformAxisMove( std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos )
{
	if (0 == vpCamPlatformXYAxisPos.size())
	{
		return FALSE;
	}

	for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
	{
		if (NULL == vpCamPlatformXYAxisPos.at(i))
		{
			return FALSE;
		}
	}

	CString strData;

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{

		CString strSimpleInfo;
		//m_XYDCommProtocol.PackDriveCamPlatformMoveToAbsPos(strSimpleInfo, pCamPlatformPos);
		//AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		//////////////////////////////////////////////////////////////////////////
		// 写要运动到轴位置
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcWriteDriveCamPlatformMoveToAbsPos(strSend, vpCamPlatformXYAxisPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DATA_PROCESS_INVALID);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PACK_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		//////////////////////////////////////////////////////////////////////////
		// 写要开始运动指令
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcWriteDrivePlatformMove(strSend))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DATA_PROCESS_INVALID);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PACK_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		//////////////////////////////////////////////////////////////////////////
		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}


		//////////////////////////////////////////////////////////////////////////
		// 查询是否运动完整指令
		scTimer stTimer;
		stTimer.Reset();
		BOOL bMoveCompleted = FALSE;
		BOOL bMoveSuccess = FALSE;
		while(!bMoveCompleted)
		{
			if (TRUE == m_bStopNow)
				return FALSE;

			//////////////////////////////////////////////////////////////////////////
			// 
			// 读取寄存器
			CString strSend;

			// 打包读取寄存器指令
			if (FALSE == m_XYDCommProtocol.PackPlcReadDrivePlatformMoveCompleted(strSend))
			{
				return FALSE;
			}

			// 获取时间	
			SYSTEMTIME tm;
			GetLocalTime(&tm);
			CString strTime;	
			CString strSendLog;
			CString strRecLog;
			strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
			strSendLog = strTime + strSend;

			// 发送读取命令
			LockShareComm(); //加锁共享通信
			if (FALSE == SendCommInfo(strSend, FALSE))	
			{
				UnlockShareComm(); //解锁共享通信
				return FALSE;
			}

			// 接收PLC回复
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = ReceiveCommRepeat(strInfo, nCommStatus, FALSE);
			UnlockShareComm(); //解锁共享通信
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				// 				return FALSE;

				strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
				strSendLog = strTime + strSend;

				// 再发一次
				// 发送读取命令
				LockShareComm(); //加锁共享通信
				if (FALSE == SendCommInfo(strSend, FALSE))	
				{
					UnlockShareComm(); //解锁共享通信
					return FALSE;
				}

				// 接收PLC回复
				nCommStatus = eCommSucceed;
				bReceived = ReceiveCommRepeat(strInfo, nCommStatus, FALSE);
				UnlockShareComm(); //解锁共享通信
				if (bReceived == FALSE || nCommStatus != eCommSucceed)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
			}

			GetLocalTime(&tm);
			strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
			strRecLog = strTime + strInfo;

			// 解析收到的响应
			CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcDrivePlatformMoveCompleted(strInfo);
			if (answeredStatus == eAswSucceed)
			{	
				AddCommCommandInfo(TRUE, strSendLog, TRUE,TRUE);
				AddCommCommandInfo(FALSE, strRecLog, TRUE,TRUE);

				if (m_pVisionASMConfig)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
					{	
						CString strTemp;
						// 						CTime t = CTime::GetCurrentTime();
						// 						strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
						CString strOut =strTemp + _T("Receive:") + strInfo;

						// 						FILE *stream;		
						// 						stream = fopen(m_strCommunicationData, _T("a+t"));
						// 						strOut =strTemp + _T("Send:") + strSendLog;
						// 						fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
						// 						strOut =strTemp + _T("Receive:") + strRecLog;
						// 						fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
						// 						fclose(stream);	VCRemoveFile(m_strCommunicationData);	

						strOut = _T("Send:") + strSendLog;
						VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationData, strOut);

						strOut = _T("Receive:") + strRecLog;
						VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationData, strOut);
					}
				}

				bMoveCompleted = TRUE;	
				bMoveSuccess = TRUE;
			}
			else if (answeredStatus == eAswUnkown)
			{
				AddCommCommandInfo(TRUE, strSendLog, TRUE,TRUE);
				AddCommCommandInfo(FALSE, strRecLog, TRUE,TRUE);

				if (m_pVisionASMConfig)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
					{	
						CString strTemp;
						// 						CTime t = CTime::GetCurrentTime();
						// 						strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
						CString strOut =strTemp + _T("Receive:") + strInfo;

						// 						FILE *stream;		
						// 						stream = fopen(m_strCommunicationData, _T("a+t"));
						// 						strOut =strTemp + _T("Send:") + strSendLog;
						// 						fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
						// 						strOut =strTemp + _T("Receive:") + strRecLog;
						// 						fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
						// 						fclose(stream);	VCRemoveFile(m_strCommunicationData);	


						strOut = _T("Send:") + strSendLog;
						VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationData, strOut);

						strOut = _T("Receive:") + strRecLog;
						VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationData, strOut);
					}
				}

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_DRIVER_AXIS_FAILE);//_T("驱动平台轴移动失败");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				bMoveCompleted = TRUE;	
				bMoveSuccess = FALSE;

			} 

			// 超时
			if (stTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
			{			

				AddCommCommandInfo(TRUE, strSendLog, TRUE,TRUE);
				AddCommCommandInfo(FALSE, strRecLog, TRUE,TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_DRIVE_PLATFORM_ARRIVED_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}  

			Sleep(1);
		}


		// 置Plc指令触发寄存器为0
		if (!ClearPlcPlatformTrigger())
		{			
			return FALSE;
		}

		std::vector<int> nParam;
		std::vector<double>dParam;

		if (bMoveSuccess == FALSE)
		{
			nParam.push_back(-1);
			PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MMVAParam.m_strCmd,nParam,dParam);
			return FALSE;
		}		

		nParam.push_back(0);
		PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MMVAParam.m_strCmd,nParam,dParam);
		return TRUE;
	}
	else
	{
		if (FALSE == m_XYDCommProtocol.PackDriveCamPlatformMoveToAbsPos(strData, vpCamPlatformXYAxisPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DATA_PROCESS_INVALID);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PACK_DRIVE_ALL_CAM_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		if (FALSE == SendCommInfo(strData))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEND_DRIVE_ALL_CAM_PLATFORM_ARRIVED_CMD_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		BOOL bReceived;
		CString strReceived;

		m_tTimer.Reset();
		bReceived = ReceiveCommInfo(strReceived);

		// 调试用
#ifdef BE_MANUAL
		AfxMessageBox(GetSysInfoString(m_psaSysInfoStrings,IDS_MB_PLEASE_PLC_SEND_CUR_CAM_PLATFORM_ARRIVED_CMD));
#endif

		while (FALSE == bReceived)
		{
			if (TRUE == m_bStopNow)
				return FALSE;

			bReceived = ReceiveCommInfo(strReceived);

			if (m_tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
			{			
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_ALL_CAM_PLATFORM_ARRIVED_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}   

			Sleep(2);
		}	

		CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswDriveCamPlatformMoveToAbsPos(strReceived);

		if (answeredStatus!=eAswSucceed)
		{				
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_ALL_CAM_PLATFORM_ARRIVED_ASW_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}	


		return TRUE;
	}

}

BOOL vcXYDVisionAlign::ReportCamCalibResult(BOOL bResult)
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReCamCalibrateFCPR(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCamCalibrateFCPR(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCamCalibrateFCPR(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{

			return FALSE;
		}
	}

	return TRUE;
}


// 接受指令
BOOL vcXYDVisionAlign::ReceiveCommPlcReg(SysWorkCmdType& sysWorkCmdType)
{
	// 将串口内容清空
	CString strTemp;
	// 	while(ReceiveCommInfo(strTemp, TRUE))
	// 	{
	// 	}
	LockShareComm(); //加锁共享通信
	ReceiveCommInfo(strTemp, TRUE);
	UnlockShareComm(); //解锁共享通信

	//////////////////////////////////////////////////////////////////////////
	// 读取寄存器
	CString strSend;

	// 打包读取寄存器指令
	if (FALSE == m_XYDCommProtocol.PackPlcReadSysWorkCmd(strSend))
	{
		return FALSE;
	}

	CString ss;

	// 获取时间	
	SYSTEMTIME tm;
	GetLocalTime(&tm);
	CString strTime;	
	CString strSendLog;
	CString strRecLog;
	strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
	strSendLog = strTime + strSend;

	// 发送读取命令
	LockShareComm(); //加锁共享通信
	if (FALSE == SendCommInfo(strSend, FALSE))	
	{
		UnlockShareComm(); //解锁共享通信
		return FALSE;
	}

	// 接收PLC回复
	BOOL bReceived;
	CString strInfo;
	CommStatus nCommStatus = eCommSucceed;
	bReceived = ReceiveCommRepeat(strInfo, nCommStatus, FALSE);
	UnlockShareComm(); //解锁共享通信
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		CString strSendLog;
		CString tmpstr;
		int iplat= GetSysPlatformIndex();
		tmpstr.Format(_T("     bReceived=%d  nCommStatus=%d     平台序号%d"),bReceived,  nCommStatus, iplat);
		strSendLog =  strSend+_T("-------ReceiveCommPlcReg    ")+tmpstr;
		VisionAlignLogRecord(_T("D:\\VisionASMLog\\commErrorLog.txt"),strSendLog);
		return FALSE;

// 		if (m_bStopNow)
// 		{
// 			return FALSE;
// 		}
// 		//	return FALSE;
// 		// 再发一次
// 		strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
// 		strSendLog = strTime + strSend;
// 
// 		// 发送读取命令
// 		LockShareComm(); //加锁共享通信
// 		if (FALSE == SendCommInfo(strSend, FALSE))	
// 		{
// 			UnlockShareComm(); //解锁共享通信
// 			return FALSE;
// 		}
// 
// 		// 接收PLC回复
// 		nCommStatus = eCommSucceed;
// 		bReceived = ReceiveCommRepeat(strInfo, nCommStatus, FALSE);
// 		UnlockShareComm(); //解锁共享通信
// 		if (bReceived == FALSE || nCommStatus != eCommSucceed)
// 		{
// 			return FALSE;
// 		}
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);//_T("通信异常");
// 		m_strStatusBarInfo2 = _T("再次通信接收指令成功！")/*GetSysInfoString(m_psaSysInfoStrings,IDS_COMM_STOP_OR_TIMEOUT)*/;//_T("通信接收指令停止或超时！");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}

	GetLocalTime(&tm);
	strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
	strRecLog = strTime + strInfo;

	//////////////////////////////////////////////////////////////////////////
	// 基恩士串口PCLink通信：在PLC断电重启后，要先发送一个通信开始的指令，否则无法进行通信

	if (eProRegKeyenceSerialPCLink == m_XYDCommProtocol.GetProtocolType())
	{
		if (strInfo == "E1")
		{
			CString strSend = _T("CR");
			LockShareComm(); //加锁共享通信
			if (FALSE == SendCommInfo(strSend, FALSE))	
			{
				UnlockShareComm(); //解锁共享通信
				return FALSE;
			}

			AddCommCommandInfo(TRUE, strSend, TRUE,TRUE);

			CString strRecieve;
			bReceived = ReceiveCommRepeat(strRecieve,nCommStatus,FALSE);
			UnlockShareComm(); //解锁共享通信
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
				// 再发一次
// 				LockShareComm(); //加锁共享通信
// 				if (FALSE == SendCommInfo(strSend, FALSE))	
// 				{
// 					UnlockShareComm(); //解锁共享通信
// 					return FALSE;
// 				}
// 
// 				AddCommCommandInfo(TRUE, strSend, TRUE,TRUE);
// 
// 				bReceived = ReceiveCommRepeat(strRecieve,nCommStatus,FALSE);
// 				UnlockShareComm(); //解锁共享通信
// 				if (bReceived == FALSE || nCommStatus != eCommSucceed)
// 				{
// 					return FALSE;
// 				}
			}

			AddCommCommandInfo(FALSE, strRecieve, TRUE,TRUE);

			if (strRecieve == "CC")
			{
				return FALSE;
			}
		}
	}

	//////////////////////////////////////////////////////////////////////////

	// 解析收到的响应
	BOOL bTriggered = FALSE;
	sysWorkCmdType = m_XYDCommProtocol.AnalyzePlcSysWorkCmdReceived(strInfo, bTriggered);


	//////////////////////////////////////////////////////////////////////////
	// 判断指令是否触发
	if (bTriggered)
	{
		AddCommCommandInfo(TRUE, strSendLog, TRUE,TRUE);
		AddCommCommandInfo(FALSE, strRecLog, TRUE,TRUE);

		if (m_pVisionASMConfig)
		{
			if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
			{	
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
				CString strOut =strTemp + _T("Receive:") + strInfo;

				// 				FILE *stream;		
				// 				stream = fopen(m_strCommunicationData, _T("a+t"));
				// 				strOut =strTemp + _T("Send:") + strSendLog;
				// 				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 				strOut =strTemp + _T("Receive:") + strRecLog;
				// 				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 				fclose(stream);	VCRemoveFile(m_strCommunicationData);	

				strOut = _T("Send:") + strSendLog;
				VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strCommunicationData, strOut);

				strOut = _T("Rece:") + strRecLog;
				VisionAlignLogRecord(m_strCommunicationData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strCommunicationData, strOut);
			}
		}

		if (!ClearPlcPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;

}

// 循环读取通信接口数据		
BOOL vcXYDVisionAlign::ReceiveCommRepeat(CString& strInfo, CommStatus& nCommStatus, BOOL bLog/* = TRUE*/)
{
	// 接收上位机回复
	BOOL bReceived;
	scTimer tTimer;

	nCommStatus = eCommSucceed;

	tTimer.Reset();
	bReceived = ReceiveCommInfo(strInfo, FALSE, bLog);

	while (FALSE == bReceived)
	{
		if (m_bStopNow == TRUE)
		{
			return FALSE;
		}

		bReceived = ReceiveCommInfo(strInfo, FALSE, bLog);

		if (tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME || m_CommStatus != eCommSucceed)
		{			
			nCommStatus = eCommTimeOut;

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_COMM_STOP_OR_TIMEOUT);//_T("通信接收指令停止或超时！");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			Sleep(200);

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = _T("");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}   
		Sleep(1);
	}

	return TRUE;
}

// 发送读PLC寄存器字符串，并接收响应字符串
BOOL vcXYDVisionAlign::CommunicateSendReadRegStr(CString strSend, CString& strInfo, CommStatus& nCommStatus, BOOL bLog/* = TRUE*/)
{
	// 发送读取命令
	LockShareComm(); //加锁共享通信
	if (FALSE == SendCommInfo(strSend, bLog))	
	{
		AddWarningInfo("读寄存器", "发送读寄存器失败");
		UnlockShareComm(); //解锁共享通信
		return FALSE;
	}

	// 接收PLC回复
	BOOL bReceived;
	bReceived = ReceiveCommRepeat(strInfo, nCommStatus, bLog);
	UnlockShareComm(); //解锁共享通信
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		AddWarningInfo("读寄存器", "接收读寄存器状态数据失败");
		CString strSendLog;
		CString tmpstr;
		int iplat= GetSysPlatformIndex();
		tmpstr.Format(_T("     bReceived=%d  nCommStatus=%d     平台序号%d"),bReceived,  nCommStatus, iplat);
		strSendLog =  strSend+_T("-------CommunicateSendReadRegStr    ")+tmpstr;
		VisionAlignLogRecord(_T("D:\\VisionASMLog\\commErrorLog.txt"),strSendLog);
		return FALSE;
	}

	return TRUE;
}

// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
BOOL vcXYDVisionAlign::CommunicateSendWriteRegStr(CString strSend, CString& strInfo, CommStatus& nCommStatus)
{
	if(strSend.GetLength() == 0)
	{//TT 如果要发送的内容为空则直接返回
		nCommStatus = eCommSucceed;
		return TRUE;
	}
	CString strTranslateResultInfo;
	CString strTmpTranslateInfo;
	m_XYDCommProtocol.GetTranslateResultInfo(strTmpTranslateInfo,FALSE);
	// 发送读取命令	
	LockShareComm(); //加锁共享通信
	if (FALSE == SendCommInfo(strSend))	
	{
		AddWarningInfo("写寄存器", "发送写寄存器失败");

		UnlockShareComm(); //解锁共享通信
		return FALSE;
	}
	// 接收PLC回复
	BOOL bReceived;
	bReceived = ReceiveCommRepeat(strInfo, nCommStatus);
	UnlockShareComm(); //解锁共享通信
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		AddWarningInfo("写寄存器", "接受写寄存器返回状态数据失败");
		CString strSendLog;
		CString tmpstr;
		int iplat= GetSysPlatformIndex();
		tmpstr.Format(_T("     bReceived=%d  nCommStatus=%d     平台序号%d"),bReceived,  nCommStatus, iplat);
		strSendLog =  strSend+_T("-------CommunicateSendWriteRegStr    ")+tmpstr;
		VisionAlignLogRecord(_T("D:\\VisionASMLog\\commErrorLog.txt"),strSendLog);
		m_XYDCommProtocol.SetTranslateResultInfo(strTmpTranslateInfo);
		return FALSE;
	}



	// 获取时间	
	SYSTEMTIME tm;
	GetLocalTime(&tm);
	CString strTime;
	strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);

	// 解析收到的响应
	if (eAswSucceed != m_XYDCommProtocol.AnalyzeAswPlcWriteReg(strInfo))
	{
		// 写回复出现异常，说明通信已经异常，状态变更，执行reOpenComm
		m_CommStatus = eCommUnConnect;

		AddWarningInfo("写寄存器", "接受写寄存器返回状态失败");

		if (m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
		{
			strTranslateResultInfo = _T("输入:") + strTime + strTranslateResultInfo + strInfo;
			VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strCommunicationSimpleData, strTranslateResultInfo);
		}
		return FALSE;
	}

	if (m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
	{
		strTranslateResultInfo = _T("输入:") + strTime  + strTranslateResultInfo;
		VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strCommunicationSimpleData, strTranslateResultInfo);
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CommunicateWriteReg(std::vector<int> vnTotalSend, CString& strInfo, CommStatus& nCommStatus
	,int nRegAddr,bool bRegType,bool bOffsetAddr)
{
	int nMaxSendNumSingleSend = 100; //单次最大可发送数量
	int nSizeSingleData = /*m_XYDCommProtocol.m_bRegType*/bRegType ? 2 : 1;
	if(m_pVisionASMConfig->m_pCommParam->GetCommType() == eSocket && ((vcSocketCommInfo*)m_pVisionASMConfig->m_pCommParam)->m_lWriteRegMaxNum >= 2)
	{//根据通信参数确定每次最大可发送几个数据-网口
		nMaxSendNumSingleSend = ((vcSocketCommInfo*)m_pVisionASMConfig->m_pCommParam)->m_lWriteRegMaxNum / nSizeSingleData;
	}
	else if(m_pVisionASMConfig->m_pCommParam->GetCommType() == eSerial && ((vcSerialCommInfo*)m_pVisionASMConfig->m_pCommParam)->m_lWriteRegMaxNum >= 2)
	{//根据通信参数确定每次最大可发送几个数据-串口
		nMaxSendNumSingleSend = ((vcSerialCommInfo*)m_pVisionASMConfig->m_pCommParam)->m_lWriteRegMaxNum / nSizeSingleData;
	}
	int nNeedSendTimes = (vnTotalSend.size()+nMaxSendNumSingleSend - 1)/nMaxSendNumSingleSend;//需要发送的次数
	for(int i = 0;i < nNeedSendTimes; i++)
	{
		CString strSend;
		std::vector<int> vnSend;
		if(vnTotalSend.size() - i * nMaxSendNumSingleSend > nMaxSendNumSingleSend)
		{//未发送数量超过单次最大可发送数量
			vnSend.insert(vnSend.begin(),vnTotalSend.begin() + i * nMaxSendNumSingleSend,
				vnTotalSend.begin() + (i + 1) * nMaxSendNumSingleSend);
		}
		else
		{
			vnSend.insert(vnSend.begin(),vnTotalSend.begin() + i * nMaxSendNumSingleSend,
				vnTotalSend.end());
		}
		int nTempRegAddr = nRegAddr + nSizeSingleData * nMaxSendNumSingleSend * i;
		m_XYDCommProtocol.PackPlcWriteReg(strSend,vnSend,nTempRegAddr,bRegType,bOffsetAddr);

		CString strTranslateResultInfo;
		CString strTmpTranslateInfo;
		m_XYDCommProtocol.GetTranslateResultInfo(strTmpTranslateInfo,FALSE);


		// 发送读取命令	
		LockShareComm(); //加锁共享通信
		if (FALSE == SendCommInfo(strSend))	
		{
			UnlockShareComm(); //解锁共享通信
			return FALSE;
		}

		// 接收PLC回复
		BOOL bReceived;
		bReceived = ReceiveCommRepeat(strInfo, nCommStatus);
		UnlockShareComm(); //解锁共享通信
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;

// 			m_XYDCommProtocol.SetTranslateResultInfo(strTmpTranslateInfo);
// 
// 			//return FALSE;
// 			// 再发一次
// 			// 发送读取命令
// 			LockShareComm(); //加锁共享通信
// 			if (FALSE == SendCommInfo(strSend))	
// 			{
// 				UnlockShareComm(); //解锁共享通信
// 				return FALSE;
// 			}
// 
// 			// 接收PLC回复
// 			bReceived = ReceiveCommRepeat(strInfo, nCommStatus);
// 			UnlockShareComm(); //解锁共享通信
// 			if (bReceived == FALSE || nCommStatus != eCommSucceed)
// 			{
// 				return FALSE;
// 			}
		}



		// 获取时间	
		SYSTEMTIME tm;
		GetLocalTime(&tm);
		CString strTime;
		strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);

		// 解析收到的响应
		if (eAswSucceed != m_XYDCommProtocol.AnalyzeAswPlcWriteReg(strInfo))
		{
			if (m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
			{
				strTranslateResultInfo = _T("输入:") + strTime + strTranslateResultInfo;
				VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strCommunicationSimpleData, strTranslateResultInfo);
			}
			return FALSE;
		}

		if (m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
		{
			strTranslateResultInfo = _T("输入:") + strTime  + strTranslateResultInfo;
			VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strCommunicationSimpleData, strTranslateResultInfo);
		}

	}
	return TRUE;


}

BOOL vcXYDVisionAlign::ClearPlcPlatformTrigger()
{
	//////////////////////////////////////////////////////////////////////////
	// 写PLC指令触发寄存器清零
	CString strSend;
	// 打包写寄存器指令
	if (FALSE == m_XYDCommProtocol.PackPlcWriteSetPlcCmdTrigger(strSend, FALSE))
	{
		return FALSE;
	}

	// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
	BOOL bReceived;
	CString strInfo;
	CommStatus nCommStatus = eCommSucceed;
	bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::SetVisionPlatformTrigger()
{
	//////////////////////////////////////////////////////////////////////////
	// 写Vision指令触发寄存器置1
	CString strSend;
	// 打包写寄存器指令
	if (FALSE == m_XYDCommProtocol.PackPlcWriteSetVisionCmdTrigger(strSend, TRUE))
	{
		return FALSE;
	}

	// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
	BOOL bReceived;
	CString strInfo;
	CommStatus nCommStatus = eCommSucceed;
	bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		return FALSE;
	}

	return TRUE;
}
BOOL vcXYDVisionAlign::SetPlcManualSearch(BOOL bShow)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		//////////////////////////////////////////////////////////////////////////
		// 写PLC指令触发寄存器清零
		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcWriteSetManualSearch(strSend, bShow))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}
	}

	return TRUE;
}


// 通信握手
BOOL  vcXYDVisionAlign::CommShakeHands()
{
	//////////////////////////////////////////////////////////////////////////
	// 通信握手
	CString strSend;
	// 打包写寄存器指令
	if (FALSE == m_XYDCommProtocol.PackPlcShakeHands(strSend))
	{
		return FALSE;
	}

	// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
	BOOL bReceived;
	CString strInfo;
	CommStatus nCommStatus = eCommSucceed;
	bReceived = CommunicateSendShakeHandsStr(strSend, strInfo, nCommStatus);
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		return FALSE;
	}

	return TRUE;
}
// 发送写PLC寄存器握手字符串，并接收解析PLC的响应字符串是否正确
BOOL vcXYDVisionAlign::CommunicateSendShakeHandsStr(CString strSend, CString& strInfo, CommStatus& nCommStatus)
{
	CString strTranslateResultInfo;
	CString strTmpTranslateInfo;
	m_XYDCommProtocol.GetTranslateResultInfo(strTmpTranslateInfo,FALSE);

	// 发送读取命令
	LockShareComm(); //加锁共享通信
	if (FALSE == SendCommInfo(strSend))	
	{
		UnlockShareComm(); //解锁共享通信
		return FALSE;
	}

	// 接收PLC回复
	BOOL bReceived;
	bReceived = ReceiveCommRepeat(strInfo, nCommStatus);
	UnlockShareComm(); //解锁共享通信
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		return FALSE;

// 		m_XYDCommProtocol.SetTranslateResultInfo(strTmpTranslateInfo);
// 
// 		//return FALSE;
// 		// 再发一次
// 		// 发送读取命令
// 		LockShareComm(); //加锁共享通信
// 		if (FALSE == SendCommInfo(strSend))	
// 		{
// 			UnlockShareComm(); //解锁共享通信
// 			return FALSE;
// 		}
// 
// 		// 接收PLC回复
// 		bReceived = ReceiveCommRepeat(strInfo, nCommStatus);
// 		UnlockShareComm(); //解锁共享通信
// 		if (bReceived == FALSE || nCommStatus != eCommSucceed)
// 		{
// 			return FALSE;
// 		}
	}

	// 获取时间	
	SYSTEMTIME tm;
	GetLocalTime(&tm);
	CString strTime;
	strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);

	// 解析收到的响应
	if (eAswSucceed != m_XYDCommProtocol.AnalyzeAswPlcShakeHands(strInfo))
	{
		if (m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
		{
			strTranslateResultInfo = _T("输入:") + strTime + strTranslateResultInfo;
			VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strCommunicationSimpleData, strTranslateResultInfo);
		}
		return FALSE;
	}

	if (m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
	{
		strTranslateResultInfo = _T("输入:") + strTime  + strTranslateResultInfo;
		VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strCommunicationSimpleData, strTranslateResultInfo);
	}

	return TRUE;
}



BOOL vcXYDVisionAlign::OnlineProductEmptyFPEP(int nProductIndexFa, int nProductIndexChd)
{
	// 判断大品种索引是否超限
	int nCountFa = m_pVisionASMConfig->m_TotalProductData.GetProductCountFa();
	if(nProductIndexFa < 0 || nProductIndexFa >= nCountFa)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种清空失败");
		m_strStatusBarInfo2.Format(_T("大品种索引%d超限"), nProductIndexFa+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductEmptyFPEP(FALSE);
		return TRUE;
	}

	// 判断小品种索引是否超限
	int nCountChd = m_pVisionASMConfig->m_TotalProductData.GetProductCountChd(nProductIndexFa);
	if(nProductIndexChd < -1 || nProductIndexChd >= nCountChd)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种清空失败");
		m_strStatusBarInfo2.Format(_T("小品种索引%d超限"), nProductIndexChd+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductEmptyFPEP(FALSE);
		return TRUE;
	}

	// 如果非大品种复制，判断全部品种索引是否超限
	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nProductIndexFa, nProductIndexChd);
	int nCount = m_pVisionASMConfig->m_TotalProductData.GetCount();
	if((nProductIndexChd != -1) && (nProductIndex < 0 || nProductIndex >= nCount))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种清空失败");
		m_strStatusBarInfo2.Format(_T("全部品种索引%d超限"), nProductIndex+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductEmptyFPEP(FALSE);
		return TRUE;
	}

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	if ((!sysPlatformInfo.m_bProductFaChd) || (nProductIndexChd == -1)) // 大品种清空
	{
		for(int i=0; i<nCountChd; i++)
		{
			nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nProductIndexFa, i);
			if (!ProductEmpty(nProductIndex))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = _T("品种清空失败");
				m_strStatusBarInfo2.Format(_T("大品种%d,小品种%d,全部品种%d"), nProductIndexFa+1, i+1, nProductIndex+1);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				PostMessageUpdateCurProductAlignInfo();
				ReportProductEmptyFPEP(FALSE);
				return TRUE;
			}
		}

		// 清空产品界面大品种名称
		CString strNewName = _T("------");
		m_pVisionASMConfig->m_TotalProductData.SetProductNameFa(nProductIndexFa, strNewName);
		SaveTotalProductDataInfo(FALSE);
		// 清空标定界面大品种名称
		m_pVisionASMConfig->m_TotalCalibData.SetCalibNameFa(nProductIndexFa, strNewName);
		SaveTotalCalibDataInfo(FALSE);
	}
	else // 小品种清空
	{
		if (!ProductEmpty(nProductIndex))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("品种清空失败");
			m_strStatusBarInfo2.Format(_T("大品种%d,小品种%d,全部品种%d"), nProductIndexFa+1, nProductIndexChd+1, nProductIndex+1);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			PostMessageUpdateCurProductAlignInfo();
			ReportProductEmptyFPEP(FALSE);
			return TRUE;
		}

		//// 不启用大小品种时，清空小品种即为清空大品种，需要对大品种名称还原默认值
		//SysPlatformInfo sysPlatformInfo;
		//GetSysPlatformInfo(sysPlatformInfo);
		//if (!sysPlatformInfo.m_bProductFaChd)
		//{
		//	// 清空产品界面大品种名称
		//	CString strNewName = _T("------");
		//	m_pVisionASMConfig->m_TotalProductData.SetProductNameFa(nProductIndexFa, strNewName);
		//	SaveTotalProductDataInfo(FALSE);
		//	// 清空标定界面大品种名称
		//	m_pVisionASMConfig->m_TotalCalibData.SetCalibNameFa(nProductIndexFa, strNewName);
		//	SaveTotalCalibDataInfo(FALSE);
		//}
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("品种清空成功");
	m_strStatusBarInfo2.Format(_T("大品种%d,小品种%d"), nProductIndexFa+1, nProductIndexChd+1);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	PostMessageUpdateCurProductAlignInfo();
	ReportProductEmptyFPEP(TRUE);

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportProductEmptyFPEP(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 指令解析
		CString strSimpleInfo; 
		m_XYDCommProtocol.PackReClearProductFPEP(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcClearProductFPEP(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReClearProductFPEP(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineProductCopyFPCP(int nSrcProductIndexFa, int nSrcProductIndexChd, int nDstProductIndexFa, int nDstProductIndexChd)
{
	// 如果来源和目的的大小品种索引都相同，则直接返回成功
	if(nSrcProductIndexFa == nDstProductIndexFa && nSrcProductIndexChd == nDstProductIndexChd)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = _T("品种复制成功");
		m_strStatusBarInfo2 = _T("来源和目的品种索引完全相同");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductCopyFPCP(TRUE);
		return TRUE;
	}

	// 如果复制大品种，则要求来源和目的的小品种索引都是0（指令是0，本函数是-1）
	if((nSrcProductIndexChd == -1 && nDstProductIndexChd != -1) || (nSrcProductIndexChd != -1 && nDstProductIndexChd == -1))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种复制失败");
		m_strStatusBarInfo2.Format(_T("来源小品种索引%d和目的小品种索引%d,应都为0或都不为0"), nSrcProductIndexChd+1, nDstProductIndexChd+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductCopyFPCP(FALSE);
		return TRUE;
	}

	// 判断来源大品种索引是否超限
	int nCountFa = m_pVisionASMConfig->m_TotalProductData.GetProductCountFa();
	if(nSrcProductIndexFa < 0 || nSrcProductIndexFa >= nCountFa)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种复制失败");
		m_strStatusBarInfo2.Format(_T("来源大品种索引%d超限"), nSrcProductIndexFa+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductCopyFPCP(FALSE);
		return TRUE;
	}

	// 判断来源小品种索引是否超限
	int nSrcCountChd = m_pVisionASMConfig->m_TotalProductData.GetProductCountChd(nSrcProductIndexFa);
	if(nSrcProductIndexChd < -1 || nSrcProductIndexChd >= nSrcCountChd)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种复制失败");
		m_strStatusBarInfo2.Format(_T("来源小品种索引%d超限"), nSrcProductIndexChd+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductCopyFPCP(FALSE);
		return TRUE;
	}

	// 如果非大品种复制，判断来源全部品种索引是否超限
	int nSrcProductIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nSrcProductIndexFa, nSrcProductIndexChd);
	int nCount = m_pVisionASMConfig->m_TotalProductData.GetCount();
	if((nSrcProductIndexChd != -1) && (nSrcProductIndex < 0 || nSrcProductIndex >= nCount))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种复制失败");
		m_strStatusBarInfo2.Format(_T("来源全部品种索引%d错误"), nSrcProductIndex+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductCopyFPCP(FALSE);
		return TRUE;
	}

	// 判断目的大品种索引是否超限
	if(nDstProductIndexFa < 0 || nDstProductIndexFa >= nCountFa)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种复制失败");
		m_strStatusBarInfo2.Format(_T("目的大品种索引%d超限"), nDstProductIndexFa+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductCopyFPCP(FALSE);
		return TRUE;
	}

	// 判断目的小品种索引是否超限
	int nDstCountChd = m_pVisionASMConfig->m_TotalProductData.GetProductCountChd(nDstProductIndexFa);
	if(nDstProductIndexChd < -1 || nDstProductIndexChd >= nDstCountChd)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种复制失败");
		m_strStatusBarInfo2.Format(_T("目的小品种索引%d超限"), nDstProductIndexChd+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductCopyFPCP(FALSE);
		return TRUE;
	}

	// 如果非大品种复制，判断目的全部品种索引是否超限
	int nDstProductIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nDstProductIndexFa, nDstProductIndexChd);
	if((nDstProductIndexChd != -1) && (nDstProductIndex < 0 || nDstProductIndex >= nCount))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种复制失败");
		m_strStatusBarInfo2.Format(_T("目的全部品种索引%d超限"), nDstProductIndex+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductCopyFPCP(FALSE);
		return TRUE;
	}



	// 获取当前全部品种索引，记为之前全部品种索引
	int nPrevProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nPrevProductIndexFa = 0, nPrevProductIndexChd = 0;
	m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nPrevProductIndexFa, nPrevProductIndexChd);

	if (nSrcProductIndexChd == -1) // 大品种复制
	{
		// 对来源和目的大品种的小品种数量不一致的情况进行特殊处理
		if(nSrcCountChd > nDstCountChd)
		{
			// 如果目的小品种少，则先补齐不足的目的小品种
			for(int i=0; i<nSrcCountChd-nDstCountChd; i++)
			{
				if (!ProductNew(nDstProductIndexFa, nDstCountChd+i))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = _T("品种复制失败");
					m_strStatusBarInfo2.Format(_T("目的大%d小%d补齐创建失败"), nDstProductIndexFa+1, nDstCountChd+i+1);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					PostMessageUpdateCurProductAlignInfo();
					ReportProductCopyFPCP(FALSE);
					return TRUE;
				}
			}
		}
		else if(nSrcCountChd < nDstCountChd)
		{
			// 如果目的小品种多，则先清空多余的目的小品种
			for(int i=nSrcCountChd; i<nDstCountChd; i++)
			{
				int nIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nDstProductIndexFa, i);
				if (!ProductEmpty(nIndex))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = _T("品种复制失败");
					m_strStatusBarInfo2.Format(_T("目的大%d小%d全%d清空失败"), nDstProductIndexFa+1, i+1, nIndex+1);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					PostMessageUpdateCurProductAlignInfo();
					ReportProductCopyFPCP(FALSE);
					return TRUE;
				}
			}
		}

		// 按来源大品种的小品种数量进行遍历
		for(int i=0; i<nSrcCountChd; i++)
		{
			int nSrctIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nSrcProductIndexFa,i);
			int nDstIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nDstProductIndexFa,i);
			if (!ProductCopy(nSrctIndex, nDstIndex))
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = _T("品种复制失败");
				m_strStatusBarInfo2.Format(_T("从大%d小%d全%d到大%d小%d全%d复制失败"), nSrcProductIndexFa+1, i+1, nSrctIndex+1, nDstProductIndexFa+1, i+1, nDstIndex+1);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				PostMessageUpdateCurProductAlignInfo();
				ReportProductCopyFPCP(FALSE);
				return TRUE;
			}
		}
	}
	else // 小品种复制
	{
		if (!ProductCopy(nSrcProductIndex, nDstProductIndex))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("品种复制失败");
			m_strStatusBarInfo2.Format(_T("从大%d小%d全%d到大%d小%d全%d复制失败"), nSrcProductIndexFa+1, nSrcProductIndexChd+1, nSrcProductIndex+1, nDstProductIndexFa+1, nDstProductIndexChd+1, nDstProductIndex+1);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			PostMessageUpdateCurProductAlignInfo();
			ReportProductCopyFPCP(FALSE);
			return TRUE;
		}
	}

	// 当大品种复制，目的大品种的小品种数量较少时，补齐创建小品种时，会变更当前品种索引至最后新建品种，造成产品复制前后品种号变更
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex != nPrevProductIndex)
	{
		if (!SetCurCalibDataIndex(nPrevProductIndex))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("品种复制失败");
			m_strStatusBarInfo2.Format(_T("切换至大%d小%d全%d品种标定失败"), nPrevProductIndexFa+1, nPrevProductIndexChd+1, nPrevProductIndex+1);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			PostMessageUpdateCurProductAlignInfo();
			ReportProductCopyFPCP(FALSE);
			return TRUE;
		}

		if (!SetCurProductIndex(nPrevProductIndex))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("品种复制失败");
			m_strStatusBarInfo2.Format(_T("切换至大%d小%d全%d品种产品失败"), nPrevProductIndexFa+1, nPrevProductIndexChd+1, nPrevProductIndex+1);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			PostMessageUpdateCurProductAlignInfo();
			ReportProductCopyFPCP(FALSE);
			return TRUE;
		}
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("品种复制成功");
	m_strStatusBarInfo2.Format(_T("从大%d小%d到大%d小%d复制成功"), nSrcProductIndexFa+1, nSrcProductIndexChd+1, nDstProductIndexFa+1, nDstProductIndexChd+1);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	PostMessageUpdateCurProductAlignInfo();
	ReportProductCopyFPCP(TRUE);

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportProductCopyFPCP(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 指令解析
		CString strSimpleInfo; 
		m_XYDCommProtocol.PackReProductCopyFPCP(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcProductCopyFPCP(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReProductCopyFPCP(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineProductRenameFPRN(int nProductIndexFa, int nProductIndexChd, int nProductNameLength)
{
	// 判断大品种索引是否超限
	int nCountFa = m_pVisionASMConfig->m_TotalProductData.GetProductCountFa();
	if(nProductIndexFa < 0 || nProductIndexFa >= nCountFa)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种重命名失败");
		m_strStatusBarInfo2.Format(_T("大品种索引%d超限"), nProductIndexFa+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductRenameFPRN(FALSE);
		return TRUE;
	}

	// 判断小品种索引是否超限
	int nCountChd = m_pVisionASMConfig->m_TotalProductData.GetProductCountChd(nProductIndexFa);
	if(nProductIndexChd < -1 || nProductIndexChd >= nCountChd)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种重命名失败");
		m_strStatusBarInfo2.Format(_T("小品种索引%d超限"), nProductIndexChd+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductRenameFPRN(FALSE);
		return TRUE;
	}

	// 如果非大品种复制，判断全部品种索引是否超限
	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetProductIndex(nProductIndexFa, nProductIndexChd);
	int nCount = m_pVisionASMConfig->m_TotalProductData.GetCount();
	if((nProductIndexChd != -1) && (nProductIndex < 0 || nProductIndex >= nCount))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种重命名失败");
		m_strStatusBarInfo2.Format(_T("全部品种索引%d超限"), nProductIndex+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductRenameFPRN(FALSE);
		return TRUE;
	}

	// 最大字符数量等于20，无论单双字协议，都对应从临时寄存器地址开始的10个寄存器地址
	int nMaxProductNameLength = 20;
	if(nProductNameLength < 0 || nProductNameLength > nMaxProductNameLength)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种重命名失败");
		m_strStatusBarInfo2.Format(_T("产品名称长度%d超限"), nProductIndexFa+1);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductRenameFPRN(FALSE);
		return TRUE;
	}

	// 如果PLC传入参数字符数量等于0，则按照最大数量进行读取
	if (nProductNameLength == 0)
	{
		nProductNameLength = nMaxProductNameLength;
	}

	// 仅支持读写寄存器通信协议
	if(!m_XYDCommProtocol.IsPlcProtocolType())
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种重命名失败");
		m_strStatusBarInfo2 = _T("仅支持读写寄存器通信协议");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductRenameFPRN(FALSE);
		return TRUE;
	}

	// 寄存器读取产品名称
	CString strProductName;
	if(!ReceiveProductNamePlcReg(nProductNameLength, strProductName))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("品种重命名失败");
		m_strStatusBarInfo2 = _T("寄存器读取产品名称失败");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		PostMessageUpdateCurProductAlignInfo();
		ReportProductRenameFPRN(FALSE);
		return TRUE;
	}

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	if ((!sysPlatformInfo.m_bProductFaChd) || (nProductIndexChd == -1)) // 大品种重命名
	{
		m_pVisionASMConfig->m_TotalProductData.SetProductNameFa(nProductIndexFa, strProductName);
		SaveTotalProductDataInfo(FALSE);

		m_pVisionASMConfig->m_TotalCalibData.SetCalibNameFa(nProductIndexFa, strProductName);
		SaveTotalCalibDataInfo(FALSE);
	}
	else // 小品种重命名
	{
		m_pVisionASMConfig->m_TotalProductData.SetItemName(nProductIndex, strProductName);
		SaveProductDataInfo(nProductIndex);

		m_pVisionASMConfig->m_TotalCalibData.SetItemName(nProductIndex, strProductName);
		SaveCalibDataInfo(nProductIndex);
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("品种重命名成功");
	m_strStatusBarInfo2.Format(_T("大品种%d,小品种%d,品种名称:"), nProductIndexFa+1, nProductIndexChd+1);
	m_strStatusBarInfo2 += strProductName;
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	PostMessageUpdateCurProductAlignInfo();
	ReportProductRenameFPRN(TRUE);

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportProductRenameFPRN(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 指令解析
		CString strSimpleInfo; 
		m_XYDCommProtocol.PackReProductRenameFPRN(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcProductRenameFPRN(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReProductRenameFPRN(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReceiveProductNamePlcReg(int nDataNum, CString& strNewName)
{
	// 指令读取产品名称功能只适用于读写寄存器协议
	if (!m_XYDCommProtocol.IsPlcProtocolType())
	{
		return FALSE;
	}

	// 将串口内容清空
	CString strTemp;
	// 	while(ReceiveCommInfo(strTemp, TRUE))
	// 	{
	// 	}
	LockShareComm(); //加锁共享通信
	ReceiveCommInfo(strTemp, TRUE);
	UnlockShareComm(); //解锁共享通信

	//////////////////////////////////////////////////////////////////////////
	// 读取寄存器
	CString strSend;

	// 打包读取寄存器指令
	if (FALSE == m_XYDCommProtocol.PackPlcReadNewName(strSend, nDataNum))
	{
		return FALSE;
	}

	CString ss;

	// 获取时间	
	SYSTEMTIME tm;
	GetLocalTime(&tm);
	CString strTime;	
	CString strSendLog;
	CString strRecLog;
	strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
	strSendLog = strTime + strSend;

	// 发送读取命令
	LockShareComm(); //加锁共享通信
	if (FALSE == SendCommInfo(strSend, FALSE))	
	{
		UnlockShareComm(); //解锁共享通信
		return FALSE;
	}

	// 接收PLC回复
	BOOL bReceived;
	CString strInfo;
	CommStatus nCommStatus = eCommSucceed;
	bReceived = ReceiveCommRepeat(strInfo, nCommStatus, FALSE);
	UnlockShareComm(); //解锁共享通信
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		return FALSE;
// 		if (m_bStopNow)
// 		{
// 			return FALSE;
// 		}
// 		//	return FALSE;
// 		// 再发一次
// 		strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
// 		strSendLog = strTime + strSend;
// 
// 		// 发送读取命令
// 		LockShareComm(); //加锁共享通信
// 		if (FALSE == SendCommInfo(strSend, FALSE))	
// 		{
// 			UnlockShareComm(); //解锁共享通信
// 			return FALSE;
// 		}
// 
// 		// 接收PLC回复
// 		nCommStatus = eCommSucceed;
// 		bReceived = ReceiveCommRepeat(strInfo, nCommStatus, FALSE);
// 		UnlockShareComm(); //解锁共享通信
// 		if (bReceived == FALSE || nCommStatus != eCommSucceed)
// 		{
// 			return FALSE;
// 		}
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);//_T("通信异常");
// 		m_strStatusBarInfo2 = _T("再次通信接收指令成功！")/*GetSysInfoString(m_psaSysInfoStrings,IDS_COMM_STOP_OR_TIMEOUT)*/;//_T("通信接收指令停止或超时！");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}

	GetLocalTime(&tm);
	strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
	strRecLog = strTime + strInfo;
	VisionAlignLogRecord(_T("E:\\name.txt"),strRecLog);

	//////////////////////////////////////////////////////////////////////////
	// 基恩士串口PCLink通信：在PLC断电重启后，要先发送一个通信开始的指令，否则无法进行通信

	if (eProRegKeyenceSerialPCLink == m_XYDCommProtocol.GetProtocolType())
	{
		if (strInfo == "E1")
		{
			CString strSend = _T("CR");
			LockShareComm(); //加锁共享通信
			if (FALSE == SendCommInfo(strSend, FALSE))	
			{
				UnlockShareComm(); //解锁共享通信
				return FALSE;
			}

			AddCommCommandInfo(TRUE, strSend, TRUE,TRUE);

			CString strRecieve;
			bReceived = ReceiveCommRepeat(strRecieve,nCommStatus,FALSE);
			UnlockShareComm(); //解锁共享通信

			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
				// 再发一次
// 				LockShareComm(); //加锁共享通信
// 				if (FALSE == SendCommInfo(strSend, FALSE))	
// 				{
// 					UnlockShareComm(); //解锁共享通信
// 					return FALSE;
// 				}
// 
// 				AddCommCommandInfo(TRUE, strSend, TRUE,TRUE);
// 
// 				bReceived = ReceiveCommRepeat(strRecieve,nCommStatus,FALSE);
// 				UnlockShareComm(); //解锁共享通信
// 				if (bReceived == FALSE || nCommStatus != eCommSucceed)
// 				{
// 					return FALSE;
// 				}
			}

			AddCommCommandInfo(FALSE, strRecieve, TRUE,TRUE);

			if (strInfo == "CC")
			{
				return FALSE;
			}
		}
	}

	//////////////////////////////////////////////////////////////////////////

	// 解析收到的响应
	BOOL bTriggered = FALSE;
	if(!m_XYDCommProtocol.AnalyzePlcNewName(strInfo, nDataNum,strNewName))
	{
		return FALSE;
	}

	return TRUE;
}


BOOL vcXYDVisionAlign::ReportObjectSearchResultFOBCALGOrACO( BOOL bResult, int nSuccessPatIndex,CPlatformAxisPos* vpPlatAxisPos)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReObjectSearchFOBCAndALGOrACO(strSimpleInfo, bResult, nSuccessPatIndex+1,vpPlatAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;

		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignAfterSearchAxisPos(strSend, bResult, vpPlatAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcObjectSearchFOBC(strSend, bResult, nSuccessPatIndex+1))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}

	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReObjectSearchFOBCAndALGOrACO(strInfo, bResult, nSuccessPatIndex+1,vpPlatAxisPos))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}	
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}
BOOL vcXYDVisionAlign::ReportObjectSearchResultFOBJALGOrACO( BOOL bResult,CPlatformAxisPos* vpPlatAxisPos)
{

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReObjectSearchFOBJAndALGOrACO(strSimpleInfo, bResult, vpPlatAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;

		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignAfterSearchAxisPos(strSend, bResult, vpPlatAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcObjectSearchFOBJ(strSend, bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}

	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReObjectSearchFOBJAndALGOrACO(strInfo, bResult, vpPlatAxisPos))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}	
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportTargetSearchResultFTGCALGOrACO( BOOL bResult, int nSuccessPatIndex,CPlatformAxisPos* vpPlatAxisPos)
{

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;

		if (m_pAlignerTool->GetProductAlignerParam()->GetAlignAccordingToPickPlatformEnable())
		{
			CCoordPos cpOffsetPickRevise;
			cpOffsetPickRevise = GetAlignPlatformPickRevise();
			m_XYDCommProtocol.PackReTargetSearchFTGCAndALGOrACO(strSimpleInfo, bResult, nSuccessPatIndex+1,vpPlatAxisPos, &cpOffsetPickRevise);
		}
		else
		{
			m_XYDCommProtocol.PackReTargetSearchFTGCAndALGOrACO(strSimpleInfo, bResult, nSuccessPatIndex+1,vpPlatAxisPos);
		}

		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;

		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignAfterSearchAxisPos(strSend, bResult, vpPlatAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}


		// 打包发送上料拾取计算偏差量临时寄存器
		if (m_pAlignerTool->GetProductAlignerParam()->GetAlignAccordingToPickPlatformEnable())
		{
			CCoordPos cpOffsetPickRevise;
			cpOffsetPickRevise = GetAlignPlatformPickRevise();
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignPickReviseResultInfoFACOAxisPos(strSend, cpOffsetPickRevise, bResult, vpPlatAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcTargetSearchFTGC(strSend, bResult, nSuccessPatIndex+1))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (m_pAlignerTool->GetProductAlignerParam()->GetAlignAccordingToPickPlatformEnable())
		{
			CCoordPos cpOffsetPickRevise;
			cpOffsetPickRevise = GetAlignPlatformPickRevise();
			m_XYDCommProtocol.PackReTargetSearchFTGCAndALGOrACO(strInfo, bResult, nSuccessPatIndex+1,vpPlatAxisPos, &cpOffsetPickRevise);
		}
		else
		{
			// 打包“写寄存器”指令
			if (!m_XYDCommProtocol.PackReTargetSearchFTGCAndALGOrACO(strInfo, bResult, nSuccessPatIndex+1,vpPlatAxisPos))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}	
		}
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}
BOOL vcXYDVisionAlign::ReportTargetSearchResultFTGTALGOrACO( BOOL bResult,CPlatformAxisPos* vpPlatAxisPos)
{

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		if (m_pAlignerTool->GetProductAlignerParam()->GetAlignAccordingToPickPlatformEnable())
		{
			CCoordPos cpOffsetPic = GetAlignPlatformPickRevise();
			m_XYDCommProtocol.PackReTargetSearchFTGTAndALGOrACO(strSimpleInfo, bResult, vpPlatAxisPos, &cpOffsetPic);
		}
		else
		{
			m_XYDCommProtocol.PackReTargetSearchFTGTAndALGOrACO(strSimpleInfo, bResult, vpPlatAxisPos);
		}
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;

		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignAfterSearchAxisPos(strSend, bResult, vpPlatAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 打包发送上料拾取计算偏差量临时寄存器
		if (m_pAlignerTool->GetProductAlignerParam()->GetAlignAccordingToPickPlatformEnable())
		{
			CCoordPos cpOffsetPickRevise;
			cpOffsetPickRevise = GetAlignPlatformPickRevise();
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignPickReviseResultInfoFACOAxisPos(strSend, cpOffsetPickRevise, bResult, vpPlatAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcTargetSearchFTGT(strSend, bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (m_pAlignerTool->GetProductAlignerParam()->GetAlignAccordingToPickPlatformEnable())
		{
			CCoordPos cpOffsetPic = GetAlignPlatformPickRevise();
			m_XYDCommProtocol.PackReTargetSearchFTGTAndALGOrACO(strInfo, bResult, vpPlatAxisPos, &cpOffsetPic);
		}
		else
		{
			if (!m_XYDCommProtocol.PackReTargetSearchFTGTAndALGOrACO(strInfo, bResult, vpPlatAxisPos))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}	
		}	
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

// 对象拍照或者目标拍照之后，执行对位计算
BOOL vcXYDVisionAlign::ExecuteAlignAfterFOBCAndFTGC(std::vector<int>& vnPosIndex,int nObject)
{
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	BOOL bObjectSearchSync = pAlignerParam->GetObjectCandidateSyncEnable();
	BOOL bTargetSearchSync = pAlignerParam->GetTargetCandidateSyncEnable();

	m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();
	m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();

	//if(!m_bAllObjectPosSearchSuccess || !m_bAllTargetPosSearchSuccess)//如果对象或者目标拍照失败，发送获取对位指令指令失败
	//{
	//	CPlatformXYDAxisPos pPlaformXYDAxiPosTemp;
	//	if(nObject == 1)//对象拍完照之后执行对位
	//	{				
	//		ReportObjectSearchResultFOBCALGOrACO(FALSE,-1,&pPlaformXYDAxiPosTemp);
	//	}
	//	if(nObject == 2)//目标拍完照之后发送对位结果
	//	{
	//		ReportTargetSearchResultFTGCALGOrACO(FALSE,-1,&pPlaformXYDAxiPosTemp);
	//	}
	//	return TRUE;
	//}
	CPlatformXYDAxisPos *pPlatformXYDAxisPos=NULL;
	int nExProductIndex = m_pAlignerTool->GetAlignExProductIndex();
	BOOL bSucc = OnlineAlignExFACOAfterSearch(m_nOffsetIndex,-1,nExProductIndex,m_nOffsetIndex);
	//if(!bSucc)
	//	return FALSE;
	//绝对值
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());
	if(m_nAlignType == 2)//相对值
	{
		CCoordPos cpOffset;
		cpOffset = GetAlignPlatformPosOffset();	
		pPlatformXYDAxisPos->m_dPosX = cpOffset.m_dPosX;
		pPlatformXYDAxisPos->m_dPosY = cpOffset.m_dPosY;
		pPlatformXYDAxisPos->m_dAngle= cpOffset.m_dAngle;
	}

	if(nObject == 1)//对象拍完照之后执行对位
	{
		if(m_bObjectSearchTest)
		{
			if (bSucc)
			{
				if (bObjectSearchSync)
				{
					ReportObjectSearchResultFOBCALGOrACO(TRUE,m_vnObjectSearchSuccessPatIndex[vnPosIndex[0]],pPlatformXYDAxisPos);
				}
				else
				{
					ReportObjectSearchResultFOBCALGOrACO(TRUE,-1,pPlatformXYDAxisPos);
				}
			}
			else
			{
				ReportObjectSearchResultFOBCALGOrACO(FALSE,-1,pPlatformXYDAxisPos);
				return FALSE;
			}
		}

	}

	if(nObject == 2)//目标拍完照之后发送对位结果
	{
		if(m_bTargetSearchTest)
		{
			if (bSucc)
			{
				if (bTargetSearchSync)
				{
					ReportTargetSearchResultFTGCALGOrACO(TRUE,m_vnObjectSearchSuccessPatIndex[vnPosIndex[0]],pPlatformXYDAxisPos);
				}
				else
				{
					ReportTargetSearchResultFTGCALGOrACO(TRUE,-1,pPlatformXYDAxisPos);
				}
			}
			else
			{
				ReportTargetSearchResultFTGCALGOrACO(FALSE,-1,pPlatformXYDAxisPos);
				return FALSE;
			}
		}

	}
	return TRUE;

}
// 对象拍照或者目标拍照之后，执行对位计算
BOOL vcXYDVisionAlign::ExecuteAlignAfterFOBJAndFTGT(int nObject)
{
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();

	m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();
	m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();

	CPlatformXYDAxisPos *pPlatformXYDAxisPos=NULL;
	int nExProductIndex = m_pAlignerTool->GetAlignExProductIndex();
	BOOL bSucc = OnlineAlignExFACOAfterSearch(m_nOffsetIndex,-1,nExProductIndex,m_nOffsetIndex);

	//绝对值
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());
	if(m_nAlignType == 2)//相对值
	{
		CCoordPos cpOffset;
		cpOffset = GetAlignPlatformPosOffset();	
		pPlatformXYDAxisPos->m_dPosX = cpOffset.m_dPosX;
		pPlatformXYDAxisPos->m_dPosY = cpOffset.m_dPosY;
		pPlatformXYDAxisPos->m_dAngle= cpOffset.m_dAngle;
	}

	if(nObject == 1)//对象拍完照之后执行对位
	{
		if(m_bObjectSearchTest)
		{
			if (bSucc)
			{

				ReportObjectSearchResultFOBJALGOrACO(TRUE,pPlatformXYDAxisPos);

			}
			else
			{
				ReportObjectSearchResultFOBJALGOrACO(FALSE,pPlatformXYDAxisPos);
				return FALSE;
			}
		}

	}

	if(nObject == 2)//目标拍完照之后发送对位结果
	{
		if(m_bTargetSearchTest)
		{
			if (bSucc)
			{

				ReportTargetSearchResultFTGTALGOrACO(TRUE,pPlatformXYDAxisPos);

			}
			else
			{
				ReportTargetSearchResultFTGTALGOrACO(FALSE,pPlatformXYDAxisPos);
				return FALSE;
			}
		}

	}
	return TRUE;

}

BOOL vcXYDVisionAlign::ReportObjectSearchResultFOBM(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReObjectSearchFOBM(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcObjectSearchFOBM(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReObjectSearchFOBM(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}

	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportACFInspectResultFCHB( BOOL bResult, int nSuccessPatIndex/* = 0*/)
{	
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReACFInspectFCHB(strSimpleInfo, bResult, nSuccessPatIndex+1);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcACFInspectFCHB(strSend, bResult, nSuccessPatIndex+1))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReACFInspectFCHB(strInfo, bResult, nSuccessPatIndex+1))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}	
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}


BOOL vcXYDVisionAlign::ReportSetProductExposureFSPE( BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReProductExposureFSPE(strSimpleInfo,bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcSetProductExposureFSPE(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReProductExposureFSPE(strInfo,bResult))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;

}

BOOL vcXYDVisionAlign::ReportObjTarSearchResultFPCB( BOOL bResult,std::vector<CCoordPos> markPos)
{	

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReObjTarSearchFPCB(strSimpleInfo, bResult,markPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcObjTarSearchFPCB(strSend, bResult,markPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReObjTarSearchFPCB(strInfo, bResult,markPos))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;

}


BOOL vcXYDVisionAlign::ReportAlignResultFWEL( BOOL bResult , BOOL bAlignBench /*= FALSE*/, CCoordPos platOffset /*= CCoordPos(0,0,0)*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFWEL(strSimpleInfo, bResult, bAlignBench, platOffset);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFWELAxisPos(strSend, platOffset, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFWEL(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFWEL(strInfo,bResult,bAlignBench,platOffset))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportAlignResultFSOL( BOOL bResult , BOOL bAlignBench /*= FALSE*/, CCoordPos platOffset /*= CCoordPos(0,0,0)*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFSOL(strSimpleInfo, bResult, bAlignBench, platOffset);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFSOLAxisPos(strSend, platOffset, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFSOL(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFSOL(strInfo,bResult,bAlignBench,platOffset))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}


BOOL vcXYDVisionAlign::ReportPCBPrecisionFPIS( BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackRePCBPrecisionFPIS(strSimpleInfo,bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcPCBPrecisionFPIS(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackRePCBPrecisionFPIS(strInfo,bResult))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}
BOOL vcXYDVisionAlign::ReportPCBPrecisionFCPI( BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackRePCBPrecisionFCPI(strSimpleInfo,bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcPCBPrecisionFCPI(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackRePCBPrecisionFCPI(strInfo,bResult))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}

BOOL vcXYDVisionAlign::ReportACFInspectResultFCHBD( BOOL bResult, int nSuccessPatIndex, std::vector<double> vdDistance, std::vector<BOOL> vbAreaInspectSubResult)
{	
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReACFInspectFCHBD(strSimpleInfo, bResult, nSuccessPatIndex+1, vdDistance);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcACFInspectFCHB(strSend, bResult, nSuccessPatIndex+1))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		if (vdDistance.size() > 0)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcACFInspectFCHBD(strSend, vdDistance)) // 备用轴位置寄存器（紧跟轴位置寄存器
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 平台选项界面启用发送面积检测子结果时，才发送子结果
		if (optionInfo.m_bSendAreaInspectSubResult && vbAreaInspectSubResult.size()>0)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcACFInspectFCHBD(strSend, vdDistance)) // 备用轴位置寄存器（紧跟轴位置寄存器
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}


		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReACFInspectFCHBD(strInfo, bResult, nSuccessPatIndex+1, vdDistance))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}

BOOL vcXYDVisionAlign::ReportACFInspectResultFCHC( BOOL bResult, int nSuccessPatIndex/* = 0*/)
{	

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReACFInspectFCHC(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcACFInspectFCHC(strSend, bResult, nSuccessPatIndex+1))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReACFInspectFCHC(strInfo, bResult, nSuccessPatIndex+1))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}

BOOL vcXYDVisionAlign::ReportResultFDRP( BOOL bResult)
{	

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReFDRP(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcFDRP(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReFDRP(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}

BOOL vcXYDVisionAlign::ReportProductInspectFINS( BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReProductInspectFINS(strSimpleInfo,bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcProductInspectFINS(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReProductInspectFINS(strInfo,bResult))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;

}

BOOL vcXYDVisionAlign::ReportSetProductVirtualAlnFVAS( BOOL bResult )
{	

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReSetProductVirtualAlnFVAS(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcSetProductVirtualAlnFVAS(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReSetProductVirtualAlnFVAS(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{

			return FALSE;
		}
	}


	return TRUE;
}

BOOL vcXYDVisionAlign::ReportTargetSearchResultFTGM(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReTargetSearchFTGM(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcTargetSearchFTGM(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReTargetSearchFTGM(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

void vcXYDVisionAlign::AddCommCommandInfo( BOOL bSend, CString strCmd , BOOL bTimeExist/* = FALSE*/,BOOL bAddDetailDInfo)
{
	// 	if (strCmd.IsEmpty())
	// 	{
	// 		return;
	// 	}

	// 获取时间	
	SYSTEMTIME tm;
	GetLocalTime(&tm);
	CString strTime;
	if (bTimeExist)
	{
		strTime.Empty();
	}
	else
	{
		strTime.Format(_T("%02d-%02d-%03d "),tm.wMinute, tm.wSecond, tm.wMilliseconds);
	}


	CString strSendRec;
	if(bSend)
	{
		strSendRec = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_OUTPUT);//_T("输出:");
	}
	else
	{
		strSendRec = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_INPUT);//_T("输入:");
	}

	EnterCriticalSection(&m_csResourceComm);

	if (bAddDetailDInfo)
	{
		if (m_saCommCommandDetail.size() > 150)	//hk20180130
		{
			//m_saCommCommandSimple.pop_front();
			m_saCommCommandDetail.pop_front();
		}
	}
	else
	{
		if (m_saCommCommandSimple.size() > 150)	//hk20180130
		{
			m_saCommCommandSimple.pop_front();
			//m_saCommCommandDetail.pop_front();
		}
	}


	// 分析指令
	CString strCmdName;
	CString strNewCmdName;
	CString strNewCmd;
	if (m_XYDCommProtocol.AnalyzeCommand(strCmd, strCmdName))
	{
		if (strCmdName!="FCHK")
		{
			// 将指令替换为新的指令
			m_XYDCommProtocol.ReplaceNewCommCmd(strCmdName, strNewCmdName);
			m_XYDCommProtocol.ReplaceNewCommCmd(strCmd, strNewCmd);
			// 加入指令记录队列
			if (bAddDetailDInfo)
			{
				m_saCommCommandDetail.push_back(strSendRec + strTime + strNewCmd);
				CString strTranslateResultInfo;
				if (m_pVisionASMConfig)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
					{
						if (bTimeExist)
						{
							strTime = strCmd.Mid(0,10);
						}
						if (TRUE == m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
						{
							VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
							VisionAlignLogRecord(m_strCommunicationSimpleData,(strSendRec + strTime + strTranslateResultInfo));
						}					
					}
				}

			}
			else
			{
				m_saCommCommandSimple.push_back(strSendRec + strTime + strNewCmd);

				if (m_pVisionASMConfig)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
					{
						VisionAlignLogRecord(m_strCommunicationSimpleShowData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationSimpleShowData,(strSendRec + strTime + strNewCmd));
					}
				}
			}
		}

	}
	else
	{
		if (strCmdName!="FCHK")
		{
			// 将指令替换为新的指令
			m_XYDCommProtocol.ReplaceNewCommCmd(strCmd, strNewCmd);
			// 加入指令记录队列
			if (bAddDetailDInfo)
			{
				m_saCommCommandDetail.push_back(strSendRec + strTime + strNewCmd);	
				CString strTranslateResultInfo;
				if (m_pVisionASMConfig)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
					{
						if (bTimeExist)
						{
							strTime = strCmd.Mid(0,10);
						}
						if (TRUE == m_XYDCommProtocol.GetTranslateResultInfo(strTranslateResultInfo,TRUE))
						{
							VisionAlignLogRecord(m_strCommunicationSimpleData, _T("\n"), FALSE);
							VisionAlignLogRecord(m_strCommunicationSimpleData,(strSendRec + strTime + strTranslateResultInfo));
						}
					}
				}
			}
			else
			{
				m_saCommCommandSimple.push_back(strSendRec + strTime + strNewCmd);

				if (m_pVisionASMConfig)
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bCommunication)
					{
						VisionAlignLogRecord(m_strCommunicationSimpleShowData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strCommunicationSimpleShowData,(strSendRec + strTime + strNewCmd));
					}
				}
			}
			//m_saCommCommandSimple.push_back(strSendRec + strTime + strNewCmd);
			//m_saCommCommandDetail.push_back(strSendRec + strTime + strNewCmd);
		}

	}
	LeaveCriticalSection(&m_csResourceComm);

	PostMessageUpdateCommCommandInfo();
}


BOOL vcXYDVisionAlign::ReportResetResult(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReResetFRST(strSimpleInfo,bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcResetFRST(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReResetFRST(strInfo,bResult))
		{
			return FALSE;
		}	
		//Sleep(50);
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}
BOOL vcXYDVisionAlign::ReportCommResultFCHK(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCommFCHK(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCommFCHK(strInfo,bResult))
		{
			return FALSE;
		}	
		//Sleep(50);
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}




BOOL vcXYDVisionAlign::ReportCalTargetFixOffsetFAFO(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReCalTargetFixOffsetFAFO(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCalTargetFixOffsetFAFO(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCalTargetFixOffsetFAFO(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}
	return TRUE;
}

BOOL vcXYDVisionAlign::ReportCalibResult( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReCalibrateFCLB(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCalibrateFCLB(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCalibrateFCLB(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportCalibResultFCBS( BOOL bResult )
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReCalibrateFCBS(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCalibrateFCBS(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCalibrateFCBS(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportCalibResultFCBP( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReCalibrateFCBP(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCalibrateFCBP(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCalibrateFCBP(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportObjectSearchResult( BOOL bResult )
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReObjectSearchFOBJ(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcObjectSearchFOBJ(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReObjectSearchFOBJ(strInfo, bResult))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}	
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}

	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportTargetSearchResultFCNO( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReTargetSearchFCNO(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcTargetSearchFCNO(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReTargetSearchFCNO(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}

	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportObjectSearchResultFCNT( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReObjectSearchFCNT(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcObjectSearchFCNT(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReObjectSearchFCNT(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}

	}

	return TRUE;
}


BOOL vcXYDVisionAlign::ReportObjectSearchResultFOBC( BOOL bResult, int nSuccessPatIndex/* = 0*/)
{

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReObjectSearchFOBC(strSimpleInfo, bResult, nSuccessPatIndex+1);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;

		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcObjectSearchFOBC(strSend, bResult, nSuccessPatIndex+1))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReObjectSearchFOBC(strInfo, bResult, nSuccessPatIndex+1))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}	
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}


BOOL vcXYDVisionAlign::ReportTargetSearchResult( BOOL bResult, int nSuccessPatIndex/* = 0 */)
{

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReTargetSearchFTGC(strSimpleInfo, bResult, nSuccessPatIndex+1);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcTargetSearchFTGC(strSend, bResult, nSuccessPatIndex+1))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReTargetSearchFTGC(strInfo, bResult, nSuccessPatIndex+1))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}	
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportTargetSearchResultFTGT( BOOL bResult )
{	

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendInspectResult = FALSE;
	if (m_bSearchWithInspect && optionInfo.m_bSendInsDistanceInSearchResult)
	{
		bSendInspectResult = TRUE;

	}
	else
	{
		bSendInspectResult = FALSE;

	}
	m_XYDCommProtocol.m_bEnablePackInspectDistance =bSendInspectResult;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReTargetSearchFTGT(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		if (bSendInspectResult && bResult)
		{
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignInspectDistanceInfo(strSend,bResult))
			{
				m_XYDCommProtocol.ClearL2LDistanceResult();
				return FALSE;
			}
			m_XYDCommProtocol.ClearL2LDistanceResult();
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcTargetSearchFTGT(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReTargetSearchFTGT(strInfo, bResult))
		{
			m_XYDCommProtocol.ClearL2LDistanceResult();
			return FALSE;
		}	
		m_XYDCommProtocol.ClearL2LDistanceResult();
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;


}


BOOL vcXYDVisionAlign::ReportTargetSearchResultFTGS( BOOL bResult )
{	

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReTargetSearchFTGS(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcTargetSearchFTGS(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReTargetSearchFTGS(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;


}


BOOL vcXYDVisionAlign::ReportSearchResultFGTC( BOOL bResult,double dImagePosX, double dImagePosY,double dImagePosD )
{
	CCoordPos imagePos;
	imagePos.m_dPosX = dImagePosX;
	imagePos.m_dPosY = dImagePosY;
	imagePos.m_dAngle = dImagePosD;


	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetImagePosFGTC(strSimpleInfo, bResult,dImagePosX,dImagePosY,dImagePosD);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFGTCAxisPos(strSend, imagePos,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFGTC(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetImagePosFGTC(strInfo, bResult,dImagePosX,dImagePosY,dImagePosD))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}


BOOL vcXYDVisionAlign::ReportSearchResultFGAP( BOOL bResult,double dImagePosX, double dImagePosY,double dImagePosD )
{	
	CCoordPos imagePos;
	imagePos.m_dPosX = dImagePosX;
	imagePos.m_dPosY = dImagePosY;
	imagePos.m_dAngle = dImagePosD;


	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetImagePosFGAP(strSimpleInfo, bResult,dImagePosX,dImagePosY,dImagePosD);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFGAPAxisPos(strSend, imagePos,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFGAP(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetImagePosFGAP(strInfo, bResult,dImagePosX,dImagePosY,dImagePosD))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}


	}



	return TRUE;


}

// 两个及两个以上相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerObjectSearchCandidateExFOBC(std::vector<int> vnPosIndex, int nStartPatIndex)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOBC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckObjectSearchTool(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	//	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
		return FALSE;
	}

	// 检查 vnPosIndex值是否合理 规避异常值传入导致错误的相机在线检查报警
	for(i=0; i<nPosNum; i++)
	{	
		nPosIndex = vnPosIndex[i];
		if(nPosIndex>=0 && nPosIndex <GetPosNum())
		{
			continue;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
			return FALSE;
		}
	}

	//	int i=0;
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nStartPatIndex);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter /*&& (0 == nStartPatIndex)*/)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;	

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eObjectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	scTimer stCommuciateTimer; double dCommuciateTime(0.0);

	stCommuciateTimer.Reset();
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{

			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (m_vpObjectPlatformAxisPos.size() <= 0 || m_vpObjectPlatformAxisPos.at(vnPosIndex[0]) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}	
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);						
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{
		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				if (optionInfo.m_bTargetAngleMulAlignerXYPD)
				{

				}
				else
				{
					pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
				}
				//				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
			}
			//D角度不累加
		}
	}


	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for(i=0; i<nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			SetObjectPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			}

		}

		m_AlignerAxisInfo.m_vdAxis.at(0) = pPlatformAxisPos->m_dPosX;
		m_AlignerAxisInfo.m_vdAxis.at(1) = pPlatformAxisPos->m_dPosY;
		m_AlignerAxisInfo.m_vdAxis.at(2) = pPlatformAxisPos->m_dAngle;
		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	dCommuciateTime = stCommuciateTimer.GetTimeMilli(FALSE);
	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		


	// 3.开启定位
	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	stObjectSearchTimer.Reset();


	// 等待搜索延时
	// 	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	// 	Sleep(nDelayTime);


	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}

	// 准备开始定位			
	//	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	//	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		//		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eObjectSearch);	// 
	}


	// 隐藏结果图形
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
	// 	//if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
	// 
	//     //HideExtraGraphics(vnPosIndex);
	//     ShowExtraGuiToDisplay(vnPosIndex, FALSE);


	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (bObjectSearchCandidate == FALSE)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bObjectSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[vnPosIndex[0]];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = OBJECTCANDIDATENUM-1;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{
				if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
				{
					continue;
				}

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					m_vnObjectSearchStartPatIndex[nPosIndex] = j;
					m_vnObjectSearchEndPatIndex[nPosIndex] = j;
				}			
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				if (bSearchSucceed)
				{
					break;
				}	
				//Sleep(100);
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = OBJECTCANDIDATENUM-1;

				m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
	}



	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
				BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
				if (bObjectSearchCandidate == FALSE)
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
				else
				{
					if (bObjectSearchSync == TRUE)
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
						{
							nTempStartPatIndex = nStartPatIndex;
						}
						else if (nStartPatIndex == 9)
						{
							nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[vnPosIndex[0]];
						}
						else
						{
							nTempStartPatIndex = 0;
						}
						nTempEndPatIndex = OBJECTCANDIDATENUM-1;

						int j = 0;
						for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
						{
							if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
							{
								continue;
							}

							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								m_vnObjectSearchStartPatIndex[nPosIndex] = j;
								m_vnObjectSearchEndPatIndex[nPosIndex] = j;
							}			
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

							if (bSearchSucceed)
							{
								break;
							}	
							//Sleep(100);
						}
					}
					else
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
							{
								nTempStartPatIndex = nStartPatIndex;
							}
							else if (nStartPatIndex == 9)
							{
								nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
							}
							else
							{
								nTempStartPatIndex = 0;
							}
							nTempEndPatIndex = OBJECTCANDIDATENUM-1;

							m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
							m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}


	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}
			else
			{
				bSearchSucceed = TRUE;
			}

			if (FALSE ==ExcuteManualSearch(1,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

			}
			else
			{
				bSearchSucceed = TRUE;
			}

			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}

	}


	// 设定、显示结果图形
	//if ((m_bIsObjectCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsObjectLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//{
	//ShowAllGuiAlnObjectExtraGraphics(nCurProdcutIndex,vnPosIndex);
	//         ShowExtraGuiToDisplay(vnPosIndex, TRUE,1);
	//     //}
	//     //     SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 	//     PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	// 	{
	//     	SetGuiAlnObjectImageMarkPos(vnPosIndex);
	//    	    PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	//     if (/*m_bIsObjectCornerSearchTool &&*/ (m_pSystempOptionConfig->m_bShowCornerTool))
	//     {
	//         SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	//         PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	//     }
	//     // SY
	//     SetShowGuiObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);



	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
		ExeSaveVDBFile(vnPosIndex,eObjectSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = m_StrSearchErrorInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		m_strStatusBarInfo1 += m_StrSearchErrorInfo;
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	SetMultiEXObjectMarkSearchResultsWithCombinationCode(m_mpObjectMarkImagePos);
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

	// 计算对象距离
	//CalculateObjectDistance(); 
	if (!optionInfo.m_bExeObjectCheckModeWhenAlign && !CheckObjectDistance())
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //__T("对象距离超过设定标准，对象定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//RecordObjectSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{		
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}
		}

		return FALSE;
	}

	//RecordObjectSizeIndfo(TRUE, TRUE);


	//**************************************************************

	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");		
		for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	//for (int i=0;i<vnPosIndex.size();i++)
	//{
	//	int nIndx=vnPosIndex.at(i);
	//	m_vbIsObjectPosSearchFinished.at(nIndx)=TRUE;
	//}
	//
	//BOOL bAllObjectPosSearch=TRUE;
	//for (int i=0;i<m_vbIsObjectPosSearchFinished.size();i++)
	//{
	//	bAllObjectPosSearch=bAllObjectPosSearch && m_vbIsObjectPosSearchFinished.at(i);
	//}
	//m_bAllObjectPosSearchSuccess=bAllObjectPosSearch;

	dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);

	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1 /*&& m_bAllObjectPosSearchSuccess && m_bAllTargetPosSearchSuccess*/)
	{
		/*for (int i=0;i<m_vbIsObjectPosSearchFinished.size();i++)
		{
		m_vbIsObjectPosSearchFinished.at(i) = FALSE;
		}
		m_bAllObjectPosSearchSuccess = FALSE;*/
		return ExecuteAlignAfterFOBCAndFTGC(vnPosIndex,1);
	}
	//	CString str;
	// 	str.Format("Serial camera object search time = %f",dObjectSearchTime);
	// 	AlignLogRecord(str);
	if(m_bObjectSearchTest)
	{
		if (bObjectSearchSync)
		{
			ReportObjectSearchResultFOBC(TRUE,m_vnObjectSearchSuccessPatIndex[vnPosIndex[0]]);
		}
		else
		{
			ReportObjectSearchResultFOBC(TRUE,-1);
		}

	}
	return TRUE;
}
BOOL vcXYDVisionAlign::ReportAlignResultFACO(CCoordPos platOffset, BOOL bResult, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL */, CCoordPos platBenchOffset/* = CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos/* = NULL*/)
{
	if (m_bIsExecuteFixTargetCheck)  // 执行检查验证时不进行指令回复
	{
		return TRUE;
	}

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFACO(strSimpleInfo,platOffset,bResult,pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACOBenchAxisPos(strSend, bResult, optionInfo.m_bEnableAlignBenchCenter, platBenchOffset, pBenchPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACOAxisPos(strSend, platOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACO(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFACO(strInfo,platOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;

}


BOOL vcXYDVisionAlign::ReportAlignMulResultFACO(std::vector<CCoordPos> vplatOffset,BOOL bResult, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL*/, CCoordPos platBenchOffset/* = CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos/* = NULL*/)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFACO(strSimpleInfo,vplatOffset,bResult,pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACOBenchAxisPos(strSend, bResult, optionInfo.m_bEnableAlignBenchCenter, platBenchOffset, pBenchPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		if(bResult)
		{
			/*if(0 == vPlatOffset.size())
			{
			return FALSE;
			}*/

			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACOAxisPos(strSend, vplatOffset,bResult,pPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACO(strSend, bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			// 视觉指令触发置位
			if (!SetVisionPlatformTrigger())
			{
				return FALSE;
			}
		}
		else
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACO(strSend, bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			// 视觉指令触发置位
			if (!SetVisionPlatformTrigger())
			{
				return FALSE;
			}
		}

	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFACO(strInfo,vplatOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}


//拾取按照上料对位, 临时寄存器中返回xy偏差量
BOOL vcXYDVisionAlign::ReportAlignResultFACO(CCoordPos platOffset, CCoordPos platOffsetPickResive,BOOL bResult, CPlatformXYDAxisPos* pPlatformXYDAxisPos /*= NULL*/, CCoordPos platBenchOffset /*= CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos/* = NULL*/)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFACO(strSimpleInfo,platOffset, platOffsetPickResive, bResult,pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACOBenchAxisPos(strSend, bResult, optionInfo.m_bEnableAlignBenchCenter, platBenchOffset, pBenchPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}


		// 打包写寄存器指令	- 偏移量
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACOAxisPos(strSend, platOffset, bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}



		// 打包写临时寄存器指令 -拾取按上料对位方式,计算 偏移量
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignPickReviseResultInfoFACOAxisPos(strSend, platOffsetPickResive, bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}




		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACO(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFACO(strInfo,platOffset, platOffsetPickResive,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}


// BOOL vcXYDVisionAlign::OnSingleCameraAlignerFCBSCalibrate(int nCalibPos, int nMarkType)
// {
// 	SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);
// 	CString strCmd = _T("VCBS");
// 	CString strTempWarningType = _T("");
// 	GetCommCommandName(strCmd);
// 	int i = 0;
// 	if (ePlatformXYPD != sysPlatformInfo.m_eMidPlatformType)
// 	{
// 		ReportCalibResultFCBS(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_PLATFORMTYPE);
// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// 
// 	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType)/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/)
// 	{	
// 		ReportCalibResultFCBS(FALSE);
// 		return FALSE;
// 	}
// 	
// // 	if(nCalibPos < 0)
// // 	{
// // 		ReportCalibResultFCBS(FALSE);
// // 		return FALSE;
// // 	}
// 
// 	if((nMarkType < 0 || nMarkType > 2) && nMarkType!=5 )
// 	{
// 		ReportCalibResultFCBS(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CALIBTYPE);
// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// // 	
// // 	// 通信是否正常
// // 	if (FALSE == m_bValidComm)
// // 	{
// // 	
// // 		ReportCalibResultFCBS(FALSE);
// // 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 		return FALSE; 
// // 	}
// // 
// // 	// 标定用定位工具是否正常 
// // 	if (m_bValidCalibSearchTool!=TRUE)
// // 	{
// // 		ReportCalibResultFCBS(FALSE);
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 		return FALSE;
// // 	}
// // 
// // 	// 相机是否处于连续采集状态
// // 	int nCamNum = m_pPlatformInfo->m_nCamNum;
// // 
// // 
// // 	int i=0;
// // 	for(i=0; i<nCamNum; i++)
// // 	{		 
// // 		if (FALSE == m_vbCameraLiveGrab[i])
// // 		{      
// // 			
// // 			ReportCalibResultFCBS(FALSE);
// // 			m_bStatusBar = FALSE;
// // 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
// // 			m_strStatusBarInfo2 = _T("");
// // 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 			return FALSE;
// // 		}    	
// // 	}
// // 
// // 	// 对位标定工具是否正常
// // 	if (m_bValidCalibSearchTool!=TRUE)
// // 	{
// // 
// // 	    ReportCalibResultFCBS(FALSE);			
// // 
// // 		return FALSE;
// // 	}
// 
// 
// 	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
// 	{
// 		nCalibPos = nCalibPos + m_pPlatformInfo->m_nPositionNum/2;
// 	}
// 
// 
// 	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;
// 	// 标定开始    
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
// 	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 	if (nMarkType == 5)
// 	{
// 		CPlatformOptionInfo optionInfo;
// 		GetPlatformOptionInfo(optionInfo);
// 		if(!(optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 		{
// 			ReportCalibResultFCBS(FALSE);
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_CHOOSE_WHOLE_DMCODE_CALIB_MODE);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 			return FALSE;
// 		}
// 
// 		if (sysPlatformInfo.m_eMidPlatformType != ePlatformX && sysPlatformInfo.m_eMidPlatformType != ePlatformXY && sysPlatformInfo.m_eMidPlatformType != ePlatformY )
// 		{
// 			BOOL bSuccess = ExecuteCalibWholeDmCodeBoard(nCalibPos);
// 			if (!bSuccess)
// 			{
// 				ReportCalibResultFCBS(FALSE);
// 				m_bStatusBar = FALSE;
// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 				PostMessageUpdateStatusBarInfo();
// 				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 				return FALSE;
// 			}
// 		}
// 		
// 		// 获取系统标定后的所有信息
// 		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 		vpAllCalibratedInfo = GetAllCalibratedInfo();
// 		int nExProductIdx = nCalibPos/GetPosNum();
// 		if (sysPlatformInfo.m_bEnableObjectCalibBench && (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()!=nCalibPos))
// 		{
// 			if (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum() < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[m_pPlatformInfo->m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()] != NULL && vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->IsValid())
// 			{
// 				CPlatformXYDAxisPos*  pBenchPlatformAxisPos = (CPlatformXYDAxisPos* )vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->GetPlatformAxisPos();
// 				CPlatformXYDAxisPos * pCurrentPlatformAxisPos = (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
// 				CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 
// 
// 				double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
// 				double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;
// 
// 
// 				//平台各轴的方向	
// 				int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
// 				int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
// 
// 				if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
// 				if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;
// 
// 				CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->GetMarkPlatformCoordPos();
// 				CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();
// 
// 				currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
// 				currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;
// 
// 
// 
// 				vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
// 				vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
// 			}
// 
// 
// 		}
// 		int nProductIdx=(GetTotalProuductData()->GetCurProductIndex());
// 		CProductData *pProductData=(GetTotalProuductData()->GetItemPtr(nProductIdx));
// 		if (sysPlatformInfo.m_bTargetObjectCamSeparate == TRUE && sysPlatformInfo.m_nPositionNum == 8 
// 			&& pProductData->m_pAlignerParam->GetAligner4Vs4Type()==eAlignerPos1234_56_4V2)
// 		{
// 			BOOL bResult=FALSE;
// 			std::vector<int> vnPos;
// 			if (nCalibPos==4 + nExProductIdx*GetPosNum())
// 			{
// 				vnPos.push_back(6 + nExProductIdx*GetPosNum());
// 				bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
// 			}
// 			if (nCalibPos==5 + nExProductIdx*GetPosNum())
// 			{
// 				vnPos.push_back(7 + nExProductIdx*GetPosNum());
// 				bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
// 			}
// 
// 			if (FALSE == bResult)
// 			{
// 				ReportCalibResultFCBS(FALSE);
// 
// // 				m_bStatusBar = FALSE;
// // 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_COPY_POS_FAILED);
// // 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 				PostMessageUpdateStatusBarInfo();
// 				
// 				return OnFailedSetSameCalibrateInfo(strCmd);
// 			}
// 			//////////////////////////////////////////////////////////////////////////
// 			vpAllCalibratedInfo = GetAllCalibratedInfo();
// 
// 		}
// 		
// 		if(optionInfo.m_bAutoCopyCalibData)
// 		{
// 			//复制标定
// 
// 			ExecuteCopyCalibrateData(2,nExProductIdx);
// 		}
// 		else
// 		{
// 			/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 			SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 			// 保存标定后信息到当前产品中及配置文件中
// 			SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 		}
// 		return TRUE;
// 	}
// 
// 	// GYM---标定日志目录
// 	if (nMarkType==0)
// 	{
// 		CalibrateMoveRangeXYPD = sc2Vector(0,0);
// 		AnalysisResultXYPD.clear();
// 	}
// 
// 	CString strCalibLogPath;
// 	// 默认D:\\VisionASMLog路径存在
// 	
// 	if (sysPlatformInfo.m_bProductFaChd)
// 	{
// 		int nCurProductIndexFa;
// 		int nCurProductIndexCh;
// 		m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 		strCalibLogPath.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CalibrateLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 			nCurProductIndexFa+1,nCurProductIndexCh+1);
// 	}
// 	else
// 	{
// 		strCalibLogPath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CalibrateLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 			m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 	}
// 	
// 	//只计算
// 	if(nMarkType == 2)
// 	{
// 
// 		CPlatformOptionInfo optionInfo;
// 		GetPlatformOptionInfo(optionInfo);
// 		//全局二维码靶标标定时，当标定位置为选择的计算位置时，执行旋转中心计算
// 		if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode()== eWholeDmcodeBoardCalib && GetWholeCalibCacuPosEnable() && nRemCalibPos == GetWholeCalibCacuPos())
// 		{
// 			if (sysPlatformInfo.m_eMidPlatformType != ePlatformX && sysPlatformInfo.m_eMidPlatformType != ePlatformXY && sysPlatformInfo.m_eMidPlatformType != ePlatformY)
// 			{
// 				{
// 					BOOL bSuccess = ExecuteCalibWholeDmCodeBoard(nCalibPos);
// 					if (!bSuccess)
// 					{
// 						ReportCalibResultFCBS(FALSE);
// 						m_bStatusBar = FALSE;
// 						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_ERROR);
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 						PostMessageUpdateStatusBarInfo();
// 						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 						return FALSE;
// 					}
// 					else
// 					{
// 						m_bStatusBar = TRUE;
// 						m_strStatusBarInfo1 = _T("");
// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_CALCU_SUCCESS);
// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 					}
// 				}
// 				
// 			}
// 			//////////////////////////////////////// 获取标定结果///////////////////////////////////////////
// 
// 			// 获取系统标定后的所有信息
// 			std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 			vpAllCalibratedInfo = GetAllCalibratedInfo();
// 			int nExProductIdx = nCalibPos/GetPosNum();
// 			if (sysPlatformInfo.m_bEnableObjectCalibBench && (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()!=nCalibPos))
// 			{
// 				if (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum() < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[m_pPlatformInfo->m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()] != NULL && vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->IsValid())
// 				{
// 					CPlatformXYDAxisPos*  pBenchPlatformAxisPos = (CPlatformXYDAxisPos* )vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->GetPlatformAxisPos();
// 					CPlatformXYDAxisPos * pCurrentPlatformAxisPos = (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
// 					CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 
// 
// 					double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
// 					double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;
// 
// 
// 					//平台各轴的方向	
// 					int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
// 					int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
// 
// 					if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
// 					if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;
// 
// 					CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->GetMarkPlatformCoordPos();
// 					CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();
// 
// 					currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
// 					currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;
// 
// 
// 
// 					vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
// 					vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
// 				}
// 
// 
// 			}
// 			int nProductIdx=(GetTotalProuductData()->GetCurProductIndex());
// 			CProductData *pProductData=(GetTotalProuductData()->GetItemPtr(nProductIdx));
// 			if (sysPlatformInfo.m_bTargetObjectCamSeparate == TRUE && sysPlatformInfo.m_nPositionNum == 8 
// 				&& pProductData->m_pAlignerParam->GetAligner4Vs4Type()==eAlignerPos1234_56_4V2)
// 			{
// 				BOOL bResult=FALSE;
// 				std::vector<int> vnPos;
// 				if (nCalibPos==4 + nExProductIdx*GetPosNum())
// 				{
// 					vnPos.push_back(6 + nExProductIdx*GetPosNum());
// 					bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
// 				}
// 				if (nCalibPos==5 + nExProductIdx*GetPosNum())
// 				{
// 					vnPos.push_back(7 + nExProductIdx*GetPosNum());
// 					bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
// 				}
// 
// 				if (FALSE == bResult)
// 				{
// 					ReportCalibResultFCBS(FALSE);
// 
// // 					m_bStatusBar = FALSE;
// // 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_COPY_POS_FAILED);
// // 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 					PostMessageUpdateStatusBarInfo();
// 					return OnFailedSetSameCalibrateInfo(strCmd);
// 				}
// 				//////////////////////////////////////////////////////////////////////////
// 				vpAllCalibratedInfo = GetAllCalibratedInfo();
// 
// 			}
// 			
// 			
// 			if(optionInfo.m_bAutoCopyCalibData)
// 			{
// 				//复制标定
// 
// 				ExecuteCopyCalibrateData(2,nExProductIdx);
// 			}
// 			else
// 			{
// 				/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 				SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 				// 保存标定后信息到当前产品中及配置文件中
// 				SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 			}
// 		}
// 		else
// 		{
// 			if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
// 			{
// 				return TRUE;
// 			}
// 
// 			{
// 				std::vector<CMarkImagePos*> Nullimage;
// 				Nullimage.clear();
// 				if(FALSE == ExecuteCalibrateFCBS(Nullimage,nCalibPos,nMarkType))
// 				{
// 
// 					ReportCalibResultFCBS(FALSE);				
// 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 					m_strStatusBarInfo2 = _T("");
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 					return FALSE;
// 				}
// 			}
// 
// 
// 			//////////////////////////////////////// 获取标定结果///////////////////////////////////////////
// 
// 			// 获取系统标定后的所有信息
// 			std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 			vpAllCalibratedInfo = GetAllCalibratedInfo();
// 
// 			//GYM-标定日志记录 -标定结果
// 			CString strOut = _T("");
// 			CalibrateLogRecord_Result(nCalibPos,CalibrateMoveRangeXYPD,strOut,AnalysisResultXYPD);
// 			VisionAlignLogRecord(strCalibLogPath,strOut,FALSE);
// 			//GYM
// 
// 			//GYM-标定日志记录-汇总信息
// 			//标定数据汇总分析结果
// 			if (AnalysisResultXYPD.size()>6)
// 			{
// 				strOut.Empty();
// 				CString strTemp = _T("");
// 				strTemp.Format(_T("位置%d标定数据汇总分析结果:\n"),nRemCalibPos+1);
// 				strOut += strTemp;
// 				strTemp.Format(_T("%s"),AnalysisResultXYPD[0]);
// 				strOut += strTemp;
// 				strTemp.Format(_T("%s"),AnalysisResultXYPD[1]);
// 				strOut += strTemp;
// 				strTemp.Format(_T("......是否存在轴X重复性精度问题和反向间隙: %s"),AnalysisResultXYPD[2]);	//X方向最大距离差
// 				strOut += strTemp;
// 				strTemp.Format(_T("......是否存在轴Y重复性精度问题和反向间隙: %s"),AnalysisResultXYPD[3]);	//Y方向最大距离差
// 				strOut += strTemp;
// 				strTemp.Format(_T("......是否存在轴D重复性精度问题和反向间隙: %s"),AnalysisResultXYPD[4]);	//D方向最大距离差
// 				strOut += strTemp;
// 				strTemp.Format(_T("......是否存在细分问题: %s"),AnalysisResultXYPD[5]);
// 				strOut += strTemp;
// 				strTemp.Format(_T("%s"),AnalysisResultXYPD[6]);     // 标定时X、Y分别占相机视野的比例
// 				strOut += strTemp;
// 				VisionAlignLogRecord(strCalibLogPath,strOut,FALSE);
// 				/////GYM
// 			}
// 
// 
// 			int nExProductIdx = nCalibPos/GetPosNum();
// 
// 			if (sysPlatformInfo.m_bEnableObjectCalibBench && (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()!=nCalibPos))
// 			{
// 				if (sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum() < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[m_pPlatformInfo->m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()] != NULL && vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->IsValid())
// 				{
// 					CPlatformXYDAxisPos*  pBenchPlatformAxisPos = (CPlatformXYDAxisPos* )vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->GetPlatformAxisPos();
// 					CPlatformXYDAxisPos * pCurrentPlatformAxisPos = (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
// 					CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 
// 
// 					double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
// 					double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;
// 
// 
// 					//平台各轴的方向	
// 					int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
// 					int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
// 
// 					if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
// 					if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;
// 
// 					CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex + nExProductIdx*GetPosNum()]->GetMarkPlatformCoordPos();
// 					CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();
// 
// 					currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
// 					currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;
// 
// 
// 
// 					vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
// 					vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
// 				}
// 
// 
// 			}
// 			int nProductIdx=(GetTotalProuductData()->GetCurProductIndex());
// 			CProductData *pProductData=(GetTotalProuductData()->GetItemPtr(nProductIdx));
// 			if (sysPlatformInfo.m_bTargetObjectCamSeparate == TRUE && sysPlatformInfo.m_nPositionNum == 8 
// 				&& pProductData->m_pAlignerParam->GetAligner4Vs4Type()==eAlignerPos1234_56_4V2)
// 			{
// 				BOOL bResult=FALSE;
// 				std::vector<int> vnPos;
// 				if (nCalibPos==4 + nExProductIdx*GetPosNum())
// 				{
// 					vnPos.push_back(6 + nExProductIdx*GetPosNum());
// 					bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
// 				}
// 				if (nCalibPos==5 + nExProductIdx*GetPosNum())
// 				{
// 					vnPos.push_back(7 + nExProductIdx*GetPosNum());
// 					bResult = SetSameCalibrateInfo(nCalibPos,vnPos);
// 				}
// 
// 				if (FALSE == bResult)
// 				{
// 					ReportCalibResultFCBS(FALSE);
// 
// // 					m_bStatusBar = FALSE;
// // 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// // 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_COPY_POS_FAILED);
// // 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 					return OnFailedSetSameCalibrateInfo(strCmd);
// 				}
// 				//////////////////////////////////////////////////////////////////////////
// 				vpAllCalibratedInfo = GetAllCalibratedInfo();
// 
// 			}
// 			
// 			
// 			if(optionInfo.m_bAutoCopyCalibData)
// 			{
// 				//复制标定
// 
// 				ExecuteCopyCalibrateData(2,nExProductIdx);
// 			}
// 			else
// 			{
// 				/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 				SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 				// 保存标定后信息到当前产品中及配置文件中
// 				SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 			}
// 		}
// 
// 
// 
// 		// 保存目标定位结果信息
// 		m_bTargetMarkSearchSucceed = FALSE;	
// 		m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
// 		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
// 		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
// 
// 		return TRUE;
// 
// 
// 	}
// 	
// 	int nCamPos = m_pPlatformInfo->m_nPositionNum;
// 	CPlatformOptionInfo optionInfo;
// 	GetPlatformOptionInfo(optionInfo);
// 	{
// 		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
// 		if (SystempOptionSearchShutter && optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode  || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 		{
// 			int nPosNum = 1;
// 			std::vector<int> vnCalibPos;
// 			vnCalibPos.push_back(nRemCalibPos);
// 			std::vector<CameraExposureType> vsmCameraExposureType;
// 
// 			for(i = 0; i < nPosNum; i++)
// 			{
// 				vsmCameraExposureType.push_back(eDmCodeSearchCameraExposure);
// 			}
// 
// 			if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType))
// 			{
// // 				m_bStatusBar = FALSE;
// // 				m_strStatusBarInfo1 = _T("切换二维码曝光失败");
// // 				m_strStatusBarInfo2 = _T("");
// // 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 				OnFailedCameraExposureSetting(strCmd);
// 			}
// 		}
// 	}
// 
// 
// 
// 	// 仅仅在标定XY时保存一遍标定前参数
// 	if (nMarkType ==0)
// 	{
// 		VisionAlignLogRecord(strCalibLogPath,_T(""),1);					// 标定日志开始记录
// 		// 标定参数记录
// 		CString StrCalibrate_Param = _T("");
// 		// 获取标定参数字符串
// 		CalibrateLogRecord_Param(nCalibPos,StrCalibrate_Param);
// 		// 写入日志
// 		VisionAlignLogRecord(strCalibLogPath,StrCalibrate_Param,FALSE);
// 	}
// 	
// 
// 
// 	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
// 	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
// 	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
// 	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
// 	if (m_bCmdParamAxisPosEanble)
// 	{
// 		bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
// 	}
// 	else
// 	{
// 		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
// 	}
// 
// 	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
// 	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
// 	{
// 		if (pPlatformAxisPos!=NULL)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;					
// 		}
// 		
// 		ReportCalibResultFCBS(FALSE);
// 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
// // 		m_strStatusBarInfo2 = _T("");
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
// 
// 		return FALSE;
// 	}
// 	else
// 	{
// 		SetCalibPlatformPos(pPlatformAxisPos);		
// 
// 		if (m_CalibPlatformAxisAbsPos.size()<nRemCalibPos+1)
// 		{
// 			m_CalibPlatformAxisAbsPos.resize(nRemCalibPos+1);
// 		}
// 		m_CalibPlatformAxisAbsPos.at(nRemCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 
// 		// 记录当前平台各个轴的绝对位置
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			// 			CTime t = CTime::GetCurrentTime();
// 			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strInfo;
// 			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 			strInfo = strTemp + strInfo;
// 
// 			// 			FILE *stream;
// 			// 			CString strPath = m_strAlignProcessData;
// 			// 			stream = fopen(strPath, _T("a+t"));
// 			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 			// 			fclose(stream);VCRemoveFile(strPath);		
// 
// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 
// 			/////GYM-标定日志记录
// 			strInfo.Format(_T(""));
// 			if (nMarkType==0)
// 			{
// 				strTemp.Format(_T("平台标定XY时平台的绝对位置:\n"));
// 			}
// 			else if (nMarkType==1)
// 			{
// 				strTemp.Format(_T("平台标定D时平台的绝对位置:\n"));
// 			}
// 
// 			strInfo += strTemp;
// 			strTemp.Format(_T("......X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"),pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 			strInfo += strTemp;
// 			VisionAlignLogRecord(strCalibLogPath,strInfo,FALSE);
// 			/////GYM
// 		}
// 
// 		if (pPlatformAxisPos)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;
// 		}
// 	}
// 
// 	//全局二维码靶标标定时，计算图像坐标到靶标坐标之间的映射关系
// 	if (nMarkType == 0 && optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
// 	{
// 		if (!ExecuteCalibWholeDmCodeBoardImgToBoard(nCalibPos))
// 		{
// 			ReportCalibResultFCBS(FALSE);
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 			return FALSE;
// 		}
// 	}
// 
// 	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
// 	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
// 	vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nRemCalibPos,nMarkType);
// 
// 	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType))
// 	{
// 	
// 		
// 		ReportCalibResultFCBS(FALSE);		
// 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_EIGHT_PLATFORM_POS_FAILED);
// // 		m_strStatusBarInfo2 = _T("");
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		return OnFailedGetCalibPlatformAxisMovePos(strCmd);
// 	}
// 	else
// 	{
// 		/////GYM-标定日志记录
// 		CString strInfo = _T("");
// 		CString strTemp = _T("");
// 		
// 		if (nMarkType==0)
// 		{
// 			strTemp.Format(_T("平台标定XY时所需要移动的绝对轴位置:\n"));
// 		}
// 		else if (nMarkType==1)
// 		{
// 			strTemp.Format(_T("平台标定D时所需要移动的绝对轴位置:\n"));
// 		}
// 		strInfo += strTemp;
// 		CPlatformXYDAxisPos* pAxisPos;
// 		for (int i=0; i<vpPlatformAxisPos.size(); i++)
// 		{
// 			strTemp.Empty();
// 			pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
// 			strTemp.Format(_T("......平台位置%d: X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
// 			strInfo = strInfo + strTemp;
// 
// 		}
// 		VisionAlignLogRecord(strCalibLogPath,strInfo,FALSE);
// 
// 		// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			// 			CTime t = CTime::GetCurrentTime();
// 			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strInfo;
// 			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
// 			strInfo = strTemp + strInfo;
// 
// 			CPlatformXYDAxisPos* pAxisPos;
// 			for (int i=0; i<vpPlatformAxisPos.size(); i++)
// 			{
// 				strTemp.Empty();
// 				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
// 
// 				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
// 				strInfo = strInfo + strTemp;
// 			}
// 
// 			// 			FILE *stream;
// 			// 			CString strPath = m_strAlignProcessData;
// 			// 			stream = fopen(strPath, _T("a+t"));
// 			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 			// 			fclose(stream);VCRemoveFile(strPath);	
// 
// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
// 		}
// 	}
// 
// 	// 3. 驱动平台到位并定位
// 	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
// 	std::vector<CMarkImagePos*> vpMarkImagePos;
// 	CMarkImagePos* pMarkImagePos = NULL;
// 	CMarkImagePos* pDisCorMarkImagePos = NULL;
// 
// 	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
// 	if (pCalibData == NULL || !pCalibData->IsValid())
// 	{
// 		ReportCalibResultFCBS(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// 	CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
// 	if (pCalibrateParam == NULL)
// 	{
// 		ReportCalibResultFCBS(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// 	int k=0;
// 	//	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum() - 1; k++)
// 	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType); k++)
// 	{         
// 		//EnterCriticalSection(&m_csResource);
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		//LeaveCriticalSection(&m_csResource);
// 
// 		pMarkImagePos = NULL;
// 		pDisCorMarkImagePos = NULL;
// 		// 驱动到位
// 		pPlatformXYDAxisPos = NULL;
// 		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);
// 
// 		if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
// 		{
// 
// 		   ReportCalibResultFCBS(FALSE);
// 
// // 			m_bStatusBar = FALSE;
// // 			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), k) ;
// // 			m_strStatusBarInfo2 = _T("");
// // 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 			return OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);
// 		}
// 
// 
// 		Sleep(100);
// 		// 将相机移动到多个位置，逐个定位
// 		pMarkImagePos = new CMarkImagePos;
// 		pMarkImagePos->SetMarkImagePosNum(1);
// 		pDisCorMarkImagePos = new CMarkImagePos;
// 		pDisCorMarkImagePos->SetMarkImagePosNum(1);
// 
// 		//for (int n=0; n<nCamPos; n++)
// 		{
// 
// 
// 
// 			// 等待搜索延时
// 			int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 			Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);
// 
// 			// 准备开始定位			
// 			std::vector<int> vnPosIndex;
// 			std::vector<SearchMode> vsmSearchMode;	
// 			vnPosIndex.push_back(nRemCalibPos);		// nCalibPos
// 
// 			if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 			{
// 				vsmSearchMode.push_back(eCalibSearch);	// 标定搜索
// 			}
// 			else
// 			{
// 				if (nMarkType==0)
// 				{
// 					vsmSearchMode.push_back(eCalibSearch);	// 标定搜索
// 
// 				}
// 				else if(nMarkType==1)
// 				{
// 					vsmSearchMode.push_back(eTargetSearch);	// 目标搜索
// 				}
// 			}
// 
// 			// 采集搜索图像
// 			if (!SnapSearchImage(vnPosIndex))
// 			{			
// 				
// 				ReportCalibResultFCBS(FALSE);				
// 		
// 				if (pMarkImagePos!=NULL)
// 				{
// 					delete pMarkImagePos;
// 					pMarkImagePos = NULL;
// 				}
// 
// 				if(pDisCorMarkImagePos != NULL)
// 				{
// 					delete pDisCorMarkImagePos;
// 					pDisCorMarkImagePos = NULL;
// 				}
// 
// 				for (int p=0; p<vpMarkImagePos.size(); p++)
// 				{
// 					if (vpMarkImagePos.at(p))
// 					{
// 						delete vpMarkImagePos.at(p);
// 						vpMarkImagePos.at(p) = NULL;
// 					}
// 				}  
// 
// // 				m_bStatusBar = FALSE;
// // 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// // 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// // 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 				return OnFailedSnapSearchImage(strCmd);
// 			}
// 
// 			// 定位
// 
// 			if (nMarkType==0)
// 			{
// 				m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
// 				m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;
// 
// 			}
// 			else if(nMarkType==1)
// 			{
// 				m_vnTargetSearchStartPatIndex[nRemCalibPos] = 0;
// 				m_vnTargetSearchEndPatIndex[nRemCalibPos] = 0;
// 			}
// 
// 			if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 			{
// 				if (k==0)
// 				{
// 					m_bIsFirstCalibPos = TRUE;
// 				}
// 				else
// 				{
// 					m_bIsFirstCalibPos = FALSE;
// 				}
// 			}
// 
// 			BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
// 			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
// 			{
// 				//PostMessageSaveVDBFile(vnPosIndex,eCalibSearch);
// 				ExeSaveVDBFile(vnPosIndex,eCalibSearch);
// 			}
// 			if (!optionInfo.m_bEnableDmCodeCalib || (GetCalibMarkPatternMode() != eCalibUseDmCode && GetCalibMarkPatternMode() != eWholeDmcodeBoardCalib))
// 			{
// 				if(nMarkType==1)
// 				{
// 					// 设定、显示结果图形
// 					m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
// // 					SetGuiAlnTargetImageMarkPos(vnPosIndex);
// // 					PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
// // 					if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
// // 					{
// // 						SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
// // 						PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
// // 					}
// // 					// SY
// // 					SetShowGuiTargetImageMarkPos(vnPosIndex);
// // 					PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
// 				}
// 			}
// 			
// 			// 分析定位结果，发送指令响应
// 			if (FALSE == bSearchSucceed)
// 			{			
// 				
// 				ReportCalibResultFCBS(FALSE);		
// 
// // 				m_bStatusBar = FALSE;
// // 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_MOVE_ROTATE_POS_SEARCH_FAILED), k);
// // 				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAM_MOVE_THEN_SEARCH_FAILED), nCalibPos); 
// // 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 				if (pMarkImagePos!=NULL)
// 				{
// 					delete pMarkImagePos;
// 					pMarkImagePos = NULL;
// 				}
// 
// 				if(pDisCorMarkImagePos != NULL)
// 				{
// 					delete pDisCorMarkImagePos;
// 					pDisCorMarkImagePos = NULL;
// 				}
// 
// 				for (int p=0; p<vpMarkImagePos.size(); p++)
// 				{
// 					if (vpMarkImagePos.at(p))
// 					{
// 						delete vpMarkImagePos.at(p);
// 						vpMarkImagePos.at(p) = NULL;
// 					}
// 				}  
// 				//return FALSE;
// 				return OnFailedCalibSearch(strCmd, k, nCalibPos);
// 			}
// 
// 
// 			// 保存定位结果	
// 			if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 			{
// 				pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	
// 			}
// 			else
// 			{
// 				if (nMarkType==0)
// 				{		
// 					if(pCalibrateParam->m_nEnableDisCor)
// 					{
// 						CCoordPos OutPutPoint;
// 						m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
// 						pDisCorMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
// 					}
// 					pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	
// 
// 				}
// 				else if (nMarkType==1)
// 				{
// 					if(pCalibrateParam->m_nEnableDisCor)
// 					{
// 						CCoordPos OutPutPoint;
// 						m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
// 						pDisCorMarkImagePos->SetMarkImagePos(0, m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
// 					}
// 					pMarkImagePos->SetMarkImagePos(0, m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));	
// 
// 				}
// 			}
// 		}
// 
// 		if(pCalibrateParam->m_nEnableDisCor)
// 		{
// 			CMarkImagePos * markpos = new CMarkImagePos(*pDisCorMarkImagePos);
// 			vpMarkImagePos.push_back(markpos); 
// 		}
// 		else
// 		{
// 			CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
// 			vpMarkImagePos.push_back(markpos); 
// 		}
// 		
// 		// 记录图像搜索数据
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			// 			CTime t = CTime::GetCurrentTime();
// 			// 			strTemp.Format(_T("\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strOut;
// 			CCoordPos cp;
// 			strOut = strTemp + _T("CalibSearch: ");		
// 			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
// 			{
// 				strTemp = _T("");
// 				cp = pMarkImagePos->GetMarkImagePos(i);
// 
// 				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 				strOut += strTemp;
// 			}
// 
// 			if(pCalibrateParam->m_nEnableDisCor)
// 			{
// 				for (int i=0; i<pDisCorMarkImagePos->GetMarkImagePosNum(); i++)
// 				{
// 					strTemp = _T("");
// 					cp = pDisCorMarkImagePos->GetMarkImagePos(i);
// 
// 					strTemp.Format(_T("DisCorMarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 					strOut += strTemp;
// 				}
// 			}
// 
// 			// 			FILE *stream;
// 			// 			CString strPath = m_strAlignProcessData;
// 			// 			stream = fopen(strPath, _T("a+t"));               
// 			// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
// 			// 			fclose(stream);VCRemoveFile(strPath);
// 
// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
// 			VisionAlignLogRecord(m_strAlignProcessData, strOut);
// 		}
// 		if (pMarkImagePos!=NULL)
// 		{
// 			delete pMarkImagePos;
// 			pMarkImagePos = NULL;
// 		}  
// 		if(pDisCorMarkImagePos != NULL)
// 		{
// 			delete pDisCorMarkImagePos;
// 			pDisCorMarkImagePos = NULL;
// 		}
// 	}    	
// 	if (pMarkImagePos!=NULL)
// 	{
// 		delete pMarkImagePos;
// 		pMarkImagePos = NULL;
// 	}  
// 	if(pDisCorMarkImagePos != NULL)
// 	{
// 		delete pDisCorMarkImagePos;
// 		pDisCorMarkImagePos = NULL;
// 	}
// 
// 	// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具
// 	
// 	//全局二维码靶标标定时，XYPD平台进行XY标定时，计算靶标坐标到平台坐标的旋转缩放关系
// 	if (nMarkType == 0 && optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
// 	{
// 		if(FALSE == ExecuteCalibrateWholeDmcodeBoardBoardToPlatFCBS(vpMarkImagePos,nCalibPos,nMarkType))
// 		{		
// 			ReportCalibResultFCBS(FALSE);	
// 
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 			m_strStatusBarInfo2 = _T("");
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 
// 			for (k=0; k<vpMarkImagePos.size(); k++)
// 			{
// 				if (vpMarkImagePos.at(k))
// 				{
// 					delete vpMarkImagePos.at(k);
// 					vpMarkImagePos.at(k) = NULL;
// 				}
// 			} 
// 
// 			SaveCurAllCameraChannelSearchImg();		
// 			return FALSE;
// 		}
// 	}
// 	else
// 	{
// 		if(FALSE == ExecuteCalibrateFCBS(vpMarkImagePos,nCalibPos,nMarkType))
// 		{
// 
// 
// 			ReportCalibResultFCBS(FALSE);	
// 
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 			m_strStatusBarInfo2 = _T("");
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 			for (k=0; k<vpMarkImagePos.size(); k++)
// 			{
// 				if (vpMarkImagePos.at(k))
// 				{
// 					delete vpMarkImagePos.at(k);
// 					vpMarkImagePos.at(k) = NULL;
// 				}
// 			} 
// 
// 			SaveCurAllCameraChannelSearchImg();		
// 			return FALSE;
// 		}
// 	}
// 	
// 	// GYM-标定日志记录 -平台标定时图像坐标
// 	{
// 		CString strOut = _T("");		
// 		CString strTemp = _T("");	
// 		strOut.Empty();
// 		strTemp.Empty();
// 		
// 		if (nMarkType==0)
// 		{
// 			strTemp.Format(_T("平台标定XY时图像坐标:\n"));
// 		}
// 		else if (nMarkType==1)
// 		{
// 			strTemp.Format(_T("平台标定D时图像坐标:\n"));
// 		}
// 
// 		strOut += strTemp;
// 		for (int i=0; i<vpMarkImagePos.size(); i++)
// 		{
// 			strTemp.Empty();
// 			CCoordPos cp;
// 			cp = vpMarkImagePos.at(i)->GetMarkImagePos(0);
// 			strTemp.Format(_T("......MarkPos%d: X: %.2f; Y: %.2f; D: %.3f;\n"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 			strOut += strTemp;
// 
// 		}
// 		VisionAlignLogRecord(strCalibLogPath,strOut, FALSE);
// 	}
// 	// GYM-标定日志记录
// 
// 	// GYM-标定日志记录-图像坐标分析
// 	CString strOut = _T("");	
// 	CalibrateLogRecord_ImagePos(nCalibPos,nMarkType,vpMarkImagePos,strOut,AnalysisResultXYPD,CalibrateMoveRangeXYPD);
// 	VisionAlignLogRecord(strCalibLogPath,strOut, FALSE);
// 	// GYM
// 
// 	// 5. 释放内存
// 	for (k=0; k<vpMarkImagePos.size(); k++)
// 	{
// 		if (vpMarkImagePos.at(k))
// 		{
// 			delete vpMarkImagePos.at(k);
// 			vpMarkImagePos.at(k) = NULL;
// 		}
// 	}   
// 	
// 	//全局二维码靶标标定时，XYPD平台进行XY标定时，保存计算得到的靶标坐标到平台坐标的旋转缩放关系
// 	if(nMarkType == 0 && optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
// 	{
// 		//////////////////////////////////////// 获取标定结果///////////////////////////////////////////
// 
// 		// 获取系统标定后的所有信息
// 		std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 		vpAllCalibratedInfo = GetAllCalibratedInfo();
// 
// 		int nExProductIdx = nCalibPos/GetPosNum();
// 
// 		CPlatformOptionInfo optionInfo;
// 		GetPlatformOptionInfo(optionInfo);
// 		if(optionInfo.m_bAutoCopyCalibData)
// 		{
// 			//复制标定
// 
// 			ExecuteCopyCalibrateData(2,nExProductIdx);
// 		}
// 		else
// 		{
// 			/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 			SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 			// 保存标定后信息到当前产品中及配置文件中
// 			SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 		}
// 
// 
// 		// 保存目标定位结果信息
// 		m_bTargetMarkSearchSucceed = FALSE;	
// 		m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
// 		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
// 		SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
// 	}
// 
// // 	if (nMarkType==0 ||nMarkType==1)
// // 	{
// // 		ReportCalibResultFCBS(TRUE);	
// // 		return TRUE;
// // 
// // 	}
// 
// 	
// 	/////////////////////////////////////// 平台标定求精//////////////////////////////////////////
// 	// 
// 
// 
// 	//////////////////////////////////////// 相机标定/////////////////////////////////////////////
// 
// 
// 
// 
// 	//////////////////////////////////////// 获取标定结果///////////////////////////////////////////
// 
// 
// 
// 	return TRUE;
// }

BOOL vcXYDVisionAlign::ReportAlignResultFAAO(CCoordPos platOffset, BOOL bResult,CPlatformXYDAxisPos* pPlatformXYDAxisPos)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFAAO(strSimpleInfo,platOffset,bResult,pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAAOAxisPos(strSend, platOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAAO(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFAAO(strInfo,platOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportAlignResultFOLC(CCoordPos platOffset, BOOL bResult, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL */)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFOLC(strSimpleInfo,platOffset,bResult,pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFOLCAxisPos(strSend, platOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFOLC(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFOLC(strInfo,platOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;

}

BOOL vcXYDVisionAlign::ReportAlignResultFABO(CCoordPos platOffset, BOOL bResult, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL */ )
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFABO(strSimpleInfo,platOffset,bResult,pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFABOAxisPos(strSend, platOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFABO(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFABO(strInfo,platOffset,bResult,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;

}

BOOL vcXYDVisionAlign::ReportAlignResultFAAL( BOOL bResult , BOOL bAlignBench /*= FALSE*/, CCoordPos platOffset /*= CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL*/, CPlatformXYDAxisPos* pTargetOffsetPlatformXYDAxisPos /*= NULL*/)
{
	if (m_pAlignerTool == NULL)
	{
		return FALSE;
	}
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	if (NULL ==pAlignerParam)
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFAAL(strSimpleInfo,bResult,bAlignBench,platOffset,pAlignerParam->GetEnableAlnTargetOffset() && pAlignerParam->GetEnableAlnSendTargetOffsetToPLC(),pTargetOffsetPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAALBenchAxisPos(strSend, bResult,optionInfo.m_bEnableAlignBenchCenter,platOffset,pPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}		

		// 对位成功且启用目标多次对位补偿以及发送补偿到PLC时，打包发送TargetOffset
		if (bResult && pAlignerParam->GetEnableAlnTargetOffset() && pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
		{
			if (FALSE == m_XYDCommProtocol.PackPlcWriteDrivePlatformMoveToAbsPosBackup(strSend,pTargetOffsetPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAAL(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFAAL(strInfo,bResult,bAlignBench,platOffset,pAlignerParam->GetEnableAlnTargetOffset() && pAlignerParam->GetEnableAlnSendTargetOffsetToPLC(),pTargetOffsetPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}
	return TRUE;

}


BOOL vcXYDVisionAlign::ReportAlignResultFXYA(BOOL bResult, BOOL bAlignBench/* = FALSE*/, CCoordPos platOffset/* = CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL*/)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFXYA(strSimpleInfo,bResult,bAlignBench,platOffset);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;


		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFXYABenchAxisPos(strSend, bResult,optionInfo.m_bEnableAlignBenchCenter,platOffset,pPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFXYA(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFXYA(strInfo,bResult,bAlignBench,platOffset))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}
	return TRUE;

}


BOOL vcXYDVisionAlign::ReportAlignResultFAAB( BOOL bResult , BOOL bAlignBench /*= FALSE*/, 
	CCoordPos platOffset /*= CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFAAB(strSimpleInfo,bResult,bAlignBench,platOffset,pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAABAxisPos(strSend, bResult,bAlignBench,platOffset,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAAB(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFAAB(strInfo,bResult,bAlignBench,platOffset,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;

}

//相机轴标定
BOOL vcXYDVisionAlign::OnlineFCPRCalibrate(int nCalibPos, int nCalibType)
{
	CString strCmd = _T("VCRP:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	switch(nCalibType)
	{
	case 0:
		{
			m_strStatusBarInfo2.Format(_T("正在进行位置%d基准相机轴注册…"),nCalibPos+1);
		}
		break;
	case 1:
		{
			m_strStatusBarInfo2.Format(_T("正在进行位置%d实时相机轴注册…"),nCalibPos+1);
		}
		break;
	case 2:
		{
			m_strStatusBarInfo2.Format(_T("正在执行位置%d相机轴标定…"),nCalibPos+1);
		}
		break;

	}
	//m_strStatusBarInfo2 = _T("正在进行相机轴标定…");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	BOOL bSucceed = FALSE;

	if(nCalibPos<0 || nCalibPos>=(m_pPlatformInfo->m_nMultiCalibExtensionMaxNum+1)*m_pPlatformInfo->m_nPositionNum)
	{
		ReportCamCalibResult(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_FAIL);
		m_strStatusBarInfo2 = _T("扩展序号超过扩展数目");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	int nRemCalibPos = nCalibPos%GetPosNum();
	int nExProductIndex = nCalibPos/GetPosNum();
	m_pAlignerTool->SetAlignExProductIndex(nExProductIndex);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{

		ReportCamCalibResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_FAIL);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	switch(nCalibType)
	{
	case 0:
		{
			//获取相机轴位置
			std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
			CPlatformXYAxisPos* pCameraAxisPos = NULL;
			for(int i = 0; i < 2 ; i++)
			{
				pCameraAxisPos = new CPlatformXYAxisPos;
				vpCamPlatformXYAxisPos.push_back(pCameraAxisPos);
			}
			BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 

			bCommuciateGetPlatformAxisAbsPos = CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos);
			if(!bCommuciateGetPlatformAxisAbsPos)
			{
				for(int i = 0; i < vpCamPlatformXYAxisPos.size(); i++)
				{
					if(vpCamPlatformXYAxisPos.at(i) != NULL)
						delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_BENCH_FAIL);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				ReportCamCalibResult(FALSE);
				return FALSE;
			}
			else
			{
				for(int i = 0; i < vpCamPlatformXYAxisPos.size() ; i++)
				{
					if(vpCamPlatformXYAxisPos.at(i) == NULL)
					{
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_BENCH_FAIL);
						m_strStatusBarInfo2 = _T("");
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();

						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

						for(int i = 0; i < vpCamPlatformXYAxisPos.size(); i++)
						{
							if(vpCamPlatformXYAxisPos.at(i) != NULL)
								delete vpCamPlatformXYAxisPos.at(i);
							vpCamPlatformXYAxisPos.at(i) = NULL;
						}

						ReportCamCalibResult(FALSE);
						return FALSE;
					}
				}


				//设置基准相机轴位置
				m_pAlignerTool->SetCalibCamPlatformPos(nCalibPos,vpCamPlatformXYAxisPos.at(0));
				m_pAlignerTool->SetCalibCamAxisPlatformAxisPos(nCalibPos,vpCamPlatformXYAxisPos.at(1));
				if(nRemCalibPos >= m_pPlatformInfo->m_nPositionNum/2 && nRemCalibPos < m_pPlatformInfo->m_nPositionNum
					&& m_pPlatformInfo->m_bTargetObjectCamSeparate)
				{
					SetTargetCamPlatformPos(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);					// 相机轴
					SetTempTargetCamAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(0));
					SetTargetCamPlatformPos_MultiEx(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);			// 产品扩展，相机轴

					SetTargetCamAxisPlatformAxisPos(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);			// 相机所在平台轴
					SetTempTargetCamAxisPlatformAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(1));
					SetTargetCamAxisPlatformAxisPos_MultiEx(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);	// 产品扩展，相机所在平台轴

					SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
				}
				else if (nRemCalibPos >= 0 && nRemCalibPos < m_pPlatformInfo->m_nPositionNum /2 && 
					m_pPlatformInfo->m_bTargetObjectCamSeparate)
				{
					SetObjectCamPlatformPos(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTempObjectCamAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(0));
					SetObjectCamPlatformPos_MultiEx(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);

					SetObjectCamAxisPlatformAxisPos(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SetTempObjectCamAxisPlatformAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(1));
					SetObjectCamAxisPlatformAxisPos_MultiEx(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);

					SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
				}
				else if(nRemCalibPos >= 0 && nRemCalibPos < m_pPlatformInfo->m_nPositionNum && 
					!m_pPlatformInfo->m_bTargetObjectCamSeparate)
				{
					SetTargetCamPlatformPos(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTempTargetCamAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(0));
					SetTargetCamPlatformPos_MultiEx(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTargetCamAxisPlatformAxisPos(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SetTempTargetCamAxisPlatformAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(1));
					SetTargetCamAxisPlatformAxisPos_MultiEx(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

					SetObjectCamPlatformPos(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTempObjectCamAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(0));
					SetObjectCamPlatformPos_MultiEx(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetObjectCamAxisPlatformAxisPos(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SetTempObjectCamAxisPlatformAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(1));
					SetObjectCamAxisPlatformAxisPos_MultiEx(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
				}

				for(int i = 0; i < vpCamPlatformXYAxisPos.size(); i++)
				{
					if(vpCamPlatformXYAxisPos.at(i) != NULL)
						delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
				//////////////////////////////////////// 获取标定结果///////////////////////////////////////////

				// 获取系统标定后的所有信息
				std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
				vpAllCalibratedInfo = GetAllCalibratedInfo();

				if (sysPlatformInfo.m_bEnableObjectCalibBench && (sysPlatformInfo.m_nObjectCalibBenchIndex!=nCalibPos))
				{
					if (sysPlatformInfo.m_nObjectCalibBenchIndex < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[m_pPlatformInfo->m_nObjectCalibBenchIndex] != NULL && vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex]->IsValid())
					{
						CPlatformXYDAxisPos*  pBenchPlatformAxisPos = (CPlatformXYDAxisPos* )vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex]->GetPlatformAxisPos();
						CPlatformXYDAxisPos * pCurrentPlatformAxisPos = (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
						CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 

						double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
						double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;


						//平台各轴的方向	
						int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
						int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

						if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
						if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;

						CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex ]->GetMarkPlatformCoordPos();
						CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();

						currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
						currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;



						vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
						vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
					}


				}

				/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
				SetCurCalibratedInfo(vpAllCalibratedInfo);	

				// 保存标定后信息到当前产品中及配置文件中
				SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);


				// 保存标定位置为目标基准位置
				int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
				CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);
				if (TRUE == m_pPlatformInfo->m_bEnableTargetBench)
				{
					for (int i = 0; i < vpAllCalibratedInfo.size(); i++)
					{
						if (m_vpTargetPlatformAxisPos.at(i) != NULL)
						{
							*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i)) = *((CPlatformXYDAxisPos*)vpAllCalibratedInfo.at(i)->GetPlatformAxisPos());
							//				m_vpTargetPlatformAxisPos.at(i) = vpAllCalibratedInfo.at(i)->GetPlatformAxisPos();
						}
						else
						{
							m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
							*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i)) = *((CPlatformXYDAxisPos*)vpAllCalibratedInfo.at(i)->GetPlatformAxisPos());
						}
						{
							SetTargetPlatformPos(m_vpTargetPlatformAxisPos.at(i),i);
							SetTempTargetPlatformAxisPos(i,m_vpTargetPlatformAxisPos.at(i));
						}
					}


				}	
			}
			m_bStatusBar = TRUE;
			/*m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_BENCH_SUCCEED);*/
			m_strStatusBarInfo1.Format(_T("位置%d"),nCalibPos+1);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_BENCH_SUCCEED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			ReportCamCalibResult(TRUE);
			return TRUE;
		}
		break;

	case 1:
		{
			//获取相机轴位置
			std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
			CPlatformXYAxisPos* pCameraAxisPos = NULL;
			for(int i = 0; i < 2 ; i++)
			{
				pCameraAxisPos = new CPlatformXYAxisPos;
				vpCamPlatformXYAxisPos.push_back(pCameraAxisPos);
			}
			BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 

			bCommuciateGetPlatformAxisAbsPos = CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos);
			if(!bCommuciateGetPlatformAxisAbsPos)
			{
				for(int i = 0; i < vpCamPlatformXYAxisPos.size(); i++)
				{
					if(vpCamPlatformXYAxisPos.at(i))
						delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_GET_CAM_AXIS_FAIL);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

				ReportCamCalibResult(FALSE);
				return FALSE;
			}
			else
			{
				if(vpCamPlatformXYAxisPos.at(0) == NULL)
				{

					for(int i = 0; i < vpCamPlatformXYAxisPos.size(); i++)
					{
						if(vpCamPlatformXYAxisPos.at(i))
							delete vpCamPlatformXYAxisPos.at(i);
						vpCamPlatformXYAxisPos.at(i) = NULL;
					}

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_SET_CAM_AXIS_FAIL);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					ReportCamCalibResult(FALSE);
					return FALSE;
				}

				if(nRemCalibPos >= m_pPlatformInfo->m_nPositionNum/2 && nRemCalibPos < m_pPlatformInfo->m_nPositionNum
					&& m_pPlatformInfo->m_bTargetObjectCamSeparate)
				{
					SetTargetCamPlatformPos(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTempTargetCamAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(0));
					SetTargetCamPlatformPos_MultiEx(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);

					SetTargetCamAxisPlatformAxisPos(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SetTempTargetCamAxisPlatformAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(1));
					SetTargetCamAxisPlatformAxisPos_MultiEx(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);

					SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
				}
				else if (nRemCalibPos >= 0 && nRemCalibPos < m_pPlatformInfo->m_nPositionNum /2 && 
					m_pPlatformInfo->m_bTargetObjectCamSeparate)
				{
					SetObjectCamPlatformPos(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTempObjectCamAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(0));
					SetObjectCamPlatformPos_MultiEx(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);

					SetObjectCamAxisPlatformAxisPos(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SetTempObjectCamAxisPlatformAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(1));
					SetObjectCamAxisPlatformAxisPos_MultiEx(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);

					SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
				}
				else if(nRemCalibPos >= 0 && nRemCalibPos < m_pPlatformInfo->m_nPositionNum && 
					!m_pPlatformInfo->m_bTargetObjectCamSeparate)
				{
					SetTargetCamPlatformPos(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTempTargetCamAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(0));
					SetTargetCamPlatformPos_MultiEx(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTargetCamAxisPlatformAxisPos(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SetTempTargetCamAxisPlatformAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(1));
					SetTargetCamAxisPlatformAxisPos_MultiEx(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

					SetObjectCamPlatformPos(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetTempObjectCamAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(0));
					SetObjectCamPlatformPos_MultiEx(vpCamPlatformXYAxisPos.at(0),nRemCalibPos);
					SetObjectCamAxisPlatformAxisPos(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SetTempObjectCamAxisPlatformAxisPos(nRemCalibPos,vpCamPlatformXYAxisPos.at(1));
					SetObjectCamAxisPlatformAxisPos_MultiEx(vpCamPlatformXYAxisPos.at(1),nRemCalibPos);
					SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
				}
			}

			for(int i = 0; i < vpCamPlatformXYAxisPos.size(); i++)
			{
				if(vpCamPlatformXYAxisPos.at(i))
					delete vpCamPlatformXYAxisPos.at(i);
				vpCamPlatformXYAxisPos.at(i) = NULL;
			}
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1.Format(_T("位置%d"),nCalibPos+1);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_CAM_AXIS_SUCCEED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			ReportCamCalibResult(TRUE);
			return TRUE;
		}
		break;
	case 2:
		{
			// 隐藏对象结果图形			
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			std::vector<int> vnObjectPosIndex;
			int nObjectPosIndex = 0;
			int i = 0;
			for(i = 0; i < nPosNum; i++)
			{
				nObjectPosIndex = i;
				vnObjectPosIndex.push_back(nObjectPosIndex);
			}	
			// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
			// 			//if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
			// 			{
			// 				PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnObjectPosIndex, FALSE);
			// 			}
			// 			// SY
			// 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
			m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);

			// 隐藏目标结果图形	
			std::vector<int> vnTargetPosIndex;
			int nTargetPosIndex = 0;
			for(i = 0; i < nPosNum; i++)
			{
				if (i==nCalibPos)
				{
					nTargetPosIndex = i;
					vnTargetPosIndex.push_back(nTargetPosIndex);
				}
			}	

			m_cVisionAlignGui.SetPosGuiInvisible(vnTargetPosIndex, eTargetSearch);
			// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnTargetPosIndex, FALSE);
			// 			// SY
			// 			PostMessageUpdateShowGuiTargetImagePosToDisplay(vnTargetPosIndex, FALSE);
			// 
			// 			if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
			// 			{
			// 				PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnTargetPosIndex, FALSE);
			// 			}
			// 			//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
			// 			{
			// 				PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnTargetPosIndex, FALSE);
			// 			}


			// 执行标定

			//    if (1 == m_pPlatformInfo->m_nCamNum)
			{		
				bSucceed = OnSingleCameraPostionCalibrateEx(nCalibPos); // 单相机对位系统标定
			}
			// 	else
			// 	{	
			//         bSucceed = OnSerialCamreaAlignerCalibrateEx(); // 多相机对位系统标定
			// 	}
			// 	
			// 返回结果
			if (TRUE == bSucceed)
			{	

				ReportCamCalibResult(TRUE);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_SUCCEED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
			}
			else
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			}
		}
		break;
	}

	return bSucceed;
}


BOOL vcXYDVisionAlign::ReportAlignResultFAAC( BOOL bResult , BOOL bAlignBench /*= FALSE*/, CCoordPos platOffset /*= CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL*/, CPlatformXYDAxisPos* pTargetOffsetPlatformXYDAxisPos /*= NULL*/)
{
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	if (NULL ==pAlignerParam)
	{
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFAAC(strSimpleInfo,bResult,bAlignBench,platOffset,pAlignerParam->GetEnableAlnTargetOffset() && pAlignerParam->GetEnableAlnSendTargetOffsetToPLC(),pTargetOffsetPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAACBenchAxisPos(strSend, bResult,optionInfo.m_bEnableAlignBenchCenter,platOffset,pPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 对位成功且启用目标多次对位补偿以及发送补偿到PLC时，打包发送TargetOffset
		if (bResult && pAlignerParam->GetEnableAlnTargetOffset() && pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
		{
			if (FALSE == m_XYDCommProtocol.PackPlcWriteDrivePlatformMoveToAbsPosBackup(strSend,pTargetOffsetPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAAC(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFAAC(strInfo,bResult,bAlignBench,platOffset,pAlignerParam->GetEnableAlnTargetOffset() && pAlignerParam->GetEnableAlnSendTargetOffsetToPLC(),pTargetOffsetPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;

}

BOOL vcXYDVisionAlign::ReportAlignResultFAOT( BOOL bResult , BOOL bAlignBench /*= FALSE*/, CCoordPos platOffset /*= CCoordPos(0,0,0)*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFAOT(strSimpleInfo,bResult,bAlignBench,platOffset);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAOTAxisPos(strSend, bResult,bAlignBench,platOffset))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAOT(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFAOT(strInfo,bResult,bAlignBench,platOffset))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;

}

BOOL vcXYDVisionAlign::ReportAlignResultFALX( BOOL bResult , BOOL bAlignBench /*= FALSE*/, CCoordPos platOffset /*= CCoordPos(0,0,0)*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFALX(strSimpleInfo,bResult,bAlignBench,platOffset);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALXAxisPos(strSend, bResult,bAlignBench,platOffset))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALX(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFALX(strInfo,bResult,bAlignBench,platOffset))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;

}

BOOL vcXYDVisionAlign::ReportAlignResultFACB( BOOL bResult , BOOL bAlignBench /*= FALSE*/, 
	CCoordPos platOffset /*= CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pPlatformXYDAxisPos/* = NULL*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFACB(strSimpleInfo,bResult,bAlignBench,platOffset,pPlatformXYDAxisPos);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACBAxisPos(strSend, bResult,bAlignBench,platOffset,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFACB(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFACB(strInfo,bResult,bAlignBench,platOffset,pPlatformXYDAxisPos))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;

}

BOOL vcXYDVisionAlign::ReportAlignResultFAHL( BOOL bResult , BOOL bAlignBench /*= FALSE*/, CCoordPos platOffset /*= CCoordPos(0,0,0)*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFAHL(strSimpleInfo,bResult,bAlignBench,platOffset);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFAHL(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFAHL(strInfo,bResult,bAlignBench,platOffset))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;

}


BOOL vcXYDVisionAlign::ReportAlignResultFALG(CPlatformXYDAxisPos* pPlatformXYDAxisPos,BOOL bResult, CCoordPos platBenchOffset/* = CCoordPos(0,0,0)*/, CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos/* = NULL*/)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFALG(strSimpleInfo,pPlatformXYDAxisPos,bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALGBenchAxisPos(strSend, bResult, optionInfo.m_bEnableAlignBenchCenter, platBenchOffset, pBenchPlatformXYDAxisPos))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}
		}



		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALGAxisPos(strSend,pPlatformXYDAxisPos,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALG(strSend,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFALG(strInfo,pPlatformXYDAxisPos,bResult))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;

}


BOOL vcXYDVisionAlign:: ReportMulAlignPosResultFALP(std::vector<std::vector<CPlatformXYDAxisPos>> vvPlatformXYDAxisPos,BOOL bResult)
{
	if(vvPlatformXYDAxisPos.size() <= 0)
	{
		bResult = FALSE;
	}
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		// 		if (vPlatformXYDAxisPos.size() == 0)
		// 		{
		// 			return FALSE;
		// 		}

		CString strSimpleInfo;
		m_XYDCommProtocol.PackReMulAlignPosInfoFALP(strSimpleInfo,vvPlatformXYDAxisPos,bResult,m_nPickMutiExMode);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (bResult)
		{
			// 打包写寄存器指令
			std::vector<int> vnSend;
			int nRegAddr;
			if (FALSE == m_XYDCommProtocol.PackRePlcMulAlignPosResultInfoFALPAxisPos(strSend,vnSend,nRegAddr,vvPlatformXYDAxisPos, bResult,m_nPickMutiExMode))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			//bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			bReceived = CommunicateWriteReg(vnSend,strInfo,nCommStatus,nRegAddr,true,false);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALP(strSend,bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}


			// 视觉指令触发置位
			if (!SetVisionPlatformTrigger())
			{
				return FALSE;
			}
		}
		else
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALP(strSend,bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}


			// 视觉指令触发置位
			if (!SetVisionPlatformTrigger())
			{
				return FALSE;
			}
		}
	}
	else
	{
		// 		if (vPlatformXYDAxisPos.size() == 0)
		// 		{
		// 			return FALSE;
		// 		}

		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReMulAlignPosInfoFALP(strInfo,vvPlatformXYDAxisPos,bResult,m_nPickMutiExMode))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}


	return TRUE;
}


BOOL vcXYDVisionAlign::ReportAlignResultFALP(CPlatformXYDAxisPos* pPlatformXYDAxisPos,BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFALP(strSimpleInfo,pPlatformXYDAxisPos,bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALPAxisPos(strSend,pPlatformXYDAxisPos,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALP(strSend,bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFALP(strInfo,pPlatformXYDAxisPos,bResult))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;

}

BOOL vcXYDVisionAlign::ReportAlignResultFALP_int(CPlatformXYDAxisPos* pPlatformXYDAxisPos,int nResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		BOOL bres = FALSE;
		if (nResult == -1)
		{
			bres = FALSE;
		}
		else
		{
			bres =TRUE;

		}
		m_XYDCommProtocol.PackReAlignResultInfoFALP(strSimpleInfo,pPlatformXYDAxisPos,TRUE);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令

		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALPAxisPos(strSend,pPlatformXYDAxisPos,bres))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFALP_int(strSend,nResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultInfoFALP_int(strInfo,pPlatformXYDAxisPos,nResult))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;

}


BOOL vcXYDVisionAlign::ReportAlignResultNumberFALP(CPlatformXYDAxisPos* pPlatformXYDAxisPos,int nResultNumber)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultNumberInfoFALP(strSimpleInfo,pPlatformXYDAxisPos,nResultNumber);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultNumberInfoFALPAxisPos(strSend,pPlatformXYDAxisPos,nResultNumber))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultNumberInfoFALP(strSend,nResultNumber))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReAlignResultNumberInfoFALP(strInfo,pPlatformXYDAxisPos,nResultNumber))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}


BOOL vcXYDVisionAlign::SendDrivePlatformAxisMoveEx(CPlatformXYDAxisPos* pPlatformXYDAxisPos)
{

	CCoordPos platOffset;	
	platOffset.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
	platOffset.m_dPosY= pPlatformXYDAxisPos->m_dPosY;
	platOffset.m_dAngle= pPlatformXYDAxisPos->m_dAngle;


	// 打包“写寄存器”指令
	CString strInfo;
	if (!m_XYDCommProtocol.PackReAlignResultInfoFACO(strInfo,platOffset,TRUE,NULL))
	{
		return FALSE;
	}	

	// 发送“写寄存器”指令
	if (FALSE == SendCommInfo(strInfo))	
	{
		return FALSE;
	}

	return TRUE;
}

// 两个及两个以上相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetSearchCandidateExFTGC(std::vector<int> vnPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VTGC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	//	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
		return FALSE;
	}

	// 检查 vnPosIndex值是否合理 规避异常值传入导致错误的相机在线检查报警
	for(i=0; i<nPosNum; i++)
	{	
		nPosIndex = vnPosIndex[i];
		if(nPosIndex>=0 && nPosIndex <GetPosNum())
		{
			continue;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
			return FALSE;
		}
	}

	//	int i=0;
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
			return FALSE;
		}    	
	}

	//	int nPosNum = m_pPlatformInfo->m_nPositionNum;

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nStartPatIndex);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter /*&& (0 == nStartPatIndex)*/)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (m_vpTargetPlatformAxisPos.size() <= 0 
			|| m_vpTargetPlatformAxisPos.at(vnPosIndex[0]) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(vnPosIndex[0]));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))		
	if (!bCommuciateGetPlatformAxisAbsPos)	
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			nPosIndex = vnPosIndex[i];
			SetTargetPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			}
		}
		m_AlignerAxisInfo.m_vdAxis.at(0) = pPlatformAxisPos->m_dPosX;
		m_AlignerAxisInfo.m_vdAxis.at(1) = pPlatformAxisPos->m_dPosY;
		m_AlignerAxisInfo.m_vdAxis.at(2) = pPlatformAxisPos->m_dAngle;
		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	if (0/*(m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX)*/)
	{
		for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
		{
			pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
			vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);      
		}

		if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos))
		{
			if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_GET_CAMERA_PLATFORM_POS_FAILED_II);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
		else
		{
			//SetTargetCamPlatformPos(vpCamPlatformXYAxisPos);

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strInfo;
				strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_CAM_PLATFORM_POS);
				strInfo = strTemp + strInfo;

				for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
				{
					strTemp = _T("");
					strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
					strInfo = strInfo + strTemp;
				}

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));
				// 				fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}
		}	
	}


	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	//	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	// 定义全部位置向量，包含0/1对象和2/3目标
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;

	//	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		//		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eTargetSearch);	// 

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex-GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);
		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 		//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		//         //HideExtraGraphics(vnAllPosIndex);
		//         ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);

		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		//         //HideExtraGraphics(vnPosIndex);
		//         ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
	BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (bTargetSearchCandidate == FALSE)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bTargetSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[vnPosIndex[0]];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = TARGETCANDIDATENUM-1;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{
				if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
				{
					continue;
				}

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					m_vnTargetSearchStartPatIndex[nPosIndex] = j;
					m_vnTargetSearchEndPatIndex[nPosIndex] = j;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				if (bSearchSucceed)
				{
					break;
				}
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
	}


	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
				BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
				if (bTargetSearchCandidate == FALSE)
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
				else
				{
					if (bTargetSearchSync == TRUE)
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
						{
							nTempStartPatIndex = nStartPatIndex;
						}
						else if (nStartPatIndex == 9)
						{
							nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[vnPosIndex[0]];
						}
						else
						{
							nTempStartPatIndex = 0;
						}
						nTempEndPatIndex = TARGETCANDIDATENUM-1;

						int j = 0;
						for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
						{
							if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
							{
								continue;
							}

							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								m_vnTargetSearchStartPatIndex[nPosIndex] = j;
								m_vnTargetSearchEndPatIndex[nPosIndex] = j;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
							if (bSearchSucceed)
							{
								break;
							}
						}
					}
					else
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
							{
								nTempStartPatIndex = nStartPatIndex;
							}
							else if (nStartPatIndex == 9)
							{
								nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
							}
							else
							{
								nTempStartPatIndex = 0;
							}
							nTempEndPatIndex = TARGETCANDIDATENUM-1;

							m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
							m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		// SendCommInfo(CMD_TGG_SEARCH_SUCCEED);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		vnHomoPosIndex = vnPosIndex;

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					//	ReportTargetSearchResultFTGM(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					//return FALSE;
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		//         SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		//         PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);

		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		//         if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
		//         {
		//             SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // 设定、显示目标定位结果文字，全部0/1/2/3图像
		//         SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		//         PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
	}
	else
	{
		// 设定、显示结果图形
		// SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);


		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		//         if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
		//         {
		//             SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // SY
		//         SetShowGuiTargetImageMarkPos(vnPosIndex);
		//         PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
	}
	//if ((m_bIsTargetCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsTargetLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//{
	//ShowAllGuiAlnTargetExtraGraphics(nCurProdcutIndex,vnPosIndex);
	//    ShowExtraGuiToDisplay(vnPosIndex, TRUE,0);
	//}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		// SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = m_StrSearchErrorInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		m_strStatusBarInfo1 += m_StrSearchErrorInfo;
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		// 4. 失败，关闭定位
		// CloseSearch();
		//		CloseSearch(vCamIndex);

		//		RecordTargetSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 4. 关闭定位
	// CloseSearch();
	//	CloseSearch(vCamIndex);

	// 5. 设置对位工具
	m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}

	// 计算目标距离
	//CalculateTargetDistance(); 
	if (!optionInfo.m_bExeTargetCheckModeWhenAlign && !CheckTargetDistance())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//RecordTargetSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{	
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageTargetSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}
		}

		return FALSE;
	}

	//RecordTargetSizeIndfo(TRUE, TRUE);


	if (!optionInfo.m_bExeTargetCheckModeWhenAlign && !CheckTargetAngle())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	//for (int i=0;i<vnPosIndex.size();i++)
	//{
	//	int nIndx=vnPosIndex.at(i);
	//	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	//	{
	//		m_vbIsTargetPosSearchFinished.at(nIndx-GetPosNum()/2)=TRUE;
	//	}
	//	else
	//	{
	//		m_vbIsTargetPosSearchFinished.at(nIndx)=TRUE;
	//	}

	//}

	//BOOL bAllTargetPosSearch=TRUE;
	//for (int i=0;i<m_vbIsTargetPosSearchFinished.size();i++)
	//{
	//	bAllTargetPosSearch=bAllTargetPosSearch && m_vbIsTargetPosSearchFinished.at(i);
	//}
	//m_bAllTargetPosSearchSuccess=bAllTargetPosSearch;

	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1/* && m_bAllObjectPosSearchSuccess && m_bAllTargetPosSearchSuccess*/)
	{
		/*for (int i=0;i<m_vbIsTargetPosSearchFinished.size();i++)
		{
		m_vbIsTargetPosSearchFinished.at(i) = FALSE;
		}
		m_bAllTargetPosSearchSuccess = FALSE;*/
		return ExecuteAlignAfterFOBCAndFTGC(vnPosIndex,2);
	}

	if (bTargetSearchSync)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(TRUE, m_vnTargetSearchSuccessPatIndex[vnPosIndex[0]]);
	}
	else
	{
		if(m_bTargetSearchTest) ReportTargetSearchResult(TRUE, -1);
	}

	return TRUE;
}


//保存产品二维码信息
BOOL vcXYDVisionAlign::OnlineSaveQRCode()
{
	SYSTEMTIME sys; 
	GetLocalTime( &sys ); 
	CString t;
	t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
	CString strLogPath;
	CString strRecord;
	strLogPath.Format(_T("D:\\SNRecord.txt"));
	FILE *fileLog;
	fileLog = fopen(strLogPath,_T("a+t"));
	strRecord.Format(_T("%s收到存储指令\n"),t);
	fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
	fclose(fileLog);


	//读取二维码的信息============================================

	std::vector<int> vnReceivedData;
	CString strSend;
	//打包读取寄存器
	if(!m_XYDCommProtocol.PackPlcReadQRCode(strSend, 0,10))
	{
		GetLocalTime(&sys);
		t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
		fileLog = fopen(strLogPath,_T("a+t"));
		strRecord.Format(_T("%s打包读取寄存器字符串失败\n"),t);
		fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
		fclose(fileLog);
		ReportSaveQRCodeFQRC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	GetLocalTime(&sys);
	t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
	fileLog = fopen(strLogPath,_T("a+t"));
	strRecord.Format(_T("%s打包读取寄存器字符串成功\n"),t);
	fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
	fclose(fileLog);

	// 发送读取命令，接收PLC回复
	BOOL bReceived;
	CString strInfo;
	CommStatus nCommStatus = eCommSucceed;
	bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		GetLocalTime(&sys);
		t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
		fileLog = fopen(strLogPath,_T("a+t"));
		strRecord.Format(_T("%s发送读取命令失败,或读取数据失败\n"),t);
		fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
		fclose(fileLog);
		ReportSaveQRCodeFQRC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	GetLocalTime(&sys);
	t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
	fileLog = fopen(strLogPath,_T("a+t"));
	strRecord.Format(_T("%s读取寄存器成功\n"),t);
	fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
	fclose(fileLog);

	//解析读取的寄存器信息
	CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcReadQRCode(strInfo,vnReceivedData,10, FALSE);
	if(answeredStatus != eAswSucceed)
	{
		GetLocalTime(&sys);
		t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
		fileLog = fopen(strLogPath,_T("a+t"));
		strRecord.Format(_T("%s解析寄存器信息失败\n"),t);
		fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
		fclose(fileLog);
		ReportSaveQRCodeFQRC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	GetLocalTime(&sys);
	t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
	fileLog = fopen(strLogPath,_T("a+t"));
	strRecord.Format(_T("%s解析寄存器信息成功\n"),t);
	fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
	fclose(fileLog);

	int nCodeLen = 9;	
	vector<int> vnRQCode;
	for(int i = 0 ; i < nCodeLen ; i++)
	{
		int nByte4 = (vnReceivedData[i]>>24)&0xff;
		int nByte3 = (vnReceivedData[i]>>16)&0xff;
		int nByte2 = (vnReceivedData[i]>>8)&0xff;
		int nByte1 = (vnReceivedData[i])&0xff;
		vnRQCode.push_back(nByte1);
		vnRQCode.push_back(nByte2);
		vnRQCode.push_back(nByte3);
		vnRQCode.push_back(nByte4);
	}
	CString strResult;
	if(vnReceivedData[9] == 1)
	{
		strResult = _T("OK");
	}
	else
	{
		strResult = _T("NG");
	}
	CString str2DCoedInfo = "";
	CString strtmp;
	for (int i=0;i<vnRQCode.size();i++)
	{
		int nData = vnRQCode.at(i);
		//if (nData == 32 || nData == 0)
		//{
		//    strtmp = " ";
		//}
		//else if (nData == 43)
		//{
		//    strtmp = "+";
		//}
		//else if (nData >= 48 && nData <= 57)//数字
		//{
		//    strtmp.Format("%d",nData-48);
		//}
		//else if (nData >= 65 && nData <= 90)//大写字母
		//{
		//    switch(nData)
		//    {
		//    case 65:
		//        strtmp = "A";
		//        break;
		//    case 66:
		//        strtmp = "B";
		//        break;
		//    case 67:
		//        strtmp = "C";
		//        break;
		//    case 68:
		//        strtmp = "D";
		//        break;
		//    case 69:
		//        strtmp = "E";
		//        break;
		//    case 70:
		//        strtmp = "F";
		//        break;
		//    case 71:
		//        strtmp = "G";
		//        break;
		//    case 72:
		//        strtmp = "H";
		//        break;
		//    case 73:
		//        strtmp = "I";
		//        break;
		//    case 74:
		//        strtmp = "J";
		//        break;
		//    case 75:
		//        strtmp = "K";
		//        break;
		//    case 76:
		//        strtmp = "L";
		//        break;
		//    case 77:
		//        strtmp = "M";
		//        break;
		//    case 78:
		//        strtmp = "N";
		//        break;
		//    case 79:
		//        strtmp = "O";
		//        break;
		//    case 80:
		//        strtmp = "P";
		//        break;
		//    case 81:
		//        strtmp = "Q";
		//        break;
		//    case 82:
		//        strtmp = "R";
		//        break;
		//    case 83:
		//        strtmp = "S";
		//        break;
		//    case 84:
		//        strtmp = "T";
		//        break;
		//    case 85:
		//        strtmp = "U";
		//        break;
		//    case 86:
		//        strtmp = "V";
		//        break;
		//    case 87:
		//        strtmp = "W";
		//        break;
		//    case 88:
		//        strtmp = "X";
		//        break;
		//    case 89:
		//        strtmp = "Y";
		//        break;
		//    case 90:
		//        strtmp = "Z";
		//        break;
		//    default:
		//        break;
		//    }
		//}
		//else if (nData >= 97 && nData <= 122)//小写字母
		//{
		//    switch(nData)
		//    {
		//    case 97:
		//        strtmp = "a";
		//        break;
		//    case 98:
		//        strtmp = "b";
		//        break;
		//    case 99:
		//        strtmp = "c";
		//        break;
		//    case 100:
		//        strtmp = "d";
		//        break;
		//    case 101:
		//        strtmp = "e";
		//        break;
		//    case 102:
		//        strtmp = "f";
		//        break;
		//    case 103:
		//        strtmp = "g";
		//        break;
		//    case 104:
		//        strtmp = "h";
		//        break;
		//    case 105:
		//        strtmp = "i";
		//        break;
		//    case 106:
		//        strtmp = "j";
		//        break;
		//    case 107:
		//        strtmp = "k";
		//        break;
		//    case 108:
		//        strtmp = "l";
		//        break;
		//    case 109:
		//        strtmp = "m";
		//        break;
		//    case 110:
		//        strtmp = "n";
		//        break;
		//    case 111:
		//        strtmp = "o";
		//        break;
		//    case 112:
		//        strtmp = "p";
		//        break;
		//    case 113:
		//        strtmp = "q";
		//        break;
		//    case 114:
		//        strtmp = "r";
		//        break;
		//    case 115:
		//        strtmp = "s";
		//        break;
		//    case 116:
		//        strtmp = "t";
		//        break;
		//    case 117:
		//        strtmp = "u";
		//        break;
		//    case 118:
		//        strtmp = "v";
		//        break;
		//    case 119:
		//        strtmp = "w";
		//        break;
		//    case 120:
		//        strtmp = "x";
		//        break;
		//    case 121:
		//        strtmp = "y";
		//        break;
		//    case 122:
		//        strtmp = "z";
		//        break;
		//    default:
		//        break;
		//    }
		//}
		//else
		//{
		//    strtmp = "？";
		//}

		if(nData>=0 && nData<128)
		{
			char ch = (char)nData;
			CString strchar(ch);
			strtmp = strchar;
		}
		else
		{
			strtmp = "？";
		}

		str2DCoedInfo+=strtmp;
	}

	GetLocalTime(&sys);
	t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
	fileLog = fopen(strLogPath,_T("a+t"));
	strRecord.Format(_T("%sSN为%s\n"),t,str2DCoedInfo);
	fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
	fclose(fileLog);
	//strResult = str2DCoedInfo;
	//============================================================
	////判断路径是否存在，如果不存在就创建
	CString strPath;
	CString strWorkType;

	//LoadQRCodeOption();

	strPath = m_stUploadData.strSavePath;
	strWorkType = m_stUploadData.strWorkType;

	CFileFind fileFind;
	BOOL bFind;
	BOOL bDir;
	bFind = FALSE;
	bDir = FALSE;
	bFind = fileFind.FindFile(strPath);
	while(bFind)
	{
		bFind = fileFind.FindNextFile();
		bDir = fileFind.IsDirectory();
		if(bDir) break;
	}
	if(!bDir)
	{
		if(!CreateDirectory(strPath,NULL))
		{
			ReportSaveQRCodeFQRC(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OPERATE_FILE_FAIL);
			m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CREATE_PATH_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
	}

	SYSTEMTIME sysTime;
	GetLocalTime(&sysTime);
	//判断文件是否存在
	CString strFileName;
	strFileName.Format(_T("%s\\%s-2DCodeRecord.csv"),strPath,strWorkType);

	CString str;
	str.Format(_T("%04d.%02d.%02d-%02d.%02d.%02d.%03d"),sysTime.wYear,sysTime.wMonth,sysTime.wDay,sysTime.wHour,
		sysTime.wMinute,sysTime.wSecond,sysTime.wMilliseconds);
	CString strCSV;
	CStdioFile file;
	CFileStatus fileStatus;
	BOOL bRet = CFile::GetStatus(strFileName,fileStatus);
	//写文件
	if(!bRet)
	{
		strCSV.Format(_T("%s,%s,result\n"),"时间","SN");
		if(FALSE == SaveCSVToDisk(strFileName,strCSV,TRUE))
		{
			GetLocalTime(&sys);
			t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
			fileLog = fopen(strLogPath,_T("a+t"));
			strRecord.Format(_T("%s写CSV文件失败\n"),t);
			fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
			fclose(fileLog);
			ReportSaveQRCodeFQRC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OPERATE_FILE_FAIL);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		strCSV.Format(_T("%s,%s,%s\n"),str,str2DCoedInfo,strResult);
		if(FALSE == SaveCSVToDisk(strFileName,strCSV,FALSE))
		{
			GetLocalTime(&sys);
			t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
			fileLog = fopen(strLogPath,_T("a+t"));
			strRecord.Format(_T("%s写CSV文件失败\n"),t);
			fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
			fclose(fileLog);
			ReportSaveQRCodeFQRC(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OPERATE_FILE_FAIL);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
	}
	else
	{
		strCSV.Format(_T("%s,%s,%s\n"),str,str2DCoedInfo,strResult);
		if(FALSE == SaveCSVToDisk(strFileName,strCSV,FALSE))
		{
			GetLocalTime(&sys);
			t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
			fileLog = fopen(strLogPath,_T("a+t"));
			strRecord.Format(_T("%s写CSV文件失败\n"),t);
			fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
			fclose(fileLog);
			ReportSaveQRCodeFQRC(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OPERATE_FILE_FAIL);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
	}
	ReportSaveQRCodeFQRC(TRUE);
	m_bStatusBar = TRUE;
	//m_strStatusBarInfo1 = _T("");
	//m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_SUCCEED);
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_SUCCEED);;
	m_strStatusBarInfo2 = str2DCoedInfo;

	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	return TRUE;
}

// 打包回复检测二维码内容
BOOL vcXYDVisionAlign::ReportInspectQRCodeFQRI(BOOL bResult,std::vector<int> vCode,CString strCode)
{
	CString strSend;
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackRe_InspectQRCode(strSimpleInfo,vCode,bResult,strCode);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if(bResult)
		{
			// 打包写寄存器-写二维码数据
			if (FALSE == m_XYDCommProtocol.PackRePLC_InspectQRCode(strSend,vCode, bResult))
			{
				return FALSE;
			}
			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			// 打包写寄存器-写二维码检测指令和检测结果
			if (FALSE == m_XYDCommProtocol.PackRePlc_InspectQRCodeStatus(strSend, bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			// 视觉指令触发置位
			if (!SetVisionPlatformTrigger())
			{
				return FALSE;
			}

		}
		else
		{
			// 打包写寄存器-写二维码检测指令和检测结果
			if (FALSE == m_XYDCommProtocol.PackRePlc_InspectQRCodeStatus(strSend, bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			// 视觉指令触发置位
			if (!SetVisionPlatformTrigger())
			{
				return FALSE;
			}
		}



	}
	else
	{
		// 打包“写寄存器”指令
		if (!m_XYDCommProtocol.PackRe_InspectQRCode(strSend,vCode, bResult,strCode))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strSend))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

// 拍照检测二维码内容，并保持二维码内容
BOOL vcXYDVisionAlign::OnlineInspectQRCode(int nPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VQRI:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	std::vector<int> vCode;

	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		ReportInspectQRCodeFQRI(FALSE,vCode);
		return FALSE;
	}


	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{
		ReportInspectQRCodeFQRI(FALSE,vCode);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("二维码检测失败");
		m_strStatusBarInfo2 = _T("PLC发送参数超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			ReportInspectQRCodeFQRI(FALSE,vCode);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	vnPosIndex.push_back(nPosIndex);
	vsmSearchMode.push_back(eInspectSearch);

	// 检测模板曝光切换
	{
		CPlatformOptionInfo optionInfo;
		GetPlatformOptionInfo(optionInfo);
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		if (SystempOptionSearchShutter && bInspectShutter)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eInspectSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	Sleep(nDelayTime);

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eInspectSearch);

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportInspectQRCodeFQRI(FALSE,vCode);//
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bInspectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
	BOOL bSearchSucceed = FALSE;
	if (bInspectSearchCandidate == FALSE)
	{
		m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
		m_vnInspectSearchEndPatIndex[nPosIndex] = nStartPatIndex;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (nStartPatIndex >= 0 && nStartPatIndex < INSPECTCANDIDATENUM)
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
		}
		else if (nStartPatIndex == 9)
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = m_vnInspectSearchSuccessPatIndex[nPosIndex];
		}
		else
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = 0;
		}			
		m_vnInspectSearchEndPatIndex[nPosIndex] = INSPECTCANDIDATENUM;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	// 设定、显示结果图形
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eInspectSearch);

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eInspectSearch);
		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
	}

	// 获取二维码搜索结果
	CString strCode = _T("");
	CString strSendCode = _T("");
	int nSuccessPatIndex = m_vnInspectSearchSuccessPatIndex[nPosIndex];	
	CSearchResult TempSeachResults = GetAlnInspectSearchResult(nPosIndex,nSuccessPatIndex);
	if (!m_vbSearchSucceed[nPosIndex])
	{
		strCode.Format("NG");
	}
	else
	{
		// 没有获取到二维码
		if((TempSeachResults.m_vcodeDMResult.size()<=0) && (TempSeachResults.m_vcodeQRResult.size()<=0))
		{
			ReportInspectQRCodeFQRI(FALSE,vCode);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("二维码获取结果失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1 + m_strStatusBarInfo2);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}


		// 保存多个二维码; DM码
		for(int it =0;it<TempSeachResults.m_vcodeDMResult.size();it++)
		{
			if(it==0)
			{
				strCode.Format("%s",TempSeachResults.m_vcodeDMResult.at(it).m_OutputData);

				for(int jt=0;jt<MAX_CODE_LENGTH;jt++)
				{
					vCode.push_back(int(TempSeachResults.m_vcodeDMResult.at(it).m_OutputData[jt]));
					if(TempSeachResults.m_vcodeDMResult.at(it).m_OutputData[jt] == '\0')
					{
						break;
					}
				}

				// 暂时只发送第一个检测的二维码 直接跳出
				break;


			}
			else// 扫描到多个二维码时不发送
			{
				CString str1 = _T("");
				str1.Format("%s ",TempSeachResults.m_vcodeDMResult.at(it).m_OutputData);
				strCode += str1;

				for(int jt=0;jt<MAX_CODE_LENGTH;jt++)
				{
					vCode.push_back(int(TempSeachResults.m_vcodeDMResult.at(it).m_OutputData[jt]));
					if(TempSeachResults.m_vcodeDMResult.at(it).m_OutputData[jt] == '\0')
					{
						break;
					}
				}

			}
		}

		for(int it =0;it<TempSeachResults.m_vcodeQRResult.size();it++)
		{
			if(it==0)
			{
				strCode.Format("%s",TempSeachResults.m_vcodeQRResult.at(it).m_OutputData);

				for(int jt=0;jt<MAX_CODE_LENGTH;jt++)
				{
					vCode.push_back(int(TempSeachResults.m_vcodeQRResult.at(it).m_OutputData[jt]));
					if(TempSeachResults.m_vcodeQRResult.at(it).m_OutputData[jt] == '\0')
					{
						break;
					}
				}

				// 暂时只发送第一个检测的二维码 直接跳出
				break;
			}
			else// 扫描到多个二维码时不发送
			{
				CString str1 = _T("");
				str1.Format("%s ",TempSeachResults.m_vcodeQRResult.at(it).m_OutputData);
				strCode += str1;

				for(int jt=0;jt<MAX_CODE_LENGTH;jt++)
				{
					vCode.push_back(int(TempSeachResults.m_vcodeDMResult.at(it).m_OutputData[jt]));
					if(TempSeachResults.m_vcodeDMResult.at(it).m_OutputData[jt] == '\0')
					{
						break;
					}
				}
			}

		}

		strSendCode = strCode;
	}


	// 本地存储二维码；写入CSV文件
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		// 存储二维码；

		CString strPath;
		CString strWorkType;

		strWorkType = m_stUploadData.strWorkType;
		;
		//判断文件是否存在
		CString strFileName;
		strFileName.Format(_T("%s\\%s-2DCodeRecord.csv"),m_strDataRecord,strWorkType);
		SYSTEMTIME sysTime;
		GetLocalTime(&sysTime);
		CString str;
		str.Format(_T("%04d.%02d.%02d-%02d.%02d.%02d.%03d"),sysTime.wYear,sysTime.wMonth,sysTime.wDay,sysTime.wHour,
			sysTime.wMinute,sysTime.wSecond,sysTime.wMilliseconds);
		CString strCSV;
		CStdioFile file;
		CFileStatus fileStatus;
		BOOL bRet = CFile::GetStatus(strFileName,fileStatus);
		//写文件
		if(!bRet)
		{
			strCSV.Format(_T("%s,%s\n"),"时间","二维码结果");
			if(FALSE == SaveCSVToDisk(strFileName,strCSV,TRUE))
			{
				ReportInspectQRCodeFQRI(FALSE,vCode);
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OPERATE_FILE_FAIL);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				return FALSE;
			}
			strCSV.Format(_T("%s,%s\n"),str,strCode);
			if(FALSE == SaveCSVToDisk(strFileName,strCSV,FALSE))
			{
				ReportInspectQRCodeFQRI(FALSE,vCode);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OPERATE_FILE_FAIL);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				CString strTemp = _T("");
				strTemp.Format(m_strStatusBarInfo1 + m_strStatusBarInfo2);
				AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

				return FALSE;
			}
		}
		else
		{
			strCSV.Format(_T("%s,%s\n"),str,strCode);
			if(FALSE == SaveCSVToDisk(strFileName,strCSV,FALSE))
			{
				ReportInspectQRCodeFQRI(FALSE,vCode);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OPERATE_FILE_FAIL);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				CString strTemp = _T("");
				strTemp.Format(m_strStatusBarInfo1 + m_strStatusBarInfo2);
				AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

				return FALSE;
			}
		}
	}

	if(bSearchSucceed)
	{

		ReportInspectQRCodeFQRI(TRUE,vCode,strSendCode);
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = _T("二维码检测成功");
		CString StrTime = _T("");
		StrTime.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		m_strStatusBarInfo1 += (_T("(") + StrTime + _T(")"));
		m_strStatusBarInfo2 = strSendCode;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		return TRUE;
	}
	else
	{
		ReportInspectQRCodeFQRI(FALSE,vCode);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("二维码检测失败");
		m_strStatusBarInfo2 = _T("搜索失败");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}
	return TRUE;
}

BOOL vcXYDVisionAlign::TargetSearchForTarFixOffset(std::vector<int> vnPosIndex)
{
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (m_vpTargetPlatformAxisPos.size() <= 0 
			|| m_vpTargetPlatformAxisPos.at(vnPosIndex[0]) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(vnPosIndex[0]));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
	}

	if (!bCommuciateGetPlatformAxisAbsPos)	
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		ReportCalTargetFixOffsetFAFO(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			nPosIndex = vnPosIndex[i];
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;
			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;

	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex-GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);
		}

	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 		//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 		//HideExtraGraphics(vnAllPosIndex);
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		//HideExtraGraphics(vnPosIndex);
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}
	for (i=0;i<vnPosIndex.size();i++)
	{
		nPosIndex = vnPosIndex.at(i);
		PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,FALSE);
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{		
		ReportCalTargetFixOffsetFAFO(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
		return FALSE;
	}
	scDMCodeParam DmCodeParam;
	for (i=0;i<vnPosIndex.size();i++)
	{
		nPosIndex=vnPosIndex.at(i);
		DmCodeParam = pCurProductData->m_vDMcodeCalib.at(nPosIndex);
		m_vDmCodeCalibTool.at(nPosIndex).SetDmCodeParam(DmCodeParam);
	}

	if (!SnapSearchImage(vnPosIndex))
	{
		ReportCalTargetFixOffsetFAFO(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SNAP_IMAGE_FAIL);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	CString strInfo;
	if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE && pCurProductData->m_pAlignerParam->GetCalibTargetMarkPatternMode()==eDmCodeCalib)
	{
		std::vector<SearchMode> vsmSearchMode;

		for (int i=0;i<vnPosIndex.size();i++)
		{
			vsmSearchMode.push_back(eAutoCalibTargetSearch);
		}

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_IS_SEARCHING);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		if (!SearchMark(vnPosIndex,vsmSearchMode))
		{
			ReportCalTargetFixOffsetFAFO(FALSE);
			strInfo=GetSysInfoString(m_psaSysInfoStrings,IDS_STR_POS);
			for (int i=0;i<vnPosIndex.size();i++)
			{
				if (!m_vbSearchSucceed[vnPosIndex.at(i)])
				{
					CString tempInfo;
					tempInfo.Format(_T("%d "),vnPosIndex.at(i)+1);
					strInfo+=tempInfo;
				}
			}
			strInfo+=GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SEARCH_FAIL);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
			m_strStatusBarInfo2 = strInfo;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		else
		{
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_SUCCESS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
	}
	else
	{
		ReportCalTargetFixOffsetFAFO(FALSE);
		//strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_STR_PLEASE_OPEN_CALIB_TARGET));
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
		m_strStatusBarInfo2 = _T("请开启二维码关联标定");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	//开始计算
	double dImageWidth = 0.0;
	double dImageHeight = 0.0;
	sc2Vector ImagePos;
	sc2Vector BoardPos;
	std::vector<sc2Vector> vImagePos;
	std::vector<sc2Vector> vBoardPos;
	for (int i=0;i<vnPosIndex.size();i++)
	{
		nPosIndex = vnPosIndex.at(i);
		dImageWidth  = m_vImageInput.at(nPosIndex).Width();
		dImageHeight = m_vImageInput.at(nPosIndex).Height();

		ImagePos.SetX(dImageWidth/2);
		ImagePos.SetY(dImageHeight/2);

		m_vDmCodeCalibTool.at(nPosIndex).GetCornersImagePos(vImagePos);
		m_vDmCodeCalibTool.at(nPosIndex ).GetCornersLabelPos(vBoardPos);

		if(FALSE == m_pAlignerTool->ConvertSrcPosToDstPos(vImagePos,vBoardPos,ImagePos,BoardPos))
		{
			ReportCalTargetFixOffsetFAFO(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(_T("获取靶标坐标失败"));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}

		m_vBoardPosForTarFixOffset.at(nPosIndex) = BoardPos;
		m_vBoardPosForTarFixOffset.at(nPosIndex-GetPosNum()/2) = BoardPos;

		CCoordPos tarPos;
		tarPos.SetPos(ImagePos);
		tarPos.SetAuxPos(0,ImagePos);
		tarPos.SetAuxPos(1,ImagePos);
		m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex,TRUE,tarPos);
		m_vbSearchSucceed.at(nPosIndex) = TRUE;
	}

	m_bTargetMarkSearchSucceed = TRUE;
	for (i=0;i<vnPosIndex.size();i++)
	{
		nPosIndex = vnPosIndex.at(i);
		PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,FALSE);
	}

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);


	// 5. 设置对位工具
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}


	if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
	{
		std::vector<CCoordPos> vCoordPos;
		std::vector<CPlatformXYDAxisPos> vPlatformXYDAxisPos;
		std::vector<CCoordPos> vBoardPos;

		CMarkPlatformPos mpTargetMarkPos;
		mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPosForCheck();
		BOOL bSucceed = TRUE;
		for (int i=0;i<vnPosIndex.size();i++)
		{
			nPosIndex = vnPosIndex.at(i);
			bSucceed = bSucceed && mpTargetMarkPos.GetIsMarkPlatformPosOK(nPosIndex);
		}

		if (bSucceed)
		{
			for (int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				vCoordPos.push_back(mpTargetMarkPos.GetMarkPlatformPos(nPosIndex));
				vPlatformXYDAxisPos.push_back(*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(nPosIndex)));
				CCoordPos vBoard;
				vBoard.SetPos(m_vBoardPosForTarFixOffset.at(nPosIndex));
				vBoardPos.push_back(vBoard);
			}

			ReportCalTargetFixOffsetFAFO(TRUE,vnPosIndex,vCoordPos,vPlatformXYDAxisPos,vBoardPos);

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = _T("获取目标固定补偿基准MARK成功");
			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return TRUE;
		}
		else
		{
			ReportCalTargetFixOffsetFAFO(FALSE);
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = _T("获取目标固定补偿基准MARK失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}	
	}
	ReportCalTargetFixOffsetFAFO(TRUE);
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("获取目标固定补偿基准MARK成功");;
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::ObjectSearchForTarFixOffset(std::vector<int> vnPosIndex)
{
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{

			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (m_vpObjectPlatformAxisPos.size() <= 0 || m_vpObjectPlatformAxisPos.at(vnPosIndex[0]) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}	
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);						
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{
		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				if (optionInfo.m_bTargetAngleMulAlignerXYPD)
				{

				}
				else
				{
					pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
				}
				//				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
			}
			//D角度不累加
		}
	}


	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bObjectSearchTest) ReportCalTargetFixOffsetFAFO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{ 
		for(i=0; i<nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			}

		}


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		//std::vector<CCoordPos> vTargetCoordPos;
		//std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		//m_pAlignerTool->SetIsReadTargetPlatformPos(TRUE);
		//BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetPlatformPos(vnPosIndex,vTargetCoordPos,vTargetPlatAxisPos);
		//if (!bCommuciateGetTargetPlatformPos)	
		//{
		//	ReportCalTargetFixOffsetFAFO(FALSE);
		//	m_bStatusBar = FALSE;
		//	m_strStatusBarInfo1.Format(_T("通信获取目标平台坐标失败"));
		//	m_strStatusBarInfo2 = _T("");
		//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		//	return FALSE;
		//}
		//else
		//{
		//	int nPosIndex=0;
		//	CMarkPlatformPos mpTargetMarkPos;
		//	mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();
		//	for (int i=0;i<mpTargetMarkPos.m_vbOK.size();i++)
		//	{
		//		mpTargetMarkPos.m_vbOK.at(i) = TRUE;
		//	}
		//	for(int i=0;i<vnPosIndex.size();i++)
		//	{
		//		nPosIndex = vnPosIndex.at(i);
		//		SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
		//		SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
		//		mpTargetMarkPos.SetMarkPlatformPos(nPosIndex,TRUE,vTargetCoordPos.at(i));
		//	}
		//	m_pAlignerTool->SetTargetMarkPlatformPos(mpTargetMarkPos);
		//}

		std::vector<CCoordPos> vBoardPos;
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetBoardPosForTarFixOffset(vnPosIndex,vBoardPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportCalTargetFixOffsetFAFO(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(_T("通信获取目标固定补偿基准靶标坐标失败"));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			sc2Vector boardPos;
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if ((nPosIndex-GetPosNum()/2)<0 || nPosIndex>=GetPosNum())
				{
					ReportCalTargetFixOffsetFAFO(FALSE);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("通信获取目标固定补偿基准靶标坐标失败"));
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
				boardPos = vBoardPos.at(i).GetPos();
				m_vBoardPosForTarFixOffset.at(nPosIndex) = boardPos;
				m_vBoardPosForTarFixOffset.at(nPosIndex-GetPosNum()/2) = boardPos;
			}
		}
	}
	// 隐藏结果图形
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
	// 	//if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
	// 
	// 	//HideExtraGraphics(vnPosIndex);
	// 	ShowExtraGuiToDisplay(vnPosIndex, FALSE);

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);


	// 	for (i=0;i<vnPosIndex.size();i++)
	// 	{
	// 		nPosIndex = vnPosIndex.at(i);
	// 		PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,FALSE);
	// 	}

	scTimer stSearchTimer; 

	stSearchTimer.Reset();

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{		
		ReportCalTargetFixOffsetFAFO(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
		return FALSE;
	}
	scDMCodeParam DmCodeParam;
	for (i=0;i<vnPosIndex.size();i++)
	{
		nPosIndex=vnPosIndex.at(i);
		DmCodeParam = pCurProductData->m_vDMcodeCalib.at(nPosIndex);
		m_vDmCodeCalibTool.at(nPosIndex).SetDmCodeParam(DmCodeParam);
	}
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportCalTargetFixOffsetFAFO(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SNAP_IMAGE_FAIL);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}
	CString strInfo;
	if (pCurProductData->m_pAlignerParam->GetCalibTargetMarkEnable() == TRUE)
	{
		std::vector<SearchMode> vsmSearchMode;

		for (int i=0;i<vnPosIndex.size();i++)
		{
			vsmSearchMode.push_back(eAutoCalibTargetSearch);
		}
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_IS_SEARCHING);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		if (!SearchMark(vnPosIndex,vsmSearchMode))
		{
			ReportCalTargetFixOffsetFAFO(FALSE);
			strInfo=GetSysInfoString(m_psaSysInfoStrings,IDS_STR_POS);
			for (int i=0;i<vnPosIndex.size();i++)
			{
				if (!m_vbSearchSucceed[vnPosIndex.at(i)])
				{
					CString tempInfo;
					tempInfo.Format(_T("%d "),vnPosIndex.at(i)+1);
					strInfo+=tempInfo;
				}
			}
			strInfo+=GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SEARCH_FAIL);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
			m_strStatusBarInfo2 = strInfo;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		else
		{
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_SUCCESS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		}
	}
	else
	{
		ReportCalTargetFixOffsetFAFO(FALSE);
		strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_STR_PLEASE_OPEN_CALIB_TARGET));
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_DM_CODE_SEARCH_FAIL);
		m_strStatusBarInfo2 = strInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	//开始计算
	std::vector<sc2Vector> vImagePos;
	std::vector<sc2Vector> vBoardPos;
	sc2Vector imgPos;
	for (i=0;i<nPosNum;i++)
	{
		nPosIndex = vnPosIndex.at(i);
		m_vDmCodeCalibTool.at(nPosIndex).GetCornersImagePos(vImagePos);
		m_vDmCodeCalibTool.at(nPosIndex ).GetCornersLabelPos(vBoardPos);
		if (FALSE == m_pAlignerTool->ConvertSrcPosToDstPos(vBoardPos,vImagePos,m_vBoardPosForTarFixOffset.at(nPosIndex),imgPos))
		{
			ReportCalTargetFixOffsetFAFO(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("获取目标固定补偿对象坐标失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		CCoordPos objPos;
		objPos.SetPos(imgPos);
		objPos.SetAuxPos(0,imgPos);
		objPos.SetAuxPos(1,imgPos);
		m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex,TRUE,objPos);
		m_vbSearchSucceed.at(nPosIndex) = TRUE;
	}
	m_bObjectMarkSearchSucceed = TRUE;

	for (i=0;i<vnPosIndex.size();i++)
	{
		nPosIndex = vnPosIndex.at(i);
		PostMessageUpdateGuiCalibrateTargetGraphics(nPosIndex,FALSE);
	}
	// 设定、显示结果图形
	//if ((m_bIsObjectCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsObjectLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//{
	//ShowAllGuiAlnObjectExtraGraphics(nCurProdcutIndex,vnPosIndex);
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

	// 	ShowExtraGuiToDisplay(vnPosIndex, TRUE,1);
	// 	
	// 	//}
	// 	//     SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 	//     PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	// 	{
	// 		SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 	if (/*m_bIsObjectCornerSearchTool &&*/ (m_pSystempOptionConfig->m_bShowCornerTool))
	// 	{
	// 		SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 	// SY
	// 	SetShowGuiObjectImageMarkPos(vnPosIndex);
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

	// 5. 设置对位工具
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

	ReportCalTargetFixOffsetFAFO(TRUE);
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("获取目标固定补偿对象坐标成功");
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::CaculateTarFixOffset(int nOffsetIndex)
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetCoordPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(TRUE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetPlatformPos(vnPosIndex,vTargetCoordPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportCalTargetFixOffsetFAFO(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(_T("通信获取目标平台坐标失败"));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			CMarkPlatformPos mpTargetMarkPos;
			mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();
			for (int i=0;i<mpTargetMarkPos.m_vbOK.size();i++)
			{
				mpTargetMarkPos.m_vbOK.at(i) = TRUE;
			}

			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if ((nPosIndex-GetPosNum()/2)<0 || nPosIndex>=GetPosNum())
				{
					ReportCalTargetFixOffsetFAFO(FALSE);
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("通信获取目标平台坐标失败"));
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
					return FALSE;
				}
				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				mpTargetMarkPos.SetMarkPlatformPos(nPosIndex,TRUE,vTargetCoordPos.at(i));
			}
			m_pAlignerTool->SetTargetMarkPlatformPos(mpTargetMarkPos);
		}
	}
	else
	{
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		// 检查目标Mark是否已成功定位
		CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);
		if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
		{
			if (FALSE == m_bTargetMarkSearchSucceed)
			{
				ReportCalTargetFixOffsetFAFO(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;
			}
		}
	}
	// 检查对象Mark是否已成功定位
	if (FALSE == m_bObjectMarkSearchSucceed)
	{
		ReportCalTargetFixOffsetFAFO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );;
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

		return FALSE;
	}
	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();
	CCoordPos offset;
	if (FALSE == CaculateTargetFixOffset(offset))
	{
		ReportCalTargetFixOffsetFAFO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("执行目标固定补偿计算失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
		return FALSE; 
	}

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	CString str;
	CCoordPos offsetVal;
	str.Format(_T("%.6f"),offset.GetPosX());
	offsetVal.m_dPosX = atof(str);
	str.Format(_T("%.6f"),offset.GetPosY());
	offsetVal.m_dPosY = atof(str);
	str.Format(_T("%.6f"),offset.GetAngle());
	offsetVal.m_dAngle = atof(str);

	pCurProductData->m_pAlignerParam->SetAlnTargetFixOffset(nOffsetIndex,offsetVal);
	pAlignerParam->SetAlnTargetFixOffset(nOffsetIndex,offsetVal);

	SaveProductDataInfo(nCurProductIndex);

	double dTime = stAlignTimer.GetTimeMilli(TRUE);
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("计算目标固定补偿成功");	
	m_strStatusBarInfo2.Format(_T("计算时间：%.3fms"), dTime);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();				

	ReportCalTargetFixOffsetFAFO(TRUE);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineCalTargetFixOffsetFAFO(int nType,int nPosIndex,int nOffsetIndex,int nExProductIndex /*= 0*/)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VAFO:");
	CString strTempWarningType = _T("");
	SetAlignExProductIndex(nExProductIndex);
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportCalTargetFixOffsetFAFO(FALSE);
		return FALSE;
	}

	//// 检查对象定位工具是否有效
	//if ( FALSE == m_bValidObjectSearchTool)
	//{
	//	ReportCalTargetFixOffsetFAFO(FALSE);

	//	m_bStatusBar = FALSE;
	//	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
	//	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
	//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	//	return FALSE;
	//}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportCalTargetFixOffsetFAFO(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportCalTargetFixOffsetFAFO(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportCalTargetFixOffsetFAFO(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));
			return FALSE;
		}            
	} 
	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportCalTargetFixOffsetFAFO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}



	switch(nType)
	{
	case 0://目标
		{
			std::vector<int> vnPosIndex;
			if (nPosIndex == 11)
			{
				for (int i=0;i<GetPosNum()/2;i++)
				{
					vnPosIndex.push_back(i+GetPosNum()/2);
				}
			}

			return TargetSearchForTarFixOffset(vnPosIndex);

		}
		break;

	case 1://对象
		{
			std::vector<int> vnPosIndex;
			if (nPosIndex == 11)
			{
				for (int i=0;i<GetPosNum()/2;i++)
				{
					vnPosIndex.push_back(i);
				}
			}

			return ObjectSearchForTarFixOffset(vnPosIndex);
		}
		break;

	case 2://计算
		{
			return CaculateTarFixOffset(nOffsetIndex);
		}
		break;


	}

	return FALSE;
}

// 接收命令后，调用该函数，里面需要做一些额外的判断
// BOOL vcXYDVisionAlign::OnlineFCBSCalibrate(int nCalibPos, int nMarkType)
// {
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = _T("");
// 	m_strStatusBarInfo2 = _T("");
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 	CString strTempWarningType = _T("");
// 	CString strCmd = _T("VCBS:");
// 	GetCommCommandName(strCmd);
// 	SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);
// 	if (ePlatformXYPD != sysPlatformInfo.m_eMidPlatformType)
// 	{
// 		ReportCalibResultFCBS(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_PLATFORMTYPE);
// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// 
// 	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType)/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/)
// 	{
// 		
// 	   ReportCalibResultFCBS(FALSE);
// 		return FALSE;
// 	}
// 
// 	// 隐藏对象结果图形			
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	std::vector<int> vnObjectPosIndex;
// 	int nObjectPosIndex = 0;
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		nObjectPosIndex = i;
// 		vnObjectPosIndex.push_back(nObjectPosIndex);
// 	}	
// // 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
// // 	//if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
// // 	{
// // 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnObjectPosIndex, FALSE);
// // 	}
// // 	// SY
// // 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);
// 
// 	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);
// 
// 	// 隐藏目标结果图形	
// 	std::vector<int> vnTargetPosIndex;
// 	int nTargetPosIndex = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		nTargetPosIndex = i;
// 		vnTargetPosIndex.push_back(nTargetPosIndex);
// 	}	
// 	m_cVisionAlignGui.SetPosGuiInvisible(vnTargetPosIndex, eTargetSearch);
// 
// // 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnTargetPosIndex, FALSE);
// // 	// SY
// // 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnTargetPosIndex, FALSE);
// // 
// // 	if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
// // 	{
// // 		PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnTargetPosIndex, FALSE);
// // 	}
// // 	//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
// // 	{
// // 		PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnTargetPosIndex, FALSE);
// // 	}
// 	BOOL bSucceed = FALSE;
// 
// 	// 执行标定
// 	if (m_pPlatformInfo->m_bPlatformPick)
// 	{	
// 		ReportCalibResultFCBS(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_PLATFORMSYSTEM);
// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 		
// 	}
// 	else
// 	{		
// 		bSucceed = OnSingleCameraAlignerFCBSCalibrate(nCalibPos, nMarkType); // 单相机对位系统标定
// 
// 	}
// 
// 	if (TRUE == bSucceed)
// 	{	
// 	
// 		ReportCalibResultFCBS(TRUE);
// 
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_SUCCEED);
// 		if	(nMarkType == 0)
// 		{
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_XY_SUCCEED);//_T("平台XY轴平移标定成功");
// 		}
// 		else if(nMarkType == 1)
// 		{
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_D_SUCCEED);//_T("平台D轴旋转标定成功");
// 		}
// 		else if(nMarkType == 2)
// 		{
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_CALCU_SUCCEED);//_T("平台标定计算成功");
// 		}
// 		m_strStatusBarInfo2 = _T("");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
// 	}
// 	else
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		if	(nMarkType == 0)
// 		{
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_XY_FAILED);//_T("平台XY轴平移标定失败");
// 		}
// 		else if(nMarkType == 1)
// 		{
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_D_FAILED);//_T("平台D轴旋转标定失败");
// 		}
// 		else if(nMarkType == 2)
// 		{
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_CALCU_FAILED);//_T("平台标定计算失败");
// 		}
// 		if (!m_boIsSnapImgSucceed)
// 		{
// 			m_strStatusBarInfo2 = m_strSnapImgStatuString;
// 		}
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 	}
// 
// 	return bSucceed;
// }

BOOL vcXYDVisionAlign::GetDmCodeImageBoardPos(int nType,int nIndex,CMarkImagePos &imagePos,CMarkPlatformPos &boardPos)
{
	// 目标端
	if (nType == 0)
	{
		if (!m_vDmCodeCalibTool.at(nIndex).IsSearchValid())
		{
			return FALSE;
		}
		imagePos.Reset();
		imagePos.SetMarkImagePosNum(GUANLIANBOARDNUM);
		CCoordPos pos;
		std::vector<sc2Vector> vDmCodeImagePos;
		std::vector<sc2Vector> vDmCodeBoardPos;
		sc2Vector tmpVec;

		std::vector<sc2Vector> vImagePos;
		std::vector<sc2Vector> vBoardPos;
		double dImageWidth  = m_vImageInput.at(nIndex).Width();
		double dImageHeight = m_vImageInput.at(nIndex).Height();

		for (int i=0;i<3;i++)
		{
			for (int j=0;j<3;j++)
			{
				tmpVec.SetX(dImageWidth/4 + dImageWidth/4*j);
				tmpVec.SetY(dImageHeight/4 + dImageHeight/4*i);
				vDmCodeImagePos.push_back(tmpVec);
				pos.SetPos(tmpVec);
				imagePos.SetMarkImagePos(i*3+j,TRUE,pos);
			}
		}
		m_vDmCodeCalibTool.at(nIndex).GetCornersImagePos(vImagePos);
		m_vDmCodeCalibTool.at(nIndex ).GetCornersLabelPos(vBoardPos);
		if(FALSE == m_pAlignerTool->ConvertSrcPosToDstPos(vImagePos,vBoardPos,vDmCodeImagePos,vDmCodeBoardPos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(_T("转换图像到靶标坐标失败"));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		boardPos.Reset();
		boardPos.SetMarkPlatformPosNum(GUANLIANBOARDNUM);
		for(int i=0;i<vDmCodeBoardPos.size();i++)
		{
			pos.SetPos(vDmCodeBoardPos.at(i));
			boardPos.SetMarkPlatformPos(i,TRUE,pos);
		}
	}

	// 对象端
	if (nType == 1)
	{
		if (!m_vDmCodeCalibTool.at(nIndex).IsSearchValid())
		{
			return FALSE;
		}

		CCoordPos pos;
		std::vector<sc2Vector> vDmCodeImagePos;
		std::vector<sc2Vector> vDmCodeBoardPos;
		sc2Vector tmpVec;
		for (int i=0;i<boardPos.m_vPos.size();i++)
		{
			tmpVec  = boardPos.m_vPos.at(i).GetPos();
			vDmCodeBoardPos.push_back(tmpVec);
		}

		std::vector<sc2Vector> vImagePos;
		std::vector<sc2Vector> vBoardPos;

		m_vDmCodeCalibTool.at(nIndex).GetCornersImagePos(vImagePos);
		m_vDmCodeCalibTool.at(nIndex ).GetCornersLabelPos(vBoardPos);
		if(FALSE == m_pAlignerTool->ConvertSrcPosToDstPos(vBoardPos,vImagePos,vDmCodeBoardPos,vDmCodeImagePos))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(_T("获取靶标坐标失败"));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			return FALSE;
		}
		imagePos.Reset();
		imagePos.SetMarkImagePosNum(GUANLIANBOARDNUM);
		for(int i=0;i<vDmCodeImagePos.size();i++)
		{
			pos.SetPos(vDmCodeImagePos.at(i));
			imagePos.SetMarkImagePos(i,TRUE,pos);
		}
	}
	return TRUE;
}


// 两个及两个以上相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerObjectSearchExFOBJ()
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOBJ:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(0);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
				vsmCameraExposureType.push_back(eObjectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}

		}
	}


	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	scTimer stCommuciateTimer; double dCommuciateTime(0.0);

	stCommuciateTimer.Reset();
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (nPosNum != m_vpObjectPlatformAxisPos.size() || m_vpObjectPlatformAxisPos.at(0) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}	
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			// bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;
			}
			//D角度不累加
		}
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for(int j=0; j<nPosNum; j++)
		{
			SetObjectPlatformPos_MultiEx(pPlatformAxisPos,j);
			SetObjectPlatformPos(pPlatformAxisPos,j);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(j,pPlatformAxisPos);
			}

		}


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	


			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	dCommuciateTime = stCommuciateTimer.GetTimeMilli(FALSE);
	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	if (0/*(m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX)*/)
	{
		for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
		{
			pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
			vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);      
		}

		if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos))
		{
			if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_CAM_PLATFORM_POS_FAILED));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
		else
		{
			//SetObjectCamPlatformPos(vpCamPlatformXYAxisPos);

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strInfo;
				strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_CAM_PLATFORM_POS);
				strInfo = strTemp + strInfo;

				for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
				{
					strTemp = _T("");
					strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
					strInfo = strInfo + strTemp;
				}

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));
				// 				fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);	


				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}
		}	
	}

	// 3.开启定位
	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	stObjectSearchTimer.Reset();


	// 等待搜索延时
	// 	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	// 	Sleep(nDelayTime);

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}


	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eObjectSearch);	// 
	}

	// 隐藏结果图形
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
	// //	if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
	//     //HideExtraGraphics(vnPosIndex);
	//     ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		if (bObjectSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
				m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bObjectSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				nTempStartPatIndex = 0;
				nTempEndPatIndex = OBJECTCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = j;
						m_vnObjectSearchEndPatIndex[nPosIndex] = j;
					}			
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

					if (bSearchSucceed)
					{
						break;
					}	
					//Sleep(100);
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					nTempStartPatIndex = 0;
					nTempEndPatIndex = OBJECTCANDIDATENUM-1;

					m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
	}
	else
	{
		for(int i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}


	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
				BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
				if(optionInfo.m_bEnableSearchCindidate)
				{
					if (bObjectSearchCandidate == FALSE)
					{
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
							m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (bObjectSearchSync == TRUE)
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							nTempStartPatIndex = 0;
							nTempEndPatIndex = OBJECTCANDIDATENUM-1;

							int j = 0;
							for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
							{
								if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
								{
									continue;
								}

								for(i = 0; i < nPosNum; i++)
								{
									nPosIndex = vnPosIndex[i];
									m_vnObjectSearchStartPatIndex[nPosIndex] = j;
									m_vnObjectSearchEndPatIndex[nPosIndex] = j;
								}			
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

								if (bSearchSucceed)
								{
									break;
								}	
								//Sleep(100);
							}
						}
						else
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								nTempStartPatIndex = 0;
								nTempEndPatIndex = OBJECTCANDIDATENUM-1;

								m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
								m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
				}
				else
				{
					for(int i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if(FALSE==ExcuteManualSearch(1,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}				
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}

	}

	// 设定、显示结果图形
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
	//     SetGuiAlnObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	//     if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	//     {
	//         SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	//         PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	//     }
	//     //if ((m_bIsObjectCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsObjectLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//     //{
	//        // ShowAllGuiAlnObjectExtraGraphics(nCurProdcutIndex,vnPosIndex);
	//         ShowExtraGuiToDisplay(vnPosIndex, TRUE,1);
	//     //}
	//     // SY
	//     SetShowGuiObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
		ExeSaveVDBFile(vnPosIndex,eObjectSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(FALSE, FALSE);

		return FALSE;
	}


	// 5. 设置对位工具
	SetMultiEXObjectMarkSearchResultsWithCombinationCode(m_mpObjectMarkImagePos);
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	// 计算对象距离
	//	CalculateObjectDistance(); 
	if (!CheckObjectDistance())
	{
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //_T("对象距离超过设定标准，对象定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{		
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}

		}

		return FALSE;
	}
	//	RecordObjectSizeIndfo(TRUE, TRUE);

	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");		
		for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}
	dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);

	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1 )
	{
		return ExecuteAlignAfterFOBJAndFTGT(1);
	}
	//	CString str;
	//str.Format("Serial camera object search time = %f",dObjectSearchTime);
	//AlignLogRecord(str);
	if(m_bObjectSearchTest) ReportObjectSearchResult(TRUE);
	return TRUE;
}


BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetSearchExFCNO()
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCNO:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));
			if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
			return FALSE;
		}    	
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(0);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);


		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
				vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (nPosNum != m_vpTargetPlatformAxisPos.size() || m_vpTargetPlatformAxisPos.at(0) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(0));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
	}


	if (!bCommuciateGetPlatformAxisAbsPos)		         
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			SetTargetPlatformPos(pPlatformAxisPos,i);
			SetTempTargetPlatformAxisPos(i,pPlatformAxisPos);

			// 			if (m_bIsMutiTarget && m_pSystempOptionConfig->m_bEnableMutiTarget)
			// 			{
			// 				SetMutiTargetPlatformPos(pPlatformAxisPos,i);
			// 			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;

			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;
	for (int j=0;j<GetPosNum();j++)
	{
		if (j>=GetPosNum()/2)
		{
			nAllPosIndex = j- GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = j;
			vnAllPosIndex.push_back(nAllPosIndex);
		}
	}

	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);
		vsmSearchMode.push_back(eTargetSearch);
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// //		if (m_pSystempOptionConfig->m_bShowCornerTool && m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);

	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (m_pSystempOptionConfig->m_bShowCornerTool && m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
		if (bTargetSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
				m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bTargetSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				nTempStartPatIndex = 0;
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = j;
						m_vnTargetSearchEndPatIndex[nPosIndex] = j;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					if (bSearchSucceed)
					{
						break;
					}
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					nTempStartPatIndex = 0;
					nTempEndPatIndex = TARGETCANDIDATENUM-1;

					m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
	}
	else
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}

		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}


	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				if(optionInfo.m_bEnableSearchCindidate)
				{
					BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
					BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
					if (bTargetSearchCandidate == FALSE)
					{
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
							m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (bTargetSearchSync == TRUE)
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							nTempStartPatIndex = 0;
							nTempEndPatIndex = TARGETCANDIDATENUM-1;

							int j = 0;
							for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
							{
								if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
								{
									continue;
								}

								for(i = 0; i < nPosNum; i++)
								{
									nPosIndex = vnPosIndex[i];
									m_vnTargetSearchStartPatIndex[nPosIndex] = j;
									m_vnTargetSearchEndPatIndex[nPosIndex] = j;
								}
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
								if (bSearchSucceed)
								{
									break;
								}
							}
						}
						else
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								nTempStartPatIndex = 0;
								nTempEndPatIndex = TARGETCANDIDATENUM-1;

								m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
								m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
				}
				else
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}


	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}


			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}
		}
	}


	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		for (int k = GetPosNum()/2; k<GetPosNum(); k++)
		{
			vnHomoPosIndex.push_back(k);
		}

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		// 		SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);

		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// 设定、显示目标定位结果文字，全部0/1/2/3图像
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
		// 
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, TRUE, 0);
	}
	else
	{
		// 设定、显示结果图形
		// 		SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

		// 
		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// SY
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, TRUE, 0);
	}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//	RecordTargetSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	// 	if (m_bIsMutiTarget && m_pSystempOptionConfig->m_bEnableMutiTarget)
	// 	{
	// 		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
	// 		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	// 	}
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());


	// 计算目标距离
	//	CalculateTargetDistance(); 
	if (!CheckTargetDistance())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//	RecordTargetSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{	
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageTargetSearchFailed.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) + 1;																			
				m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d-Check.bmp"), 
					nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}			
		}	

		return FALSE;
	}

	//	RecordTargetSizeIndfo(TRUE, TRUE);

	if (!CheckTargetAngle())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}



	// 设置对象位置为图像中心
	for(i = 0; i < vnPosIndex.size(); i++)
	{
		int nPosIndex = vnPosIndex.at(i);

		CCoordPos cpImageMarkPos;
		cpImageMarkPos.m_dPosX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
		cpImageMarkPos.m_dPosY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;
		cpImageMarkPos.m_dAngle = 0;

		m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpImageMarkPos);
	}	

	// 	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	// 	{
	// 		SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 
	// 	if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	// 	{
	// 		SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 
	// 	// SY
	// 	SetShowGuiObjectImageMarkPos(vnPosIndex);
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
	// 
	// 	ShowExtraGuiToDisplay(vnPosIndex, TRUE, 1);
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

	// 5. 设置对位工具
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;
		CCoordPos cp;

		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(TRUE);

	return TRUE;
}

BOOL vcXYDVisionAlign::OnSerialCameraAlignerObjectSearchExFCNT()
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCNT:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckObjectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (nCamNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(0);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);


		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
				vsmCameraExposureType.push_back(eObjectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}

		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	scTimer stCommuciateTimer; double dCommuciateTime(0.0);

	stCommuciateTimer.Reset();
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (nPosNum != m_vpObjectPlatformAxisPos.size() || m_vpObjectPlatformAxisPos.at(0) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}
			}			
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			// bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;
			}
			//D角度不累加
		}
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	else
	{ 
		for(int j=0; j<nPosNum; j++)
		{
			SetObjectPlatformPos(pPlatformAxisPos,j);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(j,pPlatformAxisPos);
			}

			SetTargetPlatformPos(pPlatformAxisPos,j);
			SetTempTargetPlatformAxisPos(j,pPlatformAxisPos);
		}


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	


			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	dCommuciateTime = stCommuciateTimer.GetTimeMilli(FALSE);
	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	if (0/*(m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX)*/)
	{
		for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
		{
			pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
			vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);      
		}

		if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos))
		{
			if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_CAM_PLATFORM_POS_FAILED));
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}

			return FALSE;
		}
		else
		{
			//SetObjectCamPlatformPos(vpCamPlatformXYAxisPos);

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strInfo;
				strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_CAM_PLATFORM_POS);
				strInfo = strTemp + strInfo;

				for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
				{
					strTemp = _T("");
					strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
					strInfo = strInfo + strTemp;
				}

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));
				// 				fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);	


				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
			{
				if (vpCamPlatformXYAxisPos.at(i)!=NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}
		}	
	}

	// 3.开启定位
	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	stObjectSearchTimer.Reset();


	// 等待搜索延时
	// 	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	// 	Sleep(nDelayTime);

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}


	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;

	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eObjectSearch);	// 

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex- GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);
		}
	}



	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{

		// 隐藏目标定位结果十字，全部0/1/2/3图像
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// //		if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}

		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);

	}
	else
	{
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// //		if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 
		// 		// SY
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}

		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);
	}


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		if (bObjectSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
				m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bObjectSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				nTempStartPatIndex = 0;
				nTempEndPatIndex = OBJECTCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = j;
						m_vnObjectSearchEndPatIndex[nPosIndex] = j;
					}			
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

					if (bSearchSucceed)
					{
						break;
					}	
					//Sleep(100);
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					nTempStartPatIndex = 0;
					nTempEndPatIndex = OBJECTCANDIDATENUM-1;

					m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
	}
	else
	{
		for(int i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}


	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				if(optionInfo.m_bEnableSearchCindidate)
				{
					if (bObjectSearchCandidate == FALSE)
					{
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
							m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (bObjectSearchSync == TRUE)
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							nTempStartPatIndex = 0;
							nTempEndPatIndex = OBJECTCANDIDATENUM-1;

							int j = 0;
							for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
							{
								if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
								{
									continue;
								}

								for(i = 0; i < nPosNum; i++)
								{
									nPosIndex = vnPosIndex[i];
									m_vnObjectSearchStartPatIndex[nPosIndex] = j;
									m_vnObjectSearchEndPatIndex[nPosIndex] = j;
								}			
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

								if (bSearchSucceed)
								{
									break;
								}	
								//Sleep(100);
							}
						}
						else
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								nTempStartPatIndex = 0;
								nTempEndPatIndex = OBJECTCANDIDATENUM-1;

								m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
								m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
				}
				else
				{
					for(int i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		// if(m_bObjectSearchTest) ReportObjectSearchResult(TRUE);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if(FALSE==ExcuteManualSearch(1,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}
	}

	// 设定、显示结果图形
	//     SetGuiAlnObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);

	// 	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	// 	{
	// 		SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 
	//     if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	//     {
	//         SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	//         PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	//     }
	//     // SY
	//     SetShowGuiObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);


	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
		ExeSaveVDBFile(vnPosIndex,eObjectSearch);
	}
	if (bSearchSucceed)
	{


	}
	else
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	if (!CheckObjectDistance())
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //_T("对象距离超过设定标准，对象定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{		
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}
		}
		return FALSE;
	}

	//	RecordObjectSizeIndfo(TRUE, TRUE);

	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	if (nPosNum == 2 && nCamNum == 1)
	{
		for(i = 0; i < vnPosIndex.size(); i++)
		{
			int nPosIndex = vnPosIndex.at(i);

			CCoordPos cpImageMarkPos;
			if (i == 0)
			{
				cpImageMarkPos.m_dPosX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
			}
			else
			{
				cpImageMarkPos.m_dPosX = GetPosDisplay(nPosIndex)->GetImageWidth();
			}
			cpImageMarkPos.m_dPosY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;
			cpImageMarkPos.m_dAngle = 0;

			m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpImageMarkPos);
		}		
	}
	else
	{
		// 设置目标位置为图像中心
		for(i = 0; i < vnPosIndex.size(); i++)
		{
			int nPosIndex = vnPosIndex.at(i);

			CCoordPos cpImageMarkPos;
			cpImageMarkPos.m_dPosX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
			cpImageMarkPos.m_dPosY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;
			cpImageMarkPos.m_dAngle = 0;

			m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpImageMarkPos);
		}		
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		for (int k = GetPosNum()/2; k<GetPosNum(); k++)
		{
			vnHomoPosIndex.push_back(k);
		}

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					//	ReportTargetSearchResultFTGM(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					//return FALSE;
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
		// 		SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// 设定、显示目标定位结果文字，全部0/1/2/3图像
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
	}
	else
	{
		// 设置目标显示
		// 		SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// SY
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
	}


	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());


	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");		
		for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}
	dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
	//	CString str;
	//str.Format("Serial camera object search time = %f",dObjectSearchTime);
	//AlignLogRecord(str);
	if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(TRUE);
	return TRUE;
}

// 两个及两个以上相机对位系统实时目标对象搜索
BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetAndObjectSearchFOBC(std::vector<int> vnTargetPosIndex,std::vector<int> vnObjectPosIndex,int nSameType)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOBC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckObjectSearchTool(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;	

	int nPosNum = vnTargetPosIndex.size();
	//	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
		return FALSE;
	}
	nPosNum = vnObjectPosIndex.size();
	//	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
		return FALSE;
	}


	//	int i=0;
	for(i=0; i<vnObjectPosIndex.size(); i++)
	{		 
		nPosIndex = vnObjectPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
			return FALSE;
		}    	
	}
	//	int i=0;
	for(i=0; i<vnTargetPosIndex.size(); i++)
	{		 
		nPosIndex = vnTargetPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 对象、目标模板曝光切换
	{
		int nStartPatIndex = 0;
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nStartPatIndex);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(nStartPatIndex);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);
		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)

		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && (bObjectShutter || bTargetShutter) /*&& (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnExposurePosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	

			if (bObjectShutter)
			{				
				for(i = 0; i < vnObjectPosIndex.size(); i++)
				{
					vnExposurePosIndex.push_back(vnObjectPosIndex.at(i));
					vsmCameraExposureType.push_back(eObjectSearchCameraExposure);
				}
			}

			if (bTargetShutter)
			{				
				for(i = 0; i < vnTargetPosIndex.size(); i++)
				{
					vnExposurePosIndex.push_back(vnTargetPosIndex.at(i));
					vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
				}
			}			

			if (!CameraExposureSetting(vnExposurePosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_AND_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}


	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	scTimer stCommuciateTimer; double dCommuciateTime(0.0);

	stCommuciateTimer.Reset();
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		//AfxMessageBox(_T("12"));
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (m_vpObjectPlatformAxisPos.size() <= 0 || m_vpObjectPlatformAxisPos.at(vnObjectPosIndex[0]) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnObjectPosIndex[0]));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}
			}			
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{		

					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					//AfxMessageBox(_T("13"));
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				//AfxMessageBox(_T("获取轴位置"));
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}


	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{	
			;
			//if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			//{
			//	pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
			//	//D角度不累加
			//}
			//else
			//{
			//	pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
			//}
			//D角度不累加
		}
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for(i=0; i<vnObjectPosIndex.size(); i++)
		{
			/*if (m_bAutoAlign)
			{
			AfxMessageBox("m_bAutoAlign = true");
			}else
			{
			AfxMessageBox("m_bAutoAlign = not");
			}*/
			/*if (m_nAlignTime==1)
			{
			AfxMessageBox("m_bAutoAlign = true");
			}else
			{
			AfxMessageBox("m_bAutoAlign = not");
			}*/
			nPosIndex = vnObjectPosIndex[i];
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			}

		}

		for (i=0;i<vnTargetPosIndex.size();i++)
		{
			nPosIndex = vnTargetPosIndex[i];
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;
			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	dCommuciateTime = stCommuciateTimer.GetTimeMilli(FALSE);
	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		


	// 3.开启定位
	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	stObjectSearchTimer.Reset();


	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}

	// 准备开始定位			
	//	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmObjectSearchMode;
	vsmObjectSearchMode.clear();
	std::vector<SearchMode> vsmTargetSearchMode;
	vsmTargetSearchMode.clear();
	//	int nPosIndex = 0;
	for(i = 0; i < vnObjectPosIndex.size(); i++)
	{
		nPosIndex = vnObjectPosIndex[i];
		//		vnPosIndex.push_back(nPosIndex);		// 	
		vsmObjectSearchMode.push_back(eObjectSearch);	// 
	}

	//	int nPosIndex = 0;
	for(i = 0; i < vnTargetPosIndex.size(); i++)
	{
		nPosIndex = vnTargetPosIndex[i];
		//		vnPosIndex.push_back(nPosIndex);		// 	
		vsmTargetSearchMode.push_back(eTargetSearch);	// 
	}


	// 隐藏结果图形
	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);
	m_cVisionAlignGui.SetPosGuiInvisible(vnTargetPosIndex, eTargetSearch);

	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// //	if (m_bIsObjectCornerSearchTool && (m_pSystempOptionConfig->m_bShowCornerTool))
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnObjectPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);

	// 隐藏目标定位结果十字
	// 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnTargetPosIndex, FALSE);
	// //	if (m_pSystempOptionConfig->m_bShowCornerTool && m_bIsTargetCornerSearchTool)
	// 	{
	// 		PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnTargetPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnTargetPosIndex, FALSE);
	// 	HideExtraGraphics(vnObjectPosIndex);
	// 	HideExtraGraphics(vnTargetPosIndex);

	// 采集搜索图像

	std::vector<int> vnGrabPos;
	vnGrabPos.clear();
	for (int i=0;i<vnObjectPosIndex.size();i++)
	{
		vnGrabPos.push_back(vnObjectPosIndex.at(i));
	}

	if (nSameType == 0)  // 0代表1234相机共同使用
	{
		for (int i=0;i<vnTargetPosIndex.size();i++)
		{
			vnGrabPos.push_back(vnTargetPosIndex.at(i));
		}
	}
	else if (nSameType == 1) // 1 代表可能只用12相机或者34相机
	{
		;
	}



	if (!SnapSearchImage(vnGrabPos))
	{
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
	BOOL bSearchSucceed1 = FALSE;
	BOOL bSearchSucceed2 = FALSE;
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		;
		//if (bObjectSearchCandidate == FALSE)
		//{
		//	for(i = 0; i < nPosNum; i++)
		//	{
		//		nPosIndex = vnPosIndex[i];
		//		m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
		//		m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		//	}
		//	bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		//}
		//else
		//{
		//	if (bObjectSearchSync == TRUE)
		//	{
		//		int nTempStartPatIndex, nTempEndPatIndex;
		//		nTempStartPatIndex = 0;
		//		nTempEndPatIndex = OBJECTCANDIDATENUM-1;

		//		int j = 0;
		//		for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
		//		{
		//			if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
		//			{
		//				continue;
		//			}

		//			for(i = 0; i < nPosNum; i++)
		//			{
		//				nPosIndex = vnPosIndex[i];
		//				m_vnObjectSearchStartPatIndex[nPosIndex] = j;
		//				m_vnObjectSearchEndPatIndex[nPosIndex] = j;
		//			}			
		//			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

		//			if (bSearchSucceed)
		//			{
		//				break;
		//			}	
		//			//Sleep(100);
		//		}
		//	}
		//	else
		//	{
		//		int nTempStartPatIndex, nTempEndPatIndex;
		//		for(i = 0; i < nPosNum; i++)
		//		{
		//			nPosIndex = vnPosIndex[i];
		//			nTempStartPatIndex = 0;
		//			nTempEndPatIndex = OBJECTCANDIDATENUM-1;

		//			m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
		//			m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
		//		}
		//		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		//	}
		//}
	}
	else
	{
		//2.开始使用图像定位
		for (int i=0;i<vnTargetPosIndex.size();i++)
		{
			nPosIndex = vnTargetPosIndex[i];
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed1 = SearchMark(vnTargetPosIndex, vsmTargetSearchMode);

		for (int i=0;i<vnObjectPosIndex.size();i++)
		{
			nPosIndex = vnObjectPosIndex[i];
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		}

		bSearchSucceed2 = SearchMark(vnObjectPosIndex, vsmObjectSearchMode);
	}
	bSearchSucceed = bSearchSucceed1&&bSearchSucceed2;
	// 设定、显示结果图形
	// 	SetGuiAlnObjectImageMarkPos(vnObjectPosIndex);
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, TRUE);
	// 	if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	// 	{
	// 		SetGuiAlnObjectLineImageMarkPos(vnObjectPosIndex);
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnObjectPosIndex, TRUE);
	// 	}
	// 	// SY
	// 	SetShowGuiObjectImageMarkPos(vnObjectPosIndex);
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, TRUE);
	m_cVisionAlignGui.SetPosSearchResult(vnObjectPosIndex, eObjectSearch);

	// 设定、显示目标定位结果十字，目标2/3图像
	m_cVisionAlignGui.SetPosSearchResult(vnTargetPosIndex, eObjectSearch);

	// 	SetGuiAlnTargetImageMarkPos(vnTargetPosIndex);
	// 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnTargetPosIndex, TRUE);
	// 	if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
	// 	{
	// 		SetGuiAlnTargetLineImageMarkPos(vnTargetPosIndex);
	// 		PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnTargetPosIndex, TRUE);
	// 	}
	// 	if ((/*m_bIsObjectCircleSearchTool &&*/ m_pSystempOptionConfig->m_bShowCircleTool) || (/*m_bIsObjectLineSearchTool &&*/ m_pSystempOptionConfig->m_bShowLineTool))
	// 	{
	// 		ShowAllGuiAlnObjectExtraGraphics(nCurProdcutIndex,vnObjectPosIndex);
	// 	}
	// 	if ((/*m_bIsTargetCircleSearchTool &&*/ m_pSystempOptionConfig->m_bShowCircleTool) || (/*m_bIsTargetLineSearchTool &&*/ m_pSystempOptionConfig->m_bShowLineTool))
	// 	{
	// 		ShowAllGuiAlnTargetExtraGraphics(nCurProdcutIndex,vnTargetPosIndex);
	// 	}
	// 	// 设定、显示目标定位结果文字，目标2/3图像
	// 	SetShowGuiTargetImageMarkPos(vnTargetPosIndex);
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnTargetPosIndex, TRUE);


	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			;
			//for (int k = 0; k < m_pSystempOptionConfig->m_nSearchTimes; k++)
			//{
			//	// 采集搜索图像
			//	if (!SnapSearchImage(vnPosIndex))
			//	{
			//		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

			//		m_bStatusBar = FALSE;
			//		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
			//		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
			//		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			//		return FALSE;
			//	}

			//	// 定位
			//	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
			//	BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
			//	if(m_pSystempOptionConfig->m_bEnableSearchCindidate)
			//	{
			//		if (bObjectSearchCandidate == FALSE)
			//		{
			//			for(i = 0; i < nPosNum; i++)
			//			{
			//				nPosIndex = vnPosIndex[i];
			//				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			//				m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			//			}
			//			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			//		}
			//		else
			//		{
			//			if (bObjectSearchSync == TRUE)
			//			{
			//				int nTempStartPatIndex, nTempEndPatIndex;
			//				nTempStartPatIndex = 0;
			//				nTempEndPatIndex = OBJECTCANDIDATENUM-1;

			//				int j = 0;
			//				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			//				{
			//					if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
			//					{
			//						continue;
			//					}

			//					for(i = 0; i < nPosNum; i++)
			//					{
			//						nPosIndex = vnPosIndex[i];
			//						m_vnObjectSearchStartPatIndex[nPosIndex] = j;
			//						m_vnObjectSearchEndPatIndex[nPosIndex] = j;
			//					}			
			//					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

			//					if (bSearchSucceed)
			//					{
			//						break;
			//					}	
			//					//Sleep(100);
			//				}
			//			}
			//			else
			//			{
			//				int nTempStartPatIndex, nTempEndPatIndex;
			//				for(i = 0; i < nPosNum; i++)
			//				{
			//					nPosIndex = vnPosIndex[i];
			//					nTempStartPatIndex = 0;
			//					nTempEndPatIndex = OBJECTCANDIDATENUM-1;

			//					m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
			//					m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			//				}
			//				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			//			}
			//		}
			//	}
			//	else
			//	{
			//		for(int i = 0; i < nPosNum; i++)
			//		{
			//			nPosIndex = vnPosIndex[i];
			//			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			//			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			//		}
			//		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			//	}

			//	// 设定、显示结果图形
			//	SetGuiAlnObjectImageMarkPos(vnPosIndex);
			//	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
			//	if (m_bIsObjectCornerSearchTool && (m_pSystempOptionConfig->m_bShowCornerTool))
			//	{
			//		SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
			//		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
			//	}
			//	// SY
			//	SetShowGuiObjectImageMarkPos(vnPosIndex);
			//	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

			//	if (bSearchSucceed)
			//	{
			//		break;
			//	}
			//}
		}
	}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnObjectPosIndex,eObjectSearch);
		ExeSaveVDBFile(vnObjectPosIndex,eObjectSearch);
	}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnTargetPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnTargetPosIndex,eTargetSearch);
	}
	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			//			RecordObjectSizeIndfo(FALSE,FALSE);

			if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			//			RecordObjectSizeIndfo(FALSE, FALSE);

			return FALSE;
			//if (m_pSystempOptionConfig->m_bSetVisionManualSearchToPLC)
			//{
			//	// 通知PLC，视觉弹出手动搜索框
			//	SetPlcManualSearch(TRUE);
			//}

			//if (FALSE ==ExcuteManualSearch(1,vnPosIndex))
			//{
			//	if (m_pSystempOptionConfig->m_bSetVisionManualSearchToPLC)
			//	{
			//		// 通知PLC，视觉关闭手动搜索框
			//		SetPlcManualSearch(FALSE);
			//	}

			//	if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

			//	m_bStatusBar = FALSE;
			//	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			//	m_strStatusBarInfo2 = _T("");
			//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			//	RecordObjectSizeIndfo(FALSE, FALSE);

			//	return FALSE;

			//}
			//if (m_pSystempOptionConfig->m_bSetVisionManualSearchToPLC)
			//{
			//	// 通知PLC，视觉关闭手动搜索框
			//	SetPlcManualSearch(FALSE);
			//}


		}
		else
		{
			//			RecordObjectSizeIndfo(FALSE,FALSE);

			if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			//			RecordObjectSizeIndfo(FALSE, FALSE);

			return FALSE;
		}


	}

	// 5. 设置对位工具
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	// 计算对象距离
	//	CalculateObjectDistance(); 
	if (!CheckObjectDistance())
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //__T("对象距离超过设定标准，对象定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(TRUE,FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{
			;
			/*for(i = 0; i < nPosNum; i++)
			{
			nPosIndex = vnPosIndex[i];
			CTime t = CTime::GetCurrentTime();	
			m_vstrTemp.at(nPosIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageObjectSearchFailed.bmp"),
			t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

			m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;																			
			m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d-Check.bmp"), 
			nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
			m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
			m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
			if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
			{
			m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
			}
			}*/

		}

		return FALSE;
	}

	//	RecordObjectSizeIndfo(TRUE, TRUE);

	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");		
		for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

			//strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) (%.2f,%.2f)(%.2f,%.2f)"), i, cp.GetPosX(), cp.GetPosY(),cp.GetAuxiliaryPosX(0),cp.GetAuxiliaryPosY(0),cp.GetAuxiliaryPosX(1),cp.GetAuxiliaryPosY(1));

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 5. 设置对位工具
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	// 计算目标距离
	//	CalculateTargetDistance(); 
	if (!CheckTargetDistance())
	{
		ReportObjectSearchResultFOBC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{	
			for(i = 0; i < nPosNum; i++)
			{
				;
				/*nPosIndex = vnPosIndex[i];
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageTargetSearchFailed.bmp"),
				t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) + 1;																			
				m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d-Check.bmp"), 
				nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));
				m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = 0;
				}*/
			}			
		}	

		return FALSE;
	}

	//	RecordTargetSizeIndfo(TRUE, TRUE);
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		strOut = strTemp + _T("TargetSearch: ");		

		for (int i=0;i<vnTargetPosIndex.size();i++)
		{
			//目标
			strTemp.Format("目标 CH%d The SearchResult:%.2f,%.2f;>>>>>>",vnTargetPosIndex.at(i),m_mpTargetMarkImagePos.m_vPos.at(vnTargetPosIndex.at(i)).m_dPosX,m_mpTargetMarkImagePos.m_vPos.at(vnTargetPosIndex.at(i)).m_dPosY);
			strOut += strTemp;
		}

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}



	dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
	//	CString str;
	//str.Format("Serial camera object search time = %f",dObjectSearchTime);
	//AlignLogRecord(str);
	if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(TRUE,-1);
	//AfxMessageBox(_T("11111"));
	return TRUE;
}


// 两个及两个以上相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerObjectSearchExFOBJ(std::vector<int> vnPosIndex)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOBJ:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	//	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);
		return FALSE;
	}

	// 检查 vnPosIndex值是否合理 规避异常值传入导致错误的相机在线检查报警
	for(i=0; i<nPosNum; i++)
	{	
		nPosIndex = vnPosIndex[i];
		if(nPosIndex>=0 && nPosIndex <GetPosNum())
		{
			continue;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);
			return FALSE;
		}
	}

	//	int i=0;
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(0);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;	

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eObjectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}

		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	scTimer stCommuciateTimer; double dCommuciateTime(0.0);

	stCommuciateTimer.Reset();
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (m_vpObjectPlatformAxisPos.size() <= 0 || m_vpObjectPlatformAxisPos.at(vnPosIndex[0]) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}
			}			
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}


	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
			}
			//D角度不累加
		}
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for(i=0; i<nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			SetObjectPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			}

		}


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	dCommuciateTime = stCommuciateTimer.GetTimeMilli(FALSE);
	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		


	// 3.开启定位
	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	stObjectSearchTimer.Reset();


	// 等待搜索延时
	// 	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	// 	Sleep(nDelayTime);

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}

	// 准备开始定位			
	//	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	//	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		//		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eObjectSearch);	// 
	}


	// 隐藏结果图形
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
	// //	if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
	//     //HideExtraGraphics(vnPosIndex);
	//     ShowExtraGuiToDisplay(vnPosIndex, FALSE);

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		if (bObjectSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
				m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bObjectSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				nTempStartPatIndex = 0;
				nTempEndPatIndex = OBJECTCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = j;
						m_vnObjectSearchEndPatIndex[nPosIndex] = j;
					}			
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

					if (bSearchSucceed)
					{
						break;
					}	
					//Sleep(100);
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					nTempStartPatIndex = 0;
					nTempEndPatIndex = OBJECTCANDIDATENUM-1;

					m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
	}
	else
	{
		for(int i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
				BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
				if(optionInfo.m_bEnableSearchCindidate)
				{
					if (bObjectSearchCandidate == FALSE)
					{
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
							m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (bObjectSearchSync == TRUE)
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							nTempStartPatIndex = 0;
							nTempEndPatIndex = OBJECTCANDIDATENUM-1;

							int j = 0;
							for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
							{
								if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
								{
									continue;
								}

								for(i = 0; i < nPosNum; i++)
								{
									nPosIndex = vnPosIndex[i];
									m_vnObjectSearchStartPatIndex[nPosIndex] = j;
									m_vnObjectSearchEndPatIndex[nPosIndex] = j;
								}			
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

								if (bSearchSucceed)
								{
									break;
								}	
								//Sleep(100);
							}
						}
						else
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								nTempStartPatIndex = 0;
								nTempEndPatIndex = OBJECTCANDIDATENUM-1;

								m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
								m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
				}
				else
				{
					for(int i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE ==ExcuteManualSearch(1,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}
	}

	// 设定、显示结果图形
	//     SetGuiAlnObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	//     if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	//     {
	//         SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	//         PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	//     }
	//     //if ((m_bIsObjectCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsObjectLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//     //{
	//         //ShowAllGuiAlnObjectExtraGraphics(nCurProdcutIndex,vnPosIndex);
	//         ShowExtraGuiToDisplay(vnPosIndex, TRUE,1);
	//     //}
	//     // SY
	//     SetShowGuiObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
		ExeSaveVDBFile(vnPosIndex,eObjectSearch);
	}
	if (bSearchSucceed)
	{
		// 设定、显示结果图形
		// 		SetGuiAlnObjectImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
		// 		if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
		// 		{
		// 			SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// SY
		// 		SetShowGuiObjectImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
	}
	else
	{
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		//		RecordObjectSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	SetMultiEXObjectMarkSearchResultsWithCombinationCode(m_mpObjectMarkImagePos);
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	// 计算对象距离
	//	CalculateObjectDistance(); 
	if (!optionInfo.m_bExeObjectCheckModeWhenAlign && !CheckObjectDistance())
	{
		if(m_bObjectSearchTest) ReportObjectSearchResult(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //__T("对象距离超过设定标准，对象定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(TRUE,FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{		
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}

		}

		return FALSE;
	}

	//	RecordObjectSizeIndfo(TRUE, TRUE);

	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");		
		for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

			//strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) (%.2f,%.2f)(%.2f,%.2f)"), i, cp.GetPosX(), cp.GetPosY(),cp.GetAuxiliaryPosX(0),cp.GetAuxiliaryPosY(0),cp.GetAuxiliaryPosX(1),cp.GetAuxiliaryPosY(1));

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}
	dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);

	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1 )
	{
		return ExecuteAlignAfterFOBJAndFTGT(1);
	}
	//	CString str;
	//str.Format("Serial camera object search time = %f",dObjectSearchTime);
	//AlignLogRecord(str);
	if(m_bObjectSearchTest) ReportObjectSearchResult(TRUE);
	return TRUE;
}


BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetSearchExFCNO(std::vector<int> vnPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCNO:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();

	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
		return FALSE;
	}

	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));
			if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();


		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(0);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);


		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (m_vpTargetPlatformAxisPos.size() <= 0 
			|| m_vpTargetPlatformAxisPos.at(vnPosIndex[0]) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(vnPosIndex[0]));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
	}

	if (!bCommuciateGetPlatformAxisAbsPos)		         
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFCNO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			nPosIndex = vnPosIndex[i];
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);

			// 			if (m_bIsMutiTarget && m_pSystempOptionConfig->m_bEnableMutiTarget)
			// 			{
			// 				SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			// 			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;

			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<SearchMode> vsmSearchMode;	
	// 定义全部位置向量，包含0/1对象和2/3目标
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;

	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		vsmSearchMode.push_back(eTargetSearch);	

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex- GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);

		}
	}


	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);

	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);

	}

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportTargetSearchResultFCNO(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
		if (bTargetSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
				m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bTargetSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				nTempStartPatIndex = 0;
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = j;
						m_vnTargetSearchEndPatIndex[nPosIndex] = j;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					if (bSearchSucceed)
					{
						break;
					}
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					nTempStartPatIndex = 0;
					nTempEndPatIndex = TARGETCANDIDATENUM-1;

					m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
	}
	else
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					ReportTargetSearchResultFCNO(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				if(optionInfo.m_bEnableSearchCindidate)
				{
					BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
					BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
					if (bTargetSearchCandidate == FALSE)
					{
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
							m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (bTargetSearchSync == TRUE)
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							nTempStartPatIndex = 0;
							nTempEndPatIndex = TARGETCANDIDATENUM-1;

							int j = 0;
							for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
							{
								if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
								{
									continue;
								}

								for(i = 0; i < nPosNum; i++)
								{
									nPosIndex = vnPosIndex[i];
									m_vnTargetSearchStartPatIndex[nPosIndex] = j;
									m_vnTargetSearchEndPatIndex[nPosIndex] = j;
								}
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
								if (bSearchSucceed)
								{
									break;
								}
							}
						}
						else
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								nTempStartPatIndex = 0;
								nTempEndPatIndex = TARGETCANDIDATENUM-1;

								m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
								m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
				}
				else
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}

			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}
		}
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		vnHomoPosIndex = vnPosIndex;

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		// 		SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);

		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		// 设定、显示目标定位结果文字，全部0/1/2/3图像
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
		// 
		// 		ShowExtraGuiToDisplay(vnAllPosIndex, TRUE, 0);
	}
	else
	{
		// 设定、显示目标定位结果十字，目标2/3图像
		// 		SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

		// 
		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// 设定、显示目标定位结果文字，目标2/3图像
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, TRUE, 0);
	}

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		ReportTargetSearchResultFCNO(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	// 	if (m_bIsMutiTarget && m_pSystempOptionConfig->m_bEnableMutiTarget)
	// 	{
	// 		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
	// 		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	// 	}
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());


	// 计算目标距离
	//	CalculateTargetDistance(); 
	if (!CheckTargetDistance())
	{
		ReportTargetSearchResultFCNO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{	
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%d-%d-%d-%d-%d-%d-CH%d-ImageTargetSearchFailed.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) + 1;																			
				m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d-Check.bmp"), 
					nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}			
		}	

		return FALSE;
	}

	//	RecordTargetSizeIndfo(TRUE, TRUE);

	if (!CheckTargetAngle())
	{
		ReportTargetSearchResultFCNO(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	//	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());


	// 设置对象位置为图像中心
	for(i = 0; i < vnPosIndex.size(); i++)
	{
		int nPosIndex = vnPosIndex.at(i);

		CCoordPos cpImageMarkPos;
		cpImageMarkPos.m_dPosX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
		cpImageMarkPos.m_dPosY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;
		cpImageMarkPos.m_dAngle = 0;

		m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpImageMarkPos);
	}	
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
	// 
	// 	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	// 	{
	// 		SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 
	// 	if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	// 	{
	// 		SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 
	// 	// SY
	// 	SetShowGuiObjectImageMarkPos(vnPosIndex);
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
	// 
	// 	ShowExtraGuiToDisplay(vnPosIndex, TRUE, 1);

	// 5. 设置对位工具
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;
		CCoordPos cp;

		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) (%.2f,%.2f)(%.2f,%.2f)"), i, cp.GetPosX(), cp.GetPosY(),cp.GetAuxiliaryPosX(0),cp.GetAuxiliaryPosY(0),cp.GetAuxiliaryPosX(1),cp.GetAuxiliaryPosY(1));

			strOut += strTemp;

		}

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	ReportTargetSearchResultFCNO(TRUE);

	return TRUE;
}

BOOL vcXYDVisionAlign::OnSerialCameraAlignerObjectSearchExFCNT(std::vector<int> vnPosIndex)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCNT:");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckObjectSearchTool(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	//	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);
		return FALSE;
	}

	//	int i=0;
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(0);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter)
		{

			std::vector<CameraExposureType> vsmCameraExposureType;	
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eObjectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}

		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	scTimer stCommuciateTimer; double dCommuciateTime(0.0);

	stCommuciateTimer.Reset();
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (m_vpObjectPlatformAxisPos.size() <= 0 || m_vpObjectPlatformAxisPos.at(vnPosIndex[0]) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}	
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(vnPosIndex[0]))->m_dAngle;
			}
			//D角度不累加
		}
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	else
	{ 
		for(i=0; i<nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			}

			// 目标对象分离时设置当前轴位置到3/4位置
			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				int nPosSeparate = nPosIndex+GetPosNum()/2;
				if (nPosSeparate < 0 || nPosSeparate >= GetPosNum())
				{
					if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);//SendCommInfo(CMD_TGG_SEARCH_UNKNOWN_ERR);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_SEARCH_FAILE);//_T("对象拍照失败");;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;
				}
				SetTargetPlatformPos(pPlatformAxisPos,nPosSeparate);
				SetTempTargetPlatformAxisPos(nPosSeparate,pPlatformAxisPos);
			}
			else
			{
				SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			}
		}


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	dCommuciateTime = stCommuciateTimer.GetTimeMilli(FALSE);
	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	// 3.开启定位
	double dObjectSearchTime(0.0);
	scTimer stObjectSearchTimer; 
	stObjectSearchTimer.Reset();


	// 等待搜索延时
	// 	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	// 	Sleep(nDelayTime);

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}

	// 准备开始定位			
	//	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;
	for (int j=0;j<GetPosNum();j++)
	{
		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex- GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);
		}
	}


	//	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		//		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eObjectSearch);	// 
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{

		// 隐藏目标定位结果十字，全部0/1/2/3图像
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 
		// //		if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}

		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);

	}
	else
	{
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 
		// //		if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 
		// 		// SY
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
	}


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		if (bObjectSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
				m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bObjectSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				nTempStartPatIndex = 0;
				nTempEndPatIndex = OBJECTCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = j;
						m_vnObjectSearchEndPatIndex[nPosIndex] = j;
					}	

					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

					if (bSearchSucceed)
					{
						break;
					}	
					//Sleep(100);
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					nTempStartPatIndex = 0;
					nTempEndPatIndex = OBJECTCANDIDATENUM-1;

					m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
	}
	else
	{
		for(int i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				if(optionInfo.m_bEnableSearchCindidate)
				{
					if (bObjectSearchCandidate == FALSE)
					{
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
							m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (bObjectSearchSync == TRUE)
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							nTempStartPatIndex = 0;
							nTempEndPatIndex = OBJECTCANDIDATENUM-1;

							int j = 0;
							for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
							{
								if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
								{
									continue;
								}

								for(i = 0; i < nPosNum; i++)
								{
									nPosIndex = vnPosIndex[i];
									m_vnObjectSearchStartPatIndex[nPosIndex] = j;
									m_vnObjectSearchEndPatIndex[nPosIndex] = j;
								}	

								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

								if (bSearchSucceed)
								{
									break;
								}	
								//Sleep(100);
							}
						}
						else
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								nTempStartPatIndex = 0;
								nTempEndPatIndex = OBJECTCANDIDATENUM-1;

								m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
								m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
				}
				else
				{
					for(int i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE ==ExcuteManualSearch(1,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}
	}

	// 设定、显示结果图形
	//     SetGuiAlnObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	// 	{
	// 		SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 
	//     if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	//     {
	//         SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	//         PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	//     }
	//     // SY
	//     SetShowGuiObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
		ExeSaveVDBFile(vnPosIndex,eObjectSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	if (!CheckObjectDistance())
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //__T("对象距离超过设定标准，对象定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{		
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}
		}
		return FALSE;
	}

	//	RecordObjectSizeIndfo(TRUE, TRUE);

	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 设置目标位置为图像中心
	for(i = 0; i < vnPosIndex.size(); i++)
	{
		int nPosIndex = vnPosIndex.at(i);

		// 目标对象分离时设置图像中心为3/4位置
		if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
		{
			int nPosSeparate = nPosIndex+GetPosNum()/2;
			CCoordPos cpImageMarkPos;
			cpImageMarkPos.m_dPosX = GetPosDisplay(nPosSeparate)->GetImageWidth()/2;
			cpImageMarkPos.m_dPosY = GetPosDisplay(nPosSeparate)->GetImageHeight()/2;
			cpImageMarkPos.m_dAngle = 0;

			m_mpTargetMarkImagePos.SetMarkImagePos(nPosSeparate, TRUE, cpImageMarkPos);
		}
		else
		{
			CCoordPos cpImageMarkPos;
			cpImageMarkPos.m_dPosX = GetPosDisplay(nPosIndex)->GetImageWidth()/2;
			cpImageMarkPos.m_dPosY = GetPosDisplay(nPosIndex)->GetImageHeight()/2;
			cpImageMarkPos.m_dAngle = 0;

			m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, cpImageMarkPos);
		}
	}		

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		vnHomoPosIndex = vnPosIndex;

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					//	ReportTargetSearchResultFTGM(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					//return FALSE;
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		// 		SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// 设定、显示目标定位结果文字，全部0/1/2/3图像
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
	}
	else
	{
		// 设置目标显示
		// 		SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// SY
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);

		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
	}


	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");		
		for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}
	dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
	//	CString str;
	//str.Format("Serial camera object search time = %f",dObjectSearchTime);
	//AlignLogRecord(str);
	if(m_bObjectSearchTest) ReportObjectSearchResultFCNT(TRUE);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnSerialCameraMulAlignerPosObjectSearchCandidateExFOBC(int nStartPatIndex)
{
	return TRUE;
}

// 两个及两个以上相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerObjectSearchCandidateExFOBC(int nStartPatIndex)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOBC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckObjectSearchTool(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();



	// 对象模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bObjectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchShutter(nStartPatIndex);
		BOOL bObjectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bObjectCandidate*/ && bObjectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
				vsmCameraExposureType.push_back(eObjectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_OBJECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	scTimer stCommuciateTimer; double dCommuciateTime(0.0);

	stCommuciateTimer.Reset();
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (nPosNum != m_vpObjectPlatformAxisPos.size() || m_vpObjectPlatformAxisPos.at(0) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}	
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}


	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;
			}
			//D角度不累加
		}
	}

	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for(int j=0; j<nPosNum; j++)
		{
			SetObjectPlatformPos_MultiEx(pPlatformAxisPos,j);
			SetObjectPlatformPos(pPlatformAxisPos,j);

			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(j,pPlatformAxisPos);
			}
		}


		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}

	dCommuciateTime = stCommuciateTimer.GetTimeMilli(FALSE);
	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	// 3.开启定位
	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	stObjectSearchTimer.Reset();


	// 等待搜索延时
	// 	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	// 	Sleep(nDelayTime);

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eObjectSearch);	// 
	}

	// 隐藏结果图形
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
	// //	if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
	//     //HideExtraGraphics(vnPosIndex);
	//     ShowExtraGuiToDisplay(vnPosIndex, FALSE);

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (bObjectSearchCandidate == FALSE)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = i;
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bObjectSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[0];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = OBJECTCANDIDATENUM-1;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{
				if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
				{
					continue;
				}

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = i;
					m_vnObjectSearchStartPatIndex[nPosIndex] = j;
					m_vnObjectSearchEndPatIndex[nPosIndex] = j;
				}			
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				if (bSearchSucceed)
				{
					break;
				}	
				//Sleep(100);
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = OBJECTCANDIDATENUM-1;

				m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}

	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
				BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
				if (bObjectSearchCandidate == FALSE)
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = i;
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}
				else
				{
					if (bObjectSearchSync == TRUE)
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
						{
							nTempStartPatIndex = nStartPatIndex;
						}
						else if (nStartPatIndex == 9)
						{
							nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[0];
						}
						else
						{
							nTempStartPatIndex = 0;
						}
						nTempEndPatIndex = OBJECTCANDIDATENUM-1;

						int j = 0;
						for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
						{
							if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
							{
								continue;
							}

							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = i;
								m_vnObjectSearchStartPatIndex[nPosIndex] = j;
								m_vnObjectSearchEndPatIndex[nPosIndex] = j;
							}			
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

							if (bSearchSucceed)
							{
								break;
							}	
							//Sleep(100);
						}
					}
					else
					{
						int nTempStartPatIndex, nTempEndPatIndex;
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = i;
							if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
							{
								nTempStartPatIndex = nStartPatIndex;
							}
							else if (nStartPatIndex == 9)
							{
								nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
							}
							else
							{
								nTempStartPatIndex = 0;
							}
							nTempEndPatIndex = OBJECTCANDIDATENUM-1;

							m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
							m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}

				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE ==ExcuteManualSearch(1,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}

		}
	}

	// 设定、显示结果图形
	//     SetGuiAlnObjectImageMarkPos(vnPosIndex);
	//     PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	//     	if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
	//     	{
	//     		SetGuiAlnObjectImageMarkPos(vnPosIndex);
	//     		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	//     	}
	//     
	//     	if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	//         {
	//             SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	//             PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	//         }
	//         //if ((m_bIsObjectCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsObjectLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//         //{
	//            // ShowAllGuiAlnObjectExtraGraphics(nCurProdcutIndex,vnPosIndex);
	//             ShowExtraGuiToDisplay(vnPosIndex, TRUE,1);
	//        // }
	//     
	//         // SY
	//         SetShowGuiObjectImageMarkPos(vnPosIndex);
	//         PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
		ExeSaveVDBFile(vnPosIndex,eObjectSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = m_StrSearchErrorInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		m_strStatusBarInfo1 += m_StrSearchErrorInfo;
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	SetMultiEXObjectMarkSearchResultsWithCombinationCode(m_mpObjectMarkImagePos);
	SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

	// 计算对象距离
	//	CalculateObjectDistance(); 
	if (!CheckObjectDistance())
	{
		if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //__T("对象距离超过设定标准，对象定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordObjectSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{		
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageObjectSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageObjectSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex));
				}

				CString strPath = m_strDataRecord + _T("\\AlignTool");
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],strPath + _T("\\") + m_vstrTemp.at(nPosIndex));

				if(m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerObjectSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}
		}

		return FALSE;
	}

	//	RecordObjectSizeIndfo(TRUE, TRUE);

	if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}


	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");		
		for (int i=0; i<m_mpObjectMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpObjectMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	/*for (int i=0;i<vnPosIndex.size();i++)
	{
	int nIndx=vnPosIndex.at(i);
	m_vbIsObjectPosSearchFinished.at(nIndx)=TRUE;
	}

	BOOL bAllObjectPosSearch=TRUE;
	for (int i=0;i<m_vbIsObjectPosSearchFinished.size();i++)
	{
	bAllObjectPosSearch=bAllObjectPosSearch && m_vbIsObjectPosSearchFinished.at(i);
	}
	m_bAllObjectPosSearchSuccess=bAllObjectPosSearch;*/

	dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);

	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1 /*&& m_bAllObjectPosSearchSuccess && m_bAllTargetPosSearchSuccess*/)
	{
		/*for (int i=0;i<m_vbIsObjectPosSearchFinished.size();i++)
		{
		m_vbIsObjectPosSearchFinished.at(i) = FALSE;
		}
		m_bAllObjectPosSearchSuccess = FALSE;*/
		return ExecuteAlignAfterFOBCAndFTGC(vnPosIndex,1);
	}
	//	CString str;
	// 	str.Format("Serial camera object search time = %f",dObjectSearchTime);
	// 	AlignLogRecord(str);
	if(m_bObjectSearchTest)
	{
		if (bObjectSearchSync)
		{
			ReportObjectSearchResultFOBC(TRUE,m_vnObjectSearchSuccessPatIndex[0]);
		}
		else
		{
			ReportObjectSearchResultFOBC(TRUE,-1);
		}

	}
	return TRUE;
}





// 两个及两个以上相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetSearchExFTGT()
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VTGT:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);
			return FALSE;
		}    	
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();



	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(0);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
				vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (nPosNum != m_vpTargetPlatformAxisPos.size() || m_vpTargetPlatformAxisPos.at(0) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(0));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))		
	if (!bCommuciateGetPlatformAxisAbsPos)		         
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			SetTargetPlatformPos_MultiEx(pPlatformAxisPos,i);
			SetTargetPlatformPos(pPlatformAxisPos,i);
			SetTempTargetPlatformAxisPos(i,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,i);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;
	for (int j=0;j<GetPosNum();j++)
	{
		if (j>=GetPosNum()/2)
		{
			nAllPosIndex = j- GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = j;
			vnAllPosIndex.push_back(nAllPosIndex);
		}
	}

	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eTargetSearch);	// 
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		//         //HideExtraGraphics(vnAllPosIndex);
		//         ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);
	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		//         //HideExtraGraphics(vnPosIndex);
		//         ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}



	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
		if (bTargetSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
				m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bTargetSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				nTempStartPatIndex = 0;
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = j;
						m_vnTargetSearchEndPatIndex[nPosIndex] = j;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					if (bSearchSucceed)
					{
						break;
					}
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					nTempStartPatIndex = 0;
					nTempEndPatIndex = TARGETCANDIDATENUM-1;

					m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
	}
	else
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				if(optionInfo.m_bEnableSearchCindidate)
				{
					BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
					BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
					if (bTargetSearchCandidate == FALSE)
					{
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
							m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (bTargetSearchSync == TRUE)
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							nTempStartPatIndex = 0;
							nTempEndPatIndex = TARGETCANDIDATENUM-1;

							int j = 0;
							for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
							{
								if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
								{
									continue;
								}

								for(i = 0; i < nPosNum; i++)
								{
									nPosIndex = vnPosIndex[i];
									m_vnTargetSearchStartPatIndex[nPosIndex] = j;
									m_vnTargetSearchEndPatIndex[nPosIndex] = j;
								}
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
								if (bSearchSucceed)
								{
									break;
								}
							}
						}
						else
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								nTempStartPatIndex = 0;
								nTempEndPatIndex = TARGETCANDIDATENUM-1;

								m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
								m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
				}
				else
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}


	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		for (int k = GetPosNum()/2; k<GetPosNum(); k++)
		{
			vnHomoPosIndex.push_back(k);
		}

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					//	ReportTargetSearchResultFTGM(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					//return FALSE;
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		//         SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		//         PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);

		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 		}
		// 
		//         if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		//         {
		//             SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         
		//         // 设定、显示目标定位结果文字，全部0/1/2/3图像
		//         SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		//         PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
	}
	else
	{
		// 设定、显示结果图形
		//         SetGuiAlnTargetImageMarkPos(vnPosIndex);
		//         PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);


		// 		if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		// 		{
		// 			SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 
		//         if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		//         {
		//             SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // SY
		//         SetShowGuiTargetImageMarkPos(vnPosIndex);
		//         PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
	}
	//if ((m_bIsTargetCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsTargetLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//{
	//ShowAllGuiAlnTargetExtraGraphics(nCurProdcutIndex,vnPosIndex);
	//ShowExtraGuiToDisplay(vnPosIndex, TRUE,0);
	//}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (bSearchSucceed)
	{

	}
	else
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}
	// 计算目标距离
	//	CalculateTargetDistance(); 
	if (!CheckTargetDistance())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{	
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageTargetSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}			
		}	

		return FALSE;
	}

	//	RecordTargetSizeIndfo(TRUE, TRUE);

	if (!CheckTargetAngle())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1)
	{
		return ExecuteAlignAfterFOBJAndFTGT(2);
	}
	if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(TRUE);

	return TRUE;
}

// 两个及两个以上相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetSearchExFTGT(std::vector<int> vnPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VTGT:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	//	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);
		return FALSE;
	}

	// 检查 vnPosIndex值是否合理 规避异常值传入导致错误的相机在线检查报警
	for(i=0; i<nPosNum; i++)
	{	
		nPosIndex = vnPosIndex[i];
		if(nPosIndex>=0 && nPosIndex <GetPosNum())
		{
			continue;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			if(m_bTargetSearchTest) ReportTargetSearchResult(FALSE);
			return FALSE;
		}
	}


	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	// 目标模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bTargetCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableTargetSearchShutter(0);
		BOOL bTargetShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//	if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bTargetCandidate*/ && bTargetShutter)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_TARGET_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (optionInfo.m_bTargetPosSame == TRUE)
	{
		if (m_vpTargetPlatformAxisPos.size() <= 0 
			|| m_vpTargetPlatformAxisPos.at(vnPosIndex[0]) == NULL)
		{
			bCommuciateGetPlatformAxisAbsPos = FALSE;
		}
		else
		{
			*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(vnPosIndex[0]));
			bCommuciateGetPlatformAxisAbsPos = TRUE;
		}		
	}
	else
	{
		if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
		{		
			bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
		}
		else
		{
			bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

		//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))		
	if (!bCommuciateGetPlatformAxisAbsPos)		         
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFTGT(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			nPosIndex = vnPosIndex[i];
			SetTargetPlatformPos_MultiEx(pPlatformAxisPos,nPosIndex);
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;

	//	Sleep(1000);

	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	//	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	// 定义全部位置向量，包含0/1对象和2/3目标
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;

	//	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		//		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eTargetSearch);	// 

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex- GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);

		}
	}


	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// 
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		//         //HideExtraGraphics(vnAllPosIndex);
		//         ShowExtraGuiToDisplay(vnAllPosIndex, FALSE);
	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);


		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		//         //HideExtraGraphics(vnPosIndex);
		//         ShowExtraGuiToDisplay(vnPosIndex, FALSE);
	}

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportTargetSearchResultFTGT(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bSearchSucceed = FALSE;
	if(optionInfo.m_bEnableSearchCindidate)
	{
		BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
		if (bTargetSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
				m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bTargetSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				nTempStartPatIndex = 0;
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = j;
						m_vnTargetSearchEndPatIndex[nPosIndex] = j;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					if (bSearchSucceed)
					{
						break;
					}
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					nTempStartPatIndex = 0;
					nTempEndPatIndex = TARGETCANDIDATENUM-1;

					m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}
		}
	}
	else
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
			m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					ReportTargetSearchResultFTGT(FALSE);

					// 					m_bStatusBar = FALSE;
					// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					// 					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				if(optionInfo.m_bEnableSearchCindidate)
				{
					BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
					BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
					if (bTargetSearchCandidate == FALSE)
					{
						for(i = 0; i < nPosNum; i++)
						{
							nPosIndex = vnPosIndex[i];
							m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
							m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
						}
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						if (bTargetSearchSync == TRUE)
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							nTempStartPatIndex = 0;
							nTempEndPatIndex = TARGETCANDIDATENUM-1;

							int j = 0;
							for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
							{
								if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
								{
									continue;
								}

								for(i = 0; i < nPosNum; i++)
								{
									nPosIndex = vnPosIndex[i];
									m_vnTargetSearchStartPatIndex[nPosIndex] = j;
									m_vnTargetSearchEndPatIndex[nPosIndex] = j;
								}
								bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
								if (bSearchSucceed)
								{
									break;
								}
							}
						}
						else
						{
							int nTempStartPatIndex, nTempEndPatIndex;
							for(i = 0; i < nPosNum; i++)
							{
								nPosIndex = vnPosIndex[i];
								nTempStartPatIndex = 0;
								nTempEndPatIndex = TARGETCANDIDATENUM-1;

								m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
								m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
							}
							bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
						}
					}
				}
				else
				{
					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = vnPosIndex[i];
						m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
						m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		// SendCommInfo(CMD_TGG_SEARCH_SUCCEED);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}
			}
			else
			{
				bSearchSucceed = TRUE;
			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		vnHomoPosIndex = vnPosIndex;

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					//	ReportTargetSearchResultFTGM(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					//return FALSE;
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}
		//         if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		//         {
		//             // 设定、显示目标定位结果十字，全部0/1/2/3图像
		//             SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		//             PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 
		//         }
		//         
		//         if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		//         {
		//             SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // 设定、显示目标定位结果文字，全部0/1/2/3图像
		//         SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		//         PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
	}
	else
	{
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

		//         if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		//         {
		//             // 设定、显示目标定位结果十字，目标2/3图像
		//             SetGuiAlnTargetImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//        
		//         if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		//         {
		//             SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		//         }
		//         // 设定、显示目标定位结果文字，目标2/3图像
		//         SetShowGuiTargetImageMarkPos(vnPosIndex);
		//         PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
	}
	//if ((m_bIsTargetCircleSearchTool && m_pSystempOptionConfig->m_bShowCircleTool) || (m_bIsTargetLineSearchTool && m_pSystempOptionConfig->m_bShowLineTool))
	//{
	//ShowAllGuiAlnTargetExtraGraphics(nCurProdcutIndex,vnPosIndex);
	// ShowExtraGuiToDisplay(vnPosIndex, TRUE,0);
	//}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (bSearchSucceed)
	{
	}
	else
	{
		// SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);
		ReportTargetSearchResultFTGT(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(FALSE, FALSE);

		return FALSE;
	}

	// 5. 设置对位工具
	m_vmpTargetMarkImagePosMultiEx.at(m_pAlignerTool->GetAlignExProductIndex()) = m_mpTargetMarkImagePos;
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}
	// 计算目标距离
	//	CalculateTargetDistance(); 
	if (!optionInfo.m_bExeTargetCheckModeWhenAlign && !CheckTargetDistance())
	{
		ReportTargetSearchResultFTGT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		RecordTargetSizeIndfo(TRUE, FALSE);

		if (m_pVisionASMConfig->m_DataRecord.m_bSaveNGImage)
		{	
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				CTime t = CTime::GetCurrentTime();	
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-CH%02d-ImageTargetSearchFailed-Check.bmp"),
					t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond(), nPosIndex);

				SYSTEMTIME sys; 
				GetLocalTime(&sys); 
				m_vstrTemp.at(nPosIndex).Format(_T("%04d-%02d-%02d-%02d-%02d-%02d-%03d-CH%02d-ImageTargetSearchFailed-Check.bmp"),
					sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond, sys.wMilliseconds, nPosIndex);

				m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) + 1;																			
				if (m_pVisionASMConfig->m_DataRecord.m_bDataRecordTime == FALSE)
				{
					m_vstrTemp.at(nPosIndex).Format(_T("ImageTargetSearchFailed-CH%02d-%03d-Check.bmp"), 
						nPosIndex,m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex));
				}
				/*m_vDibTemp.at(nPosIndex).Init(m_vImageSearch[nPosIndex]);
				m_vDibTemp.at(nPosIndex).Write(m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));*/
				SaveImage(nPosIndex,m_vImageSearch[nPosIndex],m_strDataRecord + _T("\\") + m_vstrTemp.at(nPosIndex));
				if(m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) > m_pVisionASMConfig->m_DataRecord.m_nSaveFailedImageNum)
				{
					m_vSaveAlignerTargetSearchImageFailIndex.at(nPosIndex) = 0;
				}
			}			
		}	

		return FALSE;
	}

	//	RecordTargetSizeIndfo(TRUE, TRUE);

	if (!optionInfo.m_bExeTargetCheckModeWhenAlign && !CheckTargetAngle())
	{
		ReportTargetSearchResultFTGT(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) (%.2f,%.2f)(%.2f,%.2f)"), i, cp.GetPosX(), cp.GetPosY(),cp.GetAuxiliaryPosX(0),cp.GetAuxiliaryPosY(0),cp.GetAuxiliaryPosX(1),cp.GetAuxiliaryPosY(1));

			strOut += strTemp;

		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}
	if (optionInfo.m_bEnableAlignAfterSearch && m_nAlignType!=-1)
	{
		return ExecuteAlignAfterFOBJAndFTGT(2);
	}

	ReportTargetSearchResultFTGT(TRUE);
	return TRUE;
}

// 两个及两个以上相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetSearchExFTGS()
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);
		return FALSE;
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);
			return FALSE;
		}    	
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();
	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (nPosNum != m_vpTargetPlatformAxisPos.size() || m_vpTargetPlatformAxisPos.at(0) == NULL)
	{
		bCommuciateGetPlatformAxisAbsPos = FALSE;
	}
	else
	{
		*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(0));
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}



	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))		
	if (!bCommuciateGetPlatformAxisAbsPos)		      
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			SetTargetPlatformPos(pPlatformAxisPos,i);
			SetTempTargetPlatformAxisPos(i,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,i);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	//	Sleep(1000);

	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	// 定义全部位置向量，包含0/1对象和2/3目标
	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;


	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eTargetSearch);	// 

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex-GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);

		}
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}

	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}

	}
	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 定位
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
		m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
	}
	BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);


	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		for (int k = GetPosNum()/2; k<GetPosNum(); k++)
		{
			vnHomoPosIndex.push_back(k);
		}

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					//	ReportTargetSearchResultFTGM(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					//return FALSE;
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
		// 		SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// 设定、显示目标定位结果文字，全部0/1/2/3图像
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
	}
	else
	{
		// 设定、显示结果图形
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);


		// 		SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// SY
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				// 定位
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = i;
					m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
					m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
				if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
				{
					int nHomoPosIndex = 0;
					std::vector<int> vnHomoPosIndex;			// 源目标位置
					for (int k = GetPosNum()/2; k<GetPosNum(); k++)
					{
						vnHomoPosIndex.push_back(k);
					}

					// 对目标2和3循环进行映射
					for (int i = 0; i<vnHomoPosIndex.size(); i++)
					{
						nHomoPosIndex = vnHomoPosIndex.at(i);
						if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
						{
							CCoordPos ObjImgPos;
							CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

							// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
							if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
							{
								//	ReportTargetSearchResultFTGM(FALSE);

								m_bStatusBar = FALSE;
								m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
								m_strStatusBarInfo2.Format(_T(""));
								SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

								//return FALSE;
							}

							// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
							m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
						}
					}

					// 设定、显示目标定位结果十字，全部0/1/2/3图像
					m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
					// 					SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
					// 					PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
					// 
					// 					if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
					// 					{
					// 						SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
					// 						PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
					// 					}
					// 					// 设定、显示目标定位结果文字，全部0/1/2/3图像
					// 					SetShowGuiTargetImageMarkPos(vnAllPosIndex);
					// 					PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
				}
				else
				{
					// 设定、显示结果图形
					m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

					// 					SetGuiAlnTargetImageMarkPos(vnPosIndex);
					// 					PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
					// 					if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
					// 					{
					// 						SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
					// 						PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
					// 					}
					// 					// SY
					// 					SetShowGuiTargetImageMarkPos(vnPosIndex);
					// 					PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
				}


				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
		ExeSaveVDBFile(vnPosIndex,eTargetSearch);
	}
	if (TRUE == bSearchSucceed)
	{
		// SendCommInfo(CMD_TGG_SEARCH_SUCCEED);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

				if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				//				RecordTargetSizeIndfo(FALSE, FALSE);

				return FALSE;

			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}
		else
		{
			// SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			// 4. 失败，关闭定位
			// CloseSearch();
			//		CloseSearch(vCamIndex);

			//			RecordTargetSizeIndfo(FALSE, FALSE);

			return FALSE;
		}

	}

	// 4. 关闭定位
	// CloseSearch();
	//	CloseSearch(vCamIndex);

	// 5. 设置对位工具
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}
	// 计算目标距离
	//	CalculateTargetDistance(); 
	if (!CheckTargetDistance())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		//		RecordTargetSizeIndfo(TRUE, FALSE);

		return FALSE;
	}

	//	RecordTargetSizeIndfo(TRUE, TRUE);

	if (!CheckTargetAngle())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}
	if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(TRUE);
	return TRUE;
}

// 两个及两个以上相机对位系统实时目标Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraAlignerTargetSearchExFTGS(std::vector<int> vnPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_bValidTargetSearchTool!=TRUE || NULL == m_pPlatformInfo)
	{	
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);
		return FALSE;
	}

	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();
	//	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nPosNum<=0)
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);
		return FALSE;
	}

	//	int i=0;
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);
			return FALSE;
		}    	
	}

	//	int nPosNum = m_pPlatformInfo->m_nPositionNum;

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();
	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (m_vpTargetPlatformAxisPos.size() <= 0 
		|| m_vpTargetPlatformAxisPos.at(vnPosIndex[0]) == NULL)
	{
		bCommuciateGetPlatformAxisAbsPos = FALSE;
	}
	else
	{
		*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(vnPosIndex[0]));
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}



	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))		
	if (!bCommuciateGetPlatformAxisAbsPos)		      
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	else
	{ 
		for (i=0;i<nPosNum;i++)
		{
			nPosIndex = vnPosIndex[i];
			SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			SetTempTargetPlatformAxisPos(nPosIndex,pPlatformAxisPos);
			if (optionInfo.m_bEnableMutiTarget)
			{
				SetMutiTargetPlatformPos(pPlatformAxisPos,nPosIndex);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(	GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_TARGET_SEARCH_PLATFORM_POS), 
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	// 2. 通信获取当前所有相机平台各个轴的绝对位置
	std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
	CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;		

	//	Sleep(1000);

	// 3.开启定位
	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	Sleep(nDelayTime);

	// 准备开始定位			
	//	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	std::vector<int> vnAllPosIndex;
	int nAllPosIndex = 0;

	//	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		//		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eTargetSearch);	// 

		if (nPosIndex>=GetPosNum()/2)
		{
			nAllPosIndex = nPosIndex-GetPosNum()/2;
			vnAllPosIndex.push_back(nAllPosIndex);

			nAllPosIndex = nPosIndex;
			vnAllPosIndex.push_back(nAllPosIndex);
		}
	}

	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate/* &&  m_pSystempOptionConfig->m_bShowSepTargetPos*//* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		// 隐藏目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnAllPosIndex, eTargetSearch);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，全部0/1/2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnAllPosIndex, FALSE);
		// 		}

	}
	else
	{
		// 隐藏目标定位结果十字，目标2/3图像
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);

		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// 		// 隐藏目标定位结果文字，目标2/3图像
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// //		if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}

	}
	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 定位
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
		m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
	}
	BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);



	// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
	{
		int nHomoPosIndex = 0;
		std::vector<int> vnHomoPosIndex;			// 源目标位置
		vnHomoPosIndex = vnPosIndex;

		// 对目标2和3循环进行映射
		for (int i = 0; i<vnHomoPosIndex.size(); i++)
		{
			nHomoPosIndex = vnHomoPosIndex.at(i);
			if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
			{
				CCoordPos ObjImgPos;
				CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

				// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
				if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
				{
					//	ReportTargetSearchResultFTGM(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					//return FALSE;
				}

				// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
				m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
			}
		}

		// 设定、显示目标定位结果十字，全部0/1/2/3图像
		m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
		// 		SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
		// 
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// 设定、显示目标定位结果文字，全部0/1/2/3图像
		// 		SetShowGuiTargetImageMarkPos(vnAllPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
	}
	else
	{
		// 设定、显示结果图形
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

		// 		SetGuiAlnTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		// 		if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
		// 		{
		// 			SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
		// 		}
		// 		// SY
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				//定位延时	 m_nSearchDelayTime
				Sleep(optionInfo.m_nSearchDelayTime);
				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				// 定位
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
					m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				// 如果目标和对象分离，并且关联标定不使用靶标，不读取轴位置，则将目标图像坐标映射到对象图像中，刷新所有图像的目标十字和文字GUI
				if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
				{
					int nHomoPosIndex = 0;
					std::vector<int> vnHomoPosIndex;			// 源目标位置
					vnHomoPosIndex = vnPosIndex;

					// 对目标2和3循环进行映射
					for (int i = 0; i<vnHomoPosIndex.size(); i++)
					{
						nHomoPosIndex = vnHomoPosIndex.at(i);
						if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
						{
							CCoordPos ObjImgPos;
							CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

							// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
							if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
							{
								//	ReportTargetSearchResultFTGM(FALSE);

								m_bStatusBar = FALSE;
								m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
								m_strStatusBarInfo2.Format(_T(""));
								SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

								//return FALSE;
							}

							// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
							m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
						}
					}

					// 设定、显示目标定位结果十字，全部0/1/2/3图像
					m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);
					// 					SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
					// 					PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
					// 					if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
					// 					{
					// 						SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
					// 						PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
					// 					}
					// 					// 设定、显示目标定位结果文字，全部0/1/2/3图像
					// 					SetShowGuiTargetImageMarkPos(vnAllPosIndex);
					// 					PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
				}
				else
				{
					// 设定、显示结果图形
					m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

					// 					SetGuiAlnTargetImageMarkPos(vnPosIndex);
					// 					PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
					// 					if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
					// 					{
					// 						SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
					// 						PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
					// 					}
					// 					// SY
					// 					SetShowGuiTargetImageMarkPos(vnPosIndex);
					// 					PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
				}


				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (TRUE == bSearchSucceed)
	{
		// SendCommInfo(CMD_TGG_SEARCH_SUCCEED);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (optionInfo.m_bManualAfTarSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				SetPlcManualSearch(TRUE);
			}

			if (FALSE == ExcuteManualSearch(0,vnPosIndex))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

				if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);//SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				//				RecordTargetSizeIndfo(FALSE, FALSE);

				return FALSE;

			}
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				SetPlcManualSearch(FALSE);
			}


		}
		else
		{
			// SendCommInfo(CMD_TGG_SEARCH_SEARCH_ERR);
			if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			// 4. 失败，关闭定位
			// CloseSearch();
			//		CloseSearch(vCamIndex);

			//			RecordTargetSizeIndfo(FALSE, FALSE);

			return FALSE;

		}

	}

	// 4. 关闭定位
	// CloseSearch();
	//	CloseSearch(vCamIndex);

	// 5. 设置对位工具
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex) = m_mpTargetMarkImagePos;
		m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex)=TRUE;
	}
	// 计算目标距离
	//	CalculateTargetDistance(); 
	if (!CheckTargetDistance())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_LEN_OVERFLOW);//_T("目标距离超过设定标准，目标定位结果可能出错");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		//		RecordTargetSizeIndfo(TRUE, FALSE);

		return FALSE;
	}

	//	RecordTargetSizeIndfo(TRUE, TRUE);

	if (!CheckTargetAngle())
	{
		if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("TargetSearch: ");		
		for (int i=0; i<m_mpTargetMarkImagePos.GetMarkImagePosNum(); i++)
		{
			strTemp = _T("");
			cp = m_mpTargetMarkImagePos.GetMarkImagePos(i);

			strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());

			strOut += strTemp;
		}

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}
	if(m_bTargetSearchTest) ReportTargetSearchResultFTGS(TRUE);
	return TRUE;
}




// 接收命令后，调用该函数，里面需要做一些额外的判断
// BOOL vcXYDVisionAlign::OnlineCalibrateEx(int nCalibPos, int nMarkType)
// {
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = _T("");
// 	m_strStatusBarInfo2 = _T("");
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 	PostMessageUpdateStatusBarInfo();
// 
// 	CString strTempWarningType = _T("");
// 	CString strCmd = _T("VCLB:");
// 	GetCommCommandName(strCmd);
// 	SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);
// 
// 	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
// 	{
//  
// 		ReportCalibResult(FALSE);
// 		
// 		return FALSE;
// 	}
// 
// 	CString strCalibLogPath;
// 	
// 	if (sysPlatformInfo.m_bProductFaChd)
// 	{
// 		int nCurProductIndexFa;
// 		int nCurProductIndexCh;
// 		m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 		strCalibLogPath.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CalibrateLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 			nCurProductIndexFa+1,nCurProductIndexCh+1);
// 	}
// 	else
// 	{
// 		strCalibLogPath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CalibrateLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 			m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 	}
// 	
// 
// 	// 平台为触发模式，标定时需要设置为非触发模式
// 	if (sysPlatformInfo.m_bCameraHardTriggerMode)
// 	{
// 		SetCameraTriggerMode(ePTNotTrigger);
// 	}
// 
// 	// 隐藏对象结果图形			
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	std::vector<int> vnObjectPosIndex;
// 	int nObjectPosIndex = 0;
// 	int i = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		nObjectPosIndex = i;
// 		vnObjectPosIndex.push_back(nObjectPosIndex);
// 	}	
// 	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);
// 
// 	// 隐藏目标结果图形	
// 	std::vector<int> vnTargetPosIndex;
// 	int nTargetPosIndex = 0;
// 	for(i = 0; i < nPosNum; i++)
// 	{
// 		if (sysPlatformInfo.m_bEnableMultiCalibExtension == TRUE)
// 		{
// 			if (i==((nCalibPos%nPosNum + nPosNum)%nPosNum))
// 			{
// 				nTargetPosIndex = i;
// 				vnTargetPosIndex.push_back(nTargetPosIndex);
// 			}
// 		}
// 		else
// 		{
// 			if (i==nCalibPos)
// 			{
// 				nTargetPosIndex = i;
// 				vnTargetPosIndex.push_back(nTargetPosIndex);
// 			}
// 		}
// 		
// 	}	
// 	m_cVisionAlignGui.SetPosGuiInvisible(vnTargetPosIndex, eTargetSearch);
// 
// 	BOOL bSucceed = FALSE;
// 
// 	// 执行标定
// 	if (m_pPlatformInfo->m_bPlatformPick)
// 	{	
// 		// 拾取标定
// 		if (m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformSepFix)			// 相机固定安装
// 		{
// 			bSucceed = OnSingleCameraAlignerCalibrateEx(nCalibPos, nMarkType);
// 		}
// 		else if (m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformShareXY)	// 相机安装在XYD吸头平台的XY轴上
// 		{
// 			if (nMarkType == 1)
// 			{
// 				bSucceed = OnSingleCameraAlignerCalibratePick(nCalibPos);				// 拾取标定像素当量和旋转角度
// 			}
// 			else if (nMarkType ==0)
// 			{
// 				bSucceed = OnSingleCameraAlignerCalibrateCenterPick(nCalibPos);			// 拾取标定旋转中心
// 			}
// 			else if(nMarkType == 5)														//全局二维码靶标标定，拾取相机随XY运动时，计算全局旋转中心
// 			{
// 				bSucceed= ExecuteCalibWholeDmCodeBoardPick(nCalibPos,nMarkType);		//拾取全局靶标标定计算旋转中心						
// 			}
// 		}
// 
// 		// 		AfxMessageBox(_T("不支持单相机！"));
// 		// 		bSucceed = FALSE;
// 	}
// 	else
// 	//    if (1 == m_pPlatformInfo->m_nCamNum)
// 	{		
// 		if ((nCalibPos == 10 || nCalibPos == 11)&& sysPlatformInfo.m_bEnableMultiCalibExtension == FALSE)
// 		{
// 			bSucceed = OnSingleCameraBenchMarkRgister(nCalibPos-10, nMarkType);
// 		}
// 		else
// 		{
// 			bSucceed = OnSingleCameraAlignerCalibrateEx(nCalibPos, nMarkType); // 单相机对位系统标定
// 		}
// 		// 		AfxMessageBox(_T("不支持单相机！"));
// 		// 		bSucceed = FALSE;
// 	}
// 	// 	else
// 	// 	{	
// 	//         bSucceed = OnSerialCamreaAlignerCalibrateEx(); // 多相机对位系统标定
// 	// 	}
// 	// 	
// 	// 返回结果
// 	if (TRUE == bSucceed)
// 	{	
// 
// 		CPlatformOptionInfo optionInfo;
// 		GetPlatformOptionInfo(optionInfo);
// 		if (optionInfo.m_bEnableCalibrateCheckByAxisMoveOption)
// 		{
// 			ReportCalibResult(TRUE);
// 
// 			m_bStatusBar = TRUE;
// 			m_strStatusBarInfo1 = _T("标定轴移动拍照验证完成");
// 			m_strStatusBarInfo2 = _T("");
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
// 		}
// 		else
// 		{
// 			ReportCalibResult(TRUE);
// 			m_bStatusBar = TRUE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_SUCCEED);
// 			m_strStatusBarInfo2 = _T("");
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
// 		}
// 	}
// 	else
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		if (!m_boIsSnapImgSucceed)
// 		{
// 			m_strStatusBarInfo2 = m_strSnapImgStatuString;
// 		}
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 	}
// 
// 	// 平台为触发模式时，标定完成后恢复触发模式
// 	if (sysPlatformInfo.m_bCameraHardTriggerMode)
// 	{
// 		SetCameraTriggerMode(ePTHardwareTrigger);
// 	}
// 
// 	return bSucceed;
// }

BOOL vcXYDVisionAlign::CheckCalibratePreparation(CString strCmd, int nCalibPos, int nMarkType)
{
	CString strTempWarningType = _T("");

	if (!CheckVisionASMConfig(strCmd) || !CheckPlatformInfo(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		return FALSE;
	}

	// 通信是否正常
	if (FALSE == m_bValidComm)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE; 
	}

	// 标定用定位工具是否正常 
	if (m_bValidCalibSearchTool!=TRUE)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_SEARCHTOOLINVALID);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	// 相机是否处于连续采集状态
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	for(int i = 0; i < nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);

			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}
	}

	BOOL bFlag;
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	if (!sysPlatformInfo.m_bEnableMultiCalibExtension)
	{
		bFlag = (nCalibPos >= sysPlatformInfo.m_nPositionNum);
	}
	else
	{
		int nExPosNum = sysPlatformInfo.m_nPositionNum*(sysPlatformInfo.m_nMultiCalibExtensionMaxNum+1);
		bFlag = (nCalibPos >= nExPosNum);
	}

	if(nCalibPos < 0 || bFlag)
	{
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSITIONERR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}		

	return TRUE;
}


BOOL vcXYDVisionAlign::CheckVisionASMConfig(CString strCmd)
{
	CString strTempWarningType = _T("");

	if (NULL == m_pVisionASMConfig)
	{		
		if (strCmd == _T(""))
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_CONFIG);
			m_strStatusBarInfo2 = _T("");
		}
		else
		{
			m_strStatusBarInfo1 = GetCmdWarningString(strCmd);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_CONFIG);
		}

		m_bStatusBar = FALSE;
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CheckPlatformInfo(CString strCmd)
{
	CString strTempWarningType = _T("");

	if (NULL == m_pPlatformInfo)
	{
		if (strCmd == _T(""))
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_CONFIG);
			m_strStatusBarInfo2 = _T("");
		}
		else
		{
			m_strStatusBarInfo1 = GetCmdWarningString(strCmd);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_CONFIG);
		}

		m_bStatusBar = FALSE;
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CheckCommuciation(CString strCmd)
{
	CString strTempWarningType = _T("");
	if (NULL == m_pComm)
	{
		m_bStatusBar = FALSE;
		if (strCmd == _T(""))
		{
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_CONFIG);
			m_strStatusBarInfo2 = _T("");
		}
		else
		{
			m_strStatusBarInfo1 = GetCmdWarningString(strCmd);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_CONFIG);
		}
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CheckCommuciationValid(CString strCmd)
{
	CString strTempWarningType = _T("");

	if (FALSE == m_bValidComm)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CheckAlignerSearchTool(CString strCmd)
{
	CString strTempWarningType = _T("");
	if (NULL == m_pAlignerTool)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CheckObjectSearchTool(CString strCmd)
{
	CString strTempWarningType = _T("");
	if (m_bValidObjectSearchTool != TRUE)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CheckTargetSearchTool(CString strCmd)
{
	CString strTempWarningType = _T("");
	if (m_bValidTargetSearchTool != TRUE)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::CheckInspectSearchTool(CString strCmd)
{
	CString strTempWarningType = _T("");
	if (m_bValidInspectSearchTool!=TRUE)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnFailedCameraExposureSetting(CString strCmd)
{
	CString strTempWarningType = _T("");
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1 = GetCmdWarningString(strCmd);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_EXPOSURESETTING_FAILED);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

	return FALSE;
}

BOOL vcXYDVisionAlign::OnFailedCommuciateGetPlatformAxisAbsPos(CString strCmd)
{
	CString strTempWarningType = _T("");
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1 = GetCmdWarningString(strCmd);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

	return FALSE;
}

BOOL vcXYDVisionAlign::OnFailedGetCalibPlatformAxisMovePos(CString strCmd)
{
	CString strTempWarningType = _T("");
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1 = GetCmdWarningString(strCmd);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_EIGHT_PLATFORM_POS_FAILED);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

	return FALSE;
}

BOOL vcXYDVisionAlign::OnFailedCommuciateDrivePlatformAxisMove(CString strCmd, int nPos)
{
	CString strTempWarningType = _T("");	
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1 = GetCmdWarningString(strCmd);
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), nPos) ;
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	return FALSE;
}

BOOL vcXYDVisionAlign::OnFailedSnapSearchImage(CString strCmd)
{
	CString strTempWarningType = _T("");
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1 = GetCmdWarningString(strCmd);
	m_strStatusBarInfo2 = m_strSnapImgStatuString;//GetSysInfoString(m_psaSysInfoStrings, IDS_SB_CAMERA_CONNECTION_ERROR);
	SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	return FALSE;
}

BOOL vcXYDVisionAlign::OnFailedCalibSearch(CString strCmd, int nMovePos, int nCalibPos)
{
	CString strTempWarningType = _T("");
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAM_MOVE_THEN_SEARCH_FAILED), nCalibPos);
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_MOVE_ROTATE_POS_SEARCH_FAILED), nMovePos); 
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	return FALSE;
}

BOOL vcXYDVisionAlign::OnFailedCommuciateGetCamPlatformAxisAbsPos(CString strCmd)
{
	CString strTempWarningType = _T("");
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_CAM_PLATFORM_POS_FAILED));
	m_strStatusBarInfo2 = _T("");
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
	return FALSE;
}

BOOL vcXYDVisionAlign::OnFailedCommuciateDriveCamPlatformAxisMove(CString strCmd, int nPos)
{
	CString strTempWarningType = _T("");
	ReportCalibResult(FALSE);
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_DRIVE_CAMERA_PLATFORM_TO_POS_FAILED), nPos);
	m_strStatusBarInfo2 = _T("");
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
	return FALSE;
}

BOOL vcXYDVisionAlign::OnFailedSetSameCalibrateInfo(CString strCmd)
{
	CString strTempWarningType = _T("");
	m_bStatusBar = FALSE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_COPY_POS_FAILED);
	SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	return FALSE;
}

// 单相机对位系统标定
// BOOL vcXYDVisionAlign::OnSingleCameraAlignerCalibratePick(int nCalibPos)
// {
// 	SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);
// 	int nMarkType = 1;
// 
// //	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
// //	{
// //		ReportCalibResult(FALSE);
// //		return FALSE;
// //	}
// //
// //	BOOL bFlag;
// //	if (!sysPlatformInfo.m_bEnableMultiCalibExtension)
// //	{
// //		bFlag = (nCalibPos >= sysPlatformInfo.m_nPositionNum);
// //	}
// //	else
// //	{
// //		int nExPosNum = sysPlatformInfo.m_nPositionNum*(sysPlatformInfo.m_nMultiCalibExtensionMaxNum+1);
// //		bFlag = (nCalibPos >= nExPosNum);
// //	}
// //
// //	if(nCalibPos < 0 || bFlag)
// //	{
// //		ReportCalibResult(FALSE);
// //		return FALSE;
// //	}
// 	CString strTempWarningType = _T("");
// 	CString strCmd = _T("VCLB:");
// 	GetCommCommandName(strCmd);
// 	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
// 	{
// 		ReportCalibResult(FALSE);
// 		return FALSE;
// 	}
// 	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;
// 	CPlatformOptionInfo optionInfo;
// 	GetPlatformOptionInfo(optionInfo);
// 	// 通信是否正常
// /*	if (FALSE == m_bValidComm)
// 	{
// 		ReportCalibResult(FALSE);
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE; 
// 	}
// 
// 	// 标定用定位工具是否正常 
// 	if (m_bValidCalibSearchTool!=TRUE)
// 	{
// 		ReportCalibResult(FALSE);
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE;
// 	}
// 
// 	// 相机是否处于连续采集状态
// 	int nCamNum = m_pPlatformInfo->m_nCamNum;
// 
// 	// 	if (nCamNum!=1)
// 	// 	{
// 	// 		ReportCalibResult(FALSE);
// 	// 		return FALSE;
// 	// 	}	
// 	int i=0;
// 	for(i=0; i<nCamNum; i++)
// 	{		 
// 		if (FALSE == m_vbCameraLiveGrab[i])
// 		{      
// 			ReportCalibResult(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
// 			m_strStatusBarInfo2 = _T("");
// 			PostMessageUpdateStatusBarInfo();
// 
// 			return FALSE;
// 		}    	
// 	}
// 
// 	// 对位标定工具是否正常
// 	if (m_bValidCalibSearchTool!=TRUE)
// 	{
// 		ReportCalibResult(FALSE);
// 		return FALSE;
// 	}
// */
// 	// 标定开始    
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
// 	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 	PostMessageUpdateStatusBarInfo();
// 
// 	int nCamPos = m_pPlatformInfo->m_nPositionNum;
// 	int i = 0;
// 
// 	{
// 		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
// 		if (SystempOptionSearchShutter && optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 		{
// 			int nPosNum = 1;
// 			std::vector<int> vnCalibPos;
// 			vnCalibPos.push_back(nRemCalibPos);
// 			std::vector<CameraExposureType> vsmCameraExposureType;
// 
// 			for(i = 0; i < nPosNum; i++)
// 			{
// 				vsmCameraExposureType.push_back(eDmCodeSearchCameraExposure);
// 			}
// 
// 			if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType))
// 			{
// 				//m_bStatusBar = FALSE;
// 				//m_strStatusBarInfo1 = _T("切换二维码曝光失败");
// 				//m_strStatusBarInfo2 = _T("");
// 				//SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 				//PostMessageUpdateStatusBarInfo();
// 				OnFailedCameraExposureSetting(strCmd);
// 			}
// 		}
// 	}
// 
// 	////GYM---标定日志目录
// 	sc2Vector CalibrateMoveRange;
// 	CalibrateMoveRange = sc2Vector(0,0);
// 	vector<CString> AnalysisResult;
// 	AnalysisResult.clear();
// 	CString strCalibLogPath;
// 
// 	// 默认D:\\VisionASMLog路径存在
// 	
// 	if (sysPlatformInfo.m_bProductFaChd)
// 	{
// 		int nCurProductIndexFa;
// 		int nCurProductIndexCh;
// 		m_pVisionASMConfig->m_TotalProductData.GetCurDlgProductIndex(nCurProductIndexFa,nCurProductIndexCh);
// 		strCalibLogPath.Format(_T("D:\\VisionASMLog\\工位%d_大品种%03d_小品种%03d_CalibrateLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 			nCurProductIndexFa+1,nCurProductIndexCh+1);
// 	}
// 	else
// 	{
// 		strCalibLogPath.Format(_T("D:\\VisionASMLog\\工位%d_品种%03d_CalibrateLog.txt"),sysPlatformInfo.m_nPlatformIndex+1,
// 			m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex()+1);
// 	}
// 	
// 	VisionAlignLogRecord(strCalibLogPath,_T(""),1);	// 标定日志开始记录
// 	// 标定参数记录
// 	CString StrCalibrate_Param = _T("");
// 	// 获取标定参数字符串
// 	CalibrateLogRecord_Param(nCalibPos,StrCalibrate_Param);
// 	// 写入日志
// 	VisionAlignLogRecord(strCalibLogPath,StrCalibrate_Param,FALSE);
// 	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
// 
// 	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
// 	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
// 	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
// 	if (m_bCmdParamAxisPosEanble)
// 	{
// 		bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
// 	}
// 	else
// 	{
// 		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
// 	}
// 
// 	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
// 	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
// 	{
// 		if (pPlatformAxisPos!=NULL)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;					
// 		}
// 
// 		ReportCalibResult(FALSE);
// 		return OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
// 		//m_bStatusBar = FALSE;
// 		//m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
// 		//m_strStatusBarInfo2 = _T("");
// 		//PostMessageUpdateStatusBarInfo();
// 
// 		//return FALSE;
// 	}
// 	else
// 	{
// 		SetCalibPlatformPos(pPlatformAxisPos);		
// 
// 		if (m_CalibPlatformAxisAbsPos.size()<nRemCalibPos+1)
// 		{
// 			m_CalibPlatformAxisAbsPos.resize(nRemCalibPos+1);
// 		}
// 		m_CalibPlatformAxisAbsPos.at(nRemCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 
// 		// 记录当前平台各个轴的绝对位置
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			CTime t = CTime::GetCurrentTime();
// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strInfo;
// 			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 			strInfo = strTemp + strInfo;
// 
// 			FILE *stream;
// 			CString strPath = m_strAlignProcessData;
// 			stream = fopen(strPath, _T("a+t"));
// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 			fclose(stream);VCRemoveFile(strPath);
// 
// 			/////GYM-标定日志记录
// 			strInfo.Format(_T(""));
// 			strTemp.Format(_T("平台标定时平台的绝对位置:\n"));
// 			strInfo += strTemp;
// 			strTemp.Format(_T("......X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"),pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 			strInfo += strTemp;
// 			VisionAlignLogRecord(strCalibLogPath,strInfo,FALSE);
// 			/////GYM
// 		}
// 
// 		if (pPlatformAxisPos)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;
// 		}
// 	}
// 
// 	//全局二维码靶标标定，计算图像坐标到靶标坐标之间的映射关系
// 	if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
// 	{
// 		if (!ExecuteCalibWholeDmCodeBoardImgToBoard(nCalibPos))
// 		{
// 			ReportCalibResult(FALSE);
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_WHOLE_CALIB_IMAGE_TO_BOARD_CALCU_ERROR);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 			return FALSE;
// 		}
// 	}
// 
// 	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
// 	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
// 	vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nRemCalibPos, nMarkType);
// 
// //	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType))
// 	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibCenterPlatformMovePosNum(nMarkType))
// 	{
// 		ReportCalibResult(FALSE);
// 		return OnFailedGetCalibPlatformAxisMovePos(strCmd);
// 		//m_bStatusBar = FALSE;
// 		//m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_EIGHT_PLATFORM_POS_FAILED);
// 		//m_strStatusBarInfo2 = _T("");
// 		//PostMessageUpdateStatusBarInfo();
// 
// 		//return FALSE;
// 	}
// 	else
// 	{
// 		// GYM-标定日志记录
// 		CString strInfo = _T("");
// 		CString strTemp = _T("");
// 		strTemp.Format(_T("平台标定XY时所需要移动的绝对轴位置:\n"));
// 		strInfo += strTemp;
// 		CPlatformXYDAxisPos* pAxisPos;
// 		for (int i=0; i<vpPlatformAxisPos.size(); i++)
// 		{
// 			strTemp.Empty();
// 			pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
// 			strTemp.Format(_T("......平台位置%d: X轴: %.3f; Y轴: %.3f; D轴: %.3f;\n"), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
// 			strInfo = strInfo + strTemp;
// 
// 		}
// 		VisionAlignLogRecord(strCalibLogPath,strInfo,FALSE);
// 		// GYM
// 
// 		// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			CTime t = CTime::GetCurrentTime();
// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strInfo;
// 			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
// 			strInfo = strTemp + strInfo;
// 
// 			CPlatformXYDAxisPos* pAxisPos;
// 			for (int i=0; i<vpPlatformAxisPos.size(); i++)
// 			{
// 				strTemp.Empty();
// 				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
// 
// 				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
// 				strInfo = strInfo + strTemp;
// 			}
// 
// 			FILE *stream;
// 			CString strPath = m_strAlignProcessData;
// 			stream = fopen(strPath, _T("a+t"));
// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 			fclose(stream);VCRemoveFile(strPath);				
// 		}
// 	}
// 
// 	// 3. 驱动平台到位并定位
// 	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
// 	std::vector<CMarkImagePos*> vpMarkImagePos;	
// 	CMarkImagePos* pMarkImagePos = NULL;
// 	CMarkImagePos* pDisCorMarkImagePos = NULL;
// 
// 	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
// 	if (pCalibData == NULL || !pCalibData->IsValid())
// 	{
// 		ReportCalibResult(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// 	CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
// 	if (pCalibrateParam == NULL)
// 	{
// 		ReportCalibResult(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// 
// 	int k=0;
// 	//	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum() - 1; k++)
// 	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType); k++)
// 	{         
// 		EnterCriticalSection(&m_csResource);
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 		PostMessageUpdateStatusBarInfo();
// 		LeaveCriticalSection(&m_csResource);
// 
// 		pMarkImagePos = NULL;
// 
// 		pDisCorMarkImagePos = NULL;
// 
// 		// 驱动到位
// 		pPlatformXYDAxisPos = NULL;
// 		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);
// 
// 		// 		if (k >8) //九点拍摄完成后，旋转部分运动
// 		// 		{
// 		// 			if(FALSE == CommuciateDrivePlatformAxisMovePick(pPlatformXYDAxisPos))
// 		// 			{
// 		// 				ReportCalibResult(FALSE);
// 		// 
// 		// 				m_bStatusBar = FALSE;
// 		// 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), k) ;
// 		// 				m_strStatusBarInfo2 = _T("");
// 		// 				PostMessageUpdateStatusBarInfo();
// 		// 
// 		// 				return FALSE;
// 		// 			}
// 		// 		}
// 		// 		else
// 		{
// 			if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
// 			{
// 				ReportCalibResult(FALSE);
// 				return OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);
// 				//m_bStatusBar = FALSE;
// 				//m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), k) ;
// 				//m_strStatusBarInfo2 = _T("");
// 				//PostMessageUpdateStatusBarInfo();
// 
// 				//return FALSE;
// 			}
// 		}
// 
// 
// 
// 
// 		Sleep(100);
// 		// 将相机移动到多个位置，逐个定位
// 		pMarkImagePos = new CMarkImagePos;
// 		pMarkImagePos->SetMarkImagePosNum(1);
// 
// 		pDisCorMarkImagePos = new CMarkImagePos;
// 		pDisCorMarkImagePos->SetMarkImagePosNum(1);
// 
// 		//for (int n=0; n<nCamPos; n++)
// 		{
// 
// 
// 			// 			if (nCamNum==1)
// 			// 			{
// 			// 				// 调整该单相机的回调参数索引
// 			// 				m_vpCamera.at(0)->Freeze();
// 			// 				m_vpCamOwner.at(0)->m_nCamIndex = nCalibPos;
// 			// 				m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 			// 				m_vpCamera.at(0)->Grab();
// 			// 			}
// 
// 			// 等待搜索延时
// 			int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 			Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);
// 
// 			// 准备开始定位			
// 			std::vector<int> vnPosIndex;
// 			std::vector<SearchMode> vsmSearchMode;	
// 			vnPosIndex.push_back(nRemCalibPos);		// nCalibPos	
// 			vsmSearchMode.push_back(eCalibSearch);	// 标定搜索
// 
// 			// 采集搜索图像
// 			if (!SnapSearchImage(vnPosIndex))
// 			{
// 				ReportCalibResult(FALSE);
// 
// 				if (pMarkImagePos!=NULL)
// 				{
// 					delete pMarkImagePos;
// 					pMarkImagePos = NULL;
// 				}
// 
// 				if(pDisCorMarkImagePos != NULL)
// 				{
// 					delete pDisCorMarkImagePos;
// 					pDisCorMarkImagePos = NULL;
// 				}
// 
// 				// 				for (int p=0; p<vpMarkImagePos.size(); p++)
// 				// 				{
// 				// 					if (vpMarkImagePos.at(p))
// 				// 					{
// 				// 						delete vpMarkImagePos.at(p);
// 				// 						vpMarkImagePos.at(p) = NULL;
// 				// 					}
// 				// 				}  
// 				return OnFailedSnapSearchImage(strCmd);
// 				//m_bStatusBar = FALSE;
// 				//m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// 				//m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// 				//PostMessageUpdateStatusBarInfo();
// 
// 				//return FALSE;
// 			}
// 
// 			// 定位
// 			m_vnCalibSearchStartPatIndex[nRemCalibPos] = 0;
// 			m_vnCalibSearchEndPatIndex[nRemCalibPos] = 0;
// 			if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 			{
// 				if (k==0)
// 				{
// 					m_bIsFirstCalibPos = TRUE;
// 				}
// 				else
// 				{
// 					m_bIsFirstCalibPos = FALSE;
// 				}
// 			}
// 			BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
// 			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
// 			{
// 				//PostMessageSaveVDBFile(vnPosIndex,eCalibSearch);
// 				ExeSaveVDBFile(vnPosIndex,eCalibSearch);
// 			}
// 			// 分析定位结果，发送指令响应
// 			if (FALSE == bSearchSucceed)
// 			{
// 				ReportCalibResult(FALSE);
// 
// 				//m_bStatusBar = FALSE;
// 				//m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_MOVE_ROTATE_POS_SEARCH_FAILED), k);
// 				//m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAM_MOVE_THEN_SEARCH_FAILED), nCalibPos); 
// 				//PostMessageUpdateStatusBarInfo();
// 
// 				if (pMarkImagePos!=NULL)
// 				{
// 					delete pMarkImagePos;
// 					pMarkImagePos = NULL;
// 				}
// 
// 				if(pDisCorMarkImagePos != NULL)
// 				{
// 					delete pDisCorMarkImagePos;
// 					pDisCorMarkImagePos = NULL;
// 				}
// 
// 				// 				for (int p=0; p<vpMarkImagePos.size(); p++)
// 				// 				{
// 				// 					if (vpMarkImagePos.at(p))
// 				// 					{
// 				// 						delete vpMarkImagePos.at(p);
// 				// 						vpMarkImagePos.at(p) = NULL;
// 				// 					}
// 				// 				}  
// 				//return FALSE;
// 				return OnFailedCalibSearch(strCmd, k, nCalibPos);
// 			}
// 
// 			if(pCalibrateParam->m_nEnableDisCor)
// 			{
// 				CCoordPos OutPutPoint;
// 				m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
// 				pDisCorMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
// 			}
// 
// 			// 保存定位结果		
// 			pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	
// 
// 		}
// 
// 		if(pCalibrateParam->m_nEnableDisCor)
// 		{
// 			CMarkImagePos * markpos = new CMarkImagePos(*pDisCorMarkImagePos);
// 			vpMarkImagePos.push_back(markpos); 
// 		}
// 		else
// 		{
// 			CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
// 
// 			// 		if (m_vpMarkImagePos.at(k)!=NULL)
// 			// 		{
// 			// 			delete m_vpMarkImagePos.at(k);
// 			// 			m_vpMarkImagePos.at(k)=NULL;			
// 			// 		}
// 			// 		m_vpMarkImagePos.at(k) =markpos;
// 			vpMarkImagePos.push_back(markpos); 
// 		}
// 
// 		// GYM-标定日志记录-平台标定时图像坐标
// 		{
// 			CString strOut = _T("");		
// 			CString strTemp = _T("");	
// 			strOut.Empty();
// 			strTemp.Empty();
// 			strTemp.Format(_T("平台标定XY时图像坐标:\n"));
// 			strOut += strTemp;
// 			for (int i=0; i<vpMarkImagePos.size(); i++)
// 			{
// 				strTemp.Empty();
// 				CCoordPos cp;
// 				cp = vpMarkImagePos.at(i)->GetMarkImagePos(0);
// 				strTemp.Format(_T("......MarkPos%d: X: %.2f; Y: %.2f; D: %.3f;\n"), i, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 				strOut += strTemp;
// 
// 			}
// 			VisionAlignLogRecord(strCalibLogPath,strOut, FALSE);
// 		}
// 		//GYM
// 
// 		//// GYM-标定日志记录-图像坐标分析
// 		//CString strOut = _T("");	
// 		//CalibrateLogRecord_ImagePos(nCalibPos,nMarkType,vpMarkImagePos,strOut,AnalysisResult,CalibrateMoveRange);
// 		//VisionAlignLogRecord(strCalibLogPath,strOut, FALSE);
// 		//// GYM
// 
// 		// 记录图像搜索数据
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			CTime t = CTime::GetCurrentTime();
// 			strTemp.Format(_T("\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strOut;
// 			CCoordPos cp;
// 			strOut = strTemp + _T("CalibSearch: ");		
// 			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
// 			{
// 				strTemp = _T("");
// 				cp = pMarkImagePos->GetMarkImagePos(i);
// 
// 				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 				strOut += strTemp;
// 			}
// 
// 			if(pCalibrateParam->m_nEnableDisCor)
// 			{
// 				for (int i=0; i<pDisCorMarkImagePos->GetMarkImagePosNum(); i++)
// 				{
// 					strTemp = _T("");
// 					cp = pDisCorMarkImagePos->GetMarkImagePos(i);
// 
// 					strTemp.Format(_T("DisCorMarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 					strOut += strTemp;
// 				}
// 			}
// 
// 			FILE *stream;
// 			CString strPath = m_strAlignProcessData;
// 			stream = fopen(strPath, _T("a+t"));               
// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
// 			fclose(stream);VCRemoveFile(strPath);
// 		}	
// 
// 		if (pMarkImagePos!=NULL)
// 		{
// 			delete pMarkImagePos;
// 			pMarkImagePos = NULL;
// 		}     
// 
// 		if(pDisCorMarkImagePos != NULL)
// 		{
// 			delete pDisCorMarkImagePos;
// 			pDisCorMarkImagePos = NULL;
// 		}
// 	}    	
// 	if (pMarkImagePos!=NULL)
// 	{
// 		delete pMarkImagePos;
// 		pMarkImagePos = NULL;
// 	}     
// 
// 	if(pDisCorMarkImagePos != NULL)
// 	{
// 		delete pDisCorMarkImagePos;
// 		pDisCorMarkImagePos = NULL;
// 	}
// 
// 	// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具
// 	// 全局二维码靶标标定，计算靶标坐标到平台坐标的旋转缩放关系
// 	if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
// 	{
// 		if(FALSE == ExecuteCalibrateWholeDmcodeBoardBoardToPlat(vpMarkImagePos,nCalibPos,nMarkType))
// 		{		
// 			ReportCalibResult(FALSE);		
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_DMCODETOPLATFORMCALCU_FAILED);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 
// 			for (k=0; k<vpMarkImagePos.size(); k++)
// 			{
// 				if (vpMarkImagePos.at(k))
// 				{
// 					delete vpMarkImagePos.at(k);
// 					vpMarkImagePos.at(k) = NULL;
// 				}
// 			} 
// 
// 			SaveCurAllCameraChannelSearchImg();		
// 			return FALSE;
// 		}
// 		// 5. 释放内存
// 		for (k=0; k<vpMarkImagePos.size(); k++)
// 		{
// 			if (vpMarkImagePos.at(k))
// 			{
// 				delete vpMarkImagePos.at(k);
// 				vpMarkImagePos.at(k) = NULL;
// 			}
// 		} 
// 
// 	}
// 	else
// 	{
// 		if(FALSE == ExecuteCalibrate(vpMarkImagePos/*m_vpMarkImagePos*/,nCalibPos,nMarkType))
// 		{
// 			ReportCalibResult(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 
// 			for (k=0; k<vpMarkImagePos.size(); k++)
// 			{
// 				if (vpMarkImagePos.at(k))
// 				{
// 					delete vpMarkImagePos.at(k);
// 					vpMarkImagePos.at(k) = NULL;
// 				}
// 			} 
// 
// 			SaveCurAllCameraChannelSearchImg();		
// 			return FALSE;
// 		}
// 		// 5. 释放内存
// 		for (k=0; k<vpMarkImagePos.size(); k++)
// 		{
// 			if (vpMarkImagePos.at(k))
// 			{
// 				delete vpMarkImagePos.at(k);
// 				vpMarkImagePos.at(k) = NULL;
// 			}
// 		}   
// 
// 		/////////////////////////////////////// 平台标定求精//////////////////////////////////////////
// 		// 
// 		// 	// 驱动该平台到达基准位置   
// 		// 	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(11);	
// 		// 	if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
// 		// 	{		
// 		// 		ReportCalibResult(FALSE);
// 		// 
// 		// 		m_bStatusBar = FALSE;
// 		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_TO_BENCH_POS_FAILED);
// 		// 		m_strStatusBarInfo2 = _T("");	
// 		// 		PostMessageUpdateStatusBarInfo();
// 		// 
// 		// 		SaveCurAllCameraChannelSearchImg();
// 		// 		return FALSE;
// 		// 	}
// 
// 
// 		// 判断是否需要进行平台标定求精，若是，则对单个相机进行平台标定求精
// 		//
// 		// 	SysPlatformInfo sysPlatformInfo;
// 		// 	GetSysPlatformInfo(sysPlatformInfo);
// 		// 	if (ePlatformXD == sysPlatformInfo.m_eMidPlatformType)
// 		// 	{
// 		// 	}
// 		// 	else if (ePlatformYD == sysPlatformInfo.m_eMidPlatformType)
// 		// 	{
// 		// 	}
// 		// 	else
// 		// 	{
// 		// 		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 		// 		int nCalibRefineTime = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nCalibPos]->GetPlatformCalibRefineTime();
// 		// 
// 		// 		for (i = 0; i < nCalibRefineTime; i++)
// 		// 		{
// 		// 			if (FALSE == ExcutePlatformCalibrateRefine(nCalibPos))
// 		// 			{
// 		// 				ReportCalibResult(FALSE);
// 		// 
// 		// 				m_bStatusBar = FALSE;
// 		// 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_BENCH_POS_CALIB_REFINE_FAILED), nCalibPos);
// 		// 				m_strStatusBarInfo2 = _T("");
// 		// 				PostMessageUpdateStatusBarInfo();
// 		// 
// 		// 				SaveCurAllCameraChannelSearchImg();
// 		// 				return FALSE;
// 		// 			}
// 		// 		}
// 		// 	}
// 
// 
// 		// 	// 判断是否需要进行平台标定求精，若是，则对单个相机进行平台标定求精
// 		// 	if (TRUE == IsExcutePlatformCalibrateRefine())
// 		// 	{
// 		// 		//	for (int n=0; n<nCamPos; n++)
// 		// 		{              
// 		// 			if (FALSE == ExcutePlatformCalibrateRefine(nCalibPos))
// 		// 			{
// 		// 				ReportCalibResult(FALSE);
// 		// 
// 		// 				m_bStatusBar = FALSE;
// 		// 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_BENCH_POS_CALIB_REFINE_FAILED), nCalibPos);
// 		// 				m_strStatusBarInfo2 = _T("");
// 		// 				PostMessageUpdateStatusBarInfo();
// 		// 
// 		// 				SaveCurAllCameraChannelSearchImg();
// 		// 				return FALSE;
// 		// 			}
// 		// 		}
// 		// 	}
// 
// 		//////////////////////////////////////// 相机标定/////////////////////////////////////////////
// 
// 
// 		// 所有相机平台同时进行相机平台标定
// 		switch (m_pPlatformInfo->m_eCamPlatformType)
// 		{
// 		case eCamPlatformSepFix:
// 			break;
// 		case eCamPlatformSepX:
// 		case eCamPlatformSepXY:
// 			{
// 				std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
// 				CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;
// 
// 				for(i=0; i<nCamPos; i++)
// 				{
// 					pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
// 					vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);		
// 				}
// 
// 				// 1. 通信获取相机平台各个基准位置, 并设置入对位工具
// 				std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPosTemp; 
// 				for (i=0; i<nCamPos; i++)
// 				{
// 					// 等待相机移动到位
// 					if (FALSE == CommuciateWaitCamMove())
// 					{           
// 						ReportCalibResult(FALSE);
// 
// 						m_bStatusBar = FALSE;
// 						m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_WAIT_CAMERA_ARRIVED), i);
// 						m_strStatusBarInfo2 = _T("");
// 						PostMessageUpdateStatusBarInfo();
// 						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 						// 释放内存
// 						for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 						{
// 							if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 							{
// 								delete vpCamPlatformXYAxisPos.at(i);
// 								vpCamPlatformXYAxisPos.at(i) = NULL;
// 							}
// 						}
// 						SaveCurAllCameraChannelSearchImg();
// 						return FALSE;
// 					}
// 
// 					vpCamPlatformXYAxisPosTemp.clear();
// 					vpCamPlatformXYAxisPosTemp.push_back(vpCamPlatformXYAxisPos.at(i));
// 
// 					// 通信获取当前位置相机平台各轴的绝对位置
// 					if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPosTemp))
// 					{
// 						ReportCalibResult(FALSE);
// 
// 						//m_bStatusBar = FALSE;
// 						//m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_CAM_PLATFORM_POS_FAILED));
// 						//m_strStatusBarInfo2 = _T("");
// 						//PostMessageUpdateStatusBarInfo();
// 
// 						// 释放内存
// 						for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 						{
// 							if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 							{
// 								delete vpCamPlatformXYAxisPos.at(i);
// 								vpCamPlatformXYAxisPos.at(i) = NULL;
// 							}
// 						}
// 
// 						SaveCurAllCameraChannelSearchImg();
// 						//return FALSE;
// 						return OnFailedCommuciateGetCamPlatformAxisAbsPos(strCmd);
// 					}
// 					else
// 					{
// 						vpCamPlatformXYAxisPos.at(i) = vpCamPlatformXYAxisPosTemp.at(0);
// 					}
// 
// 				}
// 
// 				SetCalibCamPlatformPos(vpCamPlatformXYAxisPos);
// 
// 				// 记录当前相机平台各个轴的绝对位置
// 				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 				{
// 					CString strTemp;
// 					CTime t = CTime::GetCurrentTime();
// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 					CString strInfo;
// 					strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SINGLE_CAM_CALIB_ALL_BENCH_POS);
// 					strInfo = strTemp + strInfo;
// 
// 					for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 					{
// 						strTemp = _T("");
// 						strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
// 						strInfo = strInfo + strTemp;
// 					}
// 
// 					FILE *stream;
// 					CString strPath = m_strAlignProcessData;
// 					stream = fopen(strPath, _T("a+t"));
// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 					fclose(stream);VCRemoveFile(strPath);				
// 				}		
// 
// 				// 2. 获取相机平台标定时，各个基准位置处相机平台要移动的绝对位置
// 				std::vector< std::vector<CPlatformXYAxisPos*> > vppCameraMoveAxisPos;
// 				std::vector<CPlatformXYAxisPos*> vpCameraMoveAxisPos;
// 				int nPos = 0;
// 
// 				for (i=0; i<nCamPos; i++)
// 				{
// 					vpCameraMoveAxisPos.clear();
// 					GetCalibCamPlatformMovePos(i, vpCameraMoveAxisPos);
// 					vppCameraMoveAxisPos.push_back(vpCameraMoveAxisPos);
// 
// 					nPos = vpCameraMoveAxisPos.size();
// 				}
// 
// 				// 3. 单个相机平台在各个位置同时进行标定
// 				std::vector<CPlatformXYAxisPos*> vpAllCameraMoveAbsInThisPos;
// 				std::vector<CMarkImagePos*> vpAllCalibCameraSearchResult;
// 				std::vector<CPlatformXYAxisPos*> vpTemp;
// 				CMarkImagePos* pTemMarkImagePos = NULL;
// 				CMarkImagePos* pDisCorTemMarkImagePos = NULL;
// 
// 				int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 				CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
// 				if (pCalibData == NULL || !pCalibData->IsValid())
// 				{
// 					ReportCalibResult(FALSE);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					return FALSE;
// 				}
// 				CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
// 				if (pCalibrateParam == NULL)
// 				{
// 					ReportCalibResult(FALSE);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					return FALSE;
// 				}
// 
// 				vpAllCalibCameraSearchResult.clear();
// 
// 				for (int n=0; n<nPos; n++)
// 				{
// 					vpAllCameraMoveAbsInThisPos.clear();
// 
// 					// 获取各个相机在第n次移动时所对应的绝对位置
// 					for (k=0; k<nCamPos; k++)
// 					{
// 						vpAllCameraMoveAbsInThisPos.push_back(vppCameraMoveAxisPos[k].at(n));
// 					}					
// 
// 					pTemMarkImagePos = new CMarkImagePos;
// 					pTemMarkImagePos->SetMarkImagePosNum(nCamPos);
// 
// 					pDisCorTemMarkImagePos = new CMarkImagePos;
// 					pDisCorTemMarkImagePos->SetMarkImagePosNum(nCamPos);
// 
// 					for (k=0; k<nCamPos; k++)
// 					{
// 						vpTemp.clear();
// 						vpTemp.push_back(vpAllCameraMoveAbsInThisPos.at(k));
// 
// 						// 通信驱动相机平台移动到指定位置
// 						if (FALSE == CommuciateDriveCamPlatformAxisMove(vpTemp))
// 						{
// 							ReportCalibResult(FALSE);
// 
// 							//m_bStatusBar = FALSE;
// 							//m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_DRIVE_CAMERA_PLATFORM_TO_POS_FAILED), k);
// 							//m_strStatusBarInfo2 = _T("");
// 							//PostMessageUpdateStatusBarInfo();
// 
// 							// 释放内存
// 							for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 							{
// 								if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 								{
// 									delete vpCamPlatformXYAxisPos.at(i);
// 									vpCamPlatformXYAxisPos.at(i) = NULL;
// 								}
// 							}
// 
// 							//return FALSE;
// 							return OnFailedCommuciateDriveCamPlatformAxisMove(strCmd, k);
// 						}
// 
// 						if (4 == n)
// 						{
// 							continue;
// 						}
// 
// 						// 调整该单相机的回调参数索引
// 						m_vpCamera.at(0)->Freeze();
// 						m_vpCamOwner.at(0)->m_nCamIndex = k;
// 						m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 						m_vpCamera.at(0)->Grab();
// 
// 						// 开启定位		
// 						// 					m_vbSearchSucceed[k]  = FALSE;
// 						// 					m_vbSearchFinished[k] = FALSE;	
// 						// 
// 						// 					StartSearch(eCalibSearch);
// 
// 						int nCameraIndex = k;
// 						std::vector<int> vCamIndex;
// 						std::vector<SearchMode> vsmSearchMode;
// 
// 						vCamIndex.push_back(nCameraIndex);
// 						vsmSearchMode.push_back(eCalibSearch);
// 
// 						StartSearch(vCamIndex,vsmSearchMode);
// 
// 						// 等待定位结束		
// 						while (FALSE == m_vbSearchFinished[k])
// 						{					
// 							// 等待定位结束时判断各相机是否在线，避免相机掉线后出现死循环
// 							if (!m_vpCamera.at(0)->IsOnline())
// 							{
// 								//CloseSearch();
// 								CloseSearch(vCamIndex);
// 								m_bStatusBar = FALSE;
// 								m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// 								m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// 								PostMessageUpdateStatusBarInfo();
// 								strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
// 								AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 								return FALSE;
// 							}
// 							Sleep(10);
// 						}
// 
// 						// 分析定位结果，发送指令响应
// 						BOOL bSearchSucceed = FALSE;
// 
// 						bSearchSucceed = m_vbSearchSucceed[k];
// 
// 						if (FALSE == bSearchSucceed)
// 						{
// 							ReportCalibResult(FALSE);
// 
// 							m_bStatusBar = FALSE;
// 							m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_PLATFORM_POS_CALIB_SEARCH_FAILED), k);
// 							m_strStatusBarInfo2 = _T("");
// 							PostMessageUpdateStatusBarInfo();
// 							strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
// 							AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 							if (pTemMarkImagePos!=NULL)
// 							{
// 								delete pTemMarkImagePos;
// 								pTemMarkImagePos = NULL;
// 							}
// 
// 							if(pDisCorTemMarkImagePos != NULL)
// 							{
// 								delete pDisCorTemMarkImagePos;
// 								pDisCorTemMarkImagePos = NULL;
// 							}
// 
// 							for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 							{
// 								if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 								{
// 									delete vpCamPlatformXYAxisPos.at(i);
// 									vpCamPlatformXYAxisPos.at(i) = NULL;
// 								}
// 							}
// 
// 							// 关闭定位
// 							// CloseSearch();
// 							CloseSearch(vCamIndex);
// 							// 恢复该单相机的回调参数索引
// 							m_vpCamera.at(0)->Freeze();
// 							m_vpCamOwner.at(0)->m_nCamIndex = 0;
// 							m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 							m_vpCamera.at(0)->Grab();
// 
// 							return FALSE;
// 						}
// 
// 						// 关闭定位
// 						// CloseSearch();			
// 						CloseSearch(vCamIndex);		
// 						// 暂存定位结果
// 
// 						if(pCalibrateParam->m_nEnableDisCor)
// 						{
// 							CCoordPos OutPutPoint;
// 							m_pAlignerTool->ExecuteDisCorPoint(k, m_mpCalibMarkImagePos.GetMarkImagePos(k), OutPutPoint);	// 此处k含义待确认
// 							pDisCorTemMarkImagePos->SetMarkImagePos(k, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(k), OutPutPoint);
// 						}
// 
// 						pTemMarkImagePos->SetMarkImagePos(k, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(k), m_mpCalibMarkImagePos.GetMarkImagePos(k));
// 
// 					} 	
// 
// 					// 恢复该单相机的回调参数索引
// 					m_vpCamera.at(0)->Freeze();
// 					m_vpCamOwner.at(0)->m_nCamIndex = 0;
// 					m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0),GrabImageFinishedCallback);
// 					m_vpCamera.at(0)->Grab();
// 
// 					if(pCalibrateParam->m_nEnableDisCor)
// 					{
// 						vpAllCalibCameraSearchResult.push_back(pDisCorTemMarkImagePos);
// 					}
// 					else
// 					{
// 						vpAllCalibCameraSearchResult.push_back(pTemMarkImagePos);
// 					}
// 
// 					// 记录当前相机平台各个轴的绝对位置
// 					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 					{
// 						CString strTemp;
// 						CTime t = CTime::GetCurrentTime();
// 						strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 						CString strInfo;
// 						strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CALIB_CAM_PLATFORM_CERTAIN_POS), n);
// 						strInfo = strTemp + strInfo;
// 
// 						for (int i=0; i<vpAllCameraMoveAbsInThisPos.size(); i++)
// 						{
// 							strTemp = _T("");
// 							strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpAllCameraMoveAbsInThisPos.at(i)->m_dPosX, vpAllCameraMoveAbsInThisPos.at(i)->m_dPosY);
// 							strInfo = strInfo + strTemp;
// 						}
// 
// 						FILE *stream;
// 						CString strPath = m_strAlignProcessData;
// 						stream = fopen(strPath, _T("a+t"));
// 						fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 						fclose(stream);VCRemoveFile(strPath);				
// 					}
// 
// 					// 记录图像搜索数据
// 					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 					{
// 						CString strTemp;
// 						CTime t = CTime::GetCurrentTime();
// 						strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 						CString strOut;
// 						CCoordPos cp;
// 						strOut = strTemp + _T("CalibSearch: ");	
// 						if (pTemMarkImagePos)
// 						{
// 							for (int i=0; i<pTemMarkImagePos->GetMarkImagePosNum(); i++)
// 							{
// 								strTemp = _T("");
// 								cp = pTemMarkImagePos->GetMarkImagePos(i);
// 
// 								strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
// 
// 								strOut += strTemp;
// 							}			
// 						}
// 
// 						if(pCalibrateParam->m_nEnableDisCor)
// 						{
// 							if(pDisCorTemMarkImagePos)
// 							{
// 								for (int i=0; i<pDisCorTemMarkImagePos->GetMarkImagePosNum(); i++)
// 								{
// 									strTemp = _T("");
// 									cp = pDisCorTemMarkImagePos->GetMarkImagePos(i);
// 
// 									strTemp.Format(_T("DisCorMarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
// 
// 									strOut += strTemp;
// 								}	
// 							}
// 						}
// 
// 						FILE *stream;
// 						CString strPath = m_strAlignProcessData;
// 						stream = fopen(strPath, _T("a+t"));               
// 						fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
// 						fclose(stream);VCRemoveFile(strPath);
// 					}
// 
// 				}            
// 
// 				// 4. 将所有相机平台的所有定位结果设置入对位工具
// 				if(vpAllCalibCameraSearchResult.size() <= 0 ) 
// 				{
// 					ReportCalibResult(FALSE);
// 
// 					// 释放内存
// 					for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 					{
// 						if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 						{
// 							delete vpCamPlatformXYAxisPos.at(i);
// 							vpCamPlatformXYAxisPos.at(i) = NULL;
// 						}
// 					}
// 
// 					SaveCurAllCameraChannelSearchImg();
// 					return FALSE;
// 				}
// 				else
// 				{
// 					SetCalibCameraMoveSearchResult(vpAllCalibCameraSearchResult); 
// 				}	
// 
// 				// 5. 执行相机平台的标定计算
// 				if(FALSE == ExecuteCamPlatformCalibrate())
// 				{
// 					ReportCalibResult(FALSE);
// 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CAM_PLATFORM_CALCULATE_FAILED);
// 					m_strStatusBarInfo2 = _T("");
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 					// 释放内存
// 					for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 					{
// 						if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 						{
// 							delete vpCamPlatformXYAxisPos.at(i);
// 							vpCamPlatformXYAxisPos.at(i) = NULL;
// 						}
// 					}
// 
// 					SaveCurAllCameraChannelSearchImg();
// 					return FALSE;
// 				}
// 
// 
// 				// 释放内存
// 				for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 				{
// 					if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 					{
// 						delete vpCamPlatformXYAxisPos.at(i);
// 						vpCamPlatformXYAxisPos.at(i) = NULL;
// 					}
// 				}
// 			}
// 			break;
// 		case eCamPlatformShareX:
// 			break;
// 		default:
// 			break;				
// 		}
// 	}
// 
// 	//////////////////////////////////////// 获取标定结果///////////////////////////////////////////
// 
// 	// 获取系统标定后的所有信息
// 	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 	vpAllCalibratedInfo = GetAllCalibratedInfo();
// 
// 	
// 	if(optionInfo.m_bAutoCopyCalibData)
// 	{
// 		//复制标定
// 		int nExProductIdx = nCalibPos/GetPosNum();
// 		ExecuteCopyCalibrateData(1,nExProductIdx);
// 	}
// 	else
// 	{
// 		/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 		SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 		// 保存标定后信息到当前产品中及配置文件中
// 		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 	}
// 
// 
// 	// 保存目标定位结果信息
// 	m_bTargetMarkSearchSucceed = FALSE;	
// 	m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
// 	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
// 	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
// 
// 	// 保存标定后信息到
// 
// 	return TRUE;
// }


// 接收命令后，调用该函数，里面需要做一些额外的判断
BOOL vcXYDVisionAlign::OnlineFCBPCalibrate(int nCalibPos, int nMarkType,int nExProductIndex/*=0*/)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CString strCmd = _T("VCBP:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{

		ReportCalibResultFCBP(FALSE);

		return FALSE;
	}

	// 平台为触发模式，标定时需要设置为非触发模式
	if (sysPlatformInfo.m_bCameraHardTriggerMode)
	{
		SetCameraTriggerMode(ePTNotTrigger);
	}

	//AddAllGuiDmCodeGraphicsToDisplay();

	BOOL bSucceed = FALSE;

	// 执行标定
	switch(nMarkType)
	{
	case 0:
		{
			std::vector<int> vnPosIndex;
			if (nCalibPos>=0 && nCalibPos<GetPosNum())
			{
				vnPosIndex.push_back(nCalibPos);
			}
			else if(nCalibPos == 9)
			{
				for (int i=0;i<GetPosNum();i++)
				{
					vnPosIndex.push_back(i);
				}
			}
			else if(nCalibPos == 11)
			{
				for (int i=0;i<GetPosNum()/2;i++)
				{
					vnPosIndex.push_back(i);
				}
			}
			else if(nCalibPos == 12)
			{
				for (int i=0;i<GetPosNum()/2;i++)
				{
					vnPosIndex.push_back(i+GetPosNum()/2);
				}
			}
			else if(nCalibPos >= 19 && nCalibPos < 28)
			{
				if (GetPosNum() == 8)
				{
					switch(nCalibPos)
					{
					case 19:
						{
							for (int i=0;i<GetPosNum()/4;i++)
							{
								vnPosIndex.push_back(i);
							}
						}
						break;
					case 20:
						{
							for (int i=0;i<GetPosNum()/4;i++)
							{
								vnPosIndex.push_back(i+GetPosNum()/4);
							}
						}
						break;
					case 21:
						{
							vnPosIndex.push_back(0);
							vnPosIndex.push_back(2);
						}
						break;
					case 22:
						{
							vnPosIndex.push_back(1);
							vnPosIndex.push_back(3);
						}
						break;
					case 23:
						{
							for (int i=0;i<GetPosNum()/4;i++)
							{
								vnPosIndex.push_back(i+GetPosNum()/2);
							}
						}
						break;
					case 24:
						{
							for (int i=0;i<GetPosNum()/4;i++)
							{
								vnPosIndex.push_back(i+GetPosNum()/2+GetPosNum()/4);
							}
						}
						break;
					case 25:
						{
							vnPosIndex.push_back(4);
							vnPosIndex.push_back(6);
						}
						break;
					case 26:
						{
							vnPosIndex.push_back(5);
							vnPosIndex.push_back(7);
						}
						break;
					}
				}
				else
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_PARAMETER_ERROR);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					break;
				}

			}
			else if(nCalibPos >= 256)
			{
				nCalibPos = nCalibPos - 255;

				int nMask = 1;
				for (int i=0; i<GetPosNum(); i++)
				{
					int nMaskResult = nMask<<i;

					if ( (nCalibPos & nMaskResult) == nMaskResult )
					{
						vnPosIndex.push_back(i);
					}
				}
			}
			else
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_PARAMETER_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				break;

			}
			bSucceed = SerialCameraCalibAlignerTargetSearch(vnPosIndex); // 单相机关联搜索
		}
		break;
	case 1:
		{
			bSucceed = GetCalibAlignerTargetPlatformAxisPos();; // 获取关联基准轴位置
			m_bGetAutoCalibrateBaseAxisSucceed = bSucceed;
		}
		break;
	case 2:
		{
			bSucceed = ExecuteCalibrateTarget(nExProductIndex); 
		}
		break;
	default:
		break;
	}

	// 返回结果
	if (TRUE == bSucceed)
	{	

		ReportCalibResultFCBP(TRUE);
	}
	else
	{
		ReportCalibResultFCBP(FALSE);
	}

	// 平台为触发模式时，标定完成后恢复触发模式
	if (sysPlatformInfo.m_bCameraHardTriggerMode)
	{
		SetCameraTriggerMode(ePTHardwareTrigger);
	}

	return bSucceed;
}

// 单相机对位系统标定
// BOOL vcXYDVisionAlign::OnSingleCameraAlignerCalibrateCenterPick(int nCalibPos)
// {
// 	SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);
// 
// 	//if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
// 	//{
// 	//	ReportCalibResult(FALSE);
// 	//	return FALSE;
// 	//}
// 	CString strTempWarningType = _T("");
// 	CString strCmd = _T("VCLB:");
// 	GetCommCommandName(strCmd);
// 	int i = 0;
// 	int nMarkType = 0;
// 	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType))
// 	{
// 		ReportCalibResult(FALSE);
// 		return FALSE;
// 	}
// 
// 	BOOL bFlag;
// 	if (!sysPlatformInfo.m_bEnableMultiCalibExtension)
// 	{
// 		bFlag = (nCalibPos >= sysPlatformInfo.m_nPositionNum);
// 	}
// 	else
// 	{
// 		int nExPosNum = sysPlatformInfo.m_nPositionNum*(sysPlatformInfo.m_nMultiCalibExtensionMaxNum+1);
// 		bFlag = (nCalibPos >= nExPosNum);
// 	}
// 
// 	if(nCalibPos < 0 || bFlag)
// 	{
// 		ReportCalibResult(FALSE);
// 		return FALSE;
// 	}
// 
// 	int nRemCalibPos = nCalibPos%sysPlatformInfo.m_nPositionNum;
// 
// 	// 通信是否正常
// //	if (FALSE == m_bValidComm)
// //	{
// //		ReportCalibResult(FALSE);
// //
// //		m_bStatusBar = FALSE;
// //		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// //		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// //		PostMessageUpdateStatusBarInfo();
// //
// //		return FALSE; 
// //	}
// 
// 	// 标定用定位工具是否正常 
// //	if (m_bValidCalibSearchTool!=TRUE)
// //	{
// //		ReportCalibResult(FALSE);
// //
// //		m_bStatusBar = FALSE;
// //		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
// //		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// //		PostMessageUpdateStatusBarInfo();
// //
// //		return FALSE;
// //	}
// 
// 	// 相机是否处于连续采集状态
// 	int nCamNum = m_pPlatformInfo->m_nCamNum;
// 
// 	// 	if (nCamNum!=1)
// 	// 	{
// 	// 		ReportCalibResult(FALSE);
// 	// 		return FALSE;
// 	// 	}	
// //	int i=0;
// //	for(i=0; i<nCamNum; i++)
// //	{		 
// //		if (FALSE == m_vbCameraLiveGrab[i])
// //		{      
// //			ReportCalibResult(FALSE);
// //
// //			m_bStatusBar = FALSE;
// //			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
// //			m_strStatusBarInfo2 = _T("");
// //			PostMessageUpdateStatusBarInfo();
// //
// //			return FALSE;
// //		}    	
// //	}
// 
// 	// 对位标定工具是否正常
// //	if (m_bValidCalibSearchTool!=TRUE)
// //	{
// //		ReportCalibResult(FALSE);
// //		return FALSE;
// //	}
// 
// 	// 标定开始    
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_CALIBRATING);
// 	m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 	PostMessageUpdateStatusBarInfo();
// 
// 	int nCamPos = m_pPlatformInfo->m_nPositionNum;
// 	CPlatformOptionInfo optionInfo;
// 	GetPlatformOptionInfo(optionInfo);
// 	{
// 		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
// 		if (SystempOptionSearchShutter && optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 		{
// 			int nPosNum = 1;
// 			std::vector<int> vnCalibPos;
// 			vnCalibPos.push_back(nRemCalibPos);
// 			std::vector<CameraExposureType> vsmCameraExposureType;
// 
// 			for(i = 0; i < nPosNum; i++)
// 			{
// 				vsmCameraExposureType.push_back(eDmCodeSearchCameraExposure);
// 			}
// 
// 			if (!CameraExposureSetting(vnCalibPos,vsmCameraExposureType))
// 			{
// 				//m_bStatusBar = FALSE;
// 				//m_strStatusBarInfo1 = _T("切换二维码曝光失败");
// 				//m_strStatusBarInfo2 = _T("");
// 				//SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 				//PostMessageUpdateStatusBarInfo();
// 				OnFailedCameraExposureSetting(strCmd);
// 			}
// 		}
// 	}
// 	//////////////////////////////////////// 平台标定/////////////////////////////////////////////
// 
// 	// 1. 获取平台当前各轴的绝对位置（基准位置）,并设置入对位工具
// 	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
// 	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
// 	if (m_bCmdParamAxisPosEanble)
// 	{
// 		bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
// 	}
// 	else
// 	{
// 		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
// 	}
// 
// 	//	if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
// 	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
// 	{
// 		if (pPlatformAxisPos!=NULL)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;					
// 		}
// 
// 		ReportCalibResult(FALSE);
// 		return OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
// 		//m_bStatusBar = FALSE;
// 		//m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
// 		//m_strStatusBarInfo2 = _T("");
// 		//PostMessageUpdateStatusBarInfo();
// 
// 		//return FALSE;
// 	}
// 	else
// 	{
// 		SetCalibPlatformPos(pPlatformAxisPos);		
// 
// 		if (m_CalibPlatformAxisAbsPos.size()<nRemCalibPos+1)
// 		{
// 			m_CalibPlatformAxisAbsPos.resize(nRemCalibPos+1);
// 		}
// 		m_CalibPlatformAxisAbsPos.at(nRemCalibPos)= *((CPlatformXYDAxisPos*)pPlatformAxisPos);
// 
// 		// 记录当前平台各个轴的绝对位置
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			CTime t = CTime::GetCurrentTime();
// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strInfo;
// 			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
// 			strInfo = strTemp + strInfo;
// 
// 			FILE *stream;
// 			CString strPath = m_strAlignProcessData;
// 			stream = fopen(strPath, _T("a+t"));
// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 			fclose(stream);VCRemoveFile(strPath);				
// 		}
// 
// 		if (pPlatformAxisPos)
// 		{
// 			delete pPlatformAxisPos;
// 			pPlatformAxisPos = NULL;
// 		}
// 	}
// 
// 	// 2. 获取平移标定和旋转标定时平台各轴的移动位置
// 	std::vector<CPlatformAxisPos*> vpPlatformAxisPos;   			
// 	//vpPlatformAxisPos = GetCalibPlatformAxisMovePos(nCalibPos,nMarkType);
// 	vpPlatformAxisPos = GetCalibCenterPlatformAxisMovePos(nRemCalibPos);
// 
// 	if (vpPlatformAxisPos.size()!=m_pAlignerTool->GetCalibCenterPlatformMovePosNum(nMarkType))
// 	{
// 		ReportCalibResult(FALSE);
// 		return OnFailedGetCalibPlatformAxisMovePos(strCmd);
// 		//m_bStatusBar = FALSE;
// 		//m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_EIGHT_PLATFORM_POS_FAILED);
// 		//m_strStatusBarInfo2 = _T("");
// 		//PostMessageUpdateStatusBarInfo();
// 
// 		//return FALSE;
// 	}
// 	else
// 	{
// 		// 记录平台标定时平台需移动的7个位置各个轴的绝对位置
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			CTime t = CTime::GetCurrentTime();
// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strInfo;
// 			strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CALIB_SEVEN_PLATFORM_MOVE_POS);
// 			strInfo = strTemp + strInfo;
// 
// 			CPlatformXYDAxisPos* pAxisPos;
// 			for (int i=0; i<vpPlatformAxisPos.size(); i++)
// 			{
// 				strTemp.Empty();
// 				pAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(i);           
// 
// 				strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_CALIB_PLATFORM_POS), i, pAxisPos->m_dPosX, pAxisPos->m_dPosY, pAxisPos->m_dAngle);
// 				strInfo = strInfo + strTemp;
// 			}
// 
// 			FILE *stream;
// 			CString strPath = m_strAlignProcessData;
// 			stream = fopen(strPath, _T("a+t"));
// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 			fclose(stream);VCRemoveFile(strPath);				
// 		}
// 	}
// 
// 	// 3. 驱动平台到位并定位
// 	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
// 	std::vector<CMarkImagePos*> vpMarkImagePos;
// 	CMarkImagePos* pMarkImagePos = NULL;
// 	CString str;
// 	CMarkImagePos* pDisCorMarkImagePos = NULL;
// 
// 	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 	CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
// 	if (pCalibData == NULL || !pCalibData->IsValid())
// 	{
// 		ReportCalibResult(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// 	CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
// 	if (pCalibrateParam == NULL)
// 	{
// 		ReportCalibResult(FALSE);
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		return FALSE;
// 	}
// 
// 	int k=0;
// 	//	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum() - 1; k++)
// 	for (k=0; k<m_pAlignerTool->GetCalibPlatformMovePosNum(nMarkType); k++)
// 	{         
// 		EnterCriticalSection(&m_csResource);
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE), k);
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
// 		PostMessageUpdateStatusBarInfo();
// 		LeaveCriticalSection(&m_csResource);
// 
// 		pMarkImagePos = NULL;
// 
// 		pDisCorMarkImagePos = NULL;
// 
// 		// 驱动到位
// 		pPlatformXYDAxisPos = NULL;
// 		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(k);
// 
// 		// 		if (k >8) //九点拍摄完成后，旋转部分运动
// 		// 		{
// 		// 			if(FALSE == CommuciateDrivePlatformAxisMovePick(pPlatformXYDAxisPos))
// 		// 			{
// 		// 				ReportCalibResult(FALSE);
// 		// 
// 		// 				m_bStatusBar = FALSE;
// 		// 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), k) ;
// 		// 				m_strStatusBarInfo2 = _T("");
// 		// 				PostMessageUpdateStatusBarInfo();
// 		// 
// 		// 				return FALSE;
// 		// 			}
// 		// 		}
// 		// 		else
// 		{
// 			if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
// 			{
// 				ReportCalibResult(FALSE);
// 				return OnFailedCommuciateDrivePlatformAxisMove(strCmd, k);
// 				//m_bStatusBar = FALSE;
// 				//m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), k) ;
// 				//m_strStatusBarInfo2 = _T("");
// 				//PostMessageUpdateStatusBarInfo();
// 
// 				//return FALSE;
// 			}
// 		}
// 
// 
// 
// 
// 		Sleep(100);
// 		// 将相机移动到多个位置，逐个定位
// 		pMarkImagePos = new CMarkImagePos;
// 		pMarkImagePos->SetMarkImagePosNum(1);
// 
// 		pDisCorMarkImagePos = new CMarkImagePos;
// 		pDisCorMarkImagePos->SetMarkImagePosNum(1);
// 
// 		//for (int n=0; n<nCamPos; n++)
// 		{
// 
// 
// 			// 			if (nCamNum==1)
// 			// 			{
// 			// 				// 调整该单相机的回调参数索引
// 			// 				m_vpCamera.at(0)->Freeze();
// 			// 				m_vpCamOwner.at(0)->m_nCamIndex = nCalibPos;
// 			// 				m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 			// 				m_vpCamera.at(0)->Grab();
// 			// 			}
// 
// 			// 等待搜索延时
// 			int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 			Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nRemCalibPos]->m_nSearchDelayTime);
// 
// 			// 准备开始定位			
// 			std::vector<int> vnPosIndex;
// 			std::vector<SearchMode> vsmSearchMode;	
// 			vnPosIndex.push_back(nRemCalibPos);		// nCalibPos	
// 			
// 			if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 			{
// 				vsmSearchMode.push_back(eCalibSearch);	// 标定搜索
// 			}
// 			else
// 			{
// 				vsmSearchMode.push_back(eTargetSearch);	// 标定搜索
// 			}			
// 			// 隐藏结果图形
// 			m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);
// // 			PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
// // 			// SY
// // 			PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
// // 
// // 			if (m_pPlatformInfo->m_eMidPlatformType==ePlatformXYPD)
// // 			{
// // 				PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, FALSE);
// // 			}
// // //			if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
// // 			{
// // 				PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
// //			}
// 			// 采集搜索图像
// 			if (!SnapSearchImage(vnPosIndex))
// 			{
// 
// 
// 				ReportCalibResult(FALSE);
// 
// 				if (pMarkImagePos!=NULL)
// 				{
// 					delete pMarkImagePos;
// 					pMarkImagePos = NULL;
// 				}
// 
// 				if(pDisCorMarkImagePos != NULL)
// 				{
// 					delete pDisCorMarkImagePos;
// 					pDisCorMarkImagePos = NULL;
// 				}
// 
// 				// 				for (int p=0; p<vpMarkImagePos.size(); p++)
// 				// 				{
// 				// 					if (vpMarkImagePos.at(p))
// 				// 					{
// 				// 						delete vpMarkImagePos.at(p);
// 				// 						vpMarkImagePos.at(p) = NULL;
// 				// 					}
// 				// 				}  
// 
// 				//m_bStatusBar = FALSE;
// 				//m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// 				//m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// 				//PostMessageUpdateStatusBarInfo();
// 				return OnFailedSnapSearchImage(strCmd);
// 				//return FALSE;
// 			}
// 
// 			// 定位
// 			m_vnTargetSearchStartPatIndex[nRemCalibPos] = 0;
// 			m_vnTargetSearchEndPatIndex[nRemCalibPos] = 0;
// 
// 			if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 			{
// 				if (k==0)
// 				{
// 					m_bIsFirstCalibPos = TRUE;
// 				}
// 				else
// 				{
// 					m_bIsFirstCalibPos = FALSE;
// 				}
// 			}
// 
// 			BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
// 			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
// 			{
// 				//PostMessageSaveVDBFile(vnPosIndex,eCalibSearch);
// 				ExeSaveVDBFile(vnPosIndex,eCalibSearch);
// 			}
// 			// 分析定位结果，发送指令响应
// 			if (FALSE == bSearchSucceed)
// 			{
// 
// // 				ReportCalibResult(FALSE);
// 
// // 				m_bStatusBar = FALSE;
// // 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_MOVE_ROTATE_POS_SEARCH_FAILED), k);
// // 				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAM_MOVE_THEN_SEARCH_FAILED), nCalibPos); 
// // 				PostMessageUpdateStatusBarInfo();
// 
// 				if (pMarkImagePos!=NULL)
// 				{
// 					delete pMarkImagePos;
// 					pMarkImagePos = NULL;
// 				}
// 
// 				if(pDisCorMarkImagePos != NULL)
// 				{
// 					delete pDisCorMarkImagePos;
// 					pDisCorMarkImagePos = NULL;
// 				}
// 
// 				// 				for (int p=0; p<vpMarkImagePos.size(); p++)
// 				// 				{
// 				// 					if (vpMarkImagePos.at(p))
// 				// 					{
// 				// 						delete vpMarkImagePos.at(p);
// 				// 						vpMarkImagePos.at(p) = NULL;
// 				// 					}
// 				// 				}  
// 				//return FALSE;
// 				return OnFailedCalibSearch(strCmd, k, nCalibPos);
// 			}
// 			
// 			if(pCalibrateParam->m_nEnableDisCor)
// 			{
// 				CCoordPos OutPutPoint;
// 				m_pAlignerTool->ExecuteDisCorPoint(nCalibPos, m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos), OutPutPoint);
// 				pDisCorMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), OutPutPoint);
// 			}
// 			
// 			if (optionInfo.m_bEnableDmCodeCalib && (GetCalibMarkPatternMode() == eCalibUseDmCode || GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib))
// 			{
// 				pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nRemCalibPos));	
// 			}
// 			else
// 			{
// 				// 保存定位结果		
// 				pMarkImagePos->SetMarkImagePos(0, m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nRemCalibPos), m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));	
// 
// // 				设定、显示结果图形
// 				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
// // 								SetGuiAlnTargetImageMarkPos(vnPosIndex);
// // 								PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
// // 								if (m_pSystempOptionConfig->m_bShowCornerTool/* && m_bIsTargetCornerSearchTool*/)
// // 								{
// // 									SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
// // 									PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
// // 								}
// // 								// SY
// // 								SetShowGuiTargetImageMarkPos(vnPosIndex);
// // 								PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
// 			}
// 
// 		}
// 		if(pCalibrateParam->m_nEnableDisCor)
// 		{
// 			CMarkImagePos * markpos = new CMarkImagePos(*pDisCorMarkImagePos);
// 			vpMarkImagePos.push_back(markpos); 
// 		}
// 		else
// 		{
// 			CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
// // 		if (m_vpMarkImagePos.at(k+10)!=NULL)
// // 		{
// // 			delete m_vpMarkImagePos.at(k+10);
// // 			m_vpMarkImagePos.at(k+10)= NULL;
// // 		}
// // 		m_vpMarkImagePos.at(k+10)=  markpos;
// 			vpMarkImagePos.push_back(markpos); 
// 		}
// 
// 		// 记录图像搜索数据
// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 		{
// 			CString strTemp;
// 			CTime t = CTime::GetCurrentTime();
// 			strTemp.Format(_T("\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 			CString strOut;
// 			CCoordPos cp;
// 			strOut = strTemp + _T("CalibSearch: ");		
// 			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
// 			{
// 				strTemp = _T("");
// 				cp = pMarkImagePos->GetMarkImagePos(i);
// 
// 				strTemp.Format(_T("MarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 				strOut += strTemp;
// 			}
// 
// 			if(pCalibrateParam->m_nEnableDisCor)
// 			{
// 				for (int i=0; i<pDisCorMarkImagePos->GetMarkImagePosNum(); i++)
// 				{
// 					strTemp = _T("");
// 					cp = pDisCorMarkImagePos->GetMarkImagePos(i);
// 
// 					strTemp.Format(_T("DisCorMarkPos%d( %.2f , %.2f , %.3f )"), k, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 
// 					strOut += strTemp;
// 				}
// 			}
// 
// 			FILE *stream;
// 			CString strPath = m_strAlignProcessData;
// 			stream = fopen(strPath, _T("a+t"));               
// 			fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
// 			fclose(stream);VCRemoveFile(strPath);
// 		}	
// 
// 		if (pMarkImagePos!=NULL)
// 		{
// 			delete pMarkImagePos;
// 			pMarkImagePos = NULL;
// 		}   
// 
// 		if(pDisCorMarkImagePos != NULL)
// 		{
// 			delete pDisCorMarkImagePos;
// 			pDisCorMarkImagePos = NULL;
// 		}
// 	}    	
// 	if (pMarkImagePos!=NULL)
// 	{
// 		delete pMarkImagePos;
// 		pMarkImagePos = NULL;
// 	}   
// 
// 	if(pDisCorMarkImagePos != NULL)
// 	{
// 		delete pDisCorMarkImagePos;
// 		pDisCorMarkImagePos = NULL;
// 	}
// 
// 	// 	for (int i=0; i<m_vpMarkImagePos.size(); i++)
// 	// 	{
// 	// 		for (int j=0;j<m_vpMarkImagePos.at(i)->GetMarkImagePosNum();j++)
// 	// 		{
// 	// 			CCoordPos cp;
// 	// 			cp = m_vpMarkImagePos.at(i)->GetMarkImagePos(j);
// 	// 
// 	// 			str.Format(_T("MarkPos%d_%d( %.2f , %.2f , %.3f )"), i,j, cp.GetPosX(), cp.GetPosY(), cp.GetAngle());
// 	// 			AlignLogRecord(str);
// 	// 
// 	// 			
// 	// 		}
// 	// 
// 	// 
// 	// 	}
// 	// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具
// 	
// 	//全局二维码靶标标定，拾取相机随XY轴运动，标定D轴时，仅设置旋转运动搜索的Mark坐标
// 	if (GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
// 	{
// 		if (m_pPlatformInfo->m_bPlatformPick && m_pPlatformInfo->m_ePickCamPlatformType == ePickCamPlatformShareXY)
// 		{
// 			m_pAlignerTool->SetCalibPlatformMoveSearchResult(vpMarkImagePos,nMarkType,nRemCalibPos);	
// 		}
// 		else
// 		{
// 			m_pAlignerTool->SetCalibPlatformMoveSearchResult(vpMarkImagePos,nRemCalibPos);
// 		}
// 
// 		// 5. 释放内存
// 		for (k=0; k<vpMarkImagePos.size(); k++)
// 		{
// 			if (vpMarkImagePos.at(k))
// 			{
// 				delete vpMarkImagePos.at(k);
// 				vpMarkImagePos.at(k) = NULL;
// 			}
// 		} 
// 	}
// 	else
// 	{
// 		// 4. 将平台7个位置的所有图像搜索结果，设置入对位工具
// 		if(FALSE == ExecuteCalibrate(vpMarkImagePos/*m_vpMarkImagePos*/,nCalibPos,nMarkType))
// 		{
// 			str.Format("calibrate error");
// 			AlignLogRecord(str);
// 			ReportCalibResult(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 
// 			for (k=0; k<vpMarkImagePos.size(); k++)
// 			{
// 				if (vpMarkImagePos.at(k))
// 				{
// 					delete vpMarkImagePos.at(k);
// 					vpMarkImagePos.at(k) = NULL;
// 				}
// 			} 
// 
// 			SaveCurAllCameraChannelSearchImg();		
// 			return FALSE;
// 		}
// 		// 5. 释放内存
// 		for (k=0; k<vpMarkImagePos.size(); k++)
// 		{
// 			if (vpMarkImagePos.at(k))
// 			{
// 				delete vpMarkImagePos.at(k);
// 				vpMarkImagePos.at(k) = NULL;
// 			}
// 		}   
// 
// 		/////////////////////////////////////// 平台标定求精//////////////////////////////////////////
// 		// 
// 		// 	// 驱动该平台到达基准位置   
// 		// 	 	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)vpPlatformAxisPos.at(11);	
// 		// 	 	if(FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
// 		// 	 	{		
// 		// 	 		ReportCalibResult(FALSE);
// 		// 	 
// 		// 			m_bStatusBar = FALSE;
// 		// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_TO_BENCH_POS_FAILED);
// 		// 		 		m_strStatusBarInfo2 = _T("");	
// 		// 		 		PostMessageUpdateStatusBarInfo();
// 		// 		 
// 		// 		 		SaveCurAllCameraChannelSearchImg();
// 		// 		 		return FALSE;
// 		// 		 	}
// 
// 
// 		// 判断是否需要进行平台标定求精，若是，则对单个相机进行平台标定求精
// 		//
// 		// 	 	SysPlatformInfo sysPlatformInfo;
// 		// 		GetSysPlatformInfo(sysPlatformInfo);
// 		// 	 	if (ePlatformXD == sysPlatformInfo.m_eMidPlatformType)
// 		// 	 	{
// 		// 	 	}
// 		// 	 	else if (ePlatformYD == sysPlatformInfo.m_eMidPlatformType)
// 		// 	 	{
// 		// 	 	}
// 		// 	 	else
// 		// 	 	{
// 		// 	 		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 		// 	 		int nCalibRefineTime = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nCalibPos]->GetPlatformCalibRefineTime();
// 		// 	 
// 		// 	 		for (i = 0; i < nCalibRefineTime; i++)
// 		// 			{
// 		// 	 			if (FALSE == ExcutePlatformCalibrateRefine(nCalibPos))
// 		// 	 			{
// 		// 	 				ReportCalibResult(FALSE);
// 		// 	 
// 		// 	 				m_bStatusBar = FALSE;
// 		// 	 				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_BENCH_POS_CALIB_REFINE_FAILED), nCalibPos);
// 		// 	 				m_strStatusBarInfo2 = _T("");
// 		// 					PostMessageUpdateStatusBarInfo();
// 		// 	 
// 		// 	 				SaveCurAllCameraChannelSearchImg();
// 		// 					return FALSE;
// 		// 	 			}
// 		// 	 		}
// 		// 	 	}
// 
// 
// 		// 	// 判断是否需要进行平台标定求精，若是，则对单个相机进行平台标定求精
// 		// 	 	if (TRUE == IsExcutePlatformCalibrateRefine())
// 		// 		{
// 		// 	 		//	for (int n=0; n<nCamPos; n++)
// 		// 			{              
// 		// 			if (FALSE == ExcutePlatformCalibrateRefine(nCalibPos))
// 		// 				{
// 		// 				ReportCalibResult(FALSE);
// 		// 	
// 		// 	 				m_bStatusBar = FALSE;
// 		// 					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_BENCH_POS_CALIB_REFINE_FAILED), nCalibPos);
// 		//  				m_strStatusBarInfo2 = _T("");
// 		// 	 				PostMessageUpdateStatusBarInfo();
// 		// 	 
// 		// 	 				SaveCurAllCameraChannelSearchImg();
// 		// 				return FALSE;
// 		// 				}
// 		// 			}
// 		// 		}
// 
// 		//////////////////////////////////////// 相机标定/////////////////////////////////////////////
// 
// 
// 		// 所有相机平台同时进行相机平台标定
// 		switch (m_pPlatformInfo->m_eCamPlatformType)
// 		{
// 		case eCamPlatformSepFix:
// 			break;
// 		case eCamPlatformSepX:
// 		case eCamPlatformSepXY:
// 			{
// 				std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
// 				CPlatformXYAxisPos* pCamPlatformXYAxisPos = NULL;
// 
// 				for(i=0; i<nCamPos; i++)
// 				{
// 					pCamPlatformXYAxisPos = new CPlatformXYAxisPos;
// 					vpCamPlatformXYAxisPos.push_back(pCamPlatformXYAxisPos);		
// 				}
// 
// 				// 1. 通信获取相机平台各个基准位置, 并设置入对位工具
// 				std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPosTemp; 
// 				for (i=0; i<nCamPos; i++)
// 				{
// 					// 等待相机移动到位
// 					if (FALSE == CommuciateWaitCamMove())
// 					{           
// 						ReportCalibResult(FALSE);
// 
// 						m_bStatusBar = FALSE;
// 						m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_WAIT_CAMERA_ARRIVED), i);
// 						m_strStatusBarInfo2 = _T("");
// 						PostMessageUpdateStatusBarInfo();
// 						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 						// 释放内存
// 						for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 						{
// 							if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 							{
// 								delete vpCamPlatformXYAxisPos.at(i);
// 								vpCamPlatformXYAxisPos.at(i) = NULL;
// 							}
// 						}
// 						SaveCurAllCameraChannelSearchImg();
// 						return FALSE;
// 					}
// 
// 					vpCamPlatformXYAxisPosTemp.clear();
// 					vpCamPlatformXYAxisPosTemp.push_back(vpCamPlatformXYAxisPos.at(i));
// 
// 					// 通信获取当前位置相机平台各轴的绝对位置
// 					if (FALSE == CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPosTemp))
// 					{
// // 						ReportCalibResult(FALSE);
// 
// // 						m_bStatusBar = FALSE;
// // 						m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_CAM_PLATFORM_POS_FAILED));
// // 						m_strStatusBarInfo2 = _T("");
// // 						PostMessageUpdateStatusBarInfo();
// 
// 						// 释放内存
// 						for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 						{
// 							if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 							{
// 								delete vpCamPlatformXYAxisPos.at(i);
// 								vpCamPlatformXYAxisPos.at(i) = NULL;
// 							}
// 						}
// 
// 						SaveCurAllCameraChannelSearchImg();
// 						//return FALSE;
// 						return OnFailedCommuciateGetCamPlatformAxisAbsPos(strCmd);
// 					}
// 					else
// 					{
// 						vpCamPlatformXYAxisPos.at(i) = vpCamPlatformXYAxisPosTemp.at(0);
// 					}
// 
// 				}
// 
// 				SetCalibCamPlatformPos(vpCamPlatformXYAxisPos);
// 
// 				// 记录当前相机平台各个轴的绝对位置
// 				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 				{
// 					CString strTemp;
// 					CTime t = CTime::GetCurrentTime();
// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 					CString strInfo;
// 					strInfo = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SINGLE_CAM_CALIB_ALL_BENCH_POS);
// 					strInfo = strTemp + strInfo;
// 
// 					for (int i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 					{
// 						strTemp = _T("");
// 						strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpCamPlatformXYAxisPos.at(i)->m_dPosX, vpCamPlatformXYAxisPos.at(i)->m_dPosY);
// 						strInfo = strInfo + strTemp;
// 					}
// 
// 					FILE *stream;
// 					CString strPath = m_strAlignProcessData;
// 					stream = fopen(strPath, _T("a+t"));
// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 					fclose(stream);VCRemoveFile(strPath);				
// 				}		
// 
// 				// 2. 获取相机平台标定时，各个基准位置处相机平台要移动的绝对位置
// 				std::vector< std::vector<CPlatformXYAxisPos*> > vppCameraMoveAxisPos;
// 				std::vector<CPlatformXYAxisPos*> vpCameraMoveAxisPos;
// 				int nPos = 0;
// 
// 				for (i=0; i<nCamPos; i++)
// 				{
// 					vpCameraMoveAxisPos.clear();
// 					GetCalibCamPlatformMovePos(i, vpCameraMoveAxisPos);
// 					vppCameraMoveAxisPos.push_back(vpCameraMoveAxisPos);
// 
// 					nPos = vpCameraMoveAxisPos.size();
// 				}
// 
// 				// 3. 单个相机平台在各个位置同时进行标定
// 				std::vector<CPlatformXYAxisPos*> vpAllCameraMoveAbsInThisPos;
// 				std::vector<CMarkImagePos*> vpAllCalibCameraSearchResult;
// 				std::vector<CPlatformXYAxisPos*> vpTemp;
// 				CMarkImagePos* pTemMarkImagePos = NULL;
// 				CMarkImagePos* pDisCorTemMarkImagePos = NULL;
// 
// 				int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 				CCalibData *pCalibData = m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nProductIndex);
// 				if (pCalibData == NULL || !pCalibData->IsValid())
// 				{
// 					ReportCalibResult(FALSE);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBDATA_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					return FALSE;
// 				}
// 				CCalibrateParam *pCalibrateParam = pCalibData->m_vpCalibrateParam.at(nRemCalibPos);
// 				if (pCalibrateParam == NULL)
// 				{
// 					ReportCalibResult(FALSE);
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
// 					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_WARNING_PROCESSING_GETCALIBPARAM_FAILED);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 					return FALSE;
// 				}
// 
// 				vpAllCalibCameraSearchResult.clear();
// 
// 				for (int n=0; n<nPos; n++)
// 				{
// 					vpAllCameraMoveAbsInThisPos.clear();
// 
// 					// 获取各个相机在第n次移动时所对应的绝对位置
// 					for (k=0; k<nCamPos; k++)
// 					{
// 						vpAllCameraMoveAbsInThisPos.push_back(vppCameraMoveAxisPos[k].at(n));
// 					}					
// 
// 					pTemMarkImagePos = new CMarkImagePos;
// 					pTemMarkImagePos->SetMarkImagePosNum(nCamPos);
// 
// 					pDisCorTemMarkImagePos = new CMarkImagePos;
// 					pDisCorTemMarkImagePos->SetMarkImagePosNum(nCamPos);
// 
// 					for (k=0; k<nCamPos; k++)
// 					{
// 						vpTemp.clear();
// 						vpTemp.push_back(vpAllCameraMoveAbsInThisPos.at(k));
// 
// 						// 通信驱动相机平台移动到指定位置
// 						if (FALSE == CommuciateDriveCamPlatformAxisMove(vpTemp))
// 						{
// // 							ReportCalibResult(FALSE);
// 
// // 							m_bStatusBar = FALSE;
// // 							m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_DRIVE_CAMERA_PLATFORM_TO_POS_FAILED), k);
// // 							m_strStatusBarInfo2 = _T("");
// // 							PostMessageUpdateStatusBarInfo();
// 
// 							// 释放内存
// 							for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 							{
// 								if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 								{
// 									delete vpCamPlatformXYAxisPos.at(i);
// 									vpCamPlatformXYAxisPos.at(i) = NULL;
// 								}
// 							}
// 
// 							//return FALSE;
// 							return OnFailedCommuciateDriveCamPlatformAxisMove(strCmd, k);
// 						}
// 
// 						if (4 == n)
// 						{
// 							continue;
// 						}
// 
// 						// 调整该单相机的回调参数索引
// 						m_vpCamera.at(0)->Freeze();
// 						m_vpCamOwner.at(0)->m_nCamIndex = k;
// 						m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 						m_vpCamera.at(0)->Grab();
// 
// 						// 开启定位		
// 						// 					m_vbSearchSucceed[k]  = FALSE;
// 						// 					m_vbSearchFinished[k] = FALSE;	
// 						// 
// 						// 					StartSearch(eCalibSearch);
// 
// 						int nCameraIndex = k;
// 						std::vector<int> vCamIndex;
// 						std::vector<SearchMode> vsmSearchMode;
// 
// 						vCamIndex.push_back(nCameraIndex);
// 						vsmSearchMode.push_back(eCalibSearch);
// 
// 						StartSearch(vCamIndex,vsmSearchMode);
// 
// 						// 等待定位结束		
// 						while (FALSE == m_vbSearchFinished[k])
// 						{					
// 							// 等待定位结束时判断各相机是否在线，避免相机掉线后出现死循环
// 							if (!m_vpCamera.at(0)->IsOnline())
// 							{
// 								//CloseSearch();
// 								CloseSearch(vCamIndex);
// 								m_bStatusBar = FALSE;
// 								m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
// 								m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
// 								PostMessageUpdateStatusBarInfo();
// 								strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
// 								AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 								return FALSE;
// 							}
// 							Sleep(10);
// 						}
// 
// 						// 分析定位结果，发送指令响应
// 						BOOL bSearchSucceed = FALSE;
// 
// 						bSearchSucceed = m_vbSearchSucceed[k];
// 
// 						if (FALSE == bSearchSucceed)
// 						{
// 							ReportCalibResult(FALSE);
// 
// 							m_bStatusBar = FALSE;
// 							m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_CAM_PLATFORM_POS_CALIB_SEARCH_FAILED), k);
// 							m_strStatusBarInfo2 = _T("");
// 							PostMessageUpdateStatusBarInfo();
// 							strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
// 							AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 							if (pTemMarkImagePos!=NULL)
// 							{
// 								delete pTemMarkImagePos;
// 								pTemMarkImagePos = NULL;
// 							}
// 
// 							if(pDisCorTemMarkImagePos != NULL)
// 							{
// 								delete pDisCorTemMarkImagePos;
// 								pDisCorTemMarkImagePos = NULL;
// 							}
// 
// 							for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 							{
// 								if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 								{
// 									delete vpCamPlatformXYAxisPos.at(i);
// 									vpCamPlatformXYAxisPos.at(i) = NULL;
// 								}
// 							}
// 
// 							// 关闭定位
// 							// CloseSearch();
// 							CloseSearch(vCamIndex);
// 							// 恢复该单相机的回调参数索引
// 							m_vpCamera.at(0)->Freeze();
// 							m_vpCamOwner.at(0)->m_nCamIndex = 0;
// 							m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0), GrabImageFinishedCallback);
// 							m_vpCamera.at(0)->Grab();
// 
// 							return FALSE;
// 						}
// 
// 						// 关闭定位
// 						// CloseSearch();			
// 						CloseSearch(vCamIndex);		
// 						// 暂存定位结果
// 
// 						if(pCalibrateParam->m_nEnableDisCor)
// 						{
// 							CCoordPos OutPutPoint;
// 							m_pAlignerTool->ExecuteDisCorPoint(k, m_mpCalibMarkImagePos.GetMarkImagePos(k), OutPutPoint);	// 此处k含义待确认
// 							pDisCorTemMarkImagePos->SetMarkImagePos(k, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(k), OutPutPoint);
// 						}
// 
// 						pTemMarkImagePos->SetMarkImagePos(k, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(k), m_mpCalibMarkImagePos.GetMarkImagePos(k));
// 
// 					} 	
// 
// 					// 恢复该单相机的回调参数索引
// 					m_vpCamera.at(0)->Freeze();
// 					m_vpCamOwner.at(0)->m_nCamIndex = 0;
// 					m_vpCamera.at(0)->SetOwner(m_vpCamOwner.at(0),GrabImageFinishedCallback);
// 					m_vpCamera.at(0)->Grab();
// 
// 					vpAllCalibCameraSearchResult.push_back(pTemMarkImagePos);
// 
// 					// 记录当前相机平台各个轴的绝对位置
// 					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 					{
// 						CString strTemp;
// 						CTime t = CTime::GetCurrentTime();
// 						strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 						CString strInfo;
// 						strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CALIB_CAM_PLATFORM_CERTAIN_POS), n);
// 						strInfo = strTemp + strInfo;
// 
// 						for (int i=0; i<vpAllCameraMoveAbsInThisPos.size(); i++)
// 						{
// 							strTemp = _T("");
// 							strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpAllCameraMoveAbsInThisPos.at(i)->m_dPosX, vpAllCameraMoveAbsInThisPos.at(i)->m_dPosY);
// 							strInfo = strInfo + strTemp;
// 						}
// 
// 						FILE *stream;
// 						CString strPath = m_strAlignProcessData;
// 						stream = fopen(strPath, _T("a+t"));
// 						fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
// 						fclose(stream);VCRemoveFile(strPath);				
// 					}
// 
// 					// 记录图像搜索数据
// 					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
// 					{
// 						CString strTemp;
// 						CTime t = CTime::GetCurrentTime();
// 						strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());
// 
// 						CString strOut;
// 						CCoordPos cp;
// 						strOut = strTemp + _T("CalibSearch: ");	
// 						if (pTemMarkImagePos)
// 						{
// 							for (int i=0; i<pTemMarkImagePos->GetMarkImagePosNum(); i++)
// 							{
// 								strTemp = _T("");
// 								cp = pTemMarkImagePos->GetMarkImagePos(i);
// 
// 								strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
// 
// 								strOut += strTemp;
// 							}			
// 						}
// 
// 						if(pCalibrateParam->m_nEnableDisCor)
// 						{
// 							if (pDisCorTemMarkImagePos)
// 							{
// 								for (int i=0; i<pDisCorTemMarkImagePos->GetMarkImagePosNum(); i++)
// 								{
// 									strTemp = _T("");
// 									cp = pDisCorTemMarkImagePos->GetMarkImagePos(i);
// 
// 									strTemp.Format(_T("DisCorMarkPos%d(%.2f,%.2f) "), i, cp.GetPosX(), cp.GetPosY());
// 
// 									strOut += strTemp;
// 								}			
// 							}
// 						}
// 
// 						FILE *stream;
// 						CString strPath = m_strAlignProcessData;
// 						stream = fopen(strPath, _T("a+t"));               
// 						fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
// 						fclose(stream);VCRemoveFile(strPath);
// 					}
// 
// 				}            
// 
// 				// 4. 将所有相机平台的所有定位结果设置入对位工具
// 				if(vpAllCalibCameraSearchResult.size() <= 0 ) 
// 				{
// 					ReportCalibResult(FALSE);
// 
// 					// 释放内存
// 					for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 					{
// 						if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 						{
// 							delete vpCamPlatformXYAxisPos.at(i);
// 							vpCamPlatformXYAxisPos.at(i) = NULL;
// 						}
// 					}
// 
// 					SaveCurAllCameraChannelSearchImg();
// 					return FALSE;
// 				}
// 				else
// 				{
// 					SetCalibCameraMoveSearchResult(vpAllCalibCameraSearchResult); 
// 				}	
// 
// 				// 5. 执行相机平台的标定计算
// 				if(FALSE == ExecuteCamPlatformCalibrate())
// 				{
// 					ReportCalibResult(FALSE);
// 
// 					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CAM_PLATFORM_CALCULATE_FAILED);
// 					m_strStatusBarInfo2 = _T("");
// 					PostMessageUpdateStatusBarInfo();
// 					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 					// 释放内存
// 					for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 					{
// 						if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 						{
// 							delete vpCamPlatformXYAxisPos.at(i);
// 							vpCamPlatformXYAxisPos.at(i) = NULL;
// 						}
// 					}
// 
// 					SaveCurAllCameraChannelSearchImg();
// 					return FALSE;
// 				}
// 
// 
// 				// 释放内存
// 				for (i=0; i<vpCamPlatformXYAxisPos.size(); i++)
// 				{
// 					if (vpCamPlatformXYAxisPos.at(i)!=NULL)
// 					{
// 						delete vpCamPlatformXYAxisPos.at(i);
// 						vpCamPlatformXYAxisPos.at(i) = NULL;
// 					}
// 				}
// 			}
// 			break;
// 		case eCamPlatformShareX:
// 			break;
// 		default:
// 			break;				
// 		}
// 	}
// 	
// 
// 	
// 
// 	//////////////////////////////////////// 获取标定结果///////////////////////////////////////////
// 
// 	// 获取系统标定后的所有信息
// 	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
// 	vpAllCalibratedInfo = GetAllCalibratedInfo();	
// 	/*SysPlatformInfo sysPlatformInfo;
// 	GetSysPlatformInfo(sysPlatformInfo);*/
// 
// 	
// 	if(optionInfo.m_bAutoCopyCalibData)
// 	{
// 		//复制标定
// 		int nExProductIdx = nCalibPos/GetPosNum();
// 		ExecuteCopyCalibrateData(1,nExProductIdx);
// 	}
// 	else
// 	{
// 		/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
// 		SetCurCalibratedInfo(vpAllCalibratedInfo);	
// 
// 		// 保存标定后信息到当前产品中及配置文件中
// 		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
// 	}
// 
// 
// 	// 保存目标定位结果信息
// 	m_bTargetMarkSearchSucceed = FALSE;	
// 	m_mpTargetMarkImagePos.SetMarkImagePos(nRemCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nRemCalibPos));
// 	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
// 	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());
// 
// 	if (optionInfo.m_bEnableDmCodeCalib && GetCalibMarkPatternMode()== eWholeDmcodeBoardCalib && GetWholeCalibCacuPosEnable() && nRemCalibPos == GetWholeCalibCacuPos())
// 	{
// 
// 		return ExecuteCalibWholeDmCodeBoardPick(nCalibPos,0);
// 	
// 	}
// 	// 保存标定后信息到
// 
// 	return TRUE;
// }

BOOL vcXYDVisionAlign::OnSingleCameraPostionCalibrateEx(int nCalibPos)
{
	//////////////////////////////////////// 相机标定/////////////////////////////////////////////


	// 所有相机平台同时进行相机平台标定
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	int nCamPos = m_pPlatformInfo->m_nPositionNum;
	int i = 0;
	int k = 0;

	SYSTEMTIME sys; 
	GetLocalTime( &sys ); 
	CString t;
	t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
	CString strLogPath;
	CString strRecord;
	strLogPath.Format(_T("D:\\CamCalibrate%d.txt"),sysPlatformInfo.m_nPlatformIndex);
	FILE *fileLog;
	fileLog = fopen(strLogPath,_T("a+t"));
	strRecord.Format(_T("%s位置%d开始相机标定\n"),t,nCalibPos);
	fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
	fclose(fileLog);

	switch (m_pPlatformInfo->m_eCamPlatformType)
	{
	case eCamPlatformSepFix:
		break;
	case eCamPlatformSepX:
	case eCamPlatformSepXY:
		{
			//获取相机轴位置
			std::vector<CPlatformXYAxisPos*> vpCamPlatformXYAxisPos;
			CPlatformXYAxisPos* pCameraAxisPos = NULL;
			for(i = 0; i < 2 ; i++)
			{
				pCameraAxisPos = new CPlatformXYAxisPos;
				vpCamPlatformXYAxisPos.push_back(pCameraAxisPos);
			}
			BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 

			bCommuciateGetPlatformAxisAbsPos = CommuciateGetCamPlatformAxisAbsPos(vpCamPlatformXYAxisPos);

			if (FALSE == bCommuciateGetPlatformAxisAbsPos)
			{
				fileLog = fopen(strLogPath,_T("a+t"));
				strRecord.Format(_T("获取轴位置失败\n"));
				fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
				fclose(fileLog);
				for(int i = 0; i < vpCamPlatformXYAxisPos.size() ; i++)
				{
					if(vpCamPlatformXYAxisPos.at(i) != NULL)
					{
						delete vpCamPlatformXYAxisPos.at(i);
						vpCamPlatformXYAxisPos.at(i) = NULL;
					}
				}

				ReportCamCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}
			else
			{

				if (NULL == m_pAlignerTool)
				{
					for(int i = 0; i < vpCamPlatformXYAxisPos.size() ; i++)
					{
						if(vpCamPlatformXYAxisPos.at(i) != NULL)
						{
							delete vpCamPlatformXYAxisPos.at(i);
							vpCamPlatformXYAxisPos.at(i) = NULL;
						}
					}
					return FALSE;
				}
				CPlatformXYAxisPos* pCamPlatformPos;
				pCamPlatformPos = NULL;
				pCamPlatformPos = vpCamPlatformXYAxisPos.at(0);

				fileLog = fopen(strLogPath,_T("a+t"));
				strRecord.Format(_T("%s位置%d的相机轴位置X:%f,Y:%f\n"),t,nCalibPos,pCamPlatformPos->m_dPosX,pCamPlatformPos->m_dPosY);
				fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
				fclose(fileLog);

				//设置相机轴基准位置
				m_pAlignerTool->SetCalibCamPlatformPos(nCalibPos,vpCamPlatformXYAxisPos.at(0) );
				m_pAlignerTool->SetCalibCamAxisPlatformAxisPos(nCalibPos,vpCamPlatformXYAxisPos.at(1));


			}
			// 记录当前相机轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{

				CString strInfo;
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), pCameraAxisPos->m_dPosX, pCameraAxisPos->m_dPosY, 0);
				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}


			//获取相机轴标定时相机轴移动的位置
			std::vector<CPlatformXYAxisPos*> vpCameraMoveAxisPos;
			GetCalibCamPlatformMovePos(nCalibPos,vpCameraMoveAxisPos);

			//移动+标定
			CPlatformXYAxisPos* pCameraMoveAxisPos;
			pCameraMoveAxisPos = NULL;
			std::vector<CMarkImagePos*> vpMarkImagePos;

			CMarkImagePos* pMarkImagePos = NULL;

			for(i = 0 ; i < vpCameraMoveAxisPos.size(); i++)
			{
				pCameraMoveAxisPos = vpCameraMoveAxisPos.at(i);
				vpCamPlatformXYAxisPos.at(0)->m_dPosX  = pCameraMoveAxisPos->m_dPosX;
				vpCamPlatformXYAxisPos.at(0)->m_dPosY  = pCameraMoveAxisPos->m_dPosY;

				m_bStatusBar = TRUE;
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IS_DRIVING_PLATFORM_MOVE),i );
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_WAIT);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				fileLog = fopen(strLogPath,_T("a+t"));
				strRecord.Format(_T("%s写入驱动相机轴位置X0:%f,Y0:%f\n"),t,
					vpCamPlatformXYAxisPos.at(0)->m_dPosX,vpCamPlatformXYAxisPos.at(0)->m_dPosY);
				fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
				fclose(fileLog);

				if(FALSE == CommuciateDriveCamPlatformAxisMove(vpCamPlatformXYAxisPos))
				{
					{
						for(int i = 0; i < vpCamPlatformXYAxisPos.size() ; i++)
						{
							if(vpCamPlatformXYAxisPos.at(i) != NULL)
							{
								delete vpCamPlatformXYAxisPos.at(i);
								vpCamPlatformXYAxisPos.at(i) = NULL;
							}
						}
					}


					ReportCamCalibResult(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_INDEX_ARRIVED_FAILED), i) ;
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}
				Sleep(100);

				//for(int m = 0; m < 2 ;m++)
				//{
				//	if(vpCamPlatformXYAxisPos.at(m) != NULL)
				//	{
				//		delete vpCamPlatformXYAxisPos.at(m);
				//		vpCamPlatformXYAxisPos.at(m) = NULL;
				//	}
				//}

				pMarkImagePos = new CMarkImagePos;
				pMarkImagePos->SetMarkImagePosNum(1);

				// 等待搜索延时
				int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
				Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nCalibPos]->m_nSearchDelayTime);

				// 准备开始定位			
				std::vector<int> vnPosIndex;
				std::vector<SearchMode> vsmSearchMode;	
				vnPosIndex.push_back(nCalibPos);		// nCalibPos	
				vsmSearchMode.push_back(eCalibSearch);	// 标定搜索

				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					ReportCamCalibResult(FALSE);

					if (pMarkImagePos!=NULL)
					{
						delete pMarkImagePos;
						pMarkImagePos = NULL;
					}

					for (int p=0; p<vpMarkImagePos.size(); p++)
					{
						if (vpMarkImagePos.at(p))
						{
							delete vpMarkImagePos.at(p);
							vpMarkImagePos.at(p) = NULL;
						}
					}  
					for(int i = 0; i < vpCamPlatformXYAxisPos.size() ; i++)
					{
						if(vpCamPlatformXYAxisPos.at(i) != NULL)
						{
							delete vpCamPlatformXYAxisPos.at(i);
							vpCamPlatformXYAxisPos.at(i) = NULL;
						}
					}

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					return FALSE;
				}

				fileLog = fopen(strLogPath,_T("a+t"));
				strRecord.Format(_T("%s采集图像成功\n"),t);
				fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
				fclose(fileLog);

				// 定位
				m_vnCalibSearchStartPatIndex[nCalibPos] = 0;
				m_vnCalibSearchEndPatIndex[nCalibPos] = 0;
				BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				// 分析定位结果，发送指令响应
				if (FALSE == bSearchSucceed)
				{
					ReportCamCalibResult(FALSE);

					fileLog = fopen(strLogPath,_T("a+t"));
					strRecord.Format(_T("%s图像定位失败\n"),t);
					fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
					fclose(fileLog);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_MOVE_ROTATE_POS_SEARCH_FAILED),i);
					m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAM_MOVE_THEN_SEARCH_FAILED), nCalibPos); 
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					if (pMarkImagePos!=NULL)
					{
						delete pMarkImagePos;
						pMarkImagePos = NULL;
					}

					for (int p=0; p<vpMarkImagePos.size(); p++)
					{
						if (vpMarkImagePos.at(p))
						{
							delete vpMarkImagePos.at(p);
							vpMarkImagePos.at(p) = NULL;
						}
					}  
					for(int i = 0; i < vpCamPlatformXYAxisPos.size() ; i++)
					{
						if(vpCamPlatformXYAxisPos.at(i) != NULL)
						{
							delete vpCamPlatformXYAxisPos.at(i);
							vpCamPlatformXYAxisPos.at(i) = NULL;
						}
					}

					return FALSE;
				}

				// 保存定位结果		
				pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nCalibPos));	

				CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
				vpMarkImagePos.push_back(markpos);

				fileLog = fopen(strLogPath,_T("a+t"));
				strRecord.Format(_T("%s图像定位成功\n"),t);
				fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
				fclose(fileLog);
				// 记录图像搜索数据
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{


				}

			}


			SetCalibCameraMoveSearchResult(vpMarkImagePos); 

			fileLog = fopen(strLogPath,_T("a+t"));
			strRecord.Format(_T("%s开始进行标定计算\n"),t);
			fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
			fclose(fileLog);
			//  执行相机平台的标定计算
			if(FALSE == ExecuteCamPlatformCalibrate(nCalibPos))
			{
				ReportCamCalibResult(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CAM_PLATFORM_CALCULATE_FAILED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				// 释放内存
				for (k=0; k<vpMarkImagePos.size(); k++)
				{
					if (vpMarkImagePos.at(k))
					{
						delete vpMarkImagePos.at(k);
						vpMarkImagePos.at(k) = NULL;
					}
				} 
				for(int i = 0; i < vpCamPlatformXYAxisPos.size() ; i++)
				{
					if(vpCamPlatformXYAxisPos.at(i) != NULL)
					{
						delete vpCamPlatformXYAxisPos.at(i);
						vpCamPlatformXYAxisPos.at(i) = NULL;
					}
				}

				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;
			}

			fileLog = fopen(strLogPath,_T("a+t"));
			strRecord.Format(_T("%s标定计算成功\n"),t);
			fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
			fclose(fileLog);

			if (pMarkImagePos!=NULL)
			{
				delete pMarkImagePos;
				pMarkImagePos = NULL;
			} 

			// 5. 释放内存
			for (k=0; k<vpMarkImagePos.size(); k++)
			{
				if (vpMarkImagePos.at(k))
				{
					delete vpMarkImagePos.at(k);
					vpMarkImagePos.at(k) = NULL;
				}
			}  
			for(int i = 0; i < vpCamPlatformXYAxisPos.size() ; i++)
			{
				if(vpCamPlatformXYAxisPos.at(i) != NULL)
				{
					delete vpCamPlatformXYAxisPos.at(i);
					vpCamPlatformXYAxisPos.at(i) = NULL;
				}
			}


		}
		break;
	case eCamPlatformShareX:
		break;
	default:
		break;				
	}

	//////////////////////////////////////// 获取标定结果///////////////////////////////////////////

	// 获取系统标定后的所有信息
	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();

	if (sysPlatformInfo.m_bEnableObjectCalibBench && (sysPlatformInfo.m_nObjectCalibBenchIndex!=nCalibPos))
	{
		if (sysPlatformInfo.m_nObjectCalibBenchIndex < vpAllCalibratedInfo.size() && vpAllCalibratedInfo[m_pPlatformInfo->m_nObjectCalibBenchIndex] != NULL && vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex]->IsValid())
		{
			CPlatformXYDAxisPos*  pBenchPlatformAxisPos = (CPlatformXYDAxisPos* )vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex]->GetPlatformAxisPos();
			CPlatformXYDAxisPos * pCurrentPlatformAxisPos = (CPlatformXYDAxisPos*) vpAllCalibratedInfo.at(nCalibPos)->GetPlatformAxisPos();
			CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pVisionASMConfig->m_pPlatformInfo; 

			double dPlatformAxisOffsetX = pCurrentPlatformAxisPos->m_dPosX - pBenchPlatformAxisPos->m_dPosX;
			double dPlatformAxisOffsetY = pCurrentPlatformAxisPos->m_dPosY - pBenchPlatformAxisPos->m_dPosY;


			//平台各轴的方向	
			int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
			int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

			if(eDirectNegative == iPlatformXCoordType) dPlatformAxisOffsetX = -1*dPlatformAxisOffsetX;
			if(eDirectNegative == iPlatformYCoordType) dPlatformAxisOffsetY = -1*dPlatformAxisOffsetY;

			CCoordPos benchMarkPlatformCoordPos = vpAllCalibratedInfo[sysPlatformInfo.m_nObjectCalibBenchIndex ]->GetMarkPlatformCoordPos();
			CCoordPos currentMarkPlatformCoordPos =  vpAllCalibratedInfo.at(nCalibPos)->GetMarkPlatformCoordPos();

			currentMarkPlatformCoordPos.m_dPosX = benchMarkPlatformCoordPos.m_dPosX + dPlatformAxisOffsetX;
			currentMarkPlatformCoordPos.m_dPosY = benchMarkPlatformCoordPos.m_dPosY + dPlatformAxisOffsetY;



			vpAllCalibratedInfo.at(nCalibPos)->SetPlatformAxisPos(pBenchPlatformAxisPos);
			vpAllCalibratedInfo.at(nCalibPos)->SetMarkPlatformCoordPos(currentMarkPlatformCoordPos);	
		}


	}

	if(optionInfo.m_bAutoCopyCalibData)
	{
		//复制标定
		int nExProductIdx = nCalibPos/GetPosNum();
		ExecuteCopyCalibrateData(1,nExProductIdx);
	}
	else
	{
		/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
		SetCurCalibratedInfo(vpAllCalibratedInfo);	

		// 保存标定后信息到当前产品中及配置文件中
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
	}

	// 保存目标定位结果信息
	m_bTargetMarkSearchSucceed = FALSE;	
	m_mpTargetMarkImagePos.SetMarkImagePos(nCalibPos, FALSE, m_mpTargetMarkImagePos.GetMarkImagePos(nCalibPos));
	SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

	// 保存标定位置为目标基准位置
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);
	if (TRUE == m_pPlatformInfo->m_bEnableTargetBench)
	{
		for (i = 0; i < vpAllCalibratedInfo.size(); i++)
		{
			m_mpTargetMarkImagePos.m_vPos.at(i) = vpAllCalibratedInfo.at(i)->GetMarkImgCoordPos();
			m_mpTargetMarkImagePos.m_vbOK.at(i) = TRUE;

			if (m_vpTargetPlatformAxisPos.at(i) != NULL)
			{
				*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i)) = *((CPlatformXYDAxisPos*)vpAllCalibratedInfo.at(i)->GetPlatformAxisPos());
				//				m_vpTargetPlatformAxisPos.at(i) = vpAllCalibratedInfo.at(i)->GetPlatformAxisPos();
			}
			else
			{
				m_vpTargetPlatformAxisPos.at(i) = new CPlatformXYDAxisPos;
				*((CPlatformXYDAxisPos*)m_vpTargetPlatformAxisPos.at(i)) = *((CPlatformXYDAxisPos*)vpAllCalibratedInfo.at(i)->GetPlatformAxisPos());
			}
			{
				SetTargetPlatformPos(m_vpTargetPlatformAxisPos.at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpTargetPlatformAxisPos.at(i));
			}
		}

		m_bTargetMarkSearchSucceed = TRUE;
		SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		SaveTargetPosInfo(nCurProductIndex);

		// 设定、显示结果图形
		m_cVisionAlignGui.SetAllPosSearchResult(eTargetSearch);
		// 		SetAllGuiAlnTargetImageMarkPos();
		// 		PostMessageUpdateAllGuiAlnTargetImagePosGraphics(TRUE);
		// 
		// 		SetAllShowGuiTargetImageMarkPos();
		// 		PostMessageUpdateAllShowGuiTargetImagePosToDisplay(TRUE);
	}	

	return TRUE;
}





// 1：对象相机定位；0：目标相机定位；
BOOL vcXYDVisionAlign::OnlineProductInspectFINS(int nMarkType,int nPosIndex, int nCandIndex)
{
	CString strCmd = _T("VINS:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}

	int nCamNum = m_pPlatformInfo->m_nCamNum;


	BOOL bSuccess = FALSE;
	std::vector<int> vnPosIndex;

	if (nPosIndex>=0 && nPosIndex<=3)
	{
		bSuccess = OnSingleCameraProductInspectExFINS(nMarkType, nPosIndex, nCandIndex);
	}

	// 	else if(nPosIndex==4)
	// 	{
	// 		int nPosIndex = 0;
	// 		int i = 0;
	// 		for(i = 0; i < GetCameraNum(); i++)
	// 		{
	// 			nPosIndex = i;
	// 			vnPosIndex.push_back(nPosIndex);
	// 		}
	// 
	// 		bSuccess = OnSerialCameraSetProductExposureExFSPE(nMarkType, vnPosIndex, nCandIndex);
	// 	}
	// 	else if (nPosIndex==19) 
	// 	{
	// 		std::vector<int> vnPosIndex;
	// 		int nPosIndex = 0;
	// 		int i = 0;
	// 
	// 		// 目标
	// 		if (nMarkType == 0)
	// 		{
	// 			for(i = 0; i < GetPosNum()/2; i++)
	// 			{
	// 				nPosIndex = i;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			bSuccess = OnSerialCameraSetProductExposureExFSPE(nMarkType, vnPosIndex, nCandIndex);
	// 		}
	// 		// 对象
	// 		else if (nMarkType == 1)
	// 		{
	// 			for(i = 0; i < GetPosNum()/2; i++)
	// 			{
	// 				nPosIndex = i + GetPosNum()/2;
	// 				vnPosIndex.push_back(nPosIndex);
	// 			}
	// 			bSuccess = OnSerialCameraSetProductExposureExFSPE(nMarkType, vnPosIndex, nCandIndex);
	// 		}
	// 
	// 	}

	return bSuccess;
}

BOOL vcXYDVisionAlign::OnSingleCameraProductInspectExFINS(int nMarkTpye, int nPosIndex, int nCandIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VINS:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckObjectSearchTool(strCmd) || !CheckCommuciation(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		ReportProductInspectFINS(FALSE);
		return FALSE;
	}



	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		ReportProductInspectFINS(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_SEARCH_FAILE);//_T("对象拍照失败");;
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum != 1)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportProductInspectFINS(FALSE);
		return FALSE;
	}

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));
			ReportProductInspectFINS(FALSE);
			return FALSE;
		}    	
	}

	// 隐藏对象和目标界面显示
	std::vector<int> vnPosIndex;
	vnPosIndex.push_back(nPosIndex);

	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
	// 
	// 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);



	// 等待延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTargetTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();
	int nDelayObjectTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();


	BOOL bSearch = FALSE;

	m_tTimer.Reset();

	// 对象检测有、无
	if (nMarkTpye == 1)
	{
		while(!bSearch)
		{
			if (m_bStopNow)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INSPECT_FAIL);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				ReportProductInspectFINS(FALSE);
				return FALSE;
			}

			Sleep(100);

			// 			std::vector<int> vnPosIndex;
			// 			vnPosIndex.push_back(nPosIndex);


			//// 隐藏结果图形
			//PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
			//PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);

			// 设置图像
			EnterCriticalSection(&m_vcsResource.at(nPosIndex));
			m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
			LeaveCriticalSection(&m_vcsResource.at(nPosIndex));


			// 执行定位
			CCoordPos cp;
			BOOL bSearchSucceed = ExecuteAlnObjectSearch(nPosIndex, 0);
			if(bSearchSucceed)
			{			
				m_vbSearchSucceed[nPosIndex] = TRUE;
				m_vSeachResults[nPosIndex] = GetAlnObjectSearchResult(nPosIndex,0);
				m_vnObjectSearchSuccessPatIndex[nPosIndex] = 0;
				cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
				cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
				cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
				m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	


				// 设定、显示结果图形
				// 				SetGuiAlnObjectImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
				// 
				// 				SetShowGuiObjectImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INSPECT_SUCCEED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();


				ReportProductInspectFINS(TRUE);

				bSearch = TRUE;
				return TRUE;

			}
			else
			{
				cp.m_dPosX  = 0;
				cp.m_dPosY  = 0;
				cp.m_dAngle = 0;
				m_vbSearchSucceed[nPosIndex] =FALSE;
				m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INSPECT_ING);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				//				return FALSE;

			}

			if (m_tTimer.GetTimeMilli(FALSE) >= nDelayObjectTime)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INSPECT_FAIL);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				ReportProductInspectFINS(FALSE);

				return FALSE;
			}

		}
	}
	// 目标检测有、无
	else if (nMarkTpye == 0)
	{
		while(!bSearch)
		{
			if (m_bStopNow)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INSPECT_FAIL);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				ReportProductInspectFINS(FALSE);
				return FALSE;
			}

			Sleep(100);

			// 			std::vector<int> vnPosIndex;
			// 			vnPosIndex.push_back(nPosIndex);


			//// 隐藏结果图形
			//PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
			//PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);

			// 设置图像
			EnterCriticalSection(&m_vcsResource.at(nPosIndex));
			m_vImageSearch[nPosIndex] = m_vImageInput[nPosIndex];
			LeaveCriticalSection(&m_vcsResource.at(nPosIndex));


			// 执行定位
			CCoordPos cp;
			BOOL bSearchSucceed = ExecuteAlnTargetSearch(nPosIndex, 0);
			if(bSearchSucceed)
			{			
				m_vbSearchSucceed[nPosIndex] = TRUE;
				m_vSeachResults[nPosIndex] = GetAlnTargetSearchResult(nPosIndex,0);
				m_vnTargetSearchSuccessPatIndex[nPosIndex] = 0;
				cp.m_dPosX  = m_vSeachResults[nPosIndex].m_dPosX;
				cp.m_dPosY  = m_vSeachResults[nPosIndex].m_dPosY;
				cp.m_dAngle = m_vSeachResults[nPosIndex].m_dAngle;
				m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);	


				// 设定、显示结果图形
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
				// 				SetGuiAlnTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 
				// 				SetShowGuiTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INSPECT_SUCCEED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


				ReportProductInspectFINS(TRUE);

				bSearch = TRUE;
				return TRUE;

			}
			else
			{
				cp.m_dPosX  = 0;
				cp.m_dPosY  = 0;
				cp.m_dAngle = 0;
				m_vbSearchSucceed[nPosIndex] =FALSE;
				m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, m_vbSearchSucceed[nPosIndex], cp);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INSPECT_ING);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				//				return FALSE;

			}

			if (m_tTimer.GetTimeMilli(FALSE) >= nDelayTargetTime)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INSPECT_FAIL);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				ReportProductInspectFINS(FALSE);

				return FALSE;
			}

		}
	}

	return TRUE;

}

// 1：对象相机定位；0：目标相机定位；
BOOL vcXYDVisionAlign::OnlineSetProductExposureFSPE(int nMarkType,int nPosIndex, int nCandIndex)
{
	CString strCmd = _T("VSPE:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}

	BOOL bSuccess = FALSE;
	std::vector<int> vnPosIndex;

	if (nPosIndex>=0 && nPosIndex<=3)
	{
		vnPosIndex.push_back(nPosIndex);
		bSuccess = OnSerialCameraSetProductExposureExFSPE(nMarkType, vnPosIndex, nCandIndex);
	}
	else if(nPosIndex==4)
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetCameraNum(); i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}

		bSuccess = OnSerialCameraSetProductExposureExFSPE(nMarkType, vnPosIndex, nCandIndex);
	}
	else if (nPosIndex==19) 
	{
		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		int i = 0;

		// 目标
		if (nMarkType == 0)
		{
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
			}
			bSuccess = OnSerialCameraSetProductExposureExFSPE(nMarkType, vnPosIndex, nCandIndex);
		}
		// 对象
		else if (nMarkType == 1)
		{
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i + GetPosNum()/2;
				vnPosIndex.push_back(nPosIndex);
			}
			bSuccess = OnSerialCameraSetProductExposureExFSPE(nMarkType, vnPosIndex, nCandIndex);
		}

	}

	return bSuccess;
}


BOOL vcXYDVisionAlign::OnSerialCameraSetProductExposureExFSPE(int nMarkTpye, std::vector<int> vnPosIndex, int nCandIndex)
{
	CString strCmd = _T("VSPE:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportSetProductExposureFSPE(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));
			ReportSetProductExposureFSPE(FALSE);
			return FALSE;
		}    	
	}

	std::vector<CameraExposureType> vsmCameraExposureType;	
	int nPosNum = vnPosIndex.size();

	// 目标
	if (nMarkTpye == 0)
	{
		for(i = 0; i < nPosNum; i++)
		{
			vsmCameraExposureType.push_back(eTargetSearchCameraExposure);
		}
	}
	// 对象
	else if (nMarkTpye == 1)
	{
		for(i = 0; i < nPosNum; i++)
		{	
			vsmCameraExposureType.push_back(eObjectSearchCameraExposure);
		}
	}




	if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nCandIndex))
	{
		ReportSetProductExposureFSPE(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CHANGE_PRODUCT_EXPOSURE_FAIL);
		// 		m_strStatusBarInfo2 =_T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedCameraExposureSetting(strCmd);
		return FALSE;
	}
	else
	{
		ReportSetProductExposureFSPE(TRUE);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CHANGE_PRODUCT_EXPOSURE_SUCCEED);
		m_strStatusBarInfo2 =_T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return TRUE;
	}

	return TRUE;
}

// 1：对象相机定位；2：目标相机定位；3：目标、对象同时定位
BOOL vcXYDVisionAlign::OnSerialObjTarSearchCandidateExFPCB(int nMarkType)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VPCB:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	int nStartPatIndex = 0;

	std::vector<CCoordPos> vMarkImagePos;
	vMarkImagePos.clear();

	for (int j = 0; j < nPosNum * 2; j++)
	{
		CCoordPos TempMarkPos(0,0,0);
		vMarkImagePos.push_back(TempMarkPos);
	}

	/*m_bValidObjectSearchTool != TRUE || m_bValidTargetSearchTool != TRUE|| NULL == m_pPlatformInfo*/
	if (!CheckObjectSearchTool(strCmd) || !CheckTargetSearchTool(strCmd) || !CheckPlatformInfo(strCmd))
	{	
		ReportObjTarSearchResultFPCB(FALSE,vMarkImagePos);
		return FALSE;
	}

	if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_INITIALIZATION_CAMSEPARATE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_INITIALIZATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportObjTarSearchResultFPCB(FALSE,vMarkImagePos);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			m_strStatusBarInfo2 = _T("");
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo1, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, strTemp, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));
			ReportObjTarSearchResultFPCB(FALSE,vMarkImagePos);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	//	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();
	//	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();

	int nDelayTimeTarget = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetSearchDelayTime();

	if (nMarkType == 1)
	{
		Sleep(nDelayTime);
	}
	else if (nMarkType == 2)
	{
		Sleep(nDelayTimeTarget);
	}
	else 
	{
		Sleep(nDelayTime);
	}

	// 对象定位		
	if (nMarkType==1 ||nMarkType==3)
	{
		// 采集搜索图像
		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		std::vector<SearchMode> vsmSearchMode;	

		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
			vsmSearchMode.push_back(eObjectSearch);
		}

		// 隐藏结果图形
		// 		PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
		// //		if (/*m_bIsObjectCornerSearchTool &&*/ (m_pSystempOptionConfig->m_bShowCornerTool))
		// 		{
		// 			PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 		// SY
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);

		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);


		if (!SnapSearchImage(vnPosIndex))
		{
			ReportObjTarSearchResultFPCB(FALSE,vMarkImagePos);

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
			// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();
			OnFailedSnapSearchImage(strCmd);
			return FALSE;
		}

		// 对象定位
		BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
		BOOL bObjectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateSyncEnable();
		BOOL bSearchSucceed = FALSE;
		if (bObjectSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
				m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bObjectSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[0];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = OBJECTCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnObjectSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = i;
						m_vnObjectSearchStartPatIndex[nPosIndex] = j;
						m_vnObjectSearchEndPatIndex[nPosIndex] = j;
					}			
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

					if (bSearchSucceed)
					{
						break;
					}	
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = i;
					if (nStartPatIndex>=0 && nStartPatIndex < OBJECTCANDIDATENUM)
					{
						nTempStartPatIndex = nStartPatIndex;
					}
					else if (nStartPatIndex == 9)
					{
						nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
					}
					else
					{
						nTempStartPatIndex = 0;
					}
					nTempEndPatIndex = OBJECTCANDIDATENUM-1;

					m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}

		}


		// 设定、显示结果图形
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);
		//         if (m_pSystempOptionConfig->m_ObjSearchResultCrossSize.m_bShowDefortGui)
		//         {
		// //             SetGuiAlnObjectImageMarkPos(vnPosIndex);
		// //             PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
		// 
		//         }
		// 		
		// 
		// 		// SY
		// 		SetShowGuiObjectImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, TRUE, 1);
		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
			ExeSaveVDBFile(vnPosIndex,eObjectSearch);
		}

		if (TRUE == bSearchSucceed)
		{

		}
		else
		{
			ReportObjTarSearchResultFPCB(FALSE,vMarkImagePos);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}


	///目标定位
	// 准备开始定位	
	if (nMarkType==2 || nMarkType==3)
	{
		// 采集搜索图像
		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		std::vector<SearchMode> vsmSearchMode;	

		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
			vsmSearchMode.push_back(eTargetSearch);
		}

		// 隐藏目标定位结果十字，目标2/3图像
		// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
		// //		if (/*m_bIsTargetCornerSearchTool &&*/ (m_pSystempOptionConfig->m_bShowCornerTool))
		// 		{
		// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
		// 		}
		// 
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, FALSE);
		m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);


		if (!SnapSearchImage(vnPosIndex))
		{
			ReportObjTarSearchResultFPCB(FALSE,vMarkImagePos);

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
			// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();
			OnFailedSnapSearchImage(strCmd);
			return FALSE;
		}


		// 定位
		BOOL bTargetSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateEnable();
		BOOL bTargetSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetTargetCandidateSyncEnable();
		BOOL bSearchSucceed = FALSE;

		if (bTargetSearchCandidate == FALSE)
		{
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				m_vnTargetSearchStartPatIndex[nPosIndex] = 0;
				m_vnTargetSearchEndPatIndex[nPosIndex] = 0;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			if (bTargetSearchSync == TRUE)
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[0];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = TARGETCANDIDATENUM-1;

				int j = 0;
				for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
				{
					if (j > 0 && (FALSE == GetAlnTargetSearchCandidatePatEnable(j)))
					{
						continue;
					}

					for(i = 0; i < nPosNum; i++)
					{
						nPosIndex = i;
						m_vnTargetSearchStartPatIndex[nPosIndex] = j;
						m_vnTargetSearchEndPatIndex[nPosIndex] = j;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					if (bSearchSucceed)
					{
						break;
					}
				}
			}
			else
			{
				int nTempStartPatIndex, nTempEndPatIndex;
				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = i;
					if (nStartPatIndex>=0 && nStartPatIndex < TARGETCANDIDATENUM)
					{
						nTempStartPatIndex = nStartPatIndex;
					}
					else if (nStartPatIndex == 9)
					{
						nTempStartPatIndex = m_vnTargetSearchSuccessPatIndex[nPosIndex];
					}
					else
					{
						nTempStartPatIndex = 0;
					}
					nTempEndPatIndex = TARGETCANDIDATENUM-1;

					m_vnTargetSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
					m_vnTargetSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
				}
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
			}

		}


		// 设定、显示结果图形
		m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);
		//         if (m_pSystempOptionConfig->m_TarSearchResultCrossSize.m_bShowDefortGui)
		//         {
		//             SetGuiAlnTargetImageMarkPos(vnPosIndex);
		//             PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
		//         }
		// 
		// 		// SY
		// 		SetShowGuiTargetImageMarkPos(vnPosIndex);
		// 		PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
		// 
		// 		ShowExtraGuiToDisplay(vnPosIndex, TRUE, 0);
		if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
		{
			//PostMessageSaveVDBFile(vnPosIndex,eTargetSearch);
			ExeSaveVDBFile(vnPosIndex,eTargetSearch);
		}
		if (TRUE == bSearchSucceed)
		{

		}
		else
		{
			ReportObjTarSearchResultFPCB(FALSE,vMarkImagePos);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}
	//目标定位结束


	// 5. 设置对位工具
	for (int i=0;i<vMarkImagePos.size()/2;i++)
	{
		vMarkImagePos.at(i) = m_mpObjectMarkImagePos.m_vPos.at(i);
	}


	for (int i=vMarkImagePos.size()/2;i<vMarkImagePos.size();i++)
	{
		vMarkImagePos.at(i) = m_mpTargetMarkImagePos.m_vPos.at(i-vMarkImagePos.size()/2);
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SEARCH_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


	ReportObjTarSearchResultFPCB(TRUE,vMarkImagePos);


	return TRUE;
}

// BOOL vcXYDVisionAlign::OnlineSetPCBPrecisionFPIS(int nOffsetIndex)
// {
// 	CString strCmd = _T("VPIS:");
// 	CString strTempWarningType = _T("");
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = _T("");
// 	m_strStatusBarInfo2 = _T("");
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 	GetCommCommandName(strCmd);
// 	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
// 	{
// 		ReportPCBPrecisionFPIS(FALSE);
// 		return FALSE;
// 	}	
// 
// 	// 检查对象定位工具是否有效
// 	if (!CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
// 	{
// 		ReportPCBPrecisionFPIS(FALSE);
// 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 		PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE;
// 	}
// 
// 	// 检查对位工具是否有效
// 	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
// 	{
// 		ReportPCBPrecisionFPIS(FALSE);
// 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 		PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE;
// 
// 	}
// 
// 	// 检查通信工具是否有效
// 	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
// 	{
// 		ReportPCBPrecisionFPIS(FALSE);
// 
// // 		m_bStatusBar = FALSE;
// // 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
// // 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// // 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 		PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE;
// 	}
// 
// 	// 检查所有相机是否均处于连续采集状态	
// 	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
// 	{		 
// 		if (FALSE == m_vbCameraLiveGrab[i])
// 		{
// 			ReportPCBPrecisionFPIS(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_PRECISION_INSPECT_FAIL);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
// 			CString strTemp = _T("");
// 			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
// 			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
// 			PostMessageUpdateStatusBarInfo();
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
// 			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
// 			return FALSE;
// 		}            
// 	}    
// 
// 	// 获取当前产品信息
// 	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 
// 	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
// 	{
// 		ReportPCBPrecisionFPIS(FALSE);
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();		
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 		return FALSE;
// 	}
// 
// 	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
// 	if (pCurProductData == NULL)
// 	{
// 		ReportPCBPrecisionFPIS(FALSE);
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();		
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 		return FALSE;
// 	}
// 
// 
// 	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);
// 
// 	// 检查目标Mark是否已成功定位
// 	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
// 	{
// 		if (FALSE == m_bTargetMarkSearchSucceed)
// 		{
// 			ReportPCBPrecisionFPIS(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();		
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 			return FALSE;
// 		}
// 	}
// 
// 	// 检查对象Mark是否已成功定位
// 	if (eObjectBench != curProductData.m_pAlignerParam->m_eObjectMarkType)
// 	{
// 		if (FALSE == m_bObjectMarkSearchSucceed)
// 		{
// 			ReportPCBPrecisionFPIS(FALSE);
// 
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 			PostMessageUpdateStatusBarInfo();	
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
// 			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 			return FALSE;
// 		}	
// 	}
// 
// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
// 	std::vector<BOOL> vbPosIndex;
// 	std::vector<int>  vnPosIndex;
// 	std::vector<double> vdPosOffsetX;
// 	std::vector<double> vdPosOffsetY;
// 	for (int i = 0; i < nPosNum; i++)
// 	{
// 		vbPosIndex.push_back(FALSE);
// 		vnPosIndex.push_back(i);
// 		vdPosOffsetX.push_back(0.0);
// 		vdPosOffsetY.push_back(0.0);
// 	}
// 
// 	CPCBInfo PCBInfo;
// 	PCBInfo = curProductData.m_pAlignerParam->GetPCBInfo();
// 	int nPCBInsPreType = PCBInfo.m_nPCBInsPreType;
// 	BOOL bShowInspectResult = PCBInfo.m_bPCBShowInspectResult;
// 
// 	//ShowPCBExtraGuiToDisplay(vnPosIndex,vbPosIndex,FALSE ,bShowInspectResult,vdPosOffsetX,vdPosOffsetY);
// 
// 	
// 	scTimer stAlignTimer;   double dAlignTime(0.0);	
// 	stAlignTimer.Reset();	
// 
//  
// 	// 执行对位计算
// 	if(FALSE == ExecuteAlign(0, FALSE))//当前检测不考虑补偿值，只计算当前的目标对象平台坐标差异
// 	{
// 		ReportPCBPrecisionFPIS(FALSE);
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();	
// 
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 
// 		return FALSE;     
// 	}
// 
// 
// 	if (IsPCBPrecisionInspectFinished(nPCBInsPreType, vbPosIndex,vdPosOffsetX,vdPosOffsetY))
// 	{
// 		// 更新主界面对位精度、次数、对位总时间
// 		CCoordPos cpProduct = GetAlignProductOffset();
// 		m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
// 		m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
// 		m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;
// 
// 
// 		CCoordPos cp = GetAlignPlatformOffset();
// 		m_apAlignerProcesInfo.nTimes  = 1;
// 		m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
// 		m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
// 		m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
// 		m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
// 
// 		dAlignTime=m_apAlignerProcesInfo.dTime;
// 		PostMessageUpdateAlignerProcessInfo();
// 
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_IN_RANGE);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_SUCCEED);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 
// 		//ShowPCBExtraGuiToDisplay(vnPosIndex,vbPosIndex,TRUE ,bShowInspectResult,vdPosOffsetX,vdPosOffsetY);
// 
// 		ReportPCBPrecisionFPIS(TRUE);
// 		return TRUE;
// 
// 
// 	}
// 	else
// 	{
// 		// 更新主界面对位精度、次数、对位总时间
// 		CCoordPos cpProduct = GetAlignProductOffset();
// 		m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
// 		m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
// 		m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;
// 
// 
// 		CCoordPos cp = GetAlignPlatformOffset();
// 		m_apAlignerProcesInfo.nTimes  = 1;
// 		m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
// 		m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
// 		m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
// 		m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
// 
// 		dAlignTime=m_apAlignerProcesInfo.dTime;
// 		PostMessageUpdateAlignerProcessInfo();
// 
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_OUT_RANGE);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PRECISION_INSPECT_FAIL);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 
// 		//ShowPCBExtraGuiToDisplay(vnPosIndex,vbPosIndex,TRUE, bShowInspectResult,vdPosOffsetX,vdPosOffsetY);
// 
// 		ReportPCBPrecisionFPIS(FALSE);
// 		return TRUE;
// 	}
// 
// 	return TRUE;
// 
// 	// 判断是否执行对位动作
// //  	if (TRUE == IsAlignInspectFinished(0))
// //  	{		
// // 		// 更新主界面对位精度、次数、对位总时间
// // 		CCoordPos cpProduct = GetAlignProductOffset();
// // 		m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
// // 		m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
// // 		m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;
// // 
// // 
// // 		CCoordPos cp = GetAlignPlatformOffset();
// // 		m_apAlignerProcesInfo.nTimes  = 1;
// // 		m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
// // 		m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
// // 		m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
// // 		m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
// // 
// // 		dAlignTime=m_apAlignerProcesInfo.dTime;
// // 
// // 		PostMessageUpdateAlignerProcessInfo();
// // 
// // 
// // 		m_bStatusBar = IsAlignInspectSucceed();
// // 		if (m_bStatusBar)
// // 		{
// // 			ReportPCBPrecisionFPIS(TRUE);
// // 
// // 			m_strStatusBarInfo1 = _T("精度检测在允许范围之内");
// // 			m_strStatusBarInfo2 = _T("精度检测成功");
// // 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 			PostMessageUpdateStatusBarInfo();
// // 
// // 		}
// // 		std::vector<int> vnPosIndex;
// // 		for(int i = 0;i < m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.size();i++)
// // 		{
// // 			m_FinsPos.at(i).SetX(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX());
// // 			m_FinsPos.at(i).SetY(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY());
// // 			vnPosIndex.push_back(i);
// // 		}
// // 
// // 		if (!m_bStatusBar) 
// // 		{
// // 			ReportPCBPrecisionFPIS(FALSE);
// // 			m_bStatusBar = FALSE;
// // 			BOOL x1=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(0).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosX()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosX();
// // 			BOOL y1=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(0).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosY()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosY();
// // 
// // 			BOOL x2=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(1).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosX()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosX();
// // 			BOOL y2=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(1).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosY()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosY();
// // 
// // 			BOOL x3=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(2).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(2).GetPosX()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosX();
// // 			BOOL y3=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(2).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(2).GetPosY()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosY();
// // 
// // 			BOOL x4=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(3).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(3).GetPosX()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosX();
// // 			BOOL y4=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(3).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(3).GetPosY()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosY();
// // 
// // 
// // 			if (x1 && y1)
// // 			{
// // 				m_strStatusBarInfo1 = _T(" ");
// // 			}
// // 			else
// // 			{
// // 				m_strStatusBarInfo1 = _T("位置1 NG   ");
// // 				m_vpShowGuiFinsAlnText.at(0)->SetLineColor(RGB(255,0,0));
// // 			}
// // 			if (x2 && y2)
// // 			{
// // 				m_strStatusBarInfo2 = _T("  ");
// // 			}
// // 			else
// // 			{
// // 				m_strStatusBarInfo2 = _T("位置2 NG   ");
// // 				m_vpShowGuiFinsAlnText.at(1)->SetLineColor(RGB(255,0,0));
// // 			}		
// // 			if (x3 && y3)
// // 			{
// // 				m_strStatusBarInfo3 = _T("  ");
// // 
// // 			}
// // 			else
// // 			{
// // 				m_strStatusBarInfo3 = _T("位置3 NG   ");
// // 				m_vpShowGuiFinsAlnText.at(2)->SetLineColor(RGB(255,0,0));
// // 			}			
// // 			if (x4 && y4)
// // 			{
// // 				m_strStatusBarInfo4 = _T(" ");
// // 			}
// // 			else
// // 			{
// // 				m_strStatusBarInfo4 = _T("位置4 NG");
// // 				m_vpShowGuiFinsAlnText.at(3)->SetLineColor(RGB(255,0,0));
// // 			}
// // 
// // 			SetShowGuiObjectImageMarkPos(vnPosIndex);
// // 
// // 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
// // 
// // 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2,m_strStatusBarInfo3,m_strStatusBarInfo4);
// // 
// // 			//m_strStatusBarInfo1 = _T("精度检测范围超限");
// // 			//m_strStatusBarInfo2 = _T("精度检测失败");
// // 			//SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 			ReportPCBPrecisionFPIS(FALSE);
// // 
// // 			CCoordPos cpOffset;
// // 			if (bAlignerCalculateOffset)
// // 			{			
// // 				cpOffset.m_dPosX = -cpProduct.m_dPosX;
// // 				cpOffset.m_dPosY = -cpProduct.m_dPosY;
// // 				cpOffset.m_dAngle = -cpProduct.m_dAngle;
// // 			}
// // 			else
// // 			{
// // 				cpOffset.m_dPosX = 0;
// // 				cpOffset.m_dPosY = 0;
// // 				cpOffset.m_dAngle = 0;
// // 			}
// // 
// // 			if (!pCurProductData->m_pAlignerParam->SetAlignerOffset(nOffsetIndex,cpOffset))
// // 			{
// // 				m_bStatusBar = FALSE;
// // 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// // 				m_strStatusBarInfo2 = _T("精度检测失败");
// // 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 				ReportPCBPrecisionFPIS(FALSE);
// // 				return FALSE;
// // 			}
// // 
// // 			CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
// // 			if (!pAlignerParam->SetAlignerOffset(nOffsetIndex,cpOffset))
// // 			{
// // 				m_bStatusBar = FALSE;
// // 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// // 				m_strStatusBarInfo2 = _T("精度检测失败");
// // 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 				ReportPCBPrecisionFPIS(FALSE);
// // 				return FALSE;
// // 			}
// // 
// // 			if (!SaveProductDataInfo(nCurProductIndex))
// // 			{
// // 				m_bStatusBar = FALSE;
// // 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// // 				m_strStatusBarInfo2 = _T("精度检测失败");
// // 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 				ReportPCBPrecisionFPIS(FALSE);
// // 				return FALSE;
// // 			}
// // 
// // 			PostMessageUpdateAlignOffsetInfo();
// // 		}
// // 
// // 		SetShowGuiObjectImageMarkPos(vnPosIndex);
// // 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
// // 
// // 		return m_bStatusBar;  
// // 
// // 	}
// // 	else
// // 	{
// // 		m_bStatusBar = FALSE;
// // 
// // 		m_bStatusBar = FALSE;
// // 		BOOL x1=(fabs( m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(0).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosX()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosX();
// // 		BOOL y1=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(0).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosY()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosY();
// // 
// // 		BOOL x2=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(1).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosX()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosX();
// // 		BOOL y2=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(1).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosY()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosY();
// // 
// // 		BOOL x3=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(2).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(2).GetPosX()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosX();
// // 		BOOL y3=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(2).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(2).GetPosY()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosY();
// // 
// // 		BOOL x4=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(3).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(3).GetPosX()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosX();
// // 		BOOL y4=(fabs(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(3).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(3).GetPosY()))<=m_pAlignerTool->m_AlignermentParam.GetAlignerInspectPrecision().GetPosY();
// // 		std::vector<int> vnPosIndex;
// // 		for(int i = 0;i < m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.size();i++)
// // 		{
// // 			m_FinsPos.at(i).SetX(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX());
// // 			m_FinsPos.at(i).SetY(m_pAlignerTool->m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY()-m_pAlignerTool->m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY());
// // 			vnPosIndex.push_back(i);
// // 		}
// // 
// // 		if (x1 && y1)
// // 		{
// // 			m_strStatusBarInfo1 = _T(" ");
// // 		}
// // 		else
// // 		{
// // 			m_strStatusBarInfo1 = _T("位置1 NG   ");
// // 			m_vpShowGuiFinsAlnText.at(0)->SetLineColor(RGB(255,0,0));
// // 		}
// // 		if (x2 && y2)
// // 		{
// // 			m_strStatusBarInfo2 = _T("  ");
// // 		}
// // 		else
// // 		{
// // 			m_strStatusBarInfo2 = _T("位置2 NG   ");
// // 			m_vpShowGuiFinsAlnText.at(1)->SetLineColor(RGB(255,0,0));
// // 		}		
// // 		if (x3 && y3)
// // 		{
// // 			m_strStatusBarInfo3 = _T("  ");
// // 		}
// // 		else
// // 		{
// // 			m_strStatusBarInfo3 = _T("位置3 NG   ");
// // 			m_vpShowGuiFinsAlnText.at(2)->SetLineColor(RGB(255,0,0));
// // 		}			
// // 		if (x4 && y4)
// // 		{
// // 			m_strStatusBarInfo4 = _T(" ");
// // 		}
// // 		else
// // 		{
// // 			m_strStatusBarInfo4 = _T("位置4 NG   ");
// // 			m_vpShowGuiFinsAlnText.at(3)->SetLineColor(RGB(255,0,0));
// // 		}
// // 
// // 
// // 		SetShowGuiObjectImageMarkPos(vnPosIndex);
// // 		PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);
// // 
// // 		CString strStatus1 = m_strStatusBarInfo1+m_strStatusBarInfo2;
// // 		CString strStatus2 = m_strStatusBarInfo3+m_strStatusBarInfo4;
// // 
// // 		SetStatusBarInfo(m_bStatusBar,strStatus1,strStatus2);
// // 
// // 		//m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// // 		//m_strStatusBarInfo2 = _T("精度检测失败");
// // 		//SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// // 		PostMessageUpdateStatusBarInfo();
// // 
// // 		ReportPCBPrecisionFPIS(FALSE);
// // 
// // 		// 更新主界面对位精度、次数、对位总时间
// // 		CCoordPos cpProduct = GetAlignProductOffset();
// // 		m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
// // 		m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
// // 		m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;
// // 
// // 
// // 		CCoordPos cp = GetAlignPlatformOffset();
// // 		m_apAlignerProcesInfo.nTimes  = 1;
// // 		m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
// // 		m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
// // 		m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
// // 		m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);
// // 
// // 		dAlignTime=m_apAlignerProcesInfo.dTime;
// // 
// // 		PostMessageUpdateAlignerProcessInfo();	
// // 
// // 
// // 		CCoordPos cpOffset;
// // 		if (bAlignerCalculateOffset)
// // 		{
// // 			cpOffset.m_dPosX = -cpProduct.m_dPosX;
// // 			cpOffset.m_dPosY = -cpProduct.m_dPosY;
// // 			cpOffset.m_dAngle = -cpProduct.m_dAngle;
// // 		}
// // 		else
// // 		{
// // 			cpOffset.m_dPosX = 0;
// // 			cpOffset.m_dPosY = 0;
// // 			cpOffset.m_dAngle = 0;
// // 		}
// // 
// // 		if (!pCurProductData->m_pAlignerParam->SetAlignerOffset(nOffsetIndex,cpOffset))
// // 		{
// // 			m_bStatusBar = FALSE;
// // 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// // 			m_strStatusBarInfo2 = _T("精度检测失败");
// // 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 			ReportPCBPrecisionFPIS(FALSE);
// // 			return FALSE;
// // 		}
// // 
// // 		CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
// // 		if (!pAlignerParam->SetAlignerOffset(nOffsetIndex,cpOffset))
// // 		{
// // 			m_bStatusBar = FALSE;
// // 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// // 			m_strStatusBarInfo2 = _T("精度检测失败");
// // 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 			ReportPCBPrecisionFPIS(FALSE);
// // 			return FALSE;
// // 		}
// // 
// // 		if (!SaveProductDataInfo(nCurProductIndex))
// // 		{
// // 			m_bStatusBar = FALSE;
// // 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// // 			m_strStatusBarInfo2 = _T("精度检测失败");
// // 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// // 
// // 			ReportPCBPrecisionFPIS(FALSE);
// // 			return FALSE;
// // 		}
// // 
// // 		PostMessageUpdateAlignOffsetInfo();			
// // 
// // 		ReportPCBPrecisionFPIS(FALSE);
// // 
// // 		return FALSE;
// // 
// // 	}
// // 
// // 	return TRUE;  
// }

BOOL vcXYDVisionAlign::OnlineSetPCBPrecisionFCPI(int nIndex)
{
	CString strCmd = _T("VCPI:");
	CString strTempWarningType = _T("");
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || NULL == m_pMainFrameWnd /*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/ )
	{
		ReportPCBPrecisionFCPI(FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/* FALSE == m_bValidObjectSearchTool*/)
	{
		ReportPCBPrecisionFCPI(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CHANGE_PLATFORM_FAIL);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportPCBPrecisionFCPI(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 =GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CHANGE_PLATFORM_FAIL);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportPCBPrecisionFCPI(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CHANGE_PLATFORM_FAIL);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}    
	int nPlatNum = ((CVisionASMDlg*)m_pMainFrameWnd)->m_SystemConfigure.GetPlatformNum();

	if (nIndex> nPlatNum)
	{
		ReportPCBPrecisionFCPI(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PARAMETER_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CHANGE_PLATFORM_FAIL);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	BOOL bChageResult = FALSE;
	switch(nIndex)
	{
	case 0:

		break;
	case 1:
	case 2:
	case 3:
	case 4:
		{
			::PostMessage(((CVisionASMDlg*)m_pMainFrameWnd)->GetSafeHwnd(), WM_CHANGEPLATFORM, nIndex, 0);
			bChageResult = TRUE;
			Sleep(500);
		}

		break;
	}


	if(bChageResult)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CHANGE_PLATFORM_SUCCEED);;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		ReportPCBPrecisionFCPI(TRUE);
		return TRUE;


	}
	else
	{

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PARAMETER_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CHANGE_PLATFORM_FAIL);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportPCBPrecisionFCPI(FALSE);
		return FALSE;
	}

	return TRUE;


}

BOOL vcXYDVisionAlign::OnlineAlignPickExFALP(int nOffsetIndex)
{
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();

	//BOOL bDiffPosWithSameSearchResult = pAlignerParam->m_bDiffPosWithSameSearchResultEnabled;
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendMulAlignerPos = optionInfo.m_bSendMulAlignResult;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	// 一次发送多个对位结果(适用条件：单相机、多标记点模式（一个定位工具返回两个点图像坐标）、“选项”中“一次发送多个对位结果”)
	//if ( (bSendMulAlignerPos || m_nPickMutiExMode) && (bDiffPosWithSameSearchResult) && (nCamNum == 1) )
	if ( (bSendMulAlignerPos || m_nPickMutiExMode) && (nCamNum == 1) )
	{//TT 20200831 支持一次计算所有扩展的结果
		OnlineMulAlignPickExFALP(nOffsetIndex);
	}
	else
	{
		OnlineAlignExFALP(nOffsetIndex);
	}

	return TRUE;
}


BOOL vcXYDVisionAlign::OnlineAlignExFSOL(int nOffsetIndex, int nStartPatIndex)
{
	CString strCmd = _T("VSOL:");
	CString strTempWarningType = _T("");
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || NULL == m_pMainFrameWnd /*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/ )
	{
		ReportAlignResultFSOL(FALSE, TRUE);
		return FALSE;
	}


	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	stCheckInvalidTimer.Reset();
	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{
		ReportAlignResultFSOL(FALSE, TRUE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{
		ReportAlignResultFSOL(FALSE, TRUE);

		m_bStatusBar = FALSE;

		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (FALSE == m_bValidAlignerTool)
	{
		ReportAlignResultFSOL(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		ReportAlignResultFSOL(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFSOL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFSOL(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFSOL(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);


	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	BOOL bEnableFSOL  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableFSOL();
	// 	int nFSOLTargetSearchTimes = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetFSOLTargetSearchTimes();
	// 	int nFSOLSearchBench = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetFSOLSearchBench();
	// 	int nFSOLAngleBench  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetFSOLAngleBench();
	BOOL bEnableFSOL  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_bEnableWeld;
	int nFSOLTargetSearchTimes = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_nWeldTargetSearchTimes;
	int nFSOLSearchBench = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_nWeldSearchBench;
	int nFSOLAngleBench  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_nWeldAngleBench;


	if ((!optionInfo.m_bShowFWEL) || (!bEnableFSOL))
	{
		ReportAlignResultFSOL(FALSE, TRUE);

		m_bStatusBar = FALSE;

		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_WELD_PARAM_ERROR);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 目标零次定位
	if (2 == nFSOLTargetSearchTimes)
	{
		if (eTargetOnline == pCurProductData->m_pAlignerParam->m_eTargetMarkType)
		{
			if (FALSE == m_bTargetMarkSearchSucceed)
			{
				ReportAlignResultFSOL(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;
			}
		}
	}

	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);


	// 获取当前产品最大对位次数
	int nMaxAlignTime = pCurProductData->m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);


	CCoordPos cpAlignBenchOffsetObject;
	CCoordPos cpAlignBenchOffsetTarget;
	CCoordPos cpAlignBenchOffset;


	for (i=0; i<nMaxAlignTime+1; i++)
	{
		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();

		stObjectSearchTimer.Reset();
		m_nAlignTime = i+1;

		// 目标定位
		// 目标多次定位
		if (0 == nFSOLTargetSearchTimes)
		{
			if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
			{
				ReportAlignResultFSOL(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;  
			}
		}
		// 目标一次定位
		else if (1 == nFSOLTargetSearchTimes)
		{
			if (1 == m_nAlignTime)
			{
				if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
				{
					ReportAlignResultFSOL(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;  
				}
			}
		}
		// 目标零次定位
		else if (2 == nFSOLTargetSearchTimes)
		{

		}

		// 对象定位
		if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
		{
			ReportAlignResultFSOL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;     			
		}

		dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);


		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFSOL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}

		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 

		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			CCoordPos cp = GetAlignPlatformOffset();

			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFSOL(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;
			double dWeldMovementRatioD = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dAngle;
			if (dWeldMovementRatioX !=1.0 || dWeldMovementRatioY !=1.0 || dWeldMovementRatioD !=1.0 )
			{
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY,dWeldMovementRatioD);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFSOL(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				CCoordPos cpProduct = GetAlignProductOffset();
				m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
				m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
				m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

				CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

				m_apAlignerProcesInfo.nTimes  = i+1;
				m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
				m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
				m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
				m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

				PostMessageUpdateAlignerProcessInfo();

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				//////////////////////////////////////////////////////////////////////////
				// （X,Y）对象判定为基准
				if (0 == nFSOLSearchBench)
				{
					// 对象定位
					if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
					{
						ReportAlignResultFSOL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

						return FALSE;     			
					}

					// 判断对象两Mark为0度或90度附近
					BOOL bZeroAngle = IsObjectMarksZeroAngle();


					// 计算对象与图像中心距离
					// 设置图像中心十字基准目标
					SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
					m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

					// 执行对位
					m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
					if(FALSE == ExecuteAlign(i))
					{
						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						ReportAlignResultFSOL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
						//						m_strStatusBarInfo2 = _T("");
						m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();		

						return FALSE;     
					}

					// 获取对位结果
					cpAlignBenchOffsetObject = GetAlignPlatformOffset();

					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					//设置实时对象
					m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
					double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

					cpAlignBenchOffset = cpAlignBenchOffsetObject;
					cpAlignBenchOffset.m_dPosX = cpAlignBenchOffset.m_dPosX * dWeldAmmendMovementRatioX;
					cpAlignBenchOffset.m_dPosY = cpAlignBenchOffset.m_dPosY * dWeldAmmendMovementRatioY;
					cpAlignBenchOffset.m_dAngle = cpAlignBenchOffset.m_dAngle;
				}
				// （X,Y）目标判定为基准
				else if (1 == nFSOLSearchBench)
				{
					if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
					{
						ReportAlignResultFSOL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

						return FALSE;  
					}

					// 判断目标两Mark为0度或90度附近
					BOOL bZeroAngle = IsTargetMarksZeroAngle();

					// 设置图像中心十字基准目标
					SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
					m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

					//计算目标与图像中心距离
					m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);

					// 执行对位
					m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
					if(FALSE == ExecuteAlign(i))
					{
						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						ReportAlignResultFSOL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
						//						m_strStatusBarInfo2 = _T("");
						m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();		

						return FALSE;     
					}

					// 获取对位结果
					cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					//设置实时对象
					m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
					double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

					cpAlignBenchOffset = cpAlignBenchOffsetTarget;
					cpAlignBenchOffset.m_dPosX = cpAlignBenchOffsetTarget.m_dPosX * dWeldAmmendMovementRatioX;
					cpAlignBenchOffset.m_dPosY = cpAlignBenchOffsetTarget.m_dPosY * dWeldAmmendMovementRatioY;
					cpAlignBenchOffset.m_dAngle = cpAlignBenchOffset.m_dAngle;
				}
				// （X,Y）判定没有基准
				else if (2 == nFSOLSearchBench)
				{
					cpAlignBenchOffset.m_dPosX = 0;
					cpAlignBenchOffset.m_dPosY = 0;
					cpAlignBenchOffset.m_dAngle = 0;
				}

				ReportAlignResultFSOL(TRUE,TRUE,cpAlignBenchOffset);

				return TRUE;
			}

		} // 执行一次对位


		// 多次对对位
		// 判断是否执行对位动作
		if (TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 最后一次对位时发生产品角度
			//////////////////////////////////////////////////////////////////////////
			// 			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			// 			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			// 
			// 			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			// 			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;
			// 			double dWeldMovementRatioD = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dAngle; 
			// 
			// 			if (dWeldMovementRatioX != 1.0 || dWeldMovementRatioY != 1.0 || dWeldMovementRatioD != 1.0)
			// 			{
			// 				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY,dWeldMovementRatioD);
			// 			}
			// 
			// 			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			// 			stCommunicateTimer.Reset();
			// 			// 通信驱动平台运动到指定位置
			// 			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			// 			{
			// 				ReportAlignResultFSOL(FALSE, TRUE);
			// 				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
			// 
			// 				m_bStatusBar = FALSE;
			// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
			// 				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
			// 
			// 				SaveCurAllCameraChannelSearchImg();
			// 				return FALSE;     
			// 			}
			// 			else
			{
				// 				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				// 				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				CCoordPos cpProduct = GetAlignProductOffset();
				m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
				m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
				m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

				CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

				m_apAlignerProcesInfo.nTimes  = i+1;
				m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
				m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
				m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
				m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

				PostMessageUpdateAlignerProcessInfo();

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);

				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 				// 记录当前平台各个轴的绝对位置
				// 				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				// 				{
				// 					CString strTemp;
				// 
				// 					CString strInfo;
				// 					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
				// 						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
				// 					strInfo = strTemp + strInfo;
				// 
				// 					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				// 					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				// 				}
			}
			//////////////////////////////////////////////////////////////////////////

			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
				//////////////////////////////////////////////////////////////////////////

				// 对象判定为基准
				if (0 == nFSOLSearchBench)
				{
					// 对象定位
					if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
					{
						ReportAlignResultFSOL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

						return FALSE;     			
					}

					// 判断对象两Mark为0度或90度附近
					BOOL bZeroAngle = IsObjectMarksZeroAngle();

					// 计算对象与图像中心距离
					// 设置图像中心十字基准目标
					SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
					m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

					// 执行对位
					m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
					if(FALSE == ExecuteAlign(i))
					{
						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						ReportAlignResultFSOL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
						//						m_strStatusBarInfo2 = _T("");
						m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();		

						return FALSE;     
					}

					// 获取对位结果
					cpAlignBenchOffsetObject = GetAlignPlatformOffset();

					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					//设置实时对象
					m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
					double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

					cpAlignBenchOffset = cpAlignBenchOffsetObject;
					cpAlignBenchOffset.m_dPosX = cpAlignBenchOffset.m_dPosX * dWeldAmmendMovementRatioX;
					cpAlignBenchOffset.m_dPosY = cpAlignBenchOffset.m_dPosY * dWeldAmmendMovementRatioY;
					cpAlignBenchOffset.m_dAngle = cpAlignBenchOffset.m_dAngle;

				}
				// 目标判定为基准
				else if (1 == nFSOLSearchBench)
				{
					if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
					{
						ReportAlignResultFSOL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

						return FALSE;  
					}

					// 判断目标两Mark为0度或90度附近
					BOOL bZeroAngle = IsTargetMarksZeroAngle();

					// 设置图像中心十字基准目标
					SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
					m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

					//计算目标与图像中心距离
					m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);

					// 执行对位
					m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
					if(FALSE == ExecuteAlign(i))
					{
						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						ReportAlignResultFSOL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
						//						m_strStatusBarInfo2 = _T("");
						m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();		

						return FALSE;     
					}

					// 获取对位结果
					cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					//设置实时对象
					m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
					double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

					cpAlignBenchOffset = cpAlignBenchOffsetTarget;
					cpAlignBenchOffset.m_dPosX = cpAlignBenchOffsetTarget.m_dPosX * dWeldAmmendMovementRatioX;
					cpAlignBenchOffset.m_dPosY = cpAlignBenchOffsetTarget.m_dPosY * dWeldAmmendMovementRatioY;
					//cpAlignBenchOffset.m_dAngle = 0;
					cpAlignBenchOffset.m_dAngle =cpAlignBenchOffset.m_dAngle;
				}
				// 判定没有基准
				else if (2 == nFSOLSearchBench)
				{
					cpAlignBenchOffset.m_dPosX = 0;
					cpAlignBenchOffset.m_dPosY = 0;
					cpAlignBenchOffset.m_dAngle = 0;
				}

				ReportAlignResultFSOL(TRUE,TRUE,cpAlignBenchOffset);
			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFSOL(FALSE, TRUE);

				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

			return m_bStatusBar;  
		}
		else
		{
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			CCoordPos cp = GetAlignPlatformOffset();

			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFSOL(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;
			double dWeldMovementRatioD = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dAngle;
			if (dWeldMovementRatioX != 1.0 || dWeldMovementRatioY != 1.0 || dWeldMovementRatioD != 1.0)
			{
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY,dWeldMovementRatioD);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFSOL(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				CCoordPos cpProduct = GetAlignProductOffset();
				m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
				m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
				m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

				CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

				m_apAlignerProcesInfo.nTimes  = i+1;
				m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
				m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
				m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
				m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

				PostMessageUpdateAlignerProcessInfo();

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

		} // else 

	}// for	


	if (0 == nFSOLSearchBench)
	{
		// 对象定位
		if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
		{
			ReportAlignResultFSOL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;     			
		}

		// 判断对象两Mark为0度或90度附近
		BOOL bZeroAngle = IsObjectMarksZeroAngle();

		// 计算对象与图像中心距离
		// 设置图像中心十字基准目标
		SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
		m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

		// 执行对位
		m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
		if(FALSE == ExecuteAlign())
		{
			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

			//设置实时对象
			m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			ReportAlignResultFSOL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			return FALSE;     
		}

		// 获取对位结果
		cpAlignBenchOffsetObject = GetAlignPlatformOffset();

		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

		//设置实时对象
		m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
		m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

		// 设置实时的目标
		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

		// 		cpAlignBenchOffset = cpAlignBenchOffsetObject;
		// 		cpAlignBenchOffset.m_dPosX = cpAlignBenchOffset.m_dPosX*pAlignerParam->GetAmmendMovementRatioX();
		// 		cpAlignBenchOffset.m_dPosY = cpAlignBenchOffset.m_dPosY*pAlignerParam->GetAmmendMovementRatioY();
		// 		cpAlignBenchOffset.m_dAngle = 0;


		double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
		double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

		cpAlignBenchOffset = cpAlignBenchOffsetObject;
		cpAlignBenchOffset.m_dPosX = cpAlignBenchOffset.m_dPosX * dWeldAmmendMovementRatioX;
		cpAlignBenchOffset.m_dPosY = cpAlignBenchOffset.m_dPosY * dWeldAmmendMovementRatioY;
		//cpAlignBenchOffset.m_dAngle = 0;
		cpAlignBenchOffset.m_dAngle = cpAlignBenchOffset.m_dAngle;

	}
	// 目标判定为基准
	else if (1 == nFSOLSearchBench)
	{
		if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
		{
			ReportAlignResultFSOL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;  
		}

		// 判断目标两Mark为0度或90度附近
		BOOL bZeroAngle = IsTargetMarksZeroAngle();

		// 设置图像中心十字基准目标
		SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
		m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

		//计算目标与图像中心距离
		m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);

		// 执行对位
		m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
		if(FALSE == ExecuteAlign())
		{
			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


			//设置实时对象
			m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			ReportAlignResultFSOL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			return FALSE;     
		}

		// 获取对位结果
		cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

		//设置实时对象
		m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
		m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

		// 设置实时的目标
		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

		// 		cpAlignBenchOffset = cpAlignBenchOffsetTarget;
		// 		cpAlignBenchOffset.m_dPosX = cpAlignBenchOffsetTarget.m_dPosX * pAlignerParam->GetAmmendMovementRatioX();
		// 		cpAlignBenchOffset.m_dPosY = cpAlignBenchOffsetTarget.m_dPosY * pAlignerParam->GetAmmendMovementRatioY();
		// 		cpAlignBenchOffset.m_dAngle = 0;


		double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
		double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

		cpAlignBenchOffset = cpAlignBenchOffsetTarget;
		cpAlignBenchOffset.m_dPosX = cpAlignBenchOffsetTarget.m_dPosX * dWeldAmmendMovementRatioX;
		cpAlignBenchOffset.m_dPosY = cpAlignBenchOffsetTarget.m_dPosY * dWeldAmmendMovementRatioY;
		//cpAlignBenchOffset.m_dAngle = 0;
		cpAlignBenchOffset.m_dAngle = cpAlignBenchOffset.m_dAngle;

	}
	// 判定没有基准
	else if (2 == nFSOLSearchBench)
	{
		cpAlignBenchOffset.m_dPosX = 0;
		cpAlignBenchOffset.m_dPosY = 0;
		cpAlignBenchOffset.m_dAngle = 0;
	}

	ReportAlignResultFSOL(TRUE,TRUE,cpAlignBenchOffset);


	return TRUE;

}




BOOL vcXYDVisionAlign::OnlineAlignExFWEL(int nOffsetIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strTempWarningType = _T("");
	CString strCmd = _T("");
	GetCommCommandName(strCmd);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);

	stCheckInvalidTimer.Reset();
	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{

		ReportAlignResultFWEL(FALSE, TRUE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{
		ReportAlignResultFWEL(FALSE, TRUE);

		m_bStatusBar = FALSE;

		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (FALSE == m_bValidAlignerTool)
	{
		ReportAlignResultFWEL(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		ReportAlignResultFWEL(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFWEL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFWEL(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFWEL(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);


	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 	BOOL bEnableFWEL  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableFWEL();
	// 	int nFWELTargetSearchTimes = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetFWELTargetSearchTimes();
	// 	int nFWELSearchBench = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetFWELSearchBench();
	// 	int nFWELAngleBench  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetFWELAngleBench();
	BOOL bEnableFWEL  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_bEnableWeld;
	int nFWELTargetSearchTimes = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_nWeldTargetSearchTimes;
	int nFWELSearchBench = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_nWeldSearchBench;
	int nFWELAngleBench  = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetWeldInfo().m_nWeldAngleBench;


	if ((!optionInfo.m_bShowFWEL) || (!bEnableFWEL))
	{
		ReportAlignResultFWEL(FALSE, TRUE);

		m_bStatusBar = FALSE;

		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_WELD_PARAM_ERROR);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 目标零次定位
	if (2 == nFWELTargetSearchTimes)
	{
		if (eTargetOnline == pCurProductData->m_pAlignerParam->m_eTargetMarkType)
		{
			if (FALSE == m_bTargetMarkSearchSucceed)
			{
				ReportAlignResultFWEL(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;
			}
		}
	}

	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);


	// 获取当前产品最大对位次数
	int nMaxAlignTime = pCurProductData->m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);

	CCoordPos cpAlignBenchOffsetObject;
	CCoordPos cpAlignBenchOffsetTarget;
	CCoordPos cpAlignBenchOffset;


	// 	if ((2 == nFWELSearchBench) && (bEnableFWEL))
	// 	{
	// 
	// 		double dAuxImageX0 = m_mpTargetMarkImagePos.GetMarkImagePos(0).GetAuxiliaryPosX(0);
	// 		double dAuxImageY0 = m_mpTargetMarkImagePos.GetMarkImagePos(0).GetAuxiliaryPosY(0);
	// 
	// 		double dAuxImageX1 = m_mpTargetMarkImagePos.GetMarkImagePos(1).GetAuxiliaryPosX(0);
	// 		double dAuxImageY1 = m_mpTargetMarkImagePos.GetMarkImagePos(1).GetAuxiliaryPosY(0);
	// 
	// 		//double dAuxImageX0,dAuxImageY0,dAuxImageX1,dAuxImageY1;
	// 
	// 		// 判断目标两Mark为0度或90度附近
	// 		//BOOL bZeroAngle = IsTargetMarksZeroAngle();
	// 
	// 		//if (bZeroAngle)
	// 		//{
	// 		//	dAuxImageX0 = 0;
	// 		//	dAuxImageY0 = GetPosDisplay(0)->GetImageHeight()/2.0;
	// 		//	dAuxImageX1 = GetPosDisplay(0)->GetImageWidth();
	// 		//	dAuxImageY1 = GetPosDisplay(0)->GetImageHeight()/2.0;
	// 		//} 
	// 		//else
	// 		//{
	// 		//	dAuxImageX0 = GetPosDisplay(0)->GetImageWidth()/2.0;
	// 		//	dAuxImageY0 = 0;
	// 		//	dAuxImageX1 = GetPosDisplay(0)->GetImageWidth()/2.0;
	// 		//	dAuxImageY1 = GetPosDisplay(0)->GetImageHeight();
	// 		//}
	// 
	// 		CCoordPos ImagePos0 (dAuxImageX0, dAuxImageY0, 0);
	// 		CCoordPos ImagePos1 (dAuxImageX1, dAuxImageY1, 0);
	// 
	// 		m_mpCrossBenchMarkImagePos.SetMarkImagePos(0, TRUE, ImagePos0);
	// 		m_mpCrossBenchMarkImagePos.SetMarkImagePos(1, TRUE, ImagePos1);
	// 
	// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	// 		{
	// 			CString strTemp;
	// 			CString strOut;
	// 			strOut.Format(_T("目标辅助点图像坐标：X1 = %f, Y1 = %f ; X2 = %f, Y2 = %f"), dAuxImageX0, dAuxImageY0, dAuxImageX1, dAuxImageY1);
	// 
	// 			strOut = strTemp + strOut;
	// 
	// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	// 			VisionAlignLogRecord(m_strAlignProcessData, strOut);
	// 		}
	// 
	// 
	// 		//SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
	// 		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
	// 		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	// 
	// 		//计算目标与图像中心距离
	// 		m_pAlignerTool->SetObjectPlatformPos(m_vpCrossBenchPlatformAxisPos);
	// 		m_pAlignerTool->SetObjectMarkSearchResults(m_mpCrossBenchMarkImagePos);
	// 
	// 
	// 		// 执行对位
	// 		m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
	// 		if(FALSE == ExecuteAlign())
	// 		{
	// 			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效
	// 
	// 
	// 			//设置实时对象
	// 			m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
	// 			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	// 			// 设置实时的目标
	// 			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
	// 			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	// 
	// 			ReportAlignResultFWEL(FALSE, TRUE);
	// 
	// 			m_bStatusBar = FALSE;
	// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
	// //			m_strStatusBarInfo2 = _T("");
	// 			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
	// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	// 			PostMessageUpdateStatusBarInfo();		
	// 
	// 			return FALSE;     
	// 		}
	// 
	// 		// 获取对位结果
	// 		cpAlignBenchOffsetTarget = GetAlignPlatformOffset();
	// 
	// 		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效
	// 
	// 		//设置实时对象
	// 		m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
	// 		m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
	// 
	// 		// 设置实时的目标
	// 		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
	// 		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
	// 
	// 		cpAlignBenchOffset = cpAlignBenchOffsetTarget;
	// 		cpAlignBenchOffset.m_dPosX = cpAlignBenchOffsetTarget.m_dPosX * pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
	// 		cpAlignBenchOffset.m_dPosY = cpAlignBenchOffsetTarget.m_dPosY * pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;
	// 		cpAlignBenchOffset.m_dAngle = cpAlignBenchOffset.m_dAngle;
	// 
	// 
	// 		// 记录对位精度
	// 		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	// 		{
	// 			CString strTemp;
	// 
	// 			CString strOut;
	// 			strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
	// 				i+1, cpAlignBenchOffsetTarget.GetPosX(), cpAlignBenchOffsetTarget.GetPosY(), cpAlignBenchOffsetTarget.GetAngle());
	// 			strOut = strTemp + strOut;
	// 
	// 			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
	// 			VisionAlignLogRecord(m_strAlignProcessData, strOut);
	// 		}
	// 
	// 	}


	for (i=0; i<nMaxAlignTime+1; i++)
	{
		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();

		stObjectSearchTimer.Reset();
		m_nAlignTime = i+1;

		// 目标定位
		// 目标多次定位
		if (0 == nFWELTargetSearchTimes)
		{
			if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
			{
				ReportAlignResultFWEL(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;  
			}
		}
		// 目标一次定位
		else if (1 == nFWELTargetSearchTimes)
		{
			if (1 == m_nAlignTime)
			{
				if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
				{
					ReportAlignResultFWEL(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;  
				}
			}
		}
		// 目标零次定位
		else if (2 == nFWELTargetSearchTimes)
		{

		}

		// 对象定位
		if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
		{
			ReportAlignResultFWEL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;     			
		}

		dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);


		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFWEL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}

		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 

		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			CCoordPos cp = GetAlignPlatformOffset();

			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFWEL(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;
			if (dWeldMovementRatioX !=1.0 || dWeldMovementRatioY !=1.0)
			{
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY);
			}

			// 计算产品角度
			// 对位时返回图像中心直线与目标直线之间的角度
			//////////////////////////////////////////////////////////////////////////
			if (1 == nFWELAngleBench)
			{
				CCoordPos cpTarget1;
				CCoordPos cpTarget2;
				int nPosNum = m_pPlatformInfo->m_nPositionNum;
				int nCamNum = m_pPlatformInfo->m_nCamNum;
				if (2 == nPosNum && 1 == nCamNum)
				{
					cpTarget1 = m_mpTargetMarkImagePos.GetMarkImagePos(0);
					cpTarget2 = m_mpTargetMarkImagePos.GetMarkImagePos(1);

					// 目标直线
					scLine LineTarget;
					scLineSeg lineSegTarget(sc2Vector(cpTarget1.m_dPosX, cpTarget1.m_dPosY), sc2Vector(cpTarget2.m_dPosX, cpTarget2.m_dPosY));
					LineTarget.SetFromLineSeg(lineSegTarget);

					// 目标直线角度
					scRadian LineTargetRad = LineTarget.GetRotation().SignedNormMod180();
					double dLineTargetAngle = scDegree(scRadian(LineTargetRad)).ToDouble();

					// 目标为水平直线
					double dImageCenterAngle = 0;
					if (fabs(dLineTargetAngle) <= 45)
					{
						dImageCenterAngle = 0;
					}
					// 目标为垂直直线
					else if (fabs(dLineTargetAngle) > 45)
					{
						dImageCenterAngle = 90;
					}


					// 图像中心直线
					double dImageCenterX = GetPosDisplay(0)->GetImageWidth()/2;
					double dImageCenterY = GetPosDisplay(0)->GetImageHeight()/2;
					scLine ImageCenter(sc2Vector(dImageCenterX, dImageCenterY), scRadian(scDegree(dImageCenterAngle)));

					// 目标直线与图像中心直线角度
					scRadian rad;
					bool bIsOK = sfAngleLine2Line(ImageCenter, LineTarget, rad);
					double dAngle= rad.SignedNormMod180().ToDouble()*180.0/skPI;

					CPlatformXYDInfo *pPlatformXYDInfo = (CPlatformXYDInfo*)m_pPlatformInfo;
					if (pPlatformXYDInfo->m_nPlatformDCoordType == eDirectNegative)
					{
						dAngle = -1*dAngle;
					}

					pPlatformXYDAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dAngle + dAngle;

				}
			}
			// 对位时返回图像中心直线与对象直线之间的角度
			else if (0 == nFWELAngleBench)
			{
				CCoordPos cpObject1;
				CCoordPos cpObject2;
				int nPosNum = m_pPlatformInfo->m_nPositionNum;
				int nCamNum = m_pPlatformInfo->m_nCamNum;
				if (2 == nPosNum && 1 == nCamNum)
				{
					cpObject1 = m_mpObjectMarkImagePos.GetMarkImagePos(0);
					cpObject2 = m_mpObjectMarkImagePos.GetMarkImagePos(1);

					// 对象直线
					scLine LineObject;
					scLineSeg lineSegTarget(sc2Vector(cpObject1.m_dPosX, cpObject1.m_dPosY), sc2Vector(cpObject2.m_dPosX, cpObject2.m_dPosY));
					LineObject.SetFromLineSeg(lineSegTarget);

					// 对象直线角度
					scRadian LineObjectRad = LineObject.GetRotation().SignedNormMod180();
					double dLineObjectAngle = scDegree(scRadian(LineObjectRad)).ToDouble();

					// 对象为水平直线
					double dImageCenterAngle = 0;
					if (fabs(dLineObjectAngle) <= 45)
					{
						dImageCenterAngle = 0;
					}
					// 对象为垂直直线
					else if (fabs(dLineObjectAngle) > 45)
					{
						dImageCenterAngle = 90;
					}


					// 图像中心直线
					double dImageCenterX = GetPosDisplay(0)->GetImageWidth()/2;
					double dImageCenterY = GetPosDisplay(0)->GetImageHeight()/2;
					scLine ImageCenter(sc2Vector(dImageCenterX, dImageCenterY), scRadian(scDegree(dImageCenterAngle)));

					// 对象直线与图像中心直线角度
					scRadian rad;
					bool bIsOK = sfAngleLine2Line(ImageCenter, LineObject, rad);
					double dAngle= rad.SignedNormMod180().ToDouble()*180.0/skPI;

					CPlatformXYDInfo *pPlatformXYDInfo = (CPlatformXYDInfo*)m_pPlatformInfo;
					if (pPlatformXYDInfo->m_nPlatformDCoordType == eDirectNegative)
					{
						dAngle = -1*dAngle;
					}

					pPlatformXYDAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dAngle + dAngle;

				}
			}
			else if (2 == nFWELAngleBench)
			{
				// 角度无基准时，返回当前轴位置的角度
				pPlatformXYDAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dAngle;
			}
			//////////////////////////////////////////////////////////////////////////

			if ( (0 == nFWELAngleBench) || (1 == nFWELAngleBench) )
			{
				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFWEL(FALSE, TRUE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();	

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();

					return FALSE;     
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

					CCoordPos cpProduct = GetAlignProductOffset();
					m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
					m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
					m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

					CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

					m_apAlignerProcesInfo.nTimes  = i+1;
					m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
					m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
					m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
					m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

					PostMessageUpdateAlignerProcessInfo();

					m_bStatusBar = TRUE;
					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
					m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

					dAlignTime = m_apAlignerProcesInfo.dTime;

					// 记录对位精度
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
					{
						CString strTemp;

						CString strOut;
						strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
							i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
						strOut = strTemp + strOut;

						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					}

					// 记录对位时间
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
					{
						CString strTemp;

						CString strOut;
						strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
						strOut = strTemp + strOut;

						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					}

					// 记录当前平台各个轴的绝对位置
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
					{
						CString strTemp;

						CString strInfo;
						strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
							i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
						strInfo = strTemp + strInfo;

						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strInfo);
					}

					//////////////////////////////////////////////////////////////////////////
					// （X,Y）对象判定为基准
					if (0 == nFWELSearchBench)
					{
						// 对象定位
						if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
						{
							ReportAlignResultFWEL(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

							return FALSE;     			
						}

						// 判断对象两Mark为0度或90度附近
						BOOL bZeroAngle = IsObjectMarksZeroAngle();

						// 计算对象与图像中心距离
						// 设置图像中心十字基准目标
						SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
						m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

						// 执行对位
						m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFWEL(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//						m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetObject = GetAlignPlatformOffset();

						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
						double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

						cpAlignBenchOffset = cpAlignBenchOffsetObject;
						cpAlignBenchOffset.m_dPosX = cpAlignBenchOffset.m_dPosX * dWeldAmmendMovementRatioX;
						cpAlignBenchOffset.m_dPosY = cpAlignBenchOffset.m_dPosY * dWeldAmmendMovementRatioY;

					}
					// （X,Y）目标判定为基准
					else if (1 == nFWELSearchBench)
					{
						if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
						{
							ReportAlignResultFWEL(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
							m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

							return FALSE;  
						}

						// 判断对象两Mark为0度或90度附近
						BOOL bZeroAngle = IsTargetMarksZeroAngle();
						// 设置图像中心十字基准目标
						SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
						m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

						//计算目标与图像中心距离
						m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);

						// 执行对位
						m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFWEL(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//						m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
						double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

						cpAlignBenchOffset = cpAlignBenchOffsetTarget;
						cpAlignBenchOffset.m_dPosX = cpAlignBenchOffsetTarget.m_dPosX * dWeldAmmendMovementRatioX;
						cpAlignBenchOffset.m_dPosY = cpAlignBenchOffsetTarget.m_dPosY * dWeldAmmendMovementRatioY;

					}
					// （X,Y）判定没有基准
					else if (2 == nFWELSearchBench)
					{
						cpAlignBenchOffset.m_dPosX = 0;
						cpAlignBenchOffset.m_dPosY = 0;
						cpAlignBenchOffset.m_dAngle = 0;
					}

					ReportAlignResultFWEL(TRUE,TRUE,cpAlignBenchOffset);

					return TRUE;
				}
			}

		} // 执行一次对位


		// 多次对对位
		// 判断是否执行对位动作
		if (TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 最后一次对位时发生产品角度
			//////////////////////////////////////////////////////////////////////////
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;

			if (dWeldMovementRatioX != 1.0 || dWeldMovementRatioY != 1.0)
			{
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY);
			}

			// 计算产品角度
			// 对位时返回图像中心直线与目标直线之间的角度
			//////////////////////////////////////////////////////////////////////////
			if (1 == nFWELAngleBench)
			{
				CCoordPos cpTarget1;
				CCoordPos cpTarget2;
				int nPosNum = m_pPlatformInfo->m_nPositionNum;
				int nCamNum = m_pPlatformInfo->m_nCamNum;
				if (2 == nPosNum && 1 == nCamNum)
				{
					cpTarget1 = m_mpTargetMarkImagePos.GetMarkImagePos(0);
					cpTarget2 = m_mpTargetMarkImagePos.GetMarkImagePos(1);

					// 目标直线
					scLine LineTarget;
					scLineSeg lineSegTarget(sc2Vector(cpTarget1.m_dPosX, cpTarget1.m_dPosY), sc2Vector(cpTarget2.m_dPosX, cpTarget2.m_dPosY));
					LineTarget.SetFromLineSeg(lineSegTarget);

					// 目标直线角度
					scRadian LineTargetRad = LineTarget.GetRotation().SignedNormMod180();
					double dLineTargetAngle = scDegree(scRadian(LineTargetRad)).ToDouble();


					// 目标为水平直线
					double dImageCenterAngle = 0;
					if (fabs(dLineTargetAngle) <= 45)
					{
						dImageCenterAngle = 0;

					}
					// 目标为垂直直线
					else if (fabs(dLineTargetAngle) > 45)
					{
						dImageCenterAngle = 90;
					}

					// 图像中心直线
					double dImageCenterX = GetPosDisplay(0)->GetImageWidth()/2;
					double dImageCenterY = GetPosDisplay(0)->GetImageHeight()/2;
					scLine ImageCenter(sc2Vector(dImageCenterX, dImageCenterY), scRadian(scDegree(dImageCenterAngle)));

					// 目标直线与图像中心直线角度
					scRadian rad;
					bool bIsOK = sfAngleLine2Line(ImageCenter, LineTarget, rad);
					double dAngle= rad.SignedNormMod180().ToDouble()*180.0/skPI;

					CPlatformXYDInfo *pPlatformXYDInfo = (CPlatformXYDInfo*)m_pPlatformInfo;
					if (pPlatformXYDInfo->m_nPlatformDCoordType == eDirectNegative)
					{
						dAngle = -1*dAngle;
					}

					// 0次对位：XY为当前轴位置；D为当前轴D1+产品与图像中心的角度D2
					if ((m_bAutoAlign == TRUE && m_nAlignTime == 1) || (m_bAutoAlign == FALSE))
					{
						pPlatformXYDAxisPos->m_dPosX  = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dPosX;
						pPlatformXYDAxisPos->m_dPosY  = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dPosY;
						pPlatformXYDAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dAngle + dAngle;
					}
					else
					{
						pPlatformXYDAxisPos->m_dPosX = m_CurPlatformAxisPos.m_dPosX;
						pPlatformXYDAxisPos->m_dPosY = m_CurPlatformAxisPos.m_dPosY;
						pPlatformXYDAxisPos->m_dAngle = m_CurPlatformAxisPos.m_dAngle + dAngle;
					}
				}
			}
			// 对位时返回图像中心直线与对象直线之间的角度
			else if (0 == nFWELAngleBench)
			{
				CCoordPos cpObject1;
				CCoordPos cpObject2;
				int nPosNum = m_pPlatformInfo->m_nPositionNum;
				int nCamNum = m_pPlatformInfo->m_nCamNum;
				if (2 == nPosNum && 1 == nCamNum)
				{
					cpObject1 = m_mpObjectMarkImagePos.GetMarkImagePos(0);
					cpObject2 = m_mpObjectMarkImagePos.GetMarkImagePos(1);

					// 对象直线
					scLine LineObject;
					scLineSeg lineSegTarget(sc2Vector(cpObject1.m_dPosX, cpObject1.m_dPosY), sc2Vector(cpObject2.m_dPosX, cpObject2.m_dPosY));
					LineObject.SetFromLineSeg(lineSegTarget);

					// 对象直线角度
					scRadian LineObjectRad = LineObject.GetRotation().SignedNormMod180();
					double dLineObjectAngle = scDegree(scRadian(LineObjectRad)).ToDouble();

					// 对象为水平直线
					double dImageCenterAngle = 0;
					if (fabs(dLineObjectAngle) <= 45)
					{
						dImageCenterAngle = 0;

					}
					// 对象为垂直直线
					else if (fabs(dLineObjectAngle) > 45)
					{
						dImageCenterAngle = 90;
					}


					// 图像中心直线
					double dImageCenterX = GetPosDisplay(0)->GetImageWidth()/2;
					double dImageCenterY = GetPosDisplay(0)->GetImageHeight()/2;
					scLine ImageCenter(sc2Vector(dImageCenterX, dImageCenterY), scRadian(scDegree(dImageCenterAngle)));

					// 对象直线与图像中心直线角度
					scRadian rad;
					bool bIsOK = sfAngleLine2Line(ImageCenter, LineObject, rad);
					double dAngle= rad.SignedNormMod180().ToDouble()*180.0/skPI;

					CPlatformXYDInfo *pPlatformXYDInfo = (CPlatformXYDInfo*)m_pPlatformInfo;
					if (pPlatformXYDInfo->m_nPlatformDCoordType == eDirectNegative)
					{
						dAngle = -1*dAngle;
					}

					// 0次对位：XY为当前轴位置；D为当前轴D1+产品与图像中心的角度D2
					if ((m_bAutoAlign == TRUE && m_nAlignTime == 1) || (m_bAutoAlign == FALSE))
					{
						pPlatformXYDAxisPos->m_dPosX  = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dPosX;
						pPlatformXYDAxisPos->m_dPosY  = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dPosY;
						pPlatformXYDAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dAngle + dAngle;


					}
					else
					{
						pPlatformXYDAxisPos->m_dPosX = m_CurPlatformAxisPos.m_dPosX;
						pPlatformXYDAxisPos->m_dPosY = m_CurPlatformAxisPos.m_dPosY;
						pPlatformXYDAxisPos->m_dAngle = m_CurPlatformAxisPos.m_dAngle + dAngle;
					}

				}
			}
			// 对位时角度没有基准
			else if (2 == nFWELAngleBench)
			{
				// 0次对位：XY为当前轴位置；D为当前轴D1+产品与图像中心的角度D2
				if ((m_bAutoAlign == TRUE && m_nAlignTime == 1) || (m_bAutoAlign == FALSE))
				{
					pPlatformXYDAxisPos->m_dPosX  = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dPosX;
					pPlatformXYDAxisPos->m_dPosY  = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dPosY;
					pPlatformXYDAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dAngle;
				}
				else
				{
					pPlatformXYDAxisPos->m_dPosX = m_CurPlatformAxisPos.m_dPosX;
					pPlatformXYDAxisPos->m_dPosY = m_CurPlatformAxisPos.m_dPosY;
					pPlatformXYDAxisPos->m_dAngle = m_CurPlatformAxisPos.m_dAngle;
				}
			}

			//////////////////////////////////////////////////////////////////////////


			if ( (0 == nFWELAngleBench) || (1 == nFWELAngleBench) )
			{
				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFWEL(FALSE, TRUE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();

					return FALSE;     
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

					CCoordPos cpProduct = GetAlignProductOffset();
					m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
					m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
					m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

					CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

					m_apAlignerProcesInfo.nTimes  = i+1;
					m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
					m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
					m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
					m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

					PostMessageUpdateAlignerProcessInfo();

					m_bStatusBar = TRUE;
					m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
					m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

					dAlignTime = m_apAlignerProcesInfo.dTime;

					// 记录对位精度
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
					{
						CString strTemp;

						CString strOut;
						strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
							i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
						strOut = strTemp + strOut;

						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strOut);

					}

					// 记录对位时间
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
					{
						CString strTemp;

						CString strOut;
						strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
						strOut = strTemp + strOut;

						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					}

					// 记录当前平台各个轴的绝对位置
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
					{
						CString strTemp;

						CString strInfo;
						strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
							i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
						strInfo = strTemp + strInfo;

						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strInfo);
					}
				}
			}


			//////////////////////////////////////////////////////////////////////////

			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
				//////////////////////////////////////////////////////////////////////////

				// 对象判定为基准
				if (0 == nFWELSearchBench)
				{
					// 对象定位
					if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
					{
						ReportAlignResultFWEL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

						return FALSE;     			
					}

					// 判断对象两Mark为0度或90度附近
					BOOL bZeroAngle = IsObjectMarksZeroAngle();
					// 计算对象与图像中心距离
					// 设置图像中心十字基准目标
					SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
					m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

					// 执行对位
					m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
					if(FALSE == ExecuteAlign(i))
					{
						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						ReportAlignResultFWEL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
						//						m_strStatusBarInfo2 = _T("");
						m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();		

						return FALSE;     
					}

					// 获取对位结果
					cpAlignBenchOffsetObject = GetAlignPlatformOffset();

					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					//设置实时对象
					m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
					double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

					cpAlignBenchOffset = cpAlignBenchOffsetObject;
					cpAlignBenchOffset.m_dPosX = cpAlignBenchOffset.m_dPosX * dWeldAmmendMovementRatioX;
					cpAlignBenchOffset.m_dPosY = cpAlignBenchOffset.m_dPosY * dWeldAmmendMovementRatioY;
					cpAlignBenchOffset.m_dAngle = 0;

				}
				// 目标判定为基准
				else if (1 == nFWELSearchBench)
				{
					if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
					{
						ReportAlignResultFWEL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

						return FALSE;  
					}

					// 判断对象两Mark为0度或90度附近
					BOOL bZeroAngle = IsTargetMarksZeroAngle();

					// 设置图像中心十字基准目标
					SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
					m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

					//计算目标与图像中心距离
					m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);

					// 执行对位
					m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
					if(FALSE == ExecuteAlign(i))
					{
						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						ReportAlignResultFWEL(FALSE, TRUE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
						//						m_strStatusBarInfo2 = _T("");
						m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();		

						return FALSE;     
					}

					// 获取对位结果
					cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					//设置实时对象
					m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
					m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
					double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

					cpAlignBenchOffset = cpAlignBenchOffsetTarget;
					cpAlignBenchOffset.m_dPosX = cpAlignBenchOffsetTarget.m_dPosX * dWeldAmmendMovementRatioX;
					cpAlignBenchOffset.m_dPosY = cpAlignBenchOffsetTarget.m_dPosY * dWeldAmmendMovementRatioY;
					cpAlignBenchOffset.m_dAngle = 0;

				}
				// 判定没有基准
				else if (2 == nFWELSearchBench)
				{
					cpAlignBenchOffset.m_dPosX = 0;
					cpAlignBenchOffset.m_dPosY = 0;
					cpAlignBenchOffset.m_dAngle = 0;
				}

				ReportAlignResultFWEL(TRUE,TRUE,cpAlignBenchOffset);
			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFWEL(FALSE, TRUE);

				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

			return m_bStatusBar;  
		}
		else
		{
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			CCoordPos cp = GetAlignPlatformOffset();

			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFWEL(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			// 			if (pAlignerParam->m_dMovementRatioX!=1.0 || pAlignerParam->m_dMovementRatioY!= 1.0)
			// 			{
			// 				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(pAlignerParam->m_dMovementRatioX,pAlignerParam->m_dMovementRatioY);
			// 			}

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;

			if (dWeldMovementRatioX != 1.0 || dWeldMovementRatioY != 1.0)
			{
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY);
			}

			// FPC多次对位时角度为当前轴角度;
			if ((m_bAutoAlign == TRUE && m_nAlignTime == 1) || (m_bAutoAlign == FALSE))
			{
				pPlatformXYDAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0))->m_dAngle;
			}
			else
			{
				pPlatformXYDAxisPos->m_dAngle = m_CurPlatformAxisPos.m_dAngle;
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFWEL(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				CCoordPos cpProduct = GetAlignProductOffset();
				m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
				m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
				m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

				CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

				m_apAlignerProcesInfo.nTimes  = i+1;
				m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
				m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
				m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
				m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

				PostMessageUpdateAlignerProcessInfo();

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

		} // else 

	}// for	


	if (0 == nFWELSearchBench)
	{
		// 对象定位
		if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
		{
			ReportAlignResultFWEL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;     			
		}

		// 判断对象两Mark为0度或90度附近
		BOOL bZeroAngle = IsObjectMarksZeroAngle();

		// 计算对象与图像中心距离
		// 设置图像中心十字基准目标
		SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
		m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

		// 执行对位
		m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
		if(FALSE == ExecuteAlign())
		{
			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

			//设置实时对象
			m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			ReportAlignResultFWEL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			return FALSE;     
		}

		// 获取对位结果
		cpAlignBenchOffsetObject = GetAlignPlatformOffset();

		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

		//设置实时对象
		m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
		m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

		// 设置实时的目标
		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

		double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
		double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

		cpAlignBenchOffset = cpAlignBenchOffsetObject;
		cpAlignBenchOffset.m_dPosX = cpAlignBenchOffset.m_dPosX * dWeldAmmendMovementRatioX;
		cpAlignBenchOffset.m_dPosY = cpAlignBenchOffset.m_dPosY * dWeldAmmendMovementRatioY;
		cpAlignBenchOffset.m_dAngle = 0;


	}
	// 目标判定为基准
	else if (1 == nFWELSearchBench)
	{
		if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
		{
			ReportAlignResultFWEL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;  
		}
		// 判断对象两Mark为0度或90度附近
		BOOL bZeroAngle = IsTargetMarksZeroAngle();
		// 设置图像中心十字基准目标
		SetDefaultCrossBenchTargetSearchMarkPos(TRUE,bZeroAngle);
		m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

		//计算目标与图像中心距离
		m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);

		// 执行对位
		m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
		if(FALSE == ExecuteAlign())
		{
			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


			//设置实时对象
			m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			ReportAlignResultFWEL(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			return FALSE;     
		}

		// 获取对位结果
		cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

		//设置实时对象
		m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
		m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

		// 设置实时的目标
		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

		double dWeldAmmendMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosX;
		double dWeldAmmendMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldAmmendMovementRatio.m_dPosY;

		cpAlignBenchOffset = cpAlignBenchOffsetTarget;
		cpAlignBenchOffset.m_dPosX = cpAlignBenchOffsetTarget.m_dPosX * dWeldAmmendMovementRatioX;
		cpAlignBenchOffset.m_dPosY = cpAlignBenchOffsetTarget.m_dPosY * dWeldAmmendMovementRatioY;
		cpAlignBenchOffset.m_dAngle = 0;

	}
	// 判定没有基准
	else if (2 == nFWELSearchBench)
	{
		cpAlignBenchOffset.m_dPosX = 0;
		cpAlignBenchOffset.m_dPosY = 0;
		cpAlignBenchOffset.m_dAngle = 0;

	}

	ReportAlignResultFWEL(TRUE,TRUE,cpAlignBenchOffset);


	return TRUE;

}





// 单相机基准注册
BOOL vcXYDVisionAlign::OnSingleCameraBenchMarkRgister(int nCalibPos, int nMarkType)
{
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	CString strTempWarningType = _T("");
	CString strCmd = _T("VCLB:");
	GetCommCommandName(strCmd);
	if (!CheckCalibratePreparation(strCmd, nCalibPos, nMarkType)/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/)
	{		
		ReportCalibResult(FALSE);
		return FALSE;
	}

	if(nMarkType < 0 || nMarkType > 1)
	{
		ReportCalibResult(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CALIBTYPE);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	// 通信是否正常
	// 	if (FALSE == m_bValidComm)
	// 	{
	// 		ReportCalibResult(FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_COMM_ERROR);
	// 		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 		return FALSE; 
	// 	}

	// 标定用定位工具是否正常 
	// 	if (m_bValidCalibSearchTool!=TRUE)
	// 	{
	// 		ReportCalibResult(FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_CALIB_SEARCH_TOOL_INVALID);
	// 		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_EXCUTE_SYS_CALIB_FAILED);
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 		return FALSE;
	// 	}

	// 相机是否处于连续采集状态
	// 	int nCamNum = m_pPlatformInfo->m_nCamNum;
	// 	int i=0;
	// 	for(i=0; i<nCamNum; i++)
	// 	{		 
	// 		if (FALSE == m_vbCameraLiveGrab[i])
	// 		{
	// 			ReportCalibResult(FALSE);
	// 
	// 			m_bStatusBar = FALSE;
	// 			m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
	// 			m_strStatusBarInfo2 = _T("");
	// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	// 
	// 			return FALSE;
	// 		}    	
	// 	}

	// 对位标定工具是否正常
	// 	if (m_bValidCalibSearchTool!=TRUE)
	// 	{		
	// 		ReportCalibResult(FALSE);	
	// 
	// 		return FALSE;
	// 	}

	//////////////////////////////////////////////////////////////////////////
	// 获取平台当前各轴的绝对位置

	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE; 
	if (m_bCmdParamAxisPosEanble)
	{
		bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
	}
	else
	{
		bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
	}

	if (FALSE == bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		ReportCalibResult(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1.Format(m_psaSysInfoStrings->GetAt(IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		//		PostMessageUpdateStatusBarInfo();
		//		return FALSE;
		return OnFailedCommuciateGetPlatformAxisAbsPos(strCmd);
	}
	else
	{
		//		SetCalibPlatformPos(pPlatformAxisPos);		

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strInfo;
			strInfo.Format(m_psaSysInfoStrings->GetAt(IDS_DR_XYD_THE_PLATFORM_POS), pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// X轴放料位置标定

	// 获取X轴放料位置，并设置入对位工具
	CPlatformXYDAxisPos* pPlatformAxisPosXPlace = new CPlatformXYDAxisPos;
	pPlatformAxisPosXPlace->m_dPosX = pPlatformAxisPos->m_dPosX;
	pPlatformAxisPosXPlace->m_dPosY = 0.0;
	pPlatformAxisPosXPlace->m_dAngle = 0.0;
	SetCalibPlatformPos(pPlatformAxisPosXPlace);
	if (pPlatformAxisPosXPlace != NULL)
	{
		delete pPlatformAxisPosXPlace;
		pPlatformAxisPosXPlace = NULL;
	}

	// 在对位工具中将标定轴位置设置到标定结果中
	if(FALSE == ExecuteCalibrateBenchMarkRgisterPlace(nCalibPos, nMarkType))
	{		
		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}

		ReportCalibResult(FALSE);		

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	// 获取系统标定后的所有信息
	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();

	if(optionInfo.m_bAutoCopyCalibData)
	{
		//复制标定
		int nExProductIdx = nCalibPos/GetPosNum();
		ExecuteCopyCalibrateData(1,nExProductIdx);
	}
	else
	{
		/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
		SetCurCalibratedInfo(vpAllCalibratedInfo);	

		// 保存标定后信息到当前产品中及配置文件中
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
	}

	//////////////////////////////////////////////////////////////////////////
	// X轴拍照位置标定

	// 获取X轴拍照位置，并设置入对位工具
	CPlatformXYDAxisPos* pPlatformAxisPosX = new CPlatformXYDAxisPos;
	pPlatformAxisPosX->m_dPosX = pPlatformAxisPos->m_dPosY;
	pPlatformAxisPosX->m_dPosY = 0.0;
	pPlatformAxisPosX->m_dAngle = 0.0;
	SetCalibPlatformPos(pPlatformAxisPosX);
	if (pPlatformAxisPosX != NULL)
	{
		delete pPlatformAxisPosX;
		pPlatformAxisPosX = NULL;
	}

	// 清除该轴位置指针
	if (pPlatformAxisPos != NULL)
	{
		delete pPlatformAxisPos;
		pPlatformAxisPos = NULL;
	}

	// 拍照
	std::vector<CMarkImagePos*> vpMarkImagePos;
	CMarkImagePos* pMarkImagePos = NULL;

	if (1)
	{
		pMarkImagePos = new CMarkImagePos;
		pMarkImagePos->SetMarkImagePosNum(1);

		if (1)
		{
			// 等待搜索延时
			int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
			Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[nCalibPos]->m_nSearchDelayTime);

			// 准备开始定位			
			std::vector<int> vnPosIndex;
			std::vector<SearchMode> vsmSearchMode;	
			vnPosIndex.push_back(nCalibPos);		// nCalibPos	

			vsmSearchMode.push_back(eCalibSearch);	// 标定搜索		

			// 采集搜索图像
			if (!SnapSearchImage(vnPosIndex))
			{				
				ReportCalibResult(FALSE);				

				if (pMarkImagePos!=NULL)
				{
					delete pMarkImagePos;
					pMarkImagePos = NULL;
				}

				for (int p=0; p<vpMarkImagePos.size(); p++)
				{
					if (vpMarkImagePos.at(p))
					{
						delete vpMarkImagePos.at(p);
						vpMarkImagePos.at(p) = NULL;
					}
				}  

				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_GRAB_FAILED);
				// 				m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_CAMERA_CONNECTION_ERROR);
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				//				PostMessageUpdateStatusBarInfo();
				//				return FALSE;
				return OnFailedSnapSearchImage(strCmd);
			}

			// 定位	
			m_vnCalibSearchStartPatIndex[nCalibPos] = 0;
			m_vnCalibSearchEndPatIndex[nCalibPos] = 0;			

			BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

			// 分析定位结果，发送指令响应
			if (FALSE == bSearchSucceed)
			{
				ReportCalibResult(FALSE);				

				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1.Format(m_psaSysInfoStrings->GetAt(IDS_SB_MOVE_ROTATE_POS_SEARCH_FAILED), k);
				// 				m_strStatusBarInfo2.Format(m_psaSysInfoStrings->GetAt(IDS_SB_CAM_MOVE_THEN_SEARCH_FAILED), nCalibPos); 
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				if (pMarkImagePos!=NULL)
				{
					delete pMarkImagePos;
					pMarkImagePos = NULL;
				}

				for (int p=0; p<vpMarkImagePos.size(); p++)
				{
					if (vpMarkImagePos.at(p))
					{
						delete vpMarkImagePos.at(p);
						vpMarkImagePos.at(p) = NULL;
					}
				}  
				return FALSE;
			}

			// 保存定位结果			
			pMarkImagePos->SetMarkImagePos(0, m_mpCalibMarkImagePos.GetIsMarkImagePosOK(nCalibPos), m_mpCalibMarkImagePos.GetMarkImagePos(nCalibPos));	
		}

		CMarkImagePos * markpos = new CMarkImagePos(*pMarkImagePos);
		vpMarkImagePos.push_back(markpos); 

		// 记录图像搜索数据
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			CString strOut;
			CCoordPos cp;
			strOut = strTemp + _T("CalibSearch: ");		
			for (int i=0; i<pMarkImagePos->GetMarkImagePosNum(); i++)
			{
				strTemp = _T("");
				cp = pMarkImagePos->GetMarkImagePos(i);

				strTemp.Format(_T("MarkPos0( %.2f , %.2f , %.3f )"), cp.GetPosX(), cp.GetPosY(), cp.GetAngle());

				strOut += strTemp;
			}

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}	
	}    	
	if (pMarkImagePos!=NULL)
	{
		delete pMarkImagePos;
		pMarkImagePos = NULL;
	}

	// 执行标定计算
	if(FALSE == ExecuteCalibrateBenchMarkRgister(vpMarkImagePos, nCalibPos, nMarkType))
	{		
		ReportCalibResult(FALSE);		

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_CALIB_CALCULATE_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

		return FALSE;
	}

	// 获取系统标定后的所有信息
	//	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();

	if(optionInfo.m_bAutoCopyCalibData)
	{
		//复制标定
		int nExProductIdx = nCalibPos/GetPosNum();
		ExecuteCopyCalibrateData(1,nExProductIdx);
	}
	else
	{
		/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
		SetCurCalibratedInfo(vpAllCalibratedInfo);	

		// 保存标定后信息到当前产品中及配置文件中
		SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
	}

	return TRUE;
}


// 对位：实时对位用，一般情况下需要与目标定位相配合
// 接收命令后，调用该函数，里面需要做一些额外的判断
//  接收命令，执行对位，返回命令响应；
// 执行对位时，首先1接收对位命令（命令中包含位置信息），然后2定位对位对象，3用对位工具计算平台运动量，4指定平台运动，5等待接收平台运动结束的命令，
// 6检测对象运动后的对位精度（重新定位对象，计算偏差），7如果偏差不满足精度要求则重复3到7步，8如果偏差满足精度要求或超过对位次数，则返回对位完成响应命令
// 另外，当相机独立安装时，还需要计算相机平台的运动量，让相机去追踪对象运动到的位置

BOOL vcXYDVisionAlign::OnlineAlignExFAAO(int nOffsetIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CCoordPos platOffset;

	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{

		ReportAlignResultFAAO(platOffset,FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{
		ReportAlignResultFAAO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (FALSE == m_bValidAlignerTool)
	{
		ReportAlignResultFAAO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		ReportAlignResultFAAO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFAAO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}            
	}    

	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	if(OnSerialCameraAlignerObjectSearchExFCNT() == FALSE)
	{
		ReportAlignResultFAAO(platOffset,FALSE);

		return FALSE;
	}

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAAO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}

	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAAO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	//	pCurProductData->m_pAlignerParam->SetCurAlignerBenchOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	//	pAlignerParam->SetCurAlignerBenchOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	// 执行对位计算
	if(FALSE == ExecuteAlign())
	{
		ReportAlignResultFAAO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
		//		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		//		SaveCurAllCameraChannelSearchImg();
		return FALSE;     
	}

	// 更新主界面对位精度、次数、对位总时间
	CCoordPos cpProduct = GetAlignProductOffset();
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
	}

	m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
	m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
	m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

	CCoordPos cp = GetAlignPlatformOffset();
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
	}

	m_apAlignerProcesInfo.nTimes  = 1;

	m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
	m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
	m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
	m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

	dAlignTime=m_apAlignerProcesInfo.dTime;

	PostMessageUpdateAlignerProcessInfo();	

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
	|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
	|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
	//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
	//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
	//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
	if(IsAxisMoveOverRun(cp))
	{

		CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();


		CCoordPos cpOffset;
		cpOffset = GetAlignPlatformPosOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
		}

		ReportAlignResultFAAO(cpOffset,FALSE,pPlatformXYDAxisPos);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
		m_strStatusBarInfo2.Format(_T(""));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();				

	// 记录对位精度
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	{
		CString strTemp;

		CString strOut;					
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
		strOut = strTemp + strOut;

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录对位时间
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
	{
		CString strTemp;

		CString strOut;						
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
		strOut = strTemp + strOut;

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}	

	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

	CCoordPos cpOffset;
	cpOffset = GetAlignPlatformPosOffset();

	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

		AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
	}

	ReportAlignResultFAAO(cpOffset,TRUE,pPlatformXYDAxisPos);

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFOLC(int nOffsetIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CCoordPos platOffset;
	CString strCmd = _T("VOLC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFOLC(platOffset,FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd) /*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		//		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFOLC(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();


	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	// 检查目标Mark是否已成功定位
	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	{
		if (FALSE == m_bTargetMarkSearchSucceed)
		{
			ReportAlignResultFOLC(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}

	// 对象Mark定位
	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	{
		SetDefaultObjectSearchMarkPos(TRUE);
		std::vector<int> vnPosIndex;
		int nTempPosIndex = 0;
		for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
		{
			vnPosIndex.push_back(nTempPosIndex);
		}
		if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex))
		{
			ReportAlignResultFOLC(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			if (!m_boIsSnapImgSucceed)
			{
				m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
			}
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;     			
		}
	}
	else
	{
		if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ())
		{
			ReportAlignResultFOLC(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
			if (!m_boIsSnapImgSucceed)
			{
				m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
			}
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;     			
		}
	}


	// 	// 检查对象Mark是否已成功定位
	// 	if (FALSE == m_bObjectMarkSearchSucceed)
	// 	{
	// 		ReportAlignResultFOLC(platOffset,FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );
	// 		m_strStatusBarInfo2 = _T("");
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
	// 
	// 		return FALSE;
	// 	}	

	if (!CheckObjectDistance())
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_DIS_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	if (!CheckTargetDistance())
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	if (!CheckTargetAngle())
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}



	// 执行对位计算

	if(FALSE == ExecuteAlign())
	{
		ReportAlignResultFOLC(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
		//		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		//		SaveCurAllCameraChannelSearchImg();
		return FALSE;     
	}


	// 更新主界面对位精度、次数、对位总时间
	CCoordPos cpProduct = GetAlignProductOffset();
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

	}
	m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
	m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
	m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

	CCoordPos cp = GetAlignPlatformOffset();
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

	}
	m_apAlignerProcesInfo.nTimes  = 1;

	m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
	m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
	m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
	m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

	dAlignTime=m_apAlignerProcesInfo.dTime;

	PostMessageUpdateAlignerProcessInfo();	

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
	|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
	|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
	//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
	//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
	//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
	if(IsAxisMoveOverRun(cp))
	{

		CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

		CCoordPos cpOffset;
		cpOffset = GetAlignPlatformPosOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
		}

		ReportAlignResultFOLC(cpOffset,FALSE,pPlatformXYDAxisPos);

		// ReportAlignResultFOLC(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
		m_strStatusBarInfo2.Format(_T(""));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	// 	// 执行本次对位操作
	// 	// 获取平台对位应移动到的绝对位置
	// 	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	// 	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
	// 
	// 	scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
	// 	stCommunicateTimer.Reset();
	// 	// 通信驱动平台运动到指定位置
	// 	if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
	// 	{
	// 		ReportAlignResultFAAL(FALSE);
	// 		dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
	// 		// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
	// 		// 				AlignLogRecord(str);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
	// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
	// 
	// 		SaveCurAllCameraChannelSearchImg();
	// 		return FALSE;     
	// 	}
	// 	else
	// 	{
	// 		SysPlatformInfo sysPlatformInfo;
	// 		GetSysPlatformInfo(sysPlatformInfo);
	// 		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 		{
	// 			m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
	// 			m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
	// 			//D角度不累加
	// 		}
	// 		else
	// 		{
	// 			m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
	// 		}
	// 		dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
	// 		// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
	// 		// 				AlignLogRecord(str);
	// 		CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
	// 
	// 		m_apAlignerProcesInfo.nTimes  = 1;
	// 		m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
	// 		m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
	// 		m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
	// 		m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
	// 
	// 		CCoordPos cpProduct = GetAlignProductOffset();
	// 		m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
	// 		m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
	// 		m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;
	// 
	// 		PostMessageUpdateAlignerProcessInfo();
	// 	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();				

	// 记录对位精度
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;					
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录对位时间
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;						
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}	
	// 
	// 	ReportAlignResultFOLC(cp,TRUE);

	{
		CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

		CCoordPos cpOffset;
		cpOffset = GetAlignPlatformPosOffset();

		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
		}

		ReportAlignResultFACO(cpOffset,TRUE,pPlatformXYDAxisPos);
	}



	return TRUE;  

}


BOOL vcXYDVisionAlign::OnlineAlignExFABO(int nOffsetIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CCoordPos platOffset;
	CString strCmd = _T("VABO:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFABO(platOffset,FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFABO(platOffset,FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFABO(platOffset,FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFABO(platOffset,FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFABO(platOffset,FALSE);

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFABO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFABO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();


	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	// 	// 检查目标Mark是否已成功定位
	// 	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	// 	{
	// 		if (FALSE == m_bTargetMarkSearchSucceed)
	// 		{
	// 			ReportAlignResultFABO(platOffset,FALSE);
	// 
	// 			m_bStatusBar = FALSE;
	// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
	// 			m_strStatusBarInfo2 = _T("");
	// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
	// 
	// 			return FALSE;
	// 		}
	// 	}
	// 检查对象Mark是否已成功定位
	if (FALSE == m_bObjectMarkSearchSucceed)
	{
		ReportAlignResultFABO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}	

	if (!CheckObjectDistance())
	{
		ReportAlignResultFABO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_DIS_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	//if (!CheckTargetDistance())
	//{
	//	ReportAlignResultFABO(platOffset,FALSE);

	//	m_bStatusBar = FALSE;
	//	m_strStatusBarInfo1 = _T("目标距离超过设定标准，目标定位结果可能出错");
	//	m_strStatusBarInfo2 = _T("");
	//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	//	return FALSE;
	//}

	//if (!CheckTargetAngle())
	//{
	//	ReportAlignResultFABO(platOffset,FALSE);

	//	m_bStatusBar = FALSE;
	//	m_strStatusBarInfo1 = _T("目标角度超过设定标准，目标定位结果可能出错");
	//	m_strStatusBarInfo2 = _T("");
	//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	//	return FALSE;
	//}


	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	// 执行对位计算
	// 设置图像中心十字基准目标
	SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
	m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
	m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

	// 执行对位
	m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
	if(FALSE == ExecuteAlign())
	{
		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

		// 设置实时的目标
		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);


		ReportAlignResultFABO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
		//		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
		//		SaveCurAllCameraChannelSearchImg();

		return FALSE;     
	}

	m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

	// 设置实时的目标
	m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
	m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

	// 更新主界面对位精度、次数、对位总时间
	CCoordPos cp = GetAlignPlatformOffset();

	m_apAlignerProcesInfo.nTimes  = 1;

	m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
	m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
	m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
	m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

	dAlignTime=m_apAlignerProcesInfo.dTime;

	PostMessageUpdateAlignerProcessInfo();	

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
	|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
	|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
	//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
	//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
	//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
	if(IsAxisMoveOverRun(cp))
	{
		ReportAlignResultFABO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
		m_strStatusBarInfo2.Format(_T(""));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();				

	// 记录对位精度
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;					
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录对位时间
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;						
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}	

	// 
	// 	ReportAlignResultFABO(cp,TRUE);

	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

	CCoordPos cpOffset;
	cpOffset = GetAlignPlatformPosOffset();

	ReportAlignResultFABO(cpOffset, TRUE, pPlatformXYDAxisPos);

	return TRUE;  
}

BOOL vcXYDVisionAlign::OnlineAlignExFALG(int nOffsetIndex, int nReservedIndex/* = 10*/, int nBenchOffsetIndex/* = -1*/, int nExProductIndex/* = 0*/,int nTarFixOffsetIndex /* = 0 */)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CString str;
	CString strCmd = _T("VALG:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");

	SetAlignReservedIndex(nReservedIndex);
	SetAlignBenchOffsetIndex(nBenchOffsetIndex);
	SetAlignExProductIndex(nExProductIndex);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// start 直接根据searchdata中图像坐标和轴位置 设置进对位工具中；
	{
		int nSize1 = m_vvpTargetPlatformAxisPosMultiEx.size();
		int nSize2 = m_vvpObjectPlatformAxisPosMultiEx.size();
		int nSize3 = m_vmpObjectMarkImagePos_MultiEX.size();
		int nSize4 = m_vmpTargetMarkImagePosMultiEx.size();
		bool bTmp = (nExProductIndex >=0) &&  (nExProductIndex <nSize1) &&  (nExProductIndex <nSize2) &&  (nExProductIndex <nSize3)  &&  (nExProductIndex <nSize4);

		if (bTmp)
		{

			vector<CPlatformAxisPos*> tmpObjectPlatformAxisPos;
			vector<CPlatformAxisPos*> tmpTargetPlatformAxisPos;
			tmpObjectPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);
			tmpTargetPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);

			if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
			{
				if (optionInfo.m_bObjectSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{
						tmpObjectPlatformAxisPos.at(jt) = m_vvpObjectPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpObjectMarkImagePos = m_vmpObjectMarkImagePos_MultiEX.at(nExProductIndex);
				}
				else
				{
					tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				}


				if (optionInfo.m_bTargetSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{				
						tmpTargetPlatformAxisPos.at(jt) = m_vvpTargetPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpTargetMarkImagePos = m_vmpTargetMarkImagePosMultiEx.at(nExProductIndex);
				}
				else
				{
					tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
				}
			}
			else
			{
				tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
			}


			m_pAlignerTool->SetTargetPlatformPos(tmpTargetPlatformAxisPos);
			//m_pAlignerTool->SetTargetMarkSearchResultsInit(tmpTargetImagePos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			m_pAlignerTool->SetObjectPlatformPos(tmpObjectPlatformAxisPos);
			//m_pAlignerTool->SetObjectMarkSearchResultsAll(tmpObjectImagePos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);


			// 			m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
			// 			m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();

			//lzk 0417
			std::vector<int> nObjectPosIndex;
			std::vector<int> nTargetPosIndex;
			CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
			BOOL bObjectPositionVirtualMod = pAlignerParam->GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;
			BOOL bTargetPositionVirtualMod = pAlignerParam->GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode;
			BOOL bTargetAndObjectPositionVirtualMod = m_pAlignerTool->GetEnablePositionVirtualMode();
			int nObjectPositionVirtual = pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;
			int nTargetPositionVirtual = pAlignerParam->GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode;
			//对象位置虚拟
			if (bTargetAndObjectPositionVirtualMod && bObjectPositionVirtualMod)
			{
				//对象位置虚拟模式：12拍照34虚拟(BOOL)
				if (nObjectPositionVirtual == 0)
				{
					nObjectPosIndex.push_back(0);
					nObjectPosIndex.push_back(1);
				}
				//对象位置虚拟模式：34拍照12虚拟
				else if (nObjectPositionVirtual == 1)
				{
					nObjectPosIndex.push_back(2);
					nObjectPosIndex.push_back(3);
				}
				//对象位置虚拟模式：13拍照24虚拟
				else if (nObjectPositionVirtual == 2)
				{
					nObjectPosIndex.push_back(0);
					nObjectPosIndex.push_back(2);
				}
				//对象位置虚拟模式：24拍照13虚拟
				else if (nObjectPositionVirtual == 3)
				{
					nObjectPosIndex.push_back(1);
					nObjectPosIndex.push_back(3);
				}

				m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK(nObjectPosIndex);
			}
			else
			{
				m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();
			}

			//目标位置虚拟
			if (bTargetAndObjectPositionVirtualMod && bTargetPositionVirtualMod)
			{
				//目标位置虚拟模式：56拍照78虚拟
				if (nTargetPositionVirtual == 0)
				{
					nTargetPosIndex.push_back(4);
					nTargetPosIndex.push_back(5);
				}
				//目标位置虚拟模式：78拍照56虚拟
				else if (nTargetPositionVirtual == 1)
				{
					nTargetPosIndex.push_back(6);
					nTargetPosIndex.push_back(7);
				}
				//目标位置虚拟模式：57拍照68虚拟
				else if (nTargetPositionVirtual == 2)
				{
					nTargetPosIndex.push_back(4);
					nTargetPosIndex.push_back(6);
				}
				//目标位置虚拟模式：68拍照57虚拟
				else if (nTargetPositionVirtual == 3)
				{
					nTargetPosIndex.push_back(5);
					nTargetPosIndex.push_back(7);
				}
				m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK(nTargetPosIndex);
			}
			else
			{
				m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
			}

		}
	}
	// end  直接根据searchdata中图像坐标和轴位置 设置进对位工具中；

	m_AlignerTargetSizeInfo.m_nExProductIndex = nExProductIndex;


	if (optionInfo.m_bEnableMutiTarget)
	{
		m_bTargetMarkSearchSucceed=m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
		if (m_bTargetMarkSearchSucceed)
		{
			SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
			m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			for (int i=0;i<nPosNum;i++)
			{
				SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
			}
			PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
		}	
	}

	CPlatformXYDAxisPos *pPlatformXYDAxisPos=NULL;
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());

	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		// 		str.Format("m_pPlatformInfo or m_pVisionASMConfig ==NULL");
		// 		AlignLogRecord(str);
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerBenchOffsetIndex(nBenchOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerBenchOffsetIndex(nBenchOffsetIndex);
	pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);

	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);


	if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetCoordPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(TRUE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetPlatformPos(vnPosIndex,vTargetCoordPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);
			m_bStatusBar = FALSE;
			//m_strStatusBarInfo1.Format(_T("通信获取目标平台坐标失败"));
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARPLATFORMPOS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			CMarkPlatformPos mpTargetMarkPos;
			mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();
			for (int i=0;i<mpTargetMarkPos.m_vbOK.size();i++)
			{
				mpTargetMarkPos.m_vbOK.at(i) = TRUE;
			}
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);
					m_bStatusBar = FALSE;
					//m_strStatusBarInfo1 = _T("通信获取目标平台坐标失败");// 
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARPLATFORMPOS);
					m_strStatusBarInfo2 = _T("");//
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}
				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				mpTargetMarkPos.SetMarkPlatformPos(nPosIndex,TRUE,vTargetCoordPos.at(i));
			}
			m_pAlignerTool->SetTargetMarkPlatformPos(mpTargetMarkPos);
		}
	}
	else if (optionInfo.m_nTarInfoCommModeInDiffPC == 2)//通过PLC交换目标图像坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetImgPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetImagePos(vnPosIndex,vTargetImgPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);
			m_bStatusBar = FALSE;
			//m_strStatusBarInfo1.Format(_T("通信获取目标图像坐标失败"));
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARIMGPOS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);
					m_bStatusBar = FALSE;
					//m_strStatusBarInfo1 = _T("通信获取目标图像坐标失败");// 
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARIMGPOS);
					m_strStatusBarInfo2 = _T("");//
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}
				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex,TRUE,vTargetImgPos.at(i));
			}
			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		}
	}
	else
	{
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		// 检查目标Mark是否已成功定位
		if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
		{
			if (FALSE == m_bTargetMarkSearchSucceed)
			{
				ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}
		}
	}
	// 检查对象Mark是否已成功定位
	if (FALSE == m_bObjectMarkSearchSucceed)
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );;
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}	

	if (!CheckObjectDistance())
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_DIS_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	if (!CheckTargetDistance())
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	if (!CheckTargetAngle())
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	// 执行对位计算
	CCoordPos cpBenchOffset;
	CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos = NULL;	
	if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
	{
		// 执行对位计算
		// 设置图像中心十字基准目标
		SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
		m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

		// 执行对位
		m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
		if(FALSE == ExecuteAlign())
		{
			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);


			ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();	

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
			//			SaveCurAllCameraChannelSearchImg();

			return FALSE;     
		}
		pBenchPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
		cpBenchOffset = GetAlignPlatformPosOffset();


		m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效
		// 设置实时的目标
		m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
		m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);		
	}

	// 执行对位计算
	// 	SysPlatformInfo sysPlatformInfo;
	// 	GetSysPlatformInfo(sysPlatformInfo);
	// 	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 	{  
	// 		m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //执行一次对位，总是使用当前的目标位置，防止问题情况产生
	// 	}

	if(FALSE == ExecuteAlign())
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
		//		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));

		//		SaveCurAllCameraChannelSearchImg();
		return FALSE;     
	}


	// 更新主界面对位精度、次数、对位总时间
	CCoordPos cpProduct = GetAlignProductOffset();
	// 一次对位时，勾选目标补偿时出现异常情况
	double dPosX = pAlignerParam->GetAlnTargetOffsetX();
	double dPosY = pAlignerParam->GetAlnTargetOffsetY();
	CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pPlatformInfo);
	int iPlatformYCoordType = platformXYDInfo->m_nPlatformYCoordType;
	int iPlatformXCoordType = platformXYDInfo->m_nPlatformXCoordType;
	if (eDirectNegative == iPlatformXCoordType) dPosX = -1*dPosX;
	if (eDirectNegative == iPlatformYCoordType) dPosY = -1*dPosY;
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		//cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		//cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		cpProduct.m_dPosX+=dPosX;
		cpProduct.m_dPosY+=dPosY;

	}
	m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
	m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
	m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

	CCoordPos cp = GetAlignPlatformOffset();

	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		//cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
		//cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		cp.m_dPosX+=dPosX;
		cp.m_dPosY+=dPosY;
	}

	m_apAlignerProcesInfo.nTimes  = 1;

	m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
	m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
	m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
	m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

	dAlignTime=m_apAlignerProcesInfo.dTime;

	PostMessageUpdateAlignerProcessInfo();	


	if(IsAxisMoveOverRun(cp))
	{
		ReportAlignResultFALG(pPlatformXYDAxisPos,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
		m_strStatusBarInfo2.Format(_T(""));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();				

	// 记录对位精度
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;					
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);	

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}

	// 记录对位时间
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
	{
		CString strTemp;
		// 		CTime t = CTime::GetCurrentTime();
		// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;						
		strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
		strOut = strTemp + strOut;

		// 		FILE *stream;
		// 		CString strPath = m_strAlignProcessData;
		// 		stream = fopen(strPath, _T("a+t"));               
		// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
		// 		fclose(stream);VCRemoveFile(strPath);		

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}	

	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{
		AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
	}
	ReportAlignResultFALG(pPlatformXYDAxisPos,TRUE, cpBenchOffset, pBenchPlatformXYDAxisPos);
	return TRUE;  


}

BOOL vcXYDVisionAlign::OnlineMulAlignPickExFALP(int nOffsetIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();

	CString strCmd = _T("VALP:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");

	// 所有轴位置信息
	std::vector<CPlatformXYDAxisPos> vPlatformXYDAxisPos;				//单个扩展的全部结果
	std::vector<std::vector<CPlatformXYDAxisPos>> vvPlatformXYDAxisPos;	//全部扩展的全部结果

	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = _T("");
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	// 设置补偿量
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);

	PostMessageUpdateAlignOffsetInfo();


	// 	if ( FALSE == pAlignerParam->m_bDiffPosWithSameSearchResultEnabled )
	// 	{
	// 		ReportMulAlignPosResultFALP(vPlatformXYDAxisPos, FALSE);
	// 
	// 		m_bStatusBar = FALSE;
	// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
	// 		m_strStatusBarInfo2 = _T("");
	// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	// 		PostMessageUpdateStatusBarInfo();	
	// 
	// 		return FALSE;
	// 	}


	SysPlatformInfo platformInfo;
	GetSysPlatformInfo(platformInfo);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if ((m_vpObjectPlatformAxisPos.size()== 2) && (*(CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(0) == *(CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(1))/*&& m_bObjectMarkSearchSucceed == FALSE*/)
	{
		// 对于固定相机拾取模式和相机随轴运动一次拍照拾取模式，实际上没不会执行先FOBC再FALP，直接一次进行FALP，因此必须在FALP内部拍照对象
		// 如果增加m_bObjectMarkSearchSucceed为真的判断，当重新退出软件再打开或者切换产品时，InitAlignTool会将m_bObjectMarkSearchSucceed设置为真，上述判断会直接跳过，导致FALP时不再拍照
		// 对于相机随轴运动分位置拍照拾取模式，如果前面没有FOBC两次，在FALP再拍一次，实际上也是错的，因此必须在FALP前，先进行两次FOBC

		if (optionInfo.m_bEnableMultiMarkMode)
		{
			m_bObjectMarkSearchSucceed = OnSingleCameraMulAlignerPosObjectSearchCandidateExFOBC(0,0);
		}
		// 		else
		// 		{
		// 			m_bObjectMarkSearchSucceed = OnSerialCameraMulAlignerPosObjectSearchCandidateExFOBC(0);
		// 		}

	}
	else
	{
		ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("位置1、2 轴位置不同错误");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	if (FALSE == m_bObjectMarkSearchSucceed )
	{
		//搜索失败首先进行空盘检测
		std::vector<int> vnPosIndex;
		std::vector<SearchMode> vsmSearchMode;	
		vnPosIndex.push_back(0);		// 	
		vsmSearchMode.push_back(eInspectSearch);	// 
		m_vnInspectSearchStartPatIndex[0] = 0;
		m_vnInspectSearchEndPatIndex[0] = 4;
		if(SearchMark(vnPosIndex, vsmSearchMode))
		{
			//如果空盘检测OK则报告没有产品
			CPlatformXYDAxisPos tempPlatformXYDAxisPos;
			ReportAlignResultFALP(&tempPlatformXYDAxisPos,2);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("拾取");
			m_strStatusBarInfo2 = _T("没有产品");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			return FALSE;     		
		}

		ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		if (!m_boIsSnapImgSucceed)
		{
			m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
		}
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;     			
	}

	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	



	// 每次对位轴位置偏差量
	CPlatformXYDAxisPos *pPlatformXYDAxisPos = NULL;
	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());

	// 	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	// 	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int nSuccessPatIndex = m_vnObjectSearchSuccessPatIndex[0];
	std::vector<CSearchResult> vTempSeachResults = GetAlnObjectSearchResults(0,nSuccessPatIndex);
	int nSearchNum = GetAlnObjectSearchResultNumber(0,nSuccessPatIndex);

	// 	if (nSearchNum > EXTRA_GRAPHICS_NUM_POS)
	// 	{
	// 		return FALSE;
	// 	}
	int nExNum = 1;//需要计算的扩展数量,不需要计算多扩展时仅计算一个，即当前扩展
	int	nMaxResultNum = 1000;
	if(m_nPickMutiExMode != 0)
	{//需要时计算全部扩展
		nExNum = m_pPlatformInfo->m_nMultiCalibExtensionMaxNum + 1;
		nMaxResultNum = m_nPickMutiExMode % 100;
	}
	for(int nExProductIndex = 0;nExProductIndex < nExNum;nExProductIndex++)
	{
		if(m_nPickMutiExMode != 0)
		{//设置扩展序号
			SetAlignExProductIndex(nExProductIndex);
		}
		vPlatformXYDAxisPos.clear();
		for (int i = 0; (i < nSearchNum) && (i < EXTRA_GRAPHICS_NUM_POS); i++)
		{
			if(m_nPickMutiExMode == 300 && i != nExProductIndex)
			{//nMutiExMode == 300 时，仅计算与扩展序号相同序号的搜索结果
				continue;
			}
			if((m_nPickMutiExMode >= 100 && m_nPickMutiExMode < 300) && i >= nMaxResultNum)
			{//nMutiExMode == 1xx/2xx 时，输出结果数受nMaxResultNum限制
				continue;
			}
			CCoordPos cpPosCH0;
			cpPosCH0.m_dPosX = vTempSeachResults.at(i).m_dPosX;
			cpPosCH0.m_dPosY = vTempSeachResults.at(i).m_dPosY;
			cpPosCH0.m_dAngle = vTempSeachResults.at(i).m_dAngle;

			CCoordPos cpPosCH1;
			cpPosCH1.m_dPosX = vTempSeachResults.at(i).m_vdAuxiliaryPosX.at(0);
			cpPosCH1.m_dPosY = vTempSeachResults.at(i).m_vdAuxiliaryPosY.at(0);
			cpPosCH1.m_dAngle = vTempSeachResults.at(i).m_vdAuxiliaryAngle.at(0);

			m_mpObjectMarkImagePos.SetMarkImagePos(0, m_vbSearchSucceed[0], cpPosCH0);
			if(m_pPlatformInfo->m_nPositionNum>1)
			{
				m_mpObjectMarkImagePos.SetMarkImagePos(1, m_vbSearchSucceed[0], cpPosCH1);
			}

			SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 

			//			CalculateObjectDistance();
			if (!CheckObjectDistance())
			{
				ReportAlignResultFALP(pPlatformXYDAxisPos,FALSE);
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_OBJECT_LEN_OVERFLOW); //__T("对象距离超过设定标准，对象定位结果可能出错");
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				//				RecordObjectSizeIndfo(TRUE, FALSE);
				return FALSE;

			}
			if(FALSE == ExecuteAlign(i))
			{
				ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				//				m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();	

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();

				m_bObjectMarkSearchSucceed = FALSE;
				return FALSE;     
			}

			m_bObjectMarkSearchSucceed = FALSE;

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cp = GetAlignPlatformOffset();
			m_apAlignerProcesInfo.nTimes  = 1;
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
			m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);
			dAlignTime=m_apAlignerProcesInfo.dTime;

			PostMessageUpdateAlignerProcessInfo();	

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();	


			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());

			CPlatformXYDAxisPos TempAxisMovePos;
			TempAxisMovePos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
			TempAxisMovePos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
			TempAxisMovePos.m_dAngle = pPlatformXYDAxisPos->m_dAngle;

			vPlatformXYDAxisPos.push_back(TempAxisMovePos);

			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;
				CTime t = CTime::GetCurrentTime();
				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;

				FILE *stream;
				CString strPath = m_strAlignProcessData;
				stream = fopen(strPath, _T("a+t"));               
				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				fclose(stream);VCRemoveFile(strPath);	
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;
				CTime t = CTime::GetCurrentTime();
				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
				strOut = strTemp + strOut;

				FILE *stream;
				CString strPath = m_strAlignProcessData;
				stream = fopen(strPath, _T("a+t"));               
				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				fclose(stream);VCRemoveFile(strPath);					
			}	
		}
		vvPlatformXYDAxisPos.push_back(vPlatformXYDAxisPos);
	}
	if(m_nPickMutiExMode == 300)
	{//每个扩展仅有一个结果，所有结果集合到第一个扩展的结果中一并输出
		vvPlatformXYDAxisPos[0].resize(1);//扩展1的结果仅保留第1个
		for(int i = 0;i<vvPlatformXYDAxisPos.size();i++)
		{//第i个扩展的结果添加到第1个扩展之后
			if(vvPlatformXYDAxisPos[i].size() == 1)
			{
				vvPlatformXYDAxisPos[0].resize(i+1);				
				vvPlatformXYDAxisPos[0][i] = vvPlatformXYDAxisPos[i][0];
			}
			else
			{
				break;
			}
		}
		//仅保留修改后的扩展1的结果数据，当中保存的数据为扩展1的结果1，扩展2的结果2，扩展3的结果3。。。
		vvPlatformXYDAxisPos.resize(1);
	}

	ReportMulAlignPosResultFALP(vvPlatformXYDAxisPos, TRUE);

	return TRUE;  
}

BOOL vcXYDVisionAlign::OnlineAlignExFAAL_Base(int nOffsetIndex, int nReservedIndex/* = 10*/, int nBenchOffsetIndex/* = -1*/, int nExProductIndex/* = 0*/,int nTarFixOffsetIndex /*= 0*/)
{
	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}

	BOOL bBendInspect = pCurProductData->m_pAlignerParam->GetBendInfo().m_bBendAlignInspect;

	if (bBendInspect)
	{
		return OnlineAlignExFAAL_BendAlign(nOffsetIndex, nReservedIndex, nBenchOffsetIndex, nExProductIndex,nTarFixOffsetIndex);
	}
	else
	{
		return OnlineAlignExFAAL(nOffsetIndex, nReservedIndex, nBenchOffsetIndex, nExProductIndex,nTarFixOffsetIndex);
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFAAL_BendAlign(int nOffsetIndex, int nReservedIndex/* = 10*/, int nBenchOffsetIndex/* = -1*/, int nExProductIndex/* = 0*/,int nTarFixOffsetIndex /*= 0*/)
{
	scTimer stTotalAlignTimer;double dTotalAlignTime(0.0);
	stTotalAlignTimer.Reset();

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


	CString strCmd = _T("VAAL:");
	CString strTempWarningType = _T("");


	// 避免没有进入产品设置，导致对位工具类为空时的崩溃
	if (m_pAlignerTool == NULL) 
	{
		ReportAlignResultFAAL(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd))
	{
		ReportAlignResultFAAL(FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd))
	{
		ReportAlignResultFAAL(FALSE);
		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd))
	{
		ReportAlignResultFAAL(FALSE);
		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd))
	{
		ReportAlignResultFAAL(FALSE);
		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFAAL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);

			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	if (pCurProductData->m_pAlignerParam== NULL)
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}


	SetAlignReservedIndex(nReservedIndex);
	SetAlignBenchOffsetIndex(nBenchOffsetIndex);
	SetAlignExProductIndex(nExProductIndex);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	// start 直接根据searchdata中图像坐标和轴位置 设置进对位工具中；
	{
		int nSize1 = m_vvpTargetPlatformAxisPosMultiEx.size();
		int nSize2 = m_vvpObjectPlatformAxisPosMultiEx.size();
		int nSize3 = m_vmpObjectMarkImagePos_MultiEX.size();
		int nSize4 = m_vmpTargetMarkImagePosMultiEx.size();
		bool bTmp = (nExProductIndex >=0) &&  (nExProductIndex <nSize1) &&  (nExProductIndex <nSize2) &&  (nExProductIndex <nSize3)  &&  (nExProductIndex <nSize4);

		if (bTmp)
		{

			vector<CPlatformAxisPos*> tmpObjectPlatformAxisPos;
			vector<CPlatformAxisPos*> tmpTargetPlatformAxisPos;
			tmpObjectPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);
			tmpTargetPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);

			if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
			{
				if (optionInfo.m_bObjectSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{
						tmpObjectPlatformAxisPos.at(jt) = m_vvpObjectPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpObjectMarkImagePos = m_vmpObjectMarkImagePos_MultiEX.at(nExProductIndex);
				}
				else
				{
					tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				}

				if (optionInfo.m_bTargetSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{					
						tmpTargetPlatformAxisPos.at(jt) = m_vvpTargetPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}		
					m_mpTargetMarkImagePos = m_vmpTargetMarkImagePosMultiEx.at(nExProductIndex);
				}
				else
				{
					tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
				}

			}
			else
			{
				tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
			}


			m_pAlignerTool->SetTargetPlatformPos(tmpTargetPlatformAxisPos);
			//m_pAlignerTool->SetTargetMarkSearchResultsInit(tmpTargetImagePos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			m_pAlignerTool->SetObjectPlatformPos(tmpObjectPlatformAxisPos);
			//m_pAlignerTool->SetObjectMarkSearchResultsAll(tmpObjectImagePos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);


			m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
			m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();

		}
	}
	// end  直接根据searchdata中图像坐标和轴位置 设置进对位工具中；

	if (optionInfo.m_bEnableMutiTarget)
	{
		m_bTargetMarkSearchSucceed=m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
		if (m_bTargetMarkSearchSucceed)
		{
			SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
			m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			for (int i=0;i<nPosNum;i++)
			{
				SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
			}
			PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
		}	
	}


	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerBenchOffsetIndex(nBenchOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerBenchOffsetIndex(nBenchOffsetIndex);
	pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();


	

	m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
	// 检查目标Mark是否已成功定位
	if (eTargetOnline == pCurProductData->m_pAlignerParam->m_eTargetMarkType)
	{
		if (FALSE == m_bTargetMarkSearchSucceed)
		{
			ReportAlignResultFAAL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}

	if (!pCurProductData->m_pAlignerParam->GetBendInfo().m_bBendAlignInspect)
	{
		return FALSE;
	}

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CBendInfo BendInfo = pCurProductData->m_pAlignerParam->GetBendInfo();
	m_pAlignerTool->SetBendAlignProcess(TRUE);


	// 获取当前产品最大对位次数
	int nMaxAlignTime = pCurProductData->m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);

	CCoordPos cpBenchOffset;
	CPlatformXYDAxisPos benchPlatformXYDAxisPos;
	for (i=0; i<nMaxAlignTime+1; i++)
	{		
		stAlignTimer.Reset();
		stObjectSearchTimer.Reset();

		m_nAlignTime = i+1;

		// 对象拍照
		if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
		{
			SetDefaultObjectSearchMarkPos(TRUE);
			std::vector<int> vnPosIndex;
			int nTempPosIndex = 0;

			for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
			{
				vnPosIndex.push_back(nTempPosIndex);
			}

			if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				if (!m_boIsSnapImgSucceed)	//  [5/8/2020 zzc]
				{
					m_strStatusBarInfo1 = m_strStatusBarInfo1 + _T(",") + m_strSnapImgStatuString;
				}
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo1);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;     			
			}
		}
		else
		{
			if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ())
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				if (!m_boIsSnapImgSucceed)	//  [5/8/2020 zzc]
				{
					m_strStatusBarInfo1 = m_strStatusBarInfo1 + _T(",") + m_strSnapImgStatuString;
				}
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo2,m_strStatusBarInfo1);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;     			
			}
			m_cVisionAlignGui.SetAllPosObjectToTargetResultLine();
		}
		dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);


		// 执行基准对位
		if( (TRUE == optionInfo.m_bEnableAlignBenchCenter) && (0 == i))
		{
			// 设置图像中心十字基准目标
			SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
			m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

			// 执行对位
			m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
			if(FALSE == ExecuteAlign(i))
			{
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();	

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));

				return FALSE;     
			}

			// 获取对位结果
			cpBenchOffset = GetAlignPlatformOffset();
			CPlatformXYDAxisPos* pAlignPlatformMovementResults = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			benchPlatformXYDAxisPos = *pAlignPlatformMovementResults;
			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		}



		// 折弯上料判定
		if( (pCurProductData->m_pAlignerParam->GetBendInfo().m_bBendLoadThre) && (0 == i))
		{
			// 设置图像中心十字基准目标
			SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
			m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				


			AlignerProcessInfo TempAlignerProcesInfo;

			m_apAlignerProcesInfo.nTimes  = TempAlignerProcesInfo.nTimes;
			m_apAlignerProcesInfo.dTime   = TempAlignerProcesInfo.dTime;
			m_apAlignerProcesInfo.dXMove  = TempAlignerProcesInfo.dXMove;  
			m_apAlignerProcesInfo.dYMove  = TempAlignerProcesInfo.dYMove;
			m_apAlignerProcesInfo.dDMove  = TempAlignerProcesInfo.dDMove;

			m_apAlignerProcesInfo.dXOffset = TempAlignerProcesInfo.dXOffset;
			m_apAlignerProcesInfo.dYOffset = TempAlignerProcesInfo.dYOffset;
			m_apAlignerProcesInfo.dDOffset = TempAlignerProcesInfo.dDOffset;



			CString strBendInsError = _T("");
			BendingAlignProcessInfo(strBendInsError);

			if ( !(m_BendInspectResultInfo.m_dLCenterx < fabs(BendInfo.m_scBendLoadThre.GetX())) )
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = _T("第一次对位时,左侧X上料超出范围！");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			if ( !(m_BendInspectResultInfo.m_dLCentery < fabs(BendInfo.m_scBendLoadThre.GetY())) )
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = _T("第一次对位时,左侧Y上料超出范围！");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}



			if ( !(m_BendInspectResultInfo.m_dRCenterx < fabs(BendInfo.m_scBendLoadThre.GetX())) )
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = _T("第一次对位时,右侧X上料超出范围！");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			if ( !(m_BendInspectResultInfo.m_dRCentery < fabs(BendInfo.m_scBendLoadThre.GetY())) )
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = _T("第一次对位时,右侧Y上料超出范围！");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			BendInspectResultInfo TempBendInspectResultInfo;
			TempBendInspectResultInfo.m_dLCenterx = m_BendInspectResultInfo.m_dLCenterx;
			TempBendInspectResultInfo.m_dLCentery = m_BendInspectResultInfo.m_dLCentery;
			TempBendInspectResultInfo.m_dRCenterx = m_BendInspectResultInfo.m_dLCenterx;
			TempBendInspectResultInfo.m_dRCentery = m_BendInspectResultInfo.m_dLCentery;

			m_BendInspectResultInfo = TempBendInspectResultInfo;
			PostMessageUpdateBendingDetalInfo();
			VisionInspectBendRecord(TRUE, TRUE, FALSE);

		}


		CString strBendInsError = _T("");
		BOOL bBendInspect = FALSE;

		// 说明：执行对位计算和折弯检测需成对出现，目的是将两者的结果记录在一个csv文件中
		if ( (BendInfo.m_bBendPressPara) && (0 == i) )
		{
			// 执行对位计算
			stCaluteAlignTimer.Reset();
			if(FALSE == ExecuteAlign(i))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();	

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));

				return FALSE;     
			}
			dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;
			PostMessageUpdateAlignerProcessInfo();


			bBendInspect = BendingAlignProcessInfo(strBendInsError);
			VisionInspectBendRecord(TRUE, TRUE, FALSE);
			PostMessageUpdateBendingProcessInfo();
			


			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

				return FALSE;
			}



			if( (m_BendInspectResultInfo.m_dLy < BendInfo.m_dBendPressNGYmin) || (m_BendInspectResultInfo.m_dLy > BendInfo.m_dBendPressNGYmax) )
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = _T("第一次对位时,左侧Y向距离超出范围！");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			if( (m_BendInspectResultInfo.m_dRy < BendInfo.m_dBendPressNGYmin) || (m_BendInspectResultInfo.m_dRy > BendInfo.m_dBendPressNGYmax) )
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = _T("第一次对位时,右侧Y向距离超出范围！");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}

			if(    (m_BendInspectResultInfo.m_dLy > BendInfo.m_dBendPressOKYmin) && (m_BendInspectResultInfo.m_dLy < BendInfo.m_dBendPressOKYmax) 
				&& (m_BendInspectResultInfo.m_dRy > BendInfo.m_dBendPressOKYmin) && (m_BendInspectResultInfo.m_dRy < BendInfo.m_dBendPressOKYmax) )
			{
				ReportAlignResultFAAL(TRUE);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2 = _T("压合阈值范围内对位成功！");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				return TRUE;
			}

		}


		// 执行一次对位
		if ( (TRUE == optionInfo.m_bAlignOneTime) && (0 == i) )
		{
			// 执行对位计算
			stCaluteAlignTimer.Reset();
			if(FALSE == ExecuteAlign(i))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();	

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));

				return FALSE;     
			}
			dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			}
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;
			PostMessageUpdateAlignerProcessInfo();

			bBendInspect = BendingAlignProcessInfo(strBendInsError);
			VisionInspectBendRecord(TRUE, TRUE, FALSE);
			PostMessageUpdateBendingProcessInfo();
			


			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			// 当启用目标补偿，且不发送目标补偿到PLC时，在MMVA指令中增加目标补偿运动量，否则在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器中
			if (pAlignerParam->GetEnableAlnTargetOffset() && FALSE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
			{
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}

			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}

					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				if (pAlignerParam->GetEnableAlnTargetOffset() && TRUE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
				{
					AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

					// 当启用目标补偿，且发送目标补偿到PLC时，不在MMVA指令中增加目标补偿运动量，而是在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器中
					ReportAlignResultFAAL(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos, pPlatformXYDAxisPos);
				}
				else
				{
					ReportAlignResultFAAL(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos);
				}

				return TRUE;
			}
		}


		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFAAL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();	

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));

			return FALSE;     
		}
		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 


		// 判断是否执行对位动作
		if (i!=0 && TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cp = GetAlignPlatformOffset();
			m_apAlignerProcesInfo.nTimes  = i;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			{
				cpProduct = GetAlignProductOffsetXYPD();
			}
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;
			PostMessageUpdateAlignerProcessInfo();

			bBendInspect = BendingAlignProcessInfo(strBendInsError);
			VisionInspectBendRecord(TRUE, TRUE, FALSE);
			PostMessageUpdateBendingProcessInfo();
			

			if (pAlignerParam->GetEnableAlnTargetOffset() && IsAlignSucceed() && FALSE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
			{
				CCoordPos cp = GetAlignPlatformOffset();
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();


				if(IsAxisMoveOverRun(cp))
				{
					ReportAlignResultFAAL(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);

					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFAAL(FALSE);	

					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();

					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}

						if (m_pSystempOptionConfig->m_bShowSepTargetPos)
						{
							UpdateTargetPosAfterRoate();
						}
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}			
				}  
			}

			m_bStatusBar = IsAlignSucceed();

			if (m_bStatusBar)
			{
				if (pAlignerParam->GetEnableAlnTargetOffset() && TRUE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
				{
					CCoordPos cp = GetAlignPlatformOffset();
					cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
					cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

					if(IsAxisMoveOverRun(cp))
					{
						ReportAlignResultFAAL(FALSE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
						m_strStatusBarInfo2.Format(_T(""));
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();

						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

						return FALSE;
					}


					// 执行本次对位操作
					// 获取平台对位应移动到的绝对位置
					CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
					pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

					AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

					BOOL bStatusBar = FALSE;
					bStatusBar = (m_bStatusBar && bBendInspect);

					// 当启用目标补偿，且发送目标补偿到PLC时，不在MMVA指令中增加目标补偿运动量，而是在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器
					ReportAlignResultFAAL(m_bStatusBar, FALSE, cpBenchOffset, &benchPlatformXYDAxisPos, pPlatformXYDAxisPos);

					// 检测失败
					if (!bStatusBar)
					{
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						m_strStatusBarInfo2 = strBendInsError;
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();	
					}
					else
					{
						m_bStatusBar = TRUE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
						m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
					}
				} 
				else
				{
					BOOL bStatusBar = FALSE;
					bStatusBar = (m_bStatusBar && bBendInspect);

					// 检测失败
					if (!bStatusBar)
					{
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						m_strStatusBarInfo2 = strBendInsError;
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();	
					}
					else
					{
						m_bStatusBar = TRUE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
						m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
					}


					ReportAlignResultFAAL(m_bStatusBar, FALSE, cpBenchOffset, &benchPlatformXYDAxisPos);

					m_bStatusBar = FALSE;
// 					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
// 					m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
// 					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
				
				}
			}
			else
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
			}


			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;
				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;
				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), i, dTotalAlignTime);
				strOut = strTemp + strOut;

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			return m_bStatusBar;  
		}
		else
		{
			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;
			PostMessageUpdateAlignerProcessInfo();

			bBendInspect = BendingAlignProcessInfo(strBendInsError);
			VisionInspectBendRecord(TRUE, TRUE, FALSE);
			PostMessageUpdateBendingProcessInfo();
			

			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();

				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;


				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

		} // else

	}// for	

	ReportAlignResultFAAL(TRUE, FALSE, cpBenchOffset, &benchPlatformXYDAxisPos);

	return TRUE;
}


BOOL vcXYDVisionAlign::OnlineAlignExFAAL(int nOffsetIndex, int nReservedIndex/* = 10*/, int nBenchOffsetIndex/* = -1*/, int nExProductIndex/* = 0*/,int nTarFixOffsetIndex /*= 0*/)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString str;
	// 	str.Format("Begin to FAAL Align---------------");
	// 	AlignLogRecord(str);
	//	CCoordPos platOffset;
	//	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());
	CString strCmd = _T("VAAL:");
	CString strTempWarningType = _T("");
	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);

	stCheckInvalidTimer.Reset();
	// 避免没有进入产品设置，导致对位工具类为空时的崩溃
	if (m_pAlignerTool == NULL) 
	{
		ReportAlignResultFAAL(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	SetAlignReservedIndex(nReservedIndex);
	SetAlignBenchOffsetIndex(nBenchOffsetIndex);
	SetAlignExProductIndex(nExProductIndex);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// start 直接根据searchdata中图像坐标和轴位置 设置进对位工具中；
	{
		int nSize1 = m_vvpTargetPlatformAxisPosMultiEx.size();
		int nSize2 = m_vvpObjectPlatformAxisPosMultiEx.size();
		int nSize3 = m_vmpObjectMarkImagePos_MultiEX.size();
		int nSize4 = m_vmpTargetMarkImagePosMultiEx.size();
		bool bTmp = (nExProductIndex >=0) &&  (nExProductIndex <nSize1) &&  (nExProductIndex <nSize2) &&  (nExProductIndex <nSize3)  &&  (nExProductIndex <nSize4);

		if (bTmp)
		{

			vector<CPlatformAxisPos*> tmpObjectPlatformAxisPos;
			vector<CPlatformAxisPos*> tmpTargetPlatformAxisPos;
			tmpObjectPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);
			tmpTargetPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);

			if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
			{
				if (optionInfo.m_bObjectSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{
						tmpObjectPlatformAxisPos.at(jt) = m_vvpObjectPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpObjectMarkImagePos = m_vmpObjectMarkImagePos_MultiEX.at(nExProductIndex);
				}
				else
				{
					tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				}

				if (optionInfo.m_bTargetSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{					
						tmpTargetPlatformAxisPos.at(jt) = m_vvpTargetPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}		
					m_mpTargetMarkImagePos = m_vmpTargetMarkImagePosMultiEx.at(nExProductIndex);
				}
				else
				{
					tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
				}

			}
			else
			{
				tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
			}


			m_pAlignerTool->SetTargetPlatformPos(tmpTargetPlatformAxisPos);
			//m_pAlignerTool->SetTargetMarkSearchResultsInit(tmpTargetImagePos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			m_pAlignerTool->SetObjectPlatformPos(tmpObjectPlatformAxisPos);
			//m_pAlignerTool->SetObjectMarkSearchResultsAll(tmpObjectImagePos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);


			// 			m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
			// 			m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();

			//lzk 0417
			std::vector<int> nObjectPosIndex;
			std::vector<int> nTargetPosIndex;
			CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
			BOOL bObjectPositionVirtualMod = pAlignerParam->GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;
			BOOL bTargetPositionVirtualMod = pAlignerParam->GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode;
			BOOL bTargetAndObjectPositionVirtualMod = m_pAlignerTool->GetEnablePositionVirtualMode();
			int nObjectPositionVirtual = pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;
			int nTargetPositionVirtual = pAlignerParam->GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode;
			//对象位置虚拟
			if (bTargetAndObjectPositionVirtualMod && bObjectPositionVirtualMod)
			{
				//对象位置虚拟模式：12拍照34虚拟(BOOL)
				if (nObjectPositionVirtual == 0)
				{
					nObjectPosIndex.push_back(0);
					nObjectPosIndex.push_back(1);
				}
				//对象位置虚拟模式：34拍照12虚拟
				else if (nObjectPositionVirtual == 1)
				{
					nObjectPosIndex.push_back(2);
					nObjectPosIndex.push_back(3);
				}
				//对象位置虚拟模式：13拍照24虚拟
				else if (nObjectPositionVirtual == 2)
				{
					nObjectPosIndex.push_back(0);
					nObjectPosIndex.push_back(2);
				}
				//对象位置虚拟模式：24拍照13虚拟
				else if (nObjectPositionVirtual == 3)
				{
					nObjectPosIndex.push_back(1);
					nObjectPosIndex.push_back(3);
				}

				m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK(nObjectPosIndex);
			}
			else
			{
				m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();
			}

			//目标位置虚拟
			if (bTargetAndObjectPositionVirtualMod && bTargetPositionVirtualMod)
			{
				//目标位置虚拟模式：56拍照78虚拟
				if (nTargetPositionVirtual == 0)
				{
					nTargetPosIndex.push_back(4);
					nTargetPosIndex.push_back(5);
				}
				//目标位置虚拟模式：78拍照56虚拟
				else if (nTargetPositionVirtual == 1)
				{
					nTargetPosIndex.push_back(6);
					nTargetPosIndex.push_back(7);
				}
				//目标位置虚拟模式：57拍照68虚拟
				else if (nTargetPositionVirtual == 2)
				{
					nTargetPosIndex.push_back(4);
					nTargetPosIndex.push_back(6);
				}
				//目标位置虚拟模式：68拍照57虚拟
				else if (nTargetPositionVirtual == 3)
				{
					nTargetPosIndex.push_back(5);
					nTargetPosIndex.push_back(7);
				}
				m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK(nTargetPosIndex);
			}
			else
			{
				m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
			}

		}
	}


	// end  直接根据searchdata中图像坐标和轴位置 设置进对位工具中；
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_bTargetMarkSearchSucceed=m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
		if (m_bTargetMarkSearchSucceed)
		{
			SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
			m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			for (int i=0;i<nPosNum;i++)
			{
				SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
			}
			PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
		}	
	}

	//CString strCmd = _T("VAAL:");
	//CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFAAL(FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFAAL(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFAAL(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFAAL(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFAAL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	if (pCurProductData->m_pAlignerParam== NULL)
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerBenchOffsetIndex(nBenchOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerBenchOffsetIndex(nBenchOffsetIndex);
	pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	if (optionInfo.m_nTarInfoCommModeInDiffPC == 2)//通过PLC交换目标图像坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetImgPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetImagePos(vnPosIndex,vTargetImgPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportAlignResultFAAL(FALSE);
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARIMGPOS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					ReportAlignResultFAAL(FALSE);
					m_bStatusBar = FALSE;
					//m_strStatusBarInfo1 = _T("通信获取目标图像坐标失败");// 
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARIMGPOS);
					m_strStatusBarInfo2 = _T("");//
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}
				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex,TRUE,vTargetImgPos.at(i));
			}
			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		}
	}
	else if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetCoordPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(TRUE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetPlatformPos(vnPosIndex,vTargetCoordPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportAlignResultFAAL(FALSE);
			m_bStatusBar = FALSE;
			//m_strStatusBarInfo1.Format(_T("通信获取目标平台坐标失败"));
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARPLATFORMPOS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			CMarkPlatformPos mpTargetMarkPos;
			mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();
			for (int i=0;i<mpTargetMarkPos.m_vbOK.size();i++)
			{
				mpTargetMarkPos.m_vbOK.at(i) = TRUE;
			}
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					ReportAlignResultFAAL(FALSE);
					m_bStatusBar = FALSE;
					//m_strStatusBarInfo1 = _T("通信获取目标平台坐标失败");// 
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARPLATFORMPOS);
					m_strStatusBarInfo2 = _T("");//
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}
				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				mpTargetMarkPos.SetMarkPlatformPos(nPosIndex,TRUE,vTargetCoordPos.at(i));
			}
			m_pAlignerTool->SetTargetMarkPlatformPos(mpTargetMarkPos);
		}
	}
	else
	{
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		// 检查目标Mark是否已成功定位
		if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
		{
			if (FALSE == m_bTargetMarkSearchSucceed)
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}
		}
	}
	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);


	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo(); 

	// 获取当前产品最大对位次数
	int nMaxAlignTime = curProductData.m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	// 	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 	{  
	// 		m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //第一次对位用新的TargetPos
	// 	}


	CCoordPos cpBenchOffset;
	CPlatformXYDAxisPos benchPlatformXYDAxisPos;
	for (i=0; i<nMaxAlignTime+1; i++)
	{

		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();


		{
			stObjectSearchTimer.Reset();
			m_nAlignTime = i+1;

			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				// 				if (m_pPlatformInfo->m_bTarCamWithDiffObjCam)
				// 				{
				// 					if (nExProductIndex >= 2)
				// 					{
				// 						return FALSE;
				// 					}
				// 
				// 					SetDefaultObjectSearchMarkPos(TRUE, nExProductIndex + 19);
				// 
				// 					std::vector<int> vnPosIndex;
				// 					int nTempPosIndex = 0;
				// 					for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/4; nTempPosIndex++)
				// 					{
				// 						vnPosIndex.push_back(nTempPosIndex + 2*nExProductIndex);
				// 					}
				// 
				// 					if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex))
				// 					{
				// 						ReportAlignResultFAAL(FALSE);
				// 
				// 						m_bStatusBar = FALSE;
				// 						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
				// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				// 						if (!m_boIsSnapImgSucceed)	//  [5/8/2020 zzc]
				// 						{
				// 							m_strStatusBarInfo1 = m_strStatusBarInfo1 + _T(",") + m_strSnapImgStatuString;
				// 						}
				// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo2,m_strStatusBarInfo1);
				// 						PostMessageUpdateStatusBarInfo();		
				// 						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				// 						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				// 						return FALSE;     			
				// 					}
				// 
				// 				}
				// 				else
				{
					SetDefaultObjectSearchMarkPos(TRUE);
					std::vector<int> vnPosIndex;
					int nTempPosIndex = 0;

					if (optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
					{
						int nObjectVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;
						BOOL bEnableObjectPositionVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;

						if (bEnableObjectPositionVirtualMode)
						{
							switch(nObjectVirtualMode)
							{
							case 0:
								{
									// 位置1、位置2
									vnPosIndex.push_back(0);
									vnPosIndex.push_back(1);

								}
								break;

							case 1:
								{
									// 位置3、位置4
									vnPosIndex.push_back(2);
									vnPosIndex.push_back(3);
								}
								break;

							case 2:
								{
									// 位置1、位置3
									vnPosIndex.push_back(0);
									vnPosIndex.push_back(2);
								}
								break;

							case 3:
								{
									// 位置2、位置4
									vnPosIndex.push_back(1);
									vnPosIndex.push_back(3);
								}
								break;

							default:
								{
									return FALSE;
								}
								break;
							}
						}
						else
						{
							vnPosIndex.push_back(0);
							vnPosIndex.push_back(1);
							vnPosIndex.push_back(2);
							vnPosIndex.push_back(3);
						}
					}
					else
					{
						for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
						{
							vnPosIndex.push_back(nTempPosIndex);
						}
					}


					if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex))
					{
						ReportAlignResultFAAL(FALSE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						if (!m_boIsSnapImgSucceed)	//  [5/8/2020 zzc]
						{
							m_strStatusBarInfo1 = m_strStatusBarInfo1 + _T(",") + m_strSnapImgStatuString;
						}
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo1);
						PostMessageUpdateStatusBarInfo();		
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
						return FALSE;     			
					}
				}
			}
			else
			{
				if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ())
				{
					ReportAlignResultFAAL(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					if (!m_boIsSnapImgSucceed)	//  [5/8/2020 zzc]
					{
						m_strStatusBarInfo1 = m_strStatusBarInfo1 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo2,m_strStatusBarInfo1);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;     			
				}
			}


			dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
		}

		// 执行基准对位
		if(optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			if (i == 0)
			{
				// 设置图像中心十字基准目标
				SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
				m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

				// 执行对位
				m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
				if(FALSE == ExecuteAlign(i))
				{
					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					ReportAlignResultFAAL(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
					//					m_strStatusBarInfo2 = _T("");
					m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();	

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));

					return FALSE;     
				}

				// 获取对位结果
				cpBenchOffset = GetAlignPlatformOffset();
				CPlatformXYDAxisPos* pAlignPlatformMovementResults = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
				benchPlatformXYDAxisPos = *pAlignPlatformMovementResults;
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			}
		}

		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFAAL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();	

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
			//			SaveCurAllCameraChannelSearchImg();

			return FALSE;     
		}
		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 


		// 		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
		// 		{  
		// 			m_pAlignerTool->m_bUsePreTargetPos = TRUE;    //执行一次对位成功后，使用上一次的TargetPos结果  
		// 		}


		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			}
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			// 			CCoordPos cp = GetAlignPlatformOffset();
			// 			if (pAlignerParam->GetEnableAlnTargetOffset())
			// 			{
			// 				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			// 				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			// 
			// 			}
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			// 当启用目标补偿，且不发送目标补偿到PLC时，在MMVA指令中增加目标补偿运动量，否则在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器中
			if (pAlignerParam->GetEnableAlnTargetOffset() && FALSE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
			{
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAAL(FALSE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				if (pAlignerParam->GetEnableAlnTargetOffset() && TRUE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
				{
					AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

					// 当启用目标补偿，且发送目标补偿到PLC时，不在MMVA指令中增加目标补偿运动量，而是在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器中
					ReportAlignResultFAAL(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos, pPlatformXYDAxisPos);
				}
				else
				{
					ReportAlignResultFAAL(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos);
				}

				return TRUE;
			}
		}

		// 判断是否执行对位动作
		if (i!=0 && TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cp = GetAlignPlatformOffset();
			m_apAlignerProcesInfo.nTimes  = i;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			{
				cpProduct = GetAlignProductOffsetXYPD();
			}
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			if (pAlignerParam->GetEnableAlnTargetOffset() && IsAlignSucceed() && FALSE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
			{				
				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);
				CCoordPos cp = GetAlignPlatformOffset();
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
				/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
				|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
				|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
				//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
				//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
				//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
				if(IsAxisMoveOverRun(cp))
				{

					ReportAlignResultFAAL(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFAAL(FALSE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();
					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							//D角度不累加

						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}
						//D角度不累加
						if (m_pSystempOptionConfig->m_bShowSepTargetPos)
						{
							UpdateTargetPosAfterRoate();
						}
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}	
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				}  
			}

			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);

				if (pAlignerParam->GetEnableAlnTargetOffset() && TRUE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
				{
					CPlatformOptionInfo optionInfo;
					GetPlatformOptionInfo(optionInfo);
					CCoordPos cp = GetAlignPlatformOffset();
					cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
					cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
					/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
					|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
					|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
					//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
					//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
					//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
					if(IsAxisMoveOverRun(cp))
					{

						ReportAlignResultFAAL(FALSE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
						m_strStatusBarInfo2.Format(_T(""));
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
						return FALSE;
					}


					// 执行本次对位操作
					// 获取平台对位应移动到的绝对位置
					CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
					pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

					AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

					// 当启用目标补偿，且发送目标补偿到PLC时，不在MMVA指令中增加目标补偿运动量，而是在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器
					ReportAlignResultFAAL(m_bStatusBar, FALSE, cpBenchOffset, &benchPlatformXYDAxisPos, pPlatformXYDAxisPos);
				} 
				else
				{
					ReportAlignResultFAAL(m_bStatusBar, FALSE, cpBenchOffset, &benchPlatformXYDAxisPos);
				}
			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFAAL(FALSE);

				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	


			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;
				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;
				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), i, dTotalAlignTime);
				strOut = strTemp + strOut;

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			//			ReportAlignResultFAAL(m_bStatusBar);
			return m_bStatusBar;  
		}
		else
		{
			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			//			CCoordPos cp = GetAlignPlatformOffset();
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{

				ReportAlignResultFAAL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAAL(FALSE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);		



				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;


				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

			// 调整相机平台的位置，为下次对位做准备
			/*			std::vector<CPlatformAxisPos*> vpPlatformAxisPos;
			std::vector<CPlatformXYAxisPos*> vpPlatformXYAxisPos;
			vpPlatformAxisPos.clear();
			vpPlatformXYAxisPos.clear();			

			if ((m_pPlatformInfo->m_eCamPlatformType != eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX))
			{
			vpPlatformAxisPos = GetAlignCameraMovementResults();               

			for (int q=0; q<vpPlatformAxisPos.size(); q++)
			{
			vpPlatformXYAxisPos.push_back((CPlatformXYAxisPos*)vpPlatformAxisPos.at(q));
			}

			// 单相机，则保留下次对位中，相机需要调整到的各个位置
			m_vpSingleCamAlignCamPltfmAxisPos.clear();
			if (1 == m_pPlatformInfo->m_nCamNum)
			{
			for (q=0; q<vpPlatformXYAxisPos.size(); q++)
			{
			m_vpSingleCamAlignCamPltfmAxisPos.push_back(vpPlatformXYAxisPos.at(q));
			}

			return TRUE;
			}

			// 多相机，则通信驱动相机平台到位
			if (FALSE == CommuciateDriveCamPlatformAxisMove(vpPlatformXYAxisPos))
			{
			ReportAlignResultFAAL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_CAM_PLATFORM_ARRIVED_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			SaveCurAllCameraChannelSearchImg();
			return FALSE;  
			}

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
			CString strTemp;
			CTime t = CTime::GetCurrentTime();
			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_AND_THEN_RESET_CAM_PLATFORM_POS), i+1);
			strInfo = strTemp + strInfo;

			for (int i=0; i<vpPlatformXYAxisPos.size(); i++)
			{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpPlatformXYAxisPos.at(i)->m_dPosX, vpPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
			}

			FILE *stream;
			CString strPath = m_strAlignProcessData;
			stream = fopen(strPath, _T("a+t"));
			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			fclose(stream);VCRemoveFile(strPath);				
			}	
			} */
		} // else


	}// for	
	ReportAlignResultFAAL(TRUE, FALSE, cpBenchOffset, &benchPlatformXYDAxisPos);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFXYA(int nOffsetIndex,int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString str;

	//	CCoordPos platOffset;
	//	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);

	stCheckInvalidTimer.Reset();
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_bTargetMarkSearchSucceed=m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
		if (m_bTargetMarkSearchSucceed)
		{
			SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
			m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			for (int i=0;i<nPosNum;i++)
			{
				SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
			}
			PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
		}	
	}

	CString strCmd = _T("VXYA:");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFXYA(FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd) /*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFXYA(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFXYA(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFXYA(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFXYA(FALSE);

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFXYA(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFXYA(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);

	PostMessageUpdateAlignOffsetInfo();


	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	// 检查目标Mark是否已成功定位
	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	{
		if (FALSE == m_bTargetMarkSearchSucceed)
		{
			ReportAlignResultFXYA(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}

	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);
	// 	str.Format("Check Invalid time = %f",dCheckInvalidTime);
	// 	AlignLogRecord(str);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo(); 

	// 获取当前产品最大对位次数
	int nMaxAlignTime = curProductData.m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	// 	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 	{  
	// 		m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //第一次对位用新的TargetPos
	// 	}

	CCoordPos cpBenchOffset;
	CPlatformXYDAxisPos benchPlatformXYDAxisPos;

	for (i=0; i<nMaxAlignTime+1; i++)
	{

		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();


		{
			stObjectSearchTimer.Reset();
			m_nAlignTime = i+1;

			// 目标拍照
			if ( (m_pPlatformInfo->m_bTargetObjectCamSeparate) /*&& (i > 0)*/ && (optionInfo.m_bTargetAngleMulAlignerXYPD) )
			{
				SetDefaultTargetSearchMarkPos(TRUE);

				std::vector<int> vnPosIndex;
				int nPosIndex = 0;
				for(int m = 0; m < GetPosNum()/2; m++)
				{
					nPosIndex = m + GetPosNum()/2;
					vnPosIndex.push_back(nPosIndex);
				}
				if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex, nStartPatIndex))
				{
					ReportAlignResultFXYA(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;   
				}

			}


			// 对象拍照
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				SetDefaultObjectSearchMarkPos(TRUE);
				std::vector<int> vnPosIndex;
				int nTempPosIndex = 0;
				for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
				{
					vnPosIndex.push_back(nTempPosIndex);
				}
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex,nStartPatIndex))
				{
					ReportAlignResultFXYA(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;     			
				}
			}
			else
			{
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
				{
					ReportAlignResultFXYA(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;     			
				}
			}


			dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);


		}

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////

		if (optionInfo.m_bObjMulSearchPosXYPD)
		{
			if ( (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType) && (i == 0) && (m_bAutoAlign == TRUE) )
			{
				m_pAlignerTool->CalculateTempPlatformPos();

				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;

					CString strInfo;
					strInfo.Format(_T("轴位置偏差补偿量：%.3f, %.3f"), m_pAlignerTool->GetCalculateTempPlatformPos().m_dPosX, m_pAlignerTool->GetCalculateTempPlatformPos().m_dPosY);
					strInfo = strTemp + strInfo;


					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}
		}


		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////

		// 执行基准对位
		if(optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			if (i == 0)
			{
				// 设置图像中心十字基准目标
				SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
				m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

				// 执行对位
				m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
				if(FALSE == ExecuteAlign(i))
				{
					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					ReportAlignResultFXYA(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
					//					m_strStatusBarInfo2 = _T("");
					m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();	

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
					return FALSE;     
				}

				// 获取对位结果
				cpBenchOffset = GetAlignPlatformOffset();
				CPlatformXYDAxisPos* pAlignPlatformMovementResults = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
				benchPlatformXYDAxisPos = *pAlignPlatformMovementResults;
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			}
		}


		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFXYA(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
			//			SaveCurAllCameraChannelSearchImg();

			return FALSE;     
		}
		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 


		// 		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
		// 		{  
		// 			m_pAlignerTool->m_bUsePreTargetPos = TRUE;    //执行一次对位成功后，使用上一次的TargetPos结果  
		// 		}


		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			}
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			}

			if (optionInfo.m_bObjMulSearchPosXYPD)
			{
				if ( (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType) && (m_bAutoAlign == TRUE) )
				{
					// 					cp.m_dPosX += m_pAlignerTool->m_TempPlatformPos.m_dPosX;
					// 					cp.m_dPosY += m_pAlignerTool->m_TempPlatformPos.m_dPosY;

					cp.m_dPosX += m_pAlignerTool->GetCalculateTempPlatformPos().m_dPosX;
					cp.m_dPosY += m_pAlignerTool->GetCalculateTempPlatformPos().m_dPosY;
				}
			}

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			//			CCoordPos cp = GetAlignPlatformOffset();
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFXYA(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			if (optionInfo.m_bObjMulSearchPosXYPD)
			{
				if ( (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType) && (m_bAutoAlign == TRUE) )
				{
					pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults(TRUE);
				}
			}
			else
			{
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			}


			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFXYA(FALSE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						if (optionInfo.m_bTargetAngleMulAlignerXYPD)
						{
							m_CurPlatformAxisPos.m_dAngle = pPlatformXYDAxisPos->m_dAngle;
						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						}
						//						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);		



				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;


					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				//				ReportAlignResultFXYA(TRUE);
				ReportAlignResultFXYA(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos);
				return TRUE;
			}
		}

		BOOL bAngleMulAligner = FALSE;
		if (optionInfo.m_bTargetAngleMulAlignerXYPD)
		{
			bAngleMulAligner = TRUE;
		}

		// 判断是否执行对位动作
		if (i!=0 && TRUE == IsAlignFinished( i+1, bAngleMulAligner ))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cpProduct = GetAlignProductOffset();
			if (!optionInfo.m_bTargetAngleMulAlignerXYPD && ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			{
				cpProduct = GetAlignProductOffsetXYPD();
			}
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			//			CCoordPos cp = GetAlignPlatformOffset();
			// 			m_apAlignerProcesInfo.nTimes  = i;
			// 			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			// 			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			// 			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			// 			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
			// 
			// 			PostMessageUpdateAlignerProcessInfo();


			// (2) 平台移动量
			CCoordPos cp = GetAlignPlatformOffset();

			if ( (pAlignerParam->GetEnableAlnTargetOffset() || optionInfo.m_bObjMulSearchPosXYPD) && IsAlignSucceed())
			{				
				// 目标补偿值
				if (pAlignerParam->GetEnableAlnTargetOffset())
				{
					cp.m_dPosX += pAlignerParam->GetAlnTargetOffsetX();
					cp.m_dPosY += pAlignerParam->GetAlnTargetOffsetY();
				}

				// 偏差量补偿
				if ( (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType) && (m_bAutoAlign == TRUE) )
				{
					cp.m_dPosX += m_pAlignerTool->GetCalculateTempPlatformPos().m_dPosX;
					cp.m_dPosY += m_pAlignerTool->GetCalculateTempPlatformPos().m_dPosY;
				}

				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);
				/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
				|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
				|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
				//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
				//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
				//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
				if(IsAxisMoveOverRun(cp))
				{

					ReportAlignResultFXYA(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;

				if (optionInfo.m_bObjMulSearchPosXYPD)
				{
					// 对位成功，返回对位偏差+轴位置偏移量（对象拍照位和标定位不同）
					if (IsAlignSucceed())
					{
						pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults(TRUE);	
					}
					// 对位失败，返回对位偏差
					else
					{
						pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults(FALSE);	
					}
				}
				else
				{
					pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();	
				}


				if (pAlignerParam->GetEnableAlnTargetOffset())
				{					
					AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
				}


				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFXYA(FALSE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();
					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							if (optionInfo.m_bTargetAngleMulAlignerXYPD)
							{
								m_CurPlatformAxisPos.m_dAngle = pPlatformXYDAxisPos->m_dAngle;
							}
							else
							{
								m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							}
							//							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							//D角度不累加

						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}
						//D角度不累加
						if (m_pSystempOptionConfig->m_bShowSepTargetPos)
						{
							UpdateTargetPosAfterRoate();
						}
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}	
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				}  
			}

			m_apAlignerProcesInfo.nTimes  = i;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
				ReportAlignResultFXYA(m_bStatusBar, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos);

			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFXYA(FALSE);

				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	


			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;
				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;

				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), i, dTotalAlignTime);
				strOut = strTemp + strOut;

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录当前平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;

				CString strInfo;
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
					i+1, m_CurPlatformAxisPos.m_dPosX, m_CurPlatformAxisPos.m_dPosY, m_CurPlatformAxisPos.m_dAngle);
				strInfo = strTemp + strInfo;


				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}


			return m_bStatusBar;  
		}
		else
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			//			CCoordPos cp = GetAlignPlatformOffset();
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{

				ReportAlignResultFXYA(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults(FALSE);

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFXYA(FALSE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				// 				SysPlatformInfo sysPlatformInfo;
				// 				GetSysPlatformInfo(sysPlatformInfo);
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						if (optionInfo.m_bTargetAngleMulAlignerXYPD)
						{
							m_CurPlatformAxisPos.m_dAngle = pPlatformXYDAxisPos->m_dAngle;
						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						}
						//						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}


				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;


					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   


		} // else


	}// for	


	//	ReportAlignResultFXYA(TRUE);
	ReportAlignResultFXYA(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos);

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFAHLex(int nOffsetIndex,int nMarkType)
{
	CString strtimelog;
	strtimelog = "开始执行对位FAAL=======>\n";
	VisionAlignLogRecord(m_strAlignProcessData, strtimelog);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString str;

	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);

	stCheckInvalidTimer.Reset();

	CString strCmd = _T("VAHL:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		//AfxMessageBox(_T("1"));
		ReportAlignResultFAHL(FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFAHL(FALSE);
		//AfxMessageBox(_T("2"));
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFAHL(FALSE);
		//AfxMessageBox(_T("3"));
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFAHL(FALSE);
		//AfxMessageBox(_T("4"));
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFAHL(FALSE);
			// 			//AfxMessageBox(_T("5"));
			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAHL(FALSE);
		//AfxMessageBox(_T("6"));
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAHL(FALSE);
		//AfxMessageBox(_T("7"));
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);

	PostMessageUpdateAlignOffsetInfo();
	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	//// 检查目标Mark是否已成功定位
	//if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	//{
	//	if (FALSE == m_bTargetMarkSearchSucceed)
	//	{
	//		ReportAlignResultFAHL(FALSE);
	//		AfxMessageBox(_T("8"));
	//		m_bStatusBar = FALSE;
	//		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
	//		m_strStatusBarInfo2 = _T("");
	//		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

	//		return FALSE;
	//	}
	//}

	//// 检查对象Mark是否已成功定位，是否第一次移动拍照；
	//if (eObjectBench != curProductData.m_pAlignerParam->m_eObjectMarkType)
	//{
	//	if (FALSE == m_bObjectMarkSearchSucceed)
	//	{
	//		ReportAlignResultFAHL(FALSE);
	//		AfxMessageBox(_T("10"));
	//		m_bStatusBar = FALSE;
	//		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );
	//		m_strStatusBarInfo2 = _T("");
	//		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

	//		return FALSE;
	//	}	

	//	/*if (!CheckObjectDistance())
	//	{
	//	ReportAlignResultFAHL(FALSE);

	//	m_bStatusBar = FALSE;
	//	m_strStatusBarInfo1 = _T("对象距离超过设定标准，对象定位结果可能出错");
	//	m_strStatusBarInfo2 = _T("");
	//	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	//	return FALSE;
	//	}*/


	//}

	/*if (!CheckTargetDistance())
	{
	ReportAlignResultFAHL(FALSE);

	m_bStatusBar = FALSE;
	m_strStatusBarInfo1 = _T("目标距离超过设定标准，目标定位结果可能出错");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return FALSE;
	}*/

	if (!CheckTargetAngle())
	{
		ReportAlignResultFAHL(FALSE);
		//AfxMessageBox(_T("9"));
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	// 实时对象Mark定位	
	{
		scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
		scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
		scTimer stAlignTimer;   double dAlignTime(0.0);

		stObjectSearchTimer.Reset();
		m_nAlignTime = i+1;

		strtimelog = "开始执行对象拍照>\n";
		VisionAlignLogRecord(m_strAlignProcessData, strtimelog);
		if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
		{
			SetDefaultObjectSearchMarkPos(TRUE);
			std::vector<int> vnPosIndex;
			int nTempPosIndex = 0;
			for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
			{
				vnPosIndex.push_back(nTempPosIndex);
			}
			if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex))
			{
				if (0)
				{
					;
				}
				else
				{
					ReportAlignResultFAAL(FALSE);
				}

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;     			
			}
		}
		else
		{
			////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////
			// 是否勾选1次对位，如果1次对位，则走移动拍照流程；
			//if (TRUE == m_pSystempOptionConfig->m_bAlignOneTime)
			if (1)
			{
				if (0)  /////////是否使用集银定制
				{
					std::vector<int> vnPosIndex;
					vnPosIndex.clear();
					if (11 ==nMarkType)
					{
						vnPosIndex.push_back(2);
						vnPosIndex.push_back(3);
					}
					else  // 其它情况，不改变，则是全部拍照；
					{
						vnPosIndex.push_back(0);
						vnPosIndex.push_back(1);
						vnPosIndex.push_back(2);
						vnPosIndex.push_back(3);
					}
					m_nCheckObjectDistanceIndex = 0;
					if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex,0))
					{
						ReportAlignResultFAHL(FALSE); 

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

						return FALSE;     
					}

				}
				else  // 移动目标对象同时拍照
				{
					std::vector<int> vnPosIndex;
					vnPosIndex.clear();
					std::vector<int> vnTarPosIndex;
					vnTarPosIndex.clear();
					std::vector<int> vnObjPosIndex;
					int nSameType = 0;
					vnObjPosIndex.clear();
					int nPosIndex = 0;
					int i = 0;
					if (23 ==nMarkType)
					{
						//AfxMessageBox("23");
						for(i = 0; i < GetPosNum()/2; i++)  //2，3
						{
							nPosIndex = i+GetPosNum()/2;
							vnObjPosIndex.push_back(nPosIndex);
						}
						for(i = 0; i < GetPosNum()/2; i++)  //0，1
						{
							nPosIndex = i;
							vnTarPosIndex.push_back(nPosIndex);
						}
						//vnTarPosIndex.push_back(0);
						//vnTarPosIndex.push_back(1);
						//vnObjPosIndex.push_back(2);
						//vnObjPosIndex.push_back(3);
						nSameType = 0;
					}
					else if (24 == nMarkType)
					{
						//AfxMessageBox("24");
						for(i = 0; i < GetPosNum()/2; i++)  //2，3
						{
							nPosIndex = i+GetPosNum()/2;
							vnObjPosIndex.push_back(nPosIndex);
						}
						for(i = 0; i < GetPosNum()/2; i++)  //2，3
						{
							nPosIndex = i+GetPosNum()/2;
							vnTarPosIndex.push_back(nPosIndex);
						}
						//vnTarPosIndex.push_back(2);
						//vnTarPosIndex.push_back(3);
						//vnObjPosIndex.push_back(2);
						//vnObjPosIndex.push_back(3);
						nSameType = 1;
					}
					else  // 其它情况，不改变，则是全部拍照；
					{
						vnPosIndex.push_back(0);
						vnPosIndex.push_back(1);
						vnPosIndex.push_back(2);
						vnPosIndex.push_back(3);
					}
					m_nCheckObjectDistanceIndex = 0;
					if (FALSE == OnSerialCameraAlignerTargetAndObjectSearchFOBC(vnTarPosIndex,vnObjPosIndex,nSameType))
					{
						ReportAlignResultFAHL(FALSE); 

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();		
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
						return FALSE;     
					}
				}
			}
			////////////////////////////////////////////////////////////////////////////
			// 不勾选1次对位，则走对位偏移位置指令（阿伟哥调试）；
			else
			{
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(0))
				{
					if (1)
					{
						;
					}
					else
					{
						ReportAlignResultFAAL(FALSE);
					}

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;     			
				}
			}

		}


		dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);

		// 			str.Format("OnSerialCameraAlignerObjectSearchExFOBJ Serial camera object search time = %f",dObjectSearchTime);
		// 			AlignLogRecord(str);
	}

	// 获取屏幕十字位置			
	CCoordPos cpCurCrossPos;
	std::vector<CCoordPos> vcpCurCrossPos;
	for(int n = 0; n < GetPosNum(); n++)
	{
		ImageRoi roi;
		GetPosImageROIParam(n, roi);
		cpCurCrossPos.m_dPosX = roi.m_dCrossX;
		cpCurCrossPos.m_dPosY = roi.m_dCrossY;
		vcpCurCrossPos.push_back(cpCurCrossPos);
	}
	int nAlnIndex = 1;

	scTimer stAlignTimer;   double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	{
		// 执行对位
		//AfxMessageBox(_T("222222222"));
		if(FALSE == ExecuteAlignExHLLayer(nAlnIndex, vcpCurCrossPos))
		{
			ReportAlignResultFAHL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}

		// 更新主界面对位精度、次数、对位总时间
		CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		}

		m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
		m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
		m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

		CCoordPos cpProduct = GetAlignProductOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		}
		m_apAlignerProcesInfo.nTimes  = 1;

		m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
		m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
		m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

		m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

		PostMessageUpdateAlignerProcessInfo();

		//			CCoordPos cp = GetAlignPlatformOffset();
		CPlatformOptionInfo optionInfo;
		GetPlatformOptionInfo(optionInfo);
		/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
		|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
		|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
		//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
		//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
		//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
		if(IsAxisMoveOverRun(cp))
		{
			ReportAlignResultFAHL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
			m_strStatusBarInfo2.Format(_T(""));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}


		// 执行本次对位操作
		// 获取平台对位应移动到的绝对位置
		CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

		if (pAlignerParam->GetEnableAlnTargetOffset())
		{	
			AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
		}
		//AfxMessageBox("begin move");
		// 通信驱动平台运动到指定位置
		if (FALSE == CommuciateDrivePlatformAxisMove2(pPlatformXYDAxisPos))
		{
			//AfxMessageBox("false");
			ReportAlignResultFAHL(FALSE);
			// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
			// 				AlignLogRecord(str);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}
		else
		{
			if (0)
			{
				;
			}
			else
			{
				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
			}
			i = 0;
			m_bStatusBar = TRUE;
			m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

			dAlignTime = m_apAlignerProcesInfo.dTime;

			// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
			// 				AlignLogRecord(str);
			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;
				// 					CTime t = CTime::GetCurrentTime();
				// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
					i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;

				// 					FILE *stream;
				// 					CString strPath = m_strAlignProcessData;
				// 					stream = fopen(strPath, _T("a+t")); 					
				// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 					fclose(stream);VCRemoveFile(strPath);	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;
				// 					CTime t = CTime::GetCurrentTime();
				// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
				strOut = strTemp + strOut;

				// 					FILE *stream;
				// 					CString strPath = m_strAlignProcessData;
				// 					stream = fopen(strPath, _T("a+t"));               
				// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 					fclose(stream);VCRemoveFile(strPath);

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录当前平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
				CString strTemp;
				// 					CTime t = CTime::GetCurrentTime();
				// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strInfo;
				strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
					i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
				strInfo = strTemp + strInfo;

				// 					FILE *stream;
				// 					CString strPath = m_strAlignProcessData;
				// 					stream = fopen(strPath, _T("a+t"));
				// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
				// 					fclose(stream);VCRemoveFile(strPath);	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strInfo);
			}

			ReportAlignResultFAHL(TRUE);
			return TRUE;
		}
	}
	ReportAlignResultFAHL(TRUE);
	return TRUE;
}


BOOL vcXYDVisionAlign::OnlineAlignExFAHL(int nOffsetIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString str;
	// 	str.Format("Begin to FAHL Align---------------");
	// 	AlignLogRecord(str);
	//	CCoordPos platOffset;
	//	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);

	stCheckInvalidTimer.Reset();

	CString strCmd = _T("VAHL:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFAHL(FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd) /*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFAHL(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFAHL(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFAHL(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFAHL(FALSE);

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAHL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAHL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);

	PostMessageUpdateAlignOffsetInfo();
	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	// 检查目标Mark是否已成功定位
	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	{
		if (FALSE == m_bTargetMarkSearchSucceed)
		{
			ReportAlignResultFAHL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}

	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);
	// 	str.Format("Check Invalid time = %f",dCheckInvalidTime);
	// 	AlignLogRecord(str);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo(); 

	// 获取当前产品最大对位次数
	int nMaxAlignTime = curProductData.m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);


	// 获取屏幕十字位置			
	CCoordPos cpCurCrossPos;
	std::vector<CCoordPos> vcpCurCrossPos;
	for(int n = 0; n < GetPosNum(); n++)
	{
		ImageRoi roi;
		GetPosImageROIParam(n, roi);
		cpCurCrossPos.m_dPosX = roi.m_dCrossX;
		cpCurCrossPos.m_dPosY = roi.m_dCrossY;
		vcpCurCrossPos.push_back(cpCurCrossPos);
	}

	int nStartPatIndex = 0;
	int nAlnIndex = 0;
	nMaxAlignTime = 1; // 对位两次
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	// 	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 	{  
	// 		m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //第一次对位用新的TargetPos
	// 	}
	for (i=0; i<nMaxAlignTime+1; i++)
	{
		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();

		// 实时对象Mark定位		
		// 		if (i == 0)
		// 		{
		// 			// 检查目标Mark是否已成功定位
		// 			if (FALSE == m_bObjectMarkSearchSucceed)
		// 			{
		// 				ReportAlignResultFAHL(FALSE);
		// 				
		// 				m_bStatusBar = FALSE;
		// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
		// 				m_strStatusBarInfo2 = _T("");
		// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
		// 				
		// 				return FALSE;
		// 			}
		// 		}
		// 		else if (i > 0)
		{
			stObjectSearchTimer.Reset();
			m_nAlignTime = i+1;

			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				SetDefaultObjectSearchMarkPos(TRUE);
				std::vector<int> vnPosIndex;
				int nTempPosIndex = 0;
				for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
				{
					vnPosIndex.push_back(nTempPosIndex);
				}
				//if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex))				
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex))
				{
					ReportAlignResultFAHL(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;     			
				}
			}
			else
			{
				//if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ())
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
				{
					ReportAlignResultFAHL(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;     			
				}
			}

			dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);

			// 			str.Format("OnSerialCameraAlignerObjectSearchExFOBJ Serial camera object search time = %f",dObjectSearchTime);
			// 			AlignLogRecord(str);
		}



		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			nAlnIndex = 1;

			// 执行对位计算
			stCaluteAlignTimer.Reset();
			if(FALSE == ExecuteAlignExHLLayer(nAlnIndex, vcpCurCrossPos))
			{
				ReportAlignResultFAHL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 
			// 		str.Format("Align excute time = %f",dCaluteAlignTime);

			// 		AlignLogRecord(str);

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}

			m_apAlignerProcesInfo.nTimes  = i+1;
			// m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dTime   = stTotalAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			//			CCoordPos cp = GetAlignPlatformOffset();
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAHL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}
			// 			if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			// 			{  
			// 				m_pAlignerTool->m_bUsePreTargetPos = TRUE;    //执行一次对位成功后，使用上一次的TargetPos结果  
			// 			}

			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			if (pAlignerParam->GetEnableAlnTargetOffset())
			{	
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}


			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAHL(FALSE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);


				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t")); 					
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));               
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				ReportAlignResultFAHL(TRUE);
				return TRUE;
			}
		}

		if (pAlignerParam->m_bCheckAlnTargetOffsetEnable)
		{    //////////////////////////////////////////////////////////////////////////
			//当使用多次对位目标偏移是，判断是否达到精度
			// 判断是否执行对位动作
			if (i!=0 && TRUE == IsAlignFinished(i+1))
			{
				CCoordPos cpOffset = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

				m_apAlignerProcesInfo.nTimes  = i;
				m_apAlignerProcesInfo.dTime   = stTotalAlignTimer.GetTimeMilli(FALSE);
				m_apAlignerProcesInfo.dXMove  = cpOffset.m_dPosX;  
				m_apAlignerProcesInfo.dYMove  = cpOffset.m_dPosY;
				m_apAlignerProcesInfo.dDMove  = cpOffset.m_dAngle;

				CCoordPos cpProduct = GetAlignProductOffset();
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					cpProduct = GetAlignProductOffsetXYPD();
				}
				m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
				m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
				m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

				PostMessageUpdateAlignerProcessInfo();
				double dPosX = pAlignerParam->GetAlnTargetOffsetX();
				double dPosY = pAlignerParam->GetAlnTargetOffsetY();

				dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

				//////////////////////////////////////////////////////////////////////////
				//加偏移量移动到对位位置
				CCoordPos cp = GetAlignPlatformOffset();
				cp.m_dPosX+=dPosX;
				cp.m_dPosY+=dPosY;
				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);
				/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
				|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
				|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
				//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
				//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
				//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
				if(IsAxisMoveOverRun(cp))
				{

					ReportAlignResultFAHL(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
				//////////////////////////////////////////////////////////////////////////
				////
				//首先把目标mark搜索时的轴位置（即当前位置）付给m_pPlatformPos，再加上对位偏移量；

				if (pAlignerParam->GetEnableAlnTargetOffset())
				{	
					AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
				}

				//////////////////////////////////////////////////////////////////////////

				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFAHL(FALSE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
					// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
					// 				AlignLogRecord(str);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();
					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							//D角度不累加

						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}
						//D角度不累加
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
					// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
					// 				AlignLogRecord(str);			


					m_bStatusBar = IsAlignSucceed();
					if (m_bStatusBar)
					{
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
						ReportAlignResultFAHL(m_bStatusBar);

					}

					if (!m_bStatusBar) 
					{
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						ReportAlignResultFAHL(FALSE);

						//						SaveCurAllCameraChannelSearchImg();
					}

					m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
					dAlignTime = m_apAlignerProcesInfo.dTime;

					// 记录对位精度
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
					{
						CString strTemp;

						CString strOut;
						strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
							i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
						strOut = strTemp + strOut;
						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					}

					// 记录对位时间
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
					{
						CString strTemp;
						CString strOut;
						strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
						strOut = strTemp + strOut;
						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strOut);
					}

					// 记录当前平台各个轴的绝对位置
					if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
					{
						CString strTemp;
						CString strInfo;
						strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
							i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
						strInfo = strTemp + strInfo;


						VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
						VisionAlignLogRecord(m_strAlignProcessData, strInfo);
					}
				}   

				//ReportAlignResultFAHL(TRUE);
				return m_bStatusBar;  
			} //isfinish




		}//SAlnenable
		{

			nAlnIndex = i;

			// 执行对位计算
			stCaluteAlignTimer.Reset();
			if(FALSE == ExecuteAlignExHLLayer(nAlnIndex, vcpCurCrossPos))
			{
				ReportAlignResultFAHL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stTotalAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			//			CCoordPos cp = GetAlignPlatformOffset();
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{

				ReportAlignResultFAHL(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAHL(FALSE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;
					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;
					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

			// 调整相机平台的位置，为下次对位做准备
			/*			std::vector<CPlatformAxisPos*> vpPlatformAxisPos;
			std::vector<CPlatformXYAxisPos*> vpPlatformXYAxisPos;
			vpPlatformAxisPos.clear();
			vpPlatformXYAxisPos.clear();			

			if ((m_pPlatformInfo->m_eCamPlatformType != eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX))
			{
			vpPlatformAxisPos = GetAlignCameraMovementResults();               

			for (int q=0; q<vpPlatformAxisPos.size(); q++)
			{
			vpPlatformXYAxisPos.push_back((CPlatformXYAxisPos*)vpPlatformAxisPos.at(q));
			}

			// 单相机，则保留下次对位中，相机需要调整到的各个位置
			m_vpSingleCamAlignCamPltfmAxisPos.clear();
			if (1 == m_pPlatformInfo->m_nCamNum)
			{
			for (q=0; q<vpPlatformXYAxisPos.size(); q++)
			{
			m_vpSingleCamAlignCamPltfmAxisPos.push_back(vpPlatformXYAxisPos.at(q));
			}

			return TRUE;
			}

			// 多相机，则通信驱动相机平台到位
			if (FALSE == CommuciateDriveCamPlatformAxisMove(vpPlatformXYAxisPos))
			{
			ReportAlignResultFAHL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_CAM_PLATFORM_ARRIVED_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			SaveCurAllCameraChannelSearchImg();
			return FALSE;  
			}

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
			CString strTemp;
			CTime t = CTime::GetCurrentTime();
			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_AND_THEN_RESET_CAM_PLATFORM_POS), i+1);
			strInfo = strTemp + strInfo;

			for (int i=0; i<vpPlatformXYAxisPos.size(); i++)
			{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpPlatformXYAxisPos.at(i)->m_dPosX, vpPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
			}

			FILE *stream;
			CString strPath = m_strAlignProcessData;
			stream = fopen(strPath, _T("a+t"));
			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			fclose(stream);VCRemoveFile(strPath);				
			}	
			} */
		} // else


	}// for	
	ReportAlignResultFAHL(TRUE);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFAAB(int nOffsetIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString str;
	// 	str.Format("Begin to FAAB Align---------------");
	// 	AlignLogRecord(str);
	//	CCoordPos platOffset;
	//	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);

	stCheckInvalidTimer.Reset();
	if (optionInfo.m_bEnableMutiTarget)
	{
		m_bTargetMarkSearchSucceed=m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
		if (m_bTargetMarkSearchSucceed)
		{
			SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
			m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			for (int i=0;i<nPosNum;i++)
			{
				SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
			}
			PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
		}	
	}
	CString strCmd = _T("VAAB:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFAAB(FALSE, TRUE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( !CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFAAB(FALSE, TRUE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFAAB(FALSE, TRUE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFAAB(FALSE, TRUE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFAAB(FALSE, TRUE);
			// 
			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAAB(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAAB(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	// 检查目标Mark是否已成功定位
	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	{
		if (FALSE == m_bTargetMarkSearchSucceed)
		{
			ReportAlignResultFAAB(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}

	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);
	// 	str.Format("Check Invalid time = %f",dCheckInvalidTime);
	// 	AlignLogRecord(str);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo(); 

	// 获取当前产品最大对位次数
	int nMaxAlignTime = curProductData.m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);

	CCoordPos cpAlignBenchOffset;
	CPlatformXYDAxisPos platformXYDAxisPos;

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	// 	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 	{  
	// 		m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //第一次对位用新的TargetPos
	// 	}
	for (i=0; i<nMaxAlignTime+1; i++)
	{
		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();

		// 实时对象Mark定位		
		// 		if (i == 0)
		// 		{
		// 			// 检查目标Mark是否已成功定位
		// 			if (FALSE == m_bObjectMarkSearchSucceed)
		// 			{
		// 				ReportAlignResultFAAB(FALSE);
		// 				
		// 				m_bStatusBar = FALSE;
		// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
		// 				m_strStatusBarInfo2 = _T("");
		// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
		// 				
		// 				return FALSE;
		// 			}
		// 		}
		// 		else if (i > 0)
		{
			stObjectSearchTimer.Reset();
			m_nAlignTime = i+1;

			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				SetDefaultObjectSearchMarkPos(TRUE);
				std::vector<int> vnPosIndex;
				int nTempPosIndex = 0;
				for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
				{
					vnPosIndex.push_back(nTempPosIndex);
				}
				if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ(vnPosIndex))
				{
					ReportAlignResultFAAB(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;     			
				}
			}
			else
			{
				if (FALSE == OnSerialCameraAlignerObjectSearchExFOBJ())
				{
					ReportAlignResultFAAB(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;     			
				}
			}


			dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);

			// 			str.Format("OnSerialCameraAlignerObjectSearchExFOBJ Serial camera object search time = %f",dObjectSearchTime);
			// 			AlignLogRecord(str);
		}

		// 执行基准对位
		if(1)
		{
			if (i == 0)
			{
				// 设置图像中心十字基准目标
				SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
				m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

				// 执行对位
				m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
				if(FALSE == ExecuteAlign(i))
				{
					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					ReportAlignResultFAAB(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
					//					m_strStatusBarInfo2 = _T("");
					m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();	

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
					return FALSE;     
				}

				// 获取对位结果
				cpAlignBenchOffset = GetAlignPlatformOffset();
				CPlatformXYDAxisPos* pAlignPlatformMovementResults = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
				platformXYDAxisPos = *pAlignPlatformMovementResults;
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			}
		}

		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFAAB(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
			//			SaveCurAllCameraChannelSearchImg();

			return FALSE;     
		}
		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 
		// 		str.Format("Align excute time = %f",dCaluteAlignTime);
		// 		AlignLogRecord(str);
		// 		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
		// 		{  
		// 			m_pAlignerTool->m_bUsePreTargetPos = TRUE;    //执行一次对位成功后，使用上一次的TargetPos结果  
		// 		}

		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			// 			CCoordPos cp = GetAlignPlatformOffset();
			// 			if (pAlignerParam->GetEnableAlnTargetOffset())
			// 			{
			// 				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			// 				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			// 			}
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAAB(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAAB(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);




				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t")); 					
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));               
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				ReportAlignResultFAAB(TRUE, TRUE, cpAlignBenchOffset, &platformXYDAxisPos);

				return TRUE;
			}
		}

		// 判断是否执行对位动作
		if (i!=0 && TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);
			// 
			// 			str.Format("Total Align time = %f",dTotalAlignTime);
			// 			AlignLogRecord(str);

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cp = GetAlignPlatformOffset();

			m_apAlignerProcesInfo.nTimes  = i;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			{
				cpProduct = GetAlignProductOffsetXYPD();
			}
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			if (pAlignerParam->GetEnableAlnTargetOffset() && IsAlignSucceed())
			{				
				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);
				CCoordPos cp = GetAlignPlatformOffset();
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
				/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
				|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
				|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
				//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
				//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
				//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
				if(IsAxisMoveOverRun(cp))
				{

					ReportAlignResultFAAB(FALSE,TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFAAB(FALSE,TRUE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();
					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							//D角度不累加

						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}
						//D角度不累加
						if (m_pSystempOptionConfig->m_bShowSepTargetPos)
						{
							UpdateTargetPosAfterRoate();
						}
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}	
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				}  
			}

			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
				ReportAlignResultFAAB(m_bStatusBar, TRUE, cpAlignBenchOffset, &platformXYDAxisPos);
			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFAAB(FALSE, TRUE);

				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	


			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));               
				// 				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), i, dTotalAlignTime);
				strOut = strTemp + strOut;

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));               
				// 				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			//			ReportAlignResultFAAB(m_bStatusBar, TRUE, cpAlignBenchOffset, &platformXYDAxisPos);
			return m_bStatusBar;  
		}
		else
		{
			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset = cpProduct.m_dPosX;
			m_apAlignerProcesInfo.dYOffset = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset = cpProduct.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			//			CCoordPos cp = GetAlignPlatformOffset();
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{

				ReportAlignResultFAAB(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAAB(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);		



				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t")); 					
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));               
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);		

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

			// 调整相机平台的位置，为下次对位做准备
			/*			std::vector<CPlatformAxisPos*> vpPlatformAxisPos;
			std::vector<CPlatformXYAxisPos*> vpPlatformXYAxisPos;
			vpPlatformAxisPos.clear();
			vpPlatformXYAxisPos.clear();			

			if ((m_pPlatformInfo->m_eCamPlatformType != eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX))
			{
			vpPlatformAxisPos = GetAlignCameraMovementResults();               

			for (int q=0; q<vpPlatformAxisPos.size(); q++)
			{
			vpPlatformXYAxisPos.push_back((CPlatformXYAxisPos*)vpPlatformAxisPos.at(q));
			}

			// 单相机，则保留下次对位中，相机需要调整到的各个位置
			m_vpSingleCamAlignCamPltfmAxisPos.clear();
			if (1 == m_pPlatformInfo->m_nCamNum)
			{
			for (q=0; q<vpPlatformXYAxisPos.size(); q++)
			{
			m_vpSingleCamAlignCamPltfmAxisPos.push_back(vpPlatformXYAxisPos.at(q));
			}

			return TRUE;
			}

			// 多相机，则通信驱动相机平台到位
			if (FALSE == CommuciateDriveCamPlatformAxisMove(vpPlatformXYAxisPos))
			{
			ReportAlignResultFAAB(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_CAM_PLATFORM_ARRIVED_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			SaveCurAllCameraChannelSearchImg();
			return FALSE;  
			}

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
			CString strTemp;
			CTime t = CTime::GetCurrentTime();
			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_AND_THEN_RESET_CAM_PLATFORM_POS), i+1);
			strInfo = strTemp + strInfo;

			for (int i=0; i<vpPlatformXYAxisPos.size(); i++)
			{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpPlatformXYAxisPos.at(i)->m_dPosX, vpPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
			}

			FILE *stream;
			CString strPath = m_strAlignProcessData;
			stream = fopen(strPath, _T("a+t"));
			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			fclose(stream);VCRemoveFile(strPath);				
			}	
			} */
		} // else


	}// for	
	ReportAlignResultFAAB(TRUE, TRUE, cpAlignBenchOffset, &platformXYDAxisPos);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFAAC(int nOffsetIndex, int nStartPatIndex,int nBenchOffsetIndex/* = -1*/, int nExProductIndex/* = 0*/,int nTarFixOffsetIndex /* = 0 */)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	SetAlignBenchOffsetIndex(nBenchOffsetIndex);
	SetAlignExProductIndex(nExProductIndex);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// start 直接根据searchdata中图像坐标和轴位置 设置进对位工具中；
	{
		int nSize1 = m_vvpTargetPlatformAxisPosMultiEx.size();
		int nSize2 = m_vvpObjectPlatformAxisPosMultiEx.size();
		int nSize3 = m_vmpObjectMarkImagePos_MultiEX.size();
		int nSize4 = m_vmpTargetMarkImagePosMultiEx.size();
		bool bTmp = (nExProductIndex >=0) &&  (nExProductIndex <nSize1) &&  (nExProductIndex <nSize2) &&  (nExProductIndex <nSize3)  &&  (nExProductIndex <nSize4);

		if (bTmp)
		{

			vector<CPlatformAxisPos*> tmpObjectPlatformAxisPos;
			vector<CPlatformAxisPos*> tmpTargetPlatformAxisPos;
			tmpObjectPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);
			tmpTargetPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);

			if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
			{
				if (optionInfo.m_bObjectSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{
						tmpObjectPlatformAxisPos.at(jt) = m_vvpObjectPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpObjectMarkImagePos = m_vmpObjectMarkImagePos_MultiEX.at(nExProductIndex);
				}
				else
				{
					tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				}

				if (optionInfo.m_bTargetSearchExProduct)
				{
					for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
					{	
						tmpTargetPlatformAxisPos.at(jt) = m_vvpTargetPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
					}
					m_mpTargetMarkImagePos = m_vmpTargetMarkImagePosMultiEx.at(nExProductIndex);
				}
				else
				{
					tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
				}

			}
			else
			{
				tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
				tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
			}


			m_pAlignerTool->SetTargetPlatformPos(tmpTargetPlatformAxisPos);
			//m_pAlignerTool->SetTargetMarkSearchResultsInit(tmpTargetImagePos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			m_pAlignerTool->SetObjectPlatformPos(tmpObjectPlatformAxisPos);
			//m_pAlignerTool->SetObjectMarkSearchResultsAll(tmpObjectImagePos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);


			m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
			m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();

		}
	}
	// end  直接根据searchdata中图像坐标和轴位置 设置进对位工具中；


	// 	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);
	// 	stCheckInvalidTimer.Reset();

	if (optionInfo.m_bEnableMutiTarget)
	{
		m_bTargetMarkSearchSucceed=m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
		if (m_bTargetMarkSearchSucceed)
		{
			SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
			m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
			int nPosNum = m_pPlatformInfo->m_nPositionNum;
			for (int i=0;i<nPosNum;i++)
			{
				SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
				SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
			}
			PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
		}	
	}

	CString strCmd = _T("VAAC:");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFAAC(FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/* FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFAAC(FALSE);

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFAAC(FALSE);

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFAAC(FALSE);

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFAAC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);

			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAAC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();	

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAAC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	if (optionInfo.m_nTarInfoCommModeInDiffPC == 2)//通过PLC交换目标图像坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetImgPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetImagePos(vnPosIndex,vTargetImgPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportAlignResultFAAC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARIMGPOS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					ReportAlignResultFAAC(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARIMGPOS);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					return FALSE;
				}

				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex,TRUE,vTargetImgPos.at(i));

			}

			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);


			if (!m_bIsExecuteFixTargetCheck) // 固定目标对位 执行标定检查时  对位时不进行对象目标尺寸检测 
			{
				if (!CheckTargetDistance())
				{
					ReportAlignResultFAAC(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					return FALSE;
				}
			}

		}
	}
	else if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
	{
		std::vector<int> vnPosIndex;
		std::vector<CCoordPos> vTargetCoordPos;
		std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
		m_pAlignerTool->SetIsReadTargetPlatformPos(TRUE);
		BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetPlatformPos(vnPosIndex,vTargetCoordPos,vTargetPlatAxisPos);
		if (!bCommuciateGetTargetPlatformPos)	
		{
			ReportAlignResultFAAC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARPLATFORMPOS);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}
		else
		{
			int nPosIndex=0;
			CMarkPlatformPos mpTargetMarkPos;
			mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();
			for (int i=0;i<mpTargetMarkPos.m_vbOK.size();i++)
			{
				mpTargetMarkPos.m_vbOK.at(i) = TRUE;
			}

			for(int i=0;i<vnPosIndex.size();i++)
			{
				nPosIndex = vnPosIndex.at(i);
				if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
				{
					ReportAlignResultFAAC(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_COMMGETTARPLATFORMPOS);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					return FALSE;
				}

				SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
				SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
				mpTargetMarkPos.SetMarkPlatformPos(nPosIndex,TRUE,vTargetCoordPos.at(i));
			}

			m_pAlignerTool->SetTargetMarkPlatformPos(mpTargetMarkPos);

			if (!m_bIsExecuteFixTargetCheck) // 固定目标对位 执行标定检查时  对位时不进行对象目标尺寸检测 
			{
				if (!CheckTargetDistance())
				{
					ReportAlignResultFAAC(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					return FALSE;
				}
			}

		}
	}
	else
	{
		m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
		if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
		{
			if (FALSE == m_bTargetMarkSearchSucceed)
			{
				ReportAlignResultFAAC(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();	

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

				return FALSE;
			}
		}
	}
	//	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo(); 

	// 获取当前产品最大对位次数
	int nMaxAlignTime = curProductData.m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	// 	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 	{  
	// 		m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //第一次对位用新的TargetPos
	// 	}

	// 对位居中变量
	CCoordPos cpBenchOffset;
	CPlatformXYDAxisPos benchPlatformXYDAxisPos;

	for (i=0; i<nMaxAlignTime+1; i++)
	{
		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();

		{
			stObjectSearchTimer.Reset();
			m_nAlignTime = i+1;
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				// 				if (m_pPlatformInfo->m_bTarCamWithDiffObjCam)
				// 				{
				// 					if (nExProductIndex >= 2)
				// 					{
				// 						return FALSE;
				// 					}
				// 
				// 					SetDefaultObjectSearchMarkPos(TRUE, nExProductIndex + 19);
				// 
				// 					std::vector<int> vnPosIndex;
				// 					int nTempPosIndex = 0;
				// 					for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/4; nTempPosIndex++)
				// 					{
				// 						vnPosIndex.push_back(nTempPosIndex + 2*nExProductIndex);
				// 					}
				// 
				// 					if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex))
				// 					{
				// 						ReportAlignResultFAAC(FALSE);
				// 
				// 						m_bStatusBar = FALSE;
				// 						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				// 						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
				// 						if (!m_boIsSnapImgSucceed)	//  [5/8/2020 zzc]
				// 						{
				// 							m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
				// 						}
				// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 						PostMessageUpdateStatusBarInfo();		
				// 						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				// 						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				// 						return FALSE;     			
				// 					}
				// 
				// 				}
				// 				else
				{
					SetDefaultObjectSearchMarkPos(TRUE);

					std::vector<int> vnPosIndex;
					int nTempPosIndex = 0;

					if (optionInfo.m_bEnableTargetAndObjectPositionVirtualMode)
					{
						int nObjectVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;
						BOOL bEnableObjectPositionVirtualMode = pCurProductData->m_pAlignerParam->GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;

						if (bEnableObjectPositionVirtualMode)
						{
							switch(nObjectVirtualMode)
							{
							case 0:
								{
									// 位置1、位置2
									vnPosIndex.push_back(0);
									vnPosIndex.push_back(1);

								}
								break;

							case 1:
								{
									// 位置3、位置4
									vnPosIndex.push_back(2);
									vnPosIndex.push_back(3);
								}
								break;

							case 2:
								{
									// 位置1、位置3
									vnPosIndex.push_back(0);
									vnPosIndex.push_back(2);
								}
								break;

							case 3:
								{
									// 位置2、位置4
									vnPosIndex.push_back(1);
									vnPosIndex.push_back(3);
								}
								break;

							default:
								{
									return FALSE;
								}
								break;
							}
						}
						else
						{
							vnPosIndex.push_back(0);
							vnPosIndex.push_back(1);
							vnPosIndex.push_back(2);
							vnPosIndex.push_back(3);
						}
					}
					else
					{
						for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
						{
							vnPosIndex.push_back(nTempPosIndex);
						}
					}

					if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex))
					{
						ReportAlignResultFAAC(FALSE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
						if (!m_boIsSnapImgSucceed)	//  [5/8/2020 zzc]
						{
							m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
						}
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();		

						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

						return FALSE;     			
					}
				}
			}
			else
			{
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
				{
					ReportAlignResultFAAC(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)	//  [5/8/2020 zzc]
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();	

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));

					return FALSE;     			
				}
			}

			dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);

		}

		// 执行基准对位
		if(optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			if (i == 0)
			{
				// 设置图像中心十字基准目标
				SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
				m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

				// 执行对位
				m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
				if(FALSE == ExecuteAlign(i))
				{
					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					ReportAlignResultFAAC(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
					//					m_strStatusBarInfo2 = _T("");
					m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();	

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
					return FALSE;     
				}

				// 获取对位结果
				cpBenchOffset = GetAlignPlatformOffset();
				CPlatformXYDAxisPos* pAlignPlatformMovementResults = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
				benchPlatformXYDAxisPos = *pAlignPlatformMovementResults;
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			}
		}

		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFAAC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();	

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
			//			SaveCurAllCameraChannelSearchImg();

			return FALSE;     
		}
		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 

		// 		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
		// 		{  
		// 			m_pAlignerTool->m_bUsePreTargetPos = TRUE;    //执行一次对位成功后，使用上一次的TargetPos结果  
		// 		}

		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();


			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAAC(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			// 当启用目标补偿，且不发送目标补偿到PLC时，在MMVA指令中增加目标补偿运动量，否则在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器中
			if (pAlignerParam->GetEnableAlnTargetOffset() && FALSE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
			{
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAAC(FALSE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		

				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();

				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				if (pAlignerParam->GetEnableAlnTargetOffset() && TRUE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
				{
					AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

					// 当启用目标补偿，且发送目标补偿到PLC时，不在MMVA指令中增加目标补偿运动量，而是在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器中
					ReportAlignResultFAAC(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos, pPlatformXYDAxisPos);
				}
				else
				{
					ReportAlignResultFAAC(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos);
				}

				return TRUE;
			}
		}

		// 判断是否执行对位动作
		if (i!=0 && TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset();
			if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			{
				cpProduct = GetAlignProductOffsetXYPD();
			}
			m_apAlignerProcesInfo.nTimes  = i;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			if (pAlignerParam->GetEnableAlnTargetOffset() && IsAlignSucceed() && FALSE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
			{				
				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);
				CCoordPos cp = GetAlignPlatformOffset();
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

				if(IsAxisMoveOverRun(cp))
				{
					ReportAlignResultFAAC(FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFAAC(FALSE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();
					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							//D角度不累加

						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}
						//D角度不累加
						if (m_pSystempOptionConfig->m_bShowSepTargetPos)
						{
							UpdateTargetPosAfterRoate();
						}
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}	
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				}  
			}

			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);

				if (pAlignerParam->GetEnableAlnTargetOffset() && TRUE == pAlignerParam->GetEnableAlnSendTargetOffsetToPLC())
				{
					CPlatformOptionInfo optionInfo;
					GetPlatformOptionInfo(optionInfo);
					CCoordPos cp = GetAlignPlatformOffset();
					cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
					cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

					if(IsAxisMoveOverRun(cp))
					{
						ReportAlignResultFAAC(FALSE);

						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
						m_strStatusBarInfo2.Format(_T(""));
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
						return FALSE;
					}


					// 执行本次对位操作
					// 获取平台对位应移动到的绝对位置
					CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
					pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

					AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

					// 当启用目标补偿，且发送目标补偿到PLC时，不在MMVA指令中增加目标补偿运动量，而是在报告对位成功指令中将目标补偿绝对位置放在备用轴位置寄存器
					ReportAlignResultFAAC(m_bStatusBar, FALSE, cpBenchOffset, &benchPlatformXYDAxisPos, pPlatformXYDAxisPos);
				} 
				else
				{
					ReportAlignResultFAAC(m_bStatusBar, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos);
				}
			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFAAC(FALSE);
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	


			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));               
				// 				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), i, dTotalAlignTime);
				strOut = strTemp + strOut;

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));               
				// 				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			//			ReportAlignResultFAAC(m_bStatusBar);
			return m_bStatusBar;  
		}
		else
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAAC(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAAC(FALSE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t")); 					
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));               
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

		} // else

	}// for	

	ReportAlignResultFAAC(TRUE, optionInfo.m_bEnableAlignBenchCenter, cpBenchOffset, &benchPlatformXYDAxisPos);
	return TRUE;
}

BOOL vcXYDVisionAlign::ReportSaveQRCodeFQRC(BOOL bResult)
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFQRC(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcReadQRCode(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReAlignResultInfoFQRC(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,TRUE);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
	}
	return TRUE;
}

BOOL vcXYDVisionAlign::SaveCSVToDisk(CString strFileName,CString strContent,BOOL bCreateNew)
{
	CString  str;
	BOOL bSuccess = TRUE;
	DWORD  dwBytesWritten = 0;
	SYSTEMTIME sys;

	GetLocalTime(&sys);

	DWORD nWriteStrLen = strContent.GetLength();
	HANDLE  hFile;
	if (bCreateNew)
	{
		hFile = CreateFile(
			strFileName,//创建或打开的文件或设备的名称(这里是txt文件)。
			GENERIC_WRITE,// 文件访问权限,写
			0,//共享模式,这里设置0防止其他进程打开文件或设备
			NULL,//SECURITY_ATTRIBUTES结构，安全描述，这里NULL代表默认安全级别
			CREATE_ALWAYS,//对于存在或不存在的设置执行的操作，如文件不存在则创建它
			/*FILE_ATTRIBUTE_NORMAL|*/FILE_FLAG_WRITE_THROUGH,//设置文件的属性，里面有高速缓存的选项
			NULL);
	}
	else
	{
		hFile = CreateFile(
			strFileName,//创建或打开的文件或设备的名称(这里是txt文件)。
			GENERIC_WRITE,// 文件访问权限,写
			0,//共享模式,这里设置0防止其他进程打开文件或设备
			NULL,//SECURITY_ATTRIBUTES结构，安全描述，这里NULL代表默认安全级别
			OPEN_ALWAYS,//对于存在或不存在的设置执行的操作，如文件不存在则创建它
			FILE_ATTRIBUTE_NORMAL/*|FILE_FLAG_WRITE_THROUGH*/,//设置文件的属性，里面有高速缓存的选项
			NULL);
	}


	if (hFile != INVALID_HANDLE_VALUE)
	{
		SetFilePointer(hFile,NULL,NULL,FILE_END);
		if(WriteFile(hFile, (LPCTSTR)strContent, nWriteStrLen, &dwBytesWritten,NULL)==FALSE)
		{	
			bSuccess = FALSE;
		}
		CloseHandle(hFile);
	} 
	else
	{
		bSuccess = FALSE;
	}
	return bSuccess;
}

BOOL vcXYDVisionAlign::OnlineAlignExFAOT(int nOffsetIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString str;

	CString strTempWarningType = _T("");
	CString strCmd = _T("");
	GetCommCommandName(strCmd);
	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	stCheckInvalidTimer.Reset();
	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{

		ReportAlignResultFAOT(FALSE, TRUE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{
		ReportAlignResultFAOT(FALSE, TRUE);

		m_bStatusBar = FALSE;

		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (FALSE == m_bValidAlignerTool)
	{
		ReportAlignResultFAOT(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		ReportAlignResultFAOT(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFAOT(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAOT(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAOT(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	// 检查目标Mark是否已成功定位
	// 	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	// 	{
	// 		if (FALSE == m_bTargetMarkSearchSucceed)
	// 		{
	// 			ReportAlignResultFAAC(FALSE);
	// 
	// 			m_bStatusBar = FALSE;
	// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
	// 			m_strStatusBarInfo2 = _T("");
	// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
	// 
	// 			return FALSE;
	// 		}
	// 	}

	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);
	// 	str.Format("Check Invalid time = %f",dCheckInvalidTime);
	// 	AlignLogRecord(str);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo(); 

	// 获取当前产品最大对位次数
	int nMaxAlignTime = curProductData.m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CCoordPos cpAlignBenchOffsetObject;
	CCoordPos cpAlignBenchOffsetTarget;
	CCoordPos cpAlignBenchOffset;


	// 	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 	{  
	// 		m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //第一次对位用新的TargetPos
	// 	}
	for (i=0; i<nMaxAlignTime+1; i++)
	{
		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();


		{
			stObjectSearchTimer.Reset();
			m_nAlignTime = i+1;
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				SetDefaultObjectSearchMarkPos(TRUE);

				std::vector<int> vnPosIndex;
				int nTempPosIndex = 0;

				for(nTempPosIndex = GetPosNum()/2; nTempPosIndex < GetPosNum(); nTempPosIndex++)
				{
					vnPosIndex.push_back(nTempPosIndex);
				}

				if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex,nStartPatIndex))
				{
					ReportAlignResultFAOT(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;  
				}
				vnPosIndex.clear();
				for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
				{
					vnPosIndex.push_back(nTempPosIndex);
				}
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex))
				{
					ReportAlignResultFAOT(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;     			
				}
			}
			else
			{
				if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
				{
					ReportAlignResultFAOT(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;  
				}
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
				{
					ReportAlignResultFAOT(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;     			
				}
			}

			dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
			// 
			// 			str.Format("OnSerialCameraAlignerObjectSearchCandidateExFOBC Serial camera object search time = %f",dObjectSearchTime);
			// 			AlignLogRecord(str);
		}

		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFAOT(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}
		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 
		// 		str.Format("Align excute time = %f",dCaluteAlignTime);
		// 		AlignLogRecord(str);
		// 		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
		// 		{  
		// 			m_pAlignerTool->m_bUsePreTargetPos = TRUE;    //执行一次对位成功后，使用上一次的TargetPos结果  
		// 		}

		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			// 			CCoordPos cp = GetAlignPlatformOffset();
			// 			if (pAlignerParam->GetEnableAlnTargetOffset())
			// 			{
			// 				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			// 				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			// 			}
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAOT(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}

			// 			if (pAlignerParam->m_dMovementRatioX!=1.0 || pAlignerParam->m_dMovementRatioY!= 1.0)
			// 			{
			// 				
			// 				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(pAlignerParam->m_dMovementRatioX,pAlignerParam->m_dMovementRatioY);
			// 			}

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;

			if (dWeldMovementRatioX != 1.0 || dWeldMovementRatioY != 1.0)
			{

				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAOT(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);
				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;



					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;


					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				// 执行基准对位
				if(1)
				{

					{
						//计算对象与图像中心距离
						// 设置图像中心十字基准目标
						SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
						m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

						// 执行对位
						m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFAOT(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//							m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetObject = GetAlignPlatformOffset();

						//计算目标与图像中心距离
						m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFAOT(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//							m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
					}

					cpAlignBenchOffset = cpAlignBenchOffsetObject;
					cpAlignBenchOffset.m_dAngle = cpAlignBenchOffsetTarget.m_dPosY;
				}

				ReportAlignResultFAOT(TRUE,TRUE,cpAlignBenchOffset);

				return TRUE;
			}
		}

		// 判断是否执行对位动作
		if (i!=0 && TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 			str.Format("Total Align time = %f",dTotalAlignTime);
			// 			AlignLogRecord(str);

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset();
			if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			{
				cpProduct = GetAlignProductOffsetXYPD();
			}
			m_apAlignerProcesInfo.nTimes  = i;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();
			if (pAlignerParam->GetEnableAlnTargetOffset() && IsAlignSucceed())
			{				
				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);
				CCoordPos cp = GetAlignPlatformOffset();
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
				/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
				|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
				|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
				//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
				//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
				//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
				if(IsAxisMoveOverRun(cp))
				{

					ReportAlignResultFAOT(FALSE,TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFAOT(FALSE,TRUE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();
					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							//D角度不累加

						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}
						//D角度不累加
						if (m_pSystempOptionConfig->m_bShowSepTargetPos)
						{
							UpdateTargetPosAfterRoate();
						}
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}	
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				}  
			}
			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
				if(1)
				{

					{
						//计算对象与图像中心距离
						// 设置图像中心十字基准目标
						SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
						m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

						// 执行对位
						m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFAOT(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//							m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetObject = GetAlignPlatformOffset();

						//计算目标与图像中心距离
						m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFAOT(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//							m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
					}

					cpAlignBenchOffset = cpAlignBenchOffsetObject;
					cpAlignBenchOffset.m_dAngle = cpAlignBenchOffsetTarget.m_dPosY; //四维定制
				}
				ReportAlignResultFAOT(TRUE,TRUE,cpAlignBenchOffset);


			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFAOT(FALSE, TRUE);

				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	


			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;

				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;

				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), i, dTotalAlignTime);
				strOut = strTemp + strOut;


				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			//			ReportAlignResultFAAC(m_bStatusBar);
			return m_bStatusBar;  
		}
		else
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			//			CCoordPos cp = GetAlignPlatformOffset();
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFAOT(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			// 			if (pAlignerParam->m_dMovementRatioX!=1.0 || pAlignerParam->m_dMovementRatioY!= 1.0)
			// 			{
			// 
			// 				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(pAlignerParam->m_dMovementRatioX,pAlignerParam->m_dMovementRatioY);
			// 			}

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;

			if (dWeldMovementRatioX != 1.0 || dWeldMovementRatioY != 1.0)
			{

				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFAOT(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t")); 					
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));               
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

			// 调整相机平台的位置，为下次对位做准备
			/*			std::vector<CPlatformAxisPos*> vpPlatformAxisPos;
			std::vector<CPlatformXYAxisPos*> vpPlatformXYAxisPos;
			vpPlatformAxisPos.clear();
			vpPlatformXYAxisPos.clear();			

			if ((m_pPlatformInfo->m_eCamPlatformType != eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX))
			{
			vpPlatformAxisPos = GetAlignCameraMovementResults();               

			for (int q=0; q<vpPlatformAxisPos.size(); q++)
			{
			vpPlatformXYAxisPos.push_back((CPlatformXYAxisPos*)vpPlatformAxisPos.at(q));
			}

			// 单相机，则保留下次对位中，相机需要调整到的各个位置
			m_vpSingleCamAlignCamPltfmAxisPos.clear();
			if (1 == m_pPlatformInfo->m_nCamNum)
			{
			for (q=0; q<vpPlatformXYAxisPos.size(); q++)
			{
			m_vpSingleCamAlignCamPltfmAxisPos.push_back(vpPlatformXYAxisPos.at(q));
			}

			return TRUE;
			}

			// 多相机，则通信驱动相机平台到位
			if (FALSE == CommuciateDriveCamPlatformAxisMove(vpPlatformXYAxisPos))
			{
			ReportAlignResultFAAC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_CAM_PLATFORM_ARRIVED_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			SaveCurAllCameraChannelSearchImg();
			return FALSE;  
			}

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
			CString strTemp;
			CTime t = CTime::GetCurrentTime();
			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_AND_THEN_RESET_CAM_PLATFORM_POS), i+1);
			strInfo = strTemp + strInfo;

			for (int i=0; i<vpPlatformXYAxisPos.size(); i++)
			{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpPlatformXYAxisPos.at(i)->m_dPosX, vpPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
			}

			FILE *stream;
			CString strPath = m_strAlignProcessData;
			stream = fopen(strPath, _T("a+t"));
			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			fclose(stream);VCRemoveFile(strPath);				
			}	
			} */
		} // else


	}// for	
	// 执行基准对位
	if(1)
	{

		{
			//计算对象与图像中心距离
			// 设置图像中心十字基准目标
			SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
			m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

			// 执行对位
			m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
			if(FALSE == ExecuteAlign())
			{
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				//设置实时对象
				m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
				m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

				ReportAlignResultFAOT(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				//				m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		

				return FALSE;     
			}

			// 获取对位结果
			cpAlignBenchOffsetObject = GetAlignPlatformOffset();

			//计算目标与图像中心距离
			m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);
			if(FALSE == ExecuteAlign())
			{
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


				//设置实时对象
				m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
				m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

				ReportAlignResultFAOT(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				//				m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		

				return FALSE;     
			}

			// 获取对位结果
			cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

			//设置实时对象
			m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		}

		cpAlignBenchOffset = cpAlignBenchOffsetObject;
		cpAlignBenchOffset.m_dAngle = cpAlignBenchOffsetTarget.m_dPosY;
	}
	ReportAlignResultFAOT(TRUE,TRUE,cpAlignBenchOffset);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFALX(int nOffsetIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString str;
	CString strTempWarningType = _T("");
	CString strCmd = _T("");
	GetCommCommandName(strCmd);

	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	stCheckInvalidTimer.Reset();
	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{

		ReportAlignResultFALX(FALSE, TRUE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{
		ReportAlignResultFALX(FALSE, TRUE);

		m_bStatusBar = FALSE;

		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (FALSE == m_bValidAlignerTool)
	{
		ReportAlignResultFALX(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		ReportAlignResultFALX(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFALX(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFALX(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFALX(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	// 检查目标Mark是否已成功定位
	// 	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	// 	{
	// 		if (FALSE == m_bTargetMarkSearchSucceed)
	// 		{
	// 			ReportAlignResultFAAC(FALSE);
	// 
	// 			m_bStatusBar = FALSE;
	// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
	// 			m_strStatusBarInfo2 = _T("");
	// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
	// 
	// 			return FALSE;
	// 		}
	// 	}

	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);
	// 	str.Format("Check Invalid time = %f",dCheckInvalidTime);
	// 	AlignLogRecord(str);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo(); 

	// 获取当前产品最大对位次数
	int nMaxAlignTime = curProductData.m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CCoordPos cpAlignBenchOffsetObject;
	CCoordPos cpAlignBenchOffsetTarget;
	CCoordPos cpAlignBenchOffset;


	// 	if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
	// 	{  
	// 		m_pAlignerTool->m_bUsePreTargetPos = FALSE;           //第一次对位用新的TargetPos
	// 	}
	for (i=0; i<nMaxAlignTime+1; i++)
	{
		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();


		{
			stObjectSearchTimer.Reset();
			m_nAlignTime = i+1;
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				SetDefaultObjectSearchMarkPos(TRUE);

				std::vector<int> vnPosIndex;
				int nTempPosIndex = 0;

				for(nTempPosIndex = GetPosNum()/2; nTempPosIndex < GetPosNum(); nTempPosIndex++)
				{
					vnPosIndex.push_back(nTempPosIndex);
				}

				if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(vnPosIndex,nStartPatIndex))
				{
					ReportAlignResultFALX(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;  
				}
				vnPosIndex.clear();
				for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
				{
					vnPosIndex.push_back(nTempPosIndex);
				}
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex))
				{
					ReportAlignResultFALX(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;     			
				}
			}
			else
			{
				if (FALSE == OnSerialCameraAlignerTargetSearchCandidateExFTGC(nStartPatIndex))
				{
					ReportAlignResultFALX(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;  
				}
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
				{
					ReportAlignResultFALX(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;     			
				}
			}

			dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
			// 
			// 			str.Format("OnSerialCameraAlignerObjectSearchCandidateExFOBC Serial camera object search time = %f",dObjectSearchTime);
			// 			AlignLogRecord(str);
		}

		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFALX(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}
		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 
		// 		str.Format("Align excute time = %f",dCaluteAlignTime);
		// 		AlignLogRecord(str);
		// 		if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
		// 		{  
		// 			m_pAlignerTool->m_bUsePreTargetPos = TRUE;    //执行一次对位成功后，使用上一次的TargetPos结果  
		// 		}

		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			// 			CCoordPos cp = GetAlignPlatformOffset();
			// 			if (pAlignerParam->GetEnableAlnTargetOffset())
			// 			{
			// 				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			// 				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			// 			}
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFALX(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}

			// 			if (pAlignerParam->m_dMovementRatioX!=1.0 || pAlignerParam->m_dMovementRatioY!= 1.0)
			// 			{
			// 				
			// 				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(pAlignerParam->m_dMovementRatioX,pAlignerParam->m_dMovementRatioY);
			// 			}

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;

			if (dWeldMovementRatioX != 1.0 || dWeldMovementRatioY != 1.0)
			{

				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFALX(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;



					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;


					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				// 执行基准对位
				if(1)
				{

					{
						//计算对象与图像中心距离
						// 设置图像中心十字基准目标
						SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
						m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

						// 执行对位
						m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFALX(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//							m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetObject = GetAlignPlatformOffset();

						//计算目标与图像中心距离
						m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFALX(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//						m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
					}

					cpAlignBenchOffset = cpAlignBenchOffsetObject;
					cpAlignBenchOffset.m_dAngle = cpAlignBenchOffsetTarget.m_dPosY;
				}

				ReportAlignResultFALX(TRUE,TRUE,cpAlignBenchOffset);

				return TRUE;
			}
		}

		// 判断是否执行对位动作
		if (i!=0 && TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 			str.Format("Total Align time = %f",dTotalAlignTime);
			// 			AlignLogRecord(str);

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset();
			if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			{
				cpProduct = GetAlignProductOffsetXYPD();
			}
			m_apAlignerProcesInfo.nTimes  = i;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			if (pAlignerParam->GetEnableAlnTargetOffset() && IsAlignSucceed())
			{				
				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);
				CCoordPos cp = GetAlignPlatformOffset();
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
				/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
				|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
				|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
				//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
				//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
				//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
				if(IsAxisMoveOverRun(cp))
				{

					ReportAlignResultFALX(FALSE,TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFALX(FALSE,TRUE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();
					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							//D角度不累加

						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}
						//D角度不累加
						if (m_pSystempOptionConfig->m_bShowSepTargetPos)
						{
							UpdateTargetPosAfterRoate();
						}
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}	
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				}  
			}

			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
				if(1)
				{

					{
						//计算对象与图像中心距离
						// 设置图像中心十字基准目标
						SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
						m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

						// 执行对位
						m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFALX(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//						m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetObject = GetAlignPlatformOffset();

						//计算目标与图像中心距离
						m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);
						if(FALSE == ExecuteAlign(i))
						{
							m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


							//设置实时对象
							m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
							m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
							// 设置实时的目标
							m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
							m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

							ReportAlignResultFALX(FALSE, TRUE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
							//							m_strStatusBarInfo2 = _T("");
							m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
							PostMessageUpdateStatusBarInfo();		

							return FALSE;     
						}

						// 获取对位结果
						cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

						m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

						//设置实时对象
						m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
						m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

						// 设置实时的目标
						m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
						m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
					}

					cpAlignBenchOffset = cpAlignBenchOffsetObject;
					cpAlignBenchOffset.m_dAngle = cpAlignBenchOffsetTarget.m_dPosY; //四维定制
				}
				ReportAlignResultFALX(TRUE,TRUE,cpAlignBenchOffset);


			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFALX(FALSE, TRUE);

				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	


			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;

				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;

				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), i, dTotalAlignTime);
				strOut = strTemp + strOut;


				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			//			ReportAlignResultFAAC(m_bStatusBar);
			return m_bStatusBar;  
		}
		else
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			//			CCoordPos cp = GetAlignPlatformOffset();
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFALX(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			// 			if (pAlignerParam->m_dMovementRatioX!=1.0 || pAlignerParam->m_dMovementRatioY!= 1.0)
			// 			{
			// 				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(pAlignerParam->m_dMovementRatioX,pAlignerParam->m_dMovementRatioY);
			// 			}

			double dWeldMovementRatioX = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosX;
			double dWeldMovementRatioY = pAlignerParam->GetWeldInfo().m_WeldMovementRatio.m_dPosY;

			if (dWeldMovementRatioX != 1.0 || dWeldMovementRatioY != 1.0)
			{
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAdjustAlignPlatformMovementResults(dWeldMovementRatioX, dWeldMovementRatioY);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFALX(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t")); 					
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));               
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

			// 调整相机平台的位置，为下次对位做准备
			/*			std::vector<CPlatformAxisPos*> vpPlatformAxisPos;
			std::vector<CPlatformXYAxisPos*> vpPlatformXYAxisPos;
			vpPlatformAxisPos.clear();
			vpPlatformXYAxisPos.clear();			

			if ((m_pPlatformInfo->m_eCamPlatformType != eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX))
			{
			vpPlatformAxisPos = GetAlignCameraMovementResults();               

			for (int q=0; q<vpPlatformAxisPos.size(); q++)
			{
			vpPlatformXYAxisPos.push_back((CPlatformXYAxisPos*)vpPlatformAxisPos.at(q));
			}

			// 单相机，则保留下次对位中，相机需要调整到的各个位置
			m_vpSingleCamAlignCamPltfmAxisPos.clear();
			if (1 == m_pPlatformInfo->m_nCamNum)
			{
			for (q=0; q<vpPlatformXYAxisPos.size(); q++)
			{
			m_vpSingleCamAlignCamPltfmAxisPos.push_back(vpPlatformXYAxisPos.at(q));
			}

			return TRUE;
			}

			// 多相机，则通信驱动相机平台到位
			if (FALSE == CommuciateDriveCamPlatformAxisMove(vpPlatformXYAxisPos))
			{
			ReportAlignResultFAAC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_CAM_PLATFORM_ARRIVED_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			SaveCurAllCameraChannelSearchImg();
			return FALSE;  
			}

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
			CString strTemp;
			CTime t = CTime::GetCurrentTime();
			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_AND_THEN_RESET_CAM_PLATFORM_POS), i+1);
			strInfo = strTemp + strInfo;

			for (int i=0; i<vpPlatformXYAxisPos.size(); i++)
			{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpPlatformXYAxisPos.at(i)->m_dPosX, vpPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
			}

			FILE *stream;
			CString strPath = m_strAlignProcessData;
			stream = fopen(strPath, _T("a+t"));
			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			fclose(stream);VCRemoveFile(strPath);				
			}	
			} */
		} // else


	}// for	
	// 执行基准对位
	if(1)
	{

		{
			//计算对象与图像中心距离
			// 设置图像中心十字基准目标
			SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
			m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

			// 执行对位
			m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
			if(FALSE == ExecuteAlign())
			{
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				//设置实时对象
				m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
				m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

				ReportAlignResultFALX(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				//				m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		

				return FALSE;     
			}

			// 获取对位结果
			cpAlignBenchOffsetObject = GetAlignPlatformOffset();

			//计算目标与图像中心距离
			m_pAlignerTool->SetObjectPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpTargetMarkImagePos);
			if(FALSE == ExecuteAlign())
			{
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效


				//设置实时对象
				m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
				m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

				ReportAlignResultFALX(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				//			m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		

				return FALSE;     
			}

			// 获取对位结果
			cpAlignBenchOffsetTarget = GetAlignPlatformOffset();

			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

			//设置实时对象
			m_pAlignerTool->SetObjectPlatformPos(m_vpObjectPlatformAxisPos);
			m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
		}

		cpAlignBenchOffset = cpAlignBenchOffsetObject;
		cpAlignBenchOffset.m_dAngle = cpAlignBenchOffsetTarget.m_dPosY;
	}
	ReportAlignResultFALX(TRUE,TRUE,cpAlignBenchOffset);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFACB(int nOffsetIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString str;
	// 	str.Format("Begin to FAAC Align---------------");
	// 	AlignLogRecord(str);
	//	CCoordPos platOffset;
	//	pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)(GetAlignPlatformMovementResults());

	scTimer stCheckInvalidTimer;   double dCheckInvalidTime(0.0);
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	stCheckInvalidTimer.Reset();
	CString strCmd = _T("VACB:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{

		ReportAlignResultFACB(FALSE, TRUE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if (!CheckObjectSearchTool(strCmd)/*FALSE == m_bValidObjectSearchTool*/)
	{
		ReportAlignResultFACB(FALSE, TRUE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (!CheckAlignerSearchTool(strCmd)/*FALSE == m_bValidAlignerTool*/)
	{
		ReportAlignResultFACB(FALSE, TRUE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (!CheckCommuciationValid(strCmd)/*FALSE == m_bValidComm*/)
	{
		ReportAlignResultFACB(FALSE, TRUE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	int i=0;
	for(i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFACB(FALSE, TRUE);

			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();		
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_ALIGN_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFACB(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFACB(FALSE, TRUE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	scTimer stTotalAlignTimer;
	double dTotalAlignTime(0.0);

	stTotalAlignTimer.Reset();

	// 检查目标Mark是否已成功定位
	if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
	{
		if (FALSE == m_bTargetMarkSearchSucceed)
		{
			ReportAlignResultFACB(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}
	}

	dCheckInvalidTime=stCheckInvalidTimer.GetTimeMilli(FALSE);
	// 	str.Format("Check Invalid time = %f",dCheckInvalidTime);
	// 	AlignLogRecord(str);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo(); 

	// 获取当前产品最大对位次数
	int nMaxAlignTime = curProductData.m_pAlignerParam->m_nAlignerMaxTime;

	scTimer stObjectSearchTimer; double dObjectSearchTime(0.0);
	scTimer stCaluteAlignTimer;  double dCaluteAlignTime(0.0);
	scTimer stAlignTimer;   double dAlignTime(0.0);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	CCoordPos cpAlignBenchOffset;

	for (i=0; i<nMaxAlignTime+1; i++)
	{
		stAlignTimer.Reset();
		//		m_vpSingleCamAlignCamPltfmAxisPos.clear();

		// 实时对象Mark定位		
		// 		if (i == 0)
		// 		{
		// 			// 检查目标Mark是否已成功定位
		// 			if (FALSE == m_bObjectMarkSearchSucceed)
		// 			{
		// 				ReportAlignResultFAAC(FALSE);
		// 				
		// 				m_bStatusBar = FALSE;
		// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
		// 				m_strStatusBarInfo2 = _T("");
		// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	
		// 				
		// 				return FALSE;
		// 			}
		// 		}
		// 		else if (i > 0)
		{
			stObjectSearchTimer.Reset();
			m_nAlignTime = i+1;
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				SetDefaultObjectSearchMarkPos(TRUE);

				std::vector<int> vnPosIndex;
				int nTempPosIndex = 0;
				for(nTempPosIndex = 0; nTempPosIndex < GetPosNum()/2; nTempPosIndex++)
				{
					vnPosIndex.push_back(nTempPosIndex);
				}
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(vnPosIndex, nStartPatIndex))
				{
					ReportAlignResultFACB(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					return FALSE;     			
				}
			}
			else
			{
				if (FALSE == OnSerialCameraAlignerObjectSearchCandidateExFOBC(nStartPatIndex))
				{
					ReportAlignResultFACB(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
					if (!m_boIsSnapImgSucceed)
					{
						m_strStatusBarInfo2 = m_strStatusBarInfo2 + _T(",") + m_strSnapImgStatuString;
					}
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;     			
				}
			}

			dObjectSearchTime = stObjectSearchTimer.GetTimeMilli(FALSE);
			// 
			// 			str.Format("OnSerialCameraAlignerObjectSearchCandidateExFOBC Serial camera object search time = %f",dObjectSearchTime);
			// 			AlignLogRecord(str);
		}

		// 执行基准对位
		if(1)
		{
			if (i == 0)
			{
				// 设置图像中心十字基准目标
				SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
				m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

				// 执行对位
				m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
				if(FALSE == ExecuteAlign(i))
				{
					m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

					// 设置实时的目标
					m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
					m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

					ReportAlignResultFACB(FALSE, TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
					//				m_strStatusBarInfo2 = _T("");
					m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();	

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
					return FALSE;     
				}

				// 获取对位结果
				cpAlignBenchOffset = GetAlignPlatformOffset();

				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			}
		}

		// 执行对位计算
		stCaluteAlignTimer.Reset();
		if(FALSE == ExecuteAlign(i))
		{
			ReportAlignResultFACB(FALSE, TRUE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();	

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1 + m_strStatusBarInfo2));
			//			SaveCurAllCameraChannelSearchImg();

			return FALSE;     
		}
		dCaluteAlignTime = stCaluteAlignTimer.GetTimeMilli(FALSE); 
		// 		str.Format("Align excute time = %f",dCaluteAlignTime);
		// 		AlignLogRecord(str);


		// 执行一次对位
		if (TRUE == optionInfo.m_bAlignOneTime)
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			}
			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			// 			CCoordPos cp = GetAlignPlatformOffset();
			// 			if (pAlignerParam->GetEnableAlnTargetOffset())
			// 			{
			// 				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			// 				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
			// 			}
			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFACB(FALSE, TRUE);

				m_bStatusBar = FALSE;
				//m_strStatusBarInfo1.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_PLATFORM_MOVE_OVERFLOW);
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFACB(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t")); 					
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));               
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);		

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}

				ReportAlignResultFACB(TRUE, TRUE, cpAlignBenchOffset);

				return TRUE;
			}
		}

		// 判断是否执行对位动作
		if (i!=0 && TRUE == IsAlignFinished(i+1))
		{
			dTotalAlignTime = stTotalAlignTimer.GetTimeMilli(FALSE);

			// 			str.Format("Total Align time = %f",dTotalAlignTime);
			// 			AlignLogRecord(str);

			// 更新主界面对位精度、次数、对位总时间
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的
			if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
			{
				cpProduct = GetAlignProductOffsetXYPD();
			}
			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			if (pAlignerParam->GetEnableAlnTargetOffset() && IsAlignSucceed())
			{				
				CPlatformOptionInfo optionInfo;
				GetPlatformOptionInfo(optionInfo);
				CCoordPos cp = GetAlignPlatformOffset();
				cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
				/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
				|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
				|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
				//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
				//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
				//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
				if(IsAxisMoveOverRun(cp))
				{

					ReportAlignResultFACB(FALSE,TRUE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
					m_strStatusBarInfo2.Format(_T(""));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					return FALSE;
				}


				// 执行本次对位操作
				// 获取平台对位应移动到的绝对位置
				CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
				pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();			

				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);

				scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
				stCommunicateTimer.Reset();
				// 通信驱动平台运动到指定位置
				if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
				{
					ReportAlignResultFACB(FALSE,TRUE);
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);


					m_bStatusBar = FALSE;
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();		
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
					//					SaveCurAllCameraChannelSearchImg();
					return FALSE;     
				}
				else
				{
					if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
					{
						m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
						m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
						if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
							//D角度不累加

						}
						else
						{
							m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

						}
						//D角度不累加
						if (m_pSystempOptionConfig->m_bShowSepTargetPos)
						{
							UpdateTargetPosAfterRoate();
						}
					}
					else
					{
						m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
					}	
					dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);

				}  
			}
			m_bStatusBar = IsAlignSucceed();
			if (m_bStatusBar)
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);
				ReportAlignResultFACB(m_bStatusBar, TRUE, cpAlignBenchOffset);

			}

			if (!m_bStatusBar) 
			{
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				ReportAlignResultFACB(FALSE, TRUE);

				//				SaveCurAllCameraChannelSearchImg();
			}

			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), i, dTotalAlignTime);
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	


			// 记录对位精度
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;					
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
				strOut = strTemp + strOut;

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));               
				// 				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			// 记录对位时间
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
			{
				CString strTemp;
				// 				CTime t = CTime::GetCurrentTime();
				// 				strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

				CString strOut;						
				strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), i, dTotalAlignTime);
				strOut = strTemp + strOut;

				// 				FILE *stream;
				// 				CString strPath = m_strAlignProcessData;
				// 				stream = fopen(strPath, _T("a+t"));               
				// 				fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
				// 				fclose(stream);VCRemoveFile(strPath);	

				VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
				VisionAlignLogRecord(m_strAlignProcessData, strOut);
			}

			//			ReportAlignResultFAAC(m_bStatusBar, TRUE, cpAlignBenchOffset);
			return m_bStatusBar;  
		}
		else
		{
			CCoordPos cpProduct = GetAlignProductOffset();
			m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
			m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
			m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

			CCoordPos cp = GetAlignPlatformOffset(); // 目标Mark和对象Mark二者之间的

			m_apAlignerProcesInfo.nTimes  = i+1;
			m_apAlignerProcesInfo.dTime   = stAlignTimer.GetTimeMilli(FALSE);
			m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
			m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
			m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;

			PostMessageUpdateAlignerProcessInfo();

			CPlatformOptionInfo optionInfo;
			GetPlatformOptionInfo(optionInfo);
			//			CCoordPos cp = GetAlignPlatformOffset();
			/*if (fabs(cp.GetPosX()) > m_pSystempOptionConfig->m_dAxisMoveMaxX
			|| fabs(cp.GetPosY()) > m_pSystempOptionConfig->m_dAxisMoveMaxY
			|| fabs(cp.GetAngle()) > m_pSystempOptionConfig->m_dAxisMoveMaxD)*/
			//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
			//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
			//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
			if(IsAxisMoveOverRun(cp))
			{
				ReportAlignResultFACB(FALSE, TRUE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				return FALSE;
			}


			// 执行本次对位操作
			// 获取平台对位应移动到的绝对位置
			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			scTimer stCommunicateTimer;   double dCommunicateTime(0.0);
			stCommunicateTimer.Reset();
			// 通信驱动平台运动到指定位置
			if (FALSE == CommuciateDrivePlatformAxisMove(pPlatformXYDAxisPos))
			{
				ReportAlignResultFACB(FALSE, TRUE);
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_PLATFORM_ARRIVED_FAILED);
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_FAILED);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			else
			{
				if (ePlatformXYPD == sysPlatformInfo.m_eMidPlatformType)
				{
					m_CurPlatformAxisPos.m_dPosX = pPlatformXYDAxisPos->m_dPosX;
					m_CurPlatformAxisPos.m_dPosY = pPlatformXYDAxisPos->m_dPosY;
					if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()/2-1))->m_dAngle;
						//D角度不累加

					}
					else
					{
						m_CurPlatformAxisPos.m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(m_vpObjectPlatformAxisPos.size()-1))->m_dAngle;

					}
					//D角度不累加
					if (m_pSystempOptionConfig->m_bShowSepTargetPos)
					{
						UpdateTargetPosAfterRoate();
					}
				}
				else
				{
					m_CurPlatformAxisPos = *pPlatformXYDAxisPos;
				}
				dCommunicateTime =stCommunicateTimer.GetTimeMilli(FALSE);
				// 				str.Format("Commuciate and Drive to PlatformAxis time =%f",dCommunicateTime);
				// 				AlignLogRecord(str);

				m_bStatusBar = TRUE;
				m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CERTAIN_ALIGN_SUCCEED), m_apAlignerProcesInfo.nTimes);
				m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIME), m_apAlignerProcesInfo.dTime);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				dAlignTime = m_apAlignerProcesInfo.dTime;

				// 				str.Format("The%d Times align time =%f",i+1,dAlignTime);
				// 				AlignLogRecord(str);
				// 记录对位精度
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_OFFSET), 
						i+1, m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t")); 					
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录对位时间
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strOut;
					strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CERTAIN_ALIGN_TIME_OBJECT_SEARCH_TIME_ALIGN_TIME), i+1, dAlignTime, dObjectSearchTime, dCaluteAlignTime);
					strOut = strTemp + strOut;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));               
					// 					fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strOut);
				}

				// 记录当前平台各个轴的绝对位置
				if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
				{
					CString strTemp;
					// 					CTime t = CTime::GetCurrentTime();
					// 					strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

					CString strInfo;
					strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_EXCUTE_ALIGN_ACTION_THEN_PLATFORM_POS),
						i+1, pPlatformXYDAxisPos->m_dPosX, pPlatformXYDAxisPos->m_dPosY, pPlatformXYDAxisPos->m_dAngle);
					strInfo = strTemp + strInfo;

					// 					FILE *stream;
					// 					CString strPath = m_strAlignProcessData;
					// 					stream = fopen(strPath, _T("a+t"));
					// 					fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
					// 					fclose(stream);VCRemoveFile(strPath);	

					VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
					VisionAlignLogRecord(m_strAlignProcessData, strInfo);
				}
			}   

			// 调整相机平台的位置，为下次对位做准备
			/*			std::vector<CPlatformAxisPos*> vpPlatformAxisPos;
			std::vector<CPlatformXYAxisPos*> vpPlatformXYAxisPos;
			vpPlatformAxisPos.clear();
			vpPlatformXYAxisPos.clear();			

			if ((m_pPlatformInfo->m_eCamPlatformType != eCamPlatformSepFix) && (m_pPlatformInfo->m_eCamPlatformType!=eCamPlatformShareX))
			{
			vpPlatformAxisPos = GetAlignCameraMovementResults();               

			for (int q=0; q<vpPlatformAxisPos.size(); q++)
			{
			vpPlatformXYAxisPos.push_back((CPlatformXYAxisPos*)vpPlatformAxisPos.at(q));
			}

			// 单相机，则保留下次对位中，相机需要调整到的各个位置
			m_vpSingleCamAlignCamPltfmAxisPos.clear();
			if (1 == m_pPlatformInfo->m_nCamNum)
			{
			for (q=0; q<vpPlatformXYAxisPos.size(); q++)
			{
			m_vpSingleCamAlignCamPltfmAxisPos.push_back(vpPlatformXYAxisPos.at(q));
			}

			return TRUE;
			}

			// 多相机，则通信驱动相机平台到位
			if (FALSE == CommuciateDriveCamPlatformAxisMove(vpPlatformXYAxisPos))
			{
			ReportAlignResultFAAC(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_DRIVE_CAM_PLATFORM_ARRIVED_FAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			SaveCurAllCameraChannelSearchImg();
			return FALSE;  
			}

			// 记录当前相机平台各个轴的绝对位置
			if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
			{
			CString strTemp;
			CTime t = CTime::GetCurrentTime();
			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_AND_THEN_RESET_CAM_PLATFORM_POS), i+1);
			strInfo = strTemp + strInfo;

			for (int i=0; i<vpPlatformXYAxisPos.size(); i++)
			{
			strTemp = _T("");
			strTemp.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_CAM_PLATFORM_POS), i, vpPlatformXYAxisPos.at(i)->m_dPosX, vpPlatformXYAxisPos.at(i)->m_dPosY);
			strInfo = strInfo + strTemp;
			}

			FILE *stream;
			CString strPath = m_strAlignProcessData;
			stream = fopen(strPath, _T("a+t"));
			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			fclose(stream);VCRemoveFile(strPath);				
			}	
			} */
		} // else


	}// for	
	ReportAlignResultFACB(TRUE, TRUE, cpAlignBenchOffset);
	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineSetProductName( CString strCmdCurProductName )
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{
		SendCommInfo(CMD_TP_UNKNOWN_ERR);
		return FALSE;
	}

	// 解析指令名称	
	CString strCurProductName;
	if (eAswSucceed != m_XYDCommProtocol.AnalyzeAswSetProductName(strCmdCurProductName, strCurProductName))
	{
		SendCommInfo(CMD_TP_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);//_T("切换产品失败");
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_COMMAND_ERR);//_T("指令名称解析错误");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 设置当前产品
	if (!SetCurProductName(strCurProductName))
	{
		SendCommInfo(CMD_TP_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);//_T("切换产品失败");
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_PRODUCT_NAME_FAILE);//_T("设置产品失败");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}


	SendCommInfo(CMD_TP_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_SUCCESS);//_T("切换产品成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;


}

BOOL vcXYDVisionAlign::OnlineSetProductIndex( CString strCmdCurProductName )
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{
		SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	// 解析指令名称	
	int nCurProductIndex = -1;
	if (eAswSucceed != m_XYDCommProtocol.AnalyzeAswSetProductIndex(strCmdCurProductName, nCurProductIndex))
	{
		SendCommInfo(CMD_TN_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);//_T("切换产品失败");
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_COMMAND_ERR);//_T("指令名称解析错误");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 设置当前产品
	if (!SetCurProductIndex(nCurProductIndex) || !SetProductCameraShutter(nCurProductIndex))
	{
		SendCommInfo(CMD_TN_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);//_T("切换产品失败");
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_PRODUCT_NAME_FAILE);//_T("设置产品失败");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}


	SendCommInfo(CMD_TN_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_SUCCESS);//_T("切换产品成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;

}

// 根据索引指令设置当前产品  （产品切换）
BOOL vcXYDVisionAlign::OnlineSetProductIndex(int nCurProductIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CString strCmd = _T("VSPC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportSetProductIndexFSPC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	if (IsSysMemoryUsedRateWarning())
	{
		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);

		if (sysPlatformInfo.m_bLoadSingleProductSearchToolEnable == TRUE)
		{

		}
		else if (sysPlatformInfo.m_bProductFaChd && sysPlatformInfo.m_bLoadSingleProductSearchToolEnableFaChd)
		{


		}
		else
		{
			if (!ProductSearchToolLoadState(nCurProductIndex))
			{
				ReportSetProductIndexFSPC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);//_T("切换产品失败");
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_MEM_OUT_WARNING);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
				return FALSE;
			}

		}

	}

	int nCalibDataIndex = m_pVisionASMConfig->m_TotalCalibData.GetCurCalibIndex();
	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if(nCalibDataIndex != nCurProductIndex && nProductIndex != nCurProductIndex)
	{
		if (!SetCurCalibDataAndProductIndex(nCurProductIndex) || !SetProductCameraShutter(nCurProductIndex))
		{
			ReportSetProductIndexFSPC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);//_T("切换产品失败");
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_PRODUCT_NAME_FAILE);//_T("设置产品失败");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			return FALSE;
		}

		PostMessageUpdateCurProductAlignInfo();
	}


	//if (nCalibDataIndex != nCurProductIndex)
	//{
	//	// 设置当前标定产品
	//	if (!SetCurCalibDataIndex(nCurProductIndex))
	//	{
	//		ReportSetProductIndexFSPC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);

	//		m_bStatusBar = FALSE;
	//		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);//_T("切换产品失败");
	//		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_PRODUCT_CALIB_INFO_FAIL);//_T("设置产品标定信息失败");//_T("设置产品失败")
	//		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	//		PostMessageUpdateStatusBarInfo();
	//		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	//		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	//		return FALSE;
	//	}
	//}


	//int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	//if (nProductIndex != nCurProductIndex)
	//{
	//	// 设置当前产品
	//	// 修复：曝光增益随产品切换，而用指令切换产品时，相机曝光增益没有改变的bug
	//	if (!SetCurProductIndex(nCurProductIndex) || !SetProductCameraShutter(nCurProductIndex))
	//	{
	//		ReportSetProductIndexFSPC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);

	//		m_bStatusBar = FALSE;
	//		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_FAILE);//_T("切换产品失败");
	//		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_PRODUCT_NAME_FAILE);//_T("设置产品失败");
	//		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	//		PostMessageUpdateStatusBarInfo();
	//		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
	//		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
	//		return FALSE;
	//	}

	//	


	//	PostMessageUpdateCurProductAlignInfo();
	//}


	ReportSetProductIndexFSPC(TRUE);//SendCommInfo(CMD_TN_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CHANGE_PRODUCT_NAME_SUCCESS);//_T("切换产品成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}
// 根据指令保存当前产品
BOOL vcXYDVisionAlign::OnlineSaveProductIndex(int nProductIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VSSV:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportSaveProductIndexFSSV(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	int nCurProductIndex = nProductIndex;
	if (nProductIndex == -1)
	{
		nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	}

	// 设置当前产品(将产品No.保存到配置文件中)
	if (!SaveProductDataInfo(nCurProductIndex))
	{
		ReportSaveProductIndexFSSV(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SAVE_PRODUCT_FAILE);//_T("保存产品失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	ReportSaveProductIndexFSSV(TRUE);//SendCommInfo(CMD_TN_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SAVE_PRODUCT_SUCCESS);//_T("保存产品成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

// 根据指令获取当前产品	
BOOL vcXYDVisionAlign::OnlineGetProductIndex()
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VGSP:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportGetProductIndexFGSP(FALSE, 0);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	int nFaProductIndex, nChdProductIndex;
	m_pVisionASMConfig->m_TotalProductData.GetDlgProductIndex(nCurProductIndex, nFaProductIndex, nChdProductIndex);

	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);
	if(sysPlatformInfo.m_bProductFaChd)
	{
		ReportGetProductIndexFGSP(TRUE, nFaProductIndex+1, nChdProductIndex+1);//SendCommInfo(CMD_TN_SUCCEED);
	}
	else
	{
		ReportGetProductIndexFGSP(TRUE, nCurProductIndex+1);//SendCommInfo(CMD_TN_SUCCEED);
	}

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_PRODUCT_NUMBER_SUCCESS);//_T("获取产品号成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;

}


BOOL vcXYDVisionAlign::OnlineGetAlignPrecisionFGAL( int nPrecisiontType )
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CCoordPos cpAlignPrecision;
	CString strCmd = _T("VGAL:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportGetAlignPrecisionFGAL(FALSE, cpAlignPrecision);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_PRECISION_FAILE);//_T("获取对准精度失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportGetAlignPrecisionFGAL(FALSE, cpAlignPrecision);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	cpAlignPrecision = pCurProductData->m_pAlignerParam->GetAlignerPrecision();

	ReportGetAlignPrecisionFGAL(TRUE, cpAlignPrecision);//SendCommInfo(CMD_TN_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_PRECISION_SUCCESS);//_T("获取对准精度成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineSetAlignPrecisionFALL(int nPrecisiontType)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CString strCmd = _T("VALL:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportSetAlignPrecisionFALL(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	CPlatformXYDAxisPos platformXYDAxisPos;
	if (m_bCmdParamAxisPosEanble == TRUE)		// 不读取轴位置
	{
		m_bCmdParamAxisPosEanble = CommParamGetPlatformAxisAbsPosBackup(&platformXYDAxisPos);
	}
	else
	{
		m_bCmdParamAxisPosEanble = CommuciateGetPlatformAxisAbsPosBackup(&platformXYDAxisPos);
	}

	if (!m_bCmdParamAxisPosEanble)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportSetAlignOffsetFOFS(FALSE);
		return FALSE;
	}

	CCoordPos cpAlignPrecision;
	cpAlignPrecision.m_dPosX = platformXYDAxisPos.m_dPosX;
	cpAlignPrecision.m_dPosY = platformXYDAxisPos.m_dPosY;
	cpAlignPrecision.m_dAngle = platformXYDAxisPos.m_dAngle;

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_PRECISION_FAILE);//_T("设置对准精度失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportSetAlignPrecisionFALL(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}
	pCurProductData->m_pAlignerParam->SetAlignerPrecision(cpAlignPrecision);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetAlignerPrecision(cpAlignPrecision);

	ReportSetAlignPrecisionFALL(TRUE);//SendCommInfo(CMD_TN_SUCCEED);

	PostMessageUpdateAlignPrecisionInfo();

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_PRECISION_SUCCESS);//_T("设置对准精度成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineGetAlignTimeFGAC()
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	int nAlignTime = 0;

	CString strCmd = _T("VGAC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportGetAlignTimeFGAC(FALSE,nAlignTime);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_ALN_TIME_FAILE);//_T("获取对准最多次数失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportGetAlignTimeFGAC(FALSE,nAlignTime);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}
	nAlignTime = pCurProductData->m_pAlignerParam->GetAlignerMaxTime();

	ReportGetAlignTimeFGAC(TRUE, nAlignTime);//SendCommInfo(CMD_TN_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_ALN_TIME_SUCCESS);//_T("获取对准最多次数成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineSetAlignTimeFALC( int nAlignTime )
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VALC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportSetAlignTimeFALC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_TIME_FAILE);//_T("设置对准最多次数失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportSetAlignTimeFALC(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}
	pCurProductData->m_pAlignerParam->SetAlignerMaxTime(nAlignTime);

	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetAlignerMaxTime(nAlignTime);

	ReportSetAlignTimeFALC(TRUE);//SendCommInfo(CMD_TN_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_TIME_SUCCESS);// _T("设置对准最多次数成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineGetAlignOffsetFGOF( int nOffsetIndex )
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CCoordPos cpAlignOffset;
	CString strCmd = _T("VGOF:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportGetAlignOffsetFGOF(FALSE, cpAlignOffset);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_ALN_OFFSET_FAILE);//_T("获取对位补偿失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportGetAlignOffsetFGOF(FALSE, cpAlignOffset);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	// -1 为获得基础补偿
	if (-1 == nOffsetIndex)
	{
		cpAlignOffset = pCurProductData->m_pAlignerParam->GetAlignerBaseOffset();
	}
	else
	{
		cpAlignOffset = pCurProductData->m_pAlignerParam->GetAlignerOffset(nOffsetIndex);
	}

	ReportGetAlignOffsetFGOF(TRUE, cpAlignOffset);//SendCommInfo(CMD_TN_SUCCEED);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_ALN_OFFSET_SUCCESS);// _T("获取对位补偿成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();

	//return FALSE;	[4/22/2020 为什么会一直return FALSE，不知道，感觉逻辑不对，改成了return TRUE]
	return TRUE;
}

// BOOL vcXYDVisionAlign::OnlineSetAlignOffsetFOFS(int nOffsetIndex, CCoordPos cpAlignOffset,BOOL bReGetOffsetIndex)
// {
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = _T("");
// 	m_strStatusBarInfo2 = _T("");
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
// 	{
// 		ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
// 		return FALSE;
// 	}
// 
// 	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
// 	if (pCurProductData == NULL)
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// 		m_strStatusBarInfo2 = _T("");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
// 		return FALSE;
// 	}
// 
// 	if (bReGetOffsetIndex)
// 	{
// 		nOffsetIndex = pCurProductData->m_pAlignerParam->GetCurAlignerOffsetIndex();
// 	}
// 
// 	if (!pCurProductData->m_pAlignerParam->SetAlignerOffset(nOffsetIndex,cpAlignOffset))
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// 		m_strStatusBarInfo2 = _T("");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
// 		return FALSE;
// 	}
// 	
// 
// 	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
// 
// 	if (!pAlignerParam->SetAlignerOffset(nOffsetIndex,cpAlignOffset))
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// 		m_strStatusBarInfo2 = _T("");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
// 		return FALSE;
// 	}
// 
// 	if (!SaveProductDataInfo(nCurProductIndex))
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
// 		m_strStatusBarInfo2 = _T("");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
// 		return FALSE;
// 	}
// 	
// 
// 	ReportSetAlignOffsetFOFS(TRUE);//SendCommInfo(CMD_TN_SUCCEED);
// 
// 	PostMessageUpdateAlignOffsetInfo();
// 
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_SUCCESS);// _T("设置对位补偿成功");
// 	m_strStatusBarInfo2 = _T("");
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 	return TRUE;
// }

BOOL vcXYDVisionAlign::OnlineSetAlignOffsetFOFS(int nOffsetIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOFS:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	CPlatformXYDAxisPos platformXYDAxisPos;
	if (m_bCmdParamAxisPosEanble == TRUE)		// 不读取轴位置
	{
		m_bCmdParamAxisPosEanble = CommParamGetPlatformAxisAbsPosBackup(&platformXYDAxisPos);
	}
	else
	{
		m_bCmdParamAxisPosEanble = CommuciateGetPlatformAxisAbsPosBackup(&platformXYDAxisPos);
	}

	if (!m_bCmdParamAxisPosEanble)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportSetAlignOffsetFOFS(FALSE);
		return FALSE;
	}

	CCoordPos cpAlignOffset;
	cpAlignOffset.m_dPosX = platformXYDAxisPos.m_dPosX;
	cpAlignOffset.m_dPosY = platformXYDAxisPos.m_dPosY;
	cpAlignOffset.m_dAngle = platformXYDAxisPos.m_dAngle;

	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}

	// 设置基础补偿值
	if (-1 == nOffsetIndex)
	{
		pCurProductData->m_pAlignerParam->SetAlignerBaseOffset(cpAlignOffset);
		CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
		pAlignerParam->SetAlignerBaseOffset(cpAlignOffset);
	}
	else
	{
		if (!pCurProductData->m_pAlignerParam->SetAlignerOffset(nOffsetIndex,cpAlignOffset))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
			return FALSE;
		}


		CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();

		if (!pAlignerParam->SetAlignerOffset(nOffsetIndex,cpAlignOffset))
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
			return FALSE;
		}
	}

	if (!SaveProductDataInfo(nCurProductIndex))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_FAILE);// _T("设置对位补偿失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportSetAlignOffsetFOFS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);
		return FALSE;
	}


	ReportSetAlignOffsetFOFS(TRUE);//SendCommInfo(CMD_TN_SUCCEED);

	PostMessageUpdateAlignOffsetInfo();

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SET_ALN_OFFSET_SUCCESS);// _T("设置对位补偿成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineGetPlatformOffsetFGPO()
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	/*CCoordPos cpAlignOffset = GetAlignPlatformOffset();*/
	CCoordPos cpAlignOffset = GetAlignProductOffset();

	ReportGetPlatformOffsetFGPO(TRUE, cpAlignOffset);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_GET_PRECISION_SUCCESS);//_T("获取对准精度成功");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

BOOL vcXYDVisionAlign::SendResetResult()
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VRST:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!ReportResetResult(TRUE))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SEND_RESET_FAILE);// _T("复位报警失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;

	}

	// 	// 打包“写寄存器”指令
	// 	CString strInfo;
	// 	if (!m_XYDCommProtocol.PackReResetFRST(strInfo,TRUE))
	// 	{
	// 		return FALSE;
	// 	}	
	// 	//Sleep(50);
	// 	// 发送“写寄存器”指令
	// 	if (FALSE == SendCommInfo(strInfo))	
	// 	{
	// 		return FALSE;
	// 	}

	return TRUE;
};
BOOL vcXYDVisionAlign::SendCommResultFCHK()
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCHK:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!ReportCommResultFCHK(TRUE))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_COMM_HAND_TO_HAND_FAILE);// _T("PLC握手通讯失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_COMMUNICATION);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;

	}



	return TRUE;
}

BOOL vcXYDVisionAlign::SendCommConnectStatus()//限寄存器通信使用
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackPlcWriteSetVisionStatus(strSend, eVsConneted))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

	}
	return TRUE;
}


//lzk  复制标定信息
BOOL vcXYDVisionAlign::OnlineCopyCalibrateInfo(int nCopiedCalibrateIndex,int nCopyToCalibrateIndex)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{
		ReportCopyCalibrateInfoFCCI(FALSE);
		return FALSE;
	}
	//拷贝标定信息
	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();
	std::vector<int> vnPos;
	vnPos.push_back(nCopyToCalibrateIndex);
	BOOL bResult = SetSameCalibrateInfo(nCopiedCalibrateIndex,vnPos);
	CString strInfo;
	strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_COPY_CALIBRATE_POS_TO_POS),nCopiedCalibrateIndex+1,nCopyToCalibrateIndex+1);

	if (FALSE == bResult)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_COPY_CALIBRATE_INFO_FAILE);
		m_strStatusBarInfo2 = strInfo;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		ReportCopyCalibrateInfoFCCI(FALSE);
		return FALSE;
	}
	// 获取全部的标定信息
	vpAllCalibratedInfo = GetAllCalibratedInfo();
	// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
	SetCurCalibratedInfo(vpAllCalibratedInfo);	
	// 保存标定后信息到当前产品中及配置文件中
	SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);
	//标定信息复制成功
	ReportCopyCalibrateInfoFCCI(TRUE);
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_COPY_CALIBRATE_INFO_SUCCESS);
	m_strStatusBarInfo2 = strInfo;
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	return	TRUE;
}
//lzk FCCI：复制标定信息
BOOL vcXYDVisionAlign::ReportCopyCalibrateInfoFCCI( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{		
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReCopyCalibrateInfoFCCI(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCopyCalibrateInfoFCCI(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCopyCalibrateInfoFCCI(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

//lzk 0407  易天覆膜机-位置虚拟-指令交互
BOOL vcXYDVisionAlign::ReportSetPositionVirtualFVPC(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{		
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReSetPositionVirtualFVPC(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcSetPositionVirtualFVPC(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReSetPositionVirtualFVPC(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportSetProductIndexFSPC( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{		
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReSetProductIndexFSPC(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcSetProductIndexFSPC(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReSetProductIndexFSPC(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportSaveProductIndexFSSV( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReSaveProductIndexFSSV(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;		

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcSaveProductIndexFSSV(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReSaveProductIndexFSSV(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportGetProductIndexFGSP( BOOL bResult, int nCurProductIndex, int nAssitIndex /*= 1*/ )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetProductIndexFGSP(strSimpleInfo, bResult, nCurProductIndex, nAssitIndex);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;		

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetProductIndexFGSP(strSend, bResult, nCurProductIndex, nAssitIndex))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetProductIndexFGSP(strInfo, bResult, nCurProductIndex, nAssitIndex))
		{
			return FALSE;
		}

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportGetAlignPrecisionFGAL( BOOL bResult, CCoordPos cpAlignPrecision )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetAlignPrecisionFGAL(strSimpleInfo, bResult, cpAlignPrecision);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;		

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetAlignPrecisionFGALAxisPos(strSend, bResult, cpAlignPrecision))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetAlignPrecisionFGAL(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetAlignPrecisionFGAL(strInfo, bResult, cpAlignPrecision))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}

	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportSetAlignPrecisionFALL( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReSetAlignPrecisionFALL(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;		

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcSetAlignPrecisionFALL(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{

		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReSetAlignPrecisionFALL(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportGetAlignTimeFGAC( BOOL bResult, int nAlignTime )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetAlignTimeFGAC(strSimpleInfo, bResult, nAlignTime);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;		

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetAlignTimeFGAC(strSend, bResult, nAlignTime))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetAlignTimeFGAC(strInfo, bResult, nAlignTime))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportSetAlignTimeFALC( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReSetAlignTimeFALC(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;		

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackReSetAlignTimeFALC(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReSetAlignTimeFALC(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportGetAlignOffsetFGOF( BOOL bResult, CCoordPos cpAlignOffset )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetAlignOffsetFGOF(strSimpleInfo, bResult, cpAlignOffset);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 打包结果并写到寄存器中
		if (FALSE == m_XYDCommProtocol.PackRePlcGetAlignOffsetFGOFAxisPos(strSend, bResult, cpAlignOffset))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetAlignOffsetFGOF(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetAlignOffsetFGOF(strInfo, bResult, cpAlignOffset))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportSetAlignOffsetFOFS( BOOL bResult )
{

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReSetAlignOffsetFOFS(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;		

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcSetAlignOffsetFOFS(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReSetAlignOffsetFOFS(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::ReportGetPlatformOffsetFGPO(BOOL bResult, CCoordPos cpAlignOffset)
{
	CString strSimpleInfo;
	m_XYDCommProtocol.PackReGetAlignOffsetFGPO(strSimpleInfo, bResult, cpAlignOffset);
	AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
	// 如果是PLC直接读取存储寄存器协议
	if (m_XYDCommProtocol.IsPlcProtocolType())
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;	
		if (!m_XYDCommProtocol.PackRePlcGetPlatformOffsetFGPOAxisPos(strSend, bResult, cpAlignOffset))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 写FFGPOParam令
		if (!m_XYDCommProtocol.PackRePlcGetPlatformOffsetFGPO(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetAlignOffsetFGPO(strInfo, bResult, cpAlignOffset))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}
	return TRUE;
}

// 手动搜索线程
UINT vcXYDVisionAlign::ManualSearchThread(LPVOID pParam)
{
	vcXYDVisionAlign* pOwner = (vcXYDVisionAlign*)pParam;
	if (pOwner != NULL)
	{
		pOwner->ManualSearchThreadFunc();
	}
	return 0;
}

// 手动搜索线程函数
UINT vcXYDVisionAlign::ManualSearchThreadFunc()
{
	while (!m_bExitManualSearchThread)
	{
		if (m_nManualSearchMarkMode == eTargetSearch)			// 目标搜索
		{
			// 手动目标搜索
			ManualTargetSearchEx(m_nManualTargetSearchIndex);

			m_nManualSearchMarkMode = eNoSearch;

		}		
		else if (m_nManualSearchMarkMode == eObjectSearch)		// 对象搜索
		{
			// 手动对象搜索
			ManualObjectSearchEx(m_nManualObjectSearchIndex);

			m_nManualSearchMarkMode = eNoSearch;

		}
		Sleep(1000);
	}

	return 0;
}

// 手动目标搜索
BOOL vcXYDVisionAlign::ManualTargetSearchEx(int nPosIndex)
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	SetDefaultTargetSearchMarkPos(TRUE);

	std::vector<int> vnPosIndex;
	if (nPosIndex>=0 && nPosIndex <= 3)	//编号0～3的相机中的一个
	{
		vnPosIndex.push_back(nPosIndex);
	}
	else if(nPosIndex==4)	// 所有相机
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum(); i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else if (nPosIndex>=9 && nPosIndex<=10 ) //编号2～3的相机中的一个
	{
		vnPosIndex.push_back(nPosIndex - 7);
	}
	else if (nPosIndex==11) // 所有相机中的后一半编号
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else if (nPosIndex==12) // 所有相机中的前一半编号
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_FAIL);//_T("实时目标Mark手动定位失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	if (vnPosIndex.size() == 1)
	{
		CDlgManualSearchPos1 dlgManualSearch;
		dlgManualSearch.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex;
		dlgManualSearch.m_nMarkType = 1;
		dlgManualSearch.SetSysInfoStringsRef(m_psaSysInfoStrings);
		dlgManualSearch.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		dlgManualSearch.SetVisionAlignerRef(this, vnPosIndex);

		// 定义全部位置向量，包含0/1对象和2/3目标
		std::vector<int> vnAllPosIndex;
		int nAllPosIndex = 0;


		if (dlgManualSearch.DoModal() == IDOK)
		{
			for (int i=0; i<vnPosIndex.size(); i++)
			{
				CCoordPos pos = dlgManualSearch.m_vCoordPos.at(i);
				m_mpTargetMarkImagePos.SetMarkImagePos(vnPosIndex.at(i),TRUE,pos);

				if (vnPosIndex.at(i)>=GetPosNum()/2)
				{
					nAllPosIndex = vnPosIndex.at(i)- GetPosNum()/2;
					vnAllPosIndex.push_back(nAllPosIndex);

					nAllPosIndex = vnPosIndex.at(i);
					vnAllPosIndex.push_back(nAllPosIndex);
				}
			}

			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				int nHomoPosIndex = 0;
				std::vector<int> vnHomoPosIndex;			// 源目标位置
				vnHomoPosIndex.push_back(nPosIndex);

				// 对目标2和3循环进行映射
				for (int i = 0; i<vnHomoPosIndex.size(); i++)
				{
					nHomoPosIndex = vnHomoPosIndex.at(i);
					if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
					{
						CCoordPos ObjImgPos;
						CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

						// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
						if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
						{
							//	ReportTargetSearchResultFTGM(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
							m_strStatusBarInfo2.Format(_T(""));
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

							//return FALSE;
						}

						// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
						m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
					}
				}

				// 设定、显示目标定位结果十字，全部0/1/2/3图像
				m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);

				// 				SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// 设定、显示目标定位结果文字，全部0/1/2/3图像
				// 				SetShowGuiTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
			}
			else
			{
				// 设定、显示结果图形
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

				// 				SetGuiAlnTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// SY
				// 				SetShowGuiTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
			}


			// 5. 设置对位工具
			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			// 保存目标定位结果
			SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

			m_bTargetMarkSearchSucceed = TRUE;

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_SUCCESS);//_T("实时目标Mark手动定位成功");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return TRUE;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_FAIL);//_T("实时目标Mark手动定位失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
	}
	else if (vnPosIndex.size() == 2)
	{
		CDlgManualSearchPos2 dlgManualSearch;
		dlgManualSearch.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex;
		dlgManualSearch.m_nMarkType = 1;
		dlgManualSearch.SetSysInfoStringsRef(m_psaSysInfoStrings);
		dlgManualSearch.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		dlgManualSearch.SetVisionAlignerRef(this, vnPosIndex);

		// 定义全部位置向量，包含0/1对象和2/3目标
		std::vector<int> vnAllPosIndex;
		int nAllPosIndex = 0;


		if (dlgManualSearch.DoModal() == IDOK)
		{
			for (int i=0; i<vnPosIndex.size(); i++)
			{
				CCoordPos pos = dlgManualSearch.m_vCoordPos.at(i);
				m_mpTargetMarkImagePos.SetMarkImagePos(vnPosIndex.at(i),TRUE,pos);

				if (vnPosIndex.at(i)>=GetPosNum()/2)
				{
					nAllPosIndex = vnPosIndex.at(i)- GetPosNum()/2;
					vnAllPosIndex.push_back(nAllPosIndex);

					nAllPosIndex = vnPosIndex.at(i);
					vnAllPosIndex.push_back(nAllPosIndex);
				}

			}

			if (TRUE == m_pPlatformInfo->m_bTargetObjectCamSeparate &&  m_pSystempOptionConfig->m_bShowSepTargetPos/* && FALSE == m_pPlatformInfo->m_bTargetCalibUseBoard && TRUE == m_pPlatformInfo->m_bTarObjCamSepNoAxisCalib*/)
			{
				int nHomoPosIndex = 0;
				std::vector<int> vnHomoPosIndex;			// 源目标位置
				vnHomoPosIndex.push_back(nPosIndex);

				// 对目标2和3循环进行映射
				for (int i = 0; i<vnHomoPosIndex.size(); i++)
				{
					nHomoPosIndex = vnHomoPosIndex.at(i);
					if (TRUE == m_mpTargetMarkImagePos.GetIsMarkImagePosOK(nHomoPosIndex))
					{
						CCoordPos ObjImgPos;
						CCoordPos TarImgPos = m_mpTargetMarkImagePos.GetMarkImagePos(nHomoPosIndex);

						// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
						if (!m_pAlignerTool->ConvertTarImgPosToObjImgPosUsingImageHomographyProject(ObjImgPos, nHomoPosIndex, TarImgPos))
						{
							//	ReportTargetSearchResultFTGM(FALSE);

							m_bStatusBar = FALSE;
							m_strStatusBarInfo1.Format(_T("执行目标图像坐标映射对象图像失败"));
							m_strStatusBarInfo2.Format(_T(""));
							SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

							//return FALSE;
						}

						// 将映射后图像坐标赋值给m_mpTargetMarkImagePos
						m_mpTargetMarkImagePos.SetMarkImagePos(nHomoPosIndex - GetPosNum()/2, TRUE, ObjImgPos);
					}
				}

				// 设定、显示目标定位结果十字，全部0/1/2/3图像
				m_cVisionAlignGui.SetPosSearchResult(vnAllPosIndex, eTargetSearch);

				// 				SetGuiAlnTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnAllPosIndex, TRUE);
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// 设定、显示目标定位结果文字，全部0/1/2/3图像
				// 				SetShowGuiTargetImageMarkPos(vnAllPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnAllPosIndex, TRUE);
			}
			else
			{
				// 设定、显示结果图形
				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eTargetSearch);

				// 				SetGuiAlnTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, TRUE);
				// 
				// 				if (m_pSystempOptionConfig->m_bShowCornerTool /*&& m_bIsTargetCornerSearchTool*/)
				// 				{
				// 					SetGuiAlnTargetLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// SY
				// 				SetShowGuiTargetImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, TRUE);
			}


			// 5. 设置对位工具
			SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

			// 保存目标定位结果
			SaveTargetPosInfo(GetTotalProuductData()->GetCurProductIndex());

			m_bTargetMarkSearchSucceed = TRUE;

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_SUCCESS);//_T("实时目标Mark手动定位成功");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return TRUE;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_FAIL);//_T("实时目标Mark手动定位失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
	}
	else
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_TARGET_POSITION_FAIL);//_T("实时目标Mark手动定位失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	return TRUE;
}


// 手动对象搜索
BOOL vcXYDVisionAlign::ManualObjectSearchEx(int nPosIndex)
{
	if (NULL == m_pPlatformInfo)
	{
		return FALSE;
	}

	SetDefaultObjectSearchMarkPos(TRUE);

	std::vector<int> vnPosIndex;
	if (nPosIndex>=0 && nPosIndex<=3)
	{
		vnPosIndex.push_back(nPosIndex);
	}
	else if (nPosIndex==4)
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum(); i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else if (nPosIndex==11) // 所有相机中的前一半编号
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else if (nPosIndex==12) // 所有相机中的后一半编号
	{
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i + GetPosNum()/2;
			vnPosIndex.push_back(nPosIndex);
		}
	}
	else
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_FAIL);//_T("实时对象Mark手动定位失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	if (vnPosIndex.size() == 1)
	{
		CDlgManualSearchPos1 dlgManualSearch;
		dlgManualSearch.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex;
		dlgManualSearch.m_nMarkType = 0;
		dlgManualSearch.SetSysInfoStringsRef(m_psaSysInfoStrings);
		dlgManualSearch.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		dlgManualSearch.SetVisionAlignerRef(this, vnPosIndex);

		if (dlgManualSearch.DoModal() == IDOK)
		{
			for (int i=0; i<vnPosIndex.size(); i++)
			{
				CCoordPos pos = dlgManualSearch.m_vCoordPos.at(i);
				m_mpObjectMarkImagePos.SetMarkImagePos(vnPosIndex.at(i),TRUE,pos);
			}

			// 			// 设定、显示结果图形
			// 			SetGuiAlnObjectImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
			// 			if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
			// 			{
			// 				SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
			// 				PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
			// 			}
			// 			// SY
			// 			SetShowGuiObjectImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

			// 5. 设置对位工具
			SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

			// 保存对象定位结果
			SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());

			m_bObjectMarkSearchSucceed = TRUE;

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_SUCCESS);//_T("实时对象Mark手动定位成功");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return TRUE;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_FAIL);_T("实时对象Mark手动定位失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
	}
	else if (vnPosIndex.size() == 2)
	{
		CDlgManualSearchPos2 dlgManualSearch;
		dlgManualSearch.m_nCurPlatformIndex = m_pPlatformInfo->m_nPlatformIndex;
		dlgManualSearch.m_nMarkType = 0;
		dlgManualSearch.SetSysInfoStringsRef(m_psaSysInfoStrings);
		dlgManualSearch.EnableSysKeyboard(m_pSystempOptionConfig->m_bSysKeyboardEnabled);
		dlgManualSearch.SetVisionAlignerRef(this, vnPosIndex);

		if (dlgManualSearch.DoModal() == IDOK)
		{
			for (int i=0; i<vnPosIndex.size(); i++)
			{
				CCoordPos pos = dlgManualSearch.m_vCoordPos.at(i);
				m_mpObjectMarkImagePos.SetMarkImagePos(vnPosIndex.at(i),TRUE,pos);
			}

			// 			// 设定、显示结果图形
			// 			SetGuiAlnObjectImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
			// 			if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
			// 			{
			// 				SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
			// 				PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
			// 			}
			// 			// SY
			// 			SetShowGuiObjectImageMarkPos(vnPosIndex);
			// 			PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

			// 5. 设置对位工具
			SetObjectMarkSearchResults(m_mpObjectMarkImagePos);

			// 保存对象定位结果
			SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());

			m_bObjectMarkSearchSucceed = TRUE;

			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_SUCCESS);//_T("实时对象Mark手动定位成功");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return TRUE;
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_FAIL);//_T("实时对象Mark手动定位失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
	}
	else
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_STR_SELECT_MARK_OBJECT_POSITION_FAIL);//_T("实时对象Mark手动定位失败");
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	return m_bObjectMarkSearchSucceed;
}	

BOOL vcXYDVisionAlign::SETFPMI()
{
	int nOffset=0;
	vector<double> DetectionResult;
	VisionAlignLogRecord("D:\\TimeLog.txt", "系统设置权限开通 开始");

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		CString strSimpleInfo;
		int nResult = 1;
		m_XYDCommProtocol.PackRePLCBaseFunc(strSimpleInfo, nResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);
		int nParam = nResult;

		int nOffSetMul = 0;

		BOOL bEnableMulReg= m_pPlatformInfo->m_bEnableMulRegTrigger;
		if(bEnableMulReg)
		{
			nOffSetMul =RREG_KEYENCE_PLC_REG_NUMS*m_XYDCommProtocol.m_nCurRegTriggerIndex;
			if(m_XYDCommProtocol.m_nCurRegTriggerIndex>=0 && m_XYDCommProtocol.m_nCurRegTriggerIndex<optionInfo.m_vnMulRegTriggerSet.size())
			{
				nOffSetMul = optionInfo.m_vnMulRegTriggerSet[m_XYDCommProtocol.m_nCurRegTriggerIndex].m_nMulRegOffset;
			}
		}

		// 打包写寄存器指令 向D2中写结果
		if (FALSE == m_XYDCommProtocol.PackWritePLCWithDetectionResultFunc(strSend, nParam,DetectionResult,atoi(RREG_KEYENCE_VISION_TRIGGER)+nOffset+nOffSetMul))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确 此处命令码和触发位一致 视觉指令触发置位
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}
	}
	else
	{
		// 不支持无协议
		return FALSE;
	}
	VisionAlignLogRecord("D:\\TimeLog.txt", "系统设置权限开通 结束");

	return TRUE;
}




BOOL vcXYDVisionAlign::UpdateTargetPosAfterRoate()
{
	int i = 0;
	int nPosIndex;		
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	std::vector<int> vnPosIndex;
	std::vector<int> vSepTarPosIndex;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
	}

	CCoordPos pos;
	for (i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		pos = m_pAlignerTool->GetImageCoordPosAfterRotate(i);
		if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
		{
			if (i<nPosNum/2)
			{
				m_mpTargetMarkImagePos.SetMarkImagePos(i,TRUE,pos);
				m_mpTargetRotatedMarkImagePos.SetMarkImagePos(i,TRUE,pos);
				vSepTarPosIndex.push_back(i);
			}
			else
			{
				m_mpTargetRotatedMarkImagePos.SetMarkImagePos(i,FALSE,pos);
			}

		}
		else
		{
			m_mpTargetRotatedMarkImagePos.SetMarkImagePos(i,TRUE,pos);
		}

		// 		m_vpGuiAlnTargetRotatedImageMarkPos.at(nPosIndex)->SetCenterRotationLengths(
		// 			sc2Vector(pos.m_dPosX,pos.m_dPosY),scDegree(0), 3000,3000);
	}

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);
	// 	if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
	// 	{
	// 		PostMessageUpdateGuiAlnTargetImagePosGraphics(vSepTarPosIndex,FALSE);
	// 		//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
	// 		{
	// 			PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vSepTarPosIndex, FALSE);
	// 		}
	// 	}
	// 
	// 	PostMessageUpdateGuiAlnTargetRotatedImagePosGraphics(vnPosIndex, TRUE);
	// 	SetAllShowGuiTargetImageMarkPos();
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex,TRUE);
	// 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex,FALSE);
	// 
	// 	//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
	// 	{
	// 		PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	return TRUE;
}

BOOL vcXYDVisionAlign::AddLastTargetOffsetForAln(CPlatformXYDAxisPos* platformAxisPos)
{
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	SysPlatformInfo sysPlatformInfo;
	GetSysPlatformInfo(sysPlatformInfo);

	if (pAlignerParam==NULL)
	{
		return FALSE;
	}
	if (pAlignerParam->GetEnableAlnTargetOffset())
	{	//////////////////////////////////////////////////////////////////////////
		////
		//首先把目标mark搜索时的轴位置（即当前位置）付给m_pPlatformPos，再加上对位偏移量；
		double dPosX = pAlignerParam->GetAlnTargetOffsetX();
		double dPosY = pAlignerParam->GetAlnTargetOffsetY();

		CPlatformXYDInfo* platformXYDInfo = (CPlatformXYDInfo*)(m_pVisionASMConfig->m_pPlatformInfo);

		int iPlatformYCoordType = platformXYDInfo->m_nPlatformYCoordType;
		int iPlatformXCoordType = platformXYDInfo->m_nPlatformXCoordType;


		if (eDirectNegative == iPlatformXCoordType) dPosX = -1*dPosX;
		if (eDirectNegative == iPlatformYCoordType) dPosY = -1*dPosY;	


		if ((ePlatformXDPY == sysPlatformInfo.m_eMidPlatformType) || (ePlatformXDPY1 == sysPlatformInfo.m_eMidPlatformType))
		{
			dPosY = -1*dPosY;
		}

		platformAxisPos->m_dPosX+=dPosX;
		platformAxisPos->m_dPosY+=dPosY;

		return TRUE;
	}


	return FALSE;




}

// 获取目标/对象指定位置的平台坐标
BOOL vcXYDVisionAlign::ReportGetSearchWorldPosFWLD(BOOL bResult, double dPlatformPosX, double dPlatformPosY, double dPlatformPosD)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 指令解析
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetSearchWorldPosFWLD(strSimpleInfo, bResult, dPlatformPosX, dPlatformPosY/*, dPlatformPosD*/);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 先发送平台坐标到轴位置，再写触发和动作
		CCoordPos platformPos;
		platformPos.m_dPosX = dPlatformPosX;
		platformPos.m_dPosY = dPlatformPosY;
		platformPos.m_dAngle = dPlatformPosD;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFWLDAxisPos(strSend, platformPos, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFWLD(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetSearchWorldPosFWLD(strInfo, bResult, dPlatformPosX, dPlatformPosY/*, dPlatformPosD*/))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

// 获取目标/对象指定位置的平台坐标
BOOL vcXYDVisionAlign::OnlineGetSearchWorldPosFWLD(int nPosIndex, int nMarkType)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VWLD:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		ReportGetSearchWorldPosFWLD(FALSE);
		return FALSE;
	}

	if(nPosIndex < 0 || nPosIndex >= m_pPlatformInfo->m_nPositionNum)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INPUT_POS_PARAM_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportGetSearchWorldPosFWLD(FALSE);
		return FALSE;
	}

	if(nMarkType < 0 || nMarkType > 1)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INPUT_TARGET_AND_OBJECT_PARAM_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportGetSearchWorldPosFWLD(FALSE);
		return FALSE;
	}

	// 定义平台坐标
	double dPlatformPosX = 0, dPlatformPosY = 0, dPlatformPosD = 0;

	// 状态栏说明
	CString strStatusBarInfo;

	// 如果是目标0
	if (nMarkType == 0)
	{
		// 如果是基准目标
		if (eTargetBench == m_pPlatformInfo->m_eAlignerTargetType)
		{	
			// 不考虑基准修正
			if (FALSE == m_pPlatformInfo->m_bBenchMarkAmend)
			{
				// 获取当前产品
				int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
				CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
				if (pCurProductData == NULL)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_FAIL);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					ReportGetSearchWorldPosFWLD(FALSE);
					return FALSE;
				}

				dPlatformPosX =  pCurProductData->m_vpCalibratedInfo.at(nPosIndex)->m_cpMarkPlatformCoordPos.GetPosX();
				dPlatformPosY =  pCurProductData->m_vpCalibratedInfo.at(nPosIndex)->m_cpMarkPlatformCoordPos.GetPosY();
				dPlatformPosD =  pCurProductData->m_vpCalibratedInfo.at(nPosIndex)->m_cpMarkPlatformCoordPos.GetAngle();

				strStatusBarInfo.Format(_T("基准目标位置%d, X:%.4f, Y:%.4f, D:%.4f"), nPosIndex, dPlatformPosX, dPlatformPosY, dPlatformPosD);
			}
		}
		else	// 否则是实时目标
		{
			// 获取目标平台坐标
			CMarkPlatformPos mpTargetMarkPos;
			mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();

			dPlatformPosX = mpTargetMarkPos.m_vPos.at(nPosIndex).GetPosX();
			dPlatformPosY = mpTargetMarkPos.m_vPos.at(nPosIndex).GetPosY();
			dPlatformPosD = mpTargetMarkPos.m_vPos.at(nPosIndex).GetAngle();

			strStatusBarInfo.Format(_T("实时目标位置%d, X:%.4f, Y:%.4f, D:%.4f"), nPosIndex, dPlatformPosX, dPlatformPosY, dPlatformPosD);
		}
	}
	else	// 否则是对象1
	{
		// 对象不需要判断是基准/实时，在GetObjectMarkPlatformPos已做处理

		// 获取对象平台坐标
		CMarkPlatformPos mpObjectMarkPos;
		mpObjectMarkPos = m_pAlignerTool->GetObjectMarkPlatformPos();

		dPlatformPosX = mpObjectMarkPos.m_vPos.at(nPosIndex).GetPosX();
		dPlatformPosY = mpObjectMarkPos.m_vPos.at(nPosIndex).GetPosY();
		dPlatformPosD = mpObjectMarkPos.m_vPos.at(nPosIndex).GetAngle();

		strStatusBarInfo.Format(_T("对象位置%d, X:%.4f, Y:%.4f, D:%.4f"), nPosIndex+1, dPlatformPosX, dPlatformPosY, dPlatformPosD);
	}

	m_bStatusBar = TRUE;

	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_PLATFORM_COORD_SUCCEED);
	m_strStatusBarInfo2 = strStatusBarInfo;
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	ReportGetSearchWorldPosFWLD(TRUE, dPlatformPosX, dPlatformPosY, dPlatformPosD);

	return TRUE;
}

// 获取目标/对象Mark的平台坐标系半径（相对于旋转中心的距离）
BOOL vcXYDVisionAlign::ReportGetSearchWorldRadiusFWDR(BOOL bResult, double dPlatformPosX/* = 0*/, double dPlatformPosY/* = 0*/, double dPlatformPosD/* = 0*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 指令解析
		CString strSimpleInfo;
		CCoordPos platformRadius;
		platformRadius.m_dPosX = dPlatformPosX;
		platformRadius.m_dPosY = dPlatformPosY;
		platformRadius.m_dAngle = dPlatformPosD;
		m_XYDCommProtocol.PackReGetSearchWorldRadiusFWDR(strInfo, bResult, platformRadius);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 先发送平台坐标到轴位置，再写触发和动作
		CCoordPos platformPos;
		platformPos.m_dPosX = dPlatformPosX;
		platformPos.m_dPosY = dPlatformPosY;
		platformPos.m_dAngle = dPlatformPosD;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetSearchWorldRadiusFWDRRadius(strSend, bResult, platformPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetSearchWorldRadiusFWDR(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		CCoordPos platformRadius;
		platformRadius.m_dPosX = dPlatformPosX;
		platformRadius.m_dPosY = dPlatformPosY;
		platformRadius.m_dAngle = dPlatformPosD;
		if (!m_XYDCommProtocol.PackReGetSearchWorldRadiusFWDR(strInfo, bResult, platformRadius))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

// 获取目标/对象Mark的平台坐标系半径（相对于旋转中心的距离）
BOOL vcXYDVisionAlign::OnlineGetSearchWorldRadiusFWDR(int nPosIndex, int nMarkType)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VWDR:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		ReportGetSearchWorldRadiusFWDR(FALSE);
		return FALSE;
	}

	if(nPosIndex < 0 || (nPosIndex >= m_pPlatformInfo->m_nPositionNum && nPosIndex != 4))
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INPUT_POS_PARAM_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportGetSearchWorldRadiusFWDR(FALSE);
		return FALSE;
	}

	if(nMarkType < 0 || nMarkType > 1)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_INPUT_TARGET_AND_OBJECT_PARAM_OUT_RANGE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		ReportGetSearchWorldRadiusFWDR(FALSE);
		return FALSE;
	}

	// 定义平台坐标
	double dPlatformPosX = 0, dPlatformPosY = 0, dPlatformPosD = 0;
	double dPlatformRadius = 0;

	// 状态栏说明
	CString strStatusBarInfo;

	// 如果是目标0
	if (nMarkType == 0)
	{
		// 如果是基准目标
		if (eTargetBench == m_pPlatformInfo->m_eAlignerTargetType)
		{	
			// 不考虑基准修正
			if (FALSE == m_pPlatformInfo->m_bBenchMarkAmend)
			{
				// 获取当前产品
				int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
				CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
				if (pCurProductData == NULL)
				{
					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_FAIL);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
					ReportGetSearchWorldRadiusFWDR(FALSE);
					return FALSE;
				}

				dPlatformPosX =  pCurProductData->m_vpCalibratedInfo.at(nPosIndex)->m_cpMarkPlatformCoordPos.GetPosX();
				dPlatformPosY =  pCurProductData->m_vpCalibratedInfo.at(nPosIndex)->m_cpMarkPlatformCoordPos.GetPosY();
				dPlatformPosD =  pCurProductData->m_vpCalibratedInfo.at(nPosIndex)->m_cpMarkPlatformCoordPos.GetAngle();

				dPlatformRadius = sqrt((dPlatformPosX)*(dPlatformPosX)+(dPlatformPosY)*(dPlatformPosY));

				strStatusBarInfo.Format(_T("基准目标位置%d, X:%.4f, Y:%.4f, D:%.4f, R:%.4f"), nPosIndex, dPlatformPosX, dPlatformPosY, dPlatformPosD, dPlatformRadius);
			}
		}
		else	// 否则是实时目标
		{
			// 获取目标平台坐标
			CMarkPlatformPos mpTargetMarkPos;
			mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();

			if (nPosIndex == 4)
			{
				int i = 0; 
				for (i = 0; i < mpTargetMarkPos.GetMarkPlatformPosNum(); i++)
				{
					dPlatformPosX += mpTargetMarkPos.m_vPos.at(i).GetPosX();
					dPlatformPosY += mpTargetMarkPos.m_vPos.at(i).GetPosY();
					dPlatformPosD += mpTargetMarkPos.m_vPos.at(i).GetAngle();
				}
				dPlatformPosX = dPlatformPosX/mpTargetMarkPos.GetMarkPlatformPosNum();
				dPlatformPosY = dPlatformPosY/mpTargetMarkPos.GetMarkPlatformPosNum();
				dPlatformPosD = dPlatformPosD/mpTargetMarkPos.GetMarkPlatformPosNum();

				dPlatformRadius = sqrt((dPlatformPosX)*(dPlatformPosX)+(dPlatformPosY)*(dPlatformPosY));
				strStatusBarInfo.Format(_T("实时目标位置%d, X:%.4f, Y:%.4f, D:%.4f, R:%.4f"), nPosIndex+1, dPlatformPosX, dPlatformPosY, dPlatformPosD, dPlatformRadius);
			}
			else
			{
				dPlatformPosX = mpTargetMarkPos.m_vPos.at(nPosIndex).GetPosX();
				dPlatformPosY = mpTargetMarkPos.m_vPos.at(nPosIndex).GetPosY();
				dPlatformPosD = mpTargetMarkPos.m_vPos.at(nPosIndex).GetAngle();

				dPlatformRadius = sqrt((dPlatformPosX)*(dPlatformPosX)+(dPlatformPosY)*(dPlatformPosY));

				strStatusBarInfo.Format(_T("实时目标位置%d, X:%.4f, Y:%.4f, D:%.4f, R:%.4f"), nPosIndex+1, dPlatformPosX, dPlatformPosY, dPlatformPosD, dPlatformRadius);
			}
		}
	}
	else	// 否则是对象1
	{
		// 对象不需要判断是基准/实时，在GetObjectMarkPlatformPos已做处理

		// 获取对象平台坐标
		CMarkPlatformPos mpObjectMarkPos;
		mpObjectMarkPos = m_pAlignerTool->GetObjectMarkPlatformPos();

		if (nPosIndex == 4)
		{
			int i = 0; 
			for (i = 0; i < mpObjectMarkPos.GetMarkPlatformPosNum(); i++)
			{
				dPlatformPosX += mpObjectMarkPos.m_vPos.at(i).GetPosX();
				dPlatformPosY += mpObjectMarkPos.m_vPos.at(i).GetPosY();
				dPlatformPosD += mpObjectMarkPos.m_vPos.at(i).GetAngle();
			}
			dPlatformPosX = dPlatformPosX/mpObjectMarkPos.GetMarkPlatformPosNum();
			dPlatformPosY = dPlatformPosY/mpObjectMarkPos.GetMarkPlatformPosNum();
			dPlatformPosD = dPlatformPosD/mpObjectMarkPos.GetMarkPlatformPosNum();

			dPlatformRadius = sqrt((dPlatformPosX)*(dPlatformPosX)+(dPlatformPosY)*(dPlatformPosY));
			strStatusBarInfo.Format(_T("对象位置%d, X:%.4f, Y:%.4f, D:%.4f, R:%.4f"), nPosIndex+1, dPlatformPosX, dPlatformPosY, dPlatformPosD, dPlatformRadius);
		}
		else
		{
			dPlatformPosX = mpObjectMarkPos.m_vPos.at(nPosIndex).GetPosX();
			dPlatformPosY = mpObjectMarkPos.m_vPos.at(nPosIndex).GetPosY();
			dPlatformPosD = mpObjectMarkPos.m_vPos.at(nPosIndex).GetAngle();

			dPlatformRadius = sqrt((dPlatformPosX)*(dPlatformPosX)+(dPlatformPosY)*(dPlatformPosY));

			strStatusBarInfo.Format(_T("对象位置%d, X:%.4f, Y:%.4f, D:%.4f, R:%.4f"), nPosIndex+1, dPlatformPosX, dPlatformPosY, dPlatformPosD, dPlatformRadius);

		}
	}

	m_bStatusBar = TRUE;

	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_RADIUS_SUCCEED);
	m_strStatusBarInfo2 = strStatusBarInfo;
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	ReportGetSearchWorldRadiusFWDR(TRUE, dPlatformRadius);

	return TRUE;
}

// FGOW:拍照取得对象（对象靶标）的平台坐标上的位置
BOOL vcXYDVisionAlign::ReportGetObjectWorldPosFGOW(BOOL bResult, double dPlatformPosX/* = 0*/, double dPlatformPosY/* = 0*/, double dPlatformPosD/* = 0*/)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// strSimpleInfo
		CString strSimpleInfo;
		CCoordPos platformRadius;
		platformRadius.m_dPosX = dPlatformPosX;
		platformRadius.m_dPosY = dPlatformPosY;
		platformRadius.m_dAngle = dPlatformPosD;
		m_XYDCommProtocol.PackReGetObjectWorldPosFGOW(strSimpleInfo, bResult, platformRadius);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 先发送平台坐标到轴位置，再写触发和动作
		CCoordPos platformPos;
		platformPos.m_dPosX = dPlatformPosX;
		platformPos.m_dPosY = dPlatformPosY;
		platformPos.m_dAngle = dPlatformPosD;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetObjectWorldPosFGOWAxisPos(strSend, bResult, platformPos))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcGetObjectWorldPosFGOW(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		CCoordPos platformRadius;
		platformRadius.m_dPosX = dPlatformPosX;
		platformRadius.m_dPosY = dPlatformPosY;
		platformRadius.m_dAngle = dPlatformPosD;
		if (!m_XYDCommProtocol.PackReGetObjectWorldPosFGOW(strInfo, bResult, platformRadius))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}
// FGOW:拍照取得对象（对象靶标）的平台坐标上的位置
BOOL vcXYDVisionAlign::OnlineAlnSearchExFGOW(int nPosIndex, int nPatIndex)
{
	CString strCmd = _T("VGOW:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	BOOL bSuccess = FALSE;


	if (nPosIndex>=0 && nPosIndex <= nPosNum-1)	//编号0～3的相机中的一个
	{
		bSuccess = OnSingleCameraAlignerSearchExFGOW(nPosIndex, nPatIndex);
	}

	return bSuccess;

}

// FGOW:拍照取得对象（对象靶标）的平台坐标上的位置
BOOL vcXYDVisionAlign::OnSingleCameraAlignerSearchExFGOW(int nPosIndex, int nPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
	PostMessageUpdateStatusBarInfo();
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	double dPlatformPosX = 0;
	double dPlatformPosY = 0;
	double dPlatformPosD = 0;
	CString strCmd = _T("VGOW:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckObjectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidObjectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = _T("");
		// 		m_strStatusBarInfo2 = _T("");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		if(m_bObjectSearchTest) ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
		return FALSE;
	}

	// 1. 通信获取当前平台各个轴的绝对位置
	CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;

	BOOL bCommuciateGetPlatformAxisAbsPos = FALSE;
	if (!optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
	{
		*pPlatformAxisPos = m_CurPlatformAxisPos;
		bCommuciateGetPlatformAxisAbsPos = TRUE;
	}
	else
	{
		if (optionInfo.m_bObjectPosSame == TRUE)
		{
			if (optionInfo.m_bAskStagePosEachMove && m_bAutoAlign == TRUE && m_nAlignTime > 1)
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}
			else
			{
				if (nPosIndex >= m_vpObjectPlatformAxisPos.size() || m_vpObjectPlatformAxisPos.at(nPosIndex) == NULL)
				{
					bCommuciateGetPlatformAxisAbsPos = FALSE;
				}
				else
				{
					*pPlatformAxisPos = *((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex));
					bCommuciateGetPlatformAxisAbsPos = TRUE;
				}
			}
		}
		else
		{
			if (m_bCmdParamAxisPosEanble == TRUE)		// 指令参数轴位置有效
			{
				if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
				{					
					bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);				
				}
				else	// 不是全自动对位，或者全自动第1次对位时，指令参数获取轴位置
				{
					bCommuciateGetPlatformAxisAbsPos = CommParamGetPlatformAxisAbsPos(pPlatformAxisPos);
				}
			}
			else
			{
				bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
			}

			//bCommuciateGetPlatformAxisAbsPos = CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos);
		}

	}

	if (m_bAutoAlign == TRUE && m_nAlignTime > 1)	// 全自动对位且不是第1次对位时通信获取轴位置
	{		
		if (ePlatformXYPD == m_pPlatformInfo->m_eMidPlatformType) //如果是XY+D平台，D角度不累加
		{						
			if (m_pPlatformInfo->m_bTargetObjectCamSeparate)
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
				//D角度不累加
			}
			else
			{
				pPlatformAxisPos->m_dAngle = ((CPlatformXYDAxisPos*)m_vpObjectPlatformAxisPos.at(nPosIndex))->m_dAngle;
			}
			//D角度不累加
		}
	}
	//if (FALSE == CommuciateGetPlatformAxisAbsPos(pPlatformAxisPos))
	if (!bCommuciateGetPlatformAxisAbsPos)
	{
		if (pPlatformAxisPos!=NULL)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;					
		}

		//if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PLATFORM_POS_FAILED));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		if(m_bObjectSearchTest) ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);//
		return FALSE;
	}
	else
	{ 
		SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
		if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == TRUE && m_nAlignTime == 1) 
			|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
		{
			SetTempObjectPlatformAxisPos(nPosIndex,pPlatformAxisPos);
		}

		SysPlatformInfo sysPlatformInfo;
		GetSysPlatformInfo(sysPlatformInfo);
		CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if ((optionInfo.m_bEnableMultiMarkMode) && (nPosIndex == 0))
		{
			SetObjectPlatformPos(pPlatformAxisPos,nPosIndex+1);
			if ((/*m_pSystempOptionConfig->m_bSaveAlignPos && */m_bAutoAlign == TRUE && m_nAlignTime == 1) 
				|| (/*m_pSystempOptionConfig->m_bSaveAlignPos && */ m_bAutoAlign == FALSE))
			{
				SetTempObjectPlatformAxisPos(nPosIndex+1,pPlatformAxisPos);
			}
		}

		// 记录当前平台各个轴的绝对位置
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
		{
			CString strTemp;
			// 			CTime t = CTime::GetCurrentTime();
			// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strInfo;
			strInfo.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_XYD_OBJECT_SEARCH_PLATFORM_POS),
				pPlatformAxisPos->m_dPosX, pPlatformAxisPos->m_dPosY, pPlatformAxisPos->m_dAngle);
			strInfo = strTemp + strInfo;

			// 			FILE *stream;
			// 			CString strPath = m_strAlignProcessData;
			// 			stream = fopen(strPath, _T("a+t"));
			// 			fwrite(strInfo, sizeof(TCHAR), strInfo.GetLength(), stream);
			// 			fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strInfo);
		}

		if (pPlatformAxisPos)
		{
			delete pPlatformAxisPos;
			pPlatformAxisPos = NULL;
		}
	}


	if (NULL == GetPosDisplay(nPosIndex))
	{
		m_bStatusBar = FALSE;
		//m_strStatusBarInfo1 = _T("");
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_GETDISPLAYPOINTERFAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		if(m_bObjectSearchTest) ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			// 			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = _T("");
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();
			if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 等待搜索延时
	// 		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	// 		int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	// 		Sleep(nDelayTime);

	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	int nDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime2();
	BOOL bEnableDelayTime2 = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableObjectSearchDelayTime2();

	// 自动对位过程中
	if (m_bAutoAlign == TRUE)
	{
		// 使用对象搜索延时2
		if (TRUE == bEnableDelayTime2)
		{
			if (1 == m_nAlignTime)
			{
				Sleep(nDelayTime);
			}
			else
			{
				Sleep(nDelayTime2);
			}
		}
		else
		{
			// 不使用对象搜索延时2，按照第一个搜索延时设置
			Sleep(nDelayTime);
		}

	}
	else
	{
		// 如果只接收到定位指令，按第一个对象搜索延时进行设置
		Sleep(nDelayTime);
	}

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	vnPosIndex.push_back(nPosIndex); 	
	vsmSearchMode.push_back(eObjectSearch);	 

	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, FALSE);
	// 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnPosIndex, FALSE);
	// 
	// 	//if (m_bIsObjectCornerSearchTool /*&& (m_pSystempOptionConfig->m_bShowCornerTool)*/)
	// 	{
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	// 	//if (/*m_pSystempOptionConfig->m_bShowCornerTool &&*/ m_bIsTargetCornerSearchTool)
	// 	{
	// 		PostMessageUpdateGuiAlnTargetLineImagePosGraphics(vnPosIndex, FALSE);
	// 	}
	// 	// SY
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, FALSE);
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eObjectSearch);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eTargetSearch);


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();
	BOOL bSearchSucceed = FALSE;
	if (bObjectSearchCandidate == FALSE)
	{
		if (nPatIndex == 0)
		{
			m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
			m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
		else
		{
			m_bStatusBar = FALSE;
			// 			m_strStatusBarInfo1 = _T("");
			// 			m_strStatusBarInfo2 = _T("");
			// 			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			// 			PostMessageUpdateStatusBarInfo();
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
			if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
			return FALSE;
		}
	}
	else
	{
		//if (nPatIndex >= 1 && nPatIndex < OBJECTCANDIDATENUM)
		//{
		//	m_vnObjectSearchStartPatIndex[nPosIndex] = nPatIndex;
		//	m_vnObjectSearchEndPatIndex[nPosIndex] = nPatIndex;
		//}
		//else
		//{
		//	m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
		//	m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
		//}
		//bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		int nTempStartPatIndex, nTempEndPatIndex;
		for(i = 0; i < vnPosIndex.size(); i++)
		{
			nPosIndex = vnPosIndex[i];
			if (nPatIndex>=0 && nPatIndex < OBJECTCANDIDATENUM)
			{
				nTempStartPatIndex = nPatIndex;
			}
			else if (nPatIndex == 9)
			{
				nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = OBJECTCANDIDATENUM-1;

			m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
			m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	// 设定、显示结果图形
	// 	SetGuiAlnObjectImageMarkPos(vnPosIndex);
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
	// 	if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
	// 	{
	// 		SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
	// 		PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
	// 	}
	// 	// SY
	// 	SetShowGuiObjectImageMarkPos(vnPosIndex);
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);


	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bSearchTimes)
		{
			for (int k = 0; k < optionInfo.m_nSearchTimes; k++)
			{
				// 使用对象搜索延时2
				if (TRUE == bEnableDelayTime2)
				{
					Sleep(nDelayTime2);
				}

				// 采集搜索图像
				if (!SnapSearchImage(vnPosIndex))
				{
					if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
					m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();
					OnFailedSnapSearchImage(strCmd);
					return FALSE;
				}

				// 定位
				BOOL bObjectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectCandidateEnable();

				if (bObjectSearchCandidate == FALSE)
				{
					if (nPatIndex == 0)
					{
						m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
						m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
						bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					}
					else
					{
						m_bStatusBar = FALSE;
						// 						m_strStatusBarInfo1 = _T("");
						// 						m_strStatusBarInfo2 = _T("");
						// 						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
						// 						PostMessageUpdateStatusBarInfo();
						m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
						m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
						SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
						PostMessageUpdateStatusBarInfo();
						strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
						AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
						if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);// if(m_bObjectSearchTest) SendCommInfo(CMD_OBG_SEARCH_UNKNOWN_ERR);
						return FALSE;
					}
				}
				else
				{
					//if (nPatIndex >= 1 && nPatIndex < OBJECTCANDIDATENUM)
					//{
					//	m_vnObjectSearchStartPatIndex[nPosIndex] = nPatIndex;
					//	m_vnObjectSearchEndPatIndex[nPosIndex] = nPatIndex;
					//}
					//else
					//{
					//	m_vnObjectSearchStartPatIndex[nPosIndex] = 0;
					//	m_vnObjectSearchEndPatIndex[nPosIndex] = 0;
					//}
					//bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
					int nTempStartPatIndex, nTempEndPatIndex;
					for(i = 0; i < vnPosIndex.size(); i++)
					{
						nPosIndex = vnPosIndex[i];
						if (nPatIndex>=0 && nPatIndex < OBJECTCANDIDATENUM)
						{
							nTempStartPatIndex = nPatIndex;
						}
						else if (nPatIndex == 9)
						{
							nTempStartPatIndex = m_vnObjectSearchSuccessPatIndex[nPosIndex];
						}
						else
						{
							nTempStartPatIndex = 0;
						}
						nTempEndPatIndex = OBJECTCANDIDATENUM-1;

						m_vnObjectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
						m_vnObjectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
					}
					bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
				}

				// 设定、显示结果图形
				// 				SetGuiAlnObjectImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateGuiAlnObjectImagePosGraphics(vnPosIndex, TRUE);
				// 				if (/*m_bIsObjectCornerSearchTool && */(m_pSystempOptionConfig->m_bShowCornerTool))
				// 				{
				// 					SetGuiAlnObjectLineImageMarkPos(vnPosIndex);
				// 					PostMessageUpdateGuiAlnObjectLineImagePosGraphics(vnPosIndex, TRUE);
				// 				}
				// 				// SY
				// 				SetShowGuiObjectImageMarkPos(vnPosIndex);
				// 				PostMessageUpdateShowGuiObjectImagePosToDisplay(vnPosIndex, TRUE);

				m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eObjectSearch);

				if (bSearchSucceed)
				{
					break;
				}
			}
		}
	}

	if (FALSE == bSearchSucceed)
	{
		if (optionInfo.m_bManualAfObjSearchFail)
		{
			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉弹出手动搜索框
				if(m_bObjectSearchTest) SetPlcManualSearch(TRUE);
			}


			// 弹出手动搜索框
			if (TRUE ==ExcuteManualSearch(1,vnPosIndex))
			{
				bSearchSucceed = TRUE;
			}

			if (optionInfo.m_bSetVisionManualSearchToPLC)
			{
				// 通知PLC，视觉关闭手动搜索框
				if(m_bObjectSearchTest) SetPlcManualSearch(FALSE);
			}
		}

	}

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		PostMessageSaveVDBFile(vnPosIndex,eObjectSearch);
	}

	if (FALSE == bSearchSucceed)
	{
		if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_IN_CAM_PLATFORM_OBJECT_SEARCH_FAILED),nPosIndex+1);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}


	for (i = 0; i < m_mpObjectMarkImagePos.m_vbOK.size(); i++)
	{
		if (i != nPosIndex)
		{
			m_mpObjectMarkImagePos.m_vbOK.at(i) = true;
		}		
	}


	SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 

	if ((optionInfo.m_bSaveAlignPos && m_bAutoAlign == TRUE && m_nAlignTime == 1) 
		|| (optionInfo.m_bSaveAlignPos && m_bAutoAlign == FALSE))
	{
		SaveObjectPosInfo(GetTotalProuductData()->GetCurProductIndex());
	}

	// 记录图像搜索数据
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 			CTime t = CTime::GetCurrentTime();
		// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");

		strTemp = _T("");
		cp = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex);

		strTemp.Format(_T("MarkPos%d(%.2f,%.2f) "), nPosIndex, cp.GetPosX(), cp.GetPosY());

		strOut += strTemp;

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);

	}	


	BOOL bSucced = FALSE;
	bSucced = m_mpObjectMarkImagePos.GetIsMarkImagePosOK(nPosIndex);


	if(m_pAlignerTool == NULL)
	{
		if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	// 计算对象平台坐标
	CMarkPlatformPos mpObjectMarkPos;
	mpObjectMarkPos = m_pAlignerTool->GetObjectMarkPlatformPos();
	bSucced = mpObjectMarkPos.GetIsMarkPlatformPosOK(nPosIndex);

	// 记录图像搜索数据平台坐标
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		// 			CTime t = CTime::GetCurrentTime();
		// 			strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

		CString strOut;
		CCoordPos cp;
		strOut = strTemp + _T("ObjectSearch: ");

		strTemp = _T("");
		cp = mpObjectMarkPos.GetMarkPlatformPos(nPosIndex);

		strTemp.Format(_T("MarkPlatPos%d(%.2f,%.2f) "), nPosIndex, cp.GetPosX(), cp.GetPosY());

		strOut += strTemp;

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);

	}	

	if (bSucced)
	{		
		CCoordPos cp;
		cp = mpObjectMarkPos.GetMarkPlatformPos(nPosIndex);

		dPlatformPosX = cp.GetPosX();
		dPlatformPosY = cp.GetPosY();
		dPlatformPosD = cp.GetAngle();

		if (m_pAlignerTool && m_pAlignerTool->GetProductAlignerParam())
		{
			CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();

			if (pAlignerParam->m_bAlignOffsetReverseX)
			{
				dPlatformPosX = -1*dPlatformPosX;
			}
			if (pAlignerParam->m_bAlignOffsetReverseY)
			{
				dPlatformPosY = -1*dPlatformPosY;
			}
			if (pAlignerParam->m_bAlignOffsetReverseD)
			{
				dPlatformPosD = -1*dPlatformPosD;
			}

		}



		if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(TRUE,dPlatformPosX,dPlatformPosY,dPlatformPosD);
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_SUCCEED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		return TRUE;

	}
	else
	{

		if(m_bObjectSearchTest)ReportGetObjectWorldPosFGOW(FALSE,dPlatformPosX,dPlatformPosY,dPlatformPosD);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;

	}

	return FALSE;

}

BOOL vcXYDVisionAlign::ReportCalibResultFCBR(BOOL bResult)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 指令解析
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReCalibrateFCBR(strSimpleInfo, bResult);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcCalibrateFCBR(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReCalibrateFCBR(strInfo, bResult))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

// 读写寄存器时，关联标定通信获取两个MARK的平台坐标
BOOL vcXYDVisionAlign::CommuciateGetPlatformPosFCBR(double& dPlatformPos1X, double& dPlatformPos1Y, double& dPlatformPos2X, double& dPlatformPos2Y)
{
	// 如果不是PLC直接读取存储寄存器协议
	if (!m_XYDCommProtocol.IsPlcProtocolType())
	{
		// 返回失败
		return FALSE;
	}

	// 解析获取平台坐标命令时，仍然采用MNPS，不再定义新命令
	CString strSimpleInfo;
	m_XYDCommProtocol.PackGetPlatformAbsPos(strSimpleInfo);;
	AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);


	//////////////////////////////////////////////////////////////////////////
	// 读取寄存器
	CString strSend;

	// 打包读取寄存器指令
	if (FALSE == m_XYDCommProtocol.PackPlcGetPlatformPosFCBR(strSend))
	{
		return FALSE;
	}

	// 发送读取命令，接收PLC回复
	BOOL bReceived;
	CString strInfo;
	CommStatus nCommStatus = eCommSucceed;
	bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
	if (bReceived == FALSE || nCommStatus != eCommSucceed)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
		return FALSE;
	}

	// 解析收到的响应
	CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetPlatformPosFCBR(strInfo, dPlatformPos1X, dPlatformPos1Y, dPlatformPos2X, dPlatformPos2Y);
	if (answeredStatus != eAswSucceed)
	{
		int i = 0;
		CCommOptionInfo commOptionInfo;
		GetCommOptionInfo(commOptionInfo);
		/*for(i = 0; i < m_pSystempOptionConfig->m_nCommReSendTimes && i < 10; i++)*/
		for(i = 0; i < commOptionInfo.m_nCommReSendTimes && i < 10; i++)
		{
			// 读取寄存器
			CString strSend;

			// 打包读取寄存器指令
			if (FALSE == m_XYDCommProtocol.PackPlcGetPlatformPosFCBR(strSend))
			{
				return FALSE;
			}

			// 发送读取命令，接收PLC回复
			BOOL bReceived;
			CString strInfo;
			CommStatus nCommStatus = eCommSucceed;
			bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
				m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_RECEIVE_GET_PLATFORM_POS_ASW_OUTTIME);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				return FALSE;
			}

			// 解析收到的响应
			CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcGetPlatformPosFCBR(strInfo, dPlatformPos1X, dPlatformPos1Y, dPlatformPos2X, dPlatformPos2Y);

			// 解析获取平台坐标命令时，仍然采用MNPS，不再定义新命令
			std::vector<int> nParam;
			std::vector<double> dParam;
			nParam.push_back(0);
			dParam.push_back(dPlatformPos1X);
			dParam.push_back(dPlatformPos1Y);
			dParam.push_back(dPlatformPos2X);
			dParam.push_back(dPlatformPos2Y);
			PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MNPSParam.m_strCmd,nParam,dParam);

			if (answeredStatus == eAswSucceed)
			{
				return TRUE;
			}
		}
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ANALYS_GET_PLATFORM_POS_ASW_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 解析获取平台坐标命令时，仍然采用MNPS，不再定义新命令
	std::vector<int> vnParam;
	std::vector<double> vdParam;
	vnParam.push_back(0);
	vdParam.push_back(dPlatformPos1X);
	vdParam.push_back(dPlatformPos1Y);
	vdParam.push_back(dPlatformPos2X);
	vdParam.push_back(dPlatformPos2Y);
	PackAndAddCommSimpleInfo(strSimpleInfo,m_XYDCommProtocol.m_MNPSParam.m_strCmd,vnParam,vdParam);

	return TRUE;
}

// 关联标定，输入两个MARK的平台坐标，与两个MARK的靶标坐标一起，计算靶标坐标系到平台坐标系转换关系
BOOL vcXYDVisionAlign::OnlineFCBRCalibrate(double dPlatformPos1X, double dPlatformPos1Y, double dPlatformPos2X, double dPlatformPos2Y)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	if ((NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool))
	{
		ReportCalibResultFCBR(FALSE);
		return FALSE;
	}

	if (m_pPlatformInfo->m_nCamNum != 2 || m_pPlatformInfo->m_nPositionNum != 2 || m_pPlatformInfo->m_bTargetObjectCamSeparate != FALSE || m_pPlatformInfo->m_bTargetCalibUseBoard != TRUE)
	{
		ReportCalibResultFCBR(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 =  _T("视觉参数配置错误");
		m_strStatusBarInfo2 =  _T("相机数要求等于2, 位置数要求等于2, 目标和对象要求不分离, 对象要求靶标标定");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 通信是否正常
	if (FALSE == m_bValidComm)
	{
		ReportCalibResultFCBR(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE; 
	}

	// 标定用定位工具是否正常 
	if (m_bValidCalibSearchTool!=TRUE)
	{
		ReportCalibResultFCBR(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CALIB_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_FAILED);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 相机是否处于连续采集状态
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	for(int i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			ReportCalibResultFCBR(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}    	
	}

	// 隐藏对象结果图形			
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	std::vector<int> vnObjectPosIndex;
	int nObjectPosIndex = 0;
	for(int i = 0; i < nPosNum; i++)
	{
		nObjectPosIndex = i;
		vnObjectPosIndex.push_back(nObjectPosIndex);
	}	
	// 	PostMessageUpdateGuiAlnObjectImagePosGraphics(vnObjectPosIndex, FALSE);
	// 	PostMessageUpdateShowGuiObjectImagePosToDisplay(vnObjectPosIndex, FALSE);

	m_cVisionAlignGui.SetPosGuiInvisible(vnObjectPosIndex, eObjectSearch);

	// 隐藏目标结果图形	
	std::vector<int> vnTargetPosIndex;
	int nTargetPosIndex = 0;
	for(int i = 0; i < nPosNum; i++)
	{
		nTargetPosIndex = i;
		vnTargetPosIndex.push_back(nTargetPosIndex);
	}	
	// 	PostMessageUpdateGuiAlnTargetImagePosGraphics(vnTargetPosIndex, FALSE);
	// 	PostMessageUpdateShowGuiTargetImagePosToDisplay(vnTargetPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnTargetPosIndex, eTargetSearch);



	// 无协议解析时，不能读取，也不需要读取，在指令中已经包含
	// 读写寄存器时，之前参数中轴位置均赋值为零，必须从轴位置寄存器开始的连续八个地址，重新读取四个平台坐标

	// 如果是读写寄存器
	if (m_XYDCommProtocol.IsPlcProtocolType())
	{
		// 重新获取四个平台坐标
		CommuciateGetPlatformPosFCBR(dPlatformPos1X, dPlatformPos1Y, dPlatformPos2X, dPlatformPos2Y);
	}

	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	Sleep(m_pVisionASMConfig->m_TotalCalibData.GetItemPtr(nCurProdcutIndex)->m_vpCalibrateParam[0]->m_nSearchDelayTime);

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;
	for(int i = 0; i < nPosNum; i++)
	{
		// 两个位置同时拍照
		vnPosIndex.push_back(i);
		vsmSearchMode.push_back(eCalibSearch);
	}

	// 采集
	if (!SnapSearchImage(vnPosIndex))
	{			
		ReportCalibResultFCBR(FALSE);				

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GRAB_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_CAMERA_CONNECTION_ERROR);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 定位
	for(int i = 0; i < nPosNum; i++)
	{
		m_vnCalibSearchStartPatIndex[i] = 0;
		m_vnCalibSearchEndPatIndex[i] = 0;
	}
	BOOL bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

	// 分析定位结果
	if (FALSE == bSearchSucceed)
	{			
		ReportCalibResultFCBR(FALSE);		

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 =  _T("关联标定失败");
		m_strStatusBarInfo2 =  _T("标定图像定位失败");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 获取定位结果
	double dImagePos1X = m_mpCalibMarkImagePos.GetMarkImagePos(0).GetPosX();
	double dImagePos1Y = m_mpCalibMarkImagePos.GetMarkImagePos(0).GetPosY();
	double dImagePos2X = m_mpCalibMarkImagePos.GetMarkImagePos(1).GetPosX();
	double dImagePos2Y = m_mpCalibMarkImagePos.GetMarkImagePos(1).GetPosY();

	// 记录定位结果
	if (m_pVisionASMConfig->m_DataRecord.m_bAlignerSearchPltfmInfo)
	{
		CString strTemp;
		CString strOut;

		strTemp.Format(_T("FCBR, platformPos: Pos1(X:%.3f, Y:%.3f), Pos2(X:%.3f, Y:%.3f)"), 
			dPlatformPos1X, dPlatformPos1Y, dPlatformPos2X, dPlatformPos2Y);
		strOut += strTemp;

		strTemp.Format(_T("FCBR, imagePos: Pos1(X:%.3f, Y:%.3f), Pos2(X:%.3f, Y:%.3f)"), 
			dImagePos1X, dImagePos1Y, dImagePos2X, dImagePos2Y);
		strOut += strTemp;

		VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
		VisionAlignLogRecord(m_strAlignProcessData, strOut);
	}	

	// 执行标定计算
	sc2Vector platformPos1 = sc2Vector(dPlatformPos1X, dPlatformPos1Y);
	sc2Vector platformPos2 = sc2Vector(dPlatformPos2X, dPlatformPos2Y);
	sc2Vector imagePos1 = sc2Vector(dImagePos1X, dImagePos1Y);
	sc2Vector imagePos2 = sc2Vector(dImagePos2X, dImagePos2Y);
	if (FALSE == m_pAlignerTool->ExecuteCalibrateFCBR(platformPos1, platformPos2, imagePos1, imagePos2))
	{
		ReportCalibResultFCBR(FALSE);		

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 =  _T("关联标定失败");
		m_strStatusBarInfo2 =  _T("标定计算失败");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}


	//////////////////////////////////////////////////////////////////////////
	// 保存标定结果到对位工具和配置文件

	// 获取系统标定后的所有信息
	std::vector<CCalibratedInfo*> vpAllCalibratedInfo;
	vpAllCalibratedInfo = GetAllCalibratedInfo();

	/// 设置标定后的信息到对位工具,为对位做准备，并保存到配置文件中
	SetCurCalibratedInfo(vpAllCalibratedInfo);	

	// 保存标定后信息到当前产品中及配置文件中
	SaveCalibratedInfoToCurProduct(vpAllCalibratedInfo);


	// 发送关联标定结果
	ReportCalibResultFCBR(TRUE);

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_SYS_CALIB_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

	return TRUE;
}

// 接收命令，进行相应的定位操作（定位、定位结果图形显示、状态显示，记录目标位置到对位工具），返回命令响应
BOOL vcXYDVisionAlign::OnlineACFInspectCandidateExFCHB(int nPosIndex, int nStartPatIndex)
{
	CString strCmd = _T("VCHB:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}	

	BOOL bACFInspect = FALSE;


	if (nStartPatIndex>99 && nStartPatIndex<131)
	{
		// 位置参数
		std::vector<int> vnPosIndex;
		if (nPosIndex>=0 && nPosIndex<=3)
		{
			vnPosIndex.push_back(nPosIndex);
		}
		else if (nPosIndex==4)
		{
			for (int i=0; i<GetPosNum(); i++)
			{
				vnPosIndex.push_back(i);
			}
		}
		else if (nPosIndex==11) // 所有相机中的前一半编号
		{
			for (int i=0; i<GetPosNum()/2; i++)
			{
				vnPosIndex.push_back(i);
			}
		}
		else if (nPosIndex==12) // 所有相机中的后一半编号
		{
			int nPosIndex = 0;
			int i = 0;
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i + GetPosNum()/2;
				vnPosIndex.push_back(nPosIndex);
			}

		}

		// 模板参数
		std::vector<int> vnPatIndex;
		vnPatIndex.resize(5, 0);
		int nPatIndex = nStartPatIndex - 99;
		int nMaskResult = 1;
		int nMask = 1;
		for (int i=0; i<5; i++)
		{
			nMaskResult = nMask<<i;
			if ( (nPatIndex & nMaskResult) == nMaskResult )
			{
				vnPatIndex.at(i) = 1;
			}
		}
		// nPatIndex只对1到31有效，十进制转换二进制，从低位1到高位5，对应标准0模板到候补1/2/3/4模板，哪位置1则哪个模板有效
		// 十进制数和模板组合对应关系，详见EXCEL查找表

		bACFInspect = OnSerialCameraACFInspectCandidateExFCHB(vnPosIndex, vnPatIndex);

	}
	else
	{
		if (nPosIndex>=0 && nPosIndex<=3)
		{
			bACFInspect = OnSingleCameraACFInspectCandidateExFCHB(nPosIndex, nStartPatIndex);
		}
		else if(nPosIndex==4)
		{
			bACFInspect = OnSerialCameraACFInspectCandidateExFCHB(nStartPatIndex);
		}
		else if (nPosIndex==11) // 所有相机中的前一半编号
		{
			std::vector<int> vnPosIndex;
			int nPosIndex = 0;
			int i = 0;
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
			}
			bACFInspect = OnSerialCameraACFInspectCandidateExFCHB(vnPosIndex, nStartPatIndex);

		}
		else if (nPosIndex==12) // 所有相机中的后一半编号
		{
			std::vector<int> vnPosIndex;
			int nPosIndex = 0;
			int i = 0;
			for(i = 0; i < GetPosNum()/2; i++)
			{
				nPosIndex = i + GetPosNum()/2;
				vnPosIndex.push_back(nPosIndex);
			}
			bACFInspect = OnSerialCameraACFInspectCandidateExFCHB(vnPosIndex, nStartPatIndex);
		}
	}




	return bACFInspect;

}

// 单相机ACF检测
BOOL vcXYDVisionAlign::OnSingleCameraACFInspectCandidateExFCHB(int nPosIndex, int nStartPatIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCHB:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		ReportACFInspectResultFCHB(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		ReportACFInspectResultFCHB(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE);//_T("ACF检测失败");;
		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	// 

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			ReportACFInspectResultFCHB(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	vnPosIndex.push_back(nPosIndex);		// 	
	vsmSearchMode.push_back(eInspectSearch);	// 


	// 检测模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bInspectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bInspectCandidate*/ && bInspectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eInspectSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_INSPECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}


	// 1. 通信获取当前平台各个轴的绝对位置



	// 2. 等待相机移动到不同位置，并定位


	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	Sleep(nDelayTime);

	//if (!m_bSearchWithInspect)
	//{
	//	// 隐藏目标定位结果十字，全部0/1/2/3图像
	//	PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, FALSE);
	//	// 隐藏目标定位结果文字，全部0/1/2/3图像
	//	//PostMessageUpdateShowGuiInspectImagePosToDisplay(vnPosIndex, FALSE);
	//}
	//else
	//	{
	//		ShowExtraGuiToDisplay(vnPosIndex,FALSE,3);
	//	}
	//	HideObjTarGuiResultInSpect(vnPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eInspectSearch);
	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportACFInspectResultFCHB(FALSE);//

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bInspectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
	BOOL bSearchSucceed = FALSE;
	if (bInspectSearchCandidate == FALSE)
	{
		m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
		m_vnInspectSearchEndPatIndex[nPosIndex] = nStartPatIndex;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (nStartPatIndex >= 0 && nStartPatIndex < INSPECTCANDIDATENUM)
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
		}
		else if (nStartPatIndex == 9)
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = m_vnInspectSearchSuccessPatIndex[nPosIndex];
		}
		else
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = 0;
		}			
		m_vnInspectSearchEndPatIndex[nPosIndex] = INSPECTCANDIDATENUM;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	// 设定、显示结果图形
	//	SetGuiAlnInspectImageMarkPos(vnPosIndex);
	//if (!m_bSearchWithInspect)
	//{
	//		PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, TRUE);
	//}
	//else
	{
		//		ShowExtraGuiToDisplay(vnPosIndex,TRUE,3);
	}

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eInspectSearch);





	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eInspectSearch);
		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
	}

	// SY
	//SetShowGuiInspectImageMarkPos(vnPosIndex);
	//PostMessageUpdateShowGuiInspectImagePosToDisplay(vnPosIndex, TRUE);

	if (FALSE == bSearchSucceed)
	{

		ReportACFInspectResultFCHB(FALSE);//

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;

	}

	// 4. 设置相机平台的绝对位置

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_SUCCESS);
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	ReportACFInspectResultFCHB(TRUE, m_vnInspectSearchSuccessPatIndex[nPosIndex]);
	return TRUE;

}

// 两个及两个以上相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraACFInspectCandidateExFCHB(int nStartPatIndex)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CString strCmd = _T("VCHB:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		ReportACFInspectResultFCHB(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		ReportACFInspectResultFCHB(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_OBJECT_SEARCH_FAILED);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportACFInspectResultFCHB(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_INSPECT_FAIL);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);

			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	

			
			return FALSE;
		}    	
	}


	// 3.开启定位
	scTimer stInspectSearchTimer; double dInspectSearchTime(0.0);
	stInspectSearchTimer.Reset();

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eInspectSearch);	// 
	}


	// 检测模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bInspectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
		//BOOL bInspectShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bInspectCandidate*/ && bInspectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
				vsmCameraExposureType.push_back(eInspectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_INSPECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}


	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	Sleep(nDelayTime);

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eInspectSearch);

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportACFInspectResultFCHB(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bInspectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
	BOOL bInspectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (bInspectSearchCandidate == FALSE)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = i;
			m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
			m_vnInspectSearchEndPatIndex[nPosIndex] = nStartPatIndex;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bInspectSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < INSPECTCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnInspectSearchSuccessPatIndex[0];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = INSPECTCANDIDATENUM-1;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{
				if (j > 0 && (FALSE == GetAlnInspectSearchCandidatePatEnable(j)))
				{
					continue;
				}

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = i;
					m_vnInspectSearchStartPatIndex[nPosIndex] = j;
					m_vnInspectSearchEndPatIndex[nPosIndex] = j;
				}			
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				if (bSearchSucceed)
				{
					break;
				}	
				//Sleep(100);
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				if (nStartPatIndex>=0 && nStartPatIndex < INSPECTCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnInspectSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = INSPECTCANDIDATENUM-1;

				m_vnInspectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnInspectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}

	}

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eInspectSearch);

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eInspectSearch);
		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
	}

	if (TRUE == bSearchSucceed)
	{
		// if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(TRUE);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_SUCCESS);
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stInspectSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{		
		ReportACFInspectResultFCHB(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;		

	}

	if (bInspectSearchSync)
	{
		ReportACFInspectResultFCHB(TRUE,m_vnInspectSearchSuccessPatIndex[0]);
	}
	else
	{
		ReportACFInspectResultFCHB(TRUE,-1);
	}

	return TRUE;
}

// 两个及两个以上相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraACFInspectCandidateExFCHB(std::vector<int> vnPosIndex, int nStartPatIndex)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CString strCmd = _T("VCHB:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		// 		ReportACFInspectResultFCHB(FALSE);
		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = _T("检测失败");
		// 		m_strStatusBarInfo2 = _T("检测工具无效");
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();


	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_INSPECT_FAIL);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportACFInspectResultFCHB(FALSE);
		return FALSE;
	}

	//	int i=0;
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_INSPECT_FAIL);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			ReportACFInspectResultFCHB(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();


	std::vector<SearchMode> vsmSearchMode;	
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		vsmSearchMode.push_back(eInspectSearch);
	}


	// 检测模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bInspectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
		//BOOL bInspectShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bInspectCandidate */&& bInspectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;	

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eInspectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_INSPECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}


	// 1. 通信获取当前平台各个轴的绝对位置

	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置

	// 3.开启定位
	scTimer stInspectSearchTimer; double dInspectSearchTime(0.0);
	stInspectSearchTimer.Reset();


	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	Sleep(nDelayTime);


	// 隐藏目标定位结果十字，全部0/1/2/3图像
	//if (!m_bSearchWithInspect)
	//{
	//	PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, FALSE);
	//}
	//else
	{
		//ShowExtraGuiToDisplay(vnPosIndex,FALSE,3);
	}

	HideObjTarGuiResultInSpect(vnPosIndex, FALSE);

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportACFInspectResultFCHB(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bInspectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
	BOOL bInspectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (bInspectSearchCandidate == FALSE)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
			m_vnInspectSearchEndPatIndex[nPosIndex] = nStartPatIndex;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bInspectSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < INSPECTCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnInspectSearchSuccessPatIndex[vnPosIndex[0]];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = INSPECTCANDIDATENUM-1;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{
				if (j > 0 && (FALSE == GetAlnInspectSearchCandidatePatEnable(j)))
				{
					continue;
				}

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					m_vnInspectSearchStartPatIndex[nPosIndex] = j;
					m_vnInspectSearchEndPatIndex[nPosIndex] = j;
				}			
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				if (bSearchSucceed)
				{
					break;
				}	
				//Sleep(100);
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				if (nStartPatIndex>=0 && nStartPatIndex < INSPECTCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnInspectSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = INSPECTCANDIDATENUM-1;

				m_vnInspectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnInspectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
	}


	// 设定、显示结果图形
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eInspectSearch);
	//SetGuiAlnInspectImageMarkPos(vnPosIndex);
	//if (!m_bSearchWithInspect)
	//{
	//	PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, TRUE);
	//}
	//else
	{
		//ShowExtraGuiToDisplay(vnPosIndex,TRUE,3);
	}

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eInspectSearch);
		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
	}
	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		if (!m_bSearchWithInspect)
		{
			m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_SUCCESS);
		}
		else
		{
			m_strStatusBarInfo1 = _T("距离检测成功");
		}
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{

		ReportACFInspectResultFCHB(FALSE);

		m_bStatusBar = FALSE;
		if (!m_bSearchWithInspect)
		{
			m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE);
		}
		else
		{
			m_strStatusBarInfo1 = _T("距离检测失败");
		}

		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	// 	// 4. 关闭定位
	// 	// CloseSearch();
	// 	CloseSearch(vCamIndex);


	// 5. 设置对位工具


	// 记录图像搜索数据

	//dInspectSearchTime = stInspectSearchTimer.GetTimeMilli(FALSE);

	if(1/*m_bObjectSearchTest*/)
	{
		if (bInspectSearchSync)
		{
			ReportACFInspectResultFCHB(TRUE,m_vnInspectSearchSuccessPatIndex[vnPosIndex[0]]);
		}
		else
		{
			ReportACFInspectResultFCHB(TRUE,-1);
		}

	}
	return TRUE;
}

// 两个及两个以上相机对位系统实时对象Mark定位
// BOOL vcXYDVisionAlign::OnSerialCameraACFInspectCandidateExFCHB(std::vector<int> vnPosIndex, std::vector<int> vnPatIndex)
// {
// 	// vnPatIndex表示模板组合，大小等于5，数组中从0到4分别代表标准0和候补1/2/3/4模板，哪位置1则哪个模板选中
// 	// 在处理多模板vnPatIndex时，与定位搜索时的候补策略不同（先从第一个开始搜索，当前失败后转下一个，成功后不再继续），本函数要求选中的所有模板都成功才算成功，只要有一个失败就算失败，相当于与操作
// 	// “是否候补搜索”和“指定候补模板是否选中”有效，如果不开启则无法对候补模板进行检测，但是标准0模板不受限制
// 	// “是否成对搜索”无效，与操作默认对选中位置的选中模板都要求检测成功
// 
// 	m_bStatusBar = TRUE;
// 	m_strStatusBarInfo1 = _T("");
// 	m_strStatusBarInfo2 = _T("");
// 	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 	CString strCmd = _T("VCHB:");
// 	GetCommCommandName(strCmd);
// 	CString strTempWarningType = _T("");
// 
// 	CPlatformOptionInfo optionInfo;
// 	GetPlatformOptionInfo(optionInfo);
// 	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
// 	{	
// 		ReportACFInspectResultFCHB(FALSE);
// 		return FALSE;
// 	}
// 
// 	if (vnPatIndex.size() != 5)
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		ReportACFInspectResultFCHB(FALSE);
// 
// 		return FALSE;
// 	}
// 
// 	int nPosIndex = 0;		
// 	int nPosNum = vnPosIndex.size();
// 
// 
// 	if (nPosNum<=0)
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
// 		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
// 		ReportACFInspectResultFCHB(FALSE);
// 
// 		return FALSE;
// 	}
// 
// 	for(int i=0; i<nPosNum; i++)
// 	{		 
// 		nPosIndex = vnPosIndex[i];
// 
// 		if (FALSE == IsPosCameraGrabbing(nPosIndex))
// 		{      
// 			m_bStatusBar = FALSE;
// 			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
// 			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
// 			CString strTemp = _T("");
// 			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
// 			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
// 			PostMessageUpdateStatusBarInfo();
// 
// 			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
// 			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
// 			ReportACFInspectResultFCHB(FALSE);
// 
// 			return FALSE;
// 		}    	
// 	}
// 
// 
// 	scTimer stInspectSearchTimer; double dInspectSearchTime(0.0);
// 	stInspectSearchTimer.Reset();
// 
// 	// 准备开始定位			
// 	std::vector<SearchMode> vsmSearchMode;
// 	for(int i = 0; i < nPosNum; i++)
// 	{
// 		vsmSearchMode.push_back(eInspectSearch);
// 	}
// 
// 
// 
// 	// 检测模板曝光切换
// 	{
// 		int nStartPatIndex = 0;
// 		for(int it=0;it<vnPatIndex.size();it++)
// 		{
// 			if(vnPatIndex.at(it)==1)
// 			{
// 				nStartPatIndex = it;
// 				break;
// 			}
// 		}
// 
// 		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
// 
// 		CameraParamEnable cameraParamEnable;
// 		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
// 		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);
// 
// 		if (SystempOptionSearchShutter /*&& bInspectCandidate*/ && bInspectShutter/* && (0 == nStartPatIndex)*/)
// 		{
// 			std::vector<CameraExposureType> vsmCameraExposureType;	
// 
// 			int i = 0;
// 			for(i = 0; i < nPosNum; i++)
// 			{
// 				vsmCameraExposureType.push_back(eInspectSearchCameraExposure);
// 			}
// 
// 			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
// 			{
// 				OnFailedCameraExposureSetting(strCmd);
// 			}
// 		}
// 	}
// 
// 
// 	// 等待搜索延时
// 	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
// 	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
// 	Sleep(nDelayTime);
// 
// 	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eInspectSearch);
// 
// 	// 采集搜索图像
// 	if (!SnapSearchImage(vnPosIndex))
// 	{
// 		ReportACFInspectResultFCHB(FALSE);
// 		OnFailedSnapSearchImage(strCmd);
// 
// 		return FALSE;
// 	}
// 
// 
// 	// 定位
// 	BOOL bInspectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
// 	BOOL bInspectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateSyncEnable();\
// 
// 	BOOL bSearchSucceed = TRUE;
// 	std::vector<BOOL> vbSearchSucceed;
// 	std::vector<int> vnSearchIndex;
// 
// 	if (bInspectSearchCandidate == FALSE)
// 	{
// 		// 如果模板参数选中中候补1/2/3/4模板，但是界面设置中没有选中，则认为检测失败
// 		for (int j=1; j<5; j++)
// 		{
// 			if (vnPatIndex.at(j) == 1)
// 			{
// 				bSearchSucceed = FALSE;
// 				break;
// 			}
// 		}
// 
// 		// 如果不启用候补模板，则只能检测标准0模板，直接跳过候补1/2/3/4模板
// 		if (vnPatIndex.at(0) == 1)
// 		{
// 			for (int i = 0; i<nPosNum; i++)
// 			{
// 				nPosIndex = vnPosIndex[i];
// 				m_vnInspectSearchStartPatIndex[nPosIndex] = 0;
// 				m_vnInspectSearchEndPatIndex[nPosIndex] = 0;
// 			}
// 
// 			BOOL bTmep = SearchMark(vnPosIndex, vsmSearchMode);
// 			vbSearchSucceed.push_back(bTmep);
// 			vnSearchIndex.push_back(0);
// 		}
// 	}
// 	else
// 	{
// 		for (int j=0; j<5; j++)
// 		{
// 			// 如果模板参数没有选中该模板，则跳过
// 			if (vnPatIndex.at(j) == 0)
// 			{
// 				continue;
// 			}
// 
// 			// 如果候补1/2/3/4模板在界面设置中没有被选中，则认为检测失败
// 			if (j > 0 && (FALSE == GetAlnInspectSearchCandidatePatEnable(j)))
// 			{
// 				bSearchSucceed = FALSE;
// 				break;
// 			}
// 
// 			for (int i = 0; i<nPosNum; i++)
// 			{
// 				nPosIndex = vnPosIndex[i];
// 				m_vnInspectSearchStartPatIndex[nPosIndex] = j;
// 				m_vnInspectSearchEndPatIndex[nPosIndex] = j;
// 			}
// 
// 			BOOL bTmep = SearchMark(vnPosIndex, vsmSearchMode);
// 			vbSearchSucceed.push_back(bTmep);
// 			vnSearchIndex.push_back(j);
// 		}
// 	}
// 
// 
// 	std::vector<double> vdDistance;
// 	std::vector<BOOL> vbAreaInspectSubResult;
// 
// 	std::vector<CSearchResult> vResultPatternPosLineDistanceTool;
// 	std::vector<int> vnPosIndexPatternPosLineDistanceTool;
// 
// 	std::vector<CSearchResult> vResultAreaInspectTool;
// 	std::vector<int> vnPosIndexAreaInspectTool;
// 
// 	std::vector<CSearchResult> vResultAreaInspectToolEx;
// 	std::vector<int> vnPosIndexAreaInspectToolEx;
// 
// 	std::vector<CSearchResult> vResultCornerSearchCheckInspectToolEx;
// 	std::vector<int> vnPosIndexCornerSearchCheckInspectToolEx;
// 	std::vector<CString> vsResultLabelCornerSearchCheckInspectToolEx[2];
// 
// 
// 	std::vector<CSearchResult> vResultACFInspectTool;
// 	std::vector<int> vnPosIndexACFInspectTool;
// 
// 	// FALSE包含两种情况：1）候补功能未启用、但是指令参数选中候补模板，2）候补功能打开、指令参数选中候补模板、但是界面上候补模板未选中
// 	if (TRUE == bSearchSucceed)
// 	{
// 		// 等于0包含两种情况：1）候补功能未启用、并且指令参数没有选中标准0模板，2）候补功能打开、界面上候补模板选中、但是参数一个都没有选中
// 		if (vbSearchSucceed.size() == 0)
// 		{
// 			bSearchSucceed = FALSE;
// 		}
// 		else
// 		{
// 			// 对所有参与检测的模板进行遍历
// 			for (int j=0; j<vbSearchSucceed.size(); j++)
// 			{
// 				// 将当前检测结果与总结果进行与操作
// 				bSearchSucceed &= vbSearchSucceed.at(j);
// 
// 				// 获取当前检测结果对应模板索引
// 				int nPatIndex = vnSearchIndex.at(j);
// 
// 				// 遍历所有位置
// 				for (int i = 0; i<nPosNum; i++)
// 				{
// 					// 获取当前位置
// 					nPosIndex = vnPosIndex[i];
// 
// 					// 获取指定位置、指定候补模板的定位工具
// 					CBaseSearchTool* pSearchTool = GetRepoAlnInspectSearchTool(nCurProdcutIndex, nPosIndex, nPatIndex);
// 
// 					if (pSearchTool != NULL)
// 					{
// 						CSearchToolType eType = pSearchTool->GetSearchToolType();
// 						switch (eType)
// 						{
// 						case ePatternPosLineDistanceTool:
// 							{
// 								CSearchResult result;
// 								pSearchTool->GetResult(0, result);
// 								vResultPatternPosLineDistanceTool.push_back(result);
// 								vnPosIndexPatternPosLineDistanceTool.push_back(nPosIndex);
// 
// 								// 多模板的多位置的距离结果发送PLC时，先发送第一个模板的第一个位置的所有距离，把第一个模板的所有位置发送完后，再发送第二个模板的所有位置，以此类推
// 
// 								if (result.m_resultPosLineDistanceTool.m_nResult0 == 0)
// 								{
// 									// 等于0：如果找线工具0失败，也将数值0传出
// 									vdDistance.push_back(0.0);
// 								}
// 								else
// 								{
// 									// 不等于0：如果找线工具0成功，无论检测结果成功或失败，均将实际结果传出
// 									vdDistance.push_back(result.m_resultPosLineDistanceTool.m_dDistanceMM0);
// 								}
// 
// 								if (result.m_resultPosLineDistanceTool.m_nResult1 == 0)
// 								{
// 									// 等于0：如果找线工具1失败，也将数值0传出
// 									vdDistance.push_back(0.0);
// 								}
// 								else
// 								{
// 									// 不等于0：如果找线工具1成功，无论检测结果成功或失败，均将实际结果传出
// 									vdDistance.push_back(result.m_resultPosLineDistanceTool.m_dDistanceMM1);
// 								}
// 							}
// 							break;
// 						case eAreaInspectTool:
// 							{
// 								CSearchResult result;
// 								pSearchTool->GetResult(0, result);
// 								vResultAreaInspectTool.push_back(result);
// 								vnPosIndexAreaInspectTool.push_back(nPosIndex);
// 							}
// 							break;
// 						case eAreaInspectToolEx:
// 							{
// 								CSearchResult result;
// 								pSearchTool->GetResult(0, result);
// 								vResultAreaInspectToolEx.push_back(result);
// 								vnPosIndexAreaInspectToolEx.push_back(nPosIndex);
// 
// 								// 多模板的多位置的子检测结果发送PLC时，先发送第一个模板的第一个位置的所有子结果，把第一个模板的所有位置发送完后，再发送第二个模板的所有位置，以此类推
// 
// 								for (int n=0; n<result.m_resultAreaInspectToolEx.m_nValidResultNum; n++)
// 								{
// 									BOOL bTemp = result.m_resultAreaInspectToolEx.m_vnResult.at(n) == 1;
// 									vbAreaInspectSubResult.push_back(bTemp);
// 								}
// 							}
// 							break;
// 						case eCornerSearchCheckInspectTool:
// 							{
// 								CSearchResult result;
// 								pSearchTool->GetResult(0, result);
// 								CBaseSearchDataParam *m_pSearchDataParam =new CCornerCheckSearchSearchDataParam;
// 								pSearchTool->GetSearchDataParam(m_pSearchDataParam);
// 								vResultCornerSearchCheckInspectToolEx.push_back(result);
// 								vnPosIndexCornerSearchCheckInspectToolEx.push_back(nPosIndex);
// 								vsResultLabelCornerSearchCheckInspectToolEx[0].push_back(((CCornerCheckSearchSearchDataParam*)(m_pSearchDataParam))->m_strInspectDistanceValueLabel[0]);
// 								vsResultLabelCornerSearchCheckInspectToolEx[1].push_back(((CCornerCheckSearchSearchDataParam*)(m_pSearchDataParam))->m_strInspectDistanceValueLabel[1]);
// 								if (m_pSearchDataParam != NULL)
// 								{
// 									delete m_pSearchDataParam;
// 									m_pSearchDataParam = NULL;
// 								}
// 							}
// 							break;
// 						case eACFInspectTool:
// 							{
// 								CSearchResult result;
// 								pSearchTool->GetResult(0, result);
// 								vResultACFInspectTool.push_back(result);
// 								vnPosIndexACFInspectTool.push_back(nPosIndex);
// 							}
// 							break;
// 						default:
// 							break;
// 						}
// 					}
// 				}
// 			}
// 		}
// 	} 
// 
// 	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, vnSearchIndex, eInspectSearch);
// 
// 
// 
// 	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
// 	{
// 		//PostMessageSaveVDBFile(vnPosIndex,eInspectSearch);
// 		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
// 	}
// 
// 	// 使用ACF检测工具、ACF检测工具EX和区域点线工具时，要求平台选项界面必须不启用线距检测，否则在检测成功和平台选项界面启用发送线距结果时，会因为获取距离结果错误造成软件崩溃
// 	// 只有使用角定位检查测量工具时，才能在平台选项界面启用线距检测和发送线距结果
// 
// 	// 使用区域点线工具测量点距时，无论检测结果整体成功/失败，均将距离发送到PLC备用轴位置寄存器(距离1/2/3/.../n)，无协议也发送
// 	// 使用ACF检测工具EX时，如果平台选项界面启用发送子结果，则无论检测结果整体成功/失败，均将子结果发送到PLC备用寄存器（数量+子结果1/2/3/.../n），无协议不发送
// 	// 使用角定位检查测量工具测量线距时，要求平台选项界面必须启用线距检测，在同时满足检测成功和平台选项界面启用发送线距结果时，才将距离发送到PLC备用轴位置寄存器(距离1/2/12结果/距离3/4/34结果)，无协议不发送
// 
// 
// 	if (TRUE == bSearchSucceed)
// 	{
// 		/*ReportACFInspectResultFCHB(TRUE,-1);*/
// 		if (!m_bSearchWithInspect)
// 		{
// 			ReportACFInspectResultFCHBD(TRUE,-1, vdDistance, vbAreaInspectSubResult);
// 		}
// 		else
// 		{
// 			ReportACFInspectResultFCHB(TRUE,-1);
// 		}
// 
// 
// 		m_bStatusBar = TRUE;
// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_SUCCESS);
// 		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stInspectSearchTimer.GetTimeMilli(TRUE));
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 	}
// 	else
// 	{
// 
// 		/*ReportACFInspectResultFCHB(FALSE);*/
// 		if (!m_bSearchWithInspect)
// 		{
// 			ReportACFInspectResultFCHBD(FALSE,-1, vdDistance, vbAreaInspectSubResult);
// 		}
// 		else
// 		{
// 			ReportACFInspectResultFCHB(FALSE);
// 		}
// 
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE);
// 		m_strStatusBarInfo2 = _T("");
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
// 		PostMessageUpdateStatusBarInfo();
// 		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
// 		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
// 		return FALSE;
// 	}
// 
// 	return TRUE;
// }

BOOL vcXYDVisionAlign::OnSerialCameraACFInspectCandidateExFCHB(std::vector<int> vnPosIndex, std::vector<int> vnPatIndex)
{
	// vnPatIndex表示模板组合，大小等于5，数组中从0到4分别代表标准0和候补1/2/3/4模板，哪位置1则哪个模板选中
	// 在处理多模板vnPatIndex时，与定位搜索时的候补策略不同（先从第一个开始搜索，当前失败后转下一个，成功后不再继续），本函数要求选中的所有模板都成功才算成功，只要有一个失败就算失败，相当于与操作
	// “是否候补搜索”和“指定候补模板是否选中”有效，如果不开启则无法对候补模板进行检测，但是标准0模板不受限制
	// “是否成对搜索”无效，与操作默认对选中位置的选中模板都要求检测成功

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	CString strCmd = _T("VCHB:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		ReportACFInspectResultFCHB(FALSE);
		return FALSE;
	}

	if (vnPatIndex.size() != 5)
	{
		m_bStatusBar = FALSE;
		//		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
		m_strStatusBarInfo1 = _T("检测失败");
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportACFInspectResultFCHB(FALSE);

		return FALSE;
	}

	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();


	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		//		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
		m_strStatusBarInfo1 = _T("检测失败");
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_POSNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportACFInspectResultFCHB(FALSE);

		return FALSE;
	}

	for(int i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];

		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			//			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
			m_strStatusBarInfo1 = _T("检测失败");
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			ReportACFInspectResultFCHB(FALSE);

			return FALSE;
		}    	
	}


	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFAAL(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}

	CString strProductID = _T("");
	if ( (pCurProductData->m_pAlignerParam->GetBendInfo().m_bBendingProductID) || m_XYDCommProtocol.GetIsEnableIDRead())
	{
		if (!CommunicateGetAlignProcessProductID(strProductID))
		{
			ReportAlignResultFAAL(FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("产品ID读取失败");
			m_strStatusBarInfo2 = _T("检测失败");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

			return FALSE;
		}
	}
	m_BendInspectResultInfo.m_strProductID = strProductID;
	m_strProductID = strProductID;


	// 检测模板曝光切换
	{
		int nStartPatIndex = 0;
		for(int it=0;it<vnPatIndex.size();it++)
		{
			if(vnPatIndex.at(it)==1)
			{
				nStartPatIndex = it;
				break;
			}
		}

		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;

		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		if (SystempOptionSearchShutter /*&& bInspectCandidate*/ && bInspectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;	

			int i = 0;
			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eInspectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}



	scTimer stInspectSearchTimer; double dInspectSearchTime(0.0);
	stInspectSearchTimer.Reset();

	// 准备开始定位			
	std::vector<SearchMode> vsmSearchMode;
	for(int i = 0; i < nPosNum; i++)
	{
		vsmSearchMode.push_back(eInspectSearch);
	}


	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	Sleep(nDelayTime);

	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eInspectSearch);

	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportACFInspectResultFCHB(FALSE);
		OnFailedSnapSearchImage(strCmd);

		return FALSE;
	}


	// 定位
	BOOL bInspectSearchCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
	BOOL bInspectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateSyncEnable();

	BOOL bSearchSucceed = TRUE;
	std::vector<BOOL> vbSearchSucceed;
	std::vector<int> vnSearchIndex;

	if (bInspectSearchCandidate == FALSE)
	{
		// 如果模板参数选中中候补1/2/3/4模板，但是界面设置中没有选中，则认为检测失败
		for (int j=1; j<5; j++)
		{
			if (vnPatIndex.at(j) == 1)
			{
				bSearchSucceed = FALSE;
				break;
			}
		}

		// 如果不启用候补模板，则只能检测标准0模板，直接跳过候补1/2/3/4模板
		if (vnPatIndex.at(0) == 1)
		{
			for (int i = 0; i<nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnInspectSearchStartPatIndex[nPosIndex] = 0;
				m_vnInspectSearchEndPatIndex[nPosIndex] = 0;
			}

			BOOL bTmep = SearchMark(vnPosIndex, vsmSearchMode);
			vbSearchSucceed.push_back(bTmep);
			vnSearchIndex.push_back(0);
		}
	}
	else
	{
		for (int j=0; j<5; j++)
		{
			// 如果模板参数没有选中该模板，则跳过
			if (vnPatIndex.at(j) == 0)
			{
				continue;
			}

			// 如果候补1/2/3/4模板在界面设置中没有被选中，则认为检测失败
			if (j > 0 && (FALSE == GetAlnInspectSearchCandidatePatEnable(j)))
			{
				bSearchSucceed = FALSE;
				break;
			}

			for (int i = 0; i<nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				m_vnInspectSearchStartPatIndex[nPosIndex] = j;
				m_vnInspectSearchEndPatIndex[nPosIndex] = j;
			}

			BOOL bTmep = SearchMark(vnPosIndex, vsmSearchMode);
			vbSearchSucceed.push_back(bTmep);
			vnSearchIndex.push_back(j);
		}
	}


	std::vector<double> vdDistance;
	std::vector<BOOL> vbAreaInspectSubResult;

	std::vector<double> vdCircleRadius;


	std::vector<BOOL> vbBendTwoModelSearchTool;
	std::vector<BOOL> vbBendCircleSearchTool;

	// FALSE包含两种情况：1）候补功能未启用、但是指令参数选中候补模板，2）候补功能打开、指令参数选中候补模板、但是界面上候补模板未选中
	if (TRUE == bSearchSucceed)
	{
		// 等于0包含两种情况：1）候补功能未启用、并且指令参数没有选中标准0模板，2）候补功能打开、界面上候补模板选中、但是参数一个都没有选中
		if (vbSearchSucceed.size() == 0)
		{
			bSearchSucceed = FALSE;
		}
		else
		{
			// 对所有参与检测的模板进行遍历
			for (int j=0; j<vbSearchSucceed.size(); j++)
			{
				// 将当前检测结果与总结果进行与操作
				bSearchSucceed &= vbSearchSucceed.at(j);

				// 获取当前检测结果对应模板索引
				int nPatIndex = vnSearchIndex.at(j);

				// 遍历所有位置
				for (int i = 0; i<nPosNum; i++)
				{
					// 获取当前位置
					nPosIndex = vnPosIndex[i];

					// 获取指定位置、指定候补模板的定位工具
					CBaseSearchTool* pSearchTool = GetRepoAlnInspectSearchTool(nCurProdcutIndex, nPosIndex, nPatIndex);

					if (pSearchTool != NULL)
					{
						CSearchToolType eType = pSearchTool->GetSearchToolType();
						switch (eType)
						{
						case ePatternPosLineDistanceTool:
							{
								CSearchResult result;
								pSearchTool->GetResult(0, result);

								// 多模板的多位置的距离结果发送PLC时，先发送第一个模板的第一个位置的所有距离，把第一个模板的所有位置发送完后，再发送第二个模板的所有位置，以此类推
								if (result.m_resultPosLineDistanceTool.m_nResult0 == 0)
								{
									// 等于0：如果找线工具0失败，也将数值0传出
									vdDistance.push_back(0.0);
								}
								else
								{
									// 不等于0：如果找线工具0成功，无论检测结果成功或失败，均将实际结果传出
									vdDistance.push_back(result.m_resultPosLineDistanceTool.m_dDistanceMM0);
								}

								if (result.m_resultPosLineDistanceTool.m_nResult1 == 0)
								{
									// 等于0：如果找线工具1失败，也将数值0传出
									vdDistance.push_back(0.0);
								}
								else
								{
									// 不等于0：如果找线工具1成功，无论检测结果成功或失败，均将实际结果传出
									vdDistance.push_back(result.m_resultPosLineDistanceTool.m_dDistanceMM1);
								}
							}
							break;
						case eAreaInspectTool:
							{
								CSearchResult result;
								pSearchTool->GetResult(0, result);
							}
							break;
						case eAreaInspectToolEx:
							{
								CSearchResult result;
								pSearchTool->GetResult(0, result);

								// 多模板的多位置的子检测结果发送PLC时，先发送第一个模板的第一个位置的所有子结果，把第一个模板的所有位置发送完后，再发送第二个模板的所有位置，以此类推
								for (int n=0; n<result.m_resultAreaInspectToolEx.m_nValidResultNum; n++)
								{
									BOOL bTemp = result.m_resultAreaInspectToolEx.m_vnResult.at(n) == 1;
									vbAreaInspectSubResult.push_back(bTemp);
								}
							}
							break;

						case eCornerSearchCheckInspectTool:
							{
								// 								CSearchResult result;
								// 								pSearchTool->GetResult(0, result);
							}
							break;

						case eACFInspectTool:
							{
								// 								CSearchResult result;
								// 								pSearchTool->GetResult(0, result);
							}
							break;

							// 两几何定位工具
						case eTwoQuickModelSearchTool:
						case eTwoPatModelSearchTool:
							{
								vbBendTwoModelSearchTool.push_back(TRUE);

								CSearchResult result;
								pSearchTool->GetResult(0, result);

								m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, CCoordPos(result.m_vdAuxiliaryPosX.at(0), result.m_vdAuxiliaryPosY.at(0), 0));
								m_mpObjectMarkImagePos.SetMarkImagePos(nPosIndex, TRUE, CCoordPos(result.m_vdAuxiliaryPosX.at(1), result.m_vdAuxiliaryPosY.at(1), 0));

								CPlatformXYDAxisPos* pPlatformAxisPos = new CPlatformXYDAxisPos;
								SetObjectPlatformPos(pPlatformAxisPos,nPosIndex);
								SetTargetPlatformPos(pPlatformAxisPos,nPosIndex);

								if (pPlatformAxisPos)
								{
									delete pPlatformAxisPos;
									pPlatformAxisPos = NULL;
								}

							}
							break;

						case eCircleSearchTool:
						case ePatternCircleSearchTool:
							{
								vbBendCircleSearchTool.push_back(TRUE);
								CSearchResult result;
								pSearchTool->GetResult(0, result);

								double dCircleRadius = result.m_resultCircleSearchTool.m_dRadius;
								vdCircleRadius.push_back(dCircleRadius);
							}
							break;

						default:
							break;
						}
					}
				}
			}
		}
	} 


	CString strBendInsError = _T("");
	BOOL bBendInspect = FALSE;

	if (TRUE == pCurProductData->m_pAlignerParam->GetBendInfo().m_bBendingInspect)
	{
		// 手动弹窗功能，只针对折弯检测使用的工具，其它定位工具不支持
		if (FALSE == bSearchSucceed)
		{
			if (optionInfo.m_bManualAfObjSearchFail && (2 == vbBendTwoModelSearchTool.size()))
			{
				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉弹出手动搜索框
					SetPlcManualSearch(TRUE);
				}

				if (FALSE ==ExcuteManualSearch(2,vnPosIndex))
				{
					if (optionInfo.m_bSetVisionManualSearchToPLC)
					{
						// 通知PLC，视觉关闭手动搜索框
						SetPlcManualSearch(FALSE);
					}
				}
				else
				{
					bSearchSucceed = TRUE;
				}

				if (optionInfo.m_bSetVisionManualSearchToPLC)
				{
					// 通知PLC，视觉关闭手动搜索框
					SetPlcManualSearch(FALSE);
				}

				if (TRUE == bSearchSucceed)
				{
					if ( 2 == vbBendTwoModelSearchTool.size())
					{
						SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
						SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

						m_pAlignerTool->SetBendAlignProcess(FALSE);
						bBendInspect = BendingAlignProcessInfo(strBendInsError);
						m_pAlignerTool->SetBendAlignProcess(TRUE);

						bSearchSucceed = bBendInspect;
						PostMessageUpdateBendingProcessInfo();

						VisionInspectBendRecord(FALSE, TRUE, FALSE);

					}

					if ( 2 == vbBendCircleSearchTool.size() )
					{
						bBendInspect = BendingCircleProcessInfo(strBendInsError, vdCircleRadius);
						bSearchSucceed = bBendInspect;
						PostMessageUpdateBendingCircleInfo();

						VisionInspectBendRecord(FALSE, FALSE, TRUE);
					}

//					m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, vnSearchIndex, eInspectSearch);

					if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
					{
						ExeSaveVDBFile(vnPosIndex,eInspectSearch);
					}

					if (!m_bSearchWithInspect)
					{
						ReportACFInspectResultFCHBD(TRUE,-1, vdDistance, vbAreaInspectSubResult);
					}
					else
					{
						ReportACFInspectResultFCHB(TRUE,-1);
					}

					m_bStatusBar = TRUE;
					m_strStatusBarInfo1 = _T("检测成功");
					m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stInspectSearchTimer.GetTimeMilli(TRUE));
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return TRUE;

				}
				else
				{
					if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
					{
						ExeSaveVDBFile(vnPosIndex,eInspectSearch);
					}

					if (!m_bSearchWithInspect)
					{
						ReportACFInspectResultFCHBD(FALSE,-1, vdDistance, vbAreaInspectSubResult);
					}
					else
					{
						ReportACFInspectResultFCHB(FALSE);
					}

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = _T("检测失败");
					m_strStatusBarInfo2 = strBendInsError;
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
					PostMessageUpdateStatusBarInfo();

					strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
					AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

					return FALSE;
				}

			}
		}


		if (TRUE == bSearchSucceed)
		{
			if ( 2 == vbBendTwoModelSearchTool.size())
			{
				SetObjectMarkSearchResults(m_mpObjectMarkImagePos);
				SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

				m_pAlignerTool->SetBendAlignProcess(FALSE);
				bBendInspect = BendingAlignProcessInfo(strBendInsError);
				m_pAlignerTool->SetBendAlignProcess(TRUE);

				bSearchSucceed = bBendInspect;
				PostMessageUpdateBendingProcessInfo();

				VisionInspectBendRecord(FALSE, TRUE, FALSE);

			}

			if ( 2 == vbBendCircleSearchTool.size() )
			{
				bBendInspect = BendingCircleProcessInfo(strBendInsError, vdCircleRadius);
				bSearchSucceed = bBendInspect;
				PostMessageUpdateBendingCircleInfo();

				VisionInspectBendRecord(FALSE, FALSE, TRUE);
			}

			m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, vnSearchIndex, eInspectSearch);

			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
			{
				ExeSaveVDBFile(vnPosIndex,eInspectSearch);
			}

			if (!m_bSearchWithInspect)
			{
				ReportACFInspectResultFCHBD(TRUE,-1, vdDistance, vbAreaInspectSubResult);
			}
			else
			{
				ReportACFInspectResultFCHB(TRUE,-1);
			}




			m_bStatusBar = TRUE;
			m_strStatusBarInfo1 = _T("检测成功");
			m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stInspectSearchTimer.GetTimeMilli(TRUE));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return TRUE;

		}
		else
		{
			if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
			{
				ExeSaveVDBFile(vnPosIndex,eInspectSearch);
			}

			if (!m_bSearchWithInspect)
			{
				ReportACFInspectResultFCHBD(FALSE,-1, vdDistance, vbAreaInspectSubResult);
			}
			else
			{
				ReportACFInspectResultFCHB(FALSE);
			}

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = _T("检测失败");
			m_strStatusBarInfo2 = strBendInsError;
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();

			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

			return FALSE;
		}

	}

	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, vnSearchIndex, eInspectSearch);

	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
	}

	// 使用ACF检测工具、ACF检测工具EX和区域点线工具时，要求平台选项界面必须不启用线距检测，否则在检测成功和平台选项界面启用发送线距结果时，会因为获取距离结果错误造成软件崩溃
	// 只有使用角定位检查测量工具时，才能在平台选项界面启用线距检测和发送线距结果

	// 使用区域点线工具测量点距时，无论检测结果整体成功/失败，均将距离发送到PLC备用轴位置寄存器(距离1/2/3/.../n)，无协议也发送
	// 使用ACF检测工具EX时，如果平台选项界面启用发送子结果，则无论检测结果整体成功/失败，均将子结果发送到PLC备用寄存器（数量+子结果1/2/3/.../n），无协议不发送
	// 使用角定位检查测量工具测量线距时，要求平台选项界面必须启用线距检测，在同时满足检测成功和平台选项界面启用发送线距结果时，才将距离发送到PLC备用轴位置寄存器(距离1/2/12结果/距离3/4/34结果)，无协议不发送


	if (TRUE == bSearchSucceed)
	{
		if (!m_bSearchWithInspect)
		{
			ReportACFInspectResultFCHBD(TRUE,-1, vdDistance, vbAreaInspectSubResult);
		}
		else
		{
			ReportACFInspectResultFCHB(TRUE,-1);
		}

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = _T("检测成功");
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SEARCH_TIME_COST), stInspectSearchTimer.GetTimeMilli(TRUE));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		if (!m_bSearchWithInspect)
		{
			ReportACFInspectResultFCHBD(FALSE,-1, vdDistance, vbAreaInspectSubResult);
		}
		else
		{
			ReportACFInspectResultFCHB(FALSE);
		}

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = _T("检测失败");
		m_strStatusBarInfo2 = strBendInsError;
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();

		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));

		return FALSE;
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineACFInspectCandidateExFCHC(int nPosIndex, int nStartPatIndex, int nEndPatIndex)
{
	CString strCmd = _T("VCHC:");
	GetCommCommandName(strCmd);
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}	

	BOOL bACFInspect = FALSE;
	if (nPosIndex>=0 && nPosIndex<=3)
	{
		bACFInspect = OnSingleCameraACFInspectCandidateExFCHC(nPosIndex, nStartPatIndex, nEndPatIndex);
	}
	else if(nPosIndex==4)
	{
		bACFInspect = OnSerialCameraACFInspectCandidateExFCHC(nStartPatIndex, nEndPatIndex);
	}
	else if (nPosIndex==11) // 所有相机中的前一半编号
	{
		std::vector<int> vnPosIndex;
		int nPosIndex = 0;
		int i = 0;
		for(i = 0; i < GetPosNum()/2; i++)
		{
			nPosIndex = i;
			vnPosIndex.push_back(nPosIndex);
		}
		bACFInspect = OnSerialCameraACFInspectCandidateExFCHC(vnPosIndex, nStartPatIndex, nEndPatIndex);

	}

	return bACFInspect;

}

// 单相机ACF检测
BOOL vcXYDVisionAlign::OnSingleCameraACFInspectCandidateExFCHC(int nPosIndex, int nStartPatIndex, int nEndIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCHC:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		ReportACFInspectResultFCHC(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{

		ReportACFInspectResultFCHC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE);//_T("ACF检测失败");;
		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	// 

	int i=0; 
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_ACF_INSPECT_FAILE);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			ReportACFInspectResultFCHC(FALSE);
			return FALSE;
		}    	
	}


	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	
	vnPosIndex.push_back(nPosIndex);		// 	
	vsmSearchMode.push_back(eInspectSearch);	// 


	// 检测模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bInspectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
		//BOOL bInspectShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bInspectCandidate*/ && bInspectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			vnPosIndex.push_back(nPosIndex);
			vsmCameraExposureType.push_back(eInspectSearchCameraExposure);

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_INSPECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}


	// 1. 通信获取当前平台各个轴的绝对位置

	// 2. 等待相机移动到不同位置，并定位


	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	Sleep(nDelayTime);



	// 隐藏目标定位结果十字，全部0/1/2/3图像
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eInspectSearch);
	//PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, FALSE);

	//ShowExtraGuiToDisplay(vnPosIndex,FALSE,3);

	//HideObjTarGuiResultInSpect(vnPosIndex, FALSE);

	// 隐藏目标定位结果文字，全部0/1/2/3图像
	//PostMessageUpdateShowGuiInspectImagePosToDisplay(vnPosIndex, FALSE);


	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportACFInspectResultFCHC(FALSE);//

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bSearchSucceed = FALSE;
	if (nStartPatIndex >= nEndIndex)
	{
		m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
		m_vnInspectSearchEndPatIndex[nPosIndex] = nStartPatIndex;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (nStartPatIndex >= 0 && nStartPatIndex < INSPECTCANDIDATENUM)
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
		}
		else if (nStartPatIndex == 9)
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = m_vnInspectSearchSuccessPatIndex[nPosIndex];
		}
		else
		{
			m_vnInspectSearchStartPatIndex[nPosIndex] = 0;
		}			
		m_vnInspectSearchEndPatIndex[nPosIndex] = nEndIndex;
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}

	// 设定、显示结果图形
	//SetGuiAlnInspectImageMarkPos(vnPosIndex);
	//PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, bSearchSucceed);
	//ShowExtraGuiToDisplay(vnPosIndex,TRUE,3);
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eInspectSearch);
	// SY
	//SetShowGuiInspectImageMarkPos(vnPosIndex);
	//PostMessageUpdateShowGuiInspectImagePosToDisplay(vnPosIndex, TRUE);
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eInspectSearch);
		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
	}
	if (FALSE == bSearchSucceed)
	{

		ReportACFInspectResultFCHC(FALSE);//

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1.Format(m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE));
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;

	}

	// 4. 设置相机平台的绝对位置

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_SUCCESS);
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	ReportACFInspectResultFCHC(TRUE, m_vnInspectSearchSuccessPatIndex[nPosIndex]);
	return TRUE;

}

// 两个及两个以上相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraACFInspectCandidateExFCHC(int nStartPatIndex, int nEndIndex)
{
	CString strCmd = _T("VCHC:");
	CString strTempWarningType = _T("");
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	GetCommCommandName(strCmd);
	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		ReportACFInspectResultFCHC(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	int nCamNum = m_pPlatformInfo->m_nCamNum;

	if (nCamNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_INSPECT_FAIL);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportACFInspectResultFCHC(FALSE);
		return FALSE;
	}

	int i=0;
	for(i=0; i<nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_INSPECT_FAIL);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			ReportACFInspectResultFCHC(FALSE);
			return FALSE;
		}    	
	}


	// 1. 通信获取当前平台各个轴的绝对位置	

	CString str;

	// 2. 通信获取当前所有相机平台各个轴的绝对位置

	// 3.开启定位
	scTimer stInspectSearchTimer; double dInspectSearchTime(0.0);
	stInspectSearchTimer.Reset();

	// 准备开始定位			
	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = i;
		vnPosIndex.push_back(nPosIndex);		// 	
		vsmSearchMode.push_back(eInspectSearch);	// 
	}


	// 检测模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bInspectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
		//BOOL bInspectShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bInspectCandidate*/ && bInspectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<int> vnPosIndex;
			std::vector<CameraExposureType> vsmCameraExposureType;	
			int nPosIndex = 0;

			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				vnPosIndex.push_back(nPosIndex);
				vsmCameraExposureType.push_back(eInspectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_INSPECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}


	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	Sleep(nDelayTime);



	// 隐藏目标定位结果十字，全部0/1/2/3图像
	//PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, FALSE);
	//ShowExtraGuiToDisplay(vnPosIndex,FALSE,3);
	// 隐藏目标定位结果文字，全部0/1/2/3图像
	//PostMessageUpdateShowGuiInspectImagePosToDisplay(vnPosIndex, FALSE);
	//HideObjTarGuiResultInSpect(vnPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eInspectSearch);
	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportACFInspectResultFCHC(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bInspectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (nStartPatIndex >= nEndIndex)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = i;
			m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
			m_vnInspectSearchEndPatIndex[nPosIndex] = nStartPatIndex;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bInspectSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < INSPECTCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnInspectSearchSuccessPatIndex[0];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = nEndIndex;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = i;
					m_vnInspectSearchStartPatIndex[nPosIndex] = j;
					m_vnInspectSearchEndPatIndex[nPosIndex] = j;
				}			
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				if (bSearchSucceed)
				{
					break;
				}	
				//Sleep(100);
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = i;
				if (nStartPatIndex>=0 && nStartPatIndex < INSPECTCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnInspectSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = nEndIndex;

				m_vnInspectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnInspectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}

	}

	// 设定、显示结果图形
	//SetGuiAlnInspectImageMarkPos(vnPosIndex);
	//PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, bSearchSucceed);
	//ShowExtraGuiToDisplay(vnPosIndex,TRUE,3);
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eInspectSearch);
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eInspectSearch);
		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
	}
	if (TRUE == bSearchSucceed)
	{
		// if(m_bObjectSearchTest) ReportObjectSearchResultFOBC(TRUE);

		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_SUCCESS);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{		
		ReportACFInspectResultFCHC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;		

	}

	// 	// 4. 关闭定位
	// 	// CloseSearch();
	// 	CloseSearch(vCamIndex);


	// 5. 设置对位工具

	dInspectSearchTime = stInspectSearchTimer.GetTimeMilli(FALSE);

	if(m_bObjectSearchTest)
	{
		if (bInspectSearchSync)
		{
			ReportACFInspectResultFCHC(TRUE,m_vnInspectSearchSuccessPatIndex[0]);
		}
		else
		{
			ReportACFInspectResultFCHC(TRUE,-1);
		}

	}
	return TRUE;
}

// 两个及两个以上相机对位系统实时对象Mark定位
BOOL vcXYDVisionAlign::OnSerialCameraACFInspectCandidateExFCHC(std::vector<int> vnPosIndex, int nStartPatIndex, int nEndIndex)
{

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VCHC:");
	CString strTempWarningType = _T("");
	GetCommCommandName(strCmd);
	if (!CheckInspectSearchTool(strCmd) || !CheckPlatformInfo(strCmd)/*m_bValidInspectSearchTool!=TRUE || NULL == m_pPlatformInfo*/)
	{	
		ReportACFInspectResultFCHC(FALSE);
		return FALSE;
	}
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	int i = 0;
	int nPosIndex = 0;		
	int nPosNum = vnPosIndex.size();


	if (nPosNum<=0)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_INSPECT_FAIL);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_CAMNUMERROR);
		SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		ReportACFInspectResultFCHC(FALSE);
		return FALSE;
	}

	//	int i=0;
	for(i=0; i<nPosNum; i++)
	{		 
		nPosIndex = vnPosIndex[i];
		if (FALSE == IsPosCameraGrabbing(nPosIndex))
		{      
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_SB_INSPECT_FAIL);
			m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_CAMERA_CONNECTION);
			CString strTemp = _T("");
			strTemp.Format(m_strStatusBarInfo2, i + 1);	//zzc报警 相机x链接失败，1,2,3,4
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, strTemp);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
			AddWarningInfo(strTempWarningType, (strCmd + strTemp));	
			ReportACFInspectResultFCHC(FALSE);
			return FALSE;
		}    	
	}

	scTimer stSearchTimer;	// 搜索时间
	stSearchTimer.Reset();

	// 准备开始定位			
	//	std::vector<int> vnPosIndex;
	std::vector<SearchMode> vsmSearchMode;	

	//	int nPosIndex = 0;
	for(i = 0; i < nPosNum; i++)
	{
		nPosIndex = vnPosIndex[i];
		vsmSearchMode.push_back(eInspectSearch);	// 
	}


	// 检测模板曝光切换
	{
		int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
		BOOL SystempOptionSearchShutter = optionInfo.m_bEnableSearchShutter;
		//BOOL bInspectCandidate = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateEnable();
		//BOOL bInspectShutter = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		CameraParamEnable cameraParamEnable;
		cameraParamEnable =m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetEnableInspectSearchShutter(nStartPatIndex);
		BOOL bInspectShutter = (cameraParamEnable.m_bShutterEnable || cameraParamEnable.m_bGainEnable || cameraParamEnable.m_bGammaEnable);

		//		if (m_pSystempOptionConfig->m_bEnableSearchShutter == TRUE)
		if (SystempOptionSearchShutter /*&& bInspectCandidate*/ && bInspectShutter/* && (0 == nStartPatIndex)*/)
		{
			std::vector<CameraExposureType> vsmCameraExposureType;	

			for(i = 0; i < nPosNum; i++)
			{
				vsmCameraExposureType.push_back(eInspectSearchCameraExposure);
			}

			if (!CameraExposureSetting(vnPosIndex,vsmCameraExposureType,nStartPatIndex))
			{
				// 				m_bStatusBar = FALSE;
				// 				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SET_INSPECT_EXPOSURE_FAIL);
				// 				m_strStatusBarInfo2 = _T("");
				// 				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				// 				PostMessageUpdateStatusBarInfo();
				OnFailedCameraExposureSetting(strCmd);
			}
		}
	}


	// 1. 通信获取当前平台各个轴的绝对位置

	CString str;
	// 	str.Format("CommuciateGetPlatformAxisAbsPos time = %f",dCommuciateTime);
	// 	AlignLogRecord(str);
	// 2. 通信获取当前所有相机平台各个轴的绝对位置

	// 3.开启定位
	scTimer stInspectSearchTimer; double dInspectSearchTime(0.0);
	stInspectSearchTimer.Reset();


	// 等待搜索延时
	int nCurProdcutIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();
	int nDelayTime = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetObjectSearchDelayTime();
	Sleep(nDelayTime);



	// 隐藏目标定位结果十字，全部0/1/2/3图像
	/*PostMessageUpdateGuiAlnInspectImagePosGraphics*/(vnPosIndex, FALSE);
	//ShowExtraGuiToDisplay(vnPosIndex,FALSE,3);
	//HideObjTarGuiResultInSpect(vnPosIndex, FALSE);
	m_cVisionAlignGui.SetPosGuiInvisible(vnPosIndex, eInspectSearch);
	// 采集搜索图像
	if (!SnapSearchImage(vnPosIndex))
	{
		ReportACFInspectResultFCHC(FALSE);

		// 		m_bStatusBar = FALSE;
		// 		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_SB_GRAB_FAILED);
		// 		m_strStatusBarInfo2 = m_psaSysInfoStrings->GetAt(IDS_SB_CAMERA_CONNECTION_ERROR);
		// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		// 		PostMessageUpdateStatusBarInfo();
		OnFailedSnapSearchImage(strCmd);
		return FALSE;
	}

	// 定位
	BOOL bInspectSearchSync = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProdcutIndex)->m_pAlignerParam->GetInspectCandidateSyncEnable();
	BOOL bSearchSucceed = FALSE;
	if (nStartPatIndex >= nEndIndex)
	{
		for(i = 0; i < nPosNum; i++)
		{
			nPosIndex = vnPosIndex[i];
			m_vnInspectSearchStartPatIndex[nPosIndex] = nStartPatIndex;
			m_vnInspectSearchEndPatIndex[nPosIndex] = nStartPatIndex;
		}
		bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
	}
	else
	{
		if (bInspectSearchSync == TRUE)
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			if (nStartPatIndex>=0 && nStartPatIndex < INSPECTCANDIDATENUM)
			{
				nTempStartPatIndex = nStartPatIndex;
			}
			else if (nStartPatIndex == 9)
			{
				nTempStartPatIndex = m_vnInspectSearchSuccessPatIndex[vnPosIndex[0]];
			}
			else
			{
				nTempStartPatIndex = 0;
			}
			nTempEndPatIndex = nEndIndex;

			int j = 0;
			for(j = nTempStartPatIndex ; j <= nTempEndPatIndex; j++ )
			{

				for(i = 0; i < nPosNum; i++)
				{
					nPosIndex = vnPosIndex[i];
					m_vnInspectSearchStartPatIndex[nPosIndex] = j;
					m_vnInspectSearchEndPatIndex[nPosIndex] = j;
				}			
				bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);

				if (bSearchSucceed)
				{
					break;
				}	
				//Sleep(100);
			}
		}
		else
		{
			int nTempStartPatIndex, nTempEndPatIndex;
			for(i = 0; i < nPosNum; i++)
			{
				nPosIndex = vnPosIndex[i];
				if (nStartPatIndex>=0 && nStartPatIndex < INSPECTCANDIDATENUM)
				{
					nTempStartPatIndex = nStartPatIndex;
				}
				else if (nStartPatIndex == 9)
				{
					nTempStartPatIndex = m_vnInspectSearchSuccessPatIndex[nPosIndex];
				}
				else
				{
					nTempStartPatIndex = 0;
				}
				nTempEndPatIndex = nEndIndex;

				m_vnInspectSearchStartPatIndex[nPosIndex] = nTempStartPatIndex;
				m_vnInspectSearchEndPatIndex[nPosIndex] = nTempEndPatIndex;
			}
			bSearchSucceed = SearchMark(vnPosIndex, vsmSearchMode);
		}
	}


	// 设定、显示结果图形
	//SetGuiAlnInspectImageMarkPos(vnPosIndex);
	//PostMessageUpdateGuiAlnInspectImagePosGraphics(vnPosIndex, TRUE);
	//ShowExtraGuiToDisplay(vnPosIndex,TRUE,3);
	m_cVisionAlignGui.SetPosSearchResult(vnPosIndex, eInspectSearch);
	if (m_pVisionASMConfig->m_DataRecord.m_bSaveVDBFile)
	{
		//PostMessageSaveVDBFile(vnPosIndex,eInspectSearch);
		ExeSaveVDBFile(vnPosIndex,eInspectSearch);
	}

	if (TRUE == bSearchSucceed)
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_SUCCESS);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{

		ReportACFInspectResultFCHC(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_ACF_INSPECT_FAILE);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_SEARCH);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	// 	// 4. 关闭定位
	// 	// CloseSearch();
	// 	CloseSearch(vCamIndex);


	// 5. 设置对位工具


	// 记录图像搜索数据

	dInspectSearchTime = stInspectSearchTimer.GetTimeMilli(FALSE);

	if(m_bObjectSearchTest)
	{
		if (bInspectSearchSync)
		{
			ReportACFInspectResultFCHC(TRUE,m_vnInspectSearchSuccessPatIndex[vnPosIndex[0]]);
		}
		else
		{
			ReportACFInspectResultFCHC(TRUE,-1);
		}

	}
	return TRUE;
}

// 根据索引指令设置当前产品  （产品切换）
BOOL vcXYDVisionAlign::OnlineSetProductVirtualAln(BOOL bVAlnOn)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd)/*NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig*/)
	{
		ReportSetProductVirtualAlnFVAS(FALSE);
		return FALSE;
	}

	int nProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	{
		// 设置当前产品
		if (!SetCurProductVirtualAln(bVAlnOn))
		{
			ReportSetProductVirtualAlnFVAS(FALSE);//SendCommInfo(CMD_TN_UNKNOWN_ERR);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_VALN_SETTING_FAIL);//_T("切换产品失败");
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			return FALSE;
		}

		PostMessageUpdateCurProductAlignInfo();
	}


	ReportSetProductVirtualAlnFVAS(TRUE);//SendCommInfo(CMD_TN_SUCCEED);

	m_bStatusBar = TRUE;
	if (bVAlnOn)
	{
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_VALN_SETTING_ON);//_T("切换产品成功");
	}
	else
	{
		m_strStatusBarInfo1 = m_psaSysInfoStrings->GetAt(IDS_VALN_SETTING_OFF);//_T("切换产品成功");
	}

	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

// 接收命令，进行相应的定位操作（定位、定位结果图形显示、状态显示，记录目标位置到对位工具），返回命令响应
BOOL vcXYDVisionAlign::OnlineExFDRP(int nAngleIndex,int nExProductIndex/* = 0*/)
{
	BOOL bAngleDesign = FALSE;
	CString strCmd = _T("VDRP:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	if (!CheckPlatformInfo(strCmd)/*NULL == m_pPlatformInfo*/)
	{
		return FALSE;
	}	

	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		ReportResultFDRP(FALSE);
		return FALSE;
	}
	int nPosIndex = 0;
	if(nAngleIndex > 0 && nAngleIndex < 5)
	{
		if(!GetCalibAlignerBenchPickPlatformAxisPos())
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings, IDS_WARNING_PROCESSING_GETBENCHPICKPLATAXISPOSFAILED);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar, m_strStatusBarInfo1, m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			ReportResultFDRP(FALSE);
			return FALSE;
		}
		CAlignerParam* pAlignerParam = GetProductAlignerParam();
		if(optionInfo.m_bEnableMultiMarkMode)
		{
			/*if (TRUE == SingleCameraAlignerObjectSearchExFOBJ(nPosIndex))*/
			if (TRUE == OnSingleCameraAlignerObjectSearchExFOBJ(nPosIndex))
			{
				/*m_mpObjectMarkImagePos = GetObjectMarkImagePos();

				if (TRUE == m_mpObjectMarkImagePos.GetIsMarkImagePosOK(nPosIndex))
				{
				CCoordPos pos;
				pos = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex);

				m_vpGuiAlnObjectImageMarkPos.at(nPosIndex)->SetCenterRotationLengths(
				sc2Vector(pos.GetPosX(),pos.GetPosY()),scDegree(45),400,400);
				m_vpGuiAlnObjectImageMarkPos.at(nPosIndex)->SetVisible(TRUE);
				}

				if (TRUE == m_mpObjectMarkImagePos.GetIsMarkImagePosOK(nPosIndex+1))
				{
				CCoordPos pos;
				pos = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex+1);

				m_vpGuiAlnObjectImageMarkPos.at(nPosIndex+1)->SetCenterRotationLengths(
				sc2Vector(pos.GetPosX(),pos.GetPosY()),scDegree(45),400,400);
				m_vpGuiAlnObjectImageMarkPos.at(nPosIndex+1)->SetVisible(TRUE);
				}*/
			}
		}
		else
		{
			for(nPosIndex = 0; nPosIndex < m_pPlatformInfo->m_nPositionNum; nPosIndex++)
			{			
				//if (TRUE == SingleCameraAlignerObjectSearchExFOBJ(nPosIndex))
				if (TRUE == OnSingleCameraAlignerObjectSearchExFOBJ(nPosIndex))
				{
					/*m_mpObjectMarkImagePos = GetObjectMarkImagePos();

					if (TRUE == m_mpObjectMarkImagePos.GetIsMarkImagePosOK(nPosIndex))
					{
					CCoordPos pos;
					pos = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex);

					m_vpGuiAlnObjectImageMarkPos.at(nPosIndex)->SetCenterRotationLengths(
					sc2Vector(pos.GetPosX(),pos.GetPosY()),scDegree(45),400,400);
					m_vpGuiAlnObjectImageMarkPos.at(nPosIndex)->SetVisible(TRUE);
					}*/
				}
			}
		}

		if(ExecuteBenchMarkPick(nAngleIndex-1,nExProductIndex))
		{
			if(SaveBenchMarkPick())
			{
				m_bStatusBar = TRUE;
				bAngleDesign = TRUE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALCU_0_SUCCESS+nAngleIndex-1);//.Format(_T("计算成功"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				ReportResultFDRP(TRUE);
			}
			else
			{
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALCU_0_FAILE+nAngleIndex-1);//.Format(_T("计算失败"));
				m_strStatusBarInfo2.Format(_T(""));
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();
				strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
				AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
				ReportResultFDRP(FALSE);
			}
		}
		else
		{
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CALCU_0_FAILE+nAngleIndex-1);//.Format(_T("计算失败"));
			m_strStatusBarInfo2.Format(_T(""));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			ReportResultFDRP(FALSE);
		}

	}

	return bAngleDesign;

}

// 获取目标指定位置的图像坐标
BOOL vcXYDVisionAlign::OnlineGetTargetImagePosFTGG(int nPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VTGG:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		ReportGetTargetImagePosFTGG(FALSE);
		return FALSE;
	}

	if (!CheckTargetSearchTool(strCmd)/*m_bValidTargetSearchTool!=TRUE*/)
	{	
		ReportGetTargetImagePosFTGG(FALSE);
		return FALSE;
	}

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{
		ReportGetTargetImagePosFTGG(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_SEARCH_FAILE);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	// 获取目标指定位置图像坐标
	double dImagePosX = m_mpTargetMarkImagePos.GetMarkImagePos(nPosIndex).GetPosX();
	double dImagePosY = m_mpTargetMarkImagePos.GetMarkImagePos(nPosIndex).GetPosY(); 
	double dImagePosD = m_mpTargetMarkImagePos.GetMarkImagePos(nPosIndex).GetAngle();

	// 获取图像尺寸
	double dImageSizeX = GetPosDisplay(nPosIndex)->GetImageWidth();
	double dImageSizeY = GetPosDisplay(nPosIndex)->GetImageHeight();

	if (fabs(dImagePosX) > dImageSizeX || fabs(dImagePosY) > dImageSizeY)
	{
		ReportGetTargetImagePosFTGG(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_CAMERA);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	// 返回成功
	ReportGetTargetImagePosFTGG(TRUE, dImagePosX, dImagePosY, dImagePosD);

	m_bStatusBar = TRUE;
	//	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_TARGET_MARK_COORD_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

// 报告目标指定位置的图像坐标
BOOL vcXYDVisionAlign::ReportGetTargetImagePosFTGG(BOOL bResult, double dImagePosX, double dImagePosY, double dImagePosD)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 指令解析
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetTargetImagePosFTGG(strSimpleInfo, bResult, dImagePosX, dImagePosY/*, dImagePosD*/);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 先发送平台坐标到轴位置，再写触发和动作
		CCoordPos imagePos;
		imagePos.m_dPosX = dImagePosX;
		imagePos.m_dPosY = dImagePosY;
		imagePos.m_dAngle = dImagePosD;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFTGGAxisPos(strSend, imagePos, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFTGG(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetTargetImagePosFTGG(strInfo, bResult, dImagePosX, dImagePosY/*, dImagePosD*/))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

// 获取对象指定位置的图像坐标
BOOL vcXYDVisionAlign::OnlineGetObjectImagePosFOBG(int nPosIndex)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CString strCmd = _T("VOBG:");
	GetCommCommandName(strCmd);
	CString strTempWarningType = _T("");
	/*(NULL == m_pVisionASMConfig) || (NULL == m_pPlatformInfo) || (NULL == m_pComm) || (NULL == m_pAlignerTool)*/
	if (!CheckPlatformInfo(strCmd) || !CheckVisionASMConfig(strCmd) || !CheckCommuciation(strCmd) || !CheckAlignerSearchTool(strCmd))
	{
		ReportGetObjectImagePosFOBG(FALSE);
		return FALSE;
	}

	if (!CheckTargetSearchTool(strCmd)/*m_bValidTargetSearchTool!=TRUE*/)
	{	
		ReportGetObjectImagePosFOBG(FALSE);
		return FALSE;
	}

	if (nPosIndex < 0 || nPosIndex >= GetPosNum())
	{
		ReportGetObjectImagePosFOBG(FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_TARGET_SEARCH_FAILE);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_POS_NUMBER_OUT_RANGE);//_T("位置编号超出范围");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo2));
		return FALSE;
	}

	// 获取对象指定位置图像坐标
	double dImagePosX = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex).GetPosX();
	double dImagePosY = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex).GetPosY(); 
	double dImagePosD = m_mpObjectMarkImagePos.GetMarkImagePos(nPosIndex).GetAngle();

	// 获取图像尺寸
	double dImageSizeX = GetPosDisplay(nPosIndex)->GetImageWidth();
	double dImageSizeY = GetPosDisplay(nPosIndex)->GetImageHeight();

	if (fabs(dImagePosX) > dImageSizeX || fabs(dImagePosY) > dImageSizeY)
	{
		ReportGetObjectImagePosFOBG(FALSE);
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
		PostMessageUpdateStatusBarInfo();
		strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
		AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
		return FALSE;
	}

	// 返回成功
	ReportGetObjectImagePosFOBG(TRUE, dImagePosX, dImagePosY, dImagePosD);

	m_bStatusBar = TRUE;
	//	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_SEARCH_SUCCEED);
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_OBJECT_MARK_COORD_SUCCEED);
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	return TRUE;
}

// 报告目标指定位置的图像坐标
BOOL vcXYDVisionAlign::ReportGetObjectImagePosFOBG(BOOL bResult, double dImagePosX, double dImagePosY, double dImagePosD)
{
	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		// 指令解析
		CString strSimpleInfo;
		m_XYDCommProtocol.PackReGetObjectImagePosFOBG(strSimpleInfo, bResult, dImagePosX, dImagePosY/*, dImagePosD*/);
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		// 先发送平台坐标到轴位置，再写触发和动作
		CCoordPos imagePos;
		imagePos.m_dPosX = dImagePosX;
		imagePos.m_dPosY = dImagePosY;
		imagePos.m_dAngle = dImagePosD;

		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFOBGAxisPos(strSend, imagePos, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}


		// 打包写寄存器指令
		if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFOBG(strSend, bResult))
		{
			return FALSE;
		}

		// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
		bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
		if (bReceived == FALSE || nCommStatus != eCommSucceed)
		{
			return FALSE;
		}

		// 视觉指令触发置位
		if (!SetVisionPlatformTrigger())
		{
			return FALSE;
		}
	}
	else
	{
		// 打包“写寄存器”指令
		CString strInfo;
		if (!m_XYDCommProtocol.PackReGetObjectImagePosFOBG(strInfo, bResult, dImagePosX, dImagePosY/*, dImagePosD*/))
		{
			return FALSE;
		}	

		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignExFMCO(int nOffsetCount)
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	// 所有轴位置信息
	std::vector<pair<CCoordPos, int>> vpPlatformXYDOffset;

	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{
		ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{
		ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (FALSE == m_bValidAlignerTool)
	{
		ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}

	CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

	m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
	// 检查目标Mark是否已成功定位
	if(!optionInfo.m_bEnableMutiTarget)
	{
		if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
		{
			if (FALSE == m_bTargetMarkSearchSucceed)
			{
				ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;
			}
		}

		//	CalculateTargetDistance(); 
		if (!CheckTargetDistance())
		{
			ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		if (!CheckTargetAngle())
		{
			ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

	}

	// 检查对象Mark是否已成功定位
	if (eObjectBench != curProductData.m_pAlignerParam->m_eObjectMarkType)
	{
		if (FALSE == m_bObjectMarkSearchSucceed)
		{
			ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

			return FALSE;
		}	

		//		CalculateObjectDistance(); 
		if (!CheckObjectDistance())
		{
			ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_DIS_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}
	}



	scTimer stAlignTimer;   double dAlignTime(0.0),dTotalTime(0.0);	
	BOOL bPlatformMoveOverflow = TRUE;

	for (int i = 0; i < nOffsetCount && i<ALIGNOFFSETNUM && i<ALIGNBENCHOFFSETNUM; i++)
	{
		stAlignTimer.Reset();
		//如果启用多目标，则设置多目标序号
		if (optionInfo.m_bEnableMutiTarget && i < MUTITARGETMAXNUM)
		{
			m_nMutiTargetCurIndex = i;
			m_bTargetMarkSearchSucceed = m_vbMutiTargetMarkOK.at(m_nMutiTargetCurIndex);
			if (m_bTargetMarkSearchSucceed)
			{
				SetTargetMarkSearchResults(m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex));
				m_mpTargetMarkImagePos=m_vMutiTargetMarkImagePos.at(m_nMutiTargetCurIndex);
				int nPosNum = m_pPlatformInfo->m_nPositionNum;
				for (int i = 0;i<nPosNum;i++)
				{
					SetTargetPlatformPos(m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i),i);
					SetTempTargetPlatformAxisPos(i,m_vpMutiTargetPlatformAxisPos.at(m_nMutiTargetCurIndex).at(i));
				}
				PostMessageShowMutiTargetImagePosToDisplay(m_bTargetMarkSearchSucceed);	
				//				CalculateTargetDistance(); 
				if (!CheckTargetDistance())
				{
					ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}
				if (!CheckTargetAngle())
				{
					ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

					return FALSE;
				}
			}	
			else
			{
				ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
				m_strStatusBarInfo2.Format(_T("多目标_第%d组尚未定位成功"),i + 1);
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

				return FALSE;
			}
		}

		EnterCriticalSection(&m_csAlignerOffset);
		pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(i);
		pCurProductData->m_pAlignerParam->SetCurAlignerBenchOffsetIndex(i);
		CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
		pAlignerParam->SetCurAlignerOffsetIndex(i);
		pAlignerParam->SetCurAlignerBenchOffsetIndex(i);
		LeaveCriticalSection(&m_csAlignerOffset);
		PostMessageUpdateAlignOffsetInfo();

		// 执行对位计算
		CCoordPos cpBenchOffset;
		CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos = NULL;	
		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 执行对位计算
			// 设置图像中心十字基准目标
			SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
			m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

			// 执行对位
			m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
			if(FALSE == ExecuteAlign())
			{
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

				ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				//				m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		

				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			pBenchPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			cpBenchOffset = GetAlignPlatformPosOffset();


			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效
			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);		
		}

		// 执行对位计算
		if(FALSE == ExecuteAlign())
		{
			ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}


		// 更新主界面对位精度、次数、对位总时间
		CCoordPos cpProduct = GetAlignProductOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		}

		m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
		m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
		m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

		CCoordPos cp = GetAlignPlatformOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		}

		m_apAlignerProcesInfo.nTimes  = 1;

		m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
		m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
		m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
		m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

		dAlignTime=m_apAlignerProcesInfo.dTime;
		dTotalTime += dAlignTime;

		vpPlatformXYDOffset.push_back(make_pair(cp, i));
		PostMessageUpdateAlignerProcessInfo();
		//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
		//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
		//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
		if(IsAxisMoveOverRun(cp))
		{//超运动量则失败 TT201106
			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
			m_strStatusBarInfo2.Format(_T("第%d组(X:%.3f,Y:%.3f,D:%.3f)"),i + 1,cp.m_dPosX,cp.m_dPosY,cp.m_dAngle);

			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();
			//strTempWarningType = GetSysInfoString(m_psaSysInfoStrings, IDS_OPERATION_WARNING_PROCESSING);
			//AddWarningInfo(strTempWarningType, (strCmd + m_strStatusBarInfo1));
			//return FALSE;
			bPlatformMoveOverflow = TRUE;
			break;
		}
		bPlatformMoveOverflow = FALSE;


		// 记录对位精度
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
		{
			CString strTemp;
			// 		CTime t = CTime::GetCurrentTime();
			// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strOut;					
			strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
			strOut = strTemp + strOut;

			// 		FILE *stream;
			// 		CString strPath = m_strAlignProcessData;
			// 		stream = fopen(strPath, _T("a+t"));               
			// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
			// 		fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}

		// 记录对位时间
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
		{
			CString strTemp;
			// 		CTime t = CTime::GetCurrentTime();
			// 		strTemp.Format(_T("\n\n%d-%d-%d-%d-%d-%d "),t.GetYear(), t.GetMonth(), t.GetDay(), t.GetHour(), t.GetMinute(), t.GetSecond());

			CString strOut;						
			strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
			strOut = strTemp + strOut;

			// 		FILE *stream;
			// 		CString strPath = m_strAlignProcessData;
			// 		stream = fopen(strPath, _T("a+t"));               
			// 		fwrite(strOut, sizeof(TCHAR), strOut.GetLength(), stream);
			// 		fclose(stream);VCRemoveFile(strPath);	

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}	
	}

	if (bPlatformMoveOverflow == TRUE)
	{
		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
		//m_strStatusBarInfo2.Format(_T(""));
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
	}
	else
	{
		m_bStatusBar = TRUE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
		m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dTotalTime);
	}
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();				

	ReportMulAlignPosResultFMCO(vpPlatformXYDOffset,m_bStatusBar);

	return TRUE;  
}


BOOL vcXYDVisionAlign::ReportMulAlignPosResultFMCO(std::vector<pair<CCoordPos, int>> vpPlatformXYDOffset,BOOL bResult)	// 对位拾取响应
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);

	//std::vector<pair<CCoordPos, int>> vpEffectiveOffset;

	//for (int i = 0; i < (int)vpPlatformXYDOffset.size(); i++)
	//{
	//	CCoordPos cp = vpPlatformXYDOffset.at(i).first;

	//	if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
	//		|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
	//		|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
	//	{
	//		continue;
	//	}
	//	vpEffectiveOffset.push_back(vpPlatformXYDOffset.at(i));
	//}

	CString strSimpleInfo/*,strEffectiveSimpleInfo*/;
	m_XYDCommProtocol.PackReMulAlignPosInfoFMCO(strSimpleInfo,vpPlatformXYDOffset,bResult);
	//m_XYDCommProtocol.PackReMulAlignPosInfoFMCO(strEffectiveSimpleInfo,vpEffectiveOffset,bResult);

	if (m_XYDCommProtocol.IsPlcProtocolType())// 如果是PLC直接读取存储寄存器协议
	{
		AddCommCommandInfo(TRUE,strSimpleInfo,FALSE,FALSE);

		CString strSend;
		BOOL bReceived;
		CString strInfo;
		CommStatus nCommStatus = eCommSucceed;

		if (bResult)
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcMulAlignPosResultInfoFMCOAxisPos(strSend,vpPlatformXYDOffset/*vpEffectiveOffset*/,bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}

			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFMCO(strSend,bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}


			// 视觉指令触发置位
			if (!SetVisionPlatformTrigger())
			{
				return FALSE;
			}
		}
		else
		{
			// 打包写寄存器指令
			if (FALSE == m_XYDCommProtocol.PackRePlcAlignResultInfoFMCO(strSend,bResult))
			{
				return FALSE;
			}

			// 发送写PLC寄存器字符串，并接收解析PLC的响应字符串是否正确
			bReceived = CommunicateSendWriteRegStr(strSend, strInfo, nCommStatus);
			if (bReceived == FALSE || nCommStatus != eCommSucceed)
			{
				return FALSE;
			}


			// 视觉指令触发置位
			if (!SetVisionPlatformTrigger())
			{
				return FALSE;
			}
		}
	}
	else
	{
		// 发送“写寄存器”指令
		if (FALSE == SendCommInfo(strSimpleInfo/*strEffectiveSimpleInfo*/, TRUE, strSimpleInfo))	
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignFACO(int nOffsetIndex, int nBenchOffsetIndex /*= -1*/, int nExProductIndex /*= 0*/,int nTarFixOffsetIndex /*= 0*/ )
{
	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);
	BOOL bSendMulAlignerPos = optionInfo.m_bSendMulAlignResult;
	int nCamNum = m_pPlatformInfo->m_nCamNum;
	int nPosNum = m_pPlatformInfo->m_nPositionNum;
	// 一次发送多个对位结果(适用条件：单相机、一个位置、“选项”中“一次发送多个对位结果”)
	if ( (bSendMulAlignerPos) && (nCamNum == 1) /*&& (nPosNum == 1)*/)
	{
		OnlineAlignMulExFACO(nOffsetIndex, nBenchOffsetIndex, nExProductIndex, nTarFixOffsetIndex);
	}
	else
	{
		OnlineAlignExFACO(nOffsetIndex, nBenchOffsetIndex, nExProductIndex, nTarFixOffsetIndex);
	}

	return TRUE;
}

BOOL vcXYDVisionAlign::OnlineAlignMulExFACO(int nOffsetIndex, int nBenchOffsetIndex/* = -1*/, int nExProductIndex/* = 0*/,int nTarFixOffsetIndex /*= 0*/ )
{
	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = _T("");
	m_strStatusBarInfo2 = _T("");
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();


	SetAlignBenchOffsetIndex(nBenchOffsetIndex);
	SetAlignExProductIndex(nExProductIndex);

	CPlatformOptionInfo optionInfo;
	GetPlatformOptionInfo(optionInfo);



	m_AlignerTargetSizeInfo.m_nExProductIndex = nExProductIndex;
	CCoordPos platOffset;

	if (NULL == m_pPlatformInfo || NULL == m_pVisionASMConfig)
	{

		ReportAlignResultFACO(platOffset,FALSE);
		return FALSE;
	}	

	// 检查对象定位工具是否有效
	if ( FALSE == m_bValidObjectSearchTool)
	{
		ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_SEARCH_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查对位工具是否有效
	if (FALSE == m_bValidAlignerTool)
	{
		ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;

	}

	// 检查通信工具是否有效
	if (FALSE == m_bValidComm)
	{
		ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_TOOL_INVALID);
		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_CHECK_INIT);
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

		return FALSE;
	}

	// 检查所有相机是否均处于连续采集状态	
	for(int i=0; i<m_pPlatformInfo->m_nCamNum; i++)
	{		 
		if (FALSE == m_vbCameraLiveGrab[i])
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_CAMERA_GRABBING);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

			return FALSE;
		}            
	}    

	// 获取当前产品信息
	int nCurProductIndex = m_pVisionASMConfig->m_TotalProductData.GetCurProductIndex();

	if (nCurProductIndex<0 || nCurProductIndex>=m_pVisionASMConfig->m_TotalProductData.GetCount())
	{
		ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}


	// 设置补偿量索引
	CProductData* pCurProductData = m_pVisionASMConfig->m_TotalProductData.GetItemPtr(nCurProductIndex);
	if (pCurProductData == NULL)
	{
		ReportAlignResultFACO(platOffset,FALSE);

		m_bStatusBar = FALSE;
		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_GET_CUR_PRODUCT_ALIGN_INFO_FAILED);
		m_strStatusBarInfo2 = _T("");
		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

		return FALSE;
	}
	EnterCriticalSection(&m_csAlignerOffset);
	pCurProductData->m_pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerBenchOffsetIndex(nOffsetIndex);
	pCurProductData->m_pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	CAlignerParam* pAlignerParam = m_pAlignerTool->GetProductAlignerParam();
	pAlignerParam->SetCurAlignerOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerBenchOffsetIndex(nOffsetIndex);
	pAlignerParam->SetCurAlignerTarFixOffsetIndex(nTarFixOffsetIndex);
	LeaveCriticalSection(&m_csAlignerOffset);
	PostMessageUpdateAlignOffsetInfo();




	//////////////////////////////////////////////////////////////////////////
	int nSuccessPatIndex = m_vnObjectSearchSuccessPatIndex[0];
	std::vector<CSearchResult> vTempSeachResults = GetAlnObjectSearchResults(0,nSuccessPatIndex);
	int nSearchNum = GetAlnObjectSearchResultNumber(0,nSuccessPatIndex);

	scTimer stAlignTimer;   
	double dAlignTime(0.0);	
	stAlignTimer.Reset();	

	std::vector<CCoordPos> vcpOffset;
	std::vector<CCoordPos> vcpReviseOffset;
	// 执行对位计算
	CCoordPos cpBenchOffset;
	CPlatformXYDAxisPos* pBenchPlatformXYDAxisPos = NULL;
	CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;


	for (int i = 0; i < nSearchNum; i++)
	{
		CCoordPos cpPosCH0;
		cpPosCH0.m_dPosX = vTempSeachResults.at(i).m_dPosX;
		cpPosCH0.m_dPosY = vTempSeachResults.at(i).m_dPosY;
		cpPosCH0.m_dAngle = vTempSeachResults.at(i).m_dAngle;

		CCoordPos cpPosCH1;
		cpPosCH1.m_dPosX = vTempSeachResults.at(i).m_vdAuxiliaryPosX.at(0);
		cpPosCH1.m_dPosY = vTempSeachResults.at(i).m_vdAuxiliaryPosY.at(0);
		cpPosCH1.m_dAngle = vTempSeachResults.at(i).m_vdAuxiliaryAngle.at(0);

		m_mpObjectMarkImagePos.SetMarkImagePos(0, m_vbSearchSucceed[0], cpPosCH0);
		if(m_pPlatformInfo->m_nPositionNum>1)
		{
			m_mpObjectMarkImagePos.SetMarkImagePos(1, m_vbSearchSucceed[0], cpPosCH1);
		}



		//SetObjectMarkSearchResults(m_mpObjectMarkImagePos); 


		// start 直接根据searchdata中图像坐标和轴位置 设置进对位工具中；
		{
			int nSize1 = m_vvpTargetPlatformAxisPosMultiEx.size();
			int nSize2 = m_vvpObjectPlatformAxisPosMultiEx.size();
			int nSize3 = m_vmpObjectMarkImagePos_MultiEX.size();
			int nSize4 = m_vmpTargetMarkImagePosMultiEx.size();
			bool bTmp = (nExProductIndex >=0) &&  (nExProductIndex <nSize1) &&  (nExProductIndex <nSize2) &&  (nExProductIndex <nSize3)  &&  (nExProductIndex <nSize4);

			if (bTmp)
			{

				vector<CPlatformAxisPos*> tmpObjectPlatformAxisPos;
				vector<CPlatformAxisPos*> tmpTargetPlatformAxisPos;
				tmpObjectPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);
				tmpTargetPlatformAxisPos.resize(m_pPlatformInfo->m_nPositionNum);

				if (m_pPlatformInfo->m_bEnableMultiCalibExtension)
				{
					if (optionInfo.m_bObjectSearchExProduct)
					{
						for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
						{
							tmpObjectPlatformAxisPos.at(jt) = m_vvpObjectPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
						}
						m_mpObjectMarkImagePos = m_vmpObjectMarkImagePos_MultiEX.at(nExProductIndex);
					}
					else
					{
						tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
					}

					if (optionInfo.m_bTargetSearchExProduct)
					{
						for (int jt = 0 ;jt<m_pPlatformInfo->m_nPositionNum;jt++)
						{
							tmpTargetPlatformAxisPos.at(jt) = m_vvpTargetPlatformAxisPosMultiEx.at(nExProductIndex).at(jt);
						}
						m_mpTargetMarkImagePos = m_vmpTargetMarkImagePosMultiEx.at(nExProductIndex);
					}
					else
					{
						tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
					}

				}
				else
				{
					tmpObjectPlatformAxisPos = m_vpObjectPlatformAxisPos;
					tmpTargetPlatformAxisPos = m_vpTargetPlatformAxisPos;
				}


				m_pAlignerTool->SetTargetPlatformPos(tmpTargetPlatformAxisPos);
				//m_pAlignerTool->SetTargetMarkSearchResultsInit(tmpTargetImagePos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);

				m_pAlignerTool->SetObjectPlatformPos(tmpObjectPlatformAxisPos);
				//m_pAlignerTool->SetObjectMarkSearchResultsAll(tmpObjectImagePos);
				m_pAlignerTool->SetObjectMarkSearchResults(m_mpObjectMarkImagePos);


				m_bTargetMarkSearchSucceed = m_mpTargetMarkImagePos.IsAllMarkImagePosOK();
				m_bObjectMarkSearchSucceed = m_mpObjectMarkImagePos.IsAllMarkImagePosOK();

			}
		}
		// end  直接根据searchdata中图像坐标和轴位置 设置进对位工具中；

		CProductData curProductData = m_pVisionASMConfig->m_TotalProductData.GetItem(nCurProductIndex);

		if (optionInfo.m_nTarInfoCommModeInDiffPC == 2)//通过PLC交换目标图像坐标和轴位置等
		{
			std::vector<int> vnPosIndex;
			std::vector<CCoordPos> vTargetImgPos;
			std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
			m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
			BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetImagePos(vnPosIndex,vTargetImgPos,vTargetPlatAxisPos);
			if (!bCommuciateGetTargetPlatformPos)	
			{
				ReportAlignResultFACO(platOffset,FALSE);
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1.Format(_T("通信获取目标图像坐标失败"));
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				return FALSE;
			}
			else
			{
				int nPosIndex=0;
				for(int i=0;i<vnPosIndex.size();i++)
				{
					nPosIndex = vnPosIndex.at(i);
					if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
					{
						ReportAlignResultFACO(platOffset,FALSE);
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = _T("通信获取目标图像坐标失败");// 
						m_strStatusBarInfo2 = _T("");//
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
						return FALSE;
					}
					SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
					SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
					m_mpTargetMarkImagePos.SetMarkImagePos(nPosIndex,TRUE,vTargetImgPos.at(i));
				}
				SetTargetMarkSearchResults(m_mpTargetMarkImagePos);
			}
		}
		else if (optionInfo.m_nTarInfoCommModeInDiffPC == 1)//通过PLC交换目标平台坐标和轴位置等
		{
			std::vector<int> vnPosIndex;
			std::vector<CCoordPos> vTargetCoordPos;
			std::vector<CPlatformXYDAxisPos> vTargetPlatAxisPos;
			m_pAlignerTool->SetIsReadTargetPlatformPos(TRUE);
			BOOL bCommuciateGetTargetPlatformPos = CommuciateGetTargetPlatformPos(vnPosIndex,vTargetCoordPos,vTargetPlatAxisPos);
			if (!bCommuciateGetTargetPlatformPos)	
			{
				ReportAlignResultFACO(platOffset,FALSE);
				m_bStatusBar = FALSE;
				m_strStatusBarInfo1.Format(_T("通信获取目标平台坐标失败"));
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
				return FALSE;
			}
			else
			{
				int nPosIndex=0;
				CMarkPlatformPos mpTargetMarkPos;
				mpTargetMarkPos = m_pAlignerTool->GetTargetMarkPlatformPos();
				for (int i=0;i<mpTargetMarkPos.m_vbOK.size();i++)
				{
					mpTargetMarkPos.m_vbOK.at(i) = TRUE;
				}
				for(int i=0;i<vnPosIndex.size();i++)
				{
					nPosIndex = vnPosIndex.at(i);
					if (nPosIndex<GetPosNum()/2 || nPosIndex>=GetPosNum())
					{
						ReportAlignResultFACO(platOffset,FALSE);
						m_bStatusBar = FALSE;
						m_strStatusBarInfo1 = _T("通信获取目标平台坐标失败");// 
						m_strStatusBarInfo2 = _T("");//
						SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
						return FALSE;
					}
					SetTargetPlatformPos(&vTargetPlatAxisPos.at(i),nPosIndex);
					SetTempTargetPlatformAxisPos(nPosIndex,&vTargetPlatAxisPos.at(i));
					mpTargetMarkPos.SetMarkPlatformPos(nPosIndex,TRUE,vTargetCoordPos.at(i));
				}
				m_pAlignerTool->SetTargetMarkPlatformPos(mpTargetMarkPos);
			}
		}
		else
		{
			m_pAlignerTool->SetIsReadTargetPlatformPos(FALSE);
			// 检查目标Mark是否已成功定位
			if (eTargetOnline == curProductData.m_pAlignerParam->m_eTargetMarkType)
			{
				if (FALSE == m_bTargetMarkSearchSucceed)
				{
					ReportAlignResultFACO(platOffset,FALSE);

					m_bStatusBar = FALSE;
					m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_PLEASE_KEEP_TARGET_SEARCH_SUCCEED_FIRST);
					m_strStatusBarInfo2 = _T("");
					SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();		

					return FALSE;
				}
			}
		}
		// 检查对象Mark是否已成功定位
		if (eObjectBench != curProductData.m_pAlignerParam->m_eObjectMarkType)
		{
			if (FALSE == m_bObjectMarkSearchSucceed)
			{
				ReportAlignResultFACO(platOffset,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_CONFIRM_OBJECT_SEARCH_SUCCESS);//_T("请先保证实时对象Mark定位成功" );
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();	

				return FALSE;
			}	

			//			CalculateObjectDistance(); 
			if (!CheckObjectDistance())
			{
				ReportAlignResultFACO(platOffset,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_OBJECT_DIS_OUT_RANGE);
				m_strStatusBarInfo2 = _T("");
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

				return FALSE;
			}
		}

		//		CalculateTargetDistance(); 
		if (!CheckTargetDistance())
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_DIS_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		if (!CheckTargetAngle())
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_TARGET_ANGLE_OUT_RANGE);
			m_strStatusBarInfo2 = _T("");
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}




		if (optionInfo.m_bEnableAlignBenchCenter == TRUE)
		{
			// 执行对位计算
			// 设置图像中心十字基准目标
			SetDefaultCrossBenchTargetSearchMarkPos(TRUE);
			m_pAlignerTool->SetTargetPlatformPos(m_vpCrossBenchPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpCrossBenchMarkImagePos);				

			// 执行对位
			m_pAlignerTool->SetInnerAlignBench(TRUE);	// 设置为内部图像十字中心基准对位有效
			if(FALSE == ExecuteAlign())
			{
				m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效

				// 设置实时的目标
				m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
				m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);


				ReportAlignResultFACO(platOffset,FALSE);

				m_bStatusBar = FALSE;
				m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
				//				m_strStatusBarInfo2 = _T("");
				m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
				SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
				PostMessageUpdateStatusBarInfo();		

				//				SaveCurAllCameraChannelSearchImg();
				return FALSE;     
			}
			pBenchPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();
			cpBenchOffset = GetAlignPlatformPosOffset();


			m_pAlignerTool->SetInnerAlignBench(FALSE);	// 设置为内部图像十字中心基准对位无效
			// 设置实时的目标
			m_pAlignerTool->SetTargetPlatformPos(m_vpTargetPlatformAxisPos);
			m_pAlignerTool->SetTargetMarkSearchResults(m_mpTargetMarkImagePos);		
		}

		// 执行对位计算
		if(FALSE == ExecuteAlign())
		{
			ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_EXCUTE_ALIGN_CALCULATE_FAILED);
			//			m_strStatusBarInfo2 = _T("");
			m_strStatusBarInfo2 = m_pAlignerTool->GetAlignErrInfo();
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);
			PostMessageUpdateStatusBarInfo();		

			//			SaveCurAllCameraChannelSearchImg();
			return FALSE;     
		}

		// 更新主界面对位精度、次数、对位总时间
		CCoordPos cpProduct = GetAlignProductOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpProduct.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpProduct.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		}

		m_apAlignerProcesInfo.dXOffset  = cpProduct.m_dPosX;  
		m_apAlignerProcesInfo.dYOffset  = cpProduct.m_dPosY;
		m_apAlignerProcesInfo.dDOffset  = cpProduct.m_dAngle;

		CCoordPos cp = GetAlignPlatformOffset();
		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cp.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cp.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();
		}

		m_apAlignerProcesInfo.nTimes  = 1;

		m_apAlignerProcesInfo.dXMove  = cp.m_dPosX;  
		m_apAlignerProcesInfo.dYMove  = cp.m_dPosY;
		m_apAlignerProcesInfo.dDMove  = cp.m_dAngle;
		m_apAlignerProcesInfo.dTime = stAlignTimer.GetTimeMilli(TRUE);

		dAlignTime=m_apAlignerProcesInfo.dTime;

		PostMessageUpdateAlignerProcessInfo();	

		//if (fabs(cp.GetPosX()) > optionInfo.m_dAxisMoveMaxX
		//	|| fabs(cp.GetPosY()) > optionInfo.m_dAxisMoveMaxY
		//	|| fabs(cp.GetAngle()) > optionInfo.m_dAxisMoveMaxD)
		if(IsAxisMoveOverRun(cp))
		{

			CPlatformXYDAxisPos* pPlatformXYDAxisPos = NULL;
			pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();


			CCoordPos cpOffset;
			cpOffset = GetAlignPlatformPosOffset();
			if (pAlignerParam->GetEnableAlnTargetOffset())
			{
				cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
				cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

				AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
			}

			ReportAlignResultFACO(cpOffset,FALSE,pPlatformXYDAxisPos);

			// ReportAlignResultFACO(platOffset,FALSE);

			m_bStatusBar = FALSE;
			m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_PLATFORM_MOVE_OVERFLOW);//.Format(_T("平台轴移动量超过设定的最大可移动量"));
			m_strStatusBarInfo2.Format(_T(""));
			SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

			return FALSE;
		}

		// 记录对位精度
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerPrecision)
		{
			CString strTemp;

			CString strOut;					
			strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_FINAL_ALIGN_ACCURACY), m_apAlignerProcesInfo.dXMove, m_apAlignerProcesInfo.dYMove, m_apAlignerProcesInfo.dDMove);
			strOut = strTemp + strOut;


			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}

		// 记录对位时间
		if (m_pVisionASMConfig->m_DataRecord.m_bAlignerTime)
		{
			CString strTemp;

			CString strOut;						
			strOut.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_DR_ALIGN_ALL_TIMES_AND_ALL_TIME), 0, dAlignTime);
			strOut = strTemp + strOut;

			VisionAlignLogRecord(m_strAlignProcessData, _T("\n"), FALSE);
			VisionAlignLogRecord(m_strAlignProcessData, strOut);
		}	

		pPlatformXYDAxisPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

		CCoordPos cpOffset;
		cpOffset = GetAlignPlatformPosOffset();

		if (pAlignerParam->GetEnableAlnTargetOffset())
		{
			cpOffset.m_dPosX+=pAlignerParam->GetAlnTargetOffsetX();
			cpOffset.m_dPosY+=pAlignerParam->GetAlnTargetOffsetY();

			AddLastTargetOffsetForAln(pPlatformXYDAxisPos);
		}

		vcpOffset.push_back(cpOffset);
		if (pAlignerParam->GetAlignAccordingToPickPlatformEnable())
		{
			CCoordPos cpOffsetPickResive;
			cpOffsetPickResive = GetAlignPlatformPickRevise();
			vcpReviseOffset.push_back(cpOffsetPickResive);
		}

		// 		if (!pAlignerParam->GetAlignAccordingToPickPlatformEnable())
		// 		{
		// 
		// 			ReportAlignResultFACO(cpOffset,TRUE,pPlatformXYDAxisPos, cpBenchOffset, pBenchPlatformXYDAxisPos);
		// 		}
		// 		else
		// 		{
		// 	CCoordPos cpOffsetPickResive;
		//	cpOffsetPickResive = GetAlignPlatformPickRevise();
		// 			ReportAlignResultFACO(cpOffset, cpOffsetPickResive, TRUE, pPlatformXYDAxisPos, cpBenchOffset, pBenchPlatformXYDAxisPos);
		// 		}
	}


	m_bStatusBar = TRUE;
	m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_SUCCEED);	
	m_strStatusBarInfo2.Format(GetSysInfoString(m_psaSysInfoStrings,IDS_SB_ALIGN_TIMES_AND_TIME), m_apAlignerProcesInfo.nTimes, dAlignTime);
	SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();

	ReportAlignMulResultFACO(vcpOffset, TRUE, pPlatformXYDAxisPos, cpBenchOffset, pBenchPlatformXYDAxisPos);

	return TRUE;  
}


// PB 2013.05.28
// 读寄存器数据
// strRegAddr 寄存器地址
// nReadNum   读的数量
// vReceiveData 收到的寄存器数据（8位整型，其中1位符号位，7位数据位）
BOOL vcXYDVisionAlign::ReadRegData( CString strRegAddr, int nReadNum, std::vector<int> &vnReceiveData)
{	
	if (0)
	{
		if (nReadNum != 3)
		{	// For MC4CommRecord

			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			strRecord.Format(_T("Begin ReadRegData<int>: \n(\n"));
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}

	}

	CString strInfo;
	// 打包“读寄存器”指令
	if (!m_XYDCommProtocol.PackReadRegInfo(strInfo, strRegAddr, nReadNum))
	{
		return FALSE;
	}	

	// 发送“读寄存器”指令
	if (FALSE == SendCommInfo(strInfo))	
	{
		if (0)
		{
			if (nReadNum != 3)
			{	// For MC4CommRecord
				FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
				CString strRecord;
				strRecord.Format(_T("SendCommInfo failed...  [FALSE]\n) // End ReadRegData<int> \n"));
				fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
				fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
			}
		}
		return FALSE;	
	}
	if (0)
	{
		if (nReadNum != 3)
		{	// For MC4CommRecord
			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			strRecord.Format(_T("SendCommInfo: RegAddr = %s, ReadNum = %d [OK]\n"), strRegAddr, nReadNum);
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}
	}
	// 等待响应
	BOOL bReceived;
	CString strReceived;
	scTimer tTimer;

	tTimer.Reset();
	bReceived = ReceiveCommInfo(strReceived);

	while (FALSE == bReceived)
	{
		if (m_bStopNow == TRUE)
		{
			return FALSE;
		}

		bReceived = ReceiveCommInfo(strReceived);

		if (tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
		{
			if (0)
			{	// For MC4CommRecord
				FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
				CString strRecord;
				if ((nReadNum != 3))
				{
					strRecord.Format(_T("ReceiveCommInfo: Wait time out... [FALSE]\n) // End ReadRegData<int>\n"));
				}
				else
				{
					strRecord.Format(_T("ReadRegData<int> [OK]\n(\nReceiveCommInfo: Wait time out... [FALSE]\n) // End ReadRegData<int>\n"));
				}
				fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
				fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
			}
			return FALSE;
		}
		Sleep(2);
	}

	// 解析收到的响应
	if (!m_XYDCommProtocol.AnalyzeAswReadReg(strReceived, nReadNum, vnReceiveData))
	{
		if (0)
		{	// For MC4CommRecord
			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			if ((nReadNum != 3))
			{
				strRecord.Format(_T("ReceiveCommInfo: AnalyzeAswReadReg failed...<%s> [FALSE]\n) // End ReadRegData<int>\n"), strReceived);
			}
			else
			{
				strRecord.Format(_T("ReadRegData<int> [OK]\n(\nReceiveCommInfo: AnalyzeAswReadReg failed...<%s> [FALSE]\n) // End ReadRegData<int>\n"), strReceived);
			}
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}

		return FALSE;
	}

	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord, strTemp;
		if (nReadNum != 3)
		{
			strRecord.Format(_T("ReceiveCommInfo: AnalyzeAswReadReg result ( nReadNum = %d"), nReadNum);
			for (int i=0; i<vnReceiveData.size(); i++)
			{
				strTemp.Format(_T(", vnReceiveData[%d] = %d"), i, vnReceiveData[i]);
				strRecord += strTemp;
			}
		}
		else
		{
			strRecord.Format(_T("ReadRegData<int> [OK]\n(\nReceiveCommInfo: AnalyzeAswReadReg result ( nReadNum = %d"), nReadNum);
			strTemp.Format(_T(", vnReceiveData[0] = %d<%s>"), vnReceiveData[0], g_strPLCCMD[vnReceiveData[0]]);
			strRecord += strTemp;
			strTemp.Format(_T(", vnReceiveData[1] = %d<NOT_USED>"), vnReceiveData[1]);
			strRecord += strTemp;
			strTemp.Format(_T(", vnReceiveData[2] = %d<%s>"), vnReceiveData[2], g_strTrigerCMD[vnReceiveData[2]]);
			strRecord += strTemp;
		}
		strRecord += _T(") [OK]\n) // End ReadRegData<int> \n");
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}

	return TRUE;
}


// PB 2013.05.28
// 读寄存器数据
// strRegAddr 寄存器地址
// nReadNum   读的数量
// vReceiveData 收到的寄存器数据（8位浮点型，其中1位符号位，7位数据位，包括3位小数）
BOOL vcXYDVisionAlign::ReadRegData( CString strRegAddr, int nReadNum, std::vector<double> &vdReceiveData )
{
	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord;
		strRecord.Format(_T("Begin ReadRegData<double>: \n(\n"));
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}
	// 打包“读寄存器”指令
	CString strInfo;
	if (!m_XYDCommProtocol.PackReadRegInfo(strInfo, strRegAddr, nReadNum * 2))
	{
		return FALSE;
	}	

	// 发送“读寄存器”指令
	if (FALSE == SendCommInfo(strInfo))	
	{

		if (0)
		{	// For MC4CommRecord
			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			strRecord.Format(_T("SendCommInfo failed... [FALSE]\n) // End ReadRegData<double>\n"));
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}
		return FALSE;
	}

	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord;
		strRecord.Format(_T("SendCommInfo: RegAddr = %s, ReadNum = %d [OK]\n"), strRegAddr, nReadNum);
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}

	// 等待响应
	BOOL bReceived;
	CString strReceived;
	scTimer tTimer;

	tTimer.Reset();
	bReceived = ReceiveCommInfo(strReceived);

	while (FALSE == bReceived)
	{
		if (m_bStopNow == TRUE)
		{
			return FALSE;
		}

		bReceived = ReceiveCommInfo(strReceived);

		if (tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
		{
			if (0)
			{	// For MC4CommRecord
				FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
				CString strRecord;
				strRecord.Format(_T("ReceiveCommInfo: Wait time out... [FALSE]\n) // End ReadRegData<double>\n"));
				fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
				fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
			}
			return FALSE;
		}   
		Sleep(2);
	}

	// 解析收到的响应
	if (!m_XYDCommProtocol.AnalyzeAswReadReg(strReceived, nReadNum, vdReceiveData))
	{

		if (0)
		{	// For MC4CommRecord
			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			strRecord.Format(_T("ReceiveCommInfo: AnalyzeAswReadReg failed...<%s> [FALSE]\n) // End ReadRegData<double> \n"), strReceived);
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}
		return FALSE;
	}

	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord, strTemp;
		strRecord.Format(_T("ReceiveCommInfo: AnalyzeAswReadReg result ( nReadNum = %d"), nReadNum);
		for (int i=0; i<vdReceiveData.size(); i++)
		{
			strTemp.Format(_T(", vdReceiveData[%d] = %.6f"), i, vdReceiveData[i]);
			strRecord += strTemp;
		}
		strRecord += _T(") [OK]\n) // End ReadRegData<double> \n");
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}

	return TRUE;	
}

// PB 2013.05.28
// 写寄存器数据
// strRegAddr 寄存器地址
// nReadNum   写的数量
// vdWriteData 写的数据（8位浮点型，其中1位符号位，7位数据位，包括3位小数）
BOOL vcXYDVisionAlign::WriteRegData( CString strRegAddr, int nWriteNum, std::vector<double> vdWriteData )
{
	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord;
		strRecord.Format(_T("Begin WriteRegData<double>: \n(\n"));
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}
	// 打包“写寄存器”指令
	CString strInfo;
	if (!m_XYDCommProtocol.PackWriteRegInfo(strInfo, strRegAddr, nWriteNum, vdWriteData))
	{
		return FALSE;
	}	

	// 发送“写寄存器”指令
	if (FALSE == SendCommInfo(strInfo))	
	{
		if (0)
		{	// For MC4CommRecord
			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			strRecord.Format(_T("SendCommInfo failed... [FALSE]\n) // End WriteRegData<double>\n"));
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}
		return FALSE;
	}

	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord, strTemp;
		strRecord.Format(_T("SendCommInfo: ( RegAddr = %s, WriteNum = %d"), strRegAddr, nWriteNum);
		for (int i=0; i<vdWriteData.size(); i++)
		{
			strTemp.Format(_T(", vdWriteData[%d] = %.6f"), i, vdWriteData[i]);
			strRecord += strTemp;
		}
		strRecord += _T(") [OK]\n");
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}

	// 等待响应
	BOOL bReceived;
	CString strReceived;
	scTimer tTimer;

	tTimer.Reset();
	bReceived = ReceiveCommInfo(strReceived);

	while (FALSE == bReceived)
	{
		if (m_bStopNow == TRUE)
		{
			return FALSE;
		}

		bReceived = ReceiveCommInfo(strReceived);

		if (tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
		{	
			if (0)
			{	// For MC4CommRecord
				FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
				CString strRecord;
				strRecord.Format(_T("ReceiveCommInfo: Wait time out... [FALSE]\n) // End WriteRegData<double>\n"));
				fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
				fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
			}
			return FALSE;
		}   
		Sleep(2);
	}

	// 解析收到的响应
	if (!m_XYDCommProtocol.AnalyzeAswWriteReg(strReceived))
	{
		if (0)
		{	// For MC4CommRecord
			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			strRecord.Format(_T("ReceiveCommInfo: AnalyzeAswWriteReg failed...<%s> [FALSE]\n) // End WriteRegData<double> \n"), strReceived);
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}
		return FALSE;
	}

	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord;
		strRecord.Format(_T("ReceiveCommInfo: AnalyzeAswWriteReg result [OK]\n) // End WriteRegData<double> \n"));
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}

	return TRUE;
}

// PB 2013.05.28
// 写寄存器数据
// strRegAddr 寄存器地址
// nReadNum   写的数量
// vnWriteData 写的数据（8位整型，其中1位符号位，7位数据位）
BOOL vcXYDVisionAlign::WriteRegData( CString strRegAddr, int nWriteNum, std::vector<int> vnWriteData )
{
	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord;
		strRecord.Format(_T("Begin WriteRegData<int>: \n(\n"));
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}
	// 打包“写寄存器”指令
	CString strInfo;
	if (!m_XYDCommProtocol.PackWriteRegInfo(strInfo, strRegAddr, nWriteNum, vnWriteData))
	{
		return FALSE;
	}	

	// 发送“写寄存器”指令
	if (FALSE == SendCommInfo(strInfo))		
	{
		if (0)
		{	// For MC4CommRecord
			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			strRecord.Format(_T("SendCommInfo failed... [FALSE]\n) // End WriteRegData<int> \n"));
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}
		return FALSE;	
	}

	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord, strTemp;
		strRecord.Format(_T("SendCommInfo: ( RegAddr = %s, WriteNum = %d"), strRegAddr, nWriteNum);
		for (int i=0; i<vnWriteData.size(); i++)
		{
			strTemp.Format(_T(", vnWriteData[%d] = %d"), i, vnWriteData[i]);
			strRecord += strTemp;
		}
		strRecord += _T(") [OK]\n");
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}

	// 等待响应
	BOOL bReceived;
	CString strReceived;
	scTimer tTimer;

	tTimer.Reset();
	bReceived = ReceiveCommInfo(strReceived);

	while (FALSE == bReceived)
	{
		if (m_bStopNow == TRUE)
		{
			return FALSE;
		}

		bReceived = ReceiveCommInfo(strReceived);

		if (tTimer.GetTimeMilli(FALSE) >= COMM_WAIT_TIME)
		{			
			if (0)
			{	// For MC4CommRecord
				FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
				CString strRecord;
				strRecord.Format(_T("ReceiveCommInfo: Wait time out... [FALSE]\n) // End WriteRegData<int> \n"));
				fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
				fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
			}
			return FALSE;
		}   
		Sleep(2);
	}

	// 解析收到的响应
	if (!m_XYDCommProtocol.AnalyzeAswWriteReg(strReceived))
	{
		if (0)
		{	// For MC4CommRecord
			FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
			CString strRecord;
			strRecord.Format(_T("ReceiveCommInfo: AnalyzeAswWriteReg failed...<%s> [FALSE]\n) // End WriteRegData<int> \n"), strReceived);
			fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
			fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
		}
		return FALSE;
	}

	if (0)
	{	// For MC4CommRecord
		FILE *fStream = _tfopen(m_strDataRecord + _T("\\MC4CommRecord.txt"), _T("a+t"));
		CString strRecord;
		strRecord.Format(_T("ReceiveCommInfo: AnalyzeAswWriteReg result [OK]\n) // End WriteRegData<int> \n"));
		fwrite(strRecord, sizeof(TCHAR), strRecord.GetLength(), fStream);
		fclose(fStream);CString strPath = m_strDataRecord + _T("\\MC4CommRecord.txt");VCRemoveFile(strPath);
	}
	return TRUE;
}

// 接收通信接口命令信息							
BOOL vcXYDVisionAlign::ReceiveComm(std::vector<int>& vnReceivedData)
{
	// 将串口内容清空
	CString strTemp;
	while(ReceiveCommInfo(strTemp))
	{

	}

	// 读取寄存器D*003912-D*003914
	if (!ReadRegData(PLC_CMD_DATA_REG, 3, vnReceivedData))
	{
		return FALSE;
	}

	// 判断动作指令是否触发
	if (vnReceivedData.at(2) == MC4_PLC_CMD_TRIGERED) // 目标平台指令触发
	{
		// 将目标平台指令触发寄存器置0
		return ClearPlcPlatformTrigger();
	}
	else
	{
		return FALSE;
	}
}

// BOOL vcXYDVisionAlign::BendingProductID(CString& strProductID)
// {
// 	std::vector<int> vnReceivedData;
// 	CString strSend;
// 	//打包读取寄存器
// 	if(!m_XYDCommProtocol.PackPlcReadQRCode(strSend))
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// 		m_strStatusBarInfo2 =  GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 
// 		return FALSE;
// 	}
// 
// 	// 发送读取命令，接收PLC回复
// 	BOOL bReceived;
// 	CString strInfo;
// 	CommStatus nCommStatus = eCommSucceed;
// 	bReceived = CommunicateSendReadRegStr(strSend, strInfo, nCommStatus);
// 	if (bReceived == FALSE || nCommStatus != eCommSucceed)
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		return FALSE;
// 	}
// 
// 	//解析读取的寄存器信息
// 	CmdAnsweredStatus answeredStatus = m_XYDCommProtocol.AnalyzeAswPlcReadQRCode(strInfo,vnReceivedData);
// 	if(answeredStatus != eAswSucceed)
// 	{
// 		m_bStatusBar = FALSE;
// 		m_strStatusBarInfo1 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_COMM_ERROR);
// 		m_strStatusBarInfo2 = GetSysInfoString(m_psaSysInfoStrings,IDS_SB_SAVE_2DCODE_FAIL);
// 		SetStatusBarInfo(m_bStatusBar,m_strStatusBarInfo1,m_strStatusBarInfo2);PostMessageUpdateStatusBarInfo();
// 		return FALSE;
// 	}
// 
// 	int nCodeLen = 9;	
// 	vector<int> vnRQCode;
// 	for(int i = 0 ; i < nCodeLen ; i++)
// 	{
// 		int nByte4 = (vnReceivedData[i]>>24)&0xff;
// 		int nByte3 = (vnReceivedData[i]>>16)&0xff;
// 		int nByte2 = (vnReceivedData[i]>>8)&0xff;
// 		int nByte1 = (vnReceivedData[i])&0xff;
// 		vnRQCode.push_back(nByte1);
// 		vnRQCode.push_back(nByte2);
// 		vnRQCode.push_back(nByte3);
// 		vnRQCode.push_back(nByte4);
// 	}
// 
// 	CString str2DCoedInfo = "";
// 	CString strtmp;
// 	for (int i=0;i<vnRQCode.size();i++)
// 	{
// 		int nData = vnRQCode.at(i);
// 
// 		if(nData>=0 && nData<128)
// 		{
// 			char ch = (char)nData;
// 			CString strchar(ch);
// 			strtmp = strchar;
// 		}
// 		else
// 		{
// 			strtmp = "？";
// 		}
// 
// 		str2DCoedInfo+=strtmp;
// 	}
// 
// 	strProductID = str2DCoedInfo;
// 
// 	return TRUE;
// }
