// vsBaseAlignTool.cpp: implementation of the vcBaseAlignTool class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "vsBaseAlignTool.h"
//#include "SysPlatformInfo.h" 
#include "svIntersect.h"
#include "svHomography.h"
//#include "vsVisionAlignDef.h" //20160510增加对角补偿
//#include "vsBaseVisionAlign.h"
#include <algorithm>
#include <vector>
#include "vsAlignBase.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// *****多相机、多Mark坐标值（主要针对二维码应用）*********
void CMulMarkPos::SetMarkImagePosNum(int nCamPosNum)
{
	m_vvPos.resize(nCamPosNum);
}

int CMulMarkPos::GetMarkImagePosNum()
{
	return m_vvPos.size();
}

BOOL CMulMarkPos::SetMarkImagePos( int nIndex, std::vector<sc2Vector> vpos )
{
	ASSERT((nIndex >= 0) && (nIndex < m_vvPos.size()));
	if ((nIndex < 0) || (nIndex >= m_vvPos.size()))
	{
		return FALSE;
	}
	else
	{		
		m_vvPos[nIndex] = vpos;
		return TRUE;
	}
}

std::vector<sc2Vector> CMulMarkPos::GetMarkImagePos( int nIndex )
{
	ASSERT((nIndex >= 0) && (nIndex < m_vvPos.size()));
	if ((nIndex < 0) || (nIndex >= m_vvPos.size()))
	{
		std::vector<sc2Vector> vpos;
		return vpos;
	}
	else
	{		
		return m_vvPos.at(nIndex);
	}

}


// ******************多相机Mark的图像坐标值*******************
void CMarkImagePos::SetMarkImagePosNum( int nNum )
{
	m_vPos.resize(nNum);
	m_vbOK.resize(nNum);
}

int CMarkImagePos::GetMarkImagePosNum()
{
	return m_vPos.size();
}

void CMarkImagePos::Reset()
{
	m_vPos.clear();
	m_vbOK.clear();
}

BOOL CMarkImagePos::SetMarkImagePos( int nIndex, BOOL bOK, CCoordPos pos )
{
	ASSERT((nIndex >= 0) && (nIndex < m_vPos.size()));
	if ((nIndex < 0) || (nIndex >= m_vPos.size()))
	{
		return FALSE;
	}
	else
	{		
		m_vPos.at(nIndex) = pos;
		m_vbOK.at(nIndex) = bOK;
		return TRUE;
	}
}

BOOL CMarkImagePos::GetIsMarkImagePosOK( int nIndex )
{
	ASSERT((nIndex >= 0) && (nIndex < m_vPos.size()));
	if ((nIndex < 0) || (nIndex >= m_vPos.size()))
	{
		return FALSE;
	}
	else
	{		
		return m_vbOK.at(nIndex);
	}
}

CCoordPos CMarkImagePos::GetMarkImagePos( int nIndex )
{
	ASSERT((nIndex >= 0) && (nIndex < m_vPos.size()));
	if ((nIndex < 0) || (nIndex >= m_vPos.size()))
	{
		CCoordPos pos;
		return pos;
	}
	else
	{		
		return m_vPos.at(nIndex);
	}
}

BOOL CMarkImagePos::IsAllMarkImagePosOK()
{
	for (int i=0; i<m_vPos.size(); i++)
	{
		if(FALSE == m_vbOK.at(i))	
			return FALSE;
	}
	return TRUE;
}

BOOL CMarkImagePos::IsAllMarkImagePosOK(std::vector<int> nPosIndex)
{
	for (int i=0; i<nPosIndex.size(); i++)
	{
		if(FALSE == m_vbOK.at(nPosIndex[i]))	
			return FALSE;
	}
	return TRUE;
}


// ******************多相机Mark的平台坐标值*******************
void CMarkPlatformPos::SetMarkPlatformPosNum( int nNum )
{
	m_vPos.resize(nNum);
	m_vbOK.resize(nNum);
}

int CMarkPlatformPos::GetMarkPlatformPosNum()
{
	return m_vPos.size();
}

void CMarkPlatformPos::Reset()
{
	m_vPos.clear();
	m_vbOK.clear();
}

BOOL CMarkPlatformPos::SetMarkPlatformPos( int nIndex, BOOL bOK, CCoordPos pos )
{
	ASSERT((nIndex >= 0) && (nIndex < m_vPos.size()));
	if ((nIndex < 0) || (nIndex >= m_vPos.size()))
	{
		return FALSE;
	}
	else
	{		
		m_vPos.at(nIndex) = pos;
		m_vbOK.at(nIndex) = bOK;
		return TRUE;
	}
}

BOOL CMarkPlatformPos::GetIsMarkPlatformPosOK( int nIndex )
{
	ASSERT((nIndex >= 0) && (nIndex < m_vPos.size()));
	if ((nIndex < 0) || (nIndex >= m_vPos.size()))
	{
		return FALSE;
	}
	else
	{		
		return m_vbOK.at(nIndex);
	}
}

CCoordPos CMarkPlatformPos::GetMarkPlatformPos( int nIndex )
{
	ASSERT((nIndex >= 0) && (nIndex < m_vPos.size()));
	if ((nIndex < 0) || (nIndex >= m_vPos.size()))
	{
		CCoordPos pos;
		return pos;
	}
	else
	{		
		return m_vPos.at(nIndex);
	}
}

BOOL CMarkPlatformPos::IsAllMarkPlatformPosOK()
{
	for (int i=0; i<m_vPos.size(); i++)
	{
		if(FALSE == m_vbOK.at(i))	
			return FALSE;
	}
	return TRUE;	
}

CMarkPlatformPos& CMarkPlatformPos:: operator = (const CMarkPlatformPos& lSR)
{
	if (this == &lSR)
	{
		return *this;
	}

	m_vPos.clear();
	for (int i=0; i<lSR.m_vPos.size(); i++)
	{
		m_vPos.push_back(lSR.m_vPos.at(i));			
	}

	m_vbOK.clear();
	for (int j=0; j<lSR.m_vbOK.size(); j++)
	{
		m_vbOK.push_back(lSR.m_vbOK.at(j));
	}

	return *this;
}

/************************************************************************/
/*				 scBaseAlignerTool　implementaions		                */
/************************************************************************/


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

vcBaseAlignTool::vcBaseAlignTool()
{
	m_pVisionAlignerTool = NULL;

	m_HomographyDOF=eAuto;

//	m_nObjectPositionNum = 2;
// 	m_nTargetPositionNum = 2;
// 	m_nTargetPositionVirtualMode = 0;
// 	m_nObjectPositionVirtualMode = 0;
// 	m_bEnableTargetPositionVirtualMode = FALSE;
// 	m_bEnableObjectPositionVirtualMode = FALSE;
// 	m_bTargetPositionDirectionMode	= 0;		// 目标位置方向模式: 0：位置56水平；1：位置56竖直；
// 	m_bObjectPositionDirectionMode	= 0;		// 对象位置方向模式: 0：位置12水平；1：位置12竖直；


	m_nPlatformIndex = 0;
	//标定参数
	m_pPlatformParam = NULL;
	m_pCamPlatformInfo = NULL;
	m_PlatformAxisPos = NULL;
	m_PlatformRefineAxisPos = NULL;
//	m_pTargetPlatformAxisPos = NULL;
//	m_pObjectPlatformAxisPos = NULL;
	m_pVirtualPlatformAxisPos = NULL;
	m_pPlatformPos = NULL;



	//对位参数
//	m_nAlignerCalibInfoNum = 0;
/*	m_AlignermentTimes = 0;*/
	m_bIsAlignerSuccess = FALSE;
	m_iMarkNum = 0;
	m_nCamNum = 0;
//	m_bIsRefine = FALSE;
	m_bIsRefineSatisfied = FALSE;

	m_PlatformCalibType = ePlatformCalib9Point;
//	m_targetAlignResultMode = eAlignerResultOK; //iyo
//	m_objectAlignResultMode = eAlignerResultOK; //iyo
//	m_PointMethodType = eAligner1234_1234;  //iyo

	m_eAlignerTargetMoveType = eTargetNoMove;
	m_eAlignerObjectMoveType = eObjectMoveByPlatform;
	m_bTargetObjectCamSeparate = FALSE;
//	m_bTargetGuanLianUse4Points = FALSE;
	m_bUseAlignFAHLex = FALSE;                      //iyo
	//m_bCalibSendAbsPos   = TRUE;
	m_bCalibSendRelativePos = FALSE;
	m_bTargetCalibUseBoard = FALSE;
    m_bTargetUseFixedVirtualCoordinates = FALSE;
	m_bTarObjCamSepNoAxisCalib = FALSE;
	m_bTarObjCamSepAutoCalibTar = FALSE;
	
	//lzk 0407
	m_bEnableTargetAndObjectPositionVirtualMode = FALSE;
	
	m_eTarAutoCalibAlignMode = eAlignOnObject;

	m_bInnerAlignBench	= FALSE;

	m_eMidPlatformType = ePlatformXYD;

//	m_bUsePreTargetPos = FALSE;
	for (int i=0;i<6;i++)
	{
		m_dTargetX[i]=0;			
		m_dTargetY[i]=0;
	}
	m_dDAngle = 0;

	m_bPlatformPick = FALSE;
	m_ePickCamPlatformType = ePickCamPlatformSepFix;



	m_vCalibBoardSize = sc2Vector(1.0, 1.0);

	m_bLogRecordEnable = FALSE;
	
	m_bCalibrateChangeXDirection = FALSE;
	m_bCalibrateChangeYDirection = FALSE;
	m_bCalibrateChangeDDirection = FALSE;

	m_bEnablePickPosUpdate = FALSE;

	m_bEnableMultiCalibExtension = FALSE;	// 启用单产品多标定扩展
	m_nMultiCalibExtensionMaxNum = 0;	// 扩展数量
	m_nAlignReservedIndex = 10;			// 保留序号
	m_nAlignBenchOffsetIndex = -1;		// 基准居中对位补偿序号
	m_nAlignnExProductIndex = 0;		// 扩展产品序号

//	m_bPlatformTarCamWithDiffObjCam = FALSE;

//	m_vSpecialPlatformAxisPos.resize(8,NULL);

	m_TempPlatformPos = CCoordPos(0, 0, 0);
	m_nAlnIndex = 0;

	m_bReadTargetPlatformPos = FALSE;
//	m_HomographyDOF=eAuto;

//	m_vCorrationMarkPlatformPos.clear();

//	strRecordFileFullPathLog = _T("D:\\VisionASMLog\\");

	m_nAlignErrNum = 0;
	m_bBendAlignProcess = TRUE;
	m_bEnableKeyenceCode = FALSE;
}

vcBaseAlignTool::~vcBaseAlignTool()
{
	//标定参数
	if (m_pPlatformParam != NULL)
	{
		delete m_pPlatformParam;
		m_pPlatformParam = NULL;
	}

	if (m_pCamPlatformInfo != NULL)
	{
		delete m_pCamPlatformInfo;
		m_pCamPlatformInfo = NULL;
	}

	if (m_PlatformAxisPos != NULL)
	{
		delete m_PlatformAxisPos;
		m_PlatformAxisPos = NULL;
	}

	if (m_PlatformRefineAxisPos != NULL)
	{
		delete m_PlatformRefineAxisPos;
		m_PlatformRefineAxisPos = NULL;
	}

	int i=0;
	for (i=0; i<m_vpCalibrateParam.size();i++)
	{
		if (m_vpCalibrateParam.at(i) != NULL)
		{
			delete m_vpCalibrateParam.at(i);
			m_vpCalibrateParam.at(i) = NULL;
		}
	}


	for (i=0; i<m_vPlatformAxisPos.size();i++)
	{
		if (m_vPlatformAxisPos.at(i) != NULL)
		{
			delete m_vPlatformAxisPos.at(i);
			m_vPlatformAxisPos.at(i) = NULL;
		}
	}

	for (i=0; i<m_vPlatformRefineAxisPos.size();i++)
	{
		if (m_vPlatformRefineAxisPos.at(i) != NULL)
		{
			delete m_vPlatformRefineAxisPos.at(i);
			m_vPlatformRefineAxisPos.at(i) = NULL;
		}
	}


	for (  i=0; i<m_vCamPlatformInitAxisPos.size();i++)
	{
		if (m_vCamPlatformInitAxisPos.at(i) != NULL)
		{
			delete m_vCamPlatformInitAxisPos.at(i);
			m_vCamPlatformInitAxisPos.at(i) = NULL;
		}
	}

	for( i = 0; i < m_vCamAxisPlatformInitAxisPos.size() ; i++)
	{
		if(m_vCamAxisPlatformInitAxisPos.at(i) != NULL)
		{
			delete m_vCamAxisPlatformInitAxisPos.at(i);
			m_vCamAxisPlatformInitAxisPos.at(i) = NULL;
		}
	}

	for ( i=0; i<m_vCamPlatformAxisPos.size();i++)
	{
		for (int j=0; j<m_vCamPlatformAxisPos.at(i).size(); j++)
		{		
				if (m_vCamPlatformAxisPos.at(i).at(j) != NULL)
			{
				delete m_vCamPlatformAxisPos.at(i).at(j);
				m_vCamPlatformAxisPos.at(i).at(j) = NULL;
			}
		}
		m_vCamPlatformAxisPos.at(i).clear();
	}


	for ( i=0; i<m_vCalibratedInfos.size();i++)
	{
		if (m_vCalibratedInfos.at(i) != NULL)
		{
			delete m_vCalibratedInfos.at(i);
			m_vCalibratedInfos.at(i) = NULL;
		}
	}

	for ( i=0; i<m_vAlignerCalibInfos.size();i++)
	{
		if (m_vAlignerCalibInfos.at(i) != NULL)
		{
			delete m_vAlignerCalibInfos.at(i);
			m_vAlignerCalibInfos.at(i) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();
	for (i=0;i<CALIBPOS;i++)
	{
		m_vCalibPlatformMoveResults[i].clear();
	}

	for (i=0;i<CALIBPOS;i++)
	{
		m_vCalibBoardResults[i].clear();
	}
	
	m_vCalibRefinePlatformCoord.clear();
	m_vCalibRefineImageCoord.clear();
	m_vCamPlatformInitAxisPos.clear();
	m_vCamAxisPlatformInitAxisPos.clear();
	m_vCamPlatformAxisPos.clear();
	m_vCalibCameraMoveResults.clear();
	m_vCalibratedInfos.clear();
	m_vAlignerCalibInfos.clear();


// 	for (i=0;i<m_vSpecialPlatformAxisPos.size();i++)
// 	{
// 		if (m_vSpecialPlatformAxisPos.at(i) != NULL)
// 		{
// 			delete m_vSpecialPlatformAxisPos.at(i);
// 			m_vSpecialPlatformAxisPos.at(i) = NULL;
// 		}
// 	}
// 	m_vSpecialPlatformAxisPos.clear();


	//对位参数
	
	for (i=0;i<m_pTargetPlatformAxisPos.size();i++)
	{
		if (m_pTargetPlatformAxisPos.at(i) != NULL)
		{
			delete m_pTargetPlatformAxisPos.at(i);
			m_pTargetPlatformAxisPos.at(i) = NULL;
		}
	}
	m_pTargetPlatformAxisPos.clear();
	


	for (i=0;i<m_pObjectPlatformAxisPos.size();i++)
	{
		if (m_pObjectPlatformAxisPos.at(i) != NULL)
		{
			delete m_pObjectPlatformAxisPos.at(i);
			m_pObjectPlatformAxisPos.at(i) = NULL;
		}
	}
	m_pObjectPlatformAxisPos.clear();
	
	if (m_pVirtualPlatformAxisPos != NULL)
	{
		delete m_pVirtualPlatformAxisPos;
		m_pVirtualPlatformAxisPos = NULL;
	}


	for (i=0;i<m_vpVirtualPlatformAxisPos.size();i++)
	{
		if (m_vpVirtualPlatformAxisPos.at(i) != NULL)
		{
			delete m_vpVirtualPlatformAxisPos.at(i);
			m_vpVirtualPlatformAxisPos.at(i) = NULL;
		}
	}
	m_vpVirtualPlatformAxisPos.clear();

	if (m_pPlatformPos != NULL)
	{
		delete m_pPlatformPos;
		m_pPlatformPos = NULL;
	}



// 	if (m_PlatformRefineAxisPos != NULL)
// 	{
// 		delete m_PlatformRefineAxisPos;
// 		m_PlatformRefineAxisPos = NULL;
// 	}
// 	if (m_PlatformAxisPos != NULL)
// 	{
// 		delete m_PlatformAxisPos;
// 		m_PlatformAxisPos = NULL;
// 	}

	for ( i=0; i<m_vTargetCamPlatformAxisPos.size();i++)
	{
		if (m_vTargetCamPlatformAxisPos.at(i) != NULL)
		{
			delete m_vTargetCamPlatformAxisPos.at(i);
			m_vTargetCamPlatformAxisPos.at(i) = NULL;
		}
	}
	for ( i=0; i<m_vObjectCamPlatformAxisPos.size();i++)
	{
		if (m_vObjectCamPlatformAxisPos.at(i) != NULL)
		{
			delete m_vObjectCamPlatformAxisPos.at(i);
			m_vObjectCamPlatformAxisPos.at(i) = NULL;
		}
	}
	for (i = 0 ; i < m_vObjectCamAxisPlatformAxisPos.size() ; i++)
	{
		if(m_vObjectCamAxisPlatformAxisPos.at(i) != NULL)
		{
			delete m_vObjectCamAxisPlatformAxisPos.at(i);
			m_vObjectCamAxisPlatformAxisPos.at(i) = 0;
		}
	}
	for (i = 0; i < m_vTargetCamAxisPlatformAxisPos.size() ; i++)
	{
		if(m_vTargetCamAxisPlatformAxisPos.at(i) != NULL)
		{
			delete m_vTargetCamAxisPlatformAxisPos.at(i);
			m_vTargetCamAxisPlatformAxisPos.at(i) = NULL;
		}
	}

	for (i = 0 ; i < m_vvpObjectCamPlatformAxisPosMultiEx.size() ; i++)
	{
		for (int j=0;j<m_vvpObjectCamPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if(m_vvpObjectCamPlatformAxisPosMultiEx.at(i).at(j) != NULL)
			{
				delete m_vvpObjectCamPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpObjectCamPlatformAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}

	}

	for (i = 0 ; i < m_vvpObjectCamAxisPlatformAxisPosMultiEx.size() ; i++)
	{
		for (int j=0;j<m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j) != NULL)
			{
				delete m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}

	}

	for (i = 0 ; i < m_vvpTargetCamPlatformAxisPosMultiEx.size() ; i++)
	{
		for (int j=0;j<m_vvpTargetCamPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if(m_vvpTargetCamPlatformAxisPosMultiEx.at(i).at(j) != NULL)
			{
				delete m_vvpTargetCamPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpTargetCamPlatformAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}

	}

	for (i = 0 ; i < m_vvpTargetCamAxisPlatformAxisPosMultiEx.size() ; i++)
	{
		for (int j=0;j<m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if(m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j) != NULL)
			{
				delete m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j) = NULL;
			}
		}

	}


	for ( i=0; i<m_vVirtualCamPlatformAxisPos.size();i++)
	{
		if (m_vVirtualCamPlatformAxisPos.at(i) != NULL)
		{
			delete m_vVirtualCamPlatformAxisPos.at(i);
			m_vVirtualCamPlatformAxisPos.at(i) = NULL;
		}
	}
	for ( i=0; i<m_vCamPlatformMovement.size();i++)
	{
		if (m_vCamPlatformMovement.at(i) != NULL)
		{
			delete m_vCamPlatformMovement.at(i);
			m_vCamPlatformMovement.at(i) = NULL;
		}
	}
	m_vAlignerCalibInfos.clear();
	m_vTargetCamPlatformAxisPos.clear();
	m_vObjectCamPlatformAxisPos.clear();
	m_vVirtualCamPlatformAxisPos.clear();
	m_vCamPlatformMovement.clear();
	m_vObjectCamAxisPlatformAxisPos.clear();
	m_vTargetCamAxisPlatformAxisPos.clear();


	for (int i=0;i<CALIBPOS;i++)
	{
		m_vvWholeDmCodeCalibMoveImageResults[i].clear();
		m_vvWholeDmCodeCalibMoveBoardResults[i].clear();
	}

}



// 设置平台序号
void vcBaseAlignTool::SetPlatformIndex(int nPlatformIndex)
{
	m_nPlatformIndex = nPlatformIndex;
}

int vcBaseAlignTool::GetPlatformIndex()
{
	return m_nPlatformIndex;
}

// 设置标定及对位时mark点的个数
void vcBaseAlignTool::SetMarkNum(int iNum)
{
	m_iMarkNum = iNum;
	m_vpCalibrateParam.resize(m_iMarkNum);
	m_vCamPlatformInitAxisPos.resize(m_iMarkNum);
	m_vCamAxisPlatformInitAxisPos.resize(m_iMarkNum);
	m_vTargetCamPlatformAxisPos.resize(m_iMarkNum);
	m_vObjectCamPlatformAxisPos.resize(m_iMarkNum);
	m_vTargetCamAxisPlatformAxisPos.resize(m_iMarkNum);
	m_vObjectCamAxisPlatformAxisPos.resize(m_iMarkNum);

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		m_vAlignerCalibInfos.resize(m_iMarkNum*(m_nMultiCalibExtensionMaxNum+1));	
		m_vCalibratedInfos.resize(m_iMarkNum*(m_nMultiCalibExtensionMaxNum+1));
	}
	else
	{
		m_vAlignerCalibInfos.resize(m_iMarkNum);
		m_vCalibratedInfos.resize(m_iMarkNum);
	}

	m_vCamPlatformMovement.resize(m_iMarkNum);
	m_vCamPlatformAxisPos.resize(m_iMarkNum);

	m_TargetMarkPlatformPos.m_vPos.resize(m_iMarkNum);
	m_TargetMarkPlatformPos.m_vbOK.resize(m_iMarkNum);
	m_ObjectMarkPlatformPos.m_vPos.resize(m_iMarkNum);
	m_ObjectMarkPlatformPos.m_vbOK.resize(m_iMarkNum);
	m_VirtualMarkPlatformPos.m_vPos.resize(m_iMarkNum);
	m_VirtualMarkPlatformPos.m_vbOK.resize(m_iMarkNum);

	m_ImageSizes.m_vPos.resize(m_iMarkNum);
	m_ImageSizes.m_vbOK.resize(m_iMarkNum);

}

// 设置相机的数量
void vcBaseAlignTool::SetCamNum(int nCamNum)
{
	m_nCamNum = nCamNum;
}

int	vcBaseAlignTool::GetCamNum()
{
	return m_nCamNum;
}

// 设置中间平台类型
void vcBaseAlignTool::SetMidPlatformType(PlatformType ePlatformType)
{
	m_eMidPlatformType = ePlatformType;
}

PlatformType vcBaseAlignTool::GetMidPlatformType()
{
	return m_eMidPlatformType;
}

// 设置目标移动类型
void vcBaseAlignTool::SetAlignerTargetMoveType(AlignerTargetMoveType eMoveType)
{
	m_eAlignerTargetMoveType = eMoveType;
}

AlignerTargetMoveType vcBaseAlignTool::GetAlignerTargetMoveType()
{
	return m_eAlignerTargetMoveType;
}

// 设置对象移动类型
void vcBaseAlignTool::SetAlignerObjectMoveType(AlignerObjectMoveType eMoveType)
{
	m_eAlignerObjectMoveType = eMoveType;
}

AlignerObjectMoveType vcBaseAlignTool::GetAlignerObjectMoveType()
{
	return m_eAlignerObjectMoveType;
}

// 设置目标相机和对象相机是否是独立的
void vcBaseAlignTool::SetTargetObjectCamSeparate(BOOL bTargetObjectCamSeparate)
{
	m_bTargetObjectCamSeparate = bTargetObjectCamSeparate;
}

BOOL vcBaseAlignTool::GetTargetObjectCamSeparate()
{
	return m_bTargetObjectCamSeparate;
}

// 设置目标相机和对象相机是各自独立时，标定目标位置时不读取平台轴位置
void vcBaseAlignTool::SetTarObjCamSepNoAxisCalib(BOOL bTarObjCamSepNoAxisCalib)
{
	m_bTarObjCamSepNoAxisCalib = bTarObjCamSepNoAxisCalib;
}

BOOL vcBaseAlignTool::GetTarObjCamSepNoAxisCalib()
{
	return m_bTarObjCamSepNoAxisCalib;
}

// 设置目标相机和对象相机是各自独立时，目标位置自动标定不关联
void vcBaseAlignTool::SetTarObjCamSepAutoCalibTar(BOOL bTarObjCamSepAutoCalibTar)
{
	m_bTarObjCamSepAutoCalibTar = bTarObjCamSepAutoCalibTar;
}

BOOL vcBaseAlignTool::GetTarObjCamSepAutoCalibTar()
{
	return m_bTarObjCamSepAutoCalibTar;
}

// 设置是否启用标定板关联
void vcBaseAlignTool::SetTargetCalibUseBoard(BOOL bTargetCalibUseBoard)
{
	m_bTargetCalibUseBoard = bTargetCalibUseBoard;
}

BOOL vcBaseAlignTool::GetTargetCalibUseBoard()
{
	return m_bTargetCalibUseBoard;
}

// 一组目标相机对应两组对象相机
// void vcBaseAlignTool::SetPlatformAlignTarCamWithDiffObjCam(BOOL bTarCamWithDifObjCam)
// {
// 	m_bPlatformTarCamWithDiffObjCam = bTarCamWithDifObjCam;
// }
// 
// BOOL vcBaseAlignTool::GetPlatformAlignTarCamWithDiffObjCam()
// {
// 	return m_bPlatformTarCamWithDiffObjCam;
// }

// 设置产品虚拟位置信息函数
void vcBaseAlignTool::SetEnablePositionVirtualMode(BOOL bEnablePositionVirtualMode)
{
	m_bEnableTargetAndObjectPositionVirtualMode = bEnablePositionVirtualMode;
}

BOOL vcBaseAlignTool::GetEnablePositionVirtualMode()
{
	return m_bEnableTargetAndObjectPositionVirtualMode;
}

// 设置标定时使用相对或绝对位置
//void vcBaseAlignTool::SetCalibSendAbsPos(BOOL bCalibSendAbsPos)
//{
//	m_bCalibSendAbsPos = bCalibSendAbsPos;
//}
//
//BOOL vcBaseAlignTool::GetCalibSendAbsPos()
//{
//	return m_bCalibSendAbsPos;
//}

void vcBaseAlignTool::SetCalibSendRelativePos(BOOL bCalibSendRelativePos)
{
	m_bCalibSendRelativePos = bCalibSendRelativePos;
}

BOOL vcBaseAlignTool::GetCalibSendRelativePos()
{
	return m_bCalibSendRelativePos;
}

// 设置标定过程中是否设置反置轴的方向
void vcBaseAlignTool::SetCalibrateChangeXYDDirection(BOOL bCalibrateChangeXDirection,BOOL bCalibrateChangeYDirection,BOOL bCalibrateChangeDDirection)
{
	m_bCalibrateChangeXDirection = bCalibrateChangeXDirection;
	m_bCalibrateChangeYDirection = bCalibrateChangeYDirection;
	m_bCalibrateChangeDDirection = bCalibrateChangeDDirection;
}

BOOL vcBaseAlignTool::GetCalibrateChangeXYDDirection(BOOL &bCalibrateChangeXDirection,BOOL &bCalibrateChangeYDirection,BOOL &bCalibrateChangeDDirection)
{
	bCalibrateChangeXDirection = m_bCalibrateChangeXDirection;
	bCalibrateChangeYDirection = m_bCalibrateChangeYDirection;
	bCalibrateChangeDDirection = m_bCalibrateChangeDDirection;
	return TRUE;
}

void vcBaseAlignTool::SetUseAlignFAHLex(BOOL bUseAlignFAHLex)
{
	m_bUseAlignFAHLex = bUseAlignFAHLex;
}

BOOL vcBaseAlignTool::GetUseAlignFAHLex()
{
	return m_bUseAlignFAHLex;
}

void vcBaseAlignTool::SetTargetUseFixedVirtualCoordinates(BOOL bTargetUseFixedVirtualCoordinates)
{
	m_bTargetUseFixedVirtualCoordinates = bTargetUseFixedVirtualCoordinates;
}

BOOL vcBaseAlignTool::GetTargetUseFixedVirtualCoordinates()
{
	return m_bTargetUseFixedVirtualCoordinates;
}

// 启用单产品多标定扩展	
void vcBaseAlignTool::SetEnableMultiCalibExtension(BOOL bEnableMultiCalibExtension)
{
	m_bEnableMultiCalibExtension = bEnableMultiCalibExtension;
}

BOOL vcBaseAlignTool::GetEnableMultiCalibExtension()
{
	return m_bEnableMultiCalibExtension;
}

void vcBaseAlignTool::SetMultiCalibExtensionMaxNum(int nMultiCalibExtensionMaxNum)
{
	m_nMultiCalibExtensionMaxNum = nMultiCalibExtensionMaxNum;
}

int vcBaseAlignTool::GetMultiCalibExtensionMaxNum()
{
	return m_nMultiCalibExtensionMaxNum;
}

// 设置是否为拾取系统
void vcBaseAlignTool::SetPlatformPick(BOOL bPlatformPick)
{
	m_bPlatformPick = bPlatformPick;
}

BOOL vcBaseAlignTool::GetPlatformPick()
{
	return m_bPlatformPick;
}

// 设置拾取系统中相机的安装方式
void vcBaseAlignTool::SetPickCamPlatformType(PickCamPlatformType ePickCamPlatformType)
{
	m_ePickCamPlatformType = ePickCamPlatformType;
}

PickCamPlatformType vcBaseAlignTool::GetPickCamPlatformType()
{
	return m_ePickCamPlatformType;
}



void vcBaseAlignTool::SetTarAutoCalibAlignMode(TargetAutoCalibAlignMode eTarAutoCalibAlignMode)
{
	m_eTarAutoCalibAlignMode = eTarAutoCalibAlignMode;
}

TargetAutoCalibAlignMode vcBaseAlignTool::GetTarAutoCalibAlignMode()
{
	return m_eTarAutoCalibAlignMode;
}

// 设置是否从PLC中读取的目标平台坐标（对象目标不在一台工控机时使用）
void vcBaseAlignTool::SetIsReadTargetPlatformPos(BOOL bEnable)
{
	m_bReadTargetPlatformPos = bEnable;
}


// 拾取时旋转中心位置修正
void vcBaseAlignTool::SetEnablePickPosUpdate(BOOL bEnablePickPosUpdate)
{
	m_bEnablePickPosUpdate = bEnablePickPosUpdate;
}

BOOL vcBaseAlignTool::GetEnablePickPosUpdate()
{
	return m_bEnablePickPosUpdate;
}

// 设置标定算法
BOOL vcBaseAlignTool::SetHomographyDOF(HomographyDOF dof)
{
	m_HomographyDOF=dof;
	if(m_HomographyDOF<eAuto||m_HomographyDOF>eProject)
	{
		m_HomographyDOF=eAuto;
	}
	return TRUE;
}

HomographyDOF vcBaseAlignTool::GetHomographyDOF()//获得标定算法
{
	return m_HomographyDOF;
}

// 设置标定参数
void vcBaseAlignTool::SetCalibParam(CCalibrateParam* sysCalibParam)
{
	m_CalibrateParam = sysCalibParam;
}

CCalibrateParam* vcBaseAlignTool::GetCalibParam()
{
	return m_CalibrateParam;
}

BOOL vcBaseAlignTool::SetCalibParams(std::vector<CCalibrateParam*> vpCalibParam)
{
	if (m_vpCalibrateParam.size() != vpCalibParam.size())
	{
		return FALSE;
	}

	for (int i=0; i<m_vpCalibrateParam.size(); i++)
	{
		if (m_vpCalibrateParam.at(i) != NULL)
		{
			delete m_vpCalibrateParam.at(i);
			m_vpCalibrateParam.at(i) = NULL;
		}
	}

	for (int j=0; j<m_vpCalibrateParam.size(); j++)
	{
		if (m_vpCalibrateParam.at(j) == NULL)
		{
			m_vpCalibrateParam.at(j) = new CCalibrateParam(*(vpCalibParam.at(j)));
		}
		else
		{
			*m_vpCalibrateParam.at(j) = *(vpCalibParam.at(j));
		}

	}

	return TRUE;
}

std::vector<CCalibrateParam*> vcBaseAlignTool::GetCalibParams()
{
	return m_vpCalibrateParam;
}

// 设置对位平台信息
void vcBaseAlignTool::SetPlatformParam(CPlatformInfo* pPlatformInfo)
{
	if (m_pPlatformParam != NULL)
	{
		delete m_pPlatformParam;
		m_pPlatformParam = NULL;
	}

	if (pPlatformInfo != NULL)
	{	
		//CPlatformXYDInfo platform = *(CPlatformXYDInfo*)pPlatformInfo;
		PlatformType platformType = pPlatformInfo->GetPlatformType();
		switch(platformType)
		{
		case ePlatformXYD:
			m_pPlatformParam = new CPlatformXYDInfo(*((CPlatformXYDInfo*)pPlatformInfo));
			break;
		case ePlatformXYPD:
			m_pPlatformParam = new CPlatformXYPDInfo(*((CPlatformXYPDInfo*)pPlatformInfo));
			break;
		case ePlatformX1X2Y:
			m_pPlatformParam = new CPlatformX1X2YInfo(*((CPlatformX1X2YInfo*)pPlatformInfo));
			break;
		case ePlatformXY1Y2:
			m_pPlatformParam = new CPlatformXY1Y2Info(*((CPlatformXY1Y2Info*)pPlatformInfo));
			break;
		case ePlatformXY:
			m_pPlatformParam = new CPlatformXYInfo(*((CPlatformXYInfo*)pPlatformInfo));
			break;
		case ePlatformX:
			m_pPlatformParam = new CPlatformXInfo(*((CPlatformXInfo*)pPlatformInfo));
			break;
		case ePlatformY:
			m_pPlatformParam = new CPlatformYInfo(*((CPlatformYInfo*)pPlatformInfo));
			break;
		case ePlatformYX1X2PD:
			m_pPlatformParam = new CPlatformYX1X2PDInfo(*((CPlatformYX1X2PDInfo*)pPlatformInfo));
			break;
		case ePlatformYDPX1X2:
			m_pPlatformParam = new CPlatformYDPX1X2Info(*((CPlatformYDPX1X2Info*)pPlatformInfo));
			break;
		case ePlatformDXY:
			m_pPlatformParam = new CPlatformDXYInfo(*((CPlatformDXYInfo*)pPlatformInfo));
			break;
		case ePlatformXDPY:
			m_pPlatformParam = new CPlatformXDPYInfo(*((CPlatformXDPYInfo*)pPlatformInfo));
			break;
		case ePlatformXDPY1:
			m_pPlatformParam = new CPlatformXDPY1Info(*((CPlatformXDPY1Info*)pPlatformInfo));
			break;
		default:
			break;
		}	
	}	
}

CPlatformInfo* vcBaseAlignTool::GetPlatformParam()
{
	return m_pPlatformParam;
}

// 设置相机平台信息
void vcBaseAlignTool::SetCamPlatformParam(CCamPlatformInfo* pCamPlatformInfo)
{	
	if (m_pCamPlatformInfo != NULL)
	{
		delete m_pCamPlatformInfo;
		m_pCamPlatformInfo = NULL;
	}
	if (pCamPlatformInfo != NULL)
	{		
		m_pCamPlatformInfo = new CCamPlatformInfo(*(pCamPlatformInfo));
	}
}

CCamPlatformInfo* vcBaseAlignTool::GetCamPlatformParam()
{
	return m_pCamPlatformInfo;
}

// 设置记录日志
void vcBaseAlignTool::SetLogRecordEnable(BOOL bEnable)
{
	m_bLogRecordEnable = bEnable;
}
BOOL vcBaseAlignTool::GetLogRecordEnalbe()
{
	return m_bLogRecordEnable;
}

// 设置产品对位信息
void vcBaseAlignTool::SetProductAlignerParam(CAlignerParam& alignerParam)
{
	m_AlignermentParam = alignerParam;
}

CAlignerParam* vcBaseAlignTool::GetProductAlignerParam()
{
	return &m_AlignermentParam;
}

void vcBaseAlignTool::SetCalibPlatformPos(CPlatformAxisPos* pPlatformAxisPos/*, int nIndex, BOOL bTarCamWithDiffObjCam*/)
{
// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam && bTarCamWithDiffObjCam)
// 	{
// 		if (pPlatformAxisPos != NULL)
// 		{
// 			if (m_vSpecialPlatformAxisPos.at(nIndex) != NULL)
// 			{
// 				delete m_vSpecialPlatformAxisPos.at(nIndex);
// 				m_vSpecialPlatformAxisPos.at(nIndex) = NULL;
// 			}
// 
// 			PlatformType platformType = pPlatformAxisPos->GetPlatformType();
// 			switch (platformType)
// 			{
// 			case ePlatformXYD:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformXYPD:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformXYPDAxisPos(*((CPlatformXYPDAxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformX1X2Y:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformX1X2YAxisPos(*((CPlatformX1X2YAxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformXY1Y2:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformXY1Y2AxisPos(*((CPlatformXY1Y2AxisPos*)pPlatformAxisPos));
// 				break;		
// 			case ePlatformXY:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformX:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformXAxisPos(*((CPlatformXAxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformYX1X2PD:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformYX1X2PDAxisPos(*((CPlatformYX1X2PDAxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformYDPX1X2:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformYDPX1X2AxisPos(*((CPlatformYDPX1X2AxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformDXY:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformDXYAxisPos(*((CPlatformDXYAxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformXDPY:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformXDPYAxisPos(*((CPlatformXDPYAxisPos*)pPlatformAxisPos));
// 				break;
// 			case ePlatformXDPY1:
// 				m_vSpecialPlatformAxisPos.at(nIndex) = new CPlatformXDPY1AxisPos(*((CPlatformXDPY1AxisPos*)pPlatformAxisPos));
// 				break;
// 			default:
// 				break;
// 			}	
// 		}
// 
// 		return;
// 	}

	if (pPlatformAxisPos != NULL)
	{
		if (m_PlatformAxisPos != NULL)
		{
			delete m_PlatformAxisPos;
			m_PlatformAxisPos = NULL;
		}

		PlatformType platformType = pPlatformAxisPos->GetPlatformType();
		switch (platformType)
		{
		case ePlatformXYD:
			m_PlatformAxisPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformXYPD:
			m_PlatformAxisPos = new CPlatformXYPDAxisPos(*((CPlatformXYPDAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformX1X2Y:
			m_PlatformAxisPos = new CPlatformX1X2YAxisPos(*((CPlatformX1X2YAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformXY1Y2:
			m_PlatformAxisPos = new CPlatformXY1Y2AxisPos(*((CPlatformXY1Y2AxisPos*)pPlatformAxisPos));
			break;		
		case ePlatformXY:
			m_PlatformAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformX:
			m_PlatformAxisPos = new CPlatformXAxisPos(*((CPlatformXAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformY:
			m_PlatformAxisPos = new CPlatformYAxisPos(*((CPlatformYAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformYX1X2PD:
			m_PlatformAxisPos = new CPlatformYX1X2PDAxisPos(*((CPlatformYX1X2PDAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformYDPX1X2:
			m_PlatformAxisPos = new CPlatformYDPX1X2AxisPos(*((CPlatformYDPX1X2AxisPos*)pPlatformAxisPos));
			break;
		case ePlatformDXY:
			m_PlatformAxisPos = new CPlatformDXYAxisPos(*((CPlatformDXYAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformXDPY:
			m_PlatformAxisPos = new CPlatformXDPYAxisPos(*((CPlatformXDPYAxisPos*)pPlatformAxisPos));
			break;
		case ePlatformXDPY1:
			m_PlatformAxisPos = new CPlatformXDPY1AxisPos(*((CPlatformXDPY1AxisPos*)pPlatformAxisPos));
			break;
		default:
			break;
		}	
	}
}

CPlatformAxisPos* vcBaseAlignTool::GetCalibPlatformPos(/*int nIndex*/)
{
// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		return m_vSpecialPlatformAxisPos.at(nIndex);
// 	}
// 	else
	{
		return m_PlatformAxisPos;
	}	
}




// 包含XYD平台拾取、XY平台拾取
int vcBaseAlignTool::GetCalibPlatformMovePosNum(int nMarkType)
{
	int nMovePosNun = 0;

	if (m_bPlatformPick == TRUE) 
	{
		if (m_ePickCamPlatformType == ePickCamPlatformSepFix)	// 相机固定安装
		{
			nMovePosNun = GetCalibPlatformXYDMovePosNum();

			if (ePlatformXY == m_eMidPlatformType)
			{
				nMovePosNun = GetCalibPlatformXYMovePosNum();
			}
		}
		else if (m_ePickCamPlatformType == ePickCamPlatformShareXY)	// 相机安装在XYD吸头平台的XY轴上
		{
		//	if (nMarkType == 0)
		//	{
		//		// 拾取并且是相机安装在拾取头平台上的
		//		nMovePosNun = GetCalibCenterPlatformPickMovePosNum();
		//	}
		//	else if (nMarkType == 1)
		//	{
		//		// 拾取并且是相机安装在拾取头平台上的
		//		nMovePosNun = GetCalibPlatformPickMovePosNum();
		//	}
			if (nMarkType == 1) // 旋转
			{
				// 拾取并且是相机安装在拾取头平台上的
				nMovePosNun = GetCalibCenterPlatformPickMovePosNum();
			}
			else if (nMarkType == 0) // 平移
			{
				// 拾取并且是相机安装在拾取头平台上的
				nMovePosNun = GetCalibPlatformPickMovePosNum();
			}
		}		
	}
	else
	{
		switch(m_eMidPlatformType)
		{
		case ePlatformXYD:
		case ePlatformX1X2Y:
		case ePlatformXY1Y2:
			{
				nMovePosNun = GetCalibPlatformXYDMovePosNum();
			}
			break;

		case ePlatformXY:
			{
				nMovePosNun = GetCalibPlatformXYMovePosNum();
			}
			break;

		case ePlatformXD:
			{
				nMovePosNun = GetCalibPlatformXDMovePosNum();
			}
			break;

		case ePlatformYD:
			{
				nMovePosNun = GetCalibPlatformYDMovePosNum();
			}
			break;

		case ePlatformXDPY:
			{
				nMovePosNun = GetCalibPlatformXDPYMovePosNum();
			}
			break;

		case ePlatformXDPY1:
			{
				nMovePosNun = GetCalibPlatformXDPY1MovePosNum();
			}
			break;

		case ePlatformXYPD:
			{
				if (nMarkType==0)
				{
					nMovePosNun = GetCalibPlatformXYPD_XYMovePosNum();
				}
				else if (nMarkType==1)
				{
					nMovePosNun = GetCalibPlatformXYPD_DMovePosNum();
				}
				else
				{
					nMovePosNun = 0;
				}
			}
			break;

		case ePlatformX:
			{
				nMovePosNun = GetCalibPlatformXMovePosNum();
			}
			break;

		case ePlatformY:
			{
				nMovePosNun = GetCalibPlatformYMovePosNum();
			}
			break;

		default:
			{
				nMovePosNun = 0;
			}
			break;
		}

// 		if (ePlatformXD == m_eMidPlatformType)
// 		{
// 			nMovePosNun = GetCalibPlatformXDMovePosNum();
// 		}
// 		else if (ePlatformYD == m_eMidPlatformType)
// 		{
// 			nMovePosNun = GetCalibPlatformYDMovePosNum();
// 		}
// 		else if (ePlatformXDPY == m_eMidPlatformType)
// 		{
// 			nMovePosNun = GetCalibPlatformXDPYMovePosNum();
// 		}
// 		else if (ePlatformXDPY1 == m_eMidPlatformType)
// 		{
// 			nMovePosNun = GetCalibPlatformXDPY1MovePosNum();
// 		}
// 		else if (ePlatformXYPD== m_eMidPlatformType)
// 		{
// 			if (nMarkType==0)
// 			{
// 				nMovePosNun = GetCalibPlatformXYPD_XYMovePosNum();
// 			}
// 			else if (nMarkType==1)
// 			{
// 				nMovePosNun = GetCalibPlatformXYPD_DMovePosNum();
// 			}
// 		}
// 		else if (ePlatformXY== m_eMidPlatformType)
// 		{
// 			nMovePosNun = GetCalibPlatformXYMovePosNum();
// 
// 		}
// 		else if (ePlatformX== m_eMidPlatformType)
// 		{
// 			nMovePosNun = GetCalibPlatformXMovePosNum();
// 
// 		}
// 		else
// 		{
// 			nMovePosNun = GetCalibPlatformXYDMovePosNum();
// 		}
	}

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformXYDMovePosNum()
{
	int nMovePosNun = 0;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		nMovePosNun = 12;
	}
	else
	{
		nMovePosNun = 8;
	}

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformXYMovePosNum()
{
	int nMovePosNun = 0;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		nMovePosNun = 10;
	}
	else
	{
		nMovePosNun = 6;
	}

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformXDMovePosNum()
{
	int nMovePosNun = 0;

	nMovePosNun = 6;

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformYDMovePosNum()
{
	int nMovePosNun = 0;

	nMovePosNun = 6;

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformXDPYMovePosNum()
{
	int nMovePosNun = 0;

	nMovePosNun = 9;

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformXDPY1MovePosNum()
{
	int nMovePosNun = 0;

	nMovePosNun = 7;

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformXYPD_XYMovePosNum()
{
	int nMovePosNun = 0;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		nMovePosNun = 10;
	}
	else
	{
		nMovePosNun = 6;
	}

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformXYPD_DMovePosNum()
{
	int nMovePosNun = 0;

	nMovePosNun = 4;

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformXMovePosNum()
{
	int nMovePosNun = 0;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		nMovePosNun = 4;
	}
	else
	{
		nMovePosNun = 4;
	}

	return nMovePosNun;
}

int vcBaseAlignTool::GetCalibPlatformYMovePosNum()
{
	int nMovePosNun = 0;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		nMovePosNun = 4;
	}
	else
	{
		nMovePosNun = 4;
	}

	return nMovePosNun;
}



// 获取平移标定和旋转标定时各轴的移动位置
std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformMovePos(int nMarkType)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	m_CalibrateParam = m_vpCalibrateParam[0];

	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}

		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{
			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将12个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos3->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos3->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0;
				AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos4->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos5->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos5->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos5->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos5);
				//6
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos6->m_dPosY  = dY0;	
				AxisMovePos6->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos6);
				//7
				CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos7->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos7->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos7->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos7);
				//8
				CPlatformXYDAxisPos* AxisMovePos8 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos8->m_dPosX  = dX0;
				AxisMovePos8->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos8->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos8);
				//9
				CPlatformXYDAxisPos* AxisMovePos9 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos9->m_dPosX  = dX0 ;
				AxisMovePos9->m_dPosY  = dY0 ;	
				AxisMovePos9->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos9);
				//10
				CPlatformXYDAxisPos* AxisMovePos10 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos10->m_dPosX  = dX0 ;
				AxisMovePos10->m_dPosY  = dY0 ;	
				AxisMovePos10->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos10);
				//11
				CPlatformXYDAxisPos* AxisMovePos11 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos11->m_dPosX = 0.0;
					AxisMovePos11->m_dPosY = 0.0;
					AxisMovePos11->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos11);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将8个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos3->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos3->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos4->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos5->m_dPosX  = dX0 ;
				AxisMovePos5->m_dPosY  = dY0 ;	
				AxisMovePos5->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos5);
				//6
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 ;
				AxisMovePos6->m_dPosY  = dY0 ;	
				AxisMovePos6->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos6);
				//7
				CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos7->m_dPosX = 0.0;
					AxisMovePos7->m_dPosY = 0.0;
					AxisMovePos7->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos7);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}

		}

		// 		//需要设置平台各轴的初始位置，即基准位置
		// 		if (m_PlatformAxisPos != NULL)
		// 		{
		// 			//将8个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
		// 			//0	
		// 			CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
		// 			m_vPlatformAxisPos.push_back(AxisMovePos0);
		// 			//1
		// 			CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
		// 			AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
		// 			AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
		// 			AxisMovePos1->m_dAngle  = dD0;
		// 			m_vPlatformAxisPos.push_back(AxisMovePos1);
		// 			//2
		// 			CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
		// 			AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
		// 			AxisMovePos2->m_dPosY  = dY0 -  dOffsetY;	
		// 			AxisMovePos2->m_dAngle  = dD0;
		// 			m_vPlatformAxisPos.push_back(AxisMovePos2);
		// 			//3
		// 			CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
		// 			AxisMovePos3->m_dPosX  = dX0 -  dOffsetX;
		// 			AxisMovePos3->m_dPosY  = dY0 +  dOffsetY;	
		// 			AxisMovePos3->m_dAngle  = dD0;
		// 			m_vPlatformAxisPos.push_back(AxisMovePos3);
		// 			//4
		// 			CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
		// 			AxisMovePos4->m_dPosX  = dX0 +  dOffsetX;
		// 			AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
		// 			AxisMovePos4->m_dAngle  = dD0;
		// 			m_vPlatformAxisPos.push_back(AxisMovePos4);
		// 			//5
		// 			CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
		// 			AxisMovePos5->m_dPosX  = dX0 ;
		// 			AxisMovePos5->m_dPosY  = dY0 ;	
		// 			AxisMovePos5->m_dAngle  = dD0 + dOffsetD;
		// 			m_vPlatformAxisPos.push_back(AxisMovePos5);
		// 			//6
		// 			CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
		// 			AxisMovePos6->m_dPosX  = dX0 ;
		// 			AxisMovePos6->m_dPosY  = dY0 ;	
		// 			AxisMovePos6->m_dAngle  = dD0 - dOffsetD;
		// 			m_vPlatformAxisPos.push_back(AxisMovePos6);
		// 			//7
		// 			CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
		// 			m_vPlatformAxisPos.push_back(AxisMovePos7);
		// 	
		// 		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformMovePos(int nPosIndex,int nMarkType)
{
	switch(m_eMidPlatformType)
	{
	case ePlatformXYD:
	case ePlatformX1X2Y:
	case ePlatformXY1Y2:
		{
			return GetCalibPlatformXYDMovePos(nPosIndex);
		}
		break;

	case ePlatformXY:
		{
			return GetCalibPlatformXYMovePos(nPosIndex);
		}
		break;

	case ePlatformXD:
		{
			return GetCalibPlatformXDMovePos(nPosIndex);
		}
		break;

	case ePlatformYD:
		{
			return GetCalibPlatformYDMovePos(nPosIndex);
		}
		break;

	case ePlatformXDPY:
		{
			return GetCalibPlatformXDPYMovePos(nPosIndex);
		}
		break;

	case ePlatformXDPY1:
		{
			return GetCalibPlatformXDPY1MovePos(nPosIndex);
		}
		break;

	case ePlatformXYPD:
		{
			if (nMarkType==0)
			{
				return GetCalibPlatformXYPD_XYMovePos(nPosIndex);
			}
			else if (nMarkType==1)
			{
				return GetCalibPlatformXYPD_DMovePos(nPosIndex);
			}
		}
		break;

	case ePlatformX:
		{
			return GetCalibPlatformXMovePos(nPosIndex);
		}
		break;

	case ePlatformY:
		{
			return GetCalibPlatformYMovePos(nPosIndex);
		}
		break;

	default:
		{

		}
		break;
	}

	std::vector<CPlatformAxisPos*> vpPos;
	return vpPos;

}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformXYDMovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}


		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}

			}
		}

		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================

		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{
			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将12个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos3->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos3->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0;
				AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos4->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos5->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos5->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos5->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos5);
				//6
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos6->m_dPosY  = dY0;	
				AxisMovePos6->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos6);
				//7
				CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos7->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos7->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos7->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos7);
				//8
				CPlatformXYDAxisPos* AxisMovePos8 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos8->m_dPosX  = dX0;
				AxisMovePos8->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos8->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos8);
				//9
				CPlatformXYDAxisPos* AxisMovePos9 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos9->m_dPosX  = dX0 ;
				AxisMovePos9->m_dPosY  = dY0 ;	
				AxisMovePos9->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos9);
				//10
				CPlatformXYDAxisPos* AxisMovePos10 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos10->m_dPosX  = dX0 ;
				AxisMovePos10->m_dPosY  = dY0 ;	
				AxisMovePos10->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos10);
				//11
				CPlatformXYDAxisPos* AxisMovePos11 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos11->m_dPosX = 0.0;
					AxisMovePos11->m_dPosY = 0.0;
					AxisMovePos11->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos11);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0;
				}

			}
			else
			{
				//将8个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos3->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos3->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos4->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos5->m_dPosX  = dX0 ;
				AxisMovePos5->m_dPosY  = dY0 ;	
				AxisMovePos5->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos5);
				//6
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 ;
				AxisMovePos6->m_dPosY  = dY0 ;	
				AxisMovePos6->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos6);
				//7
				CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos7->m_dPosX = 0.0;
					AxisMovePos7->m_dPosY = 0.0;
					AxisMovePos7->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos7);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0;
				}
			}
		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformXYMovePos(int nPosIndex)
{

	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}

		// 标定时轴方向取反
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================

		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将10个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos3->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos3->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0;
				AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos4->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos5->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos5->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos5->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos5);
				//6
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos6->m_dPosY  = dY0;	
				AxisMovePos6->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos6);
				//7
				CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos7->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos7->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos7->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos7);
				//8
				CPlatformXYDAxisPos* AxisMovePos8 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos8->m_dPosX  = dX0;
				AxisMovePos8->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos8->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos8);

				//9
				CPlatformXYDAxisPos* AxisMovePos9 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos9->m_dPosX = 0.0;
					AxisMovePos9->m_dPosY = 0.0;
					AxisMovePos9->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos9);

				if (m_bCalibSendRelativePos)
				{
					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos3->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos3->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos4->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos4);

				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformXDMovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}

		// 标定时轴方向取反
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================

		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);				
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 ;
				AxisMovePos3->m_dPosY  = dY0 ;	
				AxisMovePos3->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 ;
				AxisMovePos4->m_dPosY  = dY0 ;	
				AxisMovePos4->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);				
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 ;
				AxisMovePos3->m_dPosY  = dY0 ;	
				AxisMovePos3->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 ;
				AxisMovePos4->m_dPosY  = dY0 ;	
				AxisMovePos4->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}

		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformYDMovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}

		// 标定时轴方向取反
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================

		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);				
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 ;
				AxisMovePos3->m_dPosY  = dY0 ;	
				AxisMovePos3->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 ;
				AxisMovePos4->m_dPosY  = dY0 ;	
				AxisMovePos4->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);
				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);				
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 ;
				AxisMovePos3->m_dPosY  = dY0 ;	
				AxisMovePos3->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 ;
				AxisMovePos4->m_dPosY  = dY0 ;	
				AxisMovePos4->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}

		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformXDPYMovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}
		// 标定时轴方向取反
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================
		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);			

				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 ;
				AxisMovePos3->m_dPosY  = dY0 ;	
				AxisMovePos3->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 ;
				AxisMovePos4->m_dPosY  = dY0 ;	
				AxisMovePos4->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				//6 放置到Y平台，移动后，吸起回到拍摄位置
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 ;
				AxisMovePos6->m_dPosY  = dY0 + dOffsetY;	
				AxisMovePos6->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos6);

				//6 放置到Y平台，移动后，吸起回到拍摄位置
				CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos7->m_dPosX  = dX0 ;
				AxisMovePos7->m_dPosY  = dY0 - dOffsetY;	
				AxisMovePos7->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos7);

				//0	
				CPlatformXYDAxisPos* AxisMovePos8 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos8->m_dPosX = 0.0;
					AxisMovePos8->m_dPosY = 0.0;
					AxisMovePos8->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos8);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);				
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 ;
				AxisMovePos3->m_dPosY  = dY0 ;	
				AxisMovePos3->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 ;
				AxisMovePos4->m_dPosY  = dY0 ;	
				AxisMovePos4->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				//6 放置到Y平台，移动后，吸起回到拍摄位置
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 ;
				AxisMovePos6->m_dPosY  = dY0 + dOffsetY;	
				AxisMovePos6->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos6);

				//6 放置到Y平台，移动后，吸起回到拍摄位置
				CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos7->m_dPosX  = dX0 ;
				AxisMovePos7->m_dPosY  = dY0 - dOffsetY;	
				AxisMovePos7->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos7);

				//0	
				CPlatformXYDAxisPos* AxisMovePos8 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos8->m_dPosX = 0.0;
					AxisMovePos8->m_dPosY = 0.0;
					AxisMovePos8->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos8);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}

		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformXDPY1MovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}
		// 标定时轴方向取反
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================
		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);				
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 ;
				AxisMovePos3->m_dPosY  = dY0 ;	
				AxisMovePos3->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 ;
				AxisMovePos4->m_dPosY  = dY0 ;	
				AxisMovePos4->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				//6 放置到Y平台，移动后，吸起回到拍摄位置
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 ;
				AxisMovePos6->m_dPosY  = dY0 + dOffsetY;	
				AxisMovePos6->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos6);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);				
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 ;
				AxisMovePos3->m_dPosY  = dY0 ;	
				AxisMovePos3->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 ;
				AxisMovePos4->m_dPosY  = dY0 ;	
				AxisMovePos4->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				//6 放置到Y平台，移动后，吸起回到拍摄位置
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 ;
				AxisMovePos6->m_dPosY  = dY0 + dOffsetY;	
				AxisMovePos6->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos6);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}

		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformXYPD_XYMovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}


		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================
		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将10个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos3->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos3->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0;
				AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos4->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos4);
				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos5->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos5->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos5->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos5);
				//6
				CPlatformXYDAxisPos* AxisMovePos6 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos6->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos6->m_dPosY  = dY0;	
				AxisMovePos6->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos6);
				//7
				CPlatformXYDAxisPos* AxisMovePos7 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos7->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos7->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos7->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos7);
				//8
				CPlatformXYDAxisPos* AxisMovePos8 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos8->m_dPosX  = dX0;
				AxisMovePos8->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos8->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos8);

				//9
				CPlatformXYDAxisPos* AxisMovePos9 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos9->m_dPosX = 0.0;
					AxisMovePos9->m_dPosY = 0.0;
					AxisMovePos9->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos9);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos3->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos3->m_dPosY  = dY0 +  dOffsetY;	
				AxisMovePos3->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos3);
				//4
				CPlatformXYDAxisPos* AxisMovePos4 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos4->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos4->m_dPosY  = dY0 -  dOffsetY;	
				AxisMovePos4->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos4);

				//5
				CPlatformXYDAxisPos* AxisMovePos5 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos5->m_dPosX = 0.0;
					AxisMovePos5->m_dPosY = 0.0;
					AxisMovePos5->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos5);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformXYPD_DMovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================
		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将4个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);

				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 ;
				AxisMovePos1->m_dPosY  = dY0 ;	
				AxisMovePos1->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 ;
				AxisMovePos2->m_dPosY  = dY0 ;	
				AxisMovePos2->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos3->m_dPosX = 0.0;
					AxisMovePos3->m_dPosY = 0.0;
					AxisMovePos3->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos3);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}


			}
			else
			{
				//将8个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);

				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 ;
				AxisMovePos1->m_dPosY  = dY0 ;	
				AxisMovePos1->m_dAngle  = dD0 + dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 ;
				AxisMovePos2->m_dPosY  = dY0 ;	
				AxisMovePos2->m_dAngle  = dD0 - dOffsetD;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos3->m_dPosX = 0.0;
					AxisMovePos3->m_dPosY = 0.0;
					AxisMovePos3->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos3);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
		}
	}

	return m_vPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformXMovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}
		// 标定时轴方向取反
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================
		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将10个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 ;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2

				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0 ;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3

				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos3->m_dPosX = 0.0;
					AxisMovePos3->m_dPosY = 0.0;
					AxisMovePos3->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos3);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0 +  dOffsetX;
				AxisMovePos1->m_dPosY  = dY0 ;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2

				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0 -  dOffsetX;
				AxisMovePos2->m_dPosY  = dY0 ;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3

				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos3->m_dPosX = 0.0;
					AxisMovePos3->m_dPosY = 0.0;
					AxisMovePos3->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos3);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
		}
	}

	return m_vPlatformAxisPos;
}


std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformYMovePos(int nPosIndex)
{
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformAxisPos.size(); j++)
	{	
		if (m_vPlatformAxisPos.at(j) != NULL)
		{
			delete m_vPlatformAxisPos.at(j);
			m_vPlatformAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformAxisPos.clear();

	if (nPosIndex<0 || nPosIndex >= m_iMarkNum)
		return m_vPlatformAxisPos;

	m_CalibrateParam = m_vpCalibrateParam[nPosIndex];
	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	//相机平台X轴安装时，不能完成标定，直接返回空值
	if (  eCamPlatformShareX != m_pCamPlatformInfo->GetCamPlatformType())
	{

		double dOffsetX,dOffsetY,dOffsetD;
		dOffsetX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
		dOffsetD = m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle;
		double dX0,dY0,dD0;
		dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
		dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
		dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

		if (m_bCalibSendRelativePos)
		{
			dX0 = 0.0;
			dY0 = 0.0;
			dD0 = 0.0;
		}

		//将平台坐标移动量转化为实际轴移动量
		if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
			dOffsetX = -dOffsetX;
		if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
			dOffsetY = -dOffsetY;
		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
			dOffsetD = -dOffsetD;
		// 		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		// 			dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			double dStartAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
				}
			}
		}
		// 标定时轴方向取反
		//===================================================================================
		if(1)
		{
			BOOL bChangeX = FALSE;
			BOOL bChangeY = FALSE;
			BOOL bChangeD = FALSE;
			GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
			if (bChangeX)
			{
				dOffsetX = -dOffsetX;
			}
			if (bChangeY)
			{
				dOffsetY = -dOffsetY;
			}
			if (bChangeD)
			{
				dOffsetD = -dOffsetD;
			}
		}
		//===================================================================================
		//需要设置平台各轴的初始位置，即基准位置
		if (m_PlatformAxisPos != NULL)
		{

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				//将10个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0;
				AxisMovePos1->m_dPosY  = dY0 + dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0;
				AxisMovePos2->m_dPosY  = dY0 - dOffsetY;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos3->m_dPosX = 0.0;
					AxisMovePos3->m_dPosY = 0.0;
					AxisMovePos3->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos3);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
			else
			{
				//将6个位置压入，第一个和最后一个是基准位置：指针类型直接压入还是new？
				//0	
				CPlatformXYDAxisPos* AxisMovePos0 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos0->m_dPosX = 0.0;
					AxisMovePos0->m_dPosY = 0.0;
					AxisMovePos0->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos0);
				//1
				CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos1->m_dPosX  = dX0;
				AxisMovePos1->m_dPosY  = dY0 + dOffsetY;	
				AxisMovePos1->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos1);
				//2
				CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
				AxisMovePos2->m_dPosX  = dX0;
				AxisMovePos2->m_dPosY  = dY0 - dOffsetY;	
				AxisMovePos2->m_dAngle  = dD0;
				m_vPlatformAxisPos.push_back(AxisMovePos2);
				//3
				CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
				if (m_bCalibSendRelativePos)
				{
					AxisMovePos3->m_dPosX = 0.0;
					AxisMovePos3->m_dPosY = 0.0;
					AxisMovePos3->m_dAngle = 0.0;
				}
				m_vPlatformAxisPos.push_back(AxisMovePos3);

				if (m_bCalibSendRelativePos)
				{

					for (int i=m_vPlatformAxisPos.size()-1;i>0;i--)
					{
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosX;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dPosY;
						((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(i-1))->m_dAngle;
					}

					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosX = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dPosY = 0.0;
					((CPlatformXYDAxisPos*)m_vPlatformAxisPos.at(0))->m_dAngle = 0.0;
				}
			}
		}
	}

	return m_vPlatformAxisPos;
}



void vcBaseAlignTool::GetCalibPlatformMoveSearchResult(int nCalibPos,int& nNum,std::vector<CCoordPos>& ImageResults)
{
	ImageResults.clear();
	nNum = m_vCalibPlatformMoveResults[nCalibPos].size();
	for (int i=0;i<nNum;i++)
	{
		ImageResults.push_back(m_vCalibPlatformMoveResults[nCalibPos].at(i));
	}
}

// XYD/XD/YD/XY/X平台标定时图像搜索结果
void vcBaseAlignTool::SetCalibPlatformMoveSearchResult(std::vector<CMarkImagePos*> ImageResults,int nCalibPos)
{
	m_vCalibPlatformMoveResults[nCalibPos].clear();
	//将每个位置num副图像，共7个不同位置的图像坐标压入m_vCalibPlatformMoveResults

	for (int j=0; j<ImageResults.size(); j++)
	{
		int num = ImageResults.at(j)->m_vPos.size();
		for (int k=0; k<num; k++)
		{
			m_vCalibPlatformMoveResults[nCalibPos].push_back(ImageResults.at(j)->m_vPos.at(k));
		}
	}
}

// XYPD平台标定时图像搜索结果
void vcBaseAlignTool::SetCalibPlatformMoveSearchResult(std::vector<CMarkImagePos*> ImageResults,int nMarkType,int nClibPos)
{
	if (m_vCalibPlatformMoveResults[nClibPos].size()!= (CALIBMOVEPOS_XYNUM+CALIBMOVEPOS_DNUM))
	{
		m_vCalibPlatformMoveResults[nClibPos].resize(CALIBMOVEPOS_XYNUM+CALIBMOVEPOS_DNUM);
	}

	switch(nMarkType)
	{
		// 对象10个位置
	case 0:
		{
			if (ImageResults.size() != CALIBMOVEPOS_XYNUM)
			{
				return;
			}

			for (int j=0;j<ImageResults.size();j++)
			{
				int num = ImageResults.at(j)->m_vPos.size();
				for (int k=0; k<num; k++)
				{
					m_vCalibPlatformMoveResults[nClibPos].at(j) = ImageResults.at(j)->m_vPos.at(k);
				}
			}
		}
		break;

		// 目标4个位置
	case 1:
		{
			if (ImageResults.size()!=CALIBMOVEPOS_DNUM)
			{
				return;
			}

			for (int j=0;j<ImageResults.size();j++)
			{
				int num = ImageResults.at(j)->m_vPos.size();
				for (int k=0; k<num; k++)
				{
					m_vCalibPlatformMoveResults[nClibPos].at(CALIBMOVEPOS_XYNUM+j) = ImageResults.at(j)->m_vPos.at(k);	
				}
			}
		}
		break;

	default:
		{
			return;
		}
		break;
	}


// 	if (m_bPlatformPick)
// 	{
// 		switch(nMarkType)
// 		{
// 			// 旋转中心标定4个位置
// 		case 0:
// 			{
// 				if (ImageResults.size() != CALIBMOVEPOS_DNUM)
// 				{
// 					return;
// 				}
// 
// 				for (int j=0;j<ImageResults.size();j++)
// 				{
// 					int num = ImageResults.at(j)->m_vPos.size();
// 					for (int k=0; k<num; k++)
// 					{
// 						m_vCalibPlatformMoveResults[nClibPos].at(CALIBMOVEPOS_XYNUM+j) = ImageResults.at(j)->m_vPos.at(k);	
// 					}
// 				}
// 			}
// 			break;
// 
// 			// XY对象10个位置
// 		case 1:
// 			{
// 				if (ImageResults.size()!=CALIBMOVEPOS_XYNUM)
// 				{
// 					return;
// 				}
// 
// 				for (int j=0;j<ImageResults.size();j++)
// 				{
// 					int num = ImageResults.at(j)->m_vPos.size();
// 					for (int k=0; k<num; k++)
// 					{
// 						m_vCalibPlatformMoveResults[nClibPos].at(j) = ImageResults.at(j)->m_vPos.at(k);
// 					}
// 				}
// 			}
// 			break;
// 
// 		default:
// 			{
// 				return;
// 			}
// 			break;
// 		}
// 	}
// 	else
// 	{
// 		switch(nMarkType)
// 		{
// 			// 对象10个位置
// 		case 0:
// 			{
// 				if (ImageResults.size() != CALIBMOVEPOS_XYNUM)
// 				{
// 					return;
// 				}
// 
// 				for (int j=0;j<ImageResults.size();j++)
// 				{
// 					int num = ImageResults.at(j)->m_vPos.size();
// 					for (int k=0; k<num; k++)
// 					{
// 						m_vCalibPlatformMoveResults[nClibPos].at(j) = ImageResults.at(j)->m_vPos.at(k);
// 					}
// 				}
// 			}
// 			break;
// 
// 			// 目标4个位置
// 		case 1:
// 			{
// 				if (ImageResults.size()!=CALIBMOVEPOS_DNUM)
// 				{
// 					return;
// 				}
// 
// 				for (int j=0;j<ImageResults.size();j++)
// 				{
// 					int num = ImageResults.at(j)->m_vPos.size();
// 					for (int k=0; k<num; k++)
// 					{
// 						m_vCalibPlatformMoveResults[nClibPos].at(CALIBMOVEPOS_XYNUM+j) = ImageResults.at(j)->m_vPos.at(k);	
// 					}
// 				}
// 			}
// 			break;
// 
// 		default:
// 			{
// 				return;
// 			}
// 			break;
// 		}
// 	}
}

void vcBaseAlignTool::SetWholeDmCodeCalibImageResult(std::vector<CMulMarkPos*> vDmCodeImagePos,int nCalibPos)
{
	m_vvWholeDmCodeCalibMoveImageResults[nCalibPos].clear();

	for (int j=0; j<vDmCodeImagePos.size(); j++)
	{
		int num = vDmCodeImagePos.at(j)->m_vvPos.size();
		for (int k=0; k<num; k++)
		{
			m_vvWholeDmCodeCalibMoveImageResults[nCalibPos].push_back(vDmCodeImagePos.at(j)->m_vvPos.at(k));
		}
	}
}

void vcBaseAlignTool::SetWholeDmCodeCalibBoardResult(std::vector<CMulMarkPos*> vDmCodePlatformPos,int nCalibPos)
{
	m_vvWholeDmCodeCalibMoveBoardResults[nCalibPos].clear();

	for (int j=0; j<vDmCodePlatformPos.size(); j++)
	{
		int num = vDmCodePlatformPos.at(j)->m_vvPos.size();
		for (int k=0; k<num; k++)
		{
			m_vvWholeDmCodeCalibMoveBoardResults[nCalibPos].push_back(vDmCodePlatformPos.at(j)->m_vvPos.at(k));
		}
	}
}





void vcBaseAlignTool::SetWholeDmCodeCalibImageResult(std::vector<CMulMarkPos*> vDmCodeImagePos,int nMarkType,int nCalibPos)
{
	if (m_vvWholeDmCodeCalibMoveImageResults[nCalibPos].size()!= (CALIBMOVEPOS_XYNUM + CALIBMOVEPOS_DNUM))
	{
		m_vvWholeDmCodeCalibMoveImageResults[nCalibPos].resize(CALIBMOVEPOS_XYNUM+CALIBMOVEPOS_DNUM);
	}

	if (m_bPlatformPick)
	{
		switch(nMarkType)
		{
			// 旋转中心标定4个位置
		case 0:
			{
				if (vDmCodeImagePos.size() != CALIBMOVEPOS_DNUM)
				{
					return;
				}

				for (int j=0;j<vDmCodeImagePos.size();j++)
				{
					int num = vDmCodeImagePos.at(j)->m_vvPos.size();
					for (int k=0; k<num; k++)
					{
						m_vvWholeDmCodeCalibMoveImageResults[nCalibPos].at(CALIBMOVEPOS_XYNUM+j) = vDmCodeImagePos.at(j)->m_vvPos.at(k);	
					}
				}
			}
			break;

			// XY对象10个位置
		case 1:
			{
				if (vDmCodeImagePos.size()!=CALIBMOVEPOS_XYNUM)
				{
					return;
				}

				for (int j=0;j<vDmCodeImagePos.size();j++)
				{
					int num = vDmCodeImagePos.at(j)->m_vvPos.size();
					for (int k=0; k<num; k++)
					{
						m_vvWholeDmCodeCalibMoveImageResults[nCalibPos].at(j) = vDmCodeImagePos.at(j)->m_vvPos.at(k);
					}
				}
			}
			break;

		default:
			{
				return;
			}
			break;
		}
	}
	else
	{
		switch(nMarkType)
		{
			// 对象10个位置
		case 0:
			{
				if (vDmCodeImagePos.size() != CALIBMOVEPOS_XYNUM)
				{
					return;
				}

				for (int j=0;j<vDmCodeImagePos.size();j++)
				{
					int num = vDmCodeImagePos.at(j)->m_vvPos.size();
					for (int k=0; k<num; k++)
					{
						m_vvWholeDmCodeCalibMoveImageResults[nCalibPos].at(j) = vDmCodeImagePos.at(j)->m_vvPos.at(k);
					}
				}
			}
			break;

			// 目标4个位置
		case 1:
			{
				if (vDmCodeImagePos.size()!=CALIBMOVEPOS_DNUM)
				{
					return;
				}

				for (int j=0;j<vDmCodeImagePos.size();j++)
				{
					int num = vDmCodeImagePos.at(j)->m_vvPos.size();
					for (int k=0; k<num; k++)
					{
						m_vvWholeDmCodeCalibMoveImageResults[nCalibPos].at(CALIBMOVEPOS_XYNUM+j) = vDmCodeImagePos.at(j)->m_vvPos.at(k);	
					}
				}
			}
			break;

		default:
			{
				return;
			}
			break;
		}
	}

}

void vcBaseAlignTool::SetWholeDmCodeCalibBoardResult(std::vector<CMulMarkPos*> vDmCodeBoardPos,int nMarkType,int nCalibPos)
{
	if (m_vvWholeDmCodeCalibMoveBoardResults[nCalibPos].size()!= (CALIBMOVEPOS_XYNUM + CALIBMOVEPOS_DNUM))
	{
		m_vvWholeDmCodeCalibMoveBoardResults[nCalibPos].resize(CALIBMOVEPOS_XYNUM+CALIBMOVEPOS_DNUM);
	}

	if (m_bPlatformPick)
	{
		switch(nMarkType)
		{
			// 旋转中心标定4个位置
		case 0:
			{
				if (vDmCodeBoardPos.size() != CALIBMOVEPOS_DNUM)
				{
					return;
				}

				for (int j=0;j<vDmCodeBoardPos.size();j++)
				{
					int num = vDmCodeBoardPos.at(j)->m_vvPos.size();
					for (int k=0; k<num; k++)
					{
						m_vvWholeDmCodeCalibMoveBoardResults[nCalibPos].at(CALIBMOVEPOS_XYNUM+j) = vDmCodeBoardPos.at(j)->m_vvPos.at(k);	
					}
				}
			}
			break;

			// XY对象10个位置
		case 1:
			{
				if (vDmCodeBoardPos.size()!=CALIBMOVEPOS_XYNUM)
				{
					return;
				}

				for (int j=0;j<vDmCodeBoardPos.size();j++)
				{
					int num = vDmCodeBoardPos.at(j)->m_vvPos.size();
					for (int k=0; k<num; k++)
					{
						m_vvWholeDmCodeCalibMoveBoardResults[nCalibPos].at(j) = vDmCodeBoardPos.at(j)->m_vvPos.at(k);
					}
				}
			}
			break;

		default:
			{
				return;
			}
			break;
		}
	}
	else
	{
		switch(nMarkType)
		{
			// 对象10个位置
		case 0:
			{
				if (vDmCodeBoardPos.size() != CALIBMOVEPOS_XYNUM)
				{
					return;
				}

				for (int j=0;j<vDmCodeBoardPos.size();j++)
				{
					int num = vDmCodeBoardPos.at(j)->m_vvPos.size();
					for (int k=0; k<num; k++)
					{
						m_vvWholeDmCodeCalibMoveBoardResults[nCalibPos].at(j) = vDmCodeBoardPos.at(j)->m_vvPos.at(k);
					}
				}
			}
			break;

			// 目标4个位置
		case 1:
			{
				if (vDmCodeBoardPos.size()!=CALIBMOVEPOS_DNUM)
				{
					return;
				}

				for (int j=0;j<vDmCodeBoardPos.size();j++)
				{
					int num = vDmCodeBoardPos.at(j)->m_vvPos.size();
					for (int k=0; k<num; k++)
					{
						m_vvWholeDmCodeCalibMoveBoardResults[nCalibPos].at(CALIBMOVEPOS_XYNUM+j) = vDmCodeBoardPos.at(j)->m_vvPos.at(k);	
					}
				}
			}
			break;

		default:
			{
				return;
			}
			break;
		}
	}
}


BOOL vcBaseAlignTool::ExecuteCalibrate(void)
{
	//标定次数（mark点数量，不是相机数量）
	if (m_iMarkNum == 0)
	{
		return FALSE;
	}

	for (int i=0; i<m_iMarkNum ; i++)
	{
		if (FALSE == ExecuteCalibrateSingleCam(i))
			return FALSE;
	}
	return TRUE;
}

BOOL vcBaseAlignTool::ExecuteCalibrate(int nCalibPos)
{
	//标定次数（mark点数量，不是相机数量）
	if (m_iMarkNum == 0)
	{
		return FALSE;
	}
	// 	
	// 	//	for (int i=0; i<m_iMarkNum ; i++)
	// 	{
	// 		if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
	// 			return FALSE;
	// 	}


	if (m_bTargetObjectCamSeparate)// 如果目标相机和对象相机是独立的
	{		
		if (ePlatformXD == m_eMidPlatformType)
		{
			//return FALSE;
			// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
			if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
			{
				if (FALSE == ExecuteCalibrateXDSingleCamEX(nCalibPos))
					return FALSE;
			}
			else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
			{
				if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
					return FALSE;
			}
		}
		else if (ePlatformXY == m_eMidPlatformType)
		{
			//return FALSE;
			// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
			if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
			{
				if (FALSE == ExecuteCalibrateXYSingleCamEX(nCalibPos))
					return FALSE;
			}
			else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
			{
				if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
					return FALSE;
			}
		}
		else if (ePlatformX == m_eMidPlatformType)
		{
			//return FALSE;
			// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
			if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
			{
				if (FALSE == ExecuteCalibrateXSingleCamEX(nCalibPos))
					return FALSE;
			}
			else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
			{
				if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
					return FALSE;
			}
		}
		else if (ePlatformY == m_eMidPlatformType)
		{
			// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
			if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
			{
				if (FALSE == ExecuteCalibrateYSingleCamEX(nCalibPos))
					return FALSE;
			}
			else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
			{
				if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
					return FALSE;
			}
		}
		else if (ePlatformYD == m_eMidPlatformType)
		{
			//return FALSE;
			// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
			if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
			{
				if (FALSE == ExecuteCalibrateYDSingleCamEX(nCalibPos))
					return FALSE;
			}
			else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
			{
				if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
					return FALSE;
			}
		}
		else if (ePlatformXDPY == m_eMidPlatformType)
		{
			//return FALSE;
			// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
			if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
			{
				if (FALSE == ExecuteCalibrateXDPYSingleCamEX(nCalibPos))
					return FALSE;
			}
			else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
			{
				if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
					return FALSE;
			}
		}
		else if (ePlatformXDPY1 == m_eMidPlatformType)
		{
			//return FALSE;
			// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
			if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
			{
				if (FALSE == ExecuteCalibrateXDPY1SingleCamEX(nCalibPos))
					return FALSE;
			}
			else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
			{
				if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
					return FALSE;
			}
		}
		else if (ePlatformXYPD == m_eMidPlatformType)
		{
			return FALSE;
		}
		else
		{
			// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
			if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
			{
				if (ePlatformCalib9Point == m_PlatformCalibType)
				{
					if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos))
						return FALSE;
				}
				else
				{
					if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
						return FALSE;
				}
			}
			else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
			{
				if (ePlatformCalib9Point == m_PlatformCalibType)
				{
					if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
						return FALSE;
				}
				else
				{
					if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
						return FALSE;
				}
			}
		}


	}
	else// 如果目标相机和对象相机不是独立的，那么所有相机位置就按照标准的标定方法进行标定
	{
		if (ePlatformXD == m_eMidPlatformType)
		{
			if (FALSE == ExecuteCalibrateXDSingleCamEX(nCalibPos))
				return FALSE;
		}
		else if (ePlatformXY == m_eMidPlatformType)
		{
			if (FALSE == ExecuteCalibrateXYSingleCamEX(nCalibPos))
				return FALSE;
		}
		else if (ePlatformX == m_eMidPlatformType)
		{
			if (FALSE == ExecuteCalibrateXSingleCamEX(nCalibPos))
				return FALSE;
		}
		else if (ePlatformY == m_eMidPlatformType)
		{
			if (FALSE == ExecuteCalibrateYSingleCamEX(nCalibPos))
				return FALSE;
		}
		else if (ePlatformYD == m_eMidPlatformType)
		{
			if (FALSE == ExecuteCalibrateYDSingleCamEX(nCalibPos))
				return FALSE;
		}
		else if (ePlatformXDPY == m_eMidPlatformType)
		{
			if (FALSE == ExecuteCalibrateXDPYSingleCamEX(nCalibPos))
				return FALSE;
		}
		else if (ePlatformXDPY1 == m_eMidPlatformType)
		{
			if (FALSE == ExecuteCalibrateXDPY1SingleCamEX(nCalibPos))
				return FALSE;
		}
		else if (ePlatformXYPD == m_eMidPlatformType)
		{
			return FALSE;
		}
		else
		{
			if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
			{
				if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos))
					return FALSE;
			}
			else //移动5点计算2×2的旋转缩放矩阵
			{
				if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
					return FALSE;
			}
		}
	}
	return TRUE;
}	

// BOOL vcBaseAlignTool::ExecuteCalibrate(int nCalibPos, int nMarkType)
// {
// 	//标定次数（mark点数量，不是相机数量）
// 	if (m_iMarkNum == 0)
// 	{
// 		return FALSE;
// 	}
// 	// 	
// 	// 	//	for (int i=0; i<m_iMarkNum ; i++)
// 	// 	{
// 	// 		if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
// 	// 			return FALSE;
// 	// 	}
// 
// 	if (m_bPlatformPick)
// 	{
// 
// 		if (m_ePickCamPlatformType == ePickCamPlatformSepFix)
// 		{
// 			if (nMarkType == 0)
// 			{
// 				return FALSE;
// 			}
// 			else if (nMarkType==1)
// 			{
// 				if (ePlatformXY == m_eMidPlatformType)
// 				{
// 
// 					if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
// 					{
// 						if (FALSE == ExecuteCalibrateXYSingleCamPickEX(nCalibPos))
// 							return FALSE;
// 					}
// 					else //移动5点计算2×2的旋转缩放矩阵
// 					{
// 						if (FALSE == ExecuteCalibrateXYSingleCamPick(nCalibPos))
// 							return FALSE;
// 					}
// 				}
// 				else
// 				{
// 					if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
// 					{
// 						if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos))
// 							return FALSE;
// 					}
// 					else //移动5点计算2×2的旋转缩放矩阵
// 					{
// 						if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
// 							return FALSE;
// 					}
// 
// 				}
// 			}
// 			else
// 			{
// 				return FALSE;
// 			}
// 		}
// 		else
// 		{
// 			if (nMarkType == 1)
// 			{
// 				if (FALSE == ExecuteCalibratePickSingleCamEX(nCalibPos))
// 					return FALSE;
// 			}
// 			else if (nMarkType == 0)
// 			{
// 				if (FALSE == ExecuteCalibrateCenterPickSingleCamEX(nCalibPos))
// 					return FALSE;
// 			}
// 			else
// 			{
// 				return FALSE;
// 			}
// 		}
// 
// 
// 	}
// 	else
// 	{
// 		if (nMarkType == 0)
// 		{
// 			if (ePlatformXD == m_eMidPlatformType)
// 			{
// 				return FALSE;
// 			}
// 			else if (ePlatformYD == m_eMidPlatformType)
// 			{
// 				return FALSE;
// 			}
// 			else if (ePlatformXYPD == m_eMidPlatformType)
// 			{
// 				return FALSE;
// 			}
// 			else if (ePlatformXY == m_eMidPlatformType)
// 			{
// 				return FALSE;
// 			}
// 			else if (ePlatformX == m_eMidPlatformType)
// 			{
// 				return FALSE;
// 			}
// 			else
// 			{
// 				// 移动9点计算3×3的H矩阵
// 				if (FALSE == ExecuteCalibrateSingleCamTarget(nCalibPos))
// 					return FALSE;
// 			}
// 		}
// 		else if (nMarkType==1)
// 		{
// 
// 			if (m_bTargetObjectCamSeparate)// 如果目标相机和对象相机是独立的
// 			{		
// 				if (m_bTargetCalibUseBoard == FALSE)
// 				{
// 					if (ePlatformXD == m_eMidPlatformType)
// 					{
// 						//return FALSE;
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (FALSE == ExecuteCalibrateXDSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 								return FALSE;
// 						}
// 						/*return FALSE;*/
// 					}
// 					else if (ePlatformXY == m_eMidPlatformType)
// 					{
// 						//return FALSE;
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (FALSE == ExecuteCalibrateXYSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 								return FALSE;
// 						}
// 					}
// 					else if (ePlatformX == m_eMidPlatformType)
// 					{
// 						//return FALSE;
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (FALSE == ExecuteCalibrateXSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 								return FALSE;
// 						}
// 						/*return FALSE;*/
// 					}
// 					else if (ePlatformYD == m_eMidPlatformType)
// 					{
// 						//return FALSE;
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (FALSE == ExecuteCalibrateYDSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 								return FALSE;
// 						}
// 						/*return FALSE;*/
// 					}
// 					else if (ePlatformXDPY == m_eMidPlatformType)
// 					{
// 						//return FALSE;
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (FALSE == ExecuteCalibrateXDPYSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 								return FALSE;
// 						}
// 						/*return FALSE;*/
// 					}
// 					else if (ePlatformXDPY1 == m_eMidPlatformType)
// 					{
// 						//return FALSE;
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (FALSE == ExecuteCalibrateXDPY1SingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 								return FALSE;
// 						}
// 						/*return FALSE;*/
// 					}
// 					else if (ePlatformXYPD == m_eMidPlatformType)
// 					{
// 						return FALSE;			
// 					}
// 					else
// 					{
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (ePlatformCalib9Point == m_PlatformCalibType)
// 							{
// 								if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos))
// 									return FALSE;
// 							}
// 							else
// 							{
// 								if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
// 									return FALSE;
// 							}
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (TRUE == m_bTarObjCamSepAutoCalibTar)
// 							{
// 								if (ePlatformCalib9Point == m_PlatformCalibType)
// 								{
// 									if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos))
// 										return FALSE;
// 								}
// 								else
// 								{
// 									if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
// 										return FALSE;
// 								}
// 							} 
// 							else
// 							{
// 								if (ePlatformCalib9Point == m_PlatformCalibType)
// 								{
// 									if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 										return FALSE;
// 								}
// 								else
// 								{
// 									if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 										return FALSE;
// 								}
// 							}
// 						}
// 					}
// 				}
// 				else
// 				{
// 					if (ePlatformXD == m_eMidPlatformType)
// 					{
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 
// 							if (FALSE == ExecuteCalibrateXDSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2))
// 								return FALSE;
// 						}
// 					}
// 					else if (ePlatformXY == m_eMidPlatformType)
// 					{
// 						//return FALSE;
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (FALSE == ExecuteCalibrateXYSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 								return FALSE;
// 						}
// 					}
// 					else if (ePlatformX == m_eMidPlatformType)
// 					{
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 
// 							if (FALSE == ExecuteCalibrateXSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2))
// 								return FALSE;
// 						}
// 					}
// 					else if (ePlatformYD == m_eMidPlatformType)
// 					{
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 
// 							if (FALSE == ExecuteCalibrateYDSingleCamEX(nCalibPos))
// 								return FALSE;
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							if (FALSE == ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2))
// 								return FALSE;
// 						}
// 					}
// 					else if (ePlatformXYPD == m_eMidPlatformType)
// 					{
// 						return FALSE;			
// 					}
// 					else
// 					{
// 						// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 						if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 						{
// 							if (ePlatformCalib9Point == m_PlatformCalibType)
// 							{
// 								if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos))
// 									return FALSE;
// 							}
// 							else
// 							{
// 								if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
// 									return FALSE;
// 							}
// 						}
// 						else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 						{
// 							//if (ePlatformCalib9Point == m_PlatformCalibType)
// 							//{
// 							//	if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 							//		return FALSE;
// 							//}
// 							//else
// 							//{
// 							//	if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 							//		return FALSE;
// 							//}
// 							if (ePlatformCalib9Point == m_PlatformCalibType)
// 							{
// 								if (FALSE == ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2))
// 									return FALSE;
// 							}
// 							else
// 							{
// 								if (FALSE == ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2))
// 									return FALSE;
// 							}
// 						}
// 					}
// 				}
// 			}
// 			else// 如果目标相机和对象相机不是独立的，那么所有相机位置就按照标准的标定方法进行标定
// 			{
// 				// 目标对象不分离，对象使用靶标标定，计算图像坐标系与全局靶标坐标系转换关系（2*2旋转缩放矩阵、基准MARK图像坐标、基准MARK平台坐标)
// 				if (m_bTargetCalibUseBoard == TRUE)
// 				{
// 					if (FALSE == ExecuteCalibrateBoardSingleCamEX(nCalibPos))
// 					{
// 						return FALSE;
// 					}
// 					else
// 					{
// 						return TRUE;
// 					}
// 				}
// 
// 				if (ePlatformXD == m_eMidPlatformType)
// 				{
// 					if (FALSE == ExecuteCalibrateXDSingleCamEX(nCalibPos))
// 						return FALSE;
// 				}
// 				else if (ePlatformYD == m_eMidPlatformType)
// 				{
// 					if (FALSE == ExecuteCalibrateYDSingleCamEX(nCalibPos))
// 						return FALSE;
// 				}
// 				else if (ePlatformXDPY == m_eMidPlatformType)
// 				{
// 					if (FALSE == ExecuteCalibrateXDPYSingleCamEX(nCalibPos))
// 						return FALSE;
// 				}
// 				else if (ePlatformXDPY1 == m_eMidPlatformType)
// 				{
// 					if (FALSE == ExecuteCalibrateXDPY1SingleCamEX(nCalibPos))
// 						return FALSE;
// 				}
// 				else if (ePlatformXYPD == m_eMidPlatformType)
// 				{				
// 					return FALSE;
// 				}
// 				else if (ePlatformXY == m_eMidPlatformType)
// 				{
// 					if (FALSE == ExecuteCalibrateXYSingleCamEX(nCalibPos))
// 						return FALSE;
// 				}
// 				else if (ePlatformX == m_eMidPlatformType)
// 				{
// 					if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
// 					{
// 						if (FALSE == ExecuteCalibrateXSingleCamEX(nCalibPos))
// 							return FALSE;
// 					}
// 					else //移动5点计算2×2的旋转缩放矩阵
// 					{
// 						if (FALSE == ExecuteCalibrateXSingleCam(nCalibPos))
// 							return FALSE;
// 					}
// 
// 				}
// 				else
// 				{
// 					if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
// 					{
// 						if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos))
// 							return FALSE;
// 					}
// 					else //移动5点计算2×2的旋转缩放矩阵
// 					{
// 						if (FALSE == ExecuteCalibrateSingleCam(nCalibPos))
// 							return FALSE;
// 					}
// 				}
// 			}
// 		}
// 		else if (nMarkType == 2)
// 		{	
// 			if(ePlatformXYPD != m_eMidPlatformType)
// 				return FALSE;
// 
// 			if (m_bTargetObjectCamSeparate)// 如果目标相机和对象相机是独立的
// 			{
// 				// 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
// 				if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
// 				{
// 					if (ePlatformCalib9Point)
// 					{
// 						if (FALSE == ExecuteCalibrateSingleCamTarget(nCalibPos,0))
// 							return FALSE;
// 						// 					if (FALSE == ExecuteCalibrateSingleCamTarget(nCalibPos,1))
// 						// 						return FALSE;
// 					}
// 					else
// 					{
// 						if (FALSE == ExecuteCalibrateSingleCam(nCalibPos,0))
// 							return FALSE;
// 						// 					if (FALSE == ExecuteCalibrateSingleCam(nCalibPos,1))
// 						// 						return FALSE;
// 
// 					}
// 				}
// 				else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
// 				{
// 					if (ePlatformCalib9Point == m_PlatformCalibType)
// 					{
// 						if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 							return FALSE;
// 					}
// 					else
// 					{
// 						if (FALSE == ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2))
// 							return FALSE;
// 					}
// 				}
// 
// 			}
// 			else
// 			{
// 				if (ePlatformCalib9Point)
// 				{
// 					if (FALSE == ExecuteCalibrateSingleCamTarget(nCalibPos,0))
// 						return FALSE;
// 					// 				if (FALSE == ExecuteCalibrateSingleCamTarget(nCalibPos,1))
// 					// 					return FALSE;
// 				}
// 				else
// 				{
// 					if (FALSE == ExecuteCalibrateSingleCam(nCalibPos,0))
// 						return FALSE;
// 					// 				if (FALSE == ExecuteCalibrateSingleCam(nCalibPos,1))
// 					// 					return FALSE;
// 
// 				}	
// 			}				
// 
// 		}
// 	}
// 
// 
// 
// 	return TRUE;
// }

BOOL vcBaseAlignTool::ExecuteCalibrate(int nCalibPos, int nMarkType)
{
	if (m_iMarkNum == 0)
	{
		return FALSE;
	}


	// XYD平台、XY平台拾取，只需要对象标定，其它情况直接返回
	if ( m_bPlatformPick && (m_ePickCamPlatformType == ePickCamPlatformSepFix) )
	{
		if (nMarkType == 1)
		{
			switch(m_eMidPlatformType)
			{
			case ePlatformXYD:
				{
					if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
					{
						return ExecuteCalibrateSingleCamEX(nCalibPos);
					}
					else //移动5点计算2×2的旋转缩放矩阵
					{
						return ExecuteCalibrateSingleCam(nCalibPos);
					}
				}
				break;

			case ePlatformXY:
				{
					if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
					{
						return ExecuteCalibrateXYSingleCamPickEX(nCalibPos);
					}
					else //移动5点计算2×2的旋转缩放矩阵
					{
						return ExecuteCalibrateXYSingleCamPick(nCalibPos);
					}
				}
				break;

			default:
				{
					return FALSE;
				}
				break;
			}
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		if (nMarkType == 0)
		{
			switch(m_eMidPlatformType)
			{
			case ePlatformXYD:
			case ePlatformX1X2Y:
			case ePlatformXY1Y2:
				{
					// 移动9点计算3×3的H矩阵
					return ExecuteCalibrateSingleCamTarget(nCalibPos);
				}
				break;

			default:
				{
					return FALSE;
				}
				break;
			}
		}
		else if (nMarkType==1)
		{
			// 目标、对象分离分为两种情况，情况1：不使用标定板；情况2：使用标定板
			if (m_bTargetObjectCamSeparate)
			{
				// 情况1：不使用标定板
				if (m_bTargetCalibUseBoard == FALSE)
				{					
					switch(m_eMidPlatformType)
					{
					case ePlatformXYD:
					case ePlatformX1X2Y:
					case ePlatformXY1Y2:
						{
							// 对象标定
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								if (ePlatformCalib9Point == m_PlatformCalibType)
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos);
								}
								else
								{
									return ExecuteCalibrateSingleCam(nCalibPos);
								}
							}
							// 目标标定
							else
							{
								if (TRUE == m_bTarObjCamSepAutoCalibTar) 
								{
									if (ePlatformCalib9Point == m_PlatformCalibType)
									{
										return ExecuteCalibrateSingleCamEX(nCalibPos);
									}
									else
									{
										return ExecuteCalibrateSingleCam(nCalibPos);
									}
								} 
								else
								{
									if (ePlatformCalib9Point == m_PlatformCalibType)
									{
										return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
									}
									else
									{
										return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
									}
								}
							}
						}
						break;

					case ePlatformXY:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateXYSingleCamEX(nCalibPos);
							}
							else
							{
								if(TRUE == m_bTarObjCamSepAutoCalibTar)
								{
									return FALSE;
								}
								else
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
								}

							}
						}
						break;

					case ePlatformXD:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateXDSingleCamEX(nCalibPos);
							}
							else
							{
								if(TRUE == m_bTarObjCamSepAutoCalibTar)
								{
									return ExecuteCalibrateXDSingleCamEX(nCalibPos);
								}
								else
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
								}
								
							}
						}
						break;

					case ePlatformYD:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateYDSingleCamEX(nCalibPos);
							}
							else
							{
								if(TRUE == m_bTarObjCamSepAutoCalibTar)
								{
									return ExecuteCalibrateYDSingleCamEX(nCalibPos);
								}
								else
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
								}
							}
						}
						break;

					case ePlatformXDPY:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateXDPYSingleCamEX(nCalibPos);
							}
							else
							{
								if(TRUE == m_bTarObjCamSepAutoCalibTar)
								{
									return FALSE;
								}
								else
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
								}
							}
						
						}
						break;

					case ePlatformXDPY1:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateXDPY1SingleCamEX(nCalibPos);
							}
							else
							{
								if(TRUE == m_bTarObjCamSepAutoCalibTar)
								{
									return FALSE;
								}
								else
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
								}
								
							}

						}
						break;

					case ePlatformXYPD:
						{
							return FALSE;
						}
						break;

					case ePlatformX:
						{

							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateXSingleCamEX(nCalibPos);
							}
							else
							{
								if(TRUE == m_bTarObjCamSepAutoCalibTar)
								{
									return FALSE;
								}
								else
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
								}
								
							}

						}
						break;

					case ePlatformY:
						{

							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateYSingleCamEX(nCalibPos);
							}
							else
							{
								if(TRUE == m_bTarObjCamSepAutoCalibTar)
								{
									return FALSE;
								}
								else
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos, nCalibPos - m_iMarkNum/2);
								}
							}

						}
						break;


					default:
						{
							return FALSE;
						}
						break;
					}
				}
				// 情况2：使用标定板
				else
				{					
					switch(m_eMidPlatformType)
					{
					case ePlatformXYD:
					case ePlatformX1X2Y:
					case ePlatformXY1Y2:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								if (ePlatformCalib9Point == m_PlatformCalibType)
								{
									return ExecuteCalibrateSingleCamEX(nCalibPos);
								}
								else
								{
									return ExecuteCalibrateSingleCam(nCalibPos);
								}
							}
							else
							{
								if (ePlatformCalib9Point == m_PlatformCalibType)
								{
									return ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2);
								}
								else
								{
									return ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2);
								}
							}
						}
						break;

					case ePlatformXY:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateXYSingleCamEX(nCalibPos);
							}
							else
							{
								return ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2);
							}
						}
						break;

					case ePlatformXD:
						{
							
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateXDSingleCamEX(nCalibPos);
							}
							else
							{
								return ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2);
							}
						}
						break;

					case ePlatformYD:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateYDSingleCamEX(nCalibPos);
							}
							else
							{
								return ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2);
							}
						}
						break;

					case ePlatformXDPY:
						{
							return FALSE;
						}
						break;

					case ePlatformXDPY1:
						{
							return FALSE;
						}
						break;

					case ePlatformXYPD:
						{
							return FALSE;
						}
						break;

					case ePlatformX:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateXSingleCamEX(nCalibPos);
							}
							else
							{
								return ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2);
							}
						}
						break;

					case ePlatformY:
						{
							if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
							{
								return ExecuteCalibrateYSingleCamEX(nCalibPos);
							}
							else
							{
								return ExecuteCalibrateBoardSingleCamEX(nCalibPos, m_iMarkNum/2);
							}
						}
						break;

					default:
						{
							return FALSE;
						}
						break;

					}

				}
			}
			// 目标、对象不分离分离分为两种情况，情况1：不使用标定板；情况2：使用标定板
			else
			{
				// 情况1：不使用标定板
					switch(m_eMidPlatformType)
					{
					case ePlatformXYD:
					case ePlatformX1X2Y:
					case ePlatformXY1Y2:
						{
							if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
							{
								return ExecuteCalibrateSingleCamEX(nCalibPos);
							}
							else //移动5点计算2×2的旋转缩放矩阵
							{
								return ExecuteCalibrateSingleCam(nCalibPos);
							}
						}
						break;

					case ePlatformXY:
						{
							return ExecuteCalibrateXYSingleCamEX(nCalibPos);
						}
						break;

					case ePlatformXD:
						{
							return ExecuteCalibrateXDSingleCamEX(nCalibPos);
						}
						break;

					case ePlatformYD:
						{
							return ExecuteCalibrateYDSingleCamEX(nCalibPos);
						}
						break;

					case ePlatformXDPY:
						{
							return ExecuteCalibrateXDPYSingleCamEX(nCalibPos);
						}
						break;

					case ePlatformXDPY1:
						{
							return ExecuteCalibrateXDPY1SingleCamEX(nCalibPos);
						}
						break;

					case ePlatformXYPD:
						{
							return FALSE;
						}
						break;

					case ePlatformX:
						{
							if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
							{
								return ExecuteCalibrateXSingleCamEX(nCalibPos);
							}
							else //移动5点计算2×2的旋转缩放矩阵
							{
								return ExecuteCalibrateXSingleCam(nCalibPos);
							}
						}
						break;

					case ePlatformY:
						{
							if (ePlatformCalib9Point == m_PlatformCalibType)	// 移动9点计算3×3的H矩阵
							{
								return ExecuteCalibrateYSingleCamEX(nCalibPos);
							}
							else
							{
								return ExecuteCalibrateYSingleCamEX(nCalibPos);
							}
						}
						break;

					default:
						{
							return FALSE;
						}
						break;

					}

				// 情况2：使用标定板
// 				else
// 				{
// 					return ExecuteCalibrateBoardSingleCamEX(nCalibPos);
// 				}
			}
		}
		else
		{
			return FALSE;
		}

	}

	return FALSE;
}

BOOL vcBaseAlignTool::ExecuteCalibrateFCBS(int nCalibPos, int nMarkType)
{
	if (m_iMarkNum == 0)
	{
		return FALSE;
	}

	if (nMarkType != 2)
	{
		return FALSE;
	}

	// XY+D平台拾取，相机安装在XY轴上
	if ( m_bPlatformPick && (m_ePickCamPlatformType == ePickCamPlatformShareXY) )
	{
		if (ePlatformCalib9Point)
		{
			return ExecuteCalibrateSingleCamTarget(nCalibPos,0);

		}
		else
		{
			return ExecuteCalibrateSingleCam(nCalibPos,0);
		}
	}
	else
	{
		if (ePlatformXYPD != m_eMidPlatformType)
		{
			return FALSE;
		}

		if (m_bTargetObjectCamSeparate)
		{
			if (nCalibPos%m_iMarkNum >= m_iMarkNum/2)
			{
				if (ePlatformCalib9Point)
				{
					return ExecuteCalibrateSingleCamTarget(nCalibPos,0);
				}
				else
				{
					return ExecuteCalibrateSingleCam(nCalibPos,0);
				}
			}
			else
			{
				if (ePlatformCalib9Point == m_PlatformCalibType)
				{
					return ExecuteFCBSCalibrateSingleCamEX(nCalibPos, nCalibPos +m_iMarkNum/2);
				}
				else
				{
					return ExecuteFCBSCalibrateSingleCamEX(nCalibPos, nCalibPos + m_iMarkNum/2);
				}
			}

		}
		else
		{
			if (ePlatformCalib9Point)
			{
				return ExecuteCalibrateSingleCamTarget(nCalibPos,0);
			}
			else
			{
				return ExecuteCalibrateSingleCam(nCalibPos,0);
			}	
		}

		return TRUE;
	}

	return FALSE;
}

// XYD平台,  用9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamEX( int nCamIndex )
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex%m_iMarkNum;

	// 拾取sysPlatformInfo.m_bPlatformPick = TRUE; && sysPlatformInfo.m_ePickCamPlatformType =ePickCamPlatformShareXY; 时发送FCLB指令标定崩溃
	if(m_vCalibPlatformMoveResults[nRemCamIndex].size()<11)
	{
		return FALSE;
	}


	// 详细日志
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("XYD平台标定计算开始:位置[%d]------------------------------------------------------------",nCamIndex+1);
	AlignToolLogRecord(str,nPlatformIndex);

	// 全部位置标定时不能采用各个位置的步长信息，只能用位置1的;
	if (m_bEnableKeyenceCode)
	{
		m_CalibrateParam = m_vpCalibrateParam[0];
	}
	else
	{
		m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
	}
	


	//$ 1.0 计算转换矩阵
	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}


	//获取该相机对应的图像坐标

	double MarkdX[11],MarkdY[11];
	int i=0;
	for (i=0; i<11; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPosBat(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);

	str.Format("基准点图像坐标X=%f,Y=%f",m_vCalibPlatformMoveResults[nRemCamIndex].at(0).m_dPosX, m_vCalibPlatformMoveResults[nRemCamIndex].at(0).m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);

	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 9; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0]));
	}

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, +dPosY));
	vPlatMove.push_back(sc2Vector(+dPosX, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, -dPosY));
	vPlatMove.push_back(sc2Vector(0, -dPosY));
	vPlatMove.push_back(sc2Vector(-dPosX, -dPosY));
	vPlatMove.push_back(sc2Vector(-dPosX, 0));
	vPlatMove.push_back(sc2Vector(-dPosX, +dPosY));
	vPlatMove.push_back(sc2Vector(0, +dPosY));

	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);
	//if (m_bPlatformPick)
	{
		CString strTemp = _T("");
		HomographyDOF dof = GetHomographyDOF();
//		HomographyDOF dof = m_CalibrateParam->GetHomographyDOF();
		switch(dof)
		{
		case eAuto:
			strTemp = "eAuto";
			break;
		case eScaleRotate:
			strTemp = "eScaleRotate";
			break;
		case eScaleXYRotateXY:
			strTemp = "eScaleXYRotateXY";
			break;
		case eProject:
			strTemp = "eProject";
			break;
		default:
			dof =eAuto;
			strTemp = "WrongParam , turn to eAuto";
			break;
		}

		str = _T("当前标定H矩阵算法为:") + strTemp ;
		AlignToolLogRecord(str,m_nPlatformIndex);

		if(!sfGetHomography(vImageMark,vPlatMove,h,dof))
		{
			return FALSE;
		}
	}
	//else
	//{
	//	if(!sfGetHomography(vImageMark,vPlatMove,h))
	//	{
	//		return FALSE;
	//	}
	//}

	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//$ 2.0 计算基准mark平台坐标
	scDegree  degRotationDegree;		// 正转旋转角度
	sc2Vector vBenchMarkImagePos;		// 基准点Mark图像坐标
	sc2Vector vStartMarkImagePos;		// 起始点（基准点）Mark图像坐标

	sc2Vector vRotatedMarkImagePos1;	// 正转后Mark图像坐标
	sc2Vector vRotatedMarkImagePos2;	// 反转后Mark图像坐标

	sc2Vector vBenchMarkPlatformPos1;	// 正转计算得到基准点Mark的平台坐标
	sc2Vector vBenchMarkPlatformPos2;   // 反转计算得到基准点Mark的平台坐标

	degRotationDegree = scDegree(m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle);

	vBenchMarkImagePos.SetX(MarkdX[0]);
	vBenchMarkImagePos.SetY(MarkdY[0]);

	vStartMarkImagePos.SetX(MarkdX[0]);
	vStartMarkImagePos.SetY(MarkdY[0]);

	vRotatedMarkImagePos1.SetX(MarkdX[9]);
	vRotatedMarkImagePos1.SetY(MarkdY[9]);

	vRotatedMarkImagePos2.SetX(MarkdX[10]);
	vRotatedMarkImagePos2.SetY(MarkdY[10]);

	// $2.1、正向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos1, degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos1))
	{
		return FALSE;
	}


	// $2.2、反向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos2, -degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos2))
	{
		return FALSE;
	}

	// $2.3、记录基准Mark点的平台坐标值
	CCoordPos pos;
	pos.m_dPosX = (vBenchMarkPlatformPos1.GetX() + vBenchMarkPlatformPos2.GetX())/2.0;
	pos.m_dPosY = (vBenchMarkPlatformPos1.GetY() + vBenchMarkPlatformPos2.GetY())/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosBat(pos);


	str.Format("基准点平台坐标X=%f,Y=%f",pos.m_dPosX,pos.m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);

	//把十个位置的图像坐标保存
	for (int m=0; m<CALIBMOVEPOSNUM; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;

		double dImagePosX = m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX;
		double dImagePosY = m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY;

		str.Format(_T("标定位置图象坐标%d: X: %.2f; Y: %.2f; D: %.3f;"), m, dImagePosX, dImagePosY);
		AlignToolLogRecord(str,nPlatformIndex);
	}


	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

	// 详细日志
	str.Format("XYD标定计算结束:位置[%d]------------------------------------------------------------\n",nCamIndex + 1);
	AlignToolLogRecord(str,nPlatformIndex);

	return  TRUE;
}

// XYD平台,  用5点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCam( int nCamIndex )
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵

	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
	double dX1,dX2,dY1,dY2;//平台坐标偏移量
	double dx1,dy1,dx2,dy2;//图像坐标偏移量
	double A[4][4];	    // 4维矩阵,图像坐标矩阵
	double dA11, dA12, dA21, dA22;//转换矩阵
	//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	if (m_vCalibratedInfos.at(nCamIndex) != NULL)
	{
		delete m_vCalibratedInfos.at(nCamIndex);
		m_vCalibratedInfos.at(nCamIndex) = NULL;
	}

	//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
		{
			//if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k)!=NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k)!=NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			//if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}


	//获取该相机对应的图像坐标
	double MarkdX[7],MarkdY[7];
	for (int i=0; i<7; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
	// 平台坐标系变换矩阵计算之相机由点1到点2、由点3到点4：平台坐标偏移量，图像坐标偏移量
	dX1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	dY1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	dX2 = 2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	dY2 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;

	dx1 = MarkdX[2]-MarkdX[1];
	dy1 = MarkdY[2]-MarkdY[1];
	dx2 = MarkdX[4]-MarkdX[3];
	dy2 = MarkdY[4]-MarkdY[3];


	A[0][0] = dx1;
	A[0][1] = dy1;
	A[0][2] = 0;
	A[0][3] = 0;

	A[1][0] = 0;
	A[1][1] = 0;
	A[1][2] = dx1;
	A[1][3] = dy1;

	A[2][0] = dx2;
	A[2][1] = dy2;
	A[2][2] = 0;
	A[2][3] = 0;

	A[3][0] = 0;
	A[3][1] = 0;
	A[3][2] = dx2;
	A[3][3] = dy2;

	if (0 == MatrixInvert(A, 4))
	{
		return FALSE;
	}

	dA11 = A[0][0]*dX1 + A[0][1]*dY1 + A[0][2]*dX2 + A[0][3]*dY2;
	dA12 = A[1][0]*dX1 + A[1][1]*dY1 + A[1][2]*dX2 + A[1][3]*dY2;
	dA21 = A[2][0]*dX1 + A[2][1]*dY1 + A[2][2]*dX2 + A[2][3]*dY2;
	dA22 = A[3][0]*dX1 + A[3][1]*dY1 + A[3][2]*dX2 + A[3][3]*dY2;

	//记录变换结果
	sc2Matrix matrix(dA11,dA12,dA21,dA22);

	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);


	//$ 2.0 计算基准mark平台坐标
	CString str;
	scDegree  degRotationDegree;		// 正转旋转角度
	sc2Vector vBenchMarkImagePos;		// 基准点Mark图像坐标
	sc2Vector vStartMarkImagePos;		// 起始点（基准点）Mark图像坐标

	sc2Vector vRotatedMarkImagePos1;	// 正转后Mark图像坐标
	sc2Vector vRotatedMarkImagePos2;	// 反转后Mark图像坐标

	sc2Vector vBenchMarkPlatformPos1;	// 正转计算得到基准点Mark的平台坐标
	sc2Vector vBenchMarkPlatformPos2;   // 反转计算得到基准点Mark的平台坐标

	degRotationDegree = scDegree(m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle);

	vBenchMarkImagePos.SetX(MarkdX[0]);
	vBenchMarkImagePos.SetY(MarkdY[0]);

	vStartMarkImagePos.SetX(MarkdX[0]);
	vStartMarkImagePos.SetY(MarkdY[0]);

	vRotatedMarkImagePos1.SetX(MarkdX[5]);
	vRotatedMarkImagePos1.SetY(MarkdY[5]);

	vRotatedMarkImagePos2.SetX(MarkdX[6]);
	vRotatedMarkImagePos2.SetY(MarkdY[6]);

	// $2.1、正向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos1, degRotationDegree, matrix, 
		vBenchMarkImagePos, vBenchMarkPlatformPos1))
	{
		return FALSE;
	}


	// $2.2、反向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos2, -degRotationDegree, matrix, 
		vBenchMarkImagePos, vBenchMarkPlatformPos2))
	{
		return FALSE;
	}

	// $2.3、记录基准Mark点的平台坐标值
	CCoordPos pos;
	pos.m_dPosX = (vBenchMarkPlatformPos1.GetX() + vBenchMarkPlatformPos2.GetX())/2.0;
	pos.m_dPosY = (vBenchMarkPlatformPos1.GetY() + vBenchMarkPlatformPos2.GetY())/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	

	str.Format("基准点图像坐标X=%f,Y=%f",vBenchMarkImagePos.GetX(),vBenchMarkImagePos.GetY());
	str.Format("基准点平台坐标X=%f,Y=%f",pos.m_dPosX,pos.m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);


	//$3.0、计算图像坐标与平台坐标之间的夹角

	double tanValue1,tanValue2;
	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	tanValue1 = dA21/dA11;
	tanValue2 = (-1*dA12)/dA22;
	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	

	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
	return  TRUE;
}

// XY平台,   用9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXYSingleCamEX(int nCamIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}


	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}


	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	//获取该相机对应的图像坐标

	double MarkdX[10],MarkdY[10];
	int i=0;

	for (i=0; i<10; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;	


	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));

	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 9; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0]));
	}

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, +dPosY));
	vPlatMove.push_back(sc2Vector(+dPosX, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, -dPosY));
	vPlatMove.push_back(sc2Vector(0, -dPosY));
	vPlatMove.push_back(sc2Vector(-dPosX, -dPosY));
	vPlatMove.push_back(sc2Vector(-dPosX, 0));
	vPlatMove.push_back(sc2Vector(-dPosX, +dPosY));
	vPlatMove.push_back(sc2Vector(0, +dPosY));



	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(vImageMark,vPlatMove,h))
	{
		return FALSE;
	}



	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//把10个位置的图像坐标保存
	for (int m=0; m<10; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
	}

	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);


	//$ 2.0 计算基准mark平台坐标

	// $2.3、记录基准Mark点的平台坐标值

	CCoordPos pos;
	//if (nCamIndex==0)
	{
		pos.m_dPosX = 0;
		pos.m_dPosY = 0;
		m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	}
	// 	else
	// 	{
	// 		CPlatformAxisPos* 				pBasePlatformAxisPos;
	// 		if (m_vCalibratedInfos.at(0)!=NULL)
	// 		{
	// 			pBasePlatformAxisPos = m_vCalibratedInfos.at(0)->GetPlatformAxisPos();
	// 
	// 			pos.m_dPosX = ((CPlatformXYDAxisPos*) m_PlatformAxisPos)->m_dPosX - ((CPlatformXYDAxisPos*)pBasePlatformAxisPos)->m_dPosX;
	// 			pos.m_dPosY = ((CPlatformXYDAxisPos*) m_PlatformAxisPos)->m_dPosY - ((CPlatformXYDAxisPos*)pBasePlatformAxisPos)->m_dPosY;
	// 			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	// 		}
	// 
	// 	}




	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);


	// 
	// 	double tanValue1,tanValue2;
	// 	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	// 	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	// 	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	// 	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);
	// 
	// 	tanValue1 = dA21/dA11;
	// 	tanValue2 = (-1*dA12)/dA22;
	// 	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	// 	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	
	// 
	// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

	return  TRUE;
}

// XY平台,   用5点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXYSingleCam( int nCamIndex )
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	

	m_CalibrateParam = m_vpCalibrateParam[nCamIndex];

	//$ 1.0 计算转换矩阵

	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
	double dX1,dX2,dY1,dY2;//平台坐标偏移量
	double dx1,dy1,dx2,dy2;//图像坐标偏移量
	double A[4][4];	    // 4维矩阵,图像坐标矩阵
	double dA11, dA12, dA21, dA22;//转换矩阵
	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());

	for(int k = 0; k < m_iMarkNum; k++)
	{
		if (k != nCamIndex)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	//获取该相机对应的图像坐标
	double MarkdX[6],MarkdY[6];
	for (int i=0; i<6; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
	// 平台坐标系变换矩阵计算之相机由点1到点2、由点3到点4：平台坐标偏移量，图像坐标偏移量
	dX1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	dY1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	dX2 = 2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	dY2 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;

	dx1 = MarkdX[2]-MarkdX[1];
	dy1 = MarkdY[2]-MarkdY[1];
	dx2 = MarkdX[4]-MarkdX[3];
	dy2 = MarkdY[4]-MarkdY[3];


	A[0][0] = dx1;
	A[0][1] = dy1;
	A[0][2] = 0;
	A[0][3] = 0;

	A[1][0] = 0;
	A[1][1] = 0;
	A[1][2] = dx1;
	A[1][3] = dy1;

	A[2][0] = dx2;
	A[2][1] = dy2;
	A[2][2] = 0;
	A[2][3] = 0;

	A[3][0] = 0;
	A[3][1] = 0;
	A[3][2] = dx2;
	A[3][3] = dy2;

	if (0 == MatrixInvert(A, 4))
	{
		return FALSE;
	}

	dA11 = A[0][0]*dX1 + A[0][1]*dY1 + A[0][2]*dX2 + A[0][3]*dY2;
	dA12 = A[1][0]*dX1 + A[1][1]*dY1 + A[1][2]*dX2 + A[1][3]*dY2;
	dA21 = A[2][0]*dX1 + A[2][1]*dY1 + A[2][2]*dX2 + A[2][3]*dY2;
	dA22 = A[3][0]*dX1 + A[3][1]*dY1 + A[3][2]*dX2 + A[3][3]*dY2;

	//记录变换结果
	sc2Matrix matrix(dA11,dA12,dA21,dA22);

	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);


	//$ 2.0 计算基准mark平台坐标

	CCoordPos pos;
	//	if (nCamIndex==0)
	{
		pos.m_dPosX = 0;
		pos.m_dPosY = 0;
		m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	}
	// 	else
	// 	{
	// 		CPlatformAxisPos* 				pBasePlatformAxisPos;
	// 		if (m_vCalibratedInfos.at(0)!=NULL)
	// 		{
	// 			pBasePlatformAxisPos = m_vCalibratedInfos.at(0)->GetPlatformAxisPos();
	// 
	// 			pos.m_dPosX = ((CPlatformXYDAxisPos*) m_PlatformAxisPos)->m_dPosX - ((CPlatformXYDAxisPos*)pBasePlatformAxisPos)->m_dPosX;
	// 			pos.m_dPosY = ((CPlatformXYDAxisPos*) m_PlatformAxisPos)->m_dPosY - ((CPlatformXYDAxisPos*)pBasePlatformAxisPos)->m_dPosY;
	// 			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	// 		}
	// 
	// 	}

	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
	return  TRUE;
}

// XD平台,   用5点、9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXDSingleCamEX(int nCamIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}


	//获取该相机对应的图像坐标

	double MarkdX[5],MarkdY[5];
	int i=0;
	for (i=0; i<5; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));

	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 2; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0]));
	}

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, 0));

	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(vImageMark,vPlatMove,h,eScaleRotate))
	{
		return FALSE;
	}

	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//$ 2.0 计算基准mark平台坐标
	CString str;
	scDegree  degRotationDegree;		// 正转旋转角度
	sc2Vector vBenchMarkImagePos;		// 基准点Mark图像坐标
	sc2Vector vStartMarkImagePos;		// 起始点（基准点）Mark图像坐标

	sc2Vector vRotatedMarkImagePos1;	// 正转后Mark图像坐标
	sc2Vector vRotatedMarkImagePos2;	// 反转后Mark图像坐标

	sc2Vector vBenchMarkPlatformPos1;	// 正转计算得到基准点Mark的平台坐标
	sc2Vector vBenchMarkPlatformPos2;   // 反转计算得到基准点Mark的平台坐标

	degRotationDegree = scDegree(m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle);

	vBenchMarkImagePos.SetX(MarkdX[0]);
	vBenchMarkImagePos.SetY(MarkdY[0]);

	vStartMarkImagePos.SetX(MarkdX[0]);
	vStartMarkImagePos.SetY(MarkdY[0]);

	vRotatedMarkImagePos1.SetX(MarkdX[3]);
	vRotatedMarkImagePos1.SetY(MarkdY[3]);

	vRotatedMarkImagePos2.SetX(MarkdX[4]);
	vRotatedMarkImagePos2.SetY(MarkdY[4]);

	// $2.1、正向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos1, degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos1))
	{
		return FALSE;
	}


	// $2.2、反向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos2, -degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos2))
	{
		return FALSE;
	}

	// $2.3、记录基准Mark点的平台坐标值
	CCoordPos pos;
	pos.m_dPosX = (vBenchMarkPlatformPos1.GetX() + vBenchMarkPlatformPos2.GetX())/2.0;
	pos.m_dPosY = (vBenchMarkPlatformPos1.GetY() + vBenchMarkPlatformPos2.GetY())/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	

	str.Format("基准点图像坐标X=%f,Y=%f",vBenchMarkImagePos.GetX(),vBenchMarkImagePos.GetY());
	str.Format("基准点平台坐标X=%f,Y=%f",pos.m_dPosX,pos.m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);

	//把6个位置的图像坐标保存
	for (int m=0; m<6; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
	}

	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
	// 
	// 	double tanValue1,tanValue2;
	// 	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	// 	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	// 	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	// 	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);
	// 
	// 	tanValue1 = dA21/dA11;
	// 	tanValue2 = (-1*dA12)/dA22;
	// 	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	// 	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	
	// 
	// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

	return  TRUE;
}

// YD平台,   用5点、9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateYDSingleCamEX(int nCamIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}


	//获取该相机对应的图像坐标

	double MarkdX[5],MarkdY[5];
	int i=0;
	for (i=0; i<5; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));

	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 2; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0]));
	}

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(0, +dPosY));

	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(vImageMark,vPlatMove,h,eScaleRotate))
	{
		return FALSE;
	}

	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//$ 2.0 计算基准mark平台坐标
	CString str;
	scDegree  degRotationDegree;		// 正转旋转角度
	sc2Vector vBenchMarkImagePos;		// 基准点Mark图像坐标
	sc2Vector vStartMarkImagePos;		// 起始点（基准点）Mark图像坐标

	sc2Vector vRotatedMarkImagePos1;	// 正转后Mark图像坐标
	sc2Vector vRotatedMarkImagePos2;	// 反转后Mark图像坐标

	sc2Vector vBenchMarkPlatformPos1;	// 正转计算得到基准点Mark的平台坐标
	sc2Vector vBenchMarkPlatformPos2;   // 反转计算得到基准点Mark的平台坐标

	degRotationDegree = scDegree(m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle);

	vBenchMarkImagePos.SetX(MarkdX[0]);
	vBenchMarkImagePos.SetY(MarkdY[0]);

	vStartMarkImagePos.SetX(MarkdX[0]);
	vStartMarkImagePos.SetY(MarkdY[0]);

	vRotatedMarkImagePos1.SetX(MarkdX[3]);
	vRotatedMarkImagePos1.SetY(MarkdY[3]);

	vRotatedMarkImagePos2.SetX(MarkdX[4]);
	vRotatedMarkImagePos2.SetY(MarkdY[4]);

	// $2.1、正向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos1, degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos1))
	{
		return FALSE;
	}


	// $2.2、反向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos2, -degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos2))
	{
		return FALSE;
	}

	// $2.3、记录基准Mark点的平台坐标值
	CCoordPos pos;
	pos.m_dPosX = (vBenchMarkPlatformPos1.GetX() + vBenchMarkPlatformPos2.GetX())/2.0;
	pos.m_dPosY = (vBenchMarkPlatformPos1.GetY() + vBenchMarkPlatformPos2.GetY())/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	

	str.Format("基准点图像坐标X=%f,Y=%f",vBenchMarkImagePos.GetX(),vBenchMarkImagePos.GetY());
	str.Format("基准点平台坐标X=%f,Y=%f",pos.m_dPosX,pos.m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);

	//把6个位置的图像坐标保存
	for (int m=0; m<6; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
	}

	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
	// 
	// 	double tanValue1,tanValue2;
	// 	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	// 	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	// 	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	// 	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);
	// 
	// 	tanValue1 = dA21/dA11;
	// 	tanValue2 = (-1*dA12)/dA22;
	// 	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	// 	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	
	// 
	// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

	return  TRUE;
}

// XD+Y平台, 用5点、9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXDPYSingleCamEX(int nCamIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}


	//获取该相机对应的图像坐标

	double MarkdX[9],MarkdY[9];
	int i=0;
	for (i=0; i<9; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));

	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 3; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0])); //X方向
	}
	vImageMark.push_back(sc2Vector(MarkdX[6], MarkdY[6]) - sc2Vector(MarkdX[0], MarkdY[0]));    //Y方向
	vImageMark.push_back(sc2Vector(MarkdX[7], MarkdY[7]) - sc2Vector(MarkdX[0], MarkdY[0]));    //Y方向

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, 0));
	vPlatMove.push_back(sc2Vector(-dPosX, 0));
	vPlatMove.push_back(sc2Vector(0, +dPosY));
	vPlatMove.push_back(sc2Vector(0, -dPosY));

	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(vImageMark,vPlatMove,h,eScaleRotate))
	{
		return FALSE;
	}

	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//$ 2.0 计算基准mark平台坐标
	CString str;
	scDegree  degRotationDegree;		// 正转旋转角度
	sc2Vector vBenchMarkImagePos;		// 基准点Mark图像坐标
	sc2Vector vStartMarkImagePos;		// 起始点（基准点）Mark图像坐标

	sc2Vector vRotatedMarkImagePos1;	// 正转后Mark图像坐标
	sc2Vector vRotatedMarkImagePos2;	// 反转后Mark图像坐标

	sc2Vector vBenchMarkPlatformPos1;	// 正转计算得到基准点Mark的平台坐标
	sc2Vector vBenchMarkPlatformPos2;   // 反转计算得到基准点Mark的平台坐标

	degRotationDegree = scDegree(m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle);

	vBenchMarkImagePos.SetX(MarkdX[0]);
	vBenchMarkImagePos.SetY(MarkdY[0]);

	vStartMarkImagePos.SetX(MarkdX[0]);
	vStartMarkImagePos.SetY(MarkdY[0]);

	vRotatedMarkImagePos1.SetX(MarkdX[3]);
	vRotatedMarkImagePos1.SetY(MarkdY[3]);

	vRotatedMarkImagePos2.SetX(MarkdX[4]);
	vRotatedMarkImagePos2.SetY(MarkdY[4]);

	// $2.1、正向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos1, degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos1))
	{
		return FALSE;
	}


	// $2.2、反向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos2, -degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos2))
	{
		return FALSE;
	}

	// $2.3、记录基准Mark点的平台坐标值
	CCoordPos pos;
	pos.m_dPosX = (vBenchMarkPlatformPos1.GetX() + vBenchMarkPlatformPos2.GetX())/2.0;
	pos.m_dPosY = (vBenchMarkPlatformPos1.GetY() + vBenchMarkPlatformPos2.GetY())/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	

	str.Format("基准点图像坐标X=%f,Y=%f",vBenchMarkImagePos.GetX(),vBenchMarkImagePos.GetY());
	str.Format("基准点平台坐标X=%f,Y=%f",pos.m_dPosX,pos.m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);


	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
	// 
	// 	double tanValue1,tanValue2;
	// 	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	// 	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	// 	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	// 	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);
	// 
	// 	tanValue1 = dA21/dA11;
	// 	tanValue2 = (-1*dA12)/dA22;
	// 	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	// 	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	
	// 
	// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

	return  TRUE;
}

// XD+Y1平台,用5点、9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXDPY1SingleCamEX(int nCamIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}


	//获取该相机对应的图像坐标

	double MarkdX[7],MarkdY[7];
	int i=0;
	for (i=0; i<7; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));

	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 2; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0])); //X方向
	}
	vImageMark.push_back(sc2Vector(MarkdX[6], MarkdY[6]) - sc2Vector(MarkdX[0], MarkdY[0]));    //Y方向

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, 0));
	vPlatMove.push_back(sc2Vector(0, +dPosY));

	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(vImageMark,vPlatMove,h,eScaleRotate))
	{
		return FALSE;
	}

	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//$ 2.0 计算基准mark平台坐标
	CString str;
	scDegree  degRotationDegree;		// 正转旋转角度
	sc2Vector vBenchMarkImagePos;		// 基准点Mark图像坐标
	sc2Vector vStartMarkImagePos;		// 起始点（基准点）Mark图像坐标

	sc2Vector vRotatedMarkImagePos1;	// 正转后Mark图像坐标
	sc2Vector vRotatedMarkImagePos2;	// 反转后Mark图像坐标

	sc2Vector vBenchMarkPlatformPos1;	// 正转计算得到基准点Mark的平台坐标
	sc2Vector vBenchMarkPlatformPos2;   // 反转计算得到基准点Mark的平台坐标

	degRotationDegree = scDegree(m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle);

	vBenchMarkImagePos.SetX(MarkdX[0]);
	vBenchMarkImagePos.SetY(MarkdY[0]);

	vStartMarkImagePos.SetX(MarkdX[0]);
	vStartMarkImagePos.SetY(MarkdY[0]);

	vRotatedMarkImagePos1.SetX(MarkdX[3]);
	vRotatedMarkImagePos1.SetY(MarkdY[3]);

	vRotatedMarkImagePos2.SetX(MarkdX[4]);
	vRotatedMarkImagePos2.SetY(MarkdY[4]);

	// $2.1、正向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos1, degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos1))
	{
		return FALSE;
	}


	// $2.2、反向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos2, -degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos2))
	{
		return FALSE;
	}

	// $2.3、记录基准Mark点的平台坐标值
	CCoordPos pos;
	pos.m_dPosX = (vBenchMarkPlatformPos1.GetX() + vBenchMarkPlatformPos2.GetX())/2.0;
	pos.m_dPosY = (vBenchMarkPlatformPos1.GetY() + vBenchMarkPlatformPos2.GetY())/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	

	str.Format("基准点图像坐标X=%f,Y=%f",vBenchMarkImagePos.GetX(),vBenchMarkImagePos.GetY());
	str.Format("基准点平台坐标X=%f,Y=%f",pos.m_dPosX,pos.m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);


	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
	// 
	// 	double tanValue1,tanValue2;
	// 	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	// 	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	// 	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	// 	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);
	// 
	// 	tanValue1 = dA21/dA11;
	// 	tanValue2 = (-1*dA12)/dA22;
	// 	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	// 	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	
	// 
	// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

	return  TRUE;
}

// XY+D平台, 用9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamTarget(int nCamIndex,int nMarkType)
{

	// 详细日志
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("XY+D平台标定计算开始:位置[%d]------------------------------------------------------------",nCamIndex+1);
	AlignToolLogRecord(str,nPlatformIndex);

	if (0 == m_iMarkNum)
	{
		return FALSE;
	}

	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
// 		{
// 			//if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k)!=NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k)!=NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}


	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k)!=NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k)!=NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}


	//获取该相机对应的图像坐标
	double MarkdX[11],MarkdY[11];
	int i=0;

	if (m_vCalibPlatformMoveResults[nRemCamIndex].size()!=CALIBMOVEPOS_XYNUM+CALIBMOVEPOS_DNUM)
	{
		return FALSE;
	}

	if (m_PlatformAxisPos == NULL)
	{
		return FALSE;
	}
		

	for (i=0; i<10; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;	
	}

	// 设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);

	str.Format("基准点图像坐标X=%f,Y=%f",m_vCalibPlatformMoveResults[nRemCamIndex].at(0).m_dPosX, m_vCalibPlatformMoveResults[nRemCamIndex].at(0).m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);


	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 9; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0]));
	}

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, +dPosY));
	vPlatMove.push_back(sc2Vector(+dPosX, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, -dPosY));
	vPlatMove.push_back(sc2Vector(0, -dPosY));
	vPlatMove.push_back(sc2Vector(-dPosX, -dPosY));
	vPlatMove.push_back(sc2Vector(-dPosX, 0));
	vPlatMove.push_back(sc2Vector(-dPosX, +dPosY));
	vPlatMove.push_back(sc2Vector(0, +dPosY));

	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(vImageMark,vPlatMove,h))
	{
		return FALSE;
	}



	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//把九个位置的图像坐标保存
	for (int m=0; m<9; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;

		double dImagePosX = m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX;
		double dImagePosY = m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY;

		str.Format(_T("XY标定图象坐标%d: X: %.2f; Y: %.2f; D: %.3f;"), m, dImagePosX, dImagePosY);
		AlignToolLogRecord(str,nPlatformIndex);
	}

	for (i=0; i<4; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(CALIBMOVEPOS_XYNUM+i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(CALIBMOVEPOS_XYNUM+i).m_dPosY;

		str.Format(_T("D标定图象坐标%d: X: %.2f; Y: %.2f; D: %.3f;"), i, MarkdX[i], MarkdY[i]);
		AlignToolLogRecord(str,nPlatformIndex);
	}

	MarkdX[0] = (m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos()).GetPosX();
	MarkdY[0] = (m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos()).GetPosY();


	//$ 2.0 计算基准mark平台坐标
	scDegree  degRotationDegree;		// 正转旋转角度
	sc2Vector vBenchMarkImagePos;		// 基准点Mark图像坐标
	sc2Vector vStartMarkImagePos;		// 起始点（基准点）Mark图像坐标

	sc2Vector vRotatedMarkImagePos1;	// 正转后Mark图像坐标
	sc2Vector vRotatedMarkImagePos2;	// 反转后Mark图像坐标

	sc2Vector vBenchMarkPlatformPos1;	// 正转计算得到基准点Mark的平台坐标
	sc2Vector vBenchMarkPlatformPos2;   // 反转计算得到基准点Mark的平台坐标

	degRotationDegree = scDegree(m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle);

	vBenchMarkImagePos.SetX(MarkdX[0]);
	vBenchMarkImagePos.SetY(MarkdY[0]);

	vStartMarkImagePos.SetX(MarkdX[3]);
	vStartMarkImagePos.SetY(MarkdY[3]);

	vRotatedMarkImagePos1.SetX(MarkdX[1]);
	vRotatedMarkImagePos1.SetY(MarkdY[1]);

	vRotatedMarkImagePos2.SetX(MarkdX[2]);
	vRotatedMarkImagePos2.SetY(MarkdY[2]);


	// $2.1、正向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos1, degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos1))
	{
		return FALSE;
	}

	// $2.2、反向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos2, -degRotationDegree, h, 
		vBenchMarkImagePos, vBenchMarkPlatformPos2))
	{
		return FALSE;
	}

	CCoordPos pos;
	pos.m_dPosX = (vBenchMarkPlatformPos1.GetX() + vBenchMarkPlatformPos2.GetX())/2.0;
	pos.m_dPosY = (vBenchMarkPlatformPos1.GetY() + vBenchMarkPlatformPos2.GetY())/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	

	str.Format("基准点平台坐标X=%f,Y=%f",pos.m_dPosX,pos.m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);


	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);	

	//把三个位置的图像坐标保存到【9】【10】【11】
	for (int m=9; m<CALIBMOVEPOSNUM; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m+2).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m+2).m_dPosY;
	}

	str.Format("XY+D平台标定计算结束:位置[%d]------------------------------------------------------------\n",nCamIndex+1);
	AlignToolLogRecord(str,nPlatformIndex);

	return  TRUE;
}

// XY+D平台, 用5点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCam( int nCamIndex, int nMarkType )
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵

	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
	double dX1,dX2,dY1,dY2;//平台坐标偏移量
	double dx1,dy1,dx2,dy2;//图像坐标偏移量
	double A[4][4];	    // 4维矩阵,图像坐标矩阵
	double dA11, dA12, dA21, dA22;//转换矩阵
	//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	if (m_vCalibratedInfos.at(nCamIndex) != NULL)
	{
		delete m_vCalibratedInfos.at(nCamIndex);
		m_vCalibratedInfos.at(nCamIndex) = NULL;
	}

	//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
		{
			//if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k)!=NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k)!=NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			//if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}


	//获取该相机对应的图像坐标
	double MarkdX[7],MarkdY[7];

	//if (nMarkType==0)
	//{
	if (m_vCalibPlatformMoveResults[nRemCamIndex].size()!=CALIBMOVEPOS_XYNUM+CALIBMOVEPOS_DNUM)
	{
		return FALSE;
	}
	for (int i=0; i<6; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
	// 平台坐标系变换矩阵计算之相机由点1到点2、由点3到点4：平台坐标偏移量，图像坐标偏移量
	dX1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	dY1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	dX2 = 2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	dY2 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;

	dx1 = MarkdX[2]-MarkdX[1];
	dy1 = MarkdY[2]-MarkdY[1];
	dx2 = MarkdX[4]-MarkdX[3];
	dy2 = MarkdY[4]-MarkdY[3];


	A[0][0] = dx1;
	A[0][1] = dy1;
	A[0][2] = 0;
	A[0][3] = 0;

	A[1][0] = 0;
	A[1][1] = 0;
	A[1][2] = dx1;
	A[1][3] = dy1;

	A[2][0] = dx2;
	A[2][1] = dy2;
	A[2][2] = 0;
	A[2][3] = 0;

	A[3][0] = 0;
	A[3][1] = 0;
	A[3][2] = dx2;
	A[3][3] = dy2;

	if (0 == MatrixInvert(A, 4))
	{
		return FALSE;
	}

	dA11 = A[0][0]*dX1 + A[0][1]*dY1 + A[0][2]*dX2 + A[0][3]*dY2;
	dA12 = A[1][0]*dX1 + A[1][1]*dY1 + A[1][2]*dX2 + A[1][3]*dY2;
	dA21 = A[2][0]*dX1 + A[2][1]*dY1 + A[2][2]*dX2 + A[2][3]*dY2;
	dA22 = A[3][0]*dX1 + A[3][1]*dY1 + A[3][2]*dX2 + A[3][3]*dY2;

	//记录变换结果
	sc2Matrix matrix(dA11,dA12,dA21,dA22);

	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);

	//把6个位置的图像坐标保存
	for (int m=0; m<6; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
	}


	//}
	//else if (nMarkType==1)
	//{
	if (m_vCalibPlatformMoveResults[nRemCamIndex].size()!=CALIBMOVEPOS_XYNUM+CALIBMOVEPOS_DNUM)
	{
		return FALSE;
	}
	for (int i=0; i<4; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(CALIBMOVEPOS_XYNUM+i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(CALIBMOVEPOS_XYNUM+i).m_dPosY;
	}

	// 		sc2Matrix mat;
	// 		mat = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix();
	// 		dA11 = mat.GetElement(0,0);
	// 		dA12 = mat.GetElement(0,1);
	// 		dA21 = mat.GetElement(1,0);
	// 		dA22 = mat.GetElement(1,1);

	//$ 2.0 计算基准mark平台坐标
	CString str;
	scDegree  degRotationDegree;		// 正转旋转角度
	sc2Vector vBenchMarkImagePos;		// 基准点Mark图像坐标
	sc2Vector vStartMarkImagePos;		// 起始点（基准点）Mark图像坐标

	sc2Vector vRotatedMarkImagePos1;	// 正转后Mark图像坐标
	sc2Vector vRotatedMarkImagePos2;	// 反转后Mark图像坐标

	sc2Vector vBenchMarkPlatformPos1;	// 正转计算得到基准点Mark的平台坐标
	sc2Vector vBenchMarkPlatformPos2;   // 反转计算得到基准点Mark的平台坐标

	degRotationDegree = scDegree(m_CalibrateParam->m_dPlatformCalibMovement.m_dAngle);

	vBenchMarkImagePos.SetX(MarkdX[0]);
	vBenchMarkImagePos.SetY(MarkdY[0]);

	vStartMarkImagePos.SetX(MarkdX[0]);
	vStartMarkImagePos.SetY(MarkdY[0]);

	vRotatedMarkImagePos1.SetX(MarkdX[5]);
	vRotatedMarkImagePos1.SetY(MarkdY[5]);

	vRotatedMarkImagePos2.SetX(MarkdX[6]);
	vRotatedMarkImagePos2.SetY(MarkdY[6]);

	// $2.1、正向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos1, degRotationDegree, matrix, 
		vBenchMarkImagePos, vBenchMarkPlatformPos1))
	{
		return FALSE;
	}


	// $2.2、反向旋转Δθ角,计算基准mark平台坐标
	if (!vfCalibBenchMarkPlatformPos(vStartMarkImagePos, vRotatedMarkImagePos2, -degRotationDegree, matrix, 
		vBenchMarkImagePos, vBenchMarkPlatformPos2))
	{
		return FALSE;
	}

	// $2.3、记录基准Mark点的平台坐标值
	CCoordPos pos;
	pos.m_dPosX = (vBenchMarkPlatformPos1.GetX() + vBenchMarkPlatformPos2.GetX())/2.0;
	pos.m_dPosY = (vBenchMarkPlatformPos1.GetY() + vBenchMarkPlatformPos2.GetY())/2.0;
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	

	str.Format("基准点图像坐标X=%f,Y=%f",vBenchMarkImagePos.GetX(),vBenchMarkImagePos.GetY());
	str.Format("基准点平台坐标X=%f,Y=%f",pos.m_dPosX,pos.m_dPosY);
	AlignToolLogRecord(str,m_nPlatformIndex);


	//$3.0、计算图像坐标与平台坐标之间的夹角

	double tanValue1,tanValue2;
	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	tanValue1 = dA21/dA11;
	tanValue2 = (-1*dA12)/dA22;
	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	

	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;


	//把4个位置的图像坐标保存到[6][7][8][9]
	for (int m=6; m<10; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m-6).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m-6).m_dPosY;
	}

	//}

	return  TRUE;
}

// X平台,    用9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXSingleCamEX(int nCamIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}

	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k)!=NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	//获取该相机对应的图像坐标

	double MarkdX[4],MarkdY[4];
	int i=0;

	for (i=0; i<4; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;	


	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));

	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 2; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0]));
	}

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(+dPosX, 0));



	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(vImageMark,vPlatMove,h))
	{
		return FALSE;
	}



	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//把九个位置的图像坐标保存
	for (int m=0; m<4; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
	}

	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);


	//$ 2.0 计算基准mark平台坐标

	// $2.3、记录基准Mark点的平台坐标值

	CCoordPos pos;
	//	if (nCamIndex==0)
	{
		pos.m_dPosX = 0;
		pos.m_dPosY = 0;
		m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	}
	// 	else
	// 	{
	// 		CPlatformAxisPos* 				pBasePlatformAxisPos;
	// 		if (m_vCalibratedInfos.at(0)!=NULL)
	// 		{
	// 			pBasePlatformAxisPos = m_vCalibratedInfos.at(0)->GetPlatformAxisPos();
	// 
	// 			pos.m_dPosX = ((CPlatformXYDAxisPos*) m_PlatformAxisPos)->m_dPosX - ((CPlatformXYDAxisPos*)pBasePlatformAxisPos)->m_dPosX;
	// 			pos.m_dPosY = ((CPlatformXYDAxisPos*) m_PlatformAxisPos)->m_dPosY - ((CPlatformXYDAxisPos*)pBasePlatformAxisPos)->m_dPosY;
	// 			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	// 		}
	// 
	// 	}

	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

	return  TRUE;
}

// X平台,    用5点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXSingleCam( int nCamIndex )
{

	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵

	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
	double dX1,dX2,dY1,dY2;//平台坐标偏移量
	double dx1,dy1,dx2,dy2;//图像坐标偏移量
	double A[4][4];	    // 4维矩阵,图像坐标矩阵
	double dA11, dA12, dA21, dA22;//转换矩阵
	//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
		{
			//if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k)!=NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k)!=NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			//if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k)!=NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k)!=NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}

	//获取该相机对应的图像坐标
	double MarkdX[4],MarkdY[4];
	for (int i=0; i<4; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
	// 平台坐标系变换矩阵计算之相机由点1到点2、由点3到点4：平台坐标偏移量，图像坐标偏移量
	dX1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	dY1 = 0;// -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	dX2 = 2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	dY2 = 0;//-2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;

	dx1 = MarkdX[1]-MarkdX[0];
	dy1 = MarkdY[1]-MarkdY[0];
	dx2 = MarkdX[2]-MarkdX[3];
	dy2 = MarkdY[2]-MarkdY[3];


	A[0][0] = dx1;
	A[0][1] = dy1;
	A[0][2] = 0;
	A[0][3] = 0;

	A[1][0] = 0;
	A[1][1] = 0;
	A[1][2] = dx1;
	A[1][3] = dy1;

	A[2][0] = dx2;
	A[2][1] = dy2;
	A[2][2] = 0;
	A[2][3] = 0;

	A[3][0] = 0;
	A[3][1] = 0;
	A[3][2] = dx2;
	A[3][3] = dy2;

	if (0 == MatrixInvert(A, 4))
	{
		return FALSE;
	}

	dA11 = (dX1/dx1 + dX2/dx2)/2.0;//A[0][0]*dX1 + A[0][1]*dY1 + A[0][2]*dX2 + A[0][3]*dY2;
	dA12 = 0;//A[1][0]*dX1 + A[1][1]*dY1 + A[1][2]*dX2 + A[1][3]*dY2;
	dA21 = 0;//A[2][0]*dX1 + A[2][1]*dY1 + A[2][2]*dX2 + A[2][3]*dY2;
	dA22 = 0;//A[3][0]*dX1 + A[3][1]*dY1 + A[3][2]*dX2 + A[3][3]*dY2;

	//记录变换结果
	sc2Matrix matrix(dA11,dA12,dA21,dA22);

	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);


	//$ 2.0 计算基准mark平台坐标

	CCoordPos pos;
	//	if (nCamIndex==0)
	{
		pos.m_dPosX = 0;
		pos.m_dPosY = 0;
		m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	}
	// 	else
	// 	{
	// 		CPlatformAxisPos* 				pBasePlatformAxisPos;
	// 		if (m_vCalibratedInfos.at(0)!=NULL)
	// 		{
	// 			pBasePlatformAxisPos = m_vCalibratedInfos.at(0)->GetPlatformAxisPos();
	// 
	// 			pos.m_dPosX = ((CPlatformXYDAxisPos*) m_PlatformAxisPos)->m_dPosX - ((CPlatformXYDAxisPos*)pBasePlatformAxisPos)->m_dPosX;
	// 			pos.m_dPosY = ((CPlatformXYDAxisPos*) m_PlatformAxisPos)->m_dPosY - ((CPlatformXYDAxisPos*)pBasePlatformAxisPos)->m_dPosY;
	// 			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	
	// 		}
	// 
	// 	}

	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
	return  TRUE;
}


// Y平台,    用9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateYSingleCamEX(int nCamIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}

	int nRemCamIndex = nCamIndex % m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	//获取该相机对应的图像坐标

	double MarkdX[4],MarkdY[4];
	int i=0;

	for (i=0; i<4; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;	
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);

	std::vector<sc2Vector> vImageMark;
	for(i = 0; i < 2; i++)
	{
		vImageMark.push_back(sc2Vector(MarkdX[i], MarkdY[i]) - sc2Vector(MarkdX[0], MarkdY[0]));
	}

	//平台平面坐标
	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	std::vector<sc2Vector> vPlatMove;
	vPlatMove.push_back(sc2Vector(0, 0));
	vPlatMove.push_back(sc2Vector(0, +dPosY));


	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(vImageMark,vPlatMove,h))
	{
		return FALSE;
	}


	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//把九个位置的图像坐标保存
	for (int m=0; m<4; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
	}

	//记录变换结果
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);


	//$ 2.0 计算基准mark平台坐标
	CCoordPos pos = CCoordPos(0.0, 0.0, 0.0);
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(pos);	


	//$3.0、计算图像坐标与平台坐标之间的夹角
	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

	return  TRUE;
}



// 高低平面，标定目标平面，主要应用为叠摸
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamTarget(int nCamIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	

	int nRemCamIndex = nCamIndex % m_iMarkNum;
	// 拾取sysPlatformInfo.m_bPlatformPick = TRUE; && sysPlatformInfo.m_ePickCamPlatformType =ePickCamPlatformShareXY; 时发送FCLB指令标定崩溃
	if(m_vCalibPlatformMoveResults[nRemCamIndex].size()<11)
	{
		return FALSE;
	}

	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum * (m_nMultiCalibExtensionMaxNum+1); k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}




	//获取该相机对应的图像坐标

	double MarkdX[11],MarkdY[11];
	int i=0;
	for (i=0; i<11; i++)
	{
		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
	}

	//把十个位置的图像坐标保存
	for (int m=0; m<CALIBMOVEPOSNUM; m++)
	{
		m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
		m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
	}

	return  TRUE;
}

// 目标对象不分离，对象使用棋盘格标定
BOOL vcBaseAlignTool::ExecuteCalibrateBoardSingleCamEX(int nCamIndex)
{
	CString strInfo;
	strInfo.Format(_T("ExecuteCalibrateBoardSingleCamEX start nCamIndex == %d"), nCamIndex);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	if ( (m_bTargetObjectCamSeparate) || (!m_bTargetCalibUseBoard) )
	{
		return FALSE;
	}

	if (0 == m_iMarkNum)
	{
		return FALSE;
	}

	int nRemCamIndex = nCamIndex % m_iMarkNum;
	if (nRemCamIndex >= m_iMarkNum)
	{
		return FALSE;
	}

	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	// 目标、对象不分离，手动对象棋盘格标定，所有位置同时进行标定计算，该处需特殊处理
	if (m_vCalibratedInfos.at(nCamIndex) != NULL)
	{
		delete m_vCalibratedInfos.at(nCamIndex);
		m_vCalibratedInfos.at(nCamIndex) = NULL;	
	}
	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());


	//$ 1.0 计算转换矩阵

	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
	double dX1,dX2,dY1,dY2;			// 平台坐标偏移量
	double dx1,dy1;					// 图像坐标偏移量
	double A[4][4];					// 图像坐标矩阵
	double dA11, dA12, dA21, dA22;	// 转换矩阵

	double dMarkImgX[2],dMarkImgY[2];		// 图像坐标
	double dMarkBoardX[2],dMarkBoardY[2];	// 靶标坐标

	CCoordPos	cpCalibBoardMarkImgCoordPos[CALIBBOARDMARKPOSNUM]; // 用靶标关联映射时，标定板上的Mark位置图像坐标
	CCoordPos	cpCalibBoardMarkBoardCoordPos[CALIBBOARDMARKPOSNUM]; // 用靶标关联映射时，标定板上的Mark位置物理坐标

	// 图像坐标
	for (int i=0; i<m_iMarkNum; i++)
	{
		dMarkImgX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
		dMarkImgY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;

		cpCalibBoardMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
		cpCalibBoardMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;
	}

	strInfo.Format(_T("位置%d图像坐标dMarkImgX[0] = %.5f,dMarkImgY[0] = %.5f,dMarkImgX[1] = %.5f,dMarkImgY[1] = %.5f"),
		nCamIndex,dMarkImgX[0],dMarkImgY[0],dMarkImgX[1],dMarkImgY[1]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	// 靶标坐标
	for (int i=0; i<m_iMarkNum; i++)
	{
		dMarkBoardX[i] = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX * m_vCalibBoardSize.GetX();
		dMarkBoardY[i] = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY * m_vCalibBoardSize.GetY();

		cpCalibBoardMarkBoardCoordPos[i].m_dPosX = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
		cpCalibBoardMarkBoardCoordPos[i].m_dPosY = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;
	}
	strInfo.Format(_T("位置%d靶标坐标dMarkBoardX[0] = %.5f,dMarkBoardY[0] = %.5f,dMarkBoardX[1] = %.5f,dMarkBoardY[1] = %.5f"),
		nCamIndex,dMarkBoardX[0],dMarkBoardY[0],dMarkBoardX[1],dMarkBoardY[1]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	// 设置、获取用靶标关联映射时，标定板上的Mark位置图像坐标、物理坐标
	m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardMarkImgCoordPos(cpCalibBoardMarkImgCoordPos);
	m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardMarkBoardCoordPos(cpCalibBoardMarkBoardCoordPos);
	m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardSize(m_vCalibBoardSize);


	// 图像坐标偏移量
	dx1 = dMarkImgX[1]-dMarkImgX[0];
	dy1 = dMarkImgY[1]-dMarkImgY[0];

	// 平台坐标偏移量
	dX1 = dMarkBoardX[1] - dMarkBoardX[0];
	dY1 = dMarkBoardY[1] - dMarkBoardY[0];
	dX2 = dX1;
	dY2 = dY1;

	// 构造4*4图像坐标矩阵
	A[0][0] = dx1;
	A[0][1] = dy1;
	A[0][2] = 0;
	A[0][3] = 0;

	A[1][0] = dy1;
	A[1][1] = 0 - dx1;
	A[1][2] = 0;
	A[1][3] = 0;

	A[2][0] = 0;
	A[2][1] = 0;
	A[2][2] = 0 - dy1;
	A[2][3] = dx1;

	A[3][0] = 0;
	A[3][1] = 0;
	A[3][2] = dx1;
	A[3][3] = dy1;

	// 计算A矩阵的逆
	if (0 == MatrixInvert(A, 4))
	{
		return FALSE;
	}

	// 计算转换矩阵系数
	dA11 = A[0][0]*dX1 + A[0][1]*dY1 + A[0][2]*dX2 + A[0][3]*dY2;
	dA12 = A[1][0]*dX1 + A[1][1]*dY1 + A[1][2]*dX2 + A[1][3]*dY2;
	dA21 = A[2][0]*dX1 + A[2][1]*dY1 + A[2][2]*dX2 + A[2][3]*dY2;
	dA22 = A[3][0]*dX1 + A[3][1]*dY1 + A[3][2]*dX2 + A[3][3]*dY2;

	// 记录变换结果
	sc2Matrix matrix(dA11,dA12,dA21,dA22);
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);
	strInfo.Format(_T("位置%d矩阵dA11 = %.5f,dA12 = %.5f,dA21 = %.5f,dA22 = %.5f"),nCamIndex,dA11,dA12,dA21,dA22);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	// 设置基准mark图像坐标
	/*m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(0));*/
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(nRemCamIndex));

	// 设置平台轴位置
	CPlatformXYDAxisPos platformAxisPos;
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(&platformAxisPos);

	//$ 2.0 计算基准mark平台坐标
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos(dMarkBoardX[0], dMarkBoardY[0], 0)/*m_vCalibBoardResults[nCamIndex].at(0)*/);
	// m_vCalibBoardResults是靶标坐标系坐标，单位并不是mm，需要根据棋盘格尺寸转换

	//$3.0、计算图像坐标与平台坐标之间的夹角
	double tanValue1,tanValue2;
	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	tanValue1 = dA21/dA11;
	tanValue2 = (-1*dA12)/dA22;
	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	

	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

	strInfo.Format(_T("ExecuteCalibrateBoardSingleCamEX end nCamIndex == %d"), nCamIndex);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	return TRUE;
}

// 目标对象不分离，对象使用二维码标定
BOOL vcBaseAlignTool::ExecuteCalibrateDmCodeSingleCamEX(int nCamIndex, sc2Vector scImageCenter, std::vector<sc2Vector> &vImagePos, std::vector<sc2Vector> &vBoardPos)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}

	int nRemCamIndex = nCamIndex % m_iMarkNum;
	int nExProductIndex = nCamIndex/m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	// 目标、对象不分离，手动对象二维码标定，所有位置同时进行标定计算，该处需特殊处理
	if (m_vCalibratedInfos.at(nCamIndex) != NULL)
	{
		delete m_vCalibratedInfos.at(nCamIndex);
		m_vCalibratedInfos.at(nCamIndex) = NULL;
	}
	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());



	for (int i=0;i<vImagePos.size();i++)
	{
		CString strtmp;
		strtmp.Format("位置:%d-vImagePos:%d-%f,%f\n",nCamIndex,i,vImagePos.at(i).GetX(),vImagePos.at(i).GetY());
		AlignToolLogRecord(strtmp,m_nPlatformIndex);
	}

	for (int i=0;i<vBoardPos.size();i++)
	{
		CString strtmp;
		strtmp.Format("位置:%d-vBoardPos:%d-%f,%f\n",nCamIndex,i,vBoardPos.at(i).GetX(),vBoardPos.at(i).GetY());
		AlignToolLogRecord(strtmp,m_nPlatformIndex);
	}

	if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
	{
		CString strOut, strTmp;
		double p[15];
		memset(p, 0.0, sizeof(double)*15);
		scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
		result.GetNonlinearProjectResult(p);
		double dRms = result.GetRMS();
		strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
		for (int i=0;i<15; i++)
		{
			strTmp.Format(_T("P%d:%.6f "), i, p[i]);
			strOut += strTmp;
		}
		strTmp.Format(_T("P15:%.6f "),dRms);
		strOut += strTmp;
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		strOut.Format(_T("畸变校正前图像坐标: "));
		for (int i=0; i<vImagePos.size(); i++)
		{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vImagePos.at(i).GetX(), vImagePos.at(i).GetY());
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		std::vector<sc2Vector> tarImgPosDisCor;
		ExecuteDisCorPoint(nCamIndex, vImagePos, tarImgPosDisCor);
		vImagePos = tarImgPosDisCor;

		strOut.Format(_T("畸变校正后图像坐标: "));
		for (int i=0; i<vImagePos.size(); i++)
		{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vImagePos.at(i).GetX(), vImagePos.at(i).GetY());
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);
	}

	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	CCoordPos GuanlianOffset;
	double dis = 0 ;

	svStd vector<sc2Vector> vOffset;

	if (m_AlignermentParam.m_bEnableCalibTargetDMCodeOutLine)
	{
		int nOutNum = vImagePos.size()*m_AlignermentParam.m_dCalibTargetDMCodeOutLinePercent;
		svStd vector<bool> vUsed;
		if (!sfGetHomographyOutLine(vImagePos,vBoardPos,h,nOutNum,vUsed,eProject))
		{
			return FALSE;
		}
		//记录变换结果
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

		svStd vector<sc2Vector> tarUsedImgPos;
		svStd vector<sc2Vector> objUsedBoardPos;
		for (int nUseIndex = 0 ; nUseIndex < vUsed.size(); nUseIndex++ )
		{
			if ( vUsed[nUseIndex] )
			{
				tarUsedImgPos.push_back(vImagePos[nUseIndex]);
				objUsedBoardPos.push_back(vBoardPos[nUseIndex]);
			}	
		}
		if (!sfGetHomographyMaxError(tarUsedImgPos,objUsedBoardPos,h,dis,vOffset))
		{
			return FALSE;
		}

	}
	else
	{
		if(!sfGetHomography(vImagePos,vBoardPos,h))
		{
			return FALSE;
		}
		//记录变换结果
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

		sc2Matrix matrix(h[0],h[1],h[3],h[4]);
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);

		if (!sfGetHomographyMaxError(vImagePos,vBoardPos,h,dis,vOffset))
		{
			return FALSE;
		}
	}

	GuanlianOffset.m_dPosX = dis;
	GuanlianOffset.m_dPosY = dis;
	for (int i=0;i<4;i++)
	{
		GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
		GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

		{
			CString strtmp;
			strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
			AlignToolLogRecord(strtmp,m_nPlatformIndex);
		}
	}

	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);


	// 图像中心对应的二维码平台位置
	sc2Vector scPlatformPos = sc2Vector(0, 0);
	ConvertSrcPosToDstPos(vImagePos, vBoardPos, scImageCenter, scPlatformPos, nCamIndex, TRUE);

	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos(scPlatformPos.GetX(), scPlatformPos.GetY(), 0.0));
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(CCoordPos(scImageCenter.GetX(), scImageCenter.GetY(), 0.0));

	// 二维码标定
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos(0,0,0.0));
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(CCoordPos(0,0,0.0));

	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

	return TRUE;

}

// XYD平台
//根据某个相机标定结果来标定指定相机：同一个Mark移动2个位置，分别用对象相机和目标相机拍照定位，然后标定目标相机
//以4相机为例，一般对象相机为nBaseCamIndex，序号0、1；目标相机为nCamIndex，序号2、3；
BOOL  vcBaseAlignTool::ExecuteCalibrateSingleCamEX(int nCamIndex, int nBaseCamIndex)
{
	int nRemCamIndex = nCamIndex%m_iMarkNum;
	int nRemBaseCamIndex = nBaseCamIndex%m_iMarkNum;
	int nExProductIndex = nCamIndex/m_iMarkNum;
	int i=0;
	// 如果不用读取轴位置，那标定目标位置时只将目标相机与对象相机进行关联，计算该映射H矩阵
	if (m_bTarObjCamSepNoAxisCalib == TRUE)
	{
		if (!m_bTargetObjectCamSeparate)
		{
			return FALSE;
		}

		// 		if (m_PlatformAxisPos == NULL)
		// 		{
		// 			return FALSE;
		// 		}

		if (0 == m_iMarkNum)
		{
			return FALSE;
		}	

		if (nRemCamIndex < m_iMarkNum/2)
		{
			return FALSE;
		}

		if (nRemBaseCamIndex < 0 || nRemBaseCamIndex >= m_iMarkNum/2)
		{
			return FALSE;
		}

		m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

		//$ 1.0 计算转换矩阵
		if (m_bEnableMultiCalibExtension == TRUE)
		{
			for(int k = 0; k < m_iMarkNum; k++)
			{
				for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
				{
					if (j != nExProductIndex)
					{
						if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
						}
						else
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
						}
					}
				}
			}
		}

		if (m_vCalibratedInfos.at(nCamIndex) != NULL)
		{
			delete m_vCalibratedInfos.at(nCamIndex);
			m_vCalibratedInfos.at(nCamIndex) = NULL;
		}

		if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
		{
			m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
		}
		else
		{
			m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}

		for(int k = 0 + m_iMarkNum*nExProductIndex; k < m_iMarkNum/2 + m_iMarkNum*nExProductIndex; k++)
		{
			if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}

		//获取该相机对应的图像坐标
		double dTargetMarkdX,dTargetMarkdY;
		double dObjectMarkdX,dObjectMarkdY;		

		double dTargetX[4],dTargetY[4];
		double dObjectX[4],dObjectY[4];	

		std::vector<sc2Vector> vTargetMark;
		std::vector<sc2Vector> vObjectMark;
		/*int i=0;*/
		if (m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point)
		{
			i = 0;
			{
				// 目标位值的移动位置i的图像坐标
				dTargetX[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(0);
				dTargetY[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(0);
				vTargetMark.push_back(sc2Vector(dTargetX[0],dTargetY[0]));

				dTargetX[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(1);
				dTargetY[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(1);
				vTargetMark.push_back(sc2Vector(dTargetX[1],dTargetY[1]));

				// 对象位值的移动位置i的图像坐标
				dObjectX[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(0);
				dObjectY[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(0);
				vObjectMark.push_back(sc2Vector(dObjectX[0],dObjectY[0]));

				dObjectX[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(1);
				dObjectY[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(1);
				vObjectMark.push_back(sc2Vector(dObjectX[1],dObjectY[1]));
			}
			i = 1;
			{
				// 目标位值的移动位置i的图像坐标
				dTargetX[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(2);
				dTargetY[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(2);
				vTargetMark.push_back(sc2Vector(dTargetX[2],dTargetY[2]));

				dTargetX[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(3);
				dTargetY[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(3);
				vTargetMark.push_back(sc2Vector(dTargetX[3],dTargetY[3]));

				// 对象位值的移动位置i的图像坐标
				dObjectX[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(2);
				dObjectY[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(2);
				vObjectMark.push_back(sc2Vector(dObjectX[2],dObjectY[2]));

				dObjectX[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(3);
				dObjectY[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(3);
				vObjectMark.push_back(sc2Vector(dObjectX[3],dObjectY[3]));
			}
			vTargetMark.push_back(sc2Vector((dTargetX[0]+dTargetX[1]+dTargetX[2]+dTargetX[3])/4,(dTargetY[0]+dTargetY[1]+dTargetY[2]+dTargetY[3])/4));
			vObjectMark.push_back(sc2Vector((dObjectX[0]+dObjectX[1]+dObjectX[2]+dObjectX[3])/4,(dObjectY[0]+dObjectY[1]+dObjectY[2]+dObjectY[3])/4));

			for (/*int */i=0;i<5;i++)
			{
				CString strtmp;
				strtmp.Format("位置:%d-vTargetMark:%d-%f,%f\n",nCamIndex,i,vTargetMark.at(i).GetX(),vTargetMark.at(i).GetY());
				AlignToolLogRecord(strtmp,m_nPlatformIndex);
			}

			for (/*int */i=0;i<5;i++)
			{
				CString strtmp;
				strtmp.Format("位置:%d-vObjectMark:%d-%f,%f\n",nBaseCamIndex,i,vObjectMark.at(i).GetX(),vObjectMark.at(i).GetY());
				AlignToolLogRecord(strtmp,m_nPlatformIndex);
			}
		}
		else
		{
			for(i = 0; i < 2; i++)
			{
				// 目标位值的移动位置i的图像坐标
				dTargetMarkdX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
				dTargetMarkdY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;
				vTargetMark.push_back(sc2Vector(dTargetMarkdX,dTargetMarkdY));

				// 对象位值的移动位置i的图像坐标
				dObjectMarkdX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX;
				dObjectMarkdY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY;
				vObjectMark.push_back(sc2Vector(dObjectMarkdX,dObjectMarkdY));
			}
		}

		if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<vTargetMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			std::vector<sc2Vector> vTargetMarkDisCor;
			ExecuteDisCorPoint(nCamIndex, vTargetMark, vTargetMarkDisCor);
			vTargetMark = vTargetMarkDisCor;

			strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<vTargetMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);
		}

		if (m_vpCalibrateParam[nRemBaseCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nBaseCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("参考位置:%d, 畸变参数: "), nBaseCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<vObjectMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vObjectMark.at(i).GetX(), vObjectMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			std::vector<sc2Vector> vObjectMarkDisCor;
			ExecuteDisCorPoint(nBaseCamIndex, vObjectMark, vObjectMarkDisCor);
			vObjectMark = vObjectMarkDisCor;

			strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<vObjectMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vObjectMark.at(i).GetX(), vObjectMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);
		}

		// 计算H变换矩阵
		double h[9];
		memset(h, 0.0, sizeof(double)*9);

		if(!sfGetHomography(vTargetMark,vObjectMark,h))
		{
			return FALSE;
		}

		//记录变换结果
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

		CCoordPos GuanlianOffset;
		double dis = 0 ;

		svStd vector<sc2Vector> vOffset;

		//把2个位置的图像坐标保存
		if (m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point)
		{
			if (!sfGetHomographyMaxError(vTargetMark,vObjectMark,h,dis,vOffset))
			{
				return FALSE;
			}
			GuanlianOffset.m_dPosX = dis;
			GuanlianOffset.m_dPosY = dis;
			for (/*int */i=0;i<4;i++)
			{
				GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
				GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

				{
					CString strtmp;
					strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
					AlignToolLogRecord(strtmp,m_nPlatformIndex);
				}
			}

			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);

			i = 0;
			{
				// 目标位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[0].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(0);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[0].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(0);
				vTargetMark.push_back(sc2Vector(dTargetX[0],dTargetY[0]));

				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[1].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(1);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[1].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(1);
				vTargetMark.push_back(sc2Vector(dTargetX[1],dTargetY[1]));

				// 对象位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[0].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(0);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[0].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(0);
				vObjectMark.push_back(sc2Vector(dObjectX[0],dObjectY[0]));

				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[1].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(1);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[1].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(1);
				vObjectMark.push_back(sc2Vector(dObjectX[1],dObjectY[1]));
			}
			i = 1;
			{
				// 目标位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[2].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(2);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[2].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(2);
				vTargetMark.push_back(sc2Vector(dTargetX[2],dTargetY[2]));

				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[3].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(3);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[3].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(3);
				vTargetMark.push_back(sc2Vector(dTargetX[3],dTargetY[3]));

				// 对象位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[2].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(2);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[2].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(2);

				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[3].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(3);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[3].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(3);
			}

		}
		else
		{
			for (i = 0; i < 2; i++)
			{
				// 对象位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX;
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY;

				// 目标位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;		
			}

		}
		m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

		return TRUE;
	}
	else
	{
		// 如果用读取轴位置，那标定目标位置,则是直接将目标位置与平台关联起来
		if (!m_bTargetObjectCamSeparate)
		{
			return FALSE;
		}

// 		if (m_bPlatformTarCamWithDiffObjCam)
// 		{
// 			if (m_vSpecialPlatformAxisPos.at(nBaseCamIndex) == NULL)
// 			{
// 				return FALSE;
// 			}
// 		}
// 		else
		{
			if (m_PlatformAxisPos == NULL)
			{
				return FALSE;
			}
		}



		if (0 == m_iMarkNum)
		{
			return FALSE;
		}	

		if (nRemCamIndex < m_iMarkNum/2)
		{
			return FALSE;
		}

		if (nRemBaseCamIndex < 0 || nRemBaseCamIndex >= m_iMarkNum/2)
		{
			return FALSE;
		}

		m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

		//$ 1.0 计算转换矩阵

		//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
		double dX1,dX2,dY1,dY2;//平台坐标偏移量
		double dx1,dy1/*,dx2,dy2*/;//图像坐标偏移量
		double A[4][4];	    // 4维矩阵,图像坐标矩阵
		double dA11, dA12, dA21, dA22;//转换矩阵


		if (m_bEnableMultiCalibExtension == TRUE)
		{
			for(int k = 0; k < m_iMarkNum; k++)
			{
				for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
				{
					if (j != nExProductIndex)
					{
						if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
						}
						else
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
						}
					}
				}
			}
		}

		if (m_vCalibratedInfos.at(nCamIndex) != NULL)
		{
			delete m_vCalibratedInfos.at(nCamIndex);
			m_vCalibratedInfos.at(nCamIndex) = NULL;
		}
		//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
		{
			m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
		}
		else
		{
			m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}

		for(int k = 0 + m_iMarkNum*nExProductIndex; k < m_iMarkNum/2 + m_iMarkNum*nExProductIndex; k++)
		{
			if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}

					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}

					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}


		if (m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point)
		{
			//获取该相机对应的图像坐标
			// 			double MarkdX[5],MarkdY[5];
			// 			int i=0;
			// 			for (i=0; i<2; i++)
			// 			{
			// 				MarkdX[i] = m_vCalibPlatformMoveResults[nCamIndex].at(m_iMarkNum*i+nCamIndex).m_dPosX;
			// 				MarkdY[i] = m_vCalibPlatformMoveResults[nCamIndex].at(m_iMarkNum*i+nCamIndex).m_dPosY;
			// 			}

			double dTargetX[4],dTargetY[4];
			double dObjectX[4],dObjectY[4];	

			CCoordPos objectMarkImgPos[4];		//图像坐标

			std::vector<sc2Vector> vTargetMark;//图像坐标
			std::vector<sc2Vector> vObjectMark;//平台坐标

			/*int */i = 0;
			{
				// 目标位值的移动位置i的图像坐标
				dTargetX[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(0);
				dTargetY[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(0);
				vTargetMark.push_back(sc2Vector(dTargetX[0],dTargetY[0]));

				dTargetX[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(1);
				dTargetY[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(1);
				vTargetMark.push_back(sc2Vector(dTargetX[1],dTargetY[1]));

				// 对象位值的移动位置i的图像坐标
				objectMarkImgPos[0].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(0);
				objectMarkImgPos[0].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(0);

				objectMarkImgPos[1].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(1);
				objectMarkImgPos[1].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(1);
			}
			i = 1;
			{
				// 目标位值的移动位置i的图像坐标
				dTargetX[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(2);
				dTargetY[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(2);
				vTargetMark.push_back(sc2Vector(dTargetX[2],dTargetY[2]));

				dTargetX[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(3);
				dTargetY[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(3);
				vTargetMark.push_back(sc2Vector(dTargetX[3],dTargetY[3]));

				// 对象位值的移动位置i的图像坐标
				objectMarkImgPos[2].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(2);
				objectMarkImgPos[2].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(2);

				objectMarkImgPos[3].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(3);
				objectMarkImgPos[3].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(3);
			}
			vTargetMark.push_back(sc2Vector((dTargetX[0]+dTargetX[1]+dTargetX[2]+dTargetX[3])/4,(dTargetY[0]+dTargetY[1]+dTargetY[2]+dTargetY[3])/4));


			for (/*int */i=0;i<5;i++)
			{
				CString strtmp;
				strtmp.Format("位置:%d-vTargetMark:%d-%f,%f\n",nCamIndex,i,vTargetMark.at(i).GetX(),vTargetMark.at(i).GetY());
				AlignToolLogRecord(strtmp,m_nPlatformIndex);
			}

			if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
			{
				CString strOut, strTmp;
				double p[15];
				memset(p, 0.0, sizeof(double)*15);
				scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
				result.GetNonlinearProjectResult(p);
				double dRms = result.GetRMS();
				strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
				for (int i=0;i<15; i++)
				{
					strTmp.Format(_T("P%d:%.6f "), i, p[i]);
					strOut += strTmp;
				}
				strTmp.Format(_T("P15:%.6f "),dRms);
				strOut += strTmp;
				AlignToolLogRecord(strOut,m_nPlatformIndex);

				strOut.Format(_T("畸变校正前图像坐标: "));
				for (int i=0; i<vTargetMark.size(); i++)
				{
					strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
					strOut += strTmp;
				}
				AlignToolLogRecord(strOut,m_nPlatformIndex);

				std::vector<sc2Vector> vTargetMarkDisCor;
				ExecuteDisCorPoint(nCamIndex, vTargetMark, vTargetMarkDisCor);
				vTargetMark = vTargetMarkDisCor;
				for (int i=0;i<vTargetMark.size()-1;i++)
				{
					dTargetX[i]=vTargetMark.at(i).GetX();
					dTargetY[i]=vTargetMark.at(i).GetY();
				}
				strOut.Format(_T("畸变校正后图像坐标: "));
				for (int i=0; i<vTargetMark.size(); i++)
				{
					strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
					strOut += strTmp;
				}
				AlignToolLogRecord(strOut,m_nPlatformIndex);
			}


			CCoordPos objectMarkPlatformPos[4];		// 贴合到对象平台后对应点的平台坐标

			for (i=0; i<4; i++)
			{			
				ConvertImagePosToCurPlatformPos(objectMarkPlatformPos[i],  nBaseCamIndex, objectMarkImgPos[i], m_pTargetPlatformAxisPos.at(nRemBaseCamIndex));
				dObjectX[i] = objectMarkPlatformPos[i].m_dPosX;
				dObjectY[i] = objectMarkPlatformPos[i].m_dPosY;
				vObjectMark.push_back(sc2Vector(dObjectX[i],dObjectY[i]));
			}

			vObjectMark.push_back(sc2Vector((dObjectX[0]+dObjectX[1]+dObjectX[2]+dObjectX[3])/4,(dObjectY[0]+dObjectY[1]+dObjectY[2]+dObjectY[3])/4));

			for (/*int */i=0;i<5;i++)
			{
				CString strtmp;
				strtmp.Format("位置:%d-vObjectMark:%d-%f,%f\n",nBaseCamIndex,i,vObjectMark.at(i).GetX(),vObjectMark.at(i).GetY());
				AlignToolLogRecord(strtmp,m_nPlatformIndex);
			}
			CCoordPos imgPos;
			imgPos.m_dPosX = (dTargetX[0]+dTargetX[1]+dTargetX[2]+dTargetX[3])/4;
			imgPos.m_dPosY = (dTargetY[0]+dTargetY[1]+dTargetY[2]+dTargetY[3])/4;
			m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(imgPos);
			//m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nCamIndex].at(nCamIndex));
			//m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 			if (m_bPlatformTarCamWithDiffObjCam)
// 			{
// 				m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_vSpecialPlatformAxisPos.at(nBaseCamIndex));
// 			}
// 			else
			{
				m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
			}


			CCoordPos platPos;
			platPos.m_dPosX = (dObjectX[0]+dObjectX[1]+dObjectX[2]+dObjectX[3])/4;
			platPos.m_dPosY = (dObjectY[0]+dObjectY[1]+dObjectY[2]+dObjectY[3])/4;
			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(platPos);

			std::vector<sc2Vector> vTargetMarkOffSet;
			std::vector<sc2Vector> vObjectMarkOffSet;

			for (/*int */i=0;i<5;i++)
			{
				vTargetMarkOffSet.push_back(vTargetMark.at(i)-vTargetMark.at(4));
				vObjectMarkOffSet.push_back(vObjectMark.at(i)-vObjectMark.at(4));
			}

			// 计算H变换矩阵
			double h[9];
			memset(h, 0.0, sizeof(double)*9);

			if(!sfGetHomography(vTargetMarkOffSet,vObjectMarkOffSet,h))
			{
				return FALSE;
			}

			i = 0;
			{
				// 目标位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[0].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(0);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[0].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(0);
				vTargetMark.push_back(sc2Vector(dTargetX[0],dTargetY[0]));

				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[1].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(1);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[1].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(1);
				vTargetMark.push_back(sc2Vector(dTargetX[1],dTargetY[1]));

				// 对象位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[0].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(0);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[0].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(0);
				vObjectMark.push_back(sc2Vector(dObjectX[0],dObjectY[0]));

				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[1].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(1);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[1].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(1);
				vObjectMark.push_back(sc2Vector(dObjectX[1],dObjectY[1]));
			}
			i = 1;
			{
				// 目标位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[2].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(2);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[2].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(2);
				vTargetMark.push_back(sc2Vector(dTargetX[2],dTargetY[2]));

				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[3].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(3);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[3].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(3);
				vTargetMark.push_back(sc2Vector(dTargetX[3],dTargetY[3]));

				// 对象位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[2].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(2);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[2].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(2);

				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[3].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(3);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[3].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(3);
			}

			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			CCoordPos GuanlianOffset;
			double dis = 0 ;

			svStd vector<sc2Vector> vOffset;

			//把2个位置的图像坐标保存

			if (!sfGetHomographyMaxErrorInverseProject(vTargetMarkOffSet,vObjectMarkOffSet,h,dis,vOffset))
			{
				return FALSE;
			}

			GuanlianOffset.m_dPosX = dis;
			GuanlianOffset.m_dPosY = dis;
			for (/*int */i=0;i<4;i++)
			{
				GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
				GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

				{
					CString strtmp;
					strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
					AlignToolLogRecord(strtmp,m_nPlatformIndex);
				}
			}

			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);


			//记录变换结果
			sc2Matrix matrix(h[0],h[1],h[3],h[4]);

			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);


			//$ 2.0 计算基准mark平台坐标



			m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;

			m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

			return TRUE;
		}
		else
		{
			//获取该相机对应的图像坐标
			double MarkdX[2],MarkdY[2];
			/*int i=0;*/
			for (i=0; i<2; i++)
			{
				MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
				MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;
			}

			if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
			{
				std::vector<sc2Vector> vtmpTargetMark;
				for (i=0;i<2;i++)
				{
					vtmpTargetMark.push_back(sc2Vector(MarkdX[i],MarkdY[i]));
				}
				CString strOut, strTmp;
				double p[15];
				memset(p, 0.0, sizeof(double)*15);
				scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
				result.GetNonlinearProjectResult(p);
				double dRms = result.GetRMS();
				strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
				for (int i=0;i<15; i++)
				{
					strTmp.Format(_T("P%d:%.6f "), i, p[i]);
					strOut += strTmp;
				}
				strTmp.Format(_T("P15:%.6f "),dRms);
				strOut += strTmp;
				AlignToolLogRecord(strOut,m_nPlatformIndex);

				strOut.Format(_T("畸变校正前图像坐标: "));
				for (int i=0; i<vtmpTargetMark.size(); i++)
				{
					strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vtmpTargetMark.at(i).GetX(), vtmpTargetMark.at(i).GetY());
					strOut += strTmp;
				}
				AlignToolLogRecord(strOut,m_nPlatformIndex);

				std::vector<sc2Vector> vTargetMarkDisCor;
				ExecuteDisCorPoint(nCamIndex, vtmpTargetMark, vTargetMarkDisCor);
				vtmpTargetMark = vTargetMarkDisCor;
				for (int i=0;i<vtmpTargetMark.size();i++)
				{
					MarkdX[i]=vtmpTargetMark.at(i).GetX();
					MarkdY[i]=vtmpTargetMark.at(i).GetY();
				}
				strOut.Format(_T("畸变校正后图像坐标: "));
				for (int i=0; i<vtmpTargetMark.size(); i++)
				{
					strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vtmpTargetMark.at(i).GetX(), vtmpTargetMark.at(i).GetY());
					strOut += strTmp;
				}
				AlignToolLogRecord(strOut,m_nPlatformIndex);
			}

			CCoordPos objectMarkPlatformPos[2];		// 贴合到对象平台后对应点的平台坐标
			for (i=0; i<2; i++)
			{			
				ConvertImagePosToCurPlatformPos(objectMarkPlatformPos[i],  nBaseCamIndex, m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex), 
					m_pTargetPlatformAxisPos.at(nRemBaseCamIndex));
			}

			// 	for (i=0; i<2; i++)
			// 	{
			// 		if (nCamIndex == 0)
			// 		{
			// 			objectMarkPlatformPos[i].m_dPosX = objectMarkPlatformPos[i].m_dPosX - m_CalibrateParam->GetCalibMovementPos1().m_dPosX;
			// 			objectMarkPlatformPos[i].m_dPosY = objectMarkPlatformPos[i].m_dPosY - m_CalibrateParam->GetCalibMovementPos1().m_dPosY;
			// 		}
			// 		if (nCamIndex == 1)
			// 		{
			// 			objectMarkPlatformPos[i].m_dPosX = objectMarkPlatformPos[i].m_dPosX - m_CalibrateParam->GetCalibMovementPos2().m_dPosX;
			// 			objectMarkPlatformPos[i].m_dPosY = objectMarkPlatformPos[i].m_dPosY - m_CalibrateParam->GetCalibMovementPos2().m_dPosY;
			// 		}
			// 	}

			//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
			CCoordPos markImgPos;
			markImgPos.SetPos(MarkdX[0],MarkdY[0]);
			m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(markImgPos);
			/*m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(nRemCamIndex));*/
			//m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
			//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 			if (m_bPlatformTarCamWithDiffObjCam)
// 			{
// 				m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_vSpecialPlatformAxisPos.at(nBaseCamIndex));
// 			}
// 			else
			{
				m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
			}

			// 平台坐标系变换矩阵计算之相机由点1到点2、由点1到点3：平台坐标偏移量，图像坐标偏移量
			// 	dX1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
			// 	dY1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
			// 	dX2 = 2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
			// 	dY2 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;

			dX1 = objectMarkPlatformPos[1].m_dPosX - objectMarkPlatformPos[0].m_dPosX;
			dY1 = objectMarkPlatformPos[1].m_dPosY - objectMarkPlatformPos[0].m_dPosY;
			dX2 = dX1;
			dY2 = dY1;
			// 	dX2 = objectMarkPlatformPos[2].m_dPosX - objectMarkPlatformPos[0].m_dPosX;
			// 	dY2 = objectMarkPlatformPos[2].m_dPosY - objectMarkPlatformPos[0].m_dPosY;

			dx1 = MarkdX[1]-MarkdX[0];
			dy1 = MarkdY[1]-MarkdY[0];
			// 	dx2 = MarkdX[2]-MarkdX[0];
			// 	dy2 = MarkdY[2]-MarkdY[0];


			A[0][0] = dx1;
			A[0][1] = dy1;
			A[0][2] = 0;
			A[0][3] = 0;

			A[1][0] = dy1;
			A[1][1] = 0 - dx1;
			A[1][2] = 0;
			A[1][3] = 0;

			A[2][0] = 0;
			A[2][1] = 0;
			A[2][2] = 0 - dy1;
			A[2][3] = dx1;

			A[3][0] = 0;
			A[3][1] = 0;
			A[3][2] = dx1;
			A[3][3] = dy1;

			// 	A[1][0] = 0;
			// 	A[1][1] = 0;
			// 	A[1][2] = dx1;
			// 	A[1][3] = dy1;
			// 	
			// 	A[2][0] = dx2;
			// 	A[2][1] = dy2;
			// 	A[2][2] = 0;
			// 	A[2][3] = 0;
			// 	
			// 	A[3][0] = 0;
			// 	A[3][1] = 0;
			// 	A[3][2] = dx2;
			// 	A[3][3] = dy2;

			if (0 == MatrixInvert(A, 4))
			{
				return FALSE;
			}

			dA11 = A[0][0]*dX1 + A[0][1]*dY1 + A[0][2]*dX2 + A[0][3]*dY2;
			dA12 = A[1][0]*dX1 + A[1][1]*dY1 + A[1][2]*dX2 + A[1][3]*dY2;
			dA21 = A[2][0]*dX1 + A[2][1]*dY1 + A[2][2]*dX2 + A[2][3]*dY2;
			dA22 = A[3][0]*dX1 + A[3][1]*dY1 + A[3][2]*dX2 + A[3][3]*dY2;

			//记录变换结果
			sc2Matrix matrix(dA11,dA12,dA21,dA22);

			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);

			// 计算H变换矩阵
			double h[9];
			memset(h, 0.0, sizeof(double)*9);
			h[0]=dA11;h[1]=dA12;h[3]=dA21;h[4]=dA22;h[8]=1;
			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			//$ 2.0 计算基准mark平台坐标

			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(objectMarkPlatformPos[0]);


			//$3.0、计算图像坐标与平台坐标之间的夹角

			double tanValue1,tanValue2;
			double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
			double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
			double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
			double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);

			tanValue1 = dA21/dA11;
			tanValue2 = (-1*dA12)/dA22;
			tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
			tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	

			m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

			for (i = 0; i < 2; i++)
			{
				// 对象位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX;
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY;

				// 目标位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;		
			}

			m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

			return TRUE;
		}

	}
	return FALSE;
}

// XY+D平台
//根据某个相机标定结果来标定指定相机：同一个Mark移动2个位置，分别用对象相机和目标相机拍照定位，然后标定目标相机
//以4相机为例，一般对象相机为nBaseCamIndex，序号0、1；目标相机为nCamIndex，序号2、3；
BOOL  vcBaseAlignTool::ExecuteFCBSCalibrateSingleCamEX(int nCamIndex, int nBaseCamIndex)
{
	CString strInfo;
	// 如果不用读取轴位置，那标定目标位置时只将目标相机与对象相机进行关联，计算该映射H矩阵
	int nRemCamIndex = nCamIndex%m_iMarkNum;
	int nRemBaseCamIndex = nBaseCamIndex%m_iMarkNum;
	int nExProductIndex = nCamIndex/m_iMarkNum;
	if (m_bTarObjCamSepNoAxisCalib == TRUE)
	{

		if (!m_bTargetObjectCamSeparate)
		{
			return FALSE;
		}

		// 		if (m_PlatformAxisPos == NULL)
		// 		{
		// 			return FALSE;
		// 		}

		if (0 == m_iMarkNum)
		{
			return FALSE;
		}	

		if (nRemCamIndex > m_iMarkNum/2)
		{
			return FALSE;
		}

		if (nRemBaseCamIndex > m_iMarkNum || nRemBaseCamIndex < m_iMarkNum/2)
		{
			return FALSE;
		}

		m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

		//$ 1.0 计算转换矩阵

		//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
		// 		double dX1,dX2,dY1,dY2;//平台坐标偏移量
		// 		double dx1,dy1/*,dx2,dy2*/;//图像坐标偏移量
		// 		double A[4][4];	    // 4维矩阵,图像坐标矩阵
		// 		double dA11, dA12, dA21, dA22;//转换矩阵
		if (m_bEnableMultiCalibExtension == TRUE)
		{
			for(int k = 0; k < m_iMarkNum; k++)
			{
				for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
				{
					if (j != nExProductIndex)
					{
						if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
						}
						else
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
						}
					}
				}
			}
		}

		if (m_vCalibratedInfos.at(nCamIndex) != NULL)
		{
			delete m_vCalibratedInfos.at(nCamIndex);
			m_vCalibratedInfos.at(nCamIndex) = NULL;
		}
		//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
		{
			m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
		}
		else
		{
			m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}
		for(int k = m_iMarkNum/2 + m_iMarkNum*nExProductIndex; k < m_iMarkNum+ m_iMarkNum*nExProductIndex; k++)
		{
			if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}

		//获取该相机对应的图像坐标
		double dTargetMarkdX,dTargetMarkdY;
		double dObjectMarkdX,dObjectMarkdY;		

		double dTargetX[4],dTargetY[4];
		double dObjectX[4],dObjectY[4];	

		std::vector<sc2Vector> vTargetMark;
		std::vector<sc2Vector> vObjectMark;
		int i=0;
		if (m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point)
		{
			i = 0;
			{
				// 目标位值的移动位置i的图像坐标
				dTargetX[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(0);
				dTargetY[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(0);
				vTargetMark.push_back(sc2Vector(dTargetX[0],dTargetY[0]));

				dTargetX[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(1);
				dTargetY[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(1);
				vTargetMark.push_back(sc2Vector(dTargetX[1],dTargetY[1]));

				// 对象位值的移动位置i的图像坐标
				dObjectX[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(0);
				dObjectY[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(0);
				vObjectMark.push_back(sc2Vector(dObjectX[0],dObjectY[0]));

				dObjectX[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(1);
				dObjectY[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(1);
				vObjectMark.push_back(sc2Vector(dObjectX[1],dObjectY[1]));
			}
			i = 1;
			{
				// 目标位值的移动位置i的图像坐标
				dTargetX[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(2);
				dTargetY[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(2);
				vTargetMark.push_back(sc2Vector(dTargetX[2],dTargetY[2]));

				dTargetX[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(3);
				dTargetY[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(3);
				vTargetMark.push_back(sc2Vector(dTargetX[3],dTargetY[3]));

				// 对象位值的移动位置i的图像坐标
				dObjectX[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(2);
				dObjectY[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(2);
				vObjectMark.push_back(sc2Vector(dObjectX[2],dObjectY[2]));

				dObjectX[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(3);
				dObjectY[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(3);
				vObjectMark.push_back(sc2Vector(dObjectX[3],dObjectY[3]));
			}
			vTargetMark.push_back(sc2Vector((dTargetX[0]+dTargetX[1]+dTargetX[2]+dTargetX[3])/4,(dTargetY[0]+dTargetY[1]+dTargetY[2]+dTargetY[3])/4));
			vObjectMark.push_back(sc2Vector((dObjectX[0]+dObjectX[1]+dObjectX[2]+dObjectX[3])/4,(dObjectY[0]+dObjectY[1]+dObjectY[2]+dObjectY[3])/4));

			for (int i=0;i<5;i++)
			{
				CString strtmp;
				strtmp.Format("位置:%d-vTargetMark:%d-%f,%f\n",nCamIndex,i,vTargetMark.at(i).GetX(),vTargetMark.at(i).GetY());
				AlignToolLogRecord(strtmp,m_nPlatformIndex);
			}

			for (int i=0;i<5;i++)
			{
				CString strtmp;
				strtmp.Format("位置:%d-vObjectMark:%d-%f,%f\n",nBaseCamIndex,i,vObjectMark.at(i).GetX(),vObjectMark.at(i).GetY());
				AlignToolLogRecord(strtmp,m_nPlatformIndex);
			}
		}
		else
		{
			for(i = 0; i < 2; i++)
			{
				// 对象位置的移动位置i的图像坐标
				dTargetMarkdX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
				dTargetMarkdY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;
				vTargetMark.push_back(sc2Vector(dTargetMarkdX,dTargetMarkdY));

				// 目标位置的移动位置i的图像坐标
				dObjectMarkdX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX;
				dObjectMarkdY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY;
				vObjectMark.push_back(sc2Vector(dObjectMarkdX,dObjectMarkdY));

				strInfo.Format("Object[%d] m_dPosX:%f m_dPosY:%f",i,dTargetMarkdX,dTargetMarkdX);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

				strInfo.Format("Target[%d] m_dPosX:%f m_dPosY:%f",i,dObjectMarkdX,dObjectMarkdY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);
			}
		}
		if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<vTargetMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			std::vector<sc2Vector> vTargetMarkDisCor;
			ExecuteDisCorPoint(nCamIndex, vTargetMark, vTargetMarkDisCor);
			vTargetMark = vTargetMarkDisCor;

			strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<vTargetMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);
		}

		if (m_vpCalibrateParam[nRemBaseCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nBaseCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("参考位置:%d, 畸变参数: "), nBaseCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<vObjectMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vObjectMark.at(i).GetX(), vObjectMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			std::vector<sc2Vector> vObjectMarkDisCor;
			ExecuteDisCorPoint(nBaseCamIndex, vObjectMark, vObjectMarkDisCor);
			vObjectMark = vObjectMarkDisCor;

			strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<vObjectMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vObjectMark.at(i).GetX(), vObjectMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);
		}

		// 计算H变换矩阵
		double h[9];
		memset(h, 0.0, sizeof(double)*9);

		if(!sfGetHomography(vTargetMark,vObjectMark,h))
		{
			return FALSE;
		}

		//记录变换结果
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

		CCoordPos GuanlianOffset;
		double dis = 0 ;

		svStd vector<sc2Vector> vOffset;
		if (m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point)
		{
			if (!sfGetHomographyMaxError(vTargetMark,vObjectMark,h,dis,vOffset))
			{
				return FALSE;
			}
			GuanlianOffset.m_dPosX = dis;
			GuanlianOffset.m_dPosY = dis;
			for (int i=0;i<4;i++)
			{
				GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
				GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

				{
					CString strtmp;
					strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
					AlignToolLogRecord(strtmp,m_nPlatformIndex);
				}
			}

			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);

			for (int i = 0; i < 2; i++)
			{
				// 对象位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(i);
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(i);

				// 目标位值的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(i);
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(i);		
			}

		}
		else
		{
			//把2个位置的图像坐标保存
			for (i = 0; i < 2; i++)
			{
				// 对象位置的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
				m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;

				// 目标位置的移动位置i的图像坐标
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX;
				m_vCalibratedInfos.at(nCamIndex)->m_cpTargetMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY;		
			}
		}


		m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

		return TRUE;
	}
	else
	{
		// 如果用读取轴位置，那标定目标位置,则是直接将目标位置与平台关联起来

		strInfo.Format("Enter ExecuteFCBSCalibrateSingleCamEX:nCamIndex:%d,nBaseCamIndex:%d",nCamIndex,nBaseCamIndex);
		AlignToolLogRecord(strInfo,0);

		if (!m_bTargetObjectCamSeparate)
		{
			return FALSE;
		}

		if (m_PlatformAxisPos == NULL)
		{
			return FALSE;
		}

		if (0 == m_iMarkNum)
		{
			return FALSE;
		}	

		if (nRemCamIndex > m_iMarkNum/2)
		{
			return FALSE;
		}

		if (nRemBaseCamIndex > m_iMarkNum || nRemBaseCamIndex < m_iMarkNum/2)
		{
			return FALSE;
		}

		m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

		//$ 1.0 计算转换矩阵

		//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
		double dX1,dX2,dY1,dY2;//平台坐标偏移量
		double dx1,dy1/*,dx2,dy2*/;//图像坐标偏移量
		double A[4][4];	    // 4维矩阵,图像坐标矩阵
		double dA11, dA12, dA21, dA22;//转换矩阵
		if (m_bEnableMultiCalibExtension == TRUE)
		{
			for(int k = 0; k < m_iMarkNum; k++)
			{
				for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
				{
					if (j != nExProductIndex)
					{
						if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
						}
						else
						{
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
						}
					}
				}
			}
		}
		if (m_vCalibratedInfos.at(nCamIndex) != NULL)
		{
			delete m_vCalibratedInfos.at(nCamIndex);
			m_vCalibratedInfos.at(nCamIndex) = NULL;
		}

		//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
		{
			m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
		}
		else
		{
			m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}
		for(int k = m_iMarkNum/2+ m_iMarkNum*nExProductIndex; k < m_iMarkNum+ m_iMarkNum*nExProductIndex; k++)
		{
			if (k != nCamIndex)
			{
				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
		if (m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point)
		{


			//获取该相机对应的图像坐标
			// 			double MarkdX[5],MarkdY[5];
			// 			int i=0;
			// 			for (i=0; i<2; i++)
			// 			{
			// 				MarkdX[i] = m_vCalibPlatformMoveResults[nCamIndex].at(m_iMarkNum*i+nCamIndex).m_dPosX;
			// 				MarkdY[i] = m_vCalibPlatformMoveResults[nCamIndex].at(m_iMarkNum*i+nCamIndex).m_dPosY;
			// 			}

			double dTargetX[4],dTargetY[4];
			double dObjectX[4],dObjectY[4];	

			CCoordPos objectMarkImgPos[4];		//图像坐标

			std::vector<sc2Vector> vTargetMark;//图像坐标
			std::vector<sc2Vector> vObjectMark;//平台坐标

			int i = 0;
			{
				// 目标位值的移动位置i的图像坐标
				dTargetX[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(0);
				dTargetY[0] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(0);
				vTargetMark.push_back(sc2Vector(dTargetX[0],dTargetY[0]));

				dTargetX[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(1);
				dTargetY[1] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(1);
				vTargetMark.push_back(sc2Vector(dTargetX[1],dTargetY[1]));

				// 对象位值的移动位置i的图像坐标
				objectMarkImgPos[0].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(0);
				objectMarkImgPos[0].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(0);

				objectMarkImgPos[1].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(1);
				objectMarkImgPos[1].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(1);
			}
			i = 1;
			{
				// 目标位值的移动位置i的图像坐标
				dTargetX[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(2);
				dTargetY[2] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(2);
				vTargetMark.push_back(sc2Vector(dTargetX[2],dTargetY[2]));

				dTargetX[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosX(3);
				dTargetY[3] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).GetAuxiliaryPosY(3);
				vTargetMark.push_back(sc2Vector(dTargetX[3],dTargetY[3]));

				// 对象位值的移动位置i的图像坐标
				objectMarkImgPos[2].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(2);
				objectMarkImgPos[2].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(2);

				objectMarkImgPos[3].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosX(3);
				objectMarkImgPos[3].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).GetAuxiliaryPosY(3);
			}
			vTargetMark.push_back(sc2Vector((dTargetX[0]+dTargetX[1]+dTargetX[2]+dTargetX[3])/4,(dTargetY[0]+dTargetY[1]+dTargetY[2]+dTargetY[3])/4));


			for (int i=0;i<5;i++)
			{
				CString strtmp;
				strtmp.Format("位置:%d-vTargetMark:%d-%f,%f\n",nCamIndex,i,vTargetMark.at(i).GetX(),vTargetMark.at(i).GetY());
				AlignToolLogRecord(strtmp,m_nPlatformIndex);
			}


			if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
			{
				CString strOut, strTmp;
				double p[15];
				memset(p, 0.0, sizeof(double)*15);
				scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
				result.GetNonlinearProjectResult(p);
				double dRms = result.GetRMS();
				strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
				for (int i=0;i<15; i++)
				{
					strTmp.Format(_T("P%d:%.6f "), i, p[i]);
					strOut += strTmp;
				}
				strTmp.Format(_T("P15:%.6f "),dRms);
				strOut += strTmp;
				AlignToolLogRecord(strOut,m_nPlatformIndex);

				strOut.Format(_T("畸变校正前图像坐标: "));
				for (int i=0; i<vTargetMark.size(); i++)
				{
					strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
					strOut += strTmp;
				}
				AlignToolLogRecord(strOut,m_nPlatformIndex);

				std::vector<sc2Vector> vTargetMarkDisCor;
				ExecuteDisCorPoint(nCamIndex, vTargetMark, vTargetMarkDisCor);
				vTargetMark = vTargetMarkDisCor;
				for (int i=0;i<vTargetMark.size()-1;i++)
				{
					dTargetX[i]=vTargetMark.at(i).GetX();
					dTargetY[i]=vTargetMark.at(i).GetY();
				}
				strOut.Format(_T("畸变校正后图像坐标: "));
				for (int i=0; i<vTargetMark.size(); i++)
				{
					strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
					strOut += strTmp;
				}
				AlignToolLogRecord(strOut,m_nPlatformIndex);
			}

			CCoordPos objectMarkPlatformPos[4];		// 贴合到对象平台后对应点的平台坐标

			for (i=0; i<4; i++)
			{			
				ConvertImagePosToCurPlatformPos(objectMarkPlatformPos[i],  nBaseCamIndex, objectMarkImgPos[i], m_pTargetPlatformAxisPos.at(nRemBaseCamIndex));
				//===================
				//关联过程中，如果对象相机位置1的X与对象相机位置2的X不同的话，需要将变化量算到平台坐标中。
				//如：镜像位置（平台进入到目标相机能够看到Mark时），X轴位置为96.192,前进位置（平台回退到对象相机位置附近，在位置1【X轴位置为95.192】，相机1能够看到Mark；在位置2【X轴位置为97.192】，相机2能够看到Mark）
				//位置1的平台坐标需要减小1（96.192-95.192）,位置2的平台坐标需要增加1（97.192-96.192）
				//===================
				strInfo.Format("Before objectMarkPlatformPos[%d] m_dPosX:%f m_dPosY:%f",i,objectMarkPlatformPos[i].m_dPosX,objectMarkPlatformPos[i].m_dPosY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

				double dDetaX = (((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosX - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX);
				if (((CPlatformXYDInfo*)m_pPlatformParam)->m_nPlatformXCoordType == eDirectNegative)
				{
					dDetaX = -dDetaX;
				}
				objectMarkPlatformPos[i].m_dPosX = objectMarkPlatformPos[i].m_dPosX + dDetaX;

				double dDetaY = (((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosY - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY);
				if (((CPlatformXYDInfo*)m_pPlatformParam)->m_nPlatformYCoordType == eDirectNegative)
				{
					dDetaY = -dDetaY;
				}
				objectMarkPlatformPos[i].m_dPosY = objectMarkPlatformPos[i].m_dPosY + dDetaY;

				strInfo.Format("m_pTargetPlatformAxisPos.at(%d):%f,%f",nCamIndex,((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosX,((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);
				strInfo.Format("m_PlatformAxisPos:%f,%f",((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX,((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

				strInfo.Format("After objectMarkPlatformPos[%d] m_dPosX:%f m_dPosY:%f",i,objectMarkPlatformPos[i].m_dPosX,objectMarkPlatformPos[i].m_dPosY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);


				dObjectX[i] = objectMarkPlatformPos[i].m_dPosX;
				dObjectY[i] = objectMarkPlatformPos[i].m_dPosY;
				vObjectMark.push_back(sc2Vector(dObjectX[i],dObjectY[i]));
			}

			vObjectMark.push_back(sc2Vector((dObjectX[0]+dObjectX[1]+dObjectX[2]+dObjectX[3])/4,(dObjectY[0]+dObjectY[1]+dObjectY[2]+dObjectY[3])/4));

			for (int i=0;i<5;i++)
			{
				CString strtmp;
				strtmp.Format("位置:%d-vObjectMark:%d-%f,%f\n",nBaseCamIndex,i,vObjectMark.at(i).GetX(),vObjectMark.at(i).GetY());
				AlignToolLogRecord(strtmp,m_nPlatformIndex);
			}
			CCoordPos imgPos;
			imgPos.m_dPosX = (dTargetX[0]+dTargetX[1]+dTargetX[2]+dTargetX[3])/4;
			imgPos.m_dPosY = (dTargetY[0]+dTargetY[1]+dTargetY[2]+dTargetY[3])/4;
			m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(imgPos);
			//m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nCamIndex].at(nCamIndex));
			//m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 			if (m_bPlatformTarCamWithDiffObjCam)
// 			{
// 				m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_vSpecialPlatformAxisPos.at(nBaseCamIndex));
// 			}
// 			else
			{
				m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
			}


			CCoordPos platPos;
			platPos.m_dPosX = (dObjectX[0]+dObjectX[1]+dObjectX[2]+dObjectX[3])/4;
			platPos.m_dPosY = (dObjectY[0]+dObjectY[1]+dObjectY[2]+dObjectY[3])/4;
			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(platPos);

			std::vector<sc2Vector> vTargetMarkOffSet;
			std::vector<sc2Vector> vObjectMarkOffSet;

			for (int i=0;i<5;i++)
			{
				vTargetMarkOffSet.push_back(vTargetMark.at(i)-vTargetMark.at(4));
				vObjectMarkOffSet.push_back(vObjectMark.at(i)-vObjectMark.at(4));
			}

			// 计算H变换矩阵
			double h[9];
			memset(h, 0.0, sizeof(double)*9);

			if(!sfGetHomography(vTargetMarkOffSet,vObjectMarkOffSet,h))
			{
				return FALSE;
			}

			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			CCoordPos GuanlianOffset;
			double dis = 0 ;

			svStd vector<sc2Vector> vOffset;

			//把2个位置的图像坐标保存

			if (!sfGetHomographyMaxErrorInverseProject(vTargetMarkOffSet,vObjectMarkOffSet,h,dis,vOffset))
			{
				return FALSE;
			}

			GuanlianOffset.m_dPosX = dis;
			GuanlianOffset.m_dPosY = dis;
			for (int i=0;i<4;i++)
			{
				GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
				GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

				{
					CString strtmp;
					strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
					AlignToolLogRecord(strtmp,m_nPlatformIndex);
				}
			}

			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);


			//记录变换结果
			sc2Matrix matrix(h[0],h[1],h[3],h[4]);

			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);


			//$ 2.0 计算基准mark平台坐标
			m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;

			m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

			return TRUE;
		}
		else
		{
			//获取该相机对应的图像坐标
			double MarkdX[2],MarkdY[2];
			int i=0;
			for (i=0; i<2; i++)
			{
				MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
				MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;
			}

			if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
			{
				std::vector<sc2Vector> vtmpTargetMark;
				for (i=0;i<2;i++)
				{
					vtmpTargetMark.push_back(sc2Vector(MarkdX[i],MarkdY[i]));
				}
				CString strOut, strTmp;
				double p[15];
				memset(p, 0.0, sizeof(double)*15);
				scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
				result.GetNonlinearProjectResult(p);
				double dRms = result.GetRMS();
				strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
				for (int i=0;i<15; i++)
				{
					strTmp.Format(_T("P%d:%.6f "), i, p[i]);
					strOut += strTmp;
				}
				strTmp.Format(_T("P15:%.6f "),dRms);
				strOut += strTmp;
				AlignToolLogRecord(strOut,m_nPlatformIndex);

				strOut.Format(_T("畸变校正前图像坐标: "));
				for (int i=0; i<vtmpTargetMark.size(); i++)
				{
					strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vtmpTargetMark.at(i).GetX(), vtmpTargetMark.at(i).GetY());
					strOut += strTmp;
				}
				AlignToolLogRecord(strOut,m_nPlatformIndex);

				std::vector<sc2Vector> vTargetMarkDisCor;
				ExecuteDisCorPoint(nCamIndex, vtmpTargetMark, vTargetMarkDisCor);
				vtmpTargetMark = vTargetMarkDisCor;
				for (int i=0;i<vtmpTargetMark.size();i++)
				{
					MarkdX[i]=vtmpTargetMark.at(i).GetX();
					MarkdY[i]=vtmpTargetMark.at(i).GetY();
				}
				strOut.Format(_T("畸变校正后图像坐标: "));
				for (int i=0; i<vtmpTargetMark.size(); i++)
				{
					strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vtmpTargetMark.at(i).GetX(), vtmpTargetMark.at(i).GetY());
					strOut += strTmp;
				}
				AlignToolLogRecord(strOut,m_nPlatformIndex);
			}

			CCoordPos objectMarkPlatformPos[2];		// 贴合到对象平台后对应点的平台坐标
			for (i=0; i<2; i++)
			{			
				ConvertImagePosToCurPlatformPos(objectMarkPlatformPos[i],  nBaseCamIndex, m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex), 
					m_pTargetPlatformAxisPos.at(nRemBaseCamIndex));

				//===================
				//关联过程中，如果对象相机位置1的X与对象相机位置2的X不同的话，需要将变化量算到平台坐标中。
				//如：镜像位置（平台进入到目标相机能够看到Mark时），X轴位置为96.192,前进位置（平台回退到对象相机位置附近，在位置1【X轴位置为95.192】，相机1能够看到Mark；在位置2【X轴位置为97.192】，相机2能够看到Mark）
				//位置1的平台坐标需要减小1（96.192-95.192）,位置2的平台坐标需要增加1（97.192-96.192）
				//===================
				strInfo.Format("Before objectMarkPlatformPos[%d] m_dPosX:%f m_dPosY:%f",i,objectMarkPlatformPos[i].m_dPosX,objectMarkPlatformPos[i].m_dPosY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

				double dDetaX = (((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosX - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX);
				if (((CPlatformXYDInfo*)m_pPlatformParam)->m_nPlatformXCoordType == eDirectNegative)
				{
					dDetaX = -dDetaX;
				}
				objectMarkPlatformPos[i].m_dPosX = objectMarkPlatformPos[i].m_dPosX + dDetaX;

				double dDetaY = (((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosY - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY);
				if (((CPlatformXYDInfo*)m_pPlatformParam)->m_nPlatformYCoordType == eDirectNegative)
				{
					dDetaY = -dDetaY;
				}
				objectMarkPlatformPos[i].m_dPosY = objectMarkPlatformPos[i].m_dPosY + dDetaY;

				strInfo.Format("m_pTargetPlatformAxisPos.at(%d):%f,%f",nCamIndex,((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosX,((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);
				strInfo.Format("m_PlatformAxisPos:%f,%f",((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX,((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

				strInfo.Format("After objectMarkPlatformPos[%d] m_dPosX:%f m_dPosY:%f",i,objectMarkPlatformPos[i].m_dPosX,objectMarkPlatformPos[i].m_dPosY);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

			}

			// 	for (i=0; i<2; i++)
			// 	{
			// 		if (nCamIndex == 0)
			// 		{
			// 			objectMarkPlatformPos[i].m_dPosX = objectMarkPlatformPos[i].m_dPosX - m_CalibrateParam->GetCalibMovementPos1().m_dPosX;
			// 			objectMarkPlatformPos[i].m_dPosY = objectMarkPlatformPos[i].m_dPosY - m_CalibrateParam->GetCalibMovementPos1().m_dPosY;
			// 		}
			// 		if (nCamIndex == 1)
			// 		{
			// 			objectMarkPlatformPos[i].m_dPosX = objectMarkPlatformPos[i].m_dPosX - m_CalibrateParam->GetCalibMovementPos2().m_dPosX;
			// 			objectMarkPlatformPos[i].m_dPosY = objectMarkPlatformPos[i].m_dPosY - m_CalibrateParam->GetCalibMovementPos2().m_dPosY;
			// 		}
			// 	}

			//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
			CCoordPos markImgPos;
			markImgPos.SetPos(MarkdX[0],MarkdY[0]);
			m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(markImgPos);
			/*m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(nCamIndex));*/
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
			//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));

			// 平台坐标系变换矩阵计算之相机由点1到点2、由点1到点3：平台坐标偏移量，图像坐标偏移量
			// 	dX1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
			// 	dY1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
			// 	dX2 = 2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
			// 	dY2 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;

			dX1 = objectMarkPlatformPos[1].m_dPosX - objectMarkPlatformPos[0].m_dPosX;
			dY1 = objectMarkPlatformPos[1].m_dPosY - objectMarkPlatformPos[0].m_dPosY;
			dX2 = dX1;
			dY2 = dY1;
			// 	dX2 = objectMarkPlatformPos[2].m_dPosX - objectMarkPlatformPos[0].m_dPosX;
			// 	dY2 = objectMarkPlatformPos[2].m_dPosY - objectMarkPlatformPos[0].m_dPosY;

			dx1 = MarkdX[1]-MarkdX[0];
			dy1 = MarkdY[1]-MarkdY[0];
			// 	dx2 = MarkdX[2]-MarkdX[0];
			// 	dy2 = MarkdY[2]-MarkdY[0];


			A[0][0] = dx1;
			A[0][1] = dy1;
			A[0][2] = 0;
			A[0][3] = 0;

			A[1][0] = dy1;
			A[1][1] = 0 - dx1;
			A[1][2] = 0;
			A[1][3] = 0;

			A[2][0] = 0;
			A[2][1] = 0;
			A[2][2] = 0 - dy1;
			A[2][3] = dx1;

			A[3][0] = 0;
			A[3][1] = 0;
			A[3][2] = dx1;
			A[3][3] = dy1;

			// 	A[1][0] = 0;
			// 	A[1][1] = 0;
			// 	A[1][2] = dx1;
			// 	A[1][3] = dy1;
			// 	
			// 	A[2][0] = dx2;
			// 	A[2][1] = dy2;
			// 	A[2][2] = 0;
			// 	A[2][3] = 0;
			// 	
			// 	A[3][0] = 0;
			// 	A[3][1] = 0;
			// 	A[3][2] = dx2;
			// 	A[3][3] = dy2;

			if (0 == MatrixInvert(A, 4))
			{
				return FALSE;
			}

			dA11 = A[0][0]*dX1 + A[0][1]*dY1 + A[0][2]*dX2 + A[0][3]*dY2;
			dA12 = A[1][0]*dX1 + A[1][1]*dY1 + A[1][2]*dX2 + A[1][3]*dY2;
			dA21 = A[2][0]*dX1 + A[2][1]*dY1 + A[2][2]*dX2 + A[2][3]*dY2;
			dA22 = A[3][0]*dX1 + A[3][1]*dY1 + A[3][2]*dX2 + A[3][3]*dY2;

			//记录变换结果
			sc2Matrix matrix(dA11,dA12,dA21,dA22);

			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);

			// 计算H变换矩阵
			double h[9];
			memset(h, 0.0, sizeof(double)*9);
			h[0]=dA11;h[1]=dA12;h[3]=dA21;h[4]=dA22;h[8]=1;
			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
			//$ 2.0 计算基准mark平台坐标

			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(objectMarkPlatformPos[0]);


			//$3.0、计算图像坐标与平台坐标之间的夹角

			double tanValue1,tanValue2;
			double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
			double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
			double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
			double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);

			tanValue1 = dA21/dA11;
			tanValue2 = (-1*dA12)/dA22;
			tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
			tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	

			m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

			m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

			return TRUE;
		}

	}
	return FALSE;
}

// 使用二维码靶标进行关联计算
// BOOL vcBaseAlignTool::ExecuteCalibrateDmCode(int nCalibPos,std::vector<sc2Vector>& tarImgPos,std::vector<sc2Vector>& objImgPos)
// {
//     if (m_iMarkNum == 0)
//     {
//         return FALSE;
//     }
//     if (m_bTargetObjectCamSeparate)// 如果目标相机和对象相机是独立的
//     {		
// 		/*if (ePlatformXD == m_eMidPlatformType)
// 		{
// 		return FALSE;
// 		}*/
//         /*else */if (ePlatformXY == m_eMidPlatformType)
//         {
//             //return FALSE;
//             // 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
//             if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
//             {
//                     return FALSE;
//             }
//             else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
//             {
//                 if (FALSE == ExecuteCalibrateSingleCamDmCodeTarget(nCalibPos, nCalibPos - m_iMarkNum/2,tarImgPos,objImgPos))
//                     return FALSE;
//             }
//         }
//         //else if (ePlatformX == m_eMidPlatformType)
//         //{
//         //    return FALSE;
//         //}
//         //else if (ePlatformYD == m_eMidPlatformType)
//         //{
//         //    return FALSE;
//         //}
//         //else if (ePlatformXDPY == m_eMidPlatformType)
//         //{
//         //    return FALSE;
//         //}
//         //else if (ePlatformXDPY1 == m_eMidPlatformType)
//         //{
//         //    return FALSE;
//         //}
//         else if (ePlatformXYPD == m_eMidPlatformType)
//         {
//             //return FALSE;
//             // 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
//             if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
//             {
//                 if (FALSE == ExecuteCalibrateSingleCamDmCodeObject(nCalibPos, nCalibPos + m_iMarkNum/2,tarImgPos,objImgPos))
//                     return FALSE;
//             }
//             else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
//             {
//                 return FALSE;
//             }
//         }
//         else
//         {
//             // 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
//             if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
//             {
//                 if (ePlatformCalib9Point == m_PlatformCalibType)
//                 {
//                     if (FALSE == ExecuteCalibrateSingleCamDmCodeObject(nCalibPos, nCalibPos + m_iMarkNum/2,tarImgPos,objImgPos))
//                         return FALSE;
//                 }
//                 else
//                 {
//                     if (FALSE == ExecuteCalibrateSingleCamDmCodeObject(nCalibPos, nCalibPos + m_iMarkNum/2,tarImgPos,objImgPos))
//                         return FALSE;
//                 }
//             }
//             else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
//             {
//                 if (ePlatformCalib9Point == m_PlatformCalibType)
//                 {
//                     if (FALSE ==  ExecuteCalibrateSingleCamDmCodeTarget(nCalibPos, nCalibPos - m_iMarkNum/2,tarImgPos,objImgPos))
//                         return FALSE;
// 					
//                 }
//                 else
//                 {
//                     if (FALSE ==  ExecuteCalibrateSingleCamDmCodeTarget(nCalibPos, nCalibPos - m_iMarkNum/2,tarImgPos,objImgPos))
//                         return FALSE;
//                 }
//             }
//         }
// 
// 
//     }
//     else// 如果目标相机和对象相机不是独立的，那么所有相机位置就按照标准的标定方法进行标定
//     {
//         if (ePlatformXD == m_eMidPlatformType)
//         {
//             return FALSE;
//         }
//         else if (ePlatformXY == m_eMidPlatformType)
//         {
//             return FALSE;
//         }
//         else if (ePlatformX == m_eMidPlatformType)
//         {
//             return FALSE;
//         }
//         else if (ePlatformYD == m_eMidPlatformType)
//         {
//             return FALSE;
//         }
//         else if (ePlatformXDPY == m_eMidPlatformType)
//         {
//             return FALSE;
//         }
//         else if (ePlatformXDPY1 == m_eMidPlatformType)
//         {
//             return FALSE;
//         }
//         else if (ePlatformXYPD == m_eMidPlatformType)
//         {
//             return FALSE;
//         }
//         else
//         {
//             return FALSE;
//             
//         }
//     }
//     return TRUE;
// 
// }

// 使用二维码靶标进行关联计算
BOOL vcBaseAlignTool::ExecuteCalibrateDmCode(int nCalibPos,std::vector<sc2Vector>& tarImgPos,std::vector<sc2Vector>& objImgPos)
{
    if (m_iMarkNum == 0)
    {
        return FALSE;
    }

    if (m_bTargetObjectCamSeparate)// 如果目标相机和对象相机是独立的
    {		
        if (ePlatformXY == m_eMidPlatformType)
        {
            // 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
            if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
            {
                return FALSE;
            }
            else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
            {
                if (FALSE == ExecuteCalibrateSingleCamDmCodeTarget(nCalibPos, nCalibPos - m_iMarkNum/2,tarImgPos,objImgPos))
                    return FALSE;
            }
        }
        else if (ePlatformXYPD == m_eMidPlatformType)
        {
            // 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
            if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
            {
                if (FALSE == ExecuteCalibrateSingleCamDmCodeObject(nCalibPos, nCalibPos + m_iMarkNum/2,tarImgPos,objImgPos))
                    return FALSE;
            }
            else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
            {
                return FALSE;
            }
        }
        else
        {
            // 序号小于m_iMarkNum/2的位置（即对象位置相机），还按照原来的方式进行标定
            if (nCalibPos%m_iMarkNum < m_iMarkNum/2)
            {
                if (ePlatformCalib9Point == m_PlatformCalibType)
                {
                    if (FALSE == ExecuteCalibrateSingleCamDmCodeObject(nCalibPos, nCalibPos + m_iMarkNum/2,tarImgPos,objImgPos))
                        return FALSE;
                }
                else
                {
                    if (FALSE == ExecuteCalibrateSingleCamDmCodeObject(nCalibPos, nCalibPos + m_iMarkNum/2,tarImgPos,objImgPos))
                        return FALSE;
                }
            }
            else// 序号大于m_iMarkNum/2的位置（即目标位置相机），则按照新的方式进行标定，通过对应的对象相机来计算标定结果
            {
                if (ePlatformCalib9Point == m_PlatformCalibType)
                {
                    if (FALSE ==  ExecuteCalibrateSingleCamDmCodeTarget(nCalibPos, nCalibPos - m_iMarkNum/2,tarImgPos,objImgPos))
                        return FALSE;
					
                }
                else
                {
                    if (FALSE ==  ExecuteCalibrateSingleCamDmCodeTarget(nCalibPos, nCalibPos - m_iMarkNum/2,tarImgPos,objImgPos))
                        return FALSE;
                }
            }
        }
    }
    else// 如果目标相机和对象相机不是独立的，那么所有相机位置就按照标准的标定方法进行标定
    {
		return FALSE;
    }

    return TRUE;

}

// XYD平台， 二维码靶标进行关联计算
BOOL  vcBaseAlignTool::ExecuteCalibrateSingleCamDmCodeTarget(int nCamIndex, int nBaseCamIndex,std::vector<sc2Vector>& tarImgPos,std::vector<sc2Vector>& objImgPos)
{
	CString strInfo;
	CString strTmpInfo;
	strInfo.Format(_T("位置%d:二维码关联计算开始--------------"),nCamIndex);
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	int nRemCamIndex = nCamIndex%m_iMarkNum;
	int nRemBaseCamIndex = nBaseCamIndex%m_iMarkNum;
	int nExProductIndex = nCamIndex/m_iMarkNum;
	std::vector<sc2Vector> tarImgInputPos = tarImgPos;
	std::vector<sc2Vector> objImgInputPos =objImgPos;

    if (m_bTarObjCamSepNoAxisCalib == TRUE)
    {
        if (!m_bTargetObjectCamSeparate)
        {
            return FALSE;
        }
        if (0 == m_iMarkNum)
        {
            return FALSE;
        }	

        if (nRemCamIndex < m_iMarkNum/2)
        {
            return FALSE;
        }

        if (nRemBaseCamIndex < 0 || nRemBaseCamIndex >= m_iMarkNum/2)
        {
            return FALSE;
        }

        if (tarImgPos.size()<2)
        {
            return FALSE;
        }
        if (objImgPos.size()<2)
        {
            return FALSE;
        }
        m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
		if (m_bEnableMultiCalibExtension == TRUE)
		{
			for(int k = 0; k < m_iMarkNum; k++)
			{
				for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
				{
					if (j != nExProductIndex)
					{
						if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
						}
						else
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
						}
					}
				}
			}
		}


        //$ 1.0 计算转换矩阵

        //参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
        // 		double dX1,dX2,dY1,dY2;//平台坐标偏移量
        // 		double dx1,dy1/*,dx2,dy2*/;//图像坐标偏移量
        // 		double A[4][4];	    // 4维矩阵,图像坐标矩阵
        // 		double dA11, dA12, dA21, dA22;//转换矩阵
		if (m_vCalibratedInfos.at(nCamIndex) != NULL)
		{
			delete m_vCalibratedInfos.at(nCamIndex);
			m_vCalibratedInfos.at(nCamIndex) = NULL;
		}
        if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
        {
            m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
        }
        else
        {
            m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
        }
        for(int k = 0 + m_iMarkNum*nExProductIndex; k < m_iMarkNum/2 + m_iMarkNum*nExProductIndex; k++)
        {
            if (k != nCamIndex)
            {
                if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
                {
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
                    m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
                }
                else
                {
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
                    m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
                }
            }
        }

        //for (int i=0;i<tarImgPos.size();i++)
        //{
        //    CString strtmp;
        //    strtmp.Format("位置:%d-vTargetMark:%d-%f,%f\n",nCamIndex,i,tarImgPos.at(i).GetX(),tarImgPos.at(i).GetY());
        //    AlignToolLogRecord(strtmp,m_nPlatformIndex);
        //}
        //for (int i=0;i<objImgPos.size();i++)
        //{
        //    CString strtmp;
        //    strtmp.Format("位置:%d-vObjectMark:%d-%f,%f\n",nBaseCamIndex,i,objImgPos.at(i).GetX(),objImgPos.at(i).GetY());
        //    AlignToolLogRecord(strtmp,m_nPlatformIndex);
        //}

		if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			/*strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<tarImgPos.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, tarImgPos.at(i).GetX(), tarImgPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/

			std::vector<sc2Vector> tarImgPosDisCor;
			ExecuteDisCorPoint(nCamIndex, tarImgPos, tarImgPosDisCor);
			tarImgPos = tarImgPosDisCor;

			/*strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<tarImgPos.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, tarImgPos.at(i).GetX(), tarImgPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/
		}

		if (m_vpCalibrateParam[nRemBaseCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nBaseCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("参考位置:%d, 畸变参数: "), nBaseCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			/*strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<objImgPos.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, objImgPos.at(i).GetX(), objImgPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/

			std::vector<sc2Vector> objImgPosDisCor;
			ExecuteDisCorPoint(nBaseCamIndex, objImgPos, objImgPosDisCor);
			objImgPos = objImgPosDisCor;

			/*strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<objImgPos.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, objImgPos.at(i).GetX(), objImgPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/
		}

        // 计算H变换矩阵
        double h[9];
        memset(h, 0.0, sizeof(double)*9);

		CCoordPos GuanlianOffset;
		double dis = 0 ;
		int nOutNum = 0;
		int nTotolNum =  tarImgPos.size();
		svStd vector<sc2Vector> vOffset;
		svStd vector<sc2Vector> tarUsedImgPos;
		svStd vector<sc2Vector> objUsedImgPos;
		svStd vector<sc2Vector> tarOrgUsedImgPos;
		svStd vector<sc2Vector> objOrgUsedImgPos;
		//二维码关联时忽略点
		if (m_AlignermentParam.m_bEnableCalibTargetDMCodeOutLine)
		{
			nOutNum = tarImgPos.size()*m_AlignermentParam.m_dCalibTargetDMCodeOutLinePercent;
			strInfo.Format(_T("忽略点数:%d"),nOutNum);
			AlignToolLogRecord(strInfo,m_nPlatformIndex);
			svStd vector<bool> vUsed;
			if (!sfGetHomographyOutLine(tarImgPos,objImgPos,h,nOutNum,vUsed,eProject))
			{
				return FALSE;
			}

			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			for (int nUseIndex = 0 ; nUseIndex < vUsed.size(); nUseIndex++ )
			{
				if ( vUsed[nUseIndex] )
				{
					tarUsedImgPos.push_back(tarImgPos[nUseIndex]);
					objUsedImgPos.push_back(objImgPos[nUseIndex]);
					tarOrgUsedImgPos.push_back(tarImgInputPos[nUseIndex]);
					objOrgUsedImgPos.push_back(objImgInputPos[nUseIndex]);
				}	
			}
			if (!sfGetHomographyMaxError(tarUsedImgPos,objUsedImgPos,h,dis,vOffset))
			{
				return FALSE;
			}
			


		}
		else
		{
			if(!sfGetHomography(tarImgPos,objImgPos,h))
			{
				return FALSE;
			}

			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			if (!sfGetHomographyMaxError(tarImgPos,objImgPos,h,dis,vOffset))
			{
				return FALSE;
			}
		}

		strInfo.Format(_T("关联映射矩阵:"));
		for (int i=0;i<9;i++)
		{
			strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
			strInfo = strInfo + strTmpInfo;
		}
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

		strInfo.Format(_T("关联矩阵映射误差:%.3f"),dis);
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

        GuanlianOffset.m_dPosX = dis;
        GuanlianOffset.m_dPosY = dis;
        for (int i=0;i<4;i++)
        {
            GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
            GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

            {
                CString strtmp;
                strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
                AlignToolLogRecord(strtmp,m_nPlatformIndex);
            }
        }

        m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);

        m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
		/*SaveCalibTargetProjectData(nCamIndex,nBaseCamIndex,tarImgPos,objImgPos);*/
		svStd vector<sc2Vector> vInvOffset;
		if (sfGetHomographyMaxErrorInverseProject(tarImgPos,objImgPos,h,dis,vInvOffset))
		{
//			SaveCalibTargetProcessData(nCamIndex,nBaseCamIndex,nOutNum,nTotolNum, h,tarOrgUsedImgPos,objOrgUsedImgPos,tarUsedImgPos,objUsedImgPos,vOffset,vInvOffset);
		}
        return TRUE;
    }
    else
    {
        // 如果用读取轴位置，那标定目标位置,则是直接将目标位置与平台关联起来
        if (!m_bTargetObjectCamSeparate)
        {
            return FALSE;
        }

//         if (m_bPlatformTarCamWithDiffObjCam)
//         {
//             if (m_vSpecialPlatformAxisPos.at(nBaseCamIndex) == NULL)
//             {
//                 return FALSE;
//             }
//         }
//         else
        {
            if (m_PlatformAxisPos == NULL)
            {
                return FALSE;
            }
        }

        if (0 == m_iMarkNum)
        {
            return FALSE;
        }	

        if (nRemCamIndex < m_iMarkNum/2)
        {
            return FALSE;
        }

        if (nRemBaseCamIndex < 0 || nRemBaseCamIndex >= m_iMarkNum/2)
        {
            return FALSE;
        }
        if (tarImgPos.size()<2)
        {
            return FALSE;
        }
        if (objImgPos.size()<2)
        {
            return FALSE;
        }

        m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
        //$ 1.0 计算转换矩阵
		if (m_bEnableMultiCalibExtension == TRUE)
		{
			for(int k = 0; k < m_iMarkNum; k++)
			{
				for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
				{
					if (j != nExProductIndex)
					{
						if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
						}
						else
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
						}
					}
				}
			}
		}
        if (m_vCalibratedInfos.at(nCamIndex) != NULL)
        {
            delete m_vCalibratedInfos.at(nCamIndex);
            m_vCalibratedInfos.at(nCamIndex) = NULL;
        }

        if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
        {
            m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
        }
        else
        {
            m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
        }
        for(int k = 0 + m_iMarkNum*nExProductIndex; k < m_iMarkNum/2 + m_iMarkNum*nExProductIndex; k++)
        {
            if (k != nCamIndex)
            {
                if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
                {
                    if (m_vCalibratedInfos.at(k) != NULL)
                    {
                        delete m_vCalibratedInfos.at(k);
                        m_vCalibratedInfos.at(k) = NULL;
                    }

                    m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
                }
                else
                {
                    if (m_vCalibratedInfos.at(k) != NULL)
                    {
                        delete m_vCalibratedInfos.at(k);
                        m_vCalibratedInfos.at(k) = NULL;
                    }

                    m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
                }
            }
        }
        CCoordPos* objectMarkImgPos = NULL;
        CCoordPos* objectMarkPlatformPos = NULL;
        if (objImgPos.size()>0)
        {
            objectMarkImgPos = new CCoordPos[objImgPos.size()];
            objectMarkPlatformPos = new CCoordPos[objImgPos.size()];
        }
        std::vector<sc2Vector> vTargetMark;//图像坐标
        std::vector<sc2Vector> vObjectMark;//平台坐标

        for (int i=0;i<tarImgPos.size();i++)
        {
            vTargetMark.push_back(tarImgPos.at(i));
            objectMarkImgPos[i].m_dPosX = objImgPos.at(i).GetX();
            objectMarkImgPos[i].m_dPosY = objImgPos.at(i).GetY();
        }

		if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			/*strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<vTargetMark.size(); i++)
			{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
			strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/

			std::vector<sc2Vector> tarImgPosDisCor;
			ExecuteDisCorPoint(nCamIndex, vTargetMark, tarImgPosDisCor);
			vTargetMark = tarImgPosDisCor;

			/*strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<vTargetMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/
		}

        for (int i=0;i<objImgPos.size();i++)
        {
            if(!ConvertImagePosToCurPlatformPos(objectMarkPlatformPos[i],  nBaseCamIndex, objectMarkImgPos[i], m_pTargetPlatformAxisPos.at(nRemBaseCamIndex)))
            {
                if (objectMarkImgPos!=NULL)
                {
                    delete[] objectMarkImgPos;
                }
                if(objectMarkPlatformPos!=NULL)
                {
                    delete[] objectMarkPlatformPos;
                }
                return FALSE;
            }
            vObjectMark.push_back(sc2Vector(objectMarkPlatformPos[i].m_dPosX,objectMarkPlatformPos[i].m_dPosY));
        }

        if (objectMarkImgPos!=NULL)
        {
            delete[] objectMarkImgPos;
        }
        if(objectMarkPlatformPos!=NULL)
        {
            delete[] objectMarkPlatformPos;
        }
        CCoordPos imgPos;
        imgPos.m_dPosX = vTargetMark.at(vTargetMark.size()/2).GetX();
        imgPos.m_dPosY = vTargetMark.at(vTargetMark.size()/2).GetY();
        m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(imgPos);

//         if (m_bPlatformTarCamWithDiffObjCam)
//         {
//             m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_vSpecialPlatformAxisPos.at(nBaseCamIndex));
//         }
//         else
        {
            m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
        }

        CCoordPos platPos;
        platPos.m_dPosX = vObjectMark.at(vObjectMark.size()/2).GetX();
        platPos.m_dPosY = vObjectMark.at(vObjectMark.size()/2).GetY();

        m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(platPos);

        std::vector<sc2Vector> vTargetMarkOffSet;
        std::vector<sc2Vector> vObjectMarkOffSet;

        for (int i=0;i<vTargetMark.size();i++)
        {
            vTargetMarkOffSet.push_back(vTargetMark.at(i)-vTargetMark.at(vTargetMark.size()/2));
            vObjectMarkOffSet.push_back(vObjectMark.at(i)-vObjectMark.at(vObjectMark.size()/2));
        }

        // 计算H变换矩阵
        double h[9];
        memset(h, 0.0, sizeof(double)*9);

		CCoordPos GuanlianOffset;
		double dis = 0 ;

		svStd vector<sc2Vector> vOffset;
		//二维码关联时忽略点
		if (m_AlignermentParam.m_bEnableCalibTargetDMCodeOutLine)
		{
			int nOutNum = vTargetMarkOffSet.size()*m_AlignermentParam.m_dCalibTargetDMCodeOutLinePercent;
			strInfo.Format(_T("忽略点数:%d"),nOutNum);
			AlignToolLogRecord(strInfo,m_nPlatformIndex);
			svStd vector<bool> vUsed;

			if (!sfGetHomographyOutLine(vTargetMarkOffSet,vObjectMarkOffSet,h,nOutNum,vUsed,eProject))
			{
				return FALSE;
			}
			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			svStd vector<sc2Vector> tarUsedMarkPos;
			svStd vector<sc2Vector> objUsedMarkPos;
			for (int nUseIndex = 0 ; nUseIndex < vUsed.size(); nUseIndex++ )
			{
				if ( vUsed[nUseIndex] )
				{
					tarUsedMarkPos.push_back(vTargetMarkOffSet[nUseIndex]);
					objUsedMarkPos.push_back(vObjectMarkOffSet[nUseIndex]);
				}	
			}
			if (!sfGetHomographyMaxErrorInverseProject(tarUsedMarkPos,objUsedMarkPos,h,dis,vOffset))
			{
				return FALSE;
			}
		}
		else
		{
			if(!sfGetHomography(vTargetMarkOffSet,vObjectMarkOffSet,h))
			{
				return FALSE;
			}

			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
			//把2个位置的图像坐标保存

			if (!sfGetHomographyMaxErrorInverseProject(vTargetMarkOffSet,vObjectMarkOffSet,h,dis,vOffset))
			{
				return FALSE;
			}
		}

		strInfo.Format(_T("关联映射矩阵:"));
		for (int i=0;i<9;i++)
		{
			strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
			strInfo = strInfo + strTmpInfo;
		}
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

		strInfo.Format(_T("关联矩阵映射误差:%.3f"),dis);
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

        GuanlianOffset.m_dPosX = dis;
        GuanlianOffset.m_dPosY = dis;
        for (int i=0;i<4;i++)
        {
            GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
            GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

            {
                CString strtmp;
                strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
                AlignToolLogRecord(strtmp,m_nPlatformIndex);
            }
        }

        m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);


        //记录变换结果
        sc2Matrix matrix(h[0],h[1],h[3],h[4]);

        m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);


        //$ 2.0 计算基准mark平台坐标



        m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;

        m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
//		SaveCalibTargetProjectData(nCamIndex,nBaseCamIndex,tarImgPos,objImgPos);
        return TRUE;
    }
}

// XY+D平台，二维码靶标进行关联计算
BOOL  vcBaseAlignTool::ExecuteCalibrateSingleCamDmCodeObject(int nCamIndex, int nBaseCamIndex,std::vector<sc2Vector>& tarImgPos,std::vector<sc2Vector>& objImgPos)
{
	CString strInfo;
	CString strTmpInfo;
	strInfo.Format(_T("位置%d:二维码关联计算开始--------------"),nCamIndex);
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	int nRemCamIndex = nCamIndex%m_iMarkNum;
	int nRemBaseCamIndex = nBaseCamIndex%m_iMarkNum;
	int nExProductIndex = nCamIndex/m_iMarkNum;
    if (m_bTarObjCamSepNoAxisCalib == TRUE)
    {
        if (!m_bTargetObjectCamSeparate)
        {
            return FALSE;
        }
        if (0 == m_iMarkNum)
        {
            return FALSE;
        }	

        if (nRemCamIndex >= m_iMarkNum/2)
        {
            return FALSE;
        }

        if (nRemBaseCamIndex > m_iMarkNum || nRemBaseCamIndex < m_iMarkNum/2)
        {
            return FALSE;
        }

        if (tarImgPos.size()<2)
        {
            return FALSE;
        }
        if (objImgPos.size()<2)
        {
            return FALSE;
        }
        m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

        //$ 1.0 计算转换矩阵

        //参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
        // 		double dX1,dX2,dY1,dY2;//平台坐标偏移量
        // 		double dx1,dy1/*,dx2,dy2*/;//图像坐标偏移量
        // 		double A[4][4];	    // 4维矩阵,图像坐标矩阵
        // 		double dA11, dA12, dA21, dA22;//转换矩阵
		if (m_bEnableMultiCalibExtension == TRUE)
		{
			for(int k = 0; k < m_iMarkNum; k++)
			{
				for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
				{
					if (j != nExProductIndex)
					{
						if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
						}
						else
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
						}
					}
				}
			}
		}
		if (m_vCalibratedInfos.at(nCamIndex) != NULL)
		{
			delete m_vCalibratedInfos.at(nCamIndex);
			m_vCalibratedInfos.at(nCamIndex) = NULL;
		}
        if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
        {
            m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
        }
        else
        {
            m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
        }
        for(int k = m_iMarkNum/2+ m_iMarkNum*nExProductIndex; k < m_iMarkNum+ m_iMarkNum*nExProductIndex; k++)
        {
            if (k != nCamIndex)
            {
                if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
                {
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
                    m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
                }
                else
                {
					if (m_vCalibratedInfos.at(k) != NULL)
					{
						delete m_vCalibratedInfos.at(k);
						m_vCalibratedInfos.at(k) = NULL;
					}
                    m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
                }
            }
        }

        //for (int i=0;i<tarImgPos.size();i++)
        //{
        //    CString strtmp;
        //    strtmp.Format("位置:%d-vTargetMark:%d-%f,%f\n",nCamIndex,i,tarImgPos.at(i).GetX(),tarImgPos.at(i).GetY());
        //    AlignToolLogRecord(strtmp,m_nPlatformIndex);
        //}
        //for (int i=0;i<objImgPos.size();i++)
        //{
        //    CString strtmp;
        //    strtmp.Format("位置:%d-vObjectMark:%d-%f,%f\n",nCamIndex,i,objImgPos.at(i).GetX(),objImgPos.at(i).GetY());
        //    AlignToolLogRecord(strtmp,m_nPlatformIndex);
        //}

		if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			/*strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<tarImgPos.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, tarImgPos.at(i).GetX(), tarImgPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/

			std::vector<sc2Vector> tarImgPosDisCor;
			ExecuteDisCorPoint(nCamIndex, tarImgPos, tarImgPosDisCor);
			tarImgPos = tarImgPosDisCor;

			//strOut.Format(_T("畸变校正后图像坐标: "));
			//for (int i=0; i<tarImgPos.size(); i++)
			//{
			//	strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, tarImgPos.at(i).GetX(), tarImgPos.at(i).GetY());
			//	strOut += strTmp;
			//}
			//AlignToolLogRecord(strOut,m_nPlatformIndex);
		}

		if (m_vpCalibrateParam[nRemBaseCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nBaseCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("参考位置:%d, 畸变参数: "), nBaseCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			/*strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<objImgPos.size(); i++)
			{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, objImgPos.at(i).GetX(), objImgPos.at(i).GetY());
			strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/

			std::vector<sc2Vector> objImgPosDisCor;
			ExecuteDisCorPoint(nBaseCamIndex, objImgPos, objImgPosDisCor);
			objImgPos = objImgPosDisCor;

			/*strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<objImgPos.size(); i++)
			{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, objImgPos.at(i).GetX(), objImgPos.at(i).GetY());
			strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/
		}

        // 计算H变换矩阵
        double h[9];
        memset(h, 0.0, sizeof(double)*9);

		CCoordPos GuanlianOffset;
		double dis = 0 ;

		svStd vector<sc2Vector> vOffset;

		//二维码关联时忽略点
		if (m_AlignermentParam.m_bEnableCalibTargetDMCodeOutLine)
		{
			int nOutNum = tarImgPos.size()*m_AlignermentParam.m_dCalibTargetDMCodeOutLinePercent;
			strInfo.Format(_T("忽略点数:%d"),nOutNum);
			AlignToolLogRecord(strInfo,m_nPlatformIndex);
			svStd vector<bool> vUsed;
			if (!sfGetHomographyOutLine(tarImgPos,objImgPos,h,nOutNum,vUsed,eProject))
			{
				return FALSE;
			}
			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
			svStd vector<sc2Vector> tarUsedImgPos;
			svStd vector<sc2Vector> objUsedImgPos;
			for (int nUseIndex = 0 ; nUseIndex < vUsed.size(); nUseIndex++ )
			{
				if ( vUsed[nUseIndex] )
				{
					tarUsedImgPos.push_back(tarImgPos[nUseIndex]);
					objUsedImgPos.push_back(objImgPos[nUseIndex]);
				}	
			}
			if (!sfGetHomographyMaxError(tarUsedImgPos,objUsedImgPos,h,dis,vOffset))
			{
				return FALSE;
			}
		}
		else
		{
			if(!sfGetHomography(tarImgPos,objImgPos,h))
			{
				return FALSE;
			}
			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			if (!sfGetHomographyMaxError(tarImgPos,objImgPos,h,dis,vOffset))
			{
				return FALSE;
			}
		}

		strInfo.Format(_T("关联映射矩阵:"));
		for (int i=0;i<9;i++)
		{
			strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
			strInfo = strInfo + strTmpInfo;
		}
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

		strInfo.Format(_T("关联矩阵映射误差:%.3f"),dis);
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

        GuanlianOffset.m_dPosX = dis;
        GuanlianOffset.m_dPosY = dis;
        for (int i=0;i<4;i++)
        {
            GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
            GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

            {
                CString strtmp;
                strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
                AlignToolLogRecord(strtmp,m_nPlatformIndex);
            }
        }

        m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);

        m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

        return TRUE;
    }
    else
    {
        // 如果用读取轴位置，那标定目标位置,则是直接将目标位置与平台关联起来
        if (!m_bTargetObjectCamSeparate)
        {
            return FALSE;
        }

        if (m_PlatformAxisPos == NULL)
        {
            return FALSE;
        }

        if (0 == m_iMarkNum)
        {
            return FALSE;
        }	

        if (nRemCamIndex >= m_iMarkNum/2)
        {
            return FALSE;
        }

        if (nRemBaseCamIndex > m_iMarkNum || nRemBaseCamIndex < m_iMarkNum/2)
        {
            return FALSE;
        }
        if (tarImgPos.size()<2)
        {
            return FALSE;
        }
        if (objImgPos.size()<2)
        {
            return FALSE;
        }

        m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
        //$ 1.0 计算转换矩阵
		if (m_bEnableMultiCalibExtension == TRUE)
		{
			for(int k = 0; k < m_iMarkNum; k++)
			{
				for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
				{
					if (j != nExProductIndex)
					{
						if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
						}
						else
						{
							if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
							{
								delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
								m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
							}
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
						}
					}
				}
			}
		}
        if (m_vCalibratedInfos.at(nCamIndex) != NULL)
        {
            delete m_vCalibratedInfos.at(nCamIndex);
            m_vCalibratedInfos.at(nCamIndex) = NULL;
        }

        if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
        {
            m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
        }
        else
        {
            m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
        }
        for(int k =m_iMarkNum/2 + m_iMarkNum*nExProductIndex; k < m_iMarkNum + m_iMarkNum*nExProductIndex; k++)
        {
            if (k != nCamIndex)
            {
                if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
                {
                    if (m_vCalibratedInfos.at(k) != NULL)
                    {
                        delete m_vCalibratedInfos.at(k);
                        m_vCalibratedInfos.at(k) = NULL;
                    }

                    m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
                }
                else
                {
                    if (m_vCalibratedInfos.at(k) != NULL)
                    {
                        delete m_vCalibratedInfos.at(k);
                        m_vCalibratedInfos.at(k) = NULL;
                    }

                    m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
                }
            }
        }
        CCoordPos* objectMarkImgPos = NULL;
        CCoordPos* objectMarkPlatformPos = NULL;
        if (objImgPos.size()>0)
        {
            objectMarkImgPos = new CCoordPos[objImgPos.size()];
            objectMarkPlatformPos = new CCoordPos[objImgPos.size()];
        }
        std::vector<sc2Vector> vTargetMark;//图像坐标
        std::vector<sc2Vector> vObjectMark;//平台坐标

        for (int i=0;i<tarImgPos.size();i++)
        {
            vTargetMark.push_back(tarImgPos.at(i));
            objectMarkImgPos[i].m_dPosX = objImgPos.at(i).GetX();
            objectMarkImgPos[i].m_dPosY = objImgPos.at(i).GetY();
        }

		if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			/*strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<vTargetMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/

			std::vector<sc2Vector> tarImgPosDisCor;
			ExecuteDisCorPoint(nCamIndex, vTargetMark, tarImgPosDisCor);
			vTargetMark = tarImgPosDisCor;

			/*strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<vTargetMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vTargetMark.at(i).GetX(), vTargetMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);*/
		}

        for (int i=0;i<objImgPos.size();i++)
        {
            if(!ConvertImagePosToCurPlatformPos(objectMarkPlatformPos[i],  nBaseCamIndex, objectMarkImgPos[i], m_pTargetPlatformAxisPos.at(nRemBaseCamIndex)))
            {
                if (objectMarkImgPos!=NULL)
                {
                    delete[] objectMarkImgPos;
                }
                if(objectMarkPlatformPos!=NULL)
                {
                    delete[] objectMarkPlatformPos;
                }
                return FALSE;
            }
            CString strInfo;
            strInfo.Format("Before objectMarkPlatformPos[%d] m_dPosX:%f m_dPosY:%f",i,objectMarkPlatformPos[i].m_dPosX,objectMarkPlatformPos[i].m_dPosY);
            AlignToolLogRecord(strInfo,m_nPlatformIndex);

            double dDetaX = (((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosX - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX);
            if (((CPlatformXYDInfo*)m_pPlatformParam)->m_nPlatformXCoordType == eDirectNegative)
            {
                dDetaX = -dDetaX;
            }
            objectMarkPlatformPos[i].m_dPosX = objectMarkPlatformPos[i].m_dPosX + dDetaX;

            double dDetaY = (((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosY - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY);
            if (((CPlatformXYDInfo*)m_pPlatformParam)->m_nPlatformYCoordType == eDirectNegative)
            {
                dDetaY = -dDetaY;
            }
            objectMarkPlatformPos[i].m_dPosY = objectMarkPlatformPos[i].m_dPosY + dDetaY;

            strInfo.Format("m_pTargetPlatformAxisPos.at(%d):%f,%f",nCamIndex,((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosX,((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(nRemCamIndex))->m_dPosY);
            AlignToolLogRecord(strInfo,m_nPlatformIndex);
            strInfo.Format("m_PlatformAxisPos:%f,%f",((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX,((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY);
            AlignToolLogRecord(strInfo,m_nPlatformIndex);

            strInfo.Format("After objectMarkPlatformPos[%d] m_dPosX:%f m_dPosY:%f",i,objectMarkPlatformPos[i].m_dPosX,objectMarkPlatformPos[i].m_dPosY);
            AlignToolLogRecord(strInfo,m_nPlatformIndex);

            vObjectMark.push_back(sc2Vector(objectMarkPlatformPos[i].m_dPosX,objectMarkPlatformPos[i].m_dPosY));
        }

        if (objectMarkImgPos!=NULL)
        {
            delete[] objectMarkImgPos;
        }
        if(objectMarkPlatformPos!=NULL)
        {
            delete[] objectMarkPlatformPos;
        }
        CCoordPos imgPos;
        imgPos.m_dPosX = vTargetMark.at(vTargetMark.size()/2).GetX();
        imgPos.m_dPosY = vTargetMark.at(vTargetMark.size()/2).GetY();
        m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(imgPos);

//         if (m_bPlatformTarCamWithDiffObjCam)
//         {
//             m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_vSpecialPlatformAxisPos.at(nBaseCamIndex));
//         }
//         else
        {
            m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
        }

        CCoordPos platPos;
        platPos.m_dPosX = vObjectMark.at(vObjectMark.size()/2).GetX();
        platPos.m_dPosY = vObjectMark.at(vObjectMark.size()/2).GetY();

        m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(platPos);

        std::vector<sc2Vector> vTargetMarkOffSet;
        std::vector<sc2Vector> vObjectMarkOffSet;

        for (int i=0;i<vTargetMark.size();i++)
        {
            vTargetMarkOffSet.push_back(vTargetMark.at(i)-vTargetMark.at(vTargetMark.size()/2));
            vObjectMarkOffSet.push_back(vObjectMark.at(i)-vObjectMark.at(vObjectMark.size()/2));
        }

        // 计算H变换矩阵
        double h[9];
        memset(h, 0.0, sizeof(double)*9);
		CCoordPos GuanlianOffset;
		double dis = 0 ;

		svStd vector<sc2Vector> vOffset;
		//二维码关联时忽略点
		if (m_AlignermentParam.m_bEnableCalibTargetDMCodeOutLine)
		{
			int nOutNum = vTargetMarkOffSet.size()*m_AlignermentParam.m_dCalibTargetDMCodeOutLinePercent;
			strInfo.Format(_T("忽略点数:%d"),nOutNum);
			AlignToolLogRecord(strInfo,m_nPlatformIndex);
			svStd vector<bool> vUsed;

			if (!sfGetHomographyOutLine(vTargetMarkOffSet,vObjectMarkOffSet,h,nOutNum,vUsed,eProject))
			{
				return FALSE;
			}
			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			svStd vector<sc2Vector> tarUsedMarkPos;
			svStd vector<sc2Vector> objUsedMarkPos;
			for (int nUseIndex = 0 ; nUseIndex < vUsed.size(); nUseIndex++ )
			{
				if ( vUsed[nUseIndex] )
				{
					tarUsedMarkPos.push_back(vTargetMarkOffSet[nUseIndex]);
					objUsedMarkPos.push_back(vObjectMarkOffSet[nUseIndex]);
				}	
			}
			if (!sfGetHomographyMaxErrorInverseProject(tarUsedMarkPos,objUsedMarkPos,h,dis,vOffset))
			{
				return FALSE;
			}
		}
		else
		{
			if(!sfGetHomography(vTargetMarkOffSet,vObjectMarkOffSet,h))
			{
				return FALSE;
			}

			//记录变换结果
			m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

			//把2个位置的图像坐标保存

			if (!sfGetHomographyMaxErrorInverseProject(vTargetMarkOffSet,vObjectMarkOffSet,h,dis,vOffset))
			{
				return FALSE;
			}
		}

		strInfo.Format(_T("关联映射矩阵:"));
		for (int i=0;i<9;i++)
		{
			strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
			strInfo = strInfo + strTmpInfo;
		}
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

		strInfo.Format(_T("关联矩阵映射误差:%.3f"),dis);
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

        GuanlianOffset.m_dPosX = dis;
        GuanlianOffset.m_dPosY = dis;
        for (int i=0;i<4;i++)
        {
            GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
            GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

            {
                CString strtmp;
                strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
                AlignToolLogRecord(strtmp,m_nPlatformIndex);
            }
        }

        m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);


        //记录变换结果
        sc2Matrix matrix(h[0],h[1],h[3],h[4]);

        m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);


        //$ 2.0 计算基准mark平台坐标



        m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;

        m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

        return TRUE;
    }
}

// 使用棋盘格靶标关联计算
void vcBaseAlignTool::SetCalibBoardResult(std::vector<CMarkImagePos*> ImageResults,int nCalibPos)
{
	m_vCalibBoardResults[nCalibPos].clear();
	//将每个位置num副图像，共7个不同位置的图像坐标压入m_vCalibPlatformMoveResults

	for (int j=0; j<ImageResults.size(); j++)
	{
		int num = ImageResults.at(j)->m_vPos.size();
		for (int k=0; k<num; k++)
		{
			/*			if (ImageResults.at(j)->m_vbOK.at(k))*/		
			m_vCalibBoardResults[nCalibPos].push_back(ImageResults.at(j)->m_vPos.at(k));
		}
	}
}

void vcBaseAlignTool::SetCalibBoardSize(sc2Vector vBoardSize)
{
	m_vCalibBoardSize = vBoardSize;
}

// 2对4方案中:
//           位置0、位置1为对象，位置2、位置3、位置4、位置5为目标；
//           目标位置2与虚拟平台建立关联映射关系，虚拟平台坐标系与位置2图像坐标系的方向一致、偏移量为0，只是像素当量不一样；
//           目标位置3、位置4、位置5分别通过靶标和位置3，与虚拟平台坐标系建立关联映射关系；
//           对位时虚拟平台坐标系位置与对象平台坐标系位置进行对位。
// 2对4方案中，通过靶标对目标位置2、位置3、位置4、位置5进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateBoardSingleCamEX(int nCamIndex, int nBaseCamIndex)
{
	CString strInfo;
	AlignToolLogRecord(_T("ExecuteCalibrateBoardSingleCamEX start"), m_nPlatformIndex);

	if ( (!m_bTargetObjectCamSeparate) || (!m_bTargetCalibUseBoard) )
	{
		return FALSE;
	}

	// 	if (m_PlatformAxisPos == NULL)
	// 	{
	// 		return FALSE;
	// 	}

	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	int nExProductIndex = nCamIndex / m_iMarkNum;
	int nRemBaseCamIndex = nBaseCamIndex;
	nBaseCamIndex += m_iMarkNum*nExProductIndex;

	if (nRemCamIndex < m_iMarkNum/2)
	{
		return FALSE;
	}

	if (nRemBaseCamIndex < m_iMarkNum/2 || nRemBaseCamIndex >= m_iMarkNum)
	{
		return FALSE;
	}

	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];

	//$ 1.0 计算转换矩阵

	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
	double dX1,dX2,dY1,dY2;//平台坐标偏移量
	double dx1,dy1/*,dx2,dy2*/;//图像坐标偏移量
	double A[4][4];	    // 4维矩阵,图像坐标矩阵
	double dA11, dA12, dA21, dA22;//转换矩阵
	if (m_vCalibratedInfos.at(nCamIndex) != NULL)
	{
		delete m_vCalibratedInfos.at(nCamIndex);
		m_vCalibratedInfos.at(nCamIndex) = NULL;	
	}
	//m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (j != nExProductIndex)
				{
					if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
					{
						if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
						{
							delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
						}
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
					}
					else
					{
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
					}
				}
			}
		}
	}
	if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
	{
		m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
	}
	else
	{
		m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	}
	for(int k = 0+ m_iMarkNum*nExProductIndex; k < m_iMarkNum/2+ m_iMarkNum*nExProductIndex; k++)
	{
		if (k != nCamIndex)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}
	// 	for(int k = GetObjectMarkNum(); k < GetTargetMarkNum(); k++)
	// 	{
	// 		if (k != nCamIndex)
	// 		{
	// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
	// 			{
	// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
	// 			}
	// 			else
	// 			{
	// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	// 			}
	// 		}
	// 	}

	// 目标位置2或3靶标位置

	// 目标位置2或3靶标图像位置

	// 目标位置4或5靶标位置

	// 目标位置4或5靶标图像位置

	// 如果是目标位置2，则直接构造目标位置3与虚拟平台坐标系直接的映射关系

	if (nRemCamIndex == m_iMarkNum/2)
	{
		AlignToolLogRecord(_T("ExecuteCalibrateBoardSingleCamEX start nCamIndex == %d"), nCamIndex);

		int i=0;
		double dMarkImgX[2],dMarkImgY[2];				// 目标位置2图像位置
		double dMarkBoardX[2],dMarkBoardY[2];			// 目标位置2靶标位置


		CCoordPos	cpCalibBoardMarkImgCoordPos[CALIBBOARDMARKPOSNUM]; // 用靶标关联映射时，标定板上的Mark位置图像坐标
		CCoordPos	cpCalibBoardMarkBoardCoordPos[CALIBBOARDMARKPOSNUM]; // 用靶标关联映射时，标定板上的Mark位置物理坐标

		std::vector<sc2Vector> vImgMark;

		// 目标位置2图像位置
		for (i=0; i<2; i++)
		{
			cpCalibBoardMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
			cpCalibBoardMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;

			dMarkImgX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
			dMarkImgY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;

			vImgMark.push_back(cpCalibBoardMarkImgCoordPos[i].GetPos());
		}

		strInfo.Format(_T("目标位置%d图像位置dMarkImgX[0] = %.5f,dMarkImgY[0] = %.5f,dMarkImgX[1] = %.5f,dMarkImgY[1] = %.5f"),
			nCamIndex,dMarkImgX[0],dMarkImgY[0],dMarkImgX[1],dMarkImgY[1]);
		AlignToolLogRecord(strInfo, m_nPlatformIndex);

		if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			strOut.Format(_T("畸变校正前图像坐标: "));
			for (int i=0; i<vImgMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vImgMark.at(i).GetX(), vImgMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			std::vector<sc2Vector> tarImgPosDisCor;
			ExecuteDisCorPoint(nCamIndex, vImgMark, tarImgPosDisCor);
			vImgMark = tarImgPosDisCor;

			for (int i=0; i<2; i++)
			{
				cpCalibBoardMarkImgCoordPos[i].m_dPosX = vImgMark.at(i).GetX();
				cpCalibBoardMarkImgCoordPos[i].m_dPosY = vImgMark.at(i).GetY();

				dMarkImgX[i] = vImgMark.at(i).GetX();
				dMarkImgY[i] = vImgMark.at(i).GetY();

			}

			strOut.Format(_T("畸变校正后图像坐标: "));
			for (int i=0; i<vImgMark.size(); i++)
			{
				strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vImgMark.at(i).GetX(), vImgMark.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);
		}


		// 目标位置2靶标位置
		for (i=0; i<2; i++)
		{
			cpCalibBoardMarkBoardCoordPos[i].m_dPosX = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
			cpCalibBoardMarkBoardCoordPos[i].m_dPosY = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;

			dMarkBoardX[i] = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX * m_vCalibBoardSize.GetX();
			dMarkBoardY[i] = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY * m_vCalibBoardSize.GetY();
		}
		strInfo.Format(_T("目标位置%d靶标位置dMarkBoardX[0] = %.5f,dMarkBoardY[0] = %.5f,dMarkBoardX[1] = %.5f,dMarkBoardY[1] = %.5f"),
			nCamIndex,dMarkBoardX[0],dMarkBoardY[0],dMarkBoardX[1],dMarkBoardY[1]);
		AlignToolLogRecord(strInfo, m_nPlatformIndex);


		// 设置、获取用靶标关联映射时，标定板上的Mark位置图像坐标、物理坐标
		m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardMarkImgCoordPos(cpCalibBoardMarkImgCoordPos);
		m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardMarkBoardCoordPos(cpCalibBoardMarkBoardCoordPos);
		m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardSize(m_vCalibBoardSize);

		// 构造二维矩阵		
		double dImageDistance = sqrt((dMarkImgX[1] - dMarkImgX[0])*(dMarkImgX[1] - dMarkImgX[0])+(dMarkImgY[1] - dMarkImgY[0])*(dMarkImgY[1] - dMarkImgY[0]));
		double dBoardDistance = sqrt((dMarkBoardX[1] - dMarkBoardX[0])*(dMarkBoardX[1] - dMarkBoardX[0])+(dMarkBoardY[1] - dMarkBoardY[0])*(dMarkBoardY[1] - dMarkBoardY[0]));
		if (dImageDistance < DBL_EPSILON)
		{
			return FALSE;
		}
		if (dBoardDistance < DBL_EPSILON)
		{
			return FALSE;
		}
		double dRatio = dBoardDistance/dImageDistance;
		dA11 = dRatio;
		dA12 = 0.0;
		dA21 = 0.0;
		dA22 = dRatio;

		strInfo.Format(_T("目标位置%d像素当量%.5f"),nCamIndex,dRatio);
		AlignToolLogRecord(strInfo, m_nPlatformIndex);
		//记录变换结果
		sc2Matrix matrix(dA11,dA12,dA21,dA22);
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);
		strInfo.Format(_T("目标位置%d矩阵dA11 = %.5f,dA12 = %.5f,dA21 = %.5f,dA22 = %.5f"),nCamIndex,dA11,dA12,dA21,dA22);
		AlignToolLogRecord(strInfo, m_nPlatformIndex);

		double h[9];
		memset(h, 0.0, sizeof(double)*9);
		h[0]=dA11;h[1]=dA12;h[3]=dA21;h[4]=dA22;h[8]=1;
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

		//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
		CCoordPos MarkImg;
		MarkImg.SetPos(cpCalibBoardMarkImgCoordPos[0].GetPos());
		m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(MarkImg);
		/*m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(nRemCamIndex));*/
		CPlatformXYDAxisPos platformAxisPos;
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(&platformAxisPos);

		//$ 2.0 计算基准mark平台坐标
		CCoordPos objectMarkPlatformPos;
		objectMarkPlatformPos.m_dPosX = 0;
		objectMarkPlatformPos.m_dPosY = 0;
		m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(objectMarkPlatformPos);


		//$3.0、计算图像坐标与平台坐标之间的夹角
		double tanValue1,tanValue2;
		double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
		double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
		double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
		double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);

		tanValue1 = dA21/dA11;
		tanValue2 = (-1*dA12)/dA22;
		tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
		tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	

		m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

		m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

		{
			m_vAlignerCalibInfos[nCamIndex]->SetPlatformTransferMatrix(matrix);
			m_vAlignerCalibInfos[nCamIndex]->SetPlatformTransferH(h);
			m_vAlignerCalibInfos[nCamIndex]->SetMarkImgCoordPos(MarkImg);
			/*m_vAlignerCalibInfos[nCamIndex]->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(nRemCamIndex));*/
			m_vAlignerCalibInfos[nCamIndex]->SetMarkPlatformCoordPos(objectMarkPlatformPos);
			m_vAlignerCalibInfos[nCamIndex]->SetPlatformAxisPos(&platformAxisPos);
			m_vAlignerCalibInfos[nCamIndex]->SetValid(TRUE);
			m_vAlignerCalibInfos[nCamIndex]->m_dImageToPlatformAnlge = m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge;
		}
		AlignToolLogRecord(_T("ExecuteCalibrateBoardSingleCamEX end nCamIndex == %d"), nCamIndex);

		return TRUE;

	}


	// 如果是目标位置3、4、5，则按照以下步骤进行：

	// 第一步、建立目标位置3、4、5靶标位置，与目标位置3、4、5图像位置之间的映射关系

	// 第二步、建立目标位置2图像位置，与目标位置2靶标位置之间的映射关系

	// 第三步、建立目标位置3、4、5靶标位置，与目标位置2靶标位置之间的映射关系，即将位置3、4、5归一化到位置2的靶标位置

	// 第四步、建立目标位置3、4、5靶标位置与虚拟平台坐标系之间的映射关系


	int i=0;
	double dMarkImgX[2],dMarkImgY[2];				// 目标位置3、4或5图像位置
	double dMarkBoardX[2],dMarkBoardY[2];			// 目标位置3、4或5靶标位置

	double dBaseMarkImgX[2],dBaseMarkImgY[2];		// 目标位置2图像位置
	double dBaseMarkBoardX[2],dBaseMarkBoardY[2];	// 目标位置2靶标位置


	CCoordPos	cpCalibBoardMarkImgCoordPos[CALIBBOARDMARKPOSNUM]; // 用靶标关联映射时，标定板上的Mark位置图像坐标
	CCoordPos	cpCalibBoardMarkBoardCoordPos[CALIBBOARDMARKPOSNUM]; // 用靶标关联映射时，标定板上的Mark位置物理坐标

	CCoordPos	cpCalibBoardBaseMarkImgCoordPos[CALIBBOARDMARKPOSNUM]; // 用靶标关联映射时，标定板上的Mark位置图像坐标
	CCoordPos	cpCalibBoardBaseMarkBoardCoordPos[CALIBBOARDMARKPOSNUM]; // 用靶标关联映射时，标定板上的Mark位置物理坐标


	double dImageDistance = 0.0;
	double dBoardDistance = 0.0;

	std::vector<sc2Vector> vImgMark;
	// 目标位置3、4或5图像位置
	for (i=0; i<2; i++)
	{
		cpCalibBoardMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
		cpCalibBoardMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;

		dMarkImgX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
		dMarkImgY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;
		vImgMark.push_back(cpCalibBoardMarkImgCoordPos[i].GetPos());
	}
	strInfo.Format(_T("目标位置%d图像位置dMarkImgX[0] = %.5f,dMarkImgY[0] = %.5f,dMarkImgX[1] = %.5f,dMarkImgY[1] = %.5f"),
		nCamIndex,dMarkImgX[0],dMarkImgY[0],dMarkImgX[1],dMarkImgY[1]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
	{
		CString strOut, strTmp;
		double p[15];
		memset(p, 0.0, sizeof(double)*15);
		scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
		result.GetNonlinearProjectResult(p);
		double dRms = result.GetRMS();
		strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
		for (int i=0;i<15; i++)
		{
			strTmp.Format(_T("P%d:%.6f "), i, p[i]);
			strOut += strTmp;
		}
		strTmp.Format(_T("P15:%.6f "),dRms);
		strOut += strTmp;
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		strOut.Format(_T("畸变校正前图像坐标: "));
		for (int i=0; i<vImgMark.size(); i++)
		{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vImgMark.at(i).GetX(), vImgMark.at(i).GetY());
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		std::vector<sc2Vector> tarImgPosDisCor;
		ExecuteDisCorPoint(nCamIndex, vImgMark, tarImgPosDisCor);
		vImgMark = tarImgPosDisCor;

		for (int i=0; i<2; i++)
		{
			cpCalibBoardMarkImgCoordPos[i].m_dPosX = vImgMark.at(i).GetX();
			cpCalibBoardMarkImgCoordPos[i].m_dPosY = vImgMark.at(i).GetY();

			dMarkImgX[i] = vImgMark.at(i).GetX();
			dMarkImgY[i] = vImgMark.at(i).GetY();

		}

		strOut.Format(_T("畸变校正后图像坐标: "));
		for (int i=0; i<vImgMark.size(); i++)
		{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vImgMark.at(i).GetX(), vImgMark.at(i).GetY());
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);
	}

	dImageDistance = sqrt((dMarkImgX[1] - dMarkImgX[0])*(dMarkImgX[1] - dMarkImgX[0])+(dMarkImgY[1] - dMarkImgY[0])*(dMarkImgY[1] - dMarkImgY[0]));
	if (dImageDistance < DBL_EPSILON)
	{
		return FALSE;
	}

	// 目标位置3、4或5靶标位置
	for (i=0; i<2; i++)
	{
		cpCalibBoardMarkBoardCoordPos[i].m_dPosX = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX;
		cpCalibBoardMarkBoardCoordPos[i].m_dPosY = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY;

		dMarkBoardX[i] = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosX * m_vCalibBoardSize.GetX();
		dMarkBoardY[i] = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemCamIndex).m_dPosY * m_vCalibBoardSize.GetY();
	}
	strInfo.Format(_T("目标位置%d靶标位置dMarkBoardX[0] = %.5f,dMarkBoardY[0] = %.5f,dMarkBoardX[1] = %.5f,dMarkBoardY[1] = %.5f"),
		nCamIndex,dMarkBoardX[0],dMarkBoardY[0],dMarkBoardX[1],dMarkBoardY[1]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);
	dBoardDistance = sqrt((dMarkBoardX[1] - dMarkBoardX[0])*(dMarkBoardX[1] - dMarkBoardX[0])+(dMarkBoardY[1] - dMarkBoardY[0])*(dMarkBoardY[1] - dMarkBoardY[0]));
	if (dBoardDistance < DBL_EPSILON)
	{
		return FALSE;
	}

	std::vector<sc2Vector> vBaseImgMark;
	// 目标位置2图像位置
	for (i=0; i<2; i++)
	{
		cpCalibBoardBaseMarkImgCoordPos[i].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX;
		cpCalibBoardBaseMarkImgCoordPos[i].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY;

		dBaseMarkImgX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX;
		dBaseMarkImgY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY;
		vBaseImgMark.push_back(cpCalibBoardBaseMarkImgCoordPos[i].GetPos());
	}
	strInfo.Format(_T("基准目标位置%d图像位置dBaseMarkImgX[0] = %.5f,dBaseMarkImgY[0] = %.5f,dBaseMarkImgX[1] = %.5f,dBaseMarkImgY[1] = %.5f"),
		nBaseCamIndex,dBaseMarkImgX[0],dBaseMarkImgY[0],dBaseMarkImgX[1],dBaseMarkImgY[1]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	if (m_vpCalibrateParam[nRemBaseCamIndex]->m_nEnableDisCor)
	{
		CString strOut, strTmp;
		double p[15];
		memset(p, 0.0, sizeof(double)*15);
		scCalibrateResult result = m_vAlignerCalibInfos.at(nBaseCamIndex)->m_result;
		result.GetNonlinearProjectResult(p);
		double dRms = result.GetRMS();
		strOut.Format(_T("关联位置:%d, 畸变参数: "), nBaseCamIndex);
		for (int i=0;i<15; i++)
		{
			strTmp.Format(_T("P%d:%.6f "), i, p[i]);
			strOut += strTmp;
		}
		strTmp.Format(_T("P15:%.6f "),dRms);
		strOut += strTmp;
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		strOut.Format(_T("畸变校正前图像坐标: "));
		for (int i=0; i<vBaseImgMark.size(); i++)
		{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vBaseImgMark.at(i).GetX(), vBaseImgMark.at(i).GetY());
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		std::vector<sc2Vector> tarImgPosDisCor;
		ExecuteDisCorPoint(nCamIndex, vBaseImgMark, tarImgPosDisCor);
		vBaseImgMark = tarImgPosDisCor;

		for (int i=0; i<2; i++)
		{
			cpCalibBoardBaseMarkImgCoordPos[i].m_dPosX = vBaseImgMark.at(i).GetX();
			cpCalibBoardBaseMarkImgCoordPos[i].m_dPosY = vBaseImgMark.at(i).GetY();

			dBaseMarkImgX[i] = vBaseImgMark.at(i).GetX();
			dBaseMarkImgY[i] = vBaseImgMark.at(i).GetY();

		}

		strOut.Format(_T("畸变校正后图像坐标: "));
		for (int i=0; i<vBaseImgMark.size(); i++)
		{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vBaseImgMark.at(i).GetX(), vBaseImgMark.at(i).GetY());
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);
	}
	dImageDistance = sqrt((dBaseMarkImgX[1] - dBaseMarkImgX[0])*(dBaseMarkImgX[1] - dBaseMarkImgX[0])+(dBaseMarkImgY[1] - dBaseMarkImgY[0])*(dBaseMarkImgY[1] - dBaseMarkImgY[0]));
	if (dImageDistance < DBL_EPSILON)
	{
		return FALSE;
	}

	// 目标位置2靶标位置
	for (i=0; i<2; i++)
	{
		cpCalibBoardBaseMarkBoardCoordPos[i].m_dPosX = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX;
		cpCalibBoardBaseMarkBoardCoordPos[i].m_dPosY = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY;

		dBaseMarkBoardX[i] = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosX * m_vCalibBoardSize.GetX();
		dBaseMarkBoardY[i] = m_vCalibBoardResults[nRemCamIndex].at(m_iMarkNum*i+nRemBaseCamIndex).m_dPosY * m_vCalibBoardSize.GetY();
	}
	strInfo.Format(_T("基准目标位置%d靶标位置dBaseMarkBoardX[0] = %.5f,dBaseMarkBoardY[0] = %.5f,dBaseMarkBoardX[1] = %.5f,dBaseMarkBoardY[1] = %.5f"),
		nBaseCamIndex,dBaseMarkBoardX[0],dBaseMarkBoardY[0],dBaseMarkBoardX[1],dBaseMarkBoardY[1]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);
	dBoardDistance = sqrt((dBaseMarkBoardX[1] - dBaseMarkBoardX[0])*(dBaseMarkBoardX[1] - dBaseMarkBoardX[0])+(dBaseMarkBoardY[1] - dBaseMarkBoardY[0])*(dBaseMarkBoardY[1] - dBaseMarkBoardY[0]));
	if (dBoardDistance < DBL_EPSILON)
	{
		return FALSE;
	}


	// 设置、获取用靶标关联映射时，标定板上的Mark位置图像坐标、物理坐标
	m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardMarkImgCoordPos(cpCalibBoardMarkImgCoordPos);
	m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardMarkBoardCoordPos(cpCalibBoardMarkBoardCoordPos);


	// 计算H变换矩阵:目标2靶标位置――》目标2图像位置
	double h1[9];
	memset(h1, 0.0, sizeof(double)*9);

	std::vector<sc2Vector> vBaseMarkImgPos;
	std::vector<sc2Vector> vBaseMarkBoardPos;

	vBaseMarkImgPos.push_back(sc2Vector(dBaseMarkImgX[0], dBaseMarkImgY[0]));
	vBaseMarkImgPos.push_back(sc2Vector(dBaseMarkImgX[1], dBaseMarkImgY[1]));

	vBaseMarkBoardPos.push_back(sc2Vector(dBaseMarkBoardX[0], dBaseMarkBoardY[0]));
	vBaseMarkBoardPos.push_back(sc2Vector(dBaseMarkBoardX[1], dBaseMarkBoardY[1]));

	if(!sfGetHomography(vBaseMarkBoardPos,vBaseMarkImgPos,h1))
	{
		return FALSE;
	}

	// 计算H变换矩阵:目标3、4或5图像位置――》目标3、4或5靶标位置
	double h2[9];
	memset(h2, 0.0, sizeof(double)*9);

	std::vector<sc2Vector> vMarkImgPos;
	std::vector<sc2Vector> vMarkBoardPos;

	vMarkImgPos.push_back(sc2Vector(dMarkImgX[0], dMarkImgY[0]));
	vMarkImgPos.push_back(sc2Vector(dMarkImgX[1], dMarkImgY[1]));

	vMarkBoardPos.push_back(sc2Vector(dMarkBoardX[0], dMarkBoardY[0]));
	vMarkBoardPos.push_back(sc2Vector(dMarkBoardX[1], dMarkBoardY[1]));

	if(!sfGetHomography(vMarkImgPos, vMarkBoardPos,h2))
	{
		return FALSE;
	}

	// 将目标3、4或5靶标位置转换为目标2上的图像位置
	//
	std::vector<sc2Vector> vMarkInBaseCamImgPos;
	vMarkInBaseCamImgPos.resize(2);
	vMarkInBaseCamImgPos[0] = sfHomographyProject(vMarkBoardPos[0], h1);
	vMarkInBaseCamImgPos[1] = sfHomographyProject(vMarkBoardPos[1], h1);

	std::vector<CCoordPos> vCalibPlatformMoveResults;
	vCalibPlatformMoveResults.resize(2);
	vCalibPlatformMoveResults[0].m_dPosX = vMarkInBaseCamImgPos[0].GetX();
	vCalibPlatformMoveResults[0].m_dPosY = vMarkInBaseCamImgPos[0].GetY();
	vCalibPlatformMoveResults[1].m_dPosX = vMarkInBaseCamImgPos[1].GetX();
	vCalibPlatformMoveResults[1].m_dPosY = vMarkInBaseCamImgPos[1].GetY();


	//获取该相机对应的图像坐标
	double MarkdX[2],MarkdY[2];

	for (i=0; i<2; i++)
	{
		MarkdX[i] = dMarkImgX[i];
		MarkdY[i] = dMarkImgY[i];
	}

	CCoordPos objectMarkPlatformPos[2];		// 虚拟平台坐标系下的平台坐标
	for (i=0; i<2; i++)
	{			
		ConvertImagePosToCurPlatformPosBoard(objectMarkPlatformPos[i],  nBaseCamIndex, vCalibPlatformMoveResults[i], 
			m_vCalibratedInfos.at(nBaseCamIndex)->GetPlatformAxisPos(),TRUE);
	}

	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
	CCoordPos MarkImg;
	MarkImg.SetPos(cpCalibBoardMarkImgCoordPos[0].GetPos());
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(MarkImg);
	/*m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults[nRemCamIndex].at(nRemCamIndex));*/
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_vCalibratedInfos.at(nBaseCamIndex)->GetPlatformAxisPos());
	m_vCalibratedInfos.at(nCamIndex)->SetCalibBoardSize(m_vCalibBoardSize);


	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));

	// 平台坐标系变换矩阵计算之相机由点1到点2、由点1到点3：平台坐标偏移量，图像坐标偏移量
	// 	dX1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	// 	dY1 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
	// 	dX2 = 2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
	// 	dY2 = -2*m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;

	dX1 = objectMarkPlatformPos[1].m_dPosX - objectMarkPlatformPos[0].m_dPosX;
	dY1 = objectMarkPlatformPos[1].m_dPosY - objectMarkPlatformPos[0].m_dPosY;
	dX2 = dX1;
	dY2 = dY1;
	// 	dX2 = objectMarkPlatformPos[2].m_dPosX - objectMarkPlatformPos[0].m_dPosX;
	// 	dY2 = objectMarkPlatformPos[2].m_dPosY - objectMarkPlatformPos[0].m_dPosY;

	dx1 = MarkdX[1]-MarkdX[0];
	dy1 = MarkdY[1]-MarkdY[0];
	// 	dx2 = MarkdX[2]-MarkdX[0];
	// 	dy2 = MarkdY[2]-MarkdY[0];


	A[0][0] = dx1;
	A[0][1] = dy1;
	A[0][2] = 0;
	A[0][3] = 0;

	A[1][0] = dy1;
	A[1][1] = 0 - dx1;
	A[1][2] = 0;
	A[1][3] = 0;

	A[2][0] = 0;
	A[2][1] = 0;
	A[2][2] = 0 - dy1;
	A[2][3] = dx1;

	A[3][0] = 0;
	A[3][1] = 0;
	A[3][2] = dx1;
	A[3][3] = dy1;

	// 	A[1][0] = 0;
	// 	A[1][1] = 0;
	// 	A[1][2] = dx1;
	// 	A[1][3] = dy1;
	// 	
	// 	A[2][0] = dx2;
	// 	A[2][1] = dy2;
	// 	A[2][2] = 0;
	// 	A[2][3] = 0;
	// 	
	// 	A[3][0] = 0;
	// 	A[3][1] = 0;
	// 	A[3][2] = dx2;
	// 	A[3][3] = dy2;

	if (0 == MatrixInvert(A, 4))
	{
		return FALSE;
	}

	dA11 = A[0][0]*dX1 + A[0][1]*dY1 + A[0][2]*dX2 + A[0][3]*dY2;
	dA12 = A[1][0]*dX1 + A[1][1]*dY1 + A[1][2]*dX2 + A[1][3]*dY2;
	dA21 = A[2][0]*dX1 + A[2][1]*dY1 + A[2][2]*dX2 + A[2][3]*dY2;
	dA22 = A[3][0]*dX1 + A[3][1]*dY1 + A[3][2]*dX2 + A[3][3]*dY2;

	//记录变换结果
	sc2Matrix matrix(dA11,dA12,dA21,dA22);
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);
	strInfo.Format(_T("目标位置%d矩阵dA11 = %.5f,dA12 = %.5f,dA21 = %.5f,dA22 = %.5f"),nCamIndex,dA11,dA12,dA21,dA22);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	double h[9];
	memset(h, 0.0, sizeof(double)*9);
	h[0]=dA11;h[1]=dA12;h[3]=dA21;h[4]=dA22;h[8]=1;
	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

	//$ 2.0 计算基准mark平台坐标
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(objectMarkPlatformPos[0]);



	//$3.0、计算图像坐标与平台坐标之间的夹角
	double tanValue1,tanValue2;
	double dA1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dA2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dA3 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dA4 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	tanValue1 = dA21/dA11;
	tanValue2 = (-1*dA12)/dA22;
	tanValue1 = (arctan(tanValue1).ToDouble())*180.0/skPI;
	tanValue2 = (arctan(tanValue2).ToDouble())*180.0/skPI;	

	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = (tanValue1 + tanValue2)/2.0;

	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

	AlignToolLogRecord(_T("ExecuteCalibrateBoardSingleCamEX end"), m_nPlatformIndex);

	return TRUE;
}

// 二维码靶标替换棋盘格靶标
BOOL vcBaseAlignTool::ExecuteCalibrateDmCodeBoard(int nCalibPos,std::vector<sc2Vector> &vImagePos,std::vector<sc2Vector> &vBoardPos,int nMarkType)
{
	if (m_iMarkNum == 0)
	{
		return FALSE;
	}

	if (ePlatformCalib9Point == m_PlatformCalibType)
	{
		if (FALSE == ExecuteCalibrateDmCodeBoardSingleCamEX(nCalibPos, vImagePos,vBoardPos))
			return FALSE;
	}
	else
	{
		if (FALSE == ExecuteCalibrateDmCodeBoardSingleCamEX(nCalibPos, vImagePos,vBoardPos))
			return FALSE;
	}

	return TRUE;
}

BOOL vcBaseAlignTool::ExecuteCalibrateDmCodeBoardSingleCamEX(int nCamIndex,std::vector<sc2Vector> &vImagePos,std::vector<sc2Vector> &vBoardPos)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}
	int nRemCamIndex = nCamIndex % m_iMarkNum;
	int nExProductIndex = nCamIndex/m_iMarkNum;
	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];


	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (j != nExProductIndex)
				{
					if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
					{
						if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
						{
							delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
							m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
						}
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
					}
					else
					{
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
					}
				}
			}
		}
	}

	if (m_vCalibratedInfos.at(nCamIndex) != NULL)
	{
		delete m_vCalibratedInfos.at(nCamIndex);			
		m_vCalibratedInfos.at(nCamIndex) = NULL;
	}

	if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
	{
		m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
	}
	else
	{
		m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
	}

	for(int k = 0+ m_iMarkNum*nExProductIndex; k < m_iMarkNum/2+ m_iMarkNum*nExProductIndex; k++)
	{
		if (k != nCamIndex)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	for (int i=0;i<vImagePos.size();i++)
	{
		CString strtmp;
		strtmp.Format("位置:%d-vImagePos:%d-%f,%f\n",nCamIndex,i,vImagePos.at(i).GetX(),vImagePos.at(i).GetY());
		AlignToolLogRecord(strtmp,m_nPlatformIndex);
	}

	for (int i=0;i<vBoardPos.size();i++)
	{
		CString strtmp;
		strtmp.Format("位置:%d-vBoardPos:%d-%f,%f\n",nCamIndex,i,vBoardPos.at(i).GetX(),vBoardPos.at(i).GetY());
		AlignToolLogRecord(strtmp,m_nPlatformIndex);
	}

	if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
	{
		CString strOut, strTmp;
		double p[15];
		memset(p, 0.0, sizeof(double)*15);
		scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
		result.GetNonlinearProjectResult(p);
		double dRms = result.GetRMS();
		strOut.Format(_T("关联位置:%d, 畸变参数: "), nCamIndex);
		for (int i=0;i<15; i++)
		{
			strTmp.Format(_T("P%d:%.6f "), i, p[i]);
			strOut += strTmp;
		}
		strTmp.Format(_T("P15:%.6f "),dRms);
		strOut += strTmp;
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		strOut.Format(_T("畸变校正前图像坐标: "));
		for (int i=0; i<vImagePos.size(); i++)
		{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vImagePos.at(i).GetX(), vImagePos.at(i).GetY());
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		std::vector<sc2Vector> tarImgPosDisCor;
		ExecuteDisCorPoint(nCamIndex, vImagePos, tarImgPosDisCor);
		vImagePos = tarImgPosDisCor;

		strOut.Format(_T("畸变校正后图像坐标: "));
		for (int i=0; i<vImagePos.size(); i++)
		{
			strTmp.Format(_T("Pos%d(%.6f, %.6f) "), i, vImagePos.at(i).GetX(), vImagePos.at(i).GetY());
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);
	}

	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	CCoordPos GuanlianOffset;
	double dis = 0 ;

	svStd vector<sc2Vector> vOffset;

	if (m_AlignermentParam.m_bEnableCalibTargetDMCodeOutLine)
	{
		int nOutNum = vImagePos.size()*m_AlignermentParam.m_dCalibTargetDMCodeOutLinePercent;
		svStd vector<bool> vUsed;
		if (!sfGetHomographyOutLine(vImagePos,vBoardPos,h,nOutNum,vUsed,eProject))
		{
			return FALSE;
		}
		//记录变换结果
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);

		svStd vector<sc2Vector> tarUsedImgPos;
		svStd vector<sc2Vector> objUsedBoardPos;
		for (int nUseIndex = 0 ; nUseIndex < vUsed.size(); nUseIndex++ )
		{
			if ( vUsed[nUseIndex] )
			{
				tarUsedImgPos.push_back(vImagePos[nUseIndex]);
				objUsedBoardPos.push_back(vBoardPos[nUseIndex]);
			}	
		}
		if (!sfGetHomographyMaxError(tarUsedImgPos,objUsedBoardPos,h,dis,vOffset))
		{
			return FALSE;
		}

	}
	else
	{
		if(!sfGetHomography(vImagePos,vBoardPos,h))
		{
			return FALSE;
		}
		//记录变换结果
		m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);



		if (!sfGetHomographyMaxError(vImagePos,vBoardPos,h,dis,vOffset))
		{
			return FALSE;
		}
	}

	GuanlianOffset.m_dPosX = dis;
	GuanlianOffset.m_dPosY = dis;
	for (int i=0;i<4;i++)
	{
		GuanlianOffset.m_vdAuxiliaryPosX[i] = vOffset.at(i).GetX();
		GuanlianOffset.m_vdAuxiliaryPosY[i] = vOffset.at(i).GetY();

		{
			CString strtmp;
			strtmp.Format("位置:%d-H[%f,%f,%f,%f,%f,%f,%f,%f,%f],dis:%f,[%f,%f]\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8],dis,vOffset.at(i).GetX(),vOffset.at(i).GetY());
			AlignToolLogRecord(strtmp,m_nPlatformIndex);
		}
	}

	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffset(GuanlianOffset);
	//记录变换结果
	sc2Matrix matrix(h[0],h[1],h[3],h[4]);

	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferMatrix(matrix);
	m_vCalibratedInfos.at(nCamIndex)->SetMarkImgCoordPos(CCoordPos());
	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
//	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);

	return TRUE;

}



//标定时相机各轴的初始位置(单相机)
void vcBaseAlignTool::SetCalibCamPlatformPos(int nIndex, CPlatformAxisPos* vPlatformAxisPos)
{
	int nRemIndex = nIndex%m_iMarkNum;
	if (nRemIndex<0 || nRemIndex > m_iMarkNum)
		return;

	//首先将相机初始位置清空
	if (m_vCamPlatformInitAxisPos.at(nRemIndex) != NULL)
	{
		delete m_vCamPlatformInitAxisPos.at(nRemIndex);
		m_vCamPlatformInitAxisPos.at(nRemIndex) = NULL;
	}
	//有多少mark点，就要记录多少相机轴位置。单相机一般是两个位置

	if (vPlatformAxisPos != NULL)
	{
		m_vCamPlatformInitAxisPos.at(nRemIndex) = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)vPlatformAxisPos));
	}

	if (m_vCalibratedInfos.at(nIndex) != NULL)
	{
		delete m_vCalibratedInfos.at(nIndex);
		m_vCalibratedInfos.at(nIndex) = NULL;
	}

	if (nIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nIndex] != NULL)
	{
		m_vCalibratedInfos.at(nIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nIndex]);
	}
	else
	{
		m_vCalibratedInfos.at(nIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());

	}
	
	m_vCalibratedInfos.at(nIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nRemIndex));

}

CPlatformAxisPos* vcBaseAlignTool::GetCalibCamPlatformPos(int nIndex)
{
	if (nIndex>=m_iMarkNum)
		return NULL;
	return m_vCamPlatformInitAxisPos.at(nIndex);
}

//标定时相机轴所在平台的初始位置（单相机）
void vcBaseAlignTool::SetCalibCamAxisPlatformAxisPos(int nIndex, CPlatformAxisPos* vPlatformAxisPos)
{
	int nRemIndex = nIndex%m_iMarkNum;
	if (nRemIndex<0 || nRemIndex > m_iMarkNum)
		return;

	//首先将相机初始位置清空
	if (m_vCamAxisPlatformInitAxisPos.at(nRemIndex) != NULL)
	{
		delete m_vCamAxisPlatformInitAxisPos.at(nRemIndex);
		m_vCamAxisPlatformInitAxisPos.at(nRemIndex) = NULL;
	}
	//有多少mark点，就要记录多少相机轴所在平台位置。单相机一般是两个位置

	if (vPlatformAxisPos != NULL)
	{
		m_vCamAxisPlatformInitAxisPos.at(nRemIndex) = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)vPlatformAxisPos));
	}

	//if (m_vCalibratedInfos.at(nIndex) != NULL)
	//{
	//	delete m_vCalibratedInfos.at(nIndex);
	//	m_vCalibratedInfos.at(nIndex) = NULL;
	//}
	if(m_vCalibratedInfos.at(nIndex) == NULL)
	{
		if (nIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nIndex] != NULL)
		{
			m_vCalibratedInfos.at(nIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nIndex]);	
		}
		else
		{
			m_vCalibratedInfos.at(nIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());

		}
	}
	m_vCalibratedInfos.at(nIndex)->SetCamAxisPlatformAxisPos(m_vCamAxisPlatformInitAxisPos.at(nRemIndex));
}

CPlatformAxisPos* vcBaseAlignTool::GetCalibCamAxisPlatformAxisPos(int nIndex)
{
	if (nIndex>=m_iMarkNum)
		return NULL;
	return m_vCamAxisPlatformInitAxisPos.at(nIndex);
}

//标定时相机各轴的初始位置(多相机)
void vcBaseAlignTool::SetCalibCamPlatformPos( std::vector<CPlatformAxisPos*> vPlatformAxisPos)
{
	//首先将相机初始位置向量清空
	for (int i=0; i<m_vCamPlatformInitAxisPos.size(); i++)
	{
		if (m_vCamPlatformInitAxisPos.at(i) != NULL)
		{
			delete m_vCamPlatformInitAxisPos.at(i);
			m_vCamPlatformInitAxisPos.at(i) = NULL;
		}
	}

	for (int j=0; j<vPlatformAxisPos.size(); j++)
	{
		if (vPlatformAxisPos.at(j) != NULL)
		{
			m_vCamPlatformInitAxisPos.at(j) = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)(vPlatformAxisPos.at(j)) ));
		}
	}
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibCamPlatformPos()
{
	return m_vCamPlatformInitAxisPos;
}

// 获取相机平移标定时各轴的移动位置
std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibCameraMovePos(int nIndex)
{
	std::vector<CPlatformAxisPos*> vpPos;
	if (nIndex<0 || nIndex>=m_iMarkNum)
		return vpPos;

	m_CalibrateParam = m_vpCalibrateParam[nIndex];

	if ( eCamPlatformSepXY == m_pCamPlatformInfo->GetCamPlatformType()
		||eCamPlatformSepX == m_pCamPlatformInfo->GetCamPlatformType())
	{
		for (int j=0; j<m_vCamPlatformAxisPos.at(nIndex).size(); j++)
		{	
			if (m_vCamPlatformAxisPos.at(nIndex).at(j) != NULL)
			{
				delete m_vCamPlatformAxisPos.at(nIndex).at(j);
				m_vCamPlatformAxisPos.at(nIndex).at(j) = NULL;
			}
		}
		m_vCamPlatformAxisPos.at(nIndex).clear();

		double dX0 = (*(CPlatformXYAxisPos*)m_vCamPlatformInitAxisPos.at(nIndex)).m_dPosX;
		double dY0 = (*(CPlatformXYAxisPos*)m_vCamPlatformInitAxisPos.at(nIndex)).m_dPosY;

		if (m_bCalibSendRelativePos)//标定发送相对位置
		{
			dX0 = 0.0;
			dY0 = 0.0;
		}
		//将平台移动量转化为真实的平台轴移动量
		double dOffsetX,dOffsetY;
		dOffsetX = m_CalibrateParam->m_dCameraCalibMovement.m_dPosX;
		dOffsetY = m_CalibrateParam->m_dCameraCalibMovement.m_dPosY;
		if (eDirectNegative == m_pCamPlatformInfo->GetCamDirectX(nIndex))
			dOffsetX = - dOffsetX;
		else if (eDirectNone == m_pCamPlatformInfo->GetCamDirectX(nIndex))
			dOffsetX = 0;
		if (eDirectNegative == m_pCamPlatformInfo->GetCamDirectY(nIndex))
			dOffsetY = - dOffsetY;
		else if (eDirectNone == m_pCamPlatformInfo->GetCamDirectY(nIndex))
			dOffsetY = 0;

		//将5个位置压入，最后一个是基准位置

		//1
		CPlatformXYAxisPos* AxisMovePos1 = new CPlatformXYAxisPos;
		AxisMovePos1->m_dPosX  = dX0 - dOffsetX;
		AxisMovePos1->m_dPosY  = dY0;	
		m_vCamPlatformAxisPos.at(nIndex).push_back(AxisMovePos1);
		
		//2
		CPlatformXYAxisPos* AxisMovePos2 = new CPlatformXYAxisPos;
		AxisMovePos2->m_dPosX  = dX0 + dOffsetX;
		AxisMovePos2->m_dPosY  = dY0;
		m_vCamPlatformAxisPos.at(nIndex).push_back(AxisMovePos2);
		//3
		CPlatformXYAxisPos* AxisMovePos3 = new CPlatformXYAxisPos;
		AxisMovePos3->m_dPosX  = dX0;
		AxisMovePos3->m_dPosY  = dY0 - dOffsetY;
		m_vCamPlatformAxisPos.at(nIndex).push_back(AxisMovePos3);
		//4
		CPlatformXYAxisPos* AxisMovePos4 = new CPlatformXYAxisPos;
		AxisMovePos4->m_dPosX  = dX0;
		AxisMovePos4->m_dPosY  = dY0 + dOffsetY;	
		m_vCamPlatformAxisPos.at(nIndex).push_back(AxisMovePos4);
		//5
		CPlatformXYAxisPos* AxisMovePos5 = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)m_vCamPlatformInitAxisPos.at(nIndex)));
		if (m_bCalibSendRelativePos)//标定发送相对位置
		{
			AxisMovePos5->m_dPosX = 0.0;
			AxisMovePos5->m_dPosY = 0.0;
		}
		m_vCamPlatformAxisPos.at(nIndex).push_back(AxisMovePos5) ;
	}	
	return m_vCamPlatformAxisPos.at(nIndex);
}

// 设置相机平台标定时图像搜索结果
void vcBaseAlignTool::SetCalibCameraMoveSearchResult(std::vector<CMarkImagePos*> ImageResults)
{
	m_vCalibCameraMoveResults.clear();
	//将每个位置num副图像，共5个不同位置的图像坐标压入 m_vCalibCameraMoveResults
	//独立XY轴安装时5幅；独立X轴安装时3副。
	for (int j=0; j<ImageResults.size(); j++)//位置数
	{
		int num = ImageResults.at(j)->m_vPos.size();//每个位置的图像数
		for (int k=0; k<num; k++)
		{
			if (ImageResults.at(j)->m_vbOK.at(k))		
				m_vCalibCameraMoveResults.push_back(ImageResults.at(j)->m_vPos.at(k));
		}
	}
}




// 执行全局二维码标定计算：图像坐标到靶标坐标的映射关系
BOOL vcBaseAlignTool::ExecuteCalibrateWholeDmCodeBoardImgToBoard(int nExProductIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}

	CString strInfo;
	CString strTemp;

	strInfo.Format(_T("全局二维码靶标标定:图像到靶标映射计算开始--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	int nMarkNum = m_iMarkNum;
	if (m_bTargetObjectCamSeparate)
	{
		nMarkNum = m_iMarkNum/2;
	}
	else
	{
		nMarkNum = m_iMarkNum;
	}

	for (int k = 0; k < nMarkNum; k++)
	{
		// 1. 转换矩阵
		double h1[9];
		memset(h1, 0.0, sizeof(double)*9);
		if(!sfGetHomography(m_vvWholeDmCodeCalibMoveImageResults[k].at(0),m_vvWholeDmCodeCalibMoveBoardResults[k].at(0),h1))
		{
			return FALSE;
		}


		// 日志记录
		strInfo.Empty();
		strTemp.Empty();

		strInfo.Format(_T("相机%d图像到二维码靶标映射矩阵:"),k);		
		for (int i = 0; i < 9; i++)
		{
			strTemp.Format(_T(" h1[%d]:%.6f"),i,h1[i]);
			strInfo = strInfo + strTemp;
		}

		AlignToolLogRecord(strInfo,m_nPlatformIndex);



		// 2. 求精误差
		CCoordPos errorOffset;
		double dis = 0 ;
		svStd vector<sc2Vector> vOffset;
		if (!sfGetHomographyMaxError(m_vvWholeDmCodeCalibMoveImageResults[k].at(0), m_vvWholeDmCodeCalibMoveBoardResults[k].at(0), h1, dis, vOffset))
		{
			return FALSE;
		}
		errorOffset.m_dPosX = dis;
		errorOffset.m_dPosY = dis;

		// 日志记录
		strInfo.Empty();
		strTemp.Empty();

		strInfo.Format(_T("位置%d-h1矩阵映射误差:%.3f"), k, dis);
		AlignToolLogRecord(strInfo,m_nPlatformIndex);

		// 3. 结果汇总记录
		m_vCalibratedInfos.at(k + m_iMarkNum * nExProductIndex)->SetPlatformTransferH1(h1);
		m_vCalibratedInfos.at(k + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH1(errorOffset);

		if (m_vAlignerCalibInfos[k + m_iMarkNum * nExProductIndex] == NULL)
		{
			m_vAlignerCalibInfos.at(k + m_iMarkNum * nExProductIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}

		m_vAlignerCalibInfos.at(k + m_iMarkNum * nExProductIndex)->SetPlatformTransferH1(h1);
		m_vAlignerCalibInfos.at(k + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH1(errorOffset);
	}

	strInfo.Format(_T("全局二维码靶标标定：图像到靶标映射计算结束--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	return TRUE;

}

//执行全局二维码标定计算:图像坐标到靶标坐标的映射关系
// BOOL vcBaseAlignTool::ExecuteCalibrateWholeDmCodeBoardImgToBoard(int nCamIndex,std::vector<sc2Vector> &vImagePos,std::vector<sc2Vector> &vBoardPos)
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}
// 	int nRemCamIndex = nCamIndex % m_iMarkNum;
// 	int nExProductIndex = nCamIndex/m_iMarkNum;
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定图像到靶标映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (j != nExProductIndex)
// 				{
// 					if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 					{
// 						if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 						{
// 							delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 							m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 						}
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 					}
// 					else
// 					{
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 					}
// 				}
// 			}
// 		}
// 	}
// 
// 	if (m_vCalibratedInfos.at(nCamIndex) != NULL)
// 	{
// 		delete m_vCalibratedInfos.at(nCamIndex);			
// 		m_vCalibratedInfos.at(nCamIndex) = NULL;
// 	}
// 
// 	if (nCamIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[nCamIndex] != NULL)
// 	{
// 		m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(*m_vAlignerCalibInfos[nCamIndex]);
// 	}
// 	else
// 	{
// 		m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 	}
// 
// 	for(int k = 0+ m_iMarkNum*nExProductIndex; k < m_iMarkNum*(nExProductIndex+1); k++)
// 	{
// 		if (k != nCamIndex)
// 		{
// 			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 			}
// 			else
// 			{
// 				if (m_vCalibratedInfos.at(k) != NULL)
// 				{
// 					delete m_vCalibratedInfos.at(k);
// 					m_vCalibratedInfos.at(k) = NULL;
// 				}
// 				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 			}
// 		}
// 	}
// 
// 
// 	if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
// 	{
// 		CString strOut, strTmp;
// 		double p[15];
// 		memset(p, 0.0, sizeof(double)*15);
// 		scCalibrateResult result = m_vAlignerCalibInfos.at(nCamIndex)->m_result;
// 		result.GetNonlinearProjectResult(p);
// 		double dRms = result.GetRMS();
// 		strOut.Format(_T("标定位置:%d, 畸变参数: "), nCamIndex);
// 		for (int i=0;i<15; i++)
// 		{
// 			strTmp.Format(_T("P%d:%.6f "), i, p[i]);
// 			strOut += strTmp;
// 		}
// 		strTmp.Format(_T("P15:%.6f "),dRms);
// 		strOut += strTmp;
// 		AlignToolLogRecord(strOut,m_nPlatformIndex);
// 
// 		std::vector<sc2Vector> tarImgPosDisCor;
// 		ExecuteDisCorPoint(nCamIndex, vImagePos, tarImgPosDisCor);
// 		vImagePos = tarImgPosDisCor;
// 
// 	}
// 
// 	// 计算H变换矩阵
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 
// 	if(!sfGetHomography(vImagePos,vBoardPos,h1))
// 	{
// 		return FALSE;
// 	}
// 
// 	strInfo.Format(_T("图像到二维码靶标映射矩阵:"));
// 	CString strTmpInfo;
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h1[%d]:%.6f"),i,h1[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 
// 
// 
// 	CCoordPos errorOffset;
// 	double dis = 0 ;
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxError(vImagePos,vBoardPos,h1,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH1(h1);
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH1(errorOffset);
// 
// 
// 	if (m_vAlignerCalibInfos[nCamIndex] == NULL)
// 	{
// 		m_vAlignerCalibInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 	}
// 	m_vAlignerCalibInfos.at(nCamIndex)->SetPlatformTransferH1(h1);
// 	m_vAlignerCalibInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH1(errorOffset);
// 
// 
// 	strInfo.Format(_T("h1矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定图像到靶标映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return TRUE;
// 
// }

// 执行全局二维码标定：靶标坐标到平台坐标的旋转缩放关系
BOOL vcBaseAlignTool::ExecuteCalibrateWholeDmCodeBoardBoardToPlat(int nExProductIndex, int nMarkType)
{
	//标定次数（mark点数量，不是相机数量）
	if (m_iMarkNum == 0)
	{
		return FALSE;
	}

	if (m_bPlatformPick)
	{
		if (m_ePickCamPlatformType == ePickCamPlatformSepFix)
		{
			switch(m_eMidPlatformType)
			{
			case ePlatformXYD:
			case ePlatformX1X2Y:
			case ePlatformXY1Y2:
				{
					return ExecuteCalibrateSingleCamWholeDmCodeBoardBoardToPlat(nExProductIndex);					
				}

			default:
				{
					return FALSE;
				}

			}
		}
		else
		{
			return FALSE;
		}

		return FALSE;

	}
	else
	{
		switch(m_eMidPlatformType)
		{
		case ePlatformXYD:
		case ePlatformX1X2Y:
		case ePlatformXY1Y2:
			{
				return ExecuteCalibrateSingleCamWholeDmCodeBoardBoardToPlat(nExProductIndex);
			}
			break;

		case ePlatformXD:
			{
				return ExecuteCalibrateSingleCamXDWholeDmCodeBoardBoardToPlat(nExProductIndex);
			}
			break;

		case ePlatformYD:
			{
				return ExecuteCalibrateSingleCamYDWholeDmCodeBoardBoardToPlat(nExProductIndex);
			}
			break;

		case ePlatformXYPD:
			{
				return ExecuteCalibrateSingleCamXYPDWholeDmCodeBoardBoardToPlat(nExProductIndex);
			}
			break;

		default:
			{
				return FALSE;
			}

			return FALSE;
		}
	}


	return FALSE;
}

// 执行全局二维码标定：计算旋转中心
BOOL vcBaseAlignTool::ExecuteCalibWholeDmCodeBoard(int nExProductIndex/* = 0*/,BOOL bPickDiffPosSameCalib/* = FALSE*/)
{
	CString strInfo;
	CString strTemp;
	strInfo.Format(_T("全局二维码靶标标定:图像到靶标映射计算开始--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	if (0 == m_iMarkNum)
	{
		return FALSE;
	}

	int nMarkNum = m_iMarkNum;
	if (m_bTargetObjectCamSeparate)
	{
		nMarkNum = m_iMarkNum/2;
	}
	else
	{
		nMarkNum = m_iMarkNum;
	}

	std::vector<sc2Vector> vDmCodeBoardPosFit;
	std::vector<int> vFitSize;

	switch(m_eMidPlatformType)
	{
	case ePlatformXYD:
	case ePlatformX1X2Y:
	case ePlatformXY1Y2:
		{
			for (int k = 0; k < nMarkNum; k++)
			{
				// 1. 基准位置（标定走位第0个位置），图像与二维码映射关系
				double ImageToBoardH_Pos0[9];
				memset(ImageToBoardH_Pos0, 0.0, sizeof(double)*9);
				if(!sfGetHomography(m_vvWholeDmCodeCalibMoveImageResults[k].at(0),m_vvWholeDmCodeCalibMoveBoardResults[k].at(0),ImageToBoardH_Pos0))
				{
					return FALSE;
				}

				// 日志记录
				strInfo.Empty();
				strTemp.Empty();

				strInfo.Format(_T("相机%d-标定走位0-图像到二维码映射矩阵:"), k + m_iMarkNum * nExProductIndex);
				for (int i=0;i<9;i++)
				{
					strTemp.Format(_T(" h[%d]:%.6f"),i,ImageToBoardH_Pos0[i]);
					strInfo = strInfo + strTemp;
				}
				AlignToolLogRecord(strInfo,m_nPlatformIndex);


				// 2. 选取图像上的9个点位置，用于求解旋转中心
				double dImageCenterX = m_ImageSizes.GetMarkImagePos(k).GetPosX() / 2.0;
				double dImageCenterY = m_ImageSizes.GetMarkImagePos(k).GetPosY() / 2.0;

				double dImageMoveX = m_ImageSizes.GetMarkImagePos(k).GetPosX() / 4.0;;
				double dImageMoveY = m_ImageSizes.GetMarkImagePos(k).GetPosY() / 4.0;;

				std::vector<sc2Vector> vImageMove;					
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY + dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY + dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY + dImageMoveY));

				std::vector<sc2Vector> vDmCodeMove;
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));		


				strInfo.Empty();
				strTemp.Empty();
				strInfo.Format(_T("相机%d选取图像点在基准位置处（标定第0个位置）的二维码平台坐标计算开始----------"), k);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

				// 3. 选取图像点在基准位置处(标定第0个位置)的二维码平台坐标
				for (int p = 0; p < vImageMove.size(); p++)
				{
					strInfo.Empty();
					strTemp.Empty();

					if ( FALSE == ConvertSrcPosToDstPos(m_vvWholeDmCodeCalibMoveImageResults[k].at(0),m_vvWholeDmCodeCalibMoveBoardResults[k].at(0), vImageMove.at(p), vDmCodeMove.at(p), TRUE, k + m_iMarkNum * nExProductIndex) )
					{
						return FALSE;
					}

					strInfo.Format(_T("设定图像索引%d-图像坐标-二维码平台坐标："), p);
					strTemp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"), vImageMove.at(p).GetX(),	vImageMove.at(p).GetY(), vDmCodeMove.at(p).GetX(),	vDmCodeMove.at(p).GetY());

					strInfo = strInfo + strTemp;

					AlignToolLogRecord(strInfo,m_nPlatformIndex);
				}

				strInfo.Empty();
				strTemp.Empty();
				strInfo.Format(_T("相机%d选取图像点在基准位置处（标定第0个位置）的二维码平台坐标计算结束----------"), k);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);


				// 4. 旋转中心计算
				std::vector<sc2Vector> vDmCodeImagePos;
				std::vector<sc2Vector> vDmCodeBoardPos;

				sc2Vector DmCodeImageMovePosTemp;
				sc2Vector DmCodeBoardPosFitTemp;

				if (vImageMove.size() != vDmCodeMove.size())
				{
					return FALSE;
				}


				for (int j = 0; j < vDmCodeMove.size(); j++)
				{
					strInfo.Empty();
					strTemp.Empty();
					strInfo.Format(_T("拟合点计算：相机%d-图像索引%d计算开始----------"), k, j);
					AlignToolLogRecord(strInfo,m_nPlatformIndex);

					// 标定移动位置索引
					for (int i = 9; i < 12; i++)
					{
						strInfo.Empty();
						strTemp.Empty();

						vDmCodeImagePos = m_vvWholeDmCodeCalibMoveImageResults[k].at(i);
						vDmCodeBoardPos = m_vvWholeDmCodeCalibMoveBoardResults[k].at(i);

						// (1) 二维码平台坐标对应的二维码图像坐标（说明：该二维码图像坐标为虚拟出来的）
						if (FALSE == ConvertSrcPosToDstPos(vDmCodeBoardPos, vDmCodeImagePos, vDmCodeMove.at(j), DmCodeImageMovePosTemp, FALSE, k + m_iMarkNum * nExProductIndex))
						{
							return FALSE;
						}

						// (2) 二维码图像坐标在初始位置处的二维码平台坐标
						DmCodeBoardPosFitTemp = sfHomographyProject(DmCodeImageMovePosTemp,ImageToBoardH_Pos0);

						vDmCodeBoardPosFit.push_back(DmCodeBoardPosFitTemp);

						strInfo.Format(_T("标定走位%d-图像坐标-二维码平台坐标-二维码图像坐标-拟合点坐标："), i);
						strTemp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)-(%.3f,%.3f)-(%.3f,%.3f)"),
							vImageMove.at(j).GetX(),		vImageMove.at(j).GetY(),
							vDmCodeMove.at(j).GetX(),		vDmCodeMove.at(j).GetY(),
							DmCodeImageMovePosTemp.GetX(),	DmCodeImageMovePosTemp.GetY(),
							DmCodeBoardPosFitTemp.GetX(),	DmCodeBoardPosFitTemp.GetY());

						strInfo = strInfo + strTemp;

						AlignToolLogRecord(strInfo,m_nPlatformIndex);

					}

					vFitSize.push_back(3);

					strInfo.Empty();
					strTemp.Empty();
					strInfo.Format(_T("拟合点计算：相机%d-图像索引%d计算结束----------"), k, j);
					AlignToolLogRecord(strInfo,m_nPlatformIndex);

				}

			}
		}
		break;

	case ePlatformXD:
	case ePlatformYD:
		{
			for (int k = 0; k < nMarkNum; k++)
			{
				// 1. 基准位置（标定走位第0个位置），图像与二维码映射关系
				double ImageToBoardH_Pos0[9];
				memset(ImageToBoardH_Pos0, 0.0, sizeof(double)*9);
				if(!sfGetHomography( m_vvWholeDmCodeCalibMoveImageResults[k].at(0),m_vvWholeDmCodeCalibMoveBoardResults[k].at(0),ImageToBoardH_Pos0))
				{
					return FALSE;
				}

				// 日志记录
				strInfo.Empty();
				strTemp.Empty();

				strInfo.Format(_T("相机%d-标定走位0-图像到二维码映射矩阵:"), k + m_iMarkNum*nExProductIndex);
				for (int i=0;i<9;i++)
				{
					strTemp.Format(_T(" h[%d]:%.6f"),i,ImageToBoardH_Pos0[i]);
					strInfo = strInfo + strTemp;
				}
				AlignToolLogRecord(strInfo,m_nPlatformIndex);


				// 2. 选取图像上的9个点位置，用于求解旋转中心
				double dImageCenterX = m_ImageSizes.GetMarkImagePos(k).GetPosX() / 2.0;
				double dImageCenterY = m_ImageSizes.GetMarkImagePos(k).GetPosY() / 2.0;

				double dImageMoveX = m_ImageSizes.GetMarkImagePos(k).GetPosX() / 4.0;;
				double dImageMoveY = m_ImageSizes.GetMarkImagePos(k).GetPosY() / 4.0;;

				std::vector<sc2Vector> vImageMove;					
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY + dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY + dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY + dImageMoveY));

				std::vector<sc2Vector> vDmCodeMove;
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));		


				strInfo.Empty();
				strTemp.Empty();
				strInfo.Format(_T("相机%d选取图像点在基准位置处（标定第0个位置）的二维码平台坐标计算开始----------"), k);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

				// 3. 选取图像点在基准位置处(标定第0个位置)的二维码平台坐标
				for (int p = 0; p < vImageMove.size(); p++)
				{
					strInfo.Empty();
					strTemp.Empty();

					if (FALSE == ConvertSrcPosToDstPos( m_vvWholeDmCodeCalibMoveImageResults[k].at(0),m_vvWholeDmCodeCalibMoveBoardResults[k].at(0), vImageMove.at(p), vDmCodeMove.at(p), TRUE, k + m_iMarkNum * nExProductIndex) )
					{
						return FALSE;
					}

					strInfo.Format(_T("设定图像索引%d-图像坐标-二维码平台坐标："), p);
					strTemp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"), vImageMove.at(p).GetX(),	vImageMove.at(p).GetY(), vDmCodeMove.at(p).GetX(),	vDmCodeMove.at(p).GetY());

					strInfo = strInfo + strTemp;

					AlignToolLogRecord(strInfo,m_nPlatformIndex);
				}

				strInfo.Empty();
				strTemp.Empty();
				strInfo.Format(_T("相机%d选取图像点在基准位置处（标定第0个位置）的二维码平台坐标计算结束----------"), k);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);


				// 4. 旋转中心计算
				std::vector<sc2Vector> vDmCodeImagePos;
				std::vector<sc2Vector> vDmCodeBoardPos;

				sc2Vector DmCodeImageMovePosTemp;
				sc2Vector DmCodeBoardPosFitTemp;

				if (vImageMove.size() != vDmCodeMove.size())
				{
					return FALSE;
				}


				for (int j = 0; j < vDmCodeMove.size(); j++)
				{
					strInfo.Empty();
					strTemp.Empty();
					strInfo.Format(_T("拟合点计算：相机%d-图像索引%d计算开始----------"), k, j);
					AlignToolLogRecord(strInfo,m_nPlatformIndex);

					// 标定移动位置索引
					for (int i = 3; i < 6; i++)
					{
						strInfo.Empty();
						strTemp.Empty();

						vDmCodeImagePos = m_vvWholeDmCodeCalibMoveImageResults[k].at(i);
						vDmCodeBoardPos = m_vvWholeDmCodeCalibMoveBoardResults[k].at(i);

						// (1) 二维码平台坐标对应的二维码图像坐标（说明：该二维码图像坐标为虚拟出来的）
						if (FALSE == ConvertSrcPosToDstPos(vDmCodeBoardPos, vDmCodeImagePos, vDmCodeMove.at(j), DmCodeImageMovePosTemp, FALSE, k + m_iMarkNum * nExProductIndex))
						{
							return FALSE;
						}

						// (2) 二维码图像坐标在初始位置处的二维码平台坐标
						DmCodeBoardPosFitTemp = sfHomographyProject(DmCodeImageMovePosTemp,ImageToBoardH_Pos0);

						vDmCodeBoardPosFit.push_back(DmCodeBoardPosFitTemp);

						strInfo.Format(_T("标定走位%d-图像坐标-二维码平台坐标-二维码图像坐标-拟合点坐标："), i);
						strTemp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)-(%.3f,%.3f)-(%.3f,%.3f)"),
							vImageMove.at(j).GetX(),		vImageMove.at(j).GetY(),
							vDmCodeMove.at(j).GetX(),		vDmCodeMove.at(j).GetY(),
							DmCodeImageMovePosTemp.GetX(),	DmCodeImageMovePosTemp.GetY(),
							DmCodeBoardPosFitTemp.GetX(),	DmCodeBoardPosFitTemp.GetY());

						strInfo = strInfo + strTemp;

						AlignToolLogRecord(strInfo,m_nPlatformIndex);

					}

					vFitSize.push_back(3);

					strInfo.Empty();
					strTemp.Empty();
					strInfo.Format(_T("拟合点计算：相机%d-图像索引%d计算结束----------"), k, j);
					AlignToolLogRecord(strInfo,m_nPlatformIndex);

				}

			}
		}
		break;

	case ePlatformXYPD:
		{
			for (int k = 0; k < nMarkNum; k++)
			{
				// 1. 基准位置（标定走位第0个位置），图像与二维码映射关系
				double ImageToBoardH_Pos0[9];
				memset(ImageToBoardH_Pos0, 0.0, sizeof(double)*9);
				if(!sfGetHomography(m_vvWholeDmCodeCalibMoveImageResults[k].at(0),m_vvWholeDmCodeCalibMoveBoardResults[k].at(0),ImageToBoardH_Pos0))
				{
					return FALSE;
				}

				// 日志记录
				strInfo.Empty();
				strTemp.Empty();

				strInfo.Format(_T("相机%d-标定走位0-图像到二维码映射矩阵:"), k + m_iMarkNum * nExProductIndex);
				for (int i=0;i<9;i++)
				{
					strTemp.Format(_T(" h[%d]:%.6f"),i,ImageToBoardH_Pos0[i]);
					strInfo = strInfo + strTemp;
				}
				AlignToolLogRecord(strInfo,m_nPlatformIndex);


				// 2. 选取图像上的9个点位置，用于求解旋转中心
				double dImageCenterX = m_ImageSizes.GetMarkImagePos(k).GetPosX() / 2.0;
				double dImageCenterY = m_ImageSizes.GetMarkImagePos(k).GetPosY() / 2.0;

				double dImageMoveX = m_ImageSizes.GetMarkImagePos(k).GetPosX() / 4.0;;
				double dImageMoveY = m_ImageSizes.GetMarkImagePos(k).GetPosY() / 4.0;;

				std::vector<sc2Vector> vImageMove;					
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY + dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX + dImageMoveX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY - dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY));
				vImageMove.push_back(sc2Vector(dImageCenterX - dImageMoveX, dImageCenterY + dImageMoveY));
				vImageMove.push_back(sc2Vector(dImageCenterX, dImageCenterY + dImageMoveY));

				std::vector<sc2Vector> vDmCodeMove;
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));
				vDmCodeMove.push_back(sc2Vector(0, 0));		


				strInfo.Empty();
				strTemp.Empty();
				strInfo.Format(_T("相机%d选取图像点在基准位置处（标定第0个位置）的二维码平台坐标计算开始----------"), k);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);

				// 3. 选取图像点在基准位置处(标定第0个位置)的二维码平台坐标
				for (int p = 0; p < vImageMove.size(); p++)
				{
					strInfo.Empty();
					strTemp.Empty();

					if (FALSE == ConvertSrcPosToDstPos( m_vvWholeDmCodeCalibMoveImageResults[k].at(0),m_vvWholeDmCodeCalibMoveBoardResults[k].at(0), vImageMove.at(p), vDmCodeMove.at(p), TRUE, k + m_iMarkNum * nExProductIndex) )
					{
						return FALSE;
					}

					strInfo.Format(_T("设定图像索引%d-图像坐标-二维码平台坐标："), p);
					strTemp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"), vImageMove.at(p).GetX(),	vImageMove.at(p).GetY(), vDmCodeMove.at(p).GetX(),	vDmCodeMove.at(p).GetY());

					strInfo = strInfo + strTemp;

					AlignToolLogRecord(strInfo,m_nPlatformIndex);
				}

				strInfo.Empty();
				strTemp.Empty();
				strInfo.Format(_T("相机%d选取图像点在基准位置处（标定第0个位置）的二维码平台坐标计算结束----------"), k);
				AlignToolLogRecord(strInfo,m_nPlatformIndex);


				// 4. 旋转中心计算
				std::vector<sc2Vector> vDmCodeImagePos;
				std::vector<sc2Vector> vDmCodeBoardPos;

				sc2Vector DmCodeImageMovePosTemp;
				sc2Vector DmCodeBoardPosFitTemp;

				if (vImageMove.size() != vDmCodeMove.size())
				{
					return FALSE;
				}


				for (int j = 0; j < vDmCodeMove.size(); j++)
				{
					strInfo.Empty();
					strTemp.Empty();
					strInfo.Format(_T("拟合点计算：相机%d-图像索引%d计算开始----------"), k, j);
					AlignToolLogRecord(strInfo,m_nPlatformIndex);

					// 标定移动位置索引
					for (int i = 11; i < 14; i++)
					{
						strInfo.Empty();
						strTemp.Empty();

						vDmCodeImagePos = m_vvWholeDmCodeCalibMoveImageResults[k].at(i);
						vDmCodeBoardPos = m_vvWholeDmCodeCalibMoveBoardResults[k].at(i);

						// (1) 二维码平台坐标对应的二维码图像坐标（说明：该二维码图像坐标为虚拟出来的）
						if (FALSE == ConvertSrcPosToDstPos(vDmCodeBoardPos, vDmCodeImagePos, vDmCodeMove.at(j), DmCodeImageMovePosTemp, FALSE, k + m_iMarkNum * nExProductIndex))
						{
							return FALSE;
						}

						// (2) 二维码图像坐标在初始位置处的二维码平台坐标
						DmCodeBoardPosFitTemp = sfHomographyProject(DmCodeImageMovePosTemp,ImageToBoardH_Pos0);

						vDmCodeBoardPosFit.push_back(DmCodeBoardPosFitTemp);

						strInfo.Format(_T("标定走位%d-图像坐标-二维码平台坐标-二维码图像坐标-拟合点坐标："), i);
						strTemp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)-(%.3f,%.3f)-(%.3f,%.3f)"),
							vImageMove.at(j).GetX(),		vImageMove.at(j).GetY(),
							vDmCodeMove.at(j).GetX(),		vDmCodeMove.at(j).GetY(),
							DmCodeImageMovePosTemp.GetX(),	DmCodeImageMovePosTemp.GetY(),
							DmCodeBoardPosFitTemp.GetX(),	DmCodeBoardPosFitTemp.GetY());

						strInfo = strInfo + strTemp;

						AlignToolLogRecord(strInfo,m_nPlatformIndex);

					}

					vFitSize.push_back(3);

					strInfo.Empty();
					strTemp.Empty();
					strInfo.Format(_T("拟合点计算：相机%d-图像索引%d计算结束----------"), k, j);
					AlignToolLogRecord(strInfo,m_nPlatformIndex);

				}

			}
		}
		break;

	default:
		{
			return FALSE;
		}
		break;

	}

	//旋转中心标定
	sc2Vector center;
	double dMaxRms;
	if (!sfGetRotationCenter(vDmCodeBoardPosFit,vFitSize,center,dMaxRms))
	{
		return FALSE;
	}

	strInfo.Format(_T("基准中心平台坐标：(%.4f,%.4f)"),-center.GetX(),-center.GetY());
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	for (int i=0;i<nMarkNum;i++)
	{
		m_vCalibratedInfos.at(i+m_iMarkNum*nExProductIndex)->SetMarkPlatformCoordPos(CCoordPos(-center.GetX(),-center.GetY(),0));
		m_vCalibratedInfos.at(i+m_iMarkNum*nExProductIndex)->SetValid(TRUE);


		if (m_vAlignerCalibInfos[i+m_iMarkNum*nExProductIndex] == NULL)
		{
			m_vAlignerCalibInfos.at(i+m_iMarkNum*nExProductIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}
		m_vAlignerCalibInfos.at(i+m_iMarkNum*nExProductIndex)->SetMarkPlatformCoordPos(CCoordPos(-center.GetX(),-center.GetY(),0));
		m_vAlignerCalibInfos.at(i+m_iMarkNum*nExProductIndex)->SetValid(TRUE);

	}

	strInfo.Format(_T("全局二维码靶标标定:图像到靶标映射计算结束--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	return TRUE;

}

// 执行全局二维码标定：计算旋转中心
// BOOL vcBaseAlignTool::ExecuteCalibWholeDmCodeBoard(int nExProductIdx/* = 0*/,BOOL bPickDiffPosSameCalib/* = FALSE*/)
// {
// 	CString strInfo;
// 	strInfo.Format(_T("全局二维码靶标标定图像到靶标映射计算开始--------------"));
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}
// 
// 	std::vector<int> nObjectPosIndex;
// 	std::vector<int> nTargetPosIndex;
// 
// 	if (m_bTargetObjectCamSeparate)
// 	{
// // 		if (m_bEnableTargetPositionVirtualMode)
// // 		{
// // 			// 对象保护
// // 			for (long i=0; i<m_nObjectPositionNum; i++)
// // 			{
// // 				nObjectPosIndex.push_back(i);
// // 			}
// // 
// // 			// 目标保护
// // 			// 说明：目标位置虚拟模式:0-78虚拟;1-56虚拟	
// // 			if (m_nTargetPositionVirtualMode == 0)
// // 			{
// // 				for (long i=0; i<m_nTargetPositionNum; i++)
// // 				{
// // 					nTargetPosIndex.push_back(i + m_iMarkNum/2);
// // 				}
// // 			}
// // 			else
// // 			{
// // 				for (long i=0; i<m_nTargetPositionNum; i++)
// // 				{
// // 					nTargetPosIndex.push_back(i+m_nTargetPositionNum + m_iMarkNum/2);
// // 				}
// // 			}
// // 
// // 		}
// // 		else if (m_bEnableObjectPositionVirtualMode)
// // 		{
// // 			// 对象保护
// // 			// 说明：对象位置虚拟模式:0-34虚拟;1-12虚拟
// // 			if (m_nObjectPositionVirtualMode == 0)
// // 			{
// // 				for (long i=0; i<m_nObjectPositionNum; i++)
// // 				{
// // 					nObjectPosIndex.push_back(i);
// // 				}
// // 			}
// // 			else
// // 			{
// // 				for (long i=0; i<m_nObjectPositionNum; i++)
// // 				{
// // 					nObjectPosIndex.push_back(i+m_nObjectPositionNum);
// // 				}
// // 			}
// // 
// // 			// 目标保护
// // 			for (long i=0; i<m_nTargetPositionNum; i++)
// // 			{
// // 				nTargetPosIndex.push_back(i + m_iMarkNum/2);
// // 			}
// // 
// // 		}
// // 		else
// 		{
// 			long i=0;
// 
// 			// 对象保护
// 			for (i=0; i<m_iMarkNum/2; i++)
// 			{
// 				nObjectPosIndex.push_back(i);
// 			}
// 
// 			// 目标保护
// 			for (i=0; i<m_iMarkNum/2; i++)
// 			{
// 				nTargetPosIndex.push_back(i + m_iMarkNum/2);
// 			}
// 		}
// 
// 
// 		if (m_eMidPlatformType == ePlatformXYPD)
// 		{
// 			for (int i=0;i<nTargetPosIndex.size();i++)
// 			{
// 				int nIndex = nTargetPosIndex.at(i);
// 				if (m_vCalibPlatformMoveResults[nIndex].size()==0)
// 				{
// 					strInfo.Format(_T("请先进行图像到靶标坐标映射"));
// 					AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 					return FALSE;
// 				}
// 			}
// 		}
// 		else
// 		{
// 			for (int i=0;i<nObjectPosIndex.size();i++)
// 			{
// 				int nIndex = nObjectPosIndex.at(i);
// 				if (m_vCalibPlatformMoveResults[nIndex].size()==0)
// 				{
// 					strInfo.Format(_T("请先进行图像到靶标坐标映射"));
// 					AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 					return FALSE;
// 				}
// 			}
// 		}
// 		
// 	}
// 	else
// 	{
// 		// 对象保护
// 		for (long i=0; i<m_iMarkNum; i++)
// 		{
// 			nObjectPosIndex.push_back(i);
// 		}
// 
// 		// 目标保护
// 		for (long i=0; i<m_iMarkNum; i++)
// 		{
// 			nTargetPosIndex.push_back(i);
// 		}
// 
// 		{
// 			for (int i=0;i<nObjectPosIndex.size();i++)
// 			{
// 				int nIndex = nObjectPosIndex.at(i);
// 				if (bPickDiffPosSameCalib && nIndex != 0)
// 				{
// 					continue;
// 				}
// 				if (m_vCalibPlatformMoveResults[nIndex].size()==0)
// 				{
// 					strInfo.Format(_T("请先进行图像到靶标坐标映射"));
// 					AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 					return FALSE;
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 	svStd vector<sc2Vector> vFitPts;
// 	svStd vector<int> vNums;
// 	//std::vector<std::vector<sc2Vector>> PosPlatPts;
// 	if (m_bTargetObjectCamSeparate)
// 	{
// 		//PosPlatPts.resize(m_iMarkNum/2);
// 
// 		sc2Vector tmpImgPt;
// 		sc2Vector tmpPlatPt;
// 		sc2Vector tmpBoardPt;
// 		if (m_eMidPlatformType == ePlatformXYPD)
// 		{
// 
// 			for (int n=0;n<nTargetPosIndex.size();n++)
// 			{
// 					int k = nTargetPosIndex.at(n);
// 					strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 					CString strTmp;
// 					tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(10).m_dPosX);
// 					tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(10).m_dPosY);
// 					tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 					tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 					//PosPlatPts.at(k).push_back(tmpPlatPt);
// 					vFitPts.push_back(tmpPlatPt);
// 
// 					strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 					strInfo += strTmp;
// 
// 					for (int i=11;i<13;i++)
// 					{
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 					}
// 					/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 					vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 					vNums.push_back(3);
// 
// 					
// 					AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 			}
// 		}
// 		else
// 		{
// 			for (int n=0;n<nObjectPosIndex.size();n++)
// 			{
// 				int k = nObjectPosIndex.at(n);
// 				switch(m_eMidPlatformType)
// 				{
// 				//case ePlatformXYD:
// 				//	{
// 				//		if(m_bPlatformPick && m_ePickCamPlatformType == ePickCamPlatformShareXY)
// 				//		{
// 				//			strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 				//			CString strTmp;
// 				//			tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(10).m_dPosX);
// 				//			tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(10).m_dPosY);
// 				//			tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 				//			tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 				//			//PosPlatPts.at(k).push_back(tmpPlatPt);
// 				//			vFitPts.push_back(tmpPlatPt);
// 
// 				//			strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 				//			strInfo += strTmp;
// 
// 				//			for (int i=11;i<13;i++)
// 				//			{
// 				//				tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 				//				tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 				//				tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 				//				tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 				//				//PosPlatPts.at(k).push_back(tmpPlatPt);
// 				//				vFitPts.push_back(tmpPlatPt);
// 				//				strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 				//				strInfo += strTmp;
// 				//			}
// 				//			/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 				//			vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 				//			vNums.push_back(3);
// 				//			AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 				//		}
// 				//		else
// 				//		{
// 				//			strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 				//			CString strTmp;
// 				//			tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(11).m_dPosX);
// 				//			tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(11).m_dPosY);
// 				//			tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 				//			tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 				//			//PosPlatPts.at(k).push_back(tmpPlatPt);
// 				//			vFitPts.push_back(tmpPlatPt);
// 
// 				//			strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 				//			strInfo += strTmp;
// 				//			for (int i=9;i<11;i++)
// 				//			{
// 				//				tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 				//				tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 				//				tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 				//				tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 				//				//PosPlatPts.at(k).push_back(tmpPlatPt);
// 				//				vFitPts.push_back(tmpPlatPt);
// 
// 				//				strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 				//				strInfo += strTmp;
// 				//			}
// 				//			/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 				//			vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 				//			vNums.push_back(3);
// 				//			AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 				//		}
// 				//	}
// 				//	break;
// 				case ePlatformXD:
// 					{
// 						strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 						CString strTmp;
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(0).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(0).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 						for (int i=3;i<5;i++)
// 						{
// 							tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 							tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 							tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 							tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 							//PosPlatPts.at(k).push_back(tmpPlatPt);
// 							vFitPts.push_back(tmpPlatPt);
// 
// 							strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 							strInfo += strTmp;
// 						}
// 						/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 						vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 						vNums.push_back(3);
// 						AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 					}
// 					break;
// 				case ePlatformYD:
// 					{
// 						strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 						CString strTmp;
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(0).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(0).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 						for (int i=3;i<5;i++)
// 						{
// 							tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 							tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 							tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 							tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 							//PosPlatPts.at(k).push_back(tmpPlatPt);
// 							vFitPts.push_back(tmpPlatPt);
// 							strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 							strInfo += strTmp;
// 						}
// 						/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 						vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 						vNums.push_back(3);
// 						AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 					}
// 					break;
// 				case ePlatformXDPY:
// 					{
// 						strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 						CString strTmp;
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(0).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(0).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 						for (int i=3;i<5;i++)
// 						{
// 							tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 							tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 							tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 							tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 							//PosPlatPts.at(k).push_back(tmpPlatPt);
// 							vFitPts.push_back(tmpPlatPt);
// 							strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 							strInfo += strTmp;
// 						}
// 						/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 						vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 						vNums.push_back(3);
// 						AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 					}
// 					break;
// 				case ePlatformXDPY1:
// 					{
// 						strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 						CString strTmp;
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(0).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(0).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 						for (int i=3;i<5;i++)
// 						{
// 							tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 							tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 							tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 							tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 							//PosPlatPts.at(k).push_back(tmpPlatPt);
// 							vFitPts.push_back(tmpPlatPt);
// 							strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 							strInfo += strTmp;
// 						}
// 						/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 						vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 						vNums.push_back(3);
// 						AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 					}
// 					break;
// 				default:
// 					{
// 						if(m_bPlatformPick)
// 						{
// 							if (bPickDiffPosSameCalib&& k!=0)
// 							{
// 								continue;
// 							}
// 							if (m_ePickCamPlatformType == ePickCamPlatformShareXY)
// 							{
// 								strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 								CString strTmp;
// 								tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(10).m_dPosX);
// 								tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(10).m_dPosY);
// 								tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 								tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 								//PosPlatPts.at(k).push_back(tmpPlatPt);
// 								vFitPts.push_back(tmpPlatPt);
// 
// 								strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 								strInfo += strTmp;
// 
// 								for (int i=11;i<13;i++)
// 								{
// 									tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 									tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 									tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 									tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 									//PosPlatPts.at(k).push_back(tmpPlatPt);
// 									vFitPts.push_back(tmpPlatPt);
// 									strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 									strInfo += strTmp;
// 								}
// 								/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 								vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 								vNums.push_back(3);
// 								AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 							}
// 							else
// 							{
// 								strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 								CString strTmp;
// 								tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(11).m_dPosX);
// 								tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(11).m_dPosY);
// 								tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 								tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 								//PosPlatPts.at(k).push_back(tmpPlatPt);
// 								vFitPts.push_back(tmpPlatPt);
// 
// 								strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 								strInfo += strTmp;
// 								for (int i=9;i<11;i++)
// 								{
// 									tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 									tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 									tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 									tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 									//PosPlatPts.at(k).push_back(tmpPlatPt);
// 									vFitPts.push_back(tmpPlatPt);
// 
// 									strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 									strInfo += strTmp;
// 								}
// 								/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 								vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 								vNums.push_back(3);
// 								AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 							}
// 							
// 						}
// 						else
// 						{
// 							strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 							CString strTmp;
// 							tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(11).m_dPosX);
// 							tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(11).m_dPosY);
// 							tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 							tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 							//PosPlatPts.at(k).push_back(tmpPlatPt);
// 							vFitPts.push_back(tmpPlatPt);
// 
// 							strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 							strInfo += strTmp;
// 							for (int i=9;i<11;i++)
// 							{
// 								tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 								tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 								tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 								tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 								//PosPlatPts.at(k).push_back(tmpPlatPt);
// 								vFitPts.push_back(tmpPlatPt);
// 
// 								strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 								strInfo += strTmp;
// 							}
// 							/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 							vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 							vNums.push_back(3);
// 							AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 						}
// 					}
// 					break;
// 				}
// 			
// 			}
// 		}
// 		
// 	}
// 	else
// 	{
// 		//PosPlatPts.resize(m_iMarkNum);
// 
// 		sc2Vector tmpImgPt;
// 		sc2Vector tmpPlatPt;
// 		sc2Vector tmpBoardPt;
// 		for (int n=0;n<nObjectPosIndex.size();n++)
// 		{
// 			int k = nObjectPosIndex.at(n);
// 			switch(m_eMidPlatformType)
// 			{
// 			//case ePlatformXYD:
// 			//	{
// 			//		if(m_bPlatformPick && m_ePickCamPlatformType == ePickCamPlatformShareXY)
// 			//		{
// 			//			strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 			//			CString strTmp;
// 			//			tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(10).m_dPosX);
// 			//			tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(10).m_dPosY);
// 			//			tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 			//			tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 			//			//PosPlatPts.at(k).push_back(tmpPlatPt);
// 			//			vFitPts.push_back(tmpPlatPt);
// 			//			strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 			//			strInfo += strTmp;
// 			//			for (int i=11;i<13;i++)
// 			//			{
// 			//				tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 			//				tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 			//				tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 			//				tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 			//				//PosPlatPts.at(k).push_back(tmpPlatPt);
// 			//				vFitPts.push_back(tmpPlatPt);
// 			//				strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 			//				strInfo += strTmp;
// 			//			}
// 			//			/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 			//			vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 			//			vNums.push_back(3);
// 			//			AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 			//		}
// 			//		else
// 			//		{
// 			//			strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 			//			CString strTmp;
// 			//			tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(11).m_dPosX);
// 			//			tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(11).m_dPosY);
// 			//			tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 			//			tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 			//			//PosPlatPts.at(k).push_back(tmpPlatPt);
// 			//			vFitPts.push_back(tmpPlatPt);
// 			//			strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 			//			strInfo += strTmp;
// 			//			for (int i=9;i<11;i++)
// 			//			{
// 			//				tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 			//				tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 			//				tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 			//				tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 			//				//PosPlatPts.at(k).push_back(tmpPlatPt);
// 			//				vFitPts.push_back(tmpPlatPt);
// 			//				strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 			//				strInfo += strTmp;
// 			//			}
// 			//			/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 			//			vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 			//			vNums.push_back(3);
// 			//			AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 			//		}
// 			//		
// 			//	}
// 			//	break;
// 			case ePlatformXD:
// 				{
// 					strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 					CString strTmp;
// 					tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(0).m_dPosX);
// 					tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(0).m_dPosY);
// 					tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 					tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 					//PosPlatPts.at(k).push_back(tmpPlatPt);
// 					vFitPts.push_back(tmpPlatPt);
// 					strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 					strInfo += strTmp;
// 					for (int i=3;i<5;i++)
// 					{
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 					}
// 					/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 					vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 					vNums.push_back(3);
// 					AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 				}
// 				break;
// 			case ePlatformYD:
// 				{
// 					strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 					CString strTmp;
// 					tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(0).m_dPosX);
// 					tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(0).m_dPosY);
// 					tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 					tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 					//PosPlatPts.at(k).push_back(tmpPlatPt);
// 					vFitPts.push_back(tmpPlatPt);
// 					strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 					strInfo += strTmp;
// 					for (int i=3;i<5;i++)
// 					{
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 					}
// 					/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 					vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 					vNums.push_back(3);
// 					AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 				}
// 				break;
// 			case ePlatformXDPY:
// 				{
// 					strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 					CString strTmp;
// 					tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(0).m_dPosX);
// 					tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(0).m_dPosY);
// 					tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 					tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 					//PosPlatPts.at(k).push_back(tmpPlatPt);
// 					vFitPts.push_back(tmpPlatPt);
// 					strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 					strInfo += strTmp;
// 					for (int i=3;i<5;i++)
// 					{
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 					}
// 					/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 					vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 					vNums.push_back(3);
// 					AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 				}
// 				break;
// 			case ePlatformXDPY1:
// 				{
// 					strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 					CString strTmp;
// 					tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(0).m_dPosX);
// 					tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(0).m_dPosY);
// 					tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 					tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 					//PosPlatPts.at(k).push_back(tmpPlatPt);
// 					vFitPts.push_back(tmpPlatPt);
// 					strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 					strInfo += strTmp;
// 					for (int i=3;i<5;i++)
// 					{
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 					}
// 					/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 					vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 					vNums.push_back(3);
// 					AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 				}
// 				break;
// 			default:
// 				{
// 					if(m_bPlatformPick )
// 					{
// 						if (bPickDiffPosSameCalib && k!=0)
// 						{
// 							continue;
// 						}
// 						if (m_ePickCamPlatformType == ePickCamPlatformShareXY)
// 						{
// 							strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 							CString strTmp;
// 							tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(10).m_dPosX);
// 							tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(10).m_dPosY);
// 							tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 							tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 							//PosPlatPts.at(k).push_back(tmpPlatPt);
// 							vFitPts.push_back(tmpPlatPt);
// 							strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 							strInfo += strTmp;
// 							for (int i=11;i<13;i++)
// 							{
// 								tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 								tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 								tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 								tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 								//PosPlatPts.at(k).push_back(tmpPlatPt);
// 								vFitPts.push_back(tmpPlatPt);
// 								strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 								strInfo += strTmp;
// 							}
// 							/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 							vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 							vNums.push_back(3);
// 							AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 						}
// 						else
// 						{
// 							strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 							CString strTmp;
// 							tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(11).m_dPosX);
// 							tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(11).m_dPosY);
// 							tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 							tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 							//PosPlatPts.at(k).push_back(tmpPlatPt);
// 							vFitPts.push_back(tmpPlatPt);
// 							strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 							strInfo += strTmp;
// 							for (int i=9;i<11;i++)
// 							{
// 								tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 								tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 								tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 								tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 								//PosPlatPts.at(k).push_back(tmpPlatPt);
// 								vFitPts.push_back(tmpPlatPt);
// 								strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 								strInfo += strTmp;
// 							}
// 							/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 							vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 							vNums.push_back(3);
// 							AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 						}
// 						
// 					}
// 					else
// 					{
// 						strInfo.Format(_T("位置%d旋转图像坐标-相对平台坐标："),k+m_iMarkNum*nExProductIdx);
// 						CString strTmp;
// 						tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(11).m_dPosX);
// 						tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(11).m_dPosY);
// 						tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 						tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 						//PosPlatPts.at(k).push_back(tmpPlatPt);
// 						vFitPts.push_back(tmpPlatPt);
// 						strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 						strInfo += strTmp;
// 						for (int i=9;i<11;i++)
// 						{
// 							tmpImgPt.SetX(m_vCalibPlatformMoveResults[k].at(i).m_dPosX);
// 							tmpImgPt.SetY(m_vCalibPlatformMoveResults[k].at(i).m_dPosY);
// 							tmpBoardPt = sfHomographyProject(tmpImgPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH1);
// 							tmpPlatPt = sfHomographyProject(tmpBoardPt,m_vCalibratedInfos.at(k+m_iMarkNum*nExProductIdx)->m_PlatformTranferH2);
// 							//PosPlatPts.at(k).push_back(tmpPlatPt);
// 							vFitPts.push_back(tmpPlatPt);
// 							strTmp.Format(_T(" (%.3f,%.3f)-(%.3f,%.3f)"),tmpImgPt.GetX(),tmpImgPt.GetY(),tmpPlatPt.GetX(),tmpPlatPt.GetY());
// 							strInfo += strTmp;
// 						}
// 						/*vFitPts.insert(vFitPts.end(),PosPlatPts.at(k).begin(),PosPlatPts.at(k).end());
// 						vNums.insert(vNums.end(),PosPlatPts.at(k).size());*/
// 						vNums.push_back(3);
// 						AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 					}
// 					
// 				}
// 				break;
// 			}
// 		}
// 	}
// 
// 	//旋转中心标定
// 	sc2Vector center;
// 	double dMaxRms;
// 	if (!sfGetRotationCenter(vFitPts,vNums,center,dMaxRms))
// 	{
// 		return FALSE;
// 	}
// 
// 	strInfo.Format(_T("基准中心平台坐标：(%.4f,%.4f)"),-center.GetX(),-center.GetY());
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	if (m_bTargetObjectCamSeparate)
// 	{
// 		if (m_eMidPlatformType == ePlatformXYPD)
// 		{
// 			for (int i=m_iMarkNum/2;i<m_iMarkNum;i++)
// 			{
// 				m_vCalibratedInfos.at(i+m_iMarkNum*nExProductIdx)->SetMarkPlatformCoordPos(CCoordPos(-center.GetX(),-center.GetY(),0));
// 				m_vCalibratedInfos.at(i+m_iMarkNum*nExProductIdx)->SetValid(TRUE);
// 			}
// 		}
// 		else
// 		{
// 			for (int i=0;i<m_iMarkNum/2;i++)
// 			{
// 				m_vCalibratedInfos.at(i+m_iMarkNum*nExProductIdx)->SetMarkPlatformCoordPos(CCoordPos(-center.GetX(),-center.GetY(),0));
// 				m_vCalibratedInfos.at(i+m_iMarkNum*nExProductIdx)->SetValid(TRUE);
// 			}
// 		}
// 		
// 	}
// 	else
// 	{
// 		{
// 			for (int i=0;i<m_iMarkNum;i++)
// 			{
// 				m_vCalibratedInfos.at(i+m_iMarkNum*nExProductIdx)->SetMarkPlatformCoordPos(CCoordPos(-center.GetX(),-center.GetY(),0));
// 				m_vCalibratedInfos.at(i+m_iMarkNum*nExProductIdx)->SetValid(TRUE);
// 			}
// 		}
// 	}
// 	strInfo.Format(_T("全局二维码靶标标定图像到靶标映射计算结束--------------"));
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return TRUE;
// }

// 全局二维码标定时XYD平台靶标到平台坐标映射
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamWholeDmCodeBoardBoardToPlat(int nExProductIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	

	CString strInfo;
	CString strTemp;
	strInfo.Format(_T("XYD平台全局二维码靶标标定:靶标到平台映射计算开始--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);


	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	std::vector<sc2Vector> vPlatMove;
	std::vector<sc2Vector> vBoardMark;

	int nMarkNum = m_iMarkNum;
	if (m_bTargetObjectCamSeparate)
	{
		nMarkNum = m_iMarkNum/2;
	}
	else
	{
		nMarkNum = m_iMarkNum;
	}

	for (int k = 0; k < nMarkNum; k++)
	{
		strInfo.Empty();
		strTemp.Empty();

		int nRemCamIndex = k % m_iMarkNum;

		// 平台移动量
		double dPosX = m_vpCalibrateParam[nRemCamIndex]->m_dPlatformCalibMovement.GetPosX();
		double dPosY = m_vpCalibrateParam[nRemCamIndex]->m_dPlatformCalibMovement.GetPosY();
		vPlatMove.push_back(sc2Vector(0, 0));
		vPlatMove.push_back(sc2Vector(+dPosX, +dPosY));
		vPlatMove.push_back(sc2Vector(+dPosX, 0));
		vPlatMove.push_back(sc2Vector(+dPosX, -dPosY));
		vPlatMove.push_back(sc2Vector(0, -dPosY));
		vPlatMove.push_back(sc2Vector(-dPosX, -dPosY));
		vPlatMove.push_back(sc2Vector(-dPosX, 0));
		vPlatMove.push_back(sc2Vector(-dPosX, +dPosY));
		vPlatMove.push_back(sc2Vector(0, +dPosY));

		// 二维码图像移动量
		sc2Vector BoardMark[11];
		for (int i = 0; i < 9; i++)
		{
			strInfo.Empty();
			strTemp.Empty();

			sc2Vector MarkImagePos;

			MarkImagePos.SetX(m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX);
			MarkImagePos.SetY(m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY);

			BoardMark[i] = sfHomographyProject(MarkImagePos, m_vCalibratedInfos.at(k + m_iMarkNum * nExProductIndex)->m_PlatformTranferH1);

			strTemp.Format(_T("相机%d-标定走位%d-二维码图像坐标-二维码平台坐标 (%.3f,%.3f)-(%.3f,%.3f) "), k + m_iMarkNum * nExProductIndex, i, MarkImagePos.GetX(),MarkImagePos.GetY(), BoardMark[i].GetX(),BoardMark[i].GetY());
			strInfo += strTemp;

			AlignToolLogRecord(strInfo,m_nPlatformIndex);
		}


		for(int j = 0; j < 9; j++)
		{		
			vBoardMark.push_back(BoardMark[j] - BoardMark[0]);
		}
	}


	// 1. 靶标到平台坐标映射矩阵h2，所有相机公用一个h2
	double h2[9];
	memset(h2, 0.0, sizeof(double)*9);
	if(!sfGetHomography(vBoardMark,vPlatMove,h2, eScaleRotate))
	{
		return FALSE;
	}

	strInfo.Empty();
	strTemp.Empty();

	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
	for (int i=0;i<9;i++)
	{
		strTemp.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
		strInfo = strInfo + strTemp;
	}
	AlignToolLogRecord(strInfo,m_nPlatformIndex);


	// 2. 靶标到平台坐标映射矩阵h2误差
	double dis = 0 ;
	CCoordPos errorOffset;
	svStd vector<sc2Vector> vOffset;
	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
	{
		return FALSE;
	}
	errorOffset.m_dPosX = dis;
	errorOffset.m_dPosY = dis;

	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
	AlignToolLogRecord(strInfo,m_nPlatformIndex);


	// 3. 标定结果汇总记录
	for (int i = 0; i < nMarkNum; i++)
	{
		if (m_vAlignerCalibInfos[i + m_iMarkNum * nExProductIndex] == NULL)
		{
			m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}

		double h1[9];
		memset(h1, 0.0, sizeof(double)*9);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->GetPlatformTransferH1(h1);


		// 相机到平台转换矩阵
		double h[9];
		memset(h, 0.0, sizeof(double)*9);
		h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
		h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
		h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];

		h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
		h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
		h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];

		h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
		h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
		h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];

		// 日志记录
		strInfo.Empty();
		strTemp.Empty();
		strInfo.Format(_T("相机%d图像到平台坐标映射矩阵:"), i);
		for (int n = 0; n < 9; n++)
		{
			strTemp.Format(_T(" h[%d]:%.6f"), n, h[n]);
			strInfo = strInfo + strTemp;
		}
		AlignToolLogRecord(strInfo,m_nPlatformIndex);


		int nRemCamIndex = i % m_iMarkNum;

		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH(h);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkImgCoordPos(CCoordPos());
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH2(h2);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);

		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH(h);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkImgCoordPos(CCoordPos());
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH2(h2);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);


		for (int m=0; m<CALIBMOVEPOSNUM; m++)
		{
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
		}

	}


	strInfo.Format(_T("XYD平台全局二维码靶标标定:靶标到平台映射计算结束--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	return  TRUE;
}

// BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamWholeDmCodeBoardBoardToPlat(int nCamIndex)
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}	
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定,靶标到平台映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	//$ 1.0 计算转换矩阵
// 
// 	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
// 	//	double dX1,dX2,dY1,dY2;//平台坐标偏移量
// 	//	double dx1,dy1,dx2,dy2;//图像坐标偏移量
// 	//	double A[4][4];	    // 4维矩阵,图像坐标矩阵
// 	//	double dA11, dA12, dA21, dA22;//转换矩阵
// 	//	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	//获取该相机对应的图像坐标
// 
// 	double MarkdX[11],MarkdY[11];
// 	double BoardMarkX[11],BoardMarkY[11];
// 	sc2Vector boardMark;
// 	sc2Vector imgMark;
// 	int i=0;
// 	for (i=0; i<11; i++)
// 	{
// 		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
// 		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
// 		imgMark.SetX(MarkdX[i]);
// 		imgMark.SetY(MarkdY[i]);
// 		boardMark = sfHomographyProject(imgMark,m_vCalibratedInfos.at(nCamIndex)->m_PlatformTranferH1);
// 		BoardMarkX[i] = boardMark.GetX();
// 		BoardMarkY[i] = boardMark.GetY();
// 	}
// 
// 	strInfo.Format(_T("位置%d图像坐标："),nCamIndex);
// 	CString strTmpInfo;
// 	for (i=0;i<11;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),MarkdX[i],MarkdY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	strInfo.Format(_T("位置%d靶标坐标："),nCamIndex);
// 	for (i=0;i<11;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),BoardMarkX[i],BoardMarkY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 
// 	std::vector<sc2Vector> vBoardMark;
// 	for(i = 0; i < 9; i++)
// 	{		
// 		vBoardMark.push_back(sc2Vector(BoardMarkX[i], BoardMarkY[i])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	}
// 
// 	//平台平面坐标
// 	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
// 	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
// 	std::vector<sc2Vector> vPlatMove;
// 	vPlatMove.push_back(sc2Vector(0, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, +dPosY));
// 	vPlatMove.push_back(sc2Vector(+dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, -dPosY));
// 	vPlatMove.push_back(sc2Vector(0, -dPosY));
// 	vPlatMove.push_back(sc2Vector(-dPosX, -dPosY));
// 	vPlatMove.push_back(sc2Vector(-dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(-dPosX, +dPosY));
// 	vPlatMove.push_back(sc2Vector(0, +dPosY));
// 
// 	// 计算H变换矩阵
// 	double h2[9];
// 	memset(h2, 0.0, sizeof(double)*9);
// 	if (m_bPlatformPick)
// 	{
// 		CString strh;
// 		HomographyDOF dof = GetHomographyDOF();
// //		HomographyDOF dof = m_CalibrateParam->GetHomographyDOF();
// 		switch(dof)
// 		{
// 		case eAuto:
// 			strh="eAuto";
// 			break;
// 		case eScaleRotate:
// 			strh="eScaleRotate";
// 			break;
// 		case eScaleXYRotateXY:
// 			strh="eScaleXYRotateXY";
// 			break;
// 		case eProject:
// 			strh="eProject";
// 			break;
// 		default:
// 			dof =eAuto;
// 			strh="WrongParam , turn to eAuto";
// 			break;
// 		}
// 		strh=_T("当前标定H矩阵算法为:")+strh;
// 		AlignToolLogRecord(strh,m_nPlatformIndex);
// 
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2,dof))
// 		{
// 			return FALSE;
// 		}
// 	}
// 	else
// 	{
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 
// 	double dis = 0 ;
// 	CCoordPos errorOffset;
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);
// 
// 	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//记录变换结果
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH2(h2);
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 	m_vAlignerCalibInfos.at(nCamIndex)->GetPlatformTransferH1(h1);
// 
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
// 	h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
// 	h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];
// 
// 	h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
// 	h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
// 	h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];
// 
// 	h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
// 	h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
// 	h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];
// 
// 	strInfo.Format(_T("图像到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
// 	
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
// 
// 
// 	//把十个位置的图像坐标保存
// 	for (int m=0; m<CALIBMOVEPOSNUM; m++)
// 	{
// 		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
// 		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
// 	}
// 
// 
// 	//$3.0、计算图像坐标与平台坐标之间的夹角
// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
// 	//m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return  TRUE;
// }

// 全局二维码标定时XD平台靶标到平台坐标映射
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXDWholeDmCodeBoardBoardToPlat(int nExProductIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	

	CString strInfo;
	CString strTemp;
	strInfo.Format(_T("XD平台全局二维码靶标标定:靶标到平台映射计算开始--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}


	std::vector<sc2Vector> vPlatMove;
	std::vector<sc2Vector> vBoardMark;

	int nMarkNum = m_iMarkNum;
	if (m_bTargetObjectCamSeparate)
	{
		nMarkNum = m_iMarkNum/2;
	}
	else
	{
		nMarkNum = m_iMarkNum;
	}


	for (int k = 0; k < nMarkNum; k++)
	{
		strInfo.Empty();
		strTemp.Empty();

		int nRemCamIndex = k % m_iMarkNum;

		// 平台移动量
		double dPosX = m_vpCalibrateParam[nRemCamIndex]->m_dPlatformCalibMovement.GetPosX();
		double dPosY = m_vpCalibrateParam[nRemCamIndex]->m_dPlatformCalibMovement.GetPosY();
		vPlatMove.push_back(sc2Vector(0, 0));
		vPlatMove.push_back(sc2Vector(+dPosX, 0));

		// 二维码图像移动量
		sc2Vector BoardMark[11];
		for (int i = 0; i < 5; i++)
		{
			strInfo.Empty();
			strTemp.Empty();

			sc2Vector MarkImagePos;

			MarkImagePos.SetX(m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX);
			MarkImagePos.SetY(m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY);

			BoardMark[i] = sfHomographyProject(MarkImagePos, m_vCalibratedInfos.at(k + m_iMarkNum * nExProductIndex)->m_PlatformTranferH1);

			strTemp.Format(_T("相机%d-标定走位%d-二维码图像坐标-二维码平台坐标 (%.3f,%.3f)-(%.3f,%.3f) "), k + m_iMarkNum * nExProductIndex, i, MarkImagePos.GetX(),MarkImagePos.GetY(), BoardMark[i].GetX(),BoardMark[i].GetY());
			strInfo += strTemp;

			AlignToolLogRecord(strInfo,m_nPlatformIndex);
		}


		for(int j = 0; j < 2; j++)
		{		
			vBoardMark.push_back(BoardMark[j] - BoardMark[0]);
		}

	}


	// 1. 靶标到平台坐标映射矩阵h2，所有相机公用一个h2
	double h2[9];
	memset(h2, 0.0, sizeof(double)*9);
	if(!sfGetHomography(vBoardMark,vPlatMove,h2, eScaleRotate))
	{
		return FALSE;
	}

	strInfo.Empty();
	strTemp.Empty();

	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
	for (int i=0;i<9;i++)
	{
		strTemp.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
		strInfo = strInfo + strTemp;
	}
	AlignToolLogRecord(strInfo,m_nPlatformIndex);


	// 2. 靶标到平台坐标映射矩阵h2误差
	double dis = 0 ;
	CCoordPos errorOffset;
	svStd vector<sc2Vector> vOffset;
	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
	{
		return FALSE;
	}
	errorOffset.m_dPosX = dis;
	errorOffset.m_dPosY = dis;

	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	// 3. 标定结果汇总记录
	for (int i = 0; i < nMarkNum; i++)
	{
		if (m_vAlignerCalibInfos[i + m_iMarkNum * nExProductIndex] == NULL)
		{
			m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}

		double h1[9];
		memset(h1, 0.0, sizeof(double)*9);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->GetPlatformTransferH1(h1);

		// 相机到平台转换矩阵
		double h[9];
		memset(h, 0.0, sizeof(double)*9);
		h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
		h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
		h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];

		h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
		h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
		h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];

		h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
		h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
		h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];

		// 日志记录
		strInfo.Empty();
		strTemp.Empty();
		strInfo.Format(_T("相机%d图像到平台坐标映射矩阵:"), i);
		for (int n = 0; n < 9; n++)
		{
			strTemp.Format(_T(" h[%d]:%.6f"), n, h[n]);
			strInfo = strInfo + strTemp;
		}
		AlignToolLogRecord(strInfo,m_nPlatformIndex);


		int nRemCamIndex = i % m_iMarkNum;

		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH(h);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkImgCoordPos(CCoordPos());
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH2(h2);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);

		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH(h);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkImgCoordPos(CCoordPos());
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH2(h2);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);


		for (int m = 0; m < 6; m++)
		{
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
		}

	}


	strInfo.Format(_T("XD平台全局二维码靶标标定:靶标到平台映射计算结束--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	return  TRUE;

}
// BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXDWholeDmCodeBoardBoardToPlat(int nCamIndex)//全局二维码标定时XD平台靶标到平台坐标映射
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}	
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	//$ 1.0 计算转换矩阵
// 
// 	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
// 	//	double dX1,dX2,dY1,dY2;//平台坐标偏移量
// 	//	double dx1,dy1,dx2,dy2;//图像坐标偏移量
// 	//	double A[4][4];	    // 4维矩阵,图像坐标矩阵
// 	//	double dA11, dA12, dA21, dA22;//转换矩阵
// 	//	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	//获取该相机对应的图像坐标
// 
// 	double MarkdX[5],MarkdY[5];
// 	double BoardMarkX[5],BoardMarkY[5];
// 	sc2Vector boardMark;
// 	sc2Vector imgMark;
// 	int i=0;
// 	for (i=0; i<5; i++)
// 	{
// 		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
// 		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
// 		imgMark.SetX(MarkdX[i]);
// 		imgMark.SetY(MarkdY[i]);
// 		boardMark = sfHomographyProject(imgMark,m_vCalibratedInfos.at(nCamIndex)->m_PlatformTranferH1);
// 		BoardMarkX[i] = boardMark.GetX();
// 		BoardMarkY[i] = boardMark.GetY();
// 	}
// 
// 	strInfo.Format(_T("位置%d图像坐标："),nCamIndex);
// 	CString strTmpInfo;
// 	for (i=0;i<5;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),MarkdX[i],MarkdY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	strInfo.Format(_T("位置%d靶标坐标："),nCamIndex);
// 	for (i=0;i<5;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),BoardMarkX[i],BoardMarkY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 
// 	std::vector<sc2Vector> vBoardMark;
// 	for(i = 0; i < 2; i++)
// 	{		
// 		vBoardMark.push_back(sc2Vector(BoardMarkX[i], BoardMarkY[i])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	}
// 
// 	//平台平面坐标
// 	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
// 	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
// 	std::vector<sc2Vector> vPlatMove;
// 	vPlatMove.push_back(sc2Vector(0, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, 0));
// 
// 	// 计算H变换矩阵
// 	double h2[9];
// 	memset(h2, 0.0, sizeof(double)*9);
// 	//if (m_bPlatformPick)
// 	//{
// 	//	CString strh;
// 	//	HomographyDOF dof = GetHomographyDOF();
// 	//	switch(dof)
// 	//	{
// 	//	case eAuto:
// 	//		strh="eAuto";
// 	//		break;
// 	//	case eScaleRotate:
// 	//		strh="eScaleRotate";
// 	//		break;
// 	//	case eScaleXYRotateXY:
// 	//		strh="eScaleXYRotateXY";
// 	//		break;
// 	//	case eProject:
// 	//		strh="eProject";
// 	//		break;
// 	//	default:
// 	//		dof =eAuto;
// 	//		strh="WrongParam , turn to eAuto";
// 	//		break;
// 	//	}
// 	//	strh=_T("当前标定H矩阵算法为:")+strh;
// 	//	AlignToolLogRecord(strh,m_nPlatformIndex);
// 
// 	//	if(!sfGetHomography(vBoardMark,vPlatMove,h2,dof))
// 	//	{
// 	//		return FALSE;
// 	//	}
// 	//}
// 	//else
// 	{
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2,eScaleRotate))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	double dis = 0 ;
// 
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	CCoordPos errorOffset;
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);
// 	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//记录变换结果
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH2(h2);
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 	m_vAlignerCalibInfos.at(nCamIndex)->GetPlatformTransferH1(h1);
// 
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
// 	h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
// 	h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];
// 
// 	h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
// 	h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
// 	h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];
// 
// 	h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
// 	h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
// 	h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];
// 
// 	strInfo.Format(_T("图像到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
// 
// 
// 	////把十个位置的图像坐标保存
// 	//for (int m=0; m<CALIBMOVEPOSNUM; m++)
// 	//{
// 	//	m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
// 	//	m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
// 	//}
// 
// 
// 	//$3.0、计算图像坐标与平台坐标之间的夹角
// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
// 	//m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return  TRUE;
// }

// 全局二维码标定时YD平台靶标到平台坐标映射
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamYDWholeDmCodeBoardBoardToPlat(int nExProductIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	

	CString strInfo;
	CString strTemp;
	strInfo.Format(_T("YD平台全局二维码靶标标定:靶标到平台映射计算开始--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}


	std::vector<sc2Vector> vPlatMove;
	std::vector<sc2Vector> vBoardMark;

	int nMarkNum = m_iMarkNum;
	if (m_bTargetObjectCamSeparate)
	{
		nMarkNum = m_iMarkNum/2;
	}
	else
	{
		nMarkNum = m_iMarkNum;
	}

	for (int k = 0; k < nMarkNum; k++)
	{
		strInfo.Empty();
		strTemp.Empty();

		int nRemCamIndex = k % m_iMarkNum;

		// 平台移动量
		double dPosX = m_vpCalibrateParam[nRemCamIndex]->m_dPlatformCalibMovement.GetPosX();
		double dPosY = m_vpCalibrateParam[nRemCamIndex]->m_dPlatformCalibMovement.GetPosY();
		vPlatMove.push_back(sc2Vector(0, 0));
		vPlatMove.push_back(sc2Vector(0, +dPosY));

		// 二维码图像移动量
		sc2Vector BoardMark[11];
		for (int i = 0; i < 5; i++)
		{
			strInfo.Empty();
			strTemp.Empty();

			sc2Vector MarkImagePos;

			MarkImagePos.SetX(m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX);
			MarkImagePos.SetY(m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY);

			BoardMark[i] = sfHomographyProject(MarkImagePos, m_vCalibratedInfos.at(k + m_iMarkNum * nExProductIndex)->m_PlatformTranferH1);

			strTemp.Format(_T("相机%d-标定位置%d-二维码图像坐标-二维码平台坐标 (%.3f,%.3f)-(%.3f,%.3f) "), k + m_iMarkNum * nExProductIndex, i, MarkImagePos.GetX(),MarkImagePos.GetY(), BoardMark[i].GetX(),BoardMark[i].GetY());
			strInfo += strTemp;

			AlignToolLogRecord(strInfo,m_nPlatformIndex);
		}


		for(int j = 0; j < 2; j++)
		{		
			vBoardMark.push_back(BoardMark[j] - BoardMark[0]);
		}
	}


	// 1. 靶标到平台坐标映射矩阵h2，所有相机公用一个h2
	double h2[9];
	memset(h2, 0.0, sizeof(double)*9);
	if(!sfGetHomography(vBoardMark,vPlatMove,h2, eScaleRotate))
	{
		return FALSE;
	}

	strInfo.Empty();
	strTemp.Empty();

	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
	for (int i=0;i<9;i++)
	{
		strTemp.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
		strInfo = strInfo + strTemp;
	}
	AlignToolLogRecord(strInfo,m_nPlatformIndex);


	// 2. 靶标到平台坐标映射矩阵h2误差
	double dis = 0 ;
	CCoordPos errorOffset;
	svStd vector<sc2Vector> vOffset;
	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
	{
		return FALSE;
	}
	errorOffset.m_dPosX = dis;
	errorOffset.m_dPosY = dis;

	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	// 3. 标定结果汇总记录
	for (int i = 0; i < nMarkNum; i++)
	{
		if (m_vAlignerCalibInfos[i + m_iMarkNum * nExProductIndex] == NULL)
		{
			m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}

		double h1[9];
		memset(h1, 0.0, sizeof(double)*9);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->GetPlatformTransferH1(h1);

		// 相机到平台转换矩阵
		double h[9];
		memset(h, 0.0, sizeof(double)*9);
		h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
		h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
		h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];

		h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
		h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
		h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];

		h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
		h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
		h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];

		// 日志记录
		strInfo.Empty();
		strTemp.Empty();
		strInfo.Format(_T("相机%d图像到平台坐标映射矩阵:"), i);
		for (int n = 0; n < 9; n++)
		{
			strTemp.Format(_T(" h[%d]:%.6f"), n, h[n]);
			strInfo = strInfo + strTemp;
		}
		AlignToolLogRecord(strInfo,m_nPlatformIndex);


		int nRemCamIndex = i % m_iMarkNum;

		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH(h);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkImgCoordPos(CCoordPos());
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH2(h2);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);

		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH(h);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkImgCoordPos(CCoordPos());
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH2(h2);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);


		for (int m = 0; m < 6; m++)
		{
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
		}

	}

	strInfo.Format(_T("YD平台全局二维码靶标标定:靶标到平台映射计算结束--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	return  TRUE;

}

// BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamYDWholeDmCodeBoardBoardToPlat(int nCamIndex)//全局二维码标定时YD平台靶标到平台坐标映射
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}	
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	//$ 1.0 计算转换矩阵
// 
// 	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
// 	//	double dX1,dX2,dY1,dY2;//平台坐标偏移量
// 	//	double dx1,dy1,dx2,dy2;//图像坐标偏移量
// 	//	double A[4][4];	    // 4维矩阵,图像坐标矩阵
// 	//	double dA11, dA12, dA21, dA22;//转换矩阵
// 	//	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	//获取该相机对应的图像坐标
// 
// 	double MarkdX[5],MarkdY[5];
// 	double BoardMarkX[5],BoardMarkY[5];
// 	sc2Vector boardMark;
// 	sc2Vector imgMark;
// 	int i=0;
// 	for (i=0; i<5; i++)
// 	{
// 		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
// 		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
// 		imgMark.SetX(MarkdX[i]);
// 		imgMark.SetY(MarkdY[i]);
// 		boardMark = sfHomographyProject(imgMark,m_vCalibratedInfos.at(nCamIndex)->m_PlatformTranferH1);
// 		BoardMarkX[i] = boardMark.GetX();
// 		BoardMarkY[i] = boardMark.GetY();
// 	}
// 
// 	strInfo.Format(_T("位置%d图像坐标："),nCamIndex);
// 	CString strTmpInfo;
// 	for (i=0;i<5;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),MarkdX[i],MarkdY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	strInfo.Format(_T("位置%d靶标坐标："),nCamIndex);
// 	for (i=0;i<5;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),BoardMarkX[i],BoardMarkY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 
// 	std::vector<sc2Vector> vBoardMark;
// 	for(i = 0; i < 2; i++)
// 	{		
// 		vBoardMark.push_back(sc2Vector(BoardMarkX[i], BoardMarkY[i])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	}
// 
// 	//平台平面坐标
// 	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
// 	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
// 	std::vector<sc2Vector> vPlatMove;
// 	vPlatMove.push_back(sc2Vector(0, 0));
// 	vPlatMove.push_back(sc2Vector(0, +dPosY));
// 
// 	// 计算H变换矩阵
// 	double h2[9];
// 	memset(h2, 0.0, sizeof(double)*9);
// 	//if (m_bPlatformPick)
// 	//{
// 	//	CString strh;
// 	//	HomographyDOF dof = GetHomographyDOF();
// 	//	switch(dof)
// 	//	{
// 	//	case eAuto:
// 	//		strh="eAuto";
// 	//		break;
// 	//	case eScaleRotate:
// 	//		strh="eScaleRotate";
// 	//		break;
// 	//	case eScaleXYRotateXY:
// 	//		strh="eScaleXYRotateXY";
// 	//		break;
// 	//	case eProject:
// 	//		strh="eProject";
// 	//		break;
// 	//	default:
// 	//		dof =eAuto;
// 	//		strh="WrongParam , turn to eAuto";
// 	//		break;
// 	//	}
// 	//	strh=_T("当前标定H矩阵算法为:")+strh;
// 	//	AlignToolLogRecord(strh,m_nPlatformIndex);
// 
// 	//	if(!sfGetHomography(vBoardMark,vPlatMove,h2,dof))
// 	//	{
// 	//		return FALSE;
// 	//	}
// 	//}
// 	//else
// 	{
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2,eScaleRotate))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	double dis = 0 ;
// 
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	CCoordPos errorOffset;
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);
// 	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//记录变换结果
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH2(h2);
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 	m_vAlignerCalibInfos.at(nCamIndex)->GetPlatformTransferH1(h1);
// 
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
// 	h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
// 	h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];
// 
// 	h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
// 	h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
// 	h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];
// 
// 	h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
// 	h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
// 	h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];
// 
// 	strInfo.Format(_T("图像到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
// 
// 
// 	////把十个位置的图像坐标保存
// 	//for (int m=0; m<CALIBMOVEPOSNUM; m++)
// 	//{
// 	//	m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
// 	//	m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
// 	//}
// 
// 
// 	//$3.0、计算图像坐标与平台坐标之间的夹角
// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
// 	//m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return  TRUE;
// }

// BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXYWholeDmCodeBoardBoardToPlat(int nCamIndex)//全局二维码标定时XY平台靶标到平台坐标映射
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}	
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	//$ 1.0 计算转换矩阵
// 
// 	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
// 	//	double dX1,dX2,dY1,dY2;//平台坐标偏移量
// 	//	double dx1,dy1,dx2,dy2;//图像坐标偏移量
// 	//	double A[4][4];	    // 4维矩阵,图像坐标矩阵
// 	//	double dA11, dA12, dA21, dA22;//转换矩阵
// 	//	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	//获取该相机对应的图像坐标
// 
// 	double MarkdX[10],MarkdY[10];
// 	double BoardMarkX[10],BoardMarkY[10];
// 	sc2Vector boardMark;
// 	sc2Vector imgMark;
// 	int i=0;
// 	for (i=0; i<10; i++)
// 	{
// 		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
// 		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
// 		imgMark.SetX(MarkdX[i]);
// 		imgMark.SetY(MarkdY[i]);
// 		boardMark = sfHomographyProject(imgMark,m_vCalibratedInfos.at(nCamIndex)->m_PlatformTranferH1);
// 		BoardMarkX[i] = boardMark.GetX();
// 		BoardMarkY[i] = boardMark.GetY();
// 	}
// 
// 	strInfo.Format(_T("位置%d图像坐标："),nCamIndex);
// 	CString strTmpInfo;
// 	for (i=0;i<10;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),MarkdX[i],MarkdY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	strInfo.Format(_T("位置%d靶标坐标："),nCamIndex);
// 	for (i=0;i<10;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),BoardMarkX[i],BoardMarkY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 
// 	std::vector<sc2Vector> vBoardMark;
// 	for(i = 0; i < 9; i++)
// 	{		
// 		vBoardMark.push_back(sc2Vector(BoardMarkX[i], BoardMarkY[i])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	}
// 
// 	//平台平面坐标
// 	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
// 	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
// 	std::vector<sc2Vector> vPlatMove;
// 	vPlatMove.push_back(sc2Vector(0, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, +dPosY));
// 	vPlatMove.push_back(sc2Vector(+dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, -dPosY));
// 	vPlatMove.push_back(sc2Vector(0, -dPosY));
// 	vPlatMove.push_back(sc2Vector(-dPosX, -dPosY));
// 	vPlatMove.push_back(sc2Vector(-dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(-dPosX, +dPosY));
// 	vPlatMove.push_back(sc2Vector(0, +dPosY));
// 
// 	// 计算H变换矩阵
// 	double h2[9];
// 	memset(h2, 0.0, sizeof(double)*9);
// 	//if (m_bPlatformPick)
// 	//{
// 	//	CString strh;
// 	//	HomographyDOF dof = GetHomographyDOF();
// 	//	switch(dof)
// 	//	{
// 	//	case eAuto:
// 	//		strh="eAuto";
// 	//		break;
// 	//	case eScaleRotate:
// 	//		strh="eScaleRotate";
// 	//		break;
// 	//	case eScaleXYRotateXY:
// 	//		strh="eScaleXYRotateXY";
// 	//		break;
// 	//	case eProject:
// 	//		strh="eProject";
// 	//		break;
// 	//	default:
// 	//		dof =eAuto;
// 	//		strh="WrongParam , turn to eAuto";
// 	//		break;
// 	//	}
// 	//	strh=_T("当前标定H矩阵算法为:")+strh;
// 	//	AlignToolLogRecord(strh,m_nPlatformIndex);
// 
// 	//	if(!sfGetHomography(vBoardMark,vPlatMove,h2,dof))
// 	//	{
// 	//		return FALSE;
// 	//	}
// 	//}
// 	//else
// 	{
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	double dis = 0 ;
// 
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	CCoordPos errorOffset;
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);
// 	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//记录变换结果
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH2(h2);
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 	m_vAlignerCalibInfos.at(nCamIndex)->GetPlatformTransferH1(h1);
// 
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
// 	h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
// 	h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];
// 
// 	h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
// 	h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
// 	h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];
// 
// 	h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
// 	h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
// 	h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];
// 
// 	strInfo.Format(_T("图像到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
// 
// 
// 	//把九个位置的图像坐标保存
// 	for (int m=0; m<9; m++)
// 	{
// 		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
// 		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
// 	}
// 
// 
// 	//$3.0、计算图像坐标与平台坐标之间的夹角
// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
// 	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return  TRUE;
// }

// BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXWholeDmCodeBoardBoardToPlat(int nCamIndex)//全局二维码标定时X平台靶标到平台坐标映射
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}	
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	//$ 1.0 计算转换矩阵
// 
// 	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
// 	//	double dX1,dX2,dY1,dY2;//平台坐标偏移量
// 	//	double dx1,dy1,dx2,dy2;//图像坐标偏移量
// 	//	double A[4][4];	    // 4维矩阵,图像坐标矩阵
// 	//	double dA11, dA12, dA21, dA22;//转换矩阵
// 	//	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	//获取该相机对应的图像坐标
// 
// 	double MarkdX[4],MarkdY[4];
// 	double BoardMarkX[4],BoardMarkY[4];
// 	sc2Vector boardMark;
// 	sc2Vector imgMark;
// 	int i=0;
// 	for (i=0; i<4; i++)
// 	{
// 		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
// 		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
// 		imgMark.SetX(MarkdX[i]);
// 		imgMark.SetY(MarkdY[i]);
// 		boardMark = sfHomographyProject(imgMark,m_vCalibratedInfos.at(nCamIndex)->m_PlatformTranferH1);
// 		BoardMarkX[i] = boardMark.GetX();
// 		BoardMarkY[i] = boardMark.GetY();
// 	}
// 
// 	strInfo.Format(_T("位置%d图像坐标："),nCamIndex);
// 	CString strTmpInfo;
// 	for (i=0;i<4;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),MarkdX[i],MarkdY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	strInfo.Format(_T("位置%d靶标坐标："),nCamIndex);
// 	for (i=0;i<4;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),BoardMarkX[i],BoardMarkY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 
// 	std::vector<sc2Vector> vBoardMark;
// 	for(i = 0; i < 2; i++)
// 	{		
// 		vBoardMark.push_back(sc2Vector(BoardMarkX[i], BoardMarkY[i])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	}
// 
// 	//平台平面坐标
// 	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
// 	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
// 	std::vector<sc2Vector> vPlatMove;
// 	vPlatMove.push_back(sc2Vector(0, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, 0));
// 
// 	// 计算H变换矩阵
// 	double h2[9];
// 	memset(h2, 0.0, sizeof(double)*9);
// 	//if (m_bPlatformPick)
// 	//{
// 	//	CString strh;
// 	//	HomographyDOF dof = GetHomographyDOF();
// 	//	switch(dof)
// 	//	{
// 	//	case eAuto:
// 	//		strh="eAuto";
// 	//		break;
// 	//	case eScaleRotate:
// 	//		strh="eScaleRotate";
// 	//		break;
// 	//	case eScaleXYRotateXY:
// 	//		strh="eScaleXYRotateXY";
// 	//		break;
// 	//	case eProject:
// 	//		strh="eProject";
// 	//		break;
// 	//	default:
// 	//		dof =eAuto;
// 	//		strh="WrongParam , turn to eAuto";
// 	//		break;
// 	//	}
// 	//	strh=_T("当前标定H矩阵算法为:")+strh;
// 	//	AlignToolLogRecord(strh,m_nPlatformIndex);
// 
// 	//	if(!sfGetHomography(vBoardMark,vPlatMove,h2,dof))
// 	//	{
// 	//		return FALSE;
// 	//	}
// 	//}
// 	//else
// 	{
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	double dis = 0 ;
// 
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	CCoordPos errorOffset;
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);
// 	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//记录变换结果
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH2(h2);
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 	m_vAlignerCalibInfos.at(nCamIndex)->GetPlatformTransferH1(h1);
// 
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
// 	h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
// 	h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];
// 
// 	h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
// 	h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
// 	h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];
// 
// 	h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
// 	h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
// 	h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];
// 
// 	strInfo.Format(_T("图像到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
// 
// 
// 	//把九个位置的图像坐标保存
// 	for (int m=0; m<4; m++)
// 	{
// 		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
// 		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
// 	}
// 
// 
// 	//$3.0、计算图像坐标与平台坐标之间的夹角
// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
// 	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return  TRUE;
// }

// BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXDPYWholeDmCodeBoardBoardToPlat(int nCamIndex)//全局二维码标定时XDPY平台靶标到平台坐标映射
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}	
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	//$ 1.0 计算转换矩阵
// 
// 	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
// 	//	double dX1,dX2,dY1,dY2;//平台坐标偏移量
// 	//	double dx1,dy1,dx2,dy2;//图像坐标偏移量
// 	//	double A[4][4];	    // 4维矩阵,图像坐标矩阵
// 	//	double dA11, dA12, dA21, dA22;//转换矩阵
// 	//	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	//获取该相机对应的图像坐标
// 
// 	double MarkdX[9],MarkdY[9];
// 	double BoardMarkX[9],BoardMarkY[9];
// 	sc2Vector boardMark;
// 	sc2Vector imgMark;
// 	int i=0;
// 	for (i=0; i<9; i++)
// 	{
// 		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
// 		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
// 		imgMark.SetX(MarkdX[i]);
// 		imgMark.SetY(MarkdY[i]);
// 		boardMark = sfHomographyProject(imgMark,m_vCalibratedInfos.at(nCamIndex)->m_PlatformTranferH1);
// 		BoardMarkX[i] = boardMark.GetX();
// 		BoardMarkY[i] = boardMark.GetY();
// 	}
// 
// 	strInfo.Format(_T("位置%d图像坐标："),nCamIndex);
// 	CString strTmpInfo;
// 	for (i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),MarkdX[i],MarkdY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	strInfo.Format(_T("位置%d靶标坐标："),nCamIndex);
// 	for (i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),BoardMarkX[i],BoardMarkY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 
// 	std::vector<sc2Vector> vBoardMark;
// 	for(i = 0; i < 3; i++)
// 	{		
// 		vBoardMark.push_back(sc2Vector(BoardMarkX[i], BoardMarkY[i])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	}
// 	vBoardMark.push_back(sc2Vector(BoardMarkX[6], BoardMarkY[6])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	vBoardMark.push_back(sc2Vector(BoardMarkX[7], BoardMarkY[7])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 
// 	//平台平面坐标
// 	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
// 	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
// 	std::vector<sc2Vector> vPlatMove;
// 	vPlatMove.push_back(sc2Vector(0, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(-dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(0, +dPosY));
// 	vPlatMove.push_back(sc2Vector(0, -dPosY));
// 
// 	// 计算H变换矩阵
// 	double h2[9];
// 	memset(h2, 0.0, sizeof(double)*9);
// 	//if (m_bPlatformPick)
// 	//{
// 	//	CString strh;
// 	//	HomographyDOF dof = GetHomographyDOF();
// 	//	switch(dof)
// 	//	{
// 	//	case eAuto:
// 	//		strh="eAuto";
// 	//		break;
// 	//	case eScaleRotate:
// 	//		strh="eScaleRotate";
// 	//		break;
// 	//	case eScaleXYRotateXY:
// 	//		strh="eScaleXYRotateXY";
// 	//		break;
// 	//	case eProject:
// 	//		strh="eProject";
// 	//		break;
// 	//	default:
// 	//		dof =eAuto;
// 	//		strh="WrongParam , turn to eAuto";
// 	//		break;
// 	//	}
// 	//	strh=_T("当前标定H矩阵算法为:")+strh;
// 	//	AlignToolLogRecord(strh,m_nPlatformIndex);
// 
// 	//	if(!sfGetHomography(vBoardMark,vPlatMove,h2,dof))
// 	//	{
// 	//		return FALSE;
// 	//	}
// 	//}
// 	//else
// 	{
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2,eScaleRotate))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	double dis = 0 ;
// 
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	CCoordPos errorOffset;
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);
// 	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//记录变换结果
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH2(h2);
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 	m_vAlignerCalibInfos.at(nCamIndex)->GetPlatformTransferH1(h1);
// 
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
// 	h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
// 	h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];
// 
// 	h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
// 	h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
// 	h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];
// 
// 	h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
// 	h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
// 	h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];
// 
// 	strInfo.Format(_T("图像到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
// 
// 
// 	////把十个位置的图像坐标保存
// 	//for (int m=0; m<CALIBMOVEPOSNUM; m++)
// 	//{
// 	//	m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
// 	//	m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
// 	//}
// 
// 
// 	//$3.0、计算图像坐标与平台坐标之间的夹角
// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
// 	//m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return  TRUE;
// }

// BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXDPY1WholeDmCodeBoardBoardToPlat(int nCamIndex)//全局二维码标定时XDPY1平台靶标到平台坐标映射
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}	
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	//$ 1.0 计算转换矩阵
// 
// 	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
// 	//	double dX1,dX2,dY1,dY2;//平台坐标偏移量
// 	//	double dx1,dy1,dx2,dy2;//图像坐标偏移量
// 	//	double A[4][4];	    // 4维矩阵,图像坐标矩阵
// 	//	double dA11, dA12, dA21, dA22;//转换矩阵
// 	//	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	//获取该相机对应的图像坐标
// 
// 	double MarkdX[7],MarkdY[7];
// 	double BoardMarkX[7],BoardMarkY[7];
// 	sc2Vector boardMark;
// 	sc2Vector imgMark;
// 	int i=0;
// 	for (i=0; i<7; i++)
// 	{
// 		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
// 		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
// 		imgMark.SetX(MarkdX[i]);
// 		imgMark.SetY(MarkdY[i]);
// 		boardMark = sfHomographyProject(imgMark,m_vCalibratedInfos.at(nCamIndex)->m_PlatformTranferH1);
// 		BoardMarkX[i] = boardMark.GetX();
// 		BoardMarkY[i] = boardMark.GetY();
// 	}
// 
// 	strInfo.Format(_T("位置%d图像坐标："),nCamIndex);
// 	CString strTmpInfo;
// 	for (i=0;i<7;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),MarkdX[i],MarkdY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	strInfo.Format(_T("位置%d靶标坐标："),nCamIndex);
// 	for (i=0;i<7;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),BoardMarkX[i],BoardMarkY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 
// 	std::vector<sc2Vector> vBoardMark;
// 	for(i = 0; i < 2; i++)
// 	{		
// 		vBoardMark.push_back(sc2Vector(BoardMarkX[i], BoardMarkY[i])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	}
// 	vBoardMark.push_back(sc2Vector(BoardMarkX[6], BoardMarkY[6])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 
// 	//平台平面坐标
// 	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
// 	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
// 	std::vector<sc2Vector> vPlatMove;
// 	vPlatMove.push_back(sc2Vector(0, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(0, +dPosY));
// 
// 	// 计算H变换矩阵
// 	double h2[9];
// 	memset(h2, 0.0, sizeof(double)*9);
// 	//if (m_bPlatformPick)
// 	//{
// 	//	CString strh;
// 	//	HomographyDOF dof = GetHomographyDOF();
// 	//	switch(dof)
// 	//	{
// 	//	case eAuto:
// 	//		strh="eAuto";
// 	//		break;
// 	//	case eScaleRotate:
// 	//		strh="eScaleRotate";
// 	//		break;
// 	//	case eScaleXYRotateXY:
// 	//		strh="eScaleXYRotateXY";
// 	//		break;
// 	//	case eProject:
// 	//		strh="eProject";
// 	//		break;
// 	//	default:
// 	//		dof =eAuto;
// 	//		strh="WrongParam , turn to eAuto";
// 	//		break;
// 	//	}
// 	//	strh=_T("当前标定H矩阵算法为:")+strh;
// 	//	AlignToolLogRecord(strh,m_nPlatformIndex);
// 
// 	//	if(!sfGetHomography(vBoardMark,vPlatMove,h2,dof))
// 	//	{
// 	//		return FALSE;
// 	//	}
// 	//}
// 	//else
// 	{
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2,eScaleRotate))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	double dis = 0 ;
// 
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	CCoordPos errorOffset;
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);
// 	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//记录变换结果
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH2(h2);
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 	m_vAlignerCalibInfos.at(nCamIndex)->GetPlatformTransferH1(h1);
// 
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
// 	h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
// 	h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];
// 
// 	h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
// 	h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
// 	h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];
// 
// 	h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
// 	h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
// 	h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];
// 
// 	strInfo.Format(_T("图像到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
// 
// 
// 	////把十个位置的图像坐标保存
// 	//for (int m=0; m<CALIBMOVEPOSNUM; m++)
// 	//{
// 	//	m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
// 	//	m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
// 	//}
// 
// 
// 	//$3.0、计算图像坐标与平台坐标之间的夹角
// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
// 	//m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return  TRUE;
// }

// 全局二维码标定时XYPD平台靶标到平台坐标映射
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXYPDWholeDmCodeBoardBoardToPlat(int nExProductIndex)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	

	CString strInfo;
	CString strTemp;
	strInfo.Format(_T("XYPD平台全局二维码靶标标定:靶标到平台映射计算开始--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);


	if (m_bEnableMultiCalibExtension == TRUE)
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
			{
				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
				}
				else
				{
					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
					{
						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
					}
					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
				}
			}
		}
	}
	else
	{
		for(int k = 0; k < m_iMarkNum; k++)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k) != NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	std::vector<sc2Vector> vPlatMove;
	std::vector<sc2Vector> vBoardMark;

	int nMarkNum = m_iMarkNum;
	if (m_bTargetObjectCamSeparate)
	{
		nMarkNum = m_iMarkNum/2;
	}
	else
	{
		nMarkNum = m_iMarkNum;
	}

	for (int k = 0; k < nMarkNum; k++)
	{
		strInfo.Empty();
		strTemp.Empty();

		int nRemCamIndex = k % m_iMarkNum;

		// 平台移动量
		double dPosX = m_vpCalibrateParam[nRemCamIndex]->m_dPlatformCalibMovement.GetPosX();
		double dPosY = m_vpCalibrateParam[nRemCamIndex]->m_dPlatformCalibMovement.GetPosY();
		vPlatMove.push_back(sc2Vector(0, 0));
		vPlatMove.push_back(sc2Vector(+dPosX, +dPosY));
		vPlatMove.push_back(sc2Vector(+dPosX, 0));
		vPlatMove.push_back(sc2Vector(+dPosX, -dPosY));
		vPlatMove.push_back(sc2Vector(0, -dPosY));
		vPlatMove.push_back(sc2Vector(-dPosX, -dPosY));
		vPlatMove.push_back(sc2Vector(-dPosX, 0));
		vPlatMove.push_back(sc2Vector(-dPosX, +dPosY));
		vPlatMove.push_back(sc2Vector(0, +dPosY));

		// 二维码图像移动量
		sc2Vector BoardMark[11];
		for (int i = 0; i < 9; i++)
		{
			strInfo.Empty();
			strTemp.Empty();

			sc2Vector MarkImagePos;

			MarkImagePos.SetX(m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX);
			MarkImagePos.SetY(m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY);

			BoardMark[i] = sfHomographyProject(MarkImagePos, m_vCalibratedInfos.at(k + m_iMarkNum * nExProductIndex)->m_PlatformTranferH1);

			strTemp.Format(_T("相机%d-标定走位%d-二维码图像坐标-二维码平台坐标 (%.3f,%.3f)-(%.3f,%.3f) "), k + m_iMarkNum * nExProductIndex, i, MarkImagePos.GetX(),MarkImagePos.GetY(), BoardMark[i].GetX(),BoardMark[i].GetY());
			strInfo += strTemp;

			AlignToolLogRecord(strInfo,m_nPlatformIndex);
		}


		for(int j = 0; j < 9; j++)
		{		
			vBoardMark.push_back(BoardMark[j] - BoardMark[0]);
		}
	}


	// 1. 靶标到平台坐标映射矩阵h2，所有相机公用一个h2
	double h2[9];
	memset(h2, 0.0, sizeof(double)*9);
	if(!sfGetHomography(vBoardMark,vPlatMove,h2, eScaleRotate))
	{
		return FALSE;
	}

	strInfo.Empty();
	strTemp.Empty();

	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
	for (int i=0;i<9;i++)
	{
		strTemp.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
		strInfo = strInfo + strTemp;
	}
	AlignToolLogRecord(strInfo,m_nPlatformIndex);


	// 2. 靶标到平台坐标映射矩阵h2误差
	double dis = 0 ;
	CCoordPos errorOffset;
	svStd vector<sc2Vector> vOffset;
	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
	{
		return FALSE;
	}
	errorOffset.m_dPosX = dis;
	errorOffset.m_dPosY = dis;

	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
	AlignToolLogRecord(strInfo,m_nPlatformIndex);


	// 3. 标定结果汇总记录
	for (int i = 0; i < nMarkNum; i++)
	{
		if (m_vAlignerCalibInfos[i + m_iMarkNum * nExProductIndex] == NULL)
		{
			m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}

		double h1[9];
		memset(h1, 0.0, sizeof(double)*9);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->GetPlatformTransferH1(h1);


		// 相机到平台转换矩阵
		double h[9];
		memset(h, 0.0, sizeof(double)*9);
		h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
		h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
		h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];

		h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
		h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
		h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];

		h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
		h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
		h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];

		// 日志记录
		strInfo.Empty();
		strTemp.Empty();
		strInfo.Format(_T("相机%d图像到平台坐标映射矩阵:"), i);
		for (int n = 0; n < 9; n++)
		{
			strTemp.Format(_T(" h[%d]:%.6f"), n, h[n]);
			strInfo = strInfo + strTemp;
		}
		AlignToolLogRecord(strInfo,m_nPlatformIndex);


		int nRemCamIndex = i % m_iMarkNum;

		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH(h);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkImgCoordPos(CCoordPos());
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH2(h2);
		m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);

		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH(h);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkImgCoordPos(CCoordPos());
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetPlatformTransferH2(h2);
		m_vAlignerCalibInfos.at(i + m_iMarkNum * nExProductIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);


		// 把九个位置的图像坐标保存
		for (int m=0; m<9; m++)
		{
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
		}

		// 把三个位置的图像坐标保存到【9】【10】【11】
		for (int m=9; m<CALIBMOVEPOSNUM; m++)
		{
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m+2).m_dPosX;
			m_vCalibratedInfos.at(i + m_iMarkNum * nExProductIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m+2).m_dPosY;
		}

	}


	strInfo.Format(_T("XYPD平台全局二维码靶标标定:靶标到平台映射计算结束--------------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	return  TRUE;
}

// BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXYPDWholeDmCodeBoardBoardToPlat(int nCamIndex)//全局二维码标定时XYPD平台靶标到平台坐标映射
// {
// 	if (0 == m_iMarkNum)
// 	{
// 		return FALSE;
// 	}	
// 
// 	CString strInfo;
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算开始--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 
// 	m_CalibrateParam = m_vpCalibrateParam[nRemCamIndex];
// 
// 	//$ 1.0 计算转换矩阵
// 
// 	//参数准备：平台坐标偏移量,图像坐标偏移量，方程矩阵，转换参数
// 	//	double dX1,dX2,dY1,dY2;//平台坐标偏移量
// 	//	double dx1,dy1,dx2,dy2;//图像坐标偏移量
// 	//	double A[4][4];	    // 4维矩阵,图像坐标矩阵
// 	//	double dA11, dA12, dA21, dA22;//转换矩阵
// 	//	m_vCalibratedInfos.at(nCamIndex) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 
// 	if (m_bEnableMultiCalibExtension == TRUE)
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			for (int j = 0; j < m_nMultiCalibExtensionMaxNum+1; j++)
// 			{
// 				if (k + m_iMarkNum*j < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*j] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(*m_vAlignerCalibInfos[k + m_iMarkNum*j]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k + m_iMarkNum*j) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k + m_iMarkNum*j);
// 						m_vCalibratedInfos.at(k + m_iMarkNum*j) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k + m_iMarkNum*j) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for(int k = 0; k < m_iMarkNum; k++)
// 		{
// 			//		if (k != nCamIndex)
// 			{
// 				if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
// 				}
// 				else
// 				{
// 					if (m_vCalibratedInfos.at(k) != NULL)
// 					{
// 						delete m_vCalibratedInfos.at(k);
// 						m_vCalibratedInfos.at(k) = NULL;
// 					}
// 					m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
// 				}
// 			}
// 		}
// 	}
// 
// 
// 	//获取该相机对应的图像坐标
// 
// 	double MarkdX[11],MarkdY[11];
// 	double BoardMarkX[11],BoardMarkY[11];
// 	sc2Vector boardMark;
// 	sc2Vector imgMark;
// 	int i=0;
// 	for (i=0; i<10; i++)
// 	{
// 		MarkdX[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosX;
// 		MarkdY[i] = m_vCalibPlatformMoveResults[nRemCamIndex].at(i).m_dPosY;
// 		imgMark.SetX(MarkdX[i]);
// 		imgMark.SetY(MarkdY[i]);
// 		boardMark = sfHomographyProject(imgMark,m_vCalibratedInfos.at(nCamIndex)->m_PlatformTranferH1);
// 		BoardMarkX[i] = boardMark.GetX();
// 		BoardMarkY[i] = boardMark.GetY();
// 	}
// 
// 	strInfo.Format(_T("位置%d图像坐标："),nCamIndex);
// 	CString strTmpInfo;
// 	for (i=0;i<10;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),MarkdX[i],MarkdY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	strInfo.Format(_T("位置%d靶标坐标："),nCamIndex);
// 	for (i=0;i<10;i++)
// 	{
// 		strTmpInfo.Format(_T(" %.3f,%.3f"),BoardMarkX[i],BoardMarkY[i]);
// 		strInfo += strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//设置基准位置处mark的图像坐标，平台轴位置，相机轴位置
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	//	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 
// 	std::vector<sc2Vector> vBoardMark;
// 	for(i = 0; i < 9; i++)
// 	{		
// 		vBoardMark.push_back(sc2Vector(BoardMarkX[i], BoardMarkY[i])-sc2Vector(BoardMarkX[0], BoardMarkY[0]));
// 	}
// 
// 	//平台平面坐标
// 	double dPosX = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosX;
// 	double dPosY = m_CalibrateParam->m_dPlatformCalibMovement.m_dPosY;
// 	std::vector<sc2Vector> vPlatMove;
// 	vPlatMove.push_back(sc2Vector(0, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, +dPosY));
// 	vPlatMove.push_back(sc2Vector(+dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(+dPosX, -dPosY));
// 	vPlatMove.push_back(sc2Vector(0, -dPosY));
// 	vPlatMove.push_back(sc2Vector(-dPosX, -dPosY));
// 	vPlatMove.push_back(sc2Vector(-dPosX, 0));
// 	vPlatMove.push_back(sc2Vector(-dPosX, +dPosY));
// 	vPlatMove.push_back(sc2Vector(0, +dPosY));
// 
// 	// 计算H变换矩阵
// 	double h2[9];
// 	memset(h2, 0.0, sizeof(double)*9);
// 	if (m_bPlatformPick)
// 	{
// 		CString strh;
// 		HomographyDOF dof = GetHomographyDOF();
// //		HomographyDOF dof = m_CalibrateParam->GetHomographyDOF();
// 		switch(dof)
// 		{
// 		case eAuto:
// 			strh="eAuto";
// 			break;
// 		case eScaleRotate:
// 			strh="eScaleRotate";
// 			break;
// 		case eScaleXYRotateXY:
// 			strh="eScaleXYRotateXY";
// 			break;
// 		case eProject:
// 			strh="eProject";
// 			break;
// 		default:
// 			dof =eAuto;
// 			strh="WrongParam , turn to eAuto";
// 			break;
// 		}
// 		strh=_T("当前标定H矩阵算法为:")+strh;
// 		AlignToolLogRecord(strh,m_nPlatformIndex);
// 
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2,dof))
// 		{
// 			return FALSE;
// 		}
// 	}
// 	else
// 	{
// 		if(!sfGetHomography(vBoardMark,vPlatMove,h2))
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 	strInfo.Format(_T("靶标到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h2[%d]:%.6f"),i,h2[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	double dis = 0 ;
// 
// 	svStd vector<sc2Vector> vOffset;
// 	if (!sfGetHomographyMaxErrorInverseProject(vBoardMark,vPlatMove,h2,dis,vOffset))
// 	{
// 		return FALSE;
// 	}
// 	CCoordPos errorOffset;
// 	errorOffset.m_dPosX = dis;
// 	errorOffset.m_dPosY = dis;
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPosRefineOffsetH2(errorOffset);
// 	strInfo.Format(_T("h2矩阵映射误差:%.3f"),dis);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	//记录变换结果
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH2(h2);
// 	double h1[9];
// 	memset(h1, 0.0, sizeof(double)*9);
// 	m_vAlignerCalibInfos.at(nCamIndex)->GetPlatformTransferH1(h1);
// 
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	h[0]=h2[0]*h1[0]+h2[1]*h1[3]+h2[2]*h1[6];
// 	h[1]=h2[0]*h1[1]+h2[1]*h1[4]+h2[2]*h1[7];
// 	h[2]=h2[0]*h1[2]+h2[1]*h1[5]+h2[2]*h1[8];
// 
// 	h[3]=h2[3]*h1[0]+h2[4]*h1[3]+h2[5]*h1[6];
// 	h[4]=h2[3]*h1[1]+h2[4]*h1[4]+h2[5]*h1[7];
// 	h[5]=h2[3]*h1[2]+h2[4]*h1[5]+h2[5]*h1[8];
// 
// 	h[6]=h2[6]*h1[0]+h2[7]*h1[3]+h2[8]*h1[6];
// 	h[7]=h2[6]*h1[1]+h2[7]*h1[4]+h2[8]*h1[7];
// 	h[8]=h2[6]*h1[2]+h2[7]*h1[5]+h2[8]*h1[8];
// 
// 	strInfo.Format(_T("图像到平台坐标映射矩阵:"));
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmpInfo.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmpInfo;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetPlatformTransferH(h);
// 
// 	m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(CCoordPos());
// 
// 
// 	//把九个位置的图像坐标保存
// 	for (int m=0; m<9; m++)
// 	{
// 		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosX = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosX;
// 		m_vCalibratedInfos.at(nCamIndex)->m_cpObjectMarkImgCoordPos[m].m_dPosY = m_vCalibPlatformMoveResults[nRemCamIndex].at(m).m_dPosY;
// 	}
// 
// 
// 	//$3.0、计算图像坐标与平台坐标之间的夹角
// 	m_vCalibratedInfos.at(nCamIndex)->m_dImageToPlatformAnlge = 0;
// 	//m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
// 	strInfo.Format(_T("位置%d:全局二维码靶标标定靶标到平台映射计算结束--------------"),nCamIndex);
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 	return  TRUE;
// }


BOOL vcBaseAlignTool::ExecuteCalibrateBenchMarkRgisterPlace(int nCalibPos, int nMarkType)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}

	for(int k = 0; k < m_iMarkNum; k++)
	{
		//		if (k != nCalibPos)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	// 设置轴位置
	m_vCalibratedInfos.at(nCalibPos)->SetPlatformAxisPos(m_PlatformAxisPos);

	// 恢复基准图像坐标和基准平台坐标
	CCoordPos imgCoordPos = m_vCalibratedInfos.at(nCalibPos)->GetMarkImgCoordPosBat();
	m_vCalibratedInfos.at(nCalibPos)->SetMarkImgCoordPos(imgCoordPos);
	CCoordPos platCoordPos = m_vCalibratedInfos.at(nCalibPos)->GetMarkPlatformCoordPosBat();
	m_vCalibratedInfos.at(nCalibPos)->SetMarkPlatformCoordPos(platCoordPos);

	return  TRUE;
}



// 执行基准注册标定计算，拍照并保存X轴拍照轴位置
BOOL vcBaseAlignTool::ExecuteCalibrateBenchMarkRgister(int nCalibPos, int nMarkType)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}	

	for(int k = 0; k < m_iMarkNum; k++)
	{
		//		if (k != nCalibPos)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}

	// 设置轴位置
	m_vCalibratedInfos.at(nCalibPos)->SetPlatformAxisPos(m_PlatformAxisPos);

	// 设置图像坐标
	CCoordPos ImagePos = m_vCalibPlatformMoveResults[nCalibPos].at(0);
	m_vCalibratedInfos.at(nCalibPos)->SetMarkImgCoordPos(ImagePos);

	// 根据轴位置变化计算平台坐标
	CCoordPos PlatformPos;
	if (false == ConvertImagePosToCurPlatformPos(PlatformPos,  nCalibPos, ImagePos,	m_PlatformAxisPos))
	{
		return FALSE;
	}

	// 设置平台坐标
	m_vCalibratedInfos.at(nCalibPos)->SetMarkPlatformCoordPos(PlatformPos);

	return TRUE;
}

// 关联标定，输入两个MARK的平台坐标，与两个MARK的靶标坐标一起，计算靶标坐标系到平台坐标系转换关系
BOOL vcBaseAlignTool::ExecuteCalibrateFCBR(sc2Vector platformPos1, sc2Vector platformPos2, sc2Vector imagePos1, sc2Vector imagePos2)
{
	CString strInfo;
	strInfo.Format(_T("ExecuteCalibrateFCBR start"));
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	if (m_iMarkNum != 2 || m_bTargetObjectCamSeparate != FALSE || m_bTargetCalibUseBoard != TRUE)
	{
		return FALSE;
	}

	if (m_vAlignerCalibInfos[0] == NULL || m_vAlignerCalibInfos[1] == NULL)
	{
		return FALSE;
	}

	strInfo.Format(_T("platformPos: Pos1(X:%.3f, Y:%.3f), Pos2(X:%.3f, Y:%.3f)"), platformPos1.GetX(), platformPos1.GetY(), platformPos2.GetX(), platformPos2.GetY());
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	strInfo.Format(_T("imagePos: Pos1(X:%.3f, Y:%.3f), Pos2(X:%.3f, Y:%.3f)"), imagePos1.GetX(), imagePos1.GetY(), imagePos2.GetX(), imagePos2.GetY());
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	// （1）获取标定结果
	m_vCalibratedInfos.at(0) = new CCalibratedInfo(*m_vAlignerCalibInfos[0]);
	m_vCalibratedInfos.at(1) = new CCalibratedInfo(*m_vAlignerCalibInfos[1]);

	// （2）根据相机0标定结果，图像坐标1转换靶标坐标1
	sc2Vector boardPos1;
	ConvertImagePosToBoardPos(boardPos1, 0, imagePos1);

	// （3）根据相机1标定结果，图像坐标2转换靶标坐标2
	sc2Vector boardPos2;
	ConvertImagePosToBoardPos(boardPos2, 1, imagePos2);

	// 在这里不能使用ConvertImagePosToCurPlatformPos()函数，因为当考虑靶标到平台单应时，会直接从图像坐标获取平台坐标，而不是靶标坐标

	strInfo.Format(_T("boardPos: Pos1(X:%.3f, Y:%.3f), Pos2(X:%.3f, Y:%.3f)"), boardPos1.GetX(), boardPos1.GetY(), boardPos2.GetX(), boardPos2.GetY());
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	// （4）根据靶标坐标1、靶标坐标2、平台坐标1、平台坐标2，计算靶标到平台单应矩阵
	std::vector<sc2Vector> vPlatformPos;
	vPlatformPos.push_back(platformPos1);
	vPlatformPos.push_back(platformPos2);

	std::vector<sc2Vector> vBoardPos;
	vBoardPos.push_back(boardPos1);
	vBoardPos.push_back(boardPos2);

	double H[9];
	memset(H, 0.0, sizeof(double)*9);
	if(!sfGetHomography(vBoardPos, vPlatformPos, H))
	{
		return FALSE;
	}

	strInfo.Format(_T("H: 0:%.3f, 1:%.3f, 2:%.3f"), H[0], H[1], H[2]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);
	strInfo.Format(_T("H: 3:%.3f, 4:%.3f, 5:%.3f"), H[3], H[4], H[5]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);
	strInfo.Format(_T("H: 6:%.3f, 7:%.3f, 8:%.3f"), H[6], H[7], H[8]);
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	// （5）将该单应矩阵保存在相机0和相机1的标定结果中
	m_vCalibratedInfos.at(0)->SetPlatformTransferH(H);
	m_vCalibratedInfos.at(1)->SetPlatformTransferH(H);

	strInfo.Format(_T("ExecuteCalibrateFCBR end"));
	AlignToolLogRecord(strInfo, m_nPlatformIndex);

	// （6）将当前MARK的图像坐标和靶标坐标保存到标定结果中
	m_vCalibratedInfos.at(0)->SetMarkImgCoordPos(CCoordPos(imagePos1.GetX(), imagePos1.GetY(), 0));
	m_vCalibratedInfos.at(1)->SetMarkImgCoordPos(CCoordPos(imagePos2.GetX(), imagePos2.GetY(), 0));

	m_vCalibratedInfos.at(0)->SetMarkPlatformCoordPos(CCoordPos(boardPos1.GetX(), boardPos1.GetY(), 0));
	m_vCalibratedInfos.at(1)->SetMarkPlatformCoordPos(CCoordPos(boardPos2.GetX(), boardPos2.GetY(), 0));

	return TRUE;
}

// 从图像坐标转换靶标坐标，不考虑轴位置变化
BOOL vcBaseAlignTool::ConvertImagePosToBoardPos(sc2Vector& boardPos, int nIndex, sc2Vector imagePos)
{
	if (nIndex<0 || nIndex >= m_iMarkNum || m_vAlignerCalibInfos.at(nIndex) == NULL)
	{
		return FALSE;
	}

	// 2*2旋转缩放矩阵系数
	double dTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	// 基准MARK靶标坐标
	double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosX();
	double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosY();

	// 基准MARK图像坐标
	double dImageBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().GetPosX();
	double dImageBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().GetPosY();

	// 基准MARK到实时MARK图像距离
	double dImgOffsetX = imagePos.GetX() - dImageBenchMarkX;
	double dImgOffsetY = imagePos.GetY() - dImageBenchMarkY;

	// 图像距离换算成物理距离
	double dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
	double dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

	// 实时MARK靶标坐标
	boardPos.SetX(dPlatformBenchMarkX + dImgOffsetRealDistanceX);
	boardPos.SetY(dPlatformBenchMarkY + dImgOffsetRealDistanceY);

	CString str;
	str.Format("基准MARK靶标坐标：X=%f,Y=%f", dPlatformBenchMarkX, dPlatformBenchMarkY);
	AlignToolLogRecord(str, m_nPlatformIndex);
	str.Format("基准MARK图像坐标：X=%f,Y=%f", dImageBenchMarkX, dImageBenchMarkY);
	AlignToolLogRecord(str, m_nPlatformIndex);
	str.Format("基准MARK到实时MARK图像距离：X=%f,Y=%f", dImgOffsetX, dImgOffsetY);
	AlignToolLogRecord(str, m_nPlatformIndex);
	str.Format("图像距离换算成物理距离：X=%f,Y=%f", dImgOffsetRealDistanceX, dImgOffsetRealDistanceY);
	AlignToolLogRecord(str, m_nPlatformIndex);
	str.Format("实时MARK靶标坐标：X=%f,Y=%f", boardPos.GetX(), boardPos.GetY());
	AlignToolLogRecord(str, m_nPlatformIndex);

	return TRUE;
}

BOOL vcBaseAlignTool::ExecuteDisCorPoint(int nIndex, CCoordPos inputPoint, CCoordPos& outputPoint)
{
	int nRemIndex = nIndex%m_iMarkNum;

	std::vector<sc2Vector> inPoints;
	std::vector<sc2Vector> outPoints;
	inPoints.push_back(sc2Vector(inputPoint.GetPosX(),inputPoint.GetPosY()));
	for(int i = 0;i < inputPoint.m_vdAuxiliaryPosX.size(); i++)
	{
		inPoints.push_back(sc2Vector(inputPoint.m_vdAuxiliaryPosX.at(i),inputPoint.m_vdAuxiliaryPosY.at(i)));
	}
	
	scCalibrateResult result;
	result = m_vAlignerCalibInfos.at(nIndex)->m_result;

	scImageWarp* pImageWarpTool;
	double lWidth = m_ImageSizes.m_vPos.at(nRemIndex).m_dPosX;
	double lHeight = m_ImageSizes.m_vPos.at(nRemIndex).m_dPosY;
	pImageWarpTool = new scImageWarp(result, sc2Vector(lWidth,lHeight), false);

	pImageWarpTool->ExecuteProjectAndLensWarpPoints(inPoints, outPoints, false);

	if(pImageWarpTool != NULL)
	{
		delete pImageWarpTool;
		pImageWarpTool = NULL;
	}

	outputPoint.m_dPosX = outPoints.at(0).GetX();
	outputPoint.m_dPosY = outPoints.at(0).GetY();
	for(int i = 0;i < inputPoint.m_vdAuxiliaryPosX.size(); i++)
	{
		outputPoint.m_vdAuxiliaryPosX.at(i) = outPoints.at(i+1).GetX();
		outputPoint.m_vdAuxiliaryPosY.at(i) = outPoints.at(i+1).GetY();
	}

	return TRUE;
}

BOOL vcBaseAlignTool::ExecuteDisCorPoint(int nIndex, std::vector<sc2Vector> inputPoint, std::vector<sc2Vector>& outputPoint)
{
	int nRemIndex = nIndex%m_iMarkNum;

	scCalibrateResult result;
	result = m_vAlignerCalibInfos.at(nIndex)->m_result;

	scImageWarp* pImageWarpTool;
	double lWidth = m_ImageSizes.m_vPos.at(nRemIndex).m_dPosX;
	double lHeight = m_ImageSizes.m_vPos.at(nRemIndex).m_dPosY;
	pImageWarpTool = new scImageWarp(result, sc2Vector(lWidth,lHeight), false);

	pImageWarpTool->ExecuteProjectAndLensWarpPoints(inputPoint, outputPoint, false);

	if(pImageWarpTool != NULL)
	{
		delete pImageWarpTool;
		pImageWarpTool = NULL;
	}

	return TRUE;
}


/************************************************************************/
/*							标定求精								    */
/************************************************************************/

//判断是否需要求精
BOOL vcBaseAlignTool::IsExecuteCalibrateRefine( void )
{
	//读取界面上的是否求精变量（使用标定参数设置中的标定是否求精的变量）
	return m_CalibrateParam->GetPlatformCalibrateRefine();
}

//1）在执行求精函数中返回ture，才需要判断求精过程是否结束
//2）如果小于2次，不结束；等于5次，求精结束
//3）第2,3,4次，看x，y变化量是否达到精度要求，是则求精结束，否则继续
BOOL vcBaseAlignTool::IsRefineFinished( int nCamIndex )
{
	if (nCamIndex<0 || nCamIndex >= m_iMarkNum)
		return TRUE;

	int iRefineTimes = m_vCalibRefineImageCoord.size();
	if (iRefineTimes<2)
	{
		return FALSE;
	}
	//如果是第5次求精，则求精结束
	else if (iRefineTimes >= 5)
	{
		return TRUE;
	}
	//不是第5次，则判断是否满足精度要求
	else
	{
		//如果满足精度要求，求精结束，不满足则继续
		if (TRUE == m_bIsRefineSatisfied)
			return TRUE;
		else
			return FALSE;
	}

}

//标定求精时，计算各轴移动位置，拍摄图像，下一步将设置求精图像坐标
//以XYD平台为例，后续要在各子类中分别实现
CPlatformAxisPos* vcBaseAlignTool::GetCalibRefineMovePos( int nCamIndex )
{
	if (nCamIndex<0 || nCamIndex >= m_iMarkNum)
		return NULL;
	m_CalibrateParam = m_vpCalibrateParam[nCamIndex];

	//平台信息，当前轴的位置信息，转换到XYD平台
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
	CPlatformXYDAxisPos* pPlatformAxisPos = (CPlatformXYDAxisPos*)m_PlatformAxisPos;

	//读取上一次基准mark的坐标
	double dX0,dY0;
	dX0 = m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPosX();
	dY0 = m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPosY();

	//读取旋转角度，使用标定时的旋转角度；计算平台移动偏移量
	CCoordPos Offset;
	Offset.m_dAngle = m_CalibrateParam->GetPlatformCalibMovement().GetAngle();
	double A11,A12,A21,A22;
	A11 = 1-cos(Offset.m_dAngle);
	A12 = sin(Offset.m_dAngle);
	A21 = -sin(Offset.m_dAngle);
	A22 = 1-cos(Offset.m_dAngle);
	Offset.m_dPosX = A11*dX0 + A12*dY0;
	Offset.m_dPosY = A21*dX0 + A22*dY0;

	//转化成实际平台各轴的移动量
	if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)
		Offset.m_dPosX = - Offset.m_dPosX;

	if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)
		Offset.m_dPosY = - Offset.m_dPosY;

	if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)
		Offset.m_dAngle = - Offset.m_dAngle;
	if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)
		Offset.m_dAngle = tan(scDegree(Offset.m_dAngle))*pPlatformParam->m_dPlatformRotationLength;

	//计算平台轴移动的绝对位置
	pPlatformAxisPos->m_dPosX += Offset.m_dPosX;
	pPlatformAxisPos->m_dPosY += Offset.m_dPosY;
	pPlatformAxisPos->m_dAngle += Offset.m_dAngle;
	*m_PlatformRefineAxisPos = *pPlatformAxisPos;

	return m_PlatformRefineAxisPos;
}


//设置求精时的图像坐标值（基准位置不用读入图像)
void vcBaseAlignTool::SetRefineImgCoordPos( CCoordPos pos )
{
	m_vCalibRefineImageCoord.push_back(pos);
}

//返回本次求精是否成功
//第一次，没有对比，必须成功
//第二次以后，判断平台坐标变化量的符号与前一次是否一致，是则成功，否则求精失败，求精结束
BOOL vcBaseAlignTool::ExecuteCalibrateRefine(int nCamIndex)
{
	if (nCamIndex>m_iMarkNum)
		return NULL;

	int iRefineTimes = m_vCalibRefineImageCoord.size();//求精次数
	m_vCalibRefinePlatformCoord.resize(iRefineTimes);
	double dx1,dy1,dx2,dy2;	//将图像坐标变化量
	double dX1,dY1,dX2,dY2;	//计算平台坐标变化量

	//第一次求精完，计算新的平台坐标值和轴的位置，不更新标定信息
	if (iRefineTimes == 1)
	{
		return TRUE;//第一次求精，返回成功
	}

	else 
	{
		if (iRefineTimes == 2)
		{
			dx1 = m_vCalibRefineImageCoord.at(iRefineTimes-2).m_dPosX - m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos().GetPosX();
			dy1 = m_vCalibRefineImageCoord.at(iRefineTimes-2).m_dPosY - m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos().GetPosY();
			dx2 = m_vCalibRefineImageCoord.at(iRefineTimes-1).m_dPosX - m_vCalibRefineImageCoord.at(iRefineTimes-2).m_dPosX;
			dy2 = m_vCalibRefineImageCoord.at(iRefineTimes-1).m_dPosY - m_vCalibRefineImageCoord.at(iRefineTimes-2).m_dPosY;
		}
		else
		{
			dx1 = m_vCalibRefineImageCoord.at(iRefineTimes-2).m_dPosX - m_vCalibRefineImageCoord.at(iRefineTimes-3).m_dPosX;
			dy1 = m_vCalibRefineImageCoord.at(iRefineTimes-2).m_dPosY - m_vCalibRefineImageCoord.at(iRefineTimes-3).m_dPosY;
			dx2 = m_vCalibRefineImageCoord.at(iRefineTimes-1).m_dPosX - m_vCalibRefineImageCoord.at(iRefineTimes-2).m_dPosX;
			dy2 = m_vCalibRefineImageCoord.at(iRefineTimes-1).m_dPosY - m_vCalibRefineImageCoord.at(iRefineTimes-2).m_dPosY;
		}
		dX1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0)*dx1
			+ m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1)*dy1;
		dY1 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0)*dx1
			+ m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1)*dy1;
		dX2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,0)*dx2
			+ m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(0,1)*dy2;
		dY2 = m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,0)*dx2
			+ m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferMatrix().GetElement(1,1)*dy2;

		//如果X,Y变化量不同号，本次求精无效，求精结束
		if (dX1*dX2<0 || dY1*dY2<0)
		{
			return FALSE;
		}
		else//x,y变化量同号，本次求精有效
		{//将基准mark的平台坐标值进行更新

			//读取上一次基准mark的坐标
			double dX0,dY0;
			dX0 = m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPosX();
			dY0 = m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPosY();

			//计算当前基准mark坐标	

			m_vCalibRefinePlatformCoord.at(iRefineTimes-1).m_dPosX = dX0 + dX2;
			m_vCalibRefinePlatformCoord.at(iRefineTimes-1).m_dPosY = dY0 + dY2;

			//将标定结果信息中的记住mark坐标更新，
			//基准位置处平台各轴的坐标更新
			m_vCalibratedInfos.at(nCamIndex)->SetMarkPlatformCoordPos(m_vCalibRefinePlatformCoord.at(iRefineTimes-1));
			*m_PlatformAxisPos = *m_PlatformRefineAxisPos;	

			//判断是否满足精度要求？
			if (dX2<1.0 && dY2<1.0)	
				m_bIsRefineSatisfied = TRUE;
			else
				m_bIsRefineSatisfied = FALSE;

			return TRUE;
		}
	}

}


// 获取标定求精时各轴的位置（共3个，正转D度，反转D度，基准位置）
std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformRefineMovePos(int nPosIndex)
{
	int nRemPosIndex = nPosIndex%m_iMarkNum;
	//将存储标定时的绝对位置的变量清空
	for (int j=0; j<m_vPlatformRefineAxisPos.size(); j++)
	{	
		if (m_vPlatformRefineAxisPos.at(j) != NULL)
		{
			delete m_vPlatformRefineAxisPos.at(j);
			m_vPlatformRefineAxisPos.at(j) = NULL;
		}
	}
	m_vPlatformRefineAxisPos.clear();

	if (nRemPosIndex < 0 || nRemPosIndex >= m_iMarkNum)
	{
		return m_vPlatformRefineAxisPos;
	}

	m_CalibrateParam = m_vpCalibrateParam[nRemPosIndex];

	//***********************XYD平台***********************//
	//相机固定安装/或独立X安装/或独立XY轴安装时，可以正常标定
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
	double dPlatformBenchMarkX,dPlatformBenchMarkY;

	dPlatformBenchMarkX = m_vCalibratedInfos.at(nPosIndex)->GetMarkPlatformCoordPos().GetPosX();
	dPlatformBenchMarkY = m_vCalibratedInfos.at(nPosIndex)->GetMarkPlatformCoordPos().GetPosY();



	
	double dRotateAngle = m_CalibrateParam->GetPlatformCalibRefineMoveD();
	CPlatformXYDAxisPos* AxisMovePos1 = new CPlatformXYDAxisPos;//轴移动绝对位置参数
	CPlatformXYDAxisPos* AxisMovePos2 = new CPlatformXYDAxisPos;



	double dX0,dY0,dD0;  //基准坐标
	dX0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
	dY0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
	dD0 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

	//if (m_bCalibSendRelativePos)
	//{
	//	dX0 = 0.0;
	//	dY0 = 0.0;
	//	dD0 = 0.0;
	//}

	double dX1,dY1,dD1; //变换后新坐标
	dX1 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
	dY1 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
	dD1 = ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;

	//将平台坐标移动量转化为实际轴移动量
	//////////////////////////////////////////////////////////////////////////正转D
	double dOffsetX = 0.0, dOffsetY = 0.0 , dOffsetD = 0.0;
	scDegree degOffsetD = scDegree(0);
	vfGetCalibRefineBenchMarkMoveOffset(sc2Vector(dPlatformBenchMarkX,dPlatformBenchMarkY), scDegree(dRotateAngle),
		dOffsetX, dOffsetY, degOffsetD);
	dOffsetD = degOffsetD.ToDouble();


	if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
		dOffsetX = -dOffsetX;
	if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
		dOffsetY = -dOffsetY;
	if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
		dOffsetD = -dOffsetD;
	// 	if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
	// 		dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
	if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
	{
		double dStartAngle = 0;
		if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
		{
			if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
			{
				dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
				dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
			}
			else
			{
				dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
				dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
			}
		}
	}
	//===================================================================================
	if (1)
	{
		BOOL bChangeX = FALSE;
		BOOL bChangeY = FALSE;
		BOOL bChangeD = FALSE;
		GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
		if (bChangeX)
		{
			dOffsetX = -dOffsetX;
		}
		if (bChangeY)
		{
			dOffsetY = -dOffsetY;
		}
		if (bChangeD)
		{
			dOffsetD = -dOffsetD;
		}
	}

	//===================================================================================

	dX1 = dX0 + dOffsetX;
	dY1 = dY0 + dOffsetY;
	dD1 = dD0 + dOffsetD;

	AxisMovePos1->m_dPosX   = dX1 ;
	AxisMovePos1->m_dPosY   = dY1 ;	
	AxisMovePos1->m_dAngle  = dD1;


	//////////////////////////////////////////////////////////////////////////反转D
	dRotateAngle = -dRotateAngle;

	vfGetCalibRefineBenchMarkMoveOffset(sc2Vector(dPlatformBenchMarkX,dPlatformBenchMarkY), scDegree(dRotateAngle),
		dOffsetX, dOffsetY, degOffsetD);
	dOffsetD = degOffsetD.ToDouble();

	if (eDirectNegative == pPlatformParam->m_nPlatformXCoordType)//Y轴方向为负
		dOffsetX = -dOffsetX;
	if (eDirectNegative == pPlatformParam->m_nPlatformYCoordType)//x轴方向为负
		dOffsetY = -dOffsetY;
	if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType)//D轴方向为负
		dOffsetD = -dOffsetD;
	// 	if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
	// 		dOffsetD = tan(scDegree(dOffsetD))*pPlatformParam->m_dPlatformRotationLength;
	if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
	{
		double dStartAngle = 0;
		if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
		{
			if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
			{
				dStartAngle = scDegree(scRadian(asin(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
				dOffsetD = (sin(scDegree(dStartAngle + dOffsetD)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
			}
			else
			{
				dStartAngle = scDegree(scRadian(atan(dD0/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
				dOffsetD = (tan(scDegree(dStartAngle + dOffsetD)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
			}
		}
	}
	//===================================================================================
	if (1)
	{
		BOOL bChangeX = FALSE;
		BOOL bChangeY = FALSE;
		BOOL bChangeD = FALSE;
		GetCalibrateChangeXYDDirection(bChangeX,bChangeY,bChangeD);
		if (bChangeX)
		{
			dOffsetX = -dOffsetX;
		}
		if (bChangeY)
		{
			dOffsetY = -dOffsetY;
		}
		if (bChangeD)
		{
			dOffsetD = -dOffsetD;
		}
	}

	//===================================================================================
	dX1 = dX0 + dOffsetX;
	dY1 = dY0 + dOffsetY;
	dD1 = dD0 + dOffsetD;

	AxisMovePos2->m_dPosX   = dX1 ;
	AxisMovePos2->m_dPosY   = dY1 ;	
	AxisMovePos2->m_dAngle  = dD1;


	//需要设置平台各轴的初始位置，即基准位置
	if (m_PlatformAxisPos != NULL)
	{		
		//将3个位置压入，最后一个是基准位置：指针类型直接压入还是new？
		//0	
		m_vPlatformRefineAxisPos.push_back(AxisMovePos1);
		//1
		m_vPlatformRefineAxisPos.push_back(AxisMovePos2);
		//2
		CPlatformXYDAxisPos* AxisMovePos3 = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_PlatformAxisPos));
		//if (m_bCalibSendRelativePos)
		//{
		//	AxisMovePos3->m_dPosX = 0.0;
		//	AxisMovePos3->m_dPosY = 0.0;
		//	AxisMovePos3->m_dAngle = 0.0;
		//}
		m_vPlatformRefineAxisPos.push_back(AxisMovePos3);		
		if (m_bCalibSendRelativePos)
		{

			for (int i=m_vPlatformRefineAxisPos.size()-1;i>0;i--)
			{
				((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i))->m_dPosX-((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i-1))->m_dPosX;
				((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i))->m_dPosY-((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i-1))->m_dPosY;
				((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i))->m_dAngle-((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(i-1))->m_dAngle;
			}

			((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(0))->m_dPosX = ((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(0))->m_dPosX - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosX;
			((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(0))->m_dPosY = ((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(0))->m_dPosY - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dPosY;
			((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(0))->m_dAngle = ((CPlatformXYDAxisPos*)m_vPlatformRefineAxisPos.at(0))->m_dAngle - ((CPlatformXYDAxisPos*)m_PlatformAxisPos)->m_dAngle;
		}
	}

	return m_vPlatformRefineAxisPos;
}

// 设置平台标定求精时图像搜索结果
void vcBaseAlignTool::SetCalibPlatformRefineMoveSearchResult(std::vector<CMarkImagePos*> ImageResults)
{
	m_vCalibPlatformRefineMoveResults.clear();
	//将每个位置num副图像，共3个不同位置的图像坐标压入m_vCalibPlatformMoveResults

	for (int j=0; j<ImageResults.size(); j++)
	{
		int num = ImageResults.at(j)->m_vPos.size();
		for (int k=0; k<num; k++)
		{
			/*			if (ImageResults.at(j)->m_vbOK.at(k))*/		
			m_vCalibPlatformRefineMoveResults.push_back(ImageResults.at(j)->m_vPos.at(k));
		}
	}
}

//执行标定结果求精（计算新的更为准确的基准Mark平台坐标系坐标）
BOOL vcBaseAlignTool::ExecuteCalibratePlatformRefine(int nPosIndex)
{
	int nRemPosIndex = nPosIndex%m_iMarkNum;
	if (nRemPosIndex>m_iMarkNum)
		return FALSE;

	m_CalibrateParam = m_vpCalibrateParam[nRemPosIndex];

	if (m_vCalibratedInfos.at(nPosIndex)==NULL)
	{
		return FALSE;
	}

	CString str;
	str.Format("XYD平台标定求精开始:位置[%d]------------------------------------------------------------",nPosIndex+1);
	AlignToolLogRecord(str,m_nPlatformIndex);


	//获取该相机对应的图像坐标
	const int nPosNum = 3;

	m_RefineMarkPlatformPos.Reset();
	m_RefineSearchResults.Reset();

	m_RefineMarkPlatformPos.SetMarkPlatformPosNum(nPosNum);
	m_RefineSearchResults.SetMarkImagePosNum(nPosNum);

	for (int i=0; i<nPosNum; i++)
	{
		m_RefineSearchResults.SetMarkImagePos(i,TRUE, m_vCalibPlatformRefineMoveResults.at(i));
	}
	GetCalibRefineMarkPlatformPos(nPosIndex);

	str.Format("求精正转图像坐标: X=%f,Y=%f",m_vCalibPlatformRefineMoveResults.at(0).GetPosX(),m_vCalibPlatformRefineMoveResults.at(0).GetPosY());
	AlignToolLogRecord(str,m_nPlatformIndex);

	str.Format("求精反转图像坐标: X=%f,Y=%f",m_vCalibPlatformRefineMoveResults.at(1).GetPosX(),m_vCalibPlatformRefineMoveResults.at(1).GetPosY());
	AlignToolLogRecord(str,m_nPlatformIndex);

	// 求精计算
	sc2Vector vRotatedPositiveMarkPlatformPos;	// 正向旋转后Mark平台坐标
	sc2Vector vRotatedNegativeMarkPlatformPos;  // 反向旋转后Mark平台坐标
	scDegree degRotateAngle;					// 正向旋转角度
	sc2Vector vOldBenchMarkPlatformPos;			// 原基准Mark的平台坐标
	sc2Vector vNewBenchMarkPlatformPos;			// 求精后基准Mark新的平台坐标

	vRotatedPositiveMarkPlatformPos.SetX(m_RefineMarkPlatformPos.GetMarkPlatformPos(0).GetPosX());
	vRotatedPositiveMarkPlatformPos.SetY(m_RefineMarkPlatformPos.GetMarkPlatformPos(0).GetPosY());
	vRotatedNegativeMarkPlatformPos.SetX(m_RefineMarkPlatformPos.GetMarkPlatformPos(1).GetPosX());
	vRotatedNegativeMarkPlatformPos.SetY(m_RefineMarkPlatformPos.GetMarkPlatformPos(1).GetPosY());


	str.Format("求精正转平台坐标: X=%f,Y=%f",vRotatedPositiveMarkPlatformPos.GetX(),vRotatedPositiveMarkPlatformPos.GetY());
	AlignToolLogRecord(str,m_nPlatformIndex);

	str.Format("求精反转平台坐标: X=%f,Y=%f",vRotatedNegativeMarkPlatformPos.GetX(),vRotatedNegativeMarkPlatformPos.GetY());
	AlignToolLogRecord(str,m_nPlatformIndex);

	degRotateAngle = scDegree(m_CalibrateParam->GetPlatformCalibRefineMoveD());

	vOldBenchMarkPlatformPos.SetX(m_vCalibratedInfos.at(nPosIndex)->GetMarkPlatformCoordPos().GetPosX());
	vOldBenchMarkPlatformPos.SetY(m_vCalibratedInfos.at(nPosIndex)->GetMarkPlatformCoordPos().GetPosY());

	vfCalibRefineBenchMarkPlatformPos(vRotatedPositiveMarkPlatformPos, vRotatedNegativeMarkPlatformPos, degRotateAngle, 
		vOldBenchMarkPlatformPos, vNewBenchMarkPlatformPos);


	str.Format("求精原基准点平台坐标: X=%f,Y=%f",vOldBenchMarkPlatformPos.GetX(),vOldBenchMarkPlatformPos.GetY());
	AlignToolLogRecord(str,m_nPlatformIndex);
	str.Format("求精新基准点平台坐标: X=%f,Y=%f",vNewBenchMarkPlatformPos.GetX(),vNewBenchMarkPlatformPos.GetY());
	AlignToolLogRecord(str,m_nPlatformIndex);

	CCoordPos RefineOffset;
	RefineOffset = CCoordPos((vNewBenchMarkPlatformPos - vOldBenchMarkPlatformPos).GetX(),(vNewBenchMarkPlatformPos - vOldBenchMarkPlatformPos).GetY(),0);
	m_vCalibratedInfos.at(nPosIndex)->SetMarkPlatformCoordPosRefineOffset(RefineOffset);

	m_vCalibratedInfos.at(nPosIndex)->SetMarkPlatformCoordPos( CCoordPos(vNewBenchMarkPlatformPos.GetX(),vNewBenchMarkPlatformPos.GetY(),0));
	m_vCalibratedInfos.at(nPosIndex)->SetMarkPlatformCoordPosBat( CCoordPos(vNewBenchMarkPlatformPos.GetX(),vNewBenchMarkPlatformPos.GetY(),0));
	m_vCalibratedInfos.at(nPosIndex)->SetValid(TRUE);

	str.Format("XYD平台标定求精结束:位置[%d]------------------------------------------------------------\n",nPosIndex+1);
	AlignToolLogRecord(str,m_nPlatformIndex);

	return TRUE;
}

// 获取平台标定求精时图像搜索结果的平台坐标位置
CMarkPlatformPos vcBaseAlignTool::GetCalibRefineMarkPlatformPos(int nPosIndex)
{
	//针对每个相机的移动位置（3个）的图像mark计算其平台坐标值
	for (int i=0; i<m_RefineMarkPlatformPos.GetMarkPlatformPosNum(); i++)
	{	

		ConvertCalibRefineImagePosToCurPlatformPos(m_RefineMarkPlatformPos.m_vPos.at(i),nPosIndex, m_RefineSearchResults.m_vPos.at(i));

		m_RefineMarkPlatformPos.m_vbOK.at(i) = TRUE;
	}
	return m_RefineMarkPlatformPos;
}

// 将标定求精是的图像位置转为平台坐标位置
bool vcBaseAlignTool::ConvertCalibRefineImagePosToCurPlatformPos(CCoordPos& platformCoordPos, int nPosIndex, CCoordPos imageCoordPos)
{
	CString str;
// 	str.Format("---------------------------------------------------------------------begin");
// 	AlignToolLogRecord(str);

	if (nPosIndex < 0 || nPosIndex >= m_vCalibratedInfos.size())
	{
		return false;
	}

	if (NULL == m_vCalibratedInfos.at(nPosIndex))
		return false;

	//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
	//相机平台类型没有基类，不用改；
// 	CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 
// 
// 	if ( NULL == pPlatformParam)
// 	{
// 		return false;
// 	}

	// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
	//标定参数
	double dTranferA11 = m_vCalibratedInfos.at(nPosIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dTranferA12 = m_vCalibratedInfos.at(nPosIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dTranferA21 = m_vCalibratedInfos.at(nPosIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dTranferA22 = m_vCalibratedInfos.at(nPosIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	double dPlatformBenchMarkX = m_vCalibratedInfos.at(nPosIndex)->GetMarkPlatformCoordPos().GetPosX();
	double dPlatformBenchMarkY = m_vCalibratedInfos.at(nPosIndex)->GetMarkPlatformCoordPos().GetPosY();
// 	str.Format("Bench Mark paltform coord X=%f,Y=%f",dPlatformBenchMarkX,dPlatformBenchMarkY);
// 	AlignToolLogRecord(str);

	// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
	double dImgOffsetRealDistanceX = 0;
	double dImgOffsetRealDistanceY = 0;
	double dImgOffsetX = imageCoordPos.m_dPosX - m_vCalibratedInfos.at(nPosIndex)->GetMarkImgCoordPos().m_dPosX;
	double dImgOffsetY = imageCoordPos.m_dPosY - m_vCalibratedInfos.at(nPosIndex)->GetMarkImgCoordPos().m_dPosY;
	dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
	dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		sc2Vector vSrc;
		sc2Vector vDst;
		vSrc.SetX(dImgOffsetX);
		vSrc.SetY(dImgOffsetY);
		vDst = sfHomographyProject(vSrc,m_vCalibratedInfos.at(nPosIndex)->m_PlatformTranferH);
		dImgOffsetRealDistanceX = vDst.GetX();
		dImgOffsetRealDistanceY = vDst.GetY();
	}


// 	str.Format("Image offset distance X=%f,Y=%f",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
// 	AlignToolLogRecord(str);


	// $4、三部分内容相加，即为相机实时Mark的平台坐标值
	platformCoordPos.m_dPosX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
	platformCoordPos.m_dPosY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
	//mark为线时，平台mark线的角度为图像线的角度+图像平台坐标之间的夹角；
	platformCoordPos.m_dAngle = imageCoordPos.GetAngle() + 	m_vAlignerCalibInfos.at(nPosIndex)->m_dImageToPlatformAnlge;
// 	str.Format("platform coord pos X=%f,Y=%f",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY);
// 	AlignToolLogRecord(str);
// 	str.Format("---------------------------------------------------------------------over");
// 	AlignToolLogRecord(str);
	return true;
}




//执行相机平台标定
BOOL vcBaseAlignTool::ExecuteCamCalibrate( int nCalibPos )
{
	if (FALSE == ExecuteCamCalibrateSingleCam(nCalibPos))
		return FALSE;
	return TRUE;
}
BOOL vcBaseAlignTool::ExecuteCamCalibrate( void )
{
	//相机个数
	if (m_iMarkNum <= 0)
	{
		return FALSE;
	}
	
	for (int i=0; i<m_iMarkNum ; i++)
	{
		if (FALSE == ExecuteCamCalibrateSingleCam(i))
			return FALSE;
	}
	return TRUE;
}

//单个相机平台标定（相机平台坐标系到平台坐标系的转换关系）
BOOL vcBaseAlignTool::ExecuteCamCalibrateSingleCam( int nCamIndex )
{
	if (nCamIndex>=m_iMarkNum || m_iMarkNum<=0)
		return FALSE;

	int nBaseIndex;
	nBaseIndex = 0;
	SYSTEMTIME sys; 
	GetLocalTime( &sys ); 
	CString t;
	t.Format("[%d_%d_%d_%d_%d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond);
	CString strLogPath;
	CString strRecord;
	strLogPath.Format(_T("D:\\CamCalibrate%d.txt"),m_nPlatformIndex);
	FILE *fileLog;


	m_CalibrateParam = m_vpCalibrateParam[nCamIndex];


	for(int k = 0; k < m_iMarkNum; k++)
	{
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());

			}
		}
	}

	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));


	fileLog = fopen(strLogPath,_T("a+t"));
	strRecord.Format(_T("%s基准相机轴位置设置成功\n"),t);
	fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
	fclose(fileLog);

	//参数准备：四个位置的图像坐标，平台坐标变化量，转换参数
	double dX1,dX2,dY1,dY2;					//平台坐标偏移量
	double dAxx, dAxy, dAyx, dAyy;			//图像坐标到平台坐标的转换矩阵

	//$1、 读取该相机对应的图像坐标	
	// 相机按照-x，+x，-y，+y运动，读取相应的图像坐标
	double MarkdX[4],MarkdY[4];
	for (int i=0; i<4; i++)
	{
		
		if(nCamIndex >= m_iMarkNum / 2 && m_bTarObjCamSepNoAxisCalib == TRUE)
		{
			// 将目标相机的图像坐标转换为对象相机的图像坐标
			sc2Vector vSrcTarget;
			sc2Vector vDstObject;
			vSrcTarget.SetX(m_vCalibCameraMoveResults.at(i).m_dPosX);
			vSrcTarget.SetY(m_vCalibCameraMoveResults.at(i).m_dPosY);
			vDstObject = sfHomographyProject(vSrcTarget,m_vAlignerCalibInfos.at(nCamIndex)->m_PlatformTranferH);
			MarkdX[i] =  vDstObject.GetX();
			MarkdY[i] =  vDstObject.GetY();
		}
		else
		{
			MarkdX[i] = m_vCalibCameraMoveResults.at(i).m_dPosX;
			MarkdY[i] = m_vCalibCameraMoveResults.at(i).m_dPosY;
		}
		
	}
	fileLog = fopen(strLogPath,_T("a+t"));
	strRecord.Format(_T("%s图像坐标Mark0（%f,%f）,Mark1（%f,%f）,Mark2（%f,%f）,Mark3（%f,%f）\n"),t,
		MarkdX[0],MarkdY[0],MarkdX[1],MarkdY[1],MarkdX[2],MarkdY[2],MarkdX[3],MarkdY[3]);
	fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
	fclose(fileLog);

	if(nCamIndex >= m_iMarkNum / 2 && m_bTarObjCamSepNoAxisCalib == TRUE)
	{
		nBaseIndex = nCamIndex - m_iMarkNum /2;
	}
	else
	{
		nBaseIndex = nCamIndex;
	}

	//获取相应相机的标定信息
	sc2Matrix PlatformTranferMatrix;
	PlatformTranferMatrix = m_vCalibratedInfos.at(nBaseIndex)->GetPlatformTransferMatrix();

	double h[9];
	m_vCalibratedInfos.at(nBaseIndex)->GetPlatformTransferH(h);
	CCoordPos cpBenchMarkImagePos = m_vCalibratedInfos.at(nBaseIndex)->GetMarkImgCoordPos();
	// $2.0 开始标定
	sc2Vector vSrc;
	sc2Vector vDst;

	sc2Vector vSrc0;
	sc2Vector vSrc1;

	sc2Vector vDst0;
	sc2Vector vDst1;

	if (eCamPlatformSepXY == m_pCamPlatformInfo->GetCamPlatformType())//相机平台类型为独立XY轴安装
	{
		// $2.1 相机X轴运动标定
			
		dX1 = PlatformTranferMatrix.GetElement(0,0)*(MarkdX[1] - MarkdX[0])+
			  PlatformTranferMatrix.GetElement(0,1)*(MarkdY[1] - MarkdY[0]);
		dY1 = PlatformTranferMatrix.GetElement(1,0)*(MarkdX[1] - MarkdX[0])+
			  PlatformTranferMatrix.GetElement(1,1)*(MarkdY[1] - MarkdY[0]);

		fileLog = fopen(strLogPath,_T("a+t"));
		strRecord.Format(_T("%s获取PlatformTranferMatrix成功\n"),t);
		fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
		fclose(fileLog);
	
		if (m_PlatformCalibType == ePlatformCalib9Point && (nBaseIndex < m_iMarkNum / 2 || m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point) )
		{
// 			vSrc.SetX(MarkdX[1] - MarkdX[0]);
// 			vSrc.SetY(MarkdY[1] - MarkdY[0]);
// 			vDst = sfHomographyProject(vSrc,h);
// 			dX1 = vDst.GetX();
// 			dY1 = vDst.GetY();


			vSrc0.SetX(MarkdX[0] - cpBenchMarkImagePos.m_dPosX);
			vSrc0.SetY(MarkdY[0] - cpBenchMarkImagePos.m_dPosY);
			vDst0 = sfHomographyProject(vSrc0,h);

			vSrc1.SetX(MarkdX[1] - cpBenchMarkImagePos.m_dPosX);
			vSrc1.SetY(MarkdY[1] - cpBenchMarkImagePos.m_dPosY);
			vDst1 = sfHomographyProject(vSrc1,h);

			vDst = vDst1 - vDst0;
			dX1 = vDst.GetX();
			dY1 = vDst.GetY();

		}


		if(eDirectNone != m_pCamPlatformInfo->GetCamDirectX(nCamIndex))
		{
			dAxx = dX1/(-2*m_CalibrateParam->m_dCameraCalibMovement.m_dPosX);
			dAxy = dY1/(-2*m_CalibrateParam->m_dCameraCalibMovement.m_dPosX);

		}
		else
		{
			dAxx = 1.0;
			dAxy = 0.0;
		}
		fileLog = fopen(strLogPath,_T("a+t"));
		strRecord.Format(_T("%sdAxx:%f,dAxy:%f,\n"),t,dAxx,dAxy);
		fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
		fclose(fileLog);	

		// $2.2相机Y轴运动标定
		dX2 = PlatformTranferMatrix.GetElement(0,0)*(MarkdX[3] - MarkdX[2])+
			  PlatformTranferMatrix.GetElement(0,1)*(MarkdY[3] - MarkdY[2]);
		dY2 = PlatformTranferMatrix.GetElement(1,0)*(MarkdX[3] - MarkdX[2])+
			  PlatformTranferMatrix.GetElement(1,1)*(MarkdY[3] - MarkdY[2]);

		if (m_PlatformCalibType == ePlatformCalib9Point && (nBaseIndex < m_iMarkNum / 2 || m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point))
		{
// 			vSrc.SetX(MarkdX[3] - MarkdX[2]);
// 			vSrc.SetY(MarkdY[3] - MarkdY[2]);
// 			vDst = sfHomographyProject(vSrc,h);
// 			dX2 = vDst.GetX();
// 			dY2 = vDst.GetY();


			vSrc0.SetX(MarkdX[2] - cpBenchMarkImagePos.m_dPosX);
			vSrc0.SetY(MarkdY[2] - cpBenchMarkImagePos.m_dPosY);
			vDst0 = sfHomographyProject(vSrc0,h);

			vSrc1.SetX(MarkdX[3] - cpBenchMarkImagePos.m_dPosX);
			vSrc1.SetY(MarkdY[3] - cpBenchMarkImagePos.m_dPosY);
			vDst1 = sfHomographyProject(vSrc1,h);

			vDst = vDst1 - vDst0;
			dX2 = vDst.GetX();
			dY2 = vDst.GetY();
		}

		if(eDirectNone != m_pCamPlatformInfo->GetCamDirectY(nCamIndex))
		{
			dAyx = dX2/(-2*m_CalibrateParam->m_dCameraCalibMovement.m_dPosY);
			dAyy = dY2/(-2*m_CalibrateParam->m_dCameraCalibMovement.m_dPosY);
		}
		else
		{
			dAyx = 0.0;
			dAyy = 1.0;

		}
		fileLog = fopen(strLogPath,_T("a+t"));
		strRecord.Format(_T("%sdAyx:%f,dAyy:%f,\n"),t,dAyx,dAyy);
		fwrite(strRecord,sizeof(TCHAR),strRecord.GetLength(),fileLog);
		fclose(fileLog);
		
	}
	else if (eCamPlatformSepX == m_pCamPlatformInfo->GetCamPlatformType())
	{
		// $2.1 相机X轴运动标定
			
		dX1 = PlatformTranferMatrix.GetElement(0,0)*(MarkdX[1] - MarkdX[0])+
			  PlatformTranferMatrix.GetElement(0,1)*(MarkdY[1] - MarkdY[0]);
		dY1 = PlatformTranferMatrix.GetElement(1,0)*(MarkdX[1] - MarkdX[0])+
			  PlatformTranferMatrix.GetElement(1,1)*(MarkdY[1] - MarkdY[0]);

		if (m_PlatformCalibType == ePlatformCalib9Point && (nBaseIndex < m_iMarkNum / 2 || m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point))
		{
// 			vSrc.SetX(MarkdX[1] - MarkdX[0]);
// 			vSrc.SetY(MarkdY[1] - MarkdY[0]);
// 			vDst = sfHomographyProject(vSrc,h);
// 			dX1 = vDst.GetX();
// 			dY1 = vDst.GetY();


			vSrc0.SetX(MarkdX[0] - cpBenchMarkImagePos.m_dPosX);
			vSrc0.SetY(MarkdY[0] - cpBenchMarkImagePos.m_dPosY);
			vDst0 = sfHomographyProject(vSrc0,h);

			vSrc1.SetX(MarkdX[1] - cpBenchMarkImagePos.m_dPosX);
			vSrc1.SetY(MarkdY[1] - cpBenchMarkImagePos.m_dPosY);
			vDst1 = sfHomographyProject(vSrc1,h);

			vDst = vDst1 - vDst0;
			dX1 = vDst.GetX();
			dY1 = vDst.GetY();
		}


		
		dAxx = dX1/(-2*m_CalibrateParam->m_dCameraCalibMovement.m_dPosX);
		dAxy = dY1/(-2*m_CalibrateParam->m_dCameraCalibMovement.m_dPosX);

		// $2.2相机Y轴运动标定
		dAyx = 0;
		dAyy = 1;
	}
	else 
	{
		// $2.1 相机X轴运动标定
		dAxx = 1;
		dAxy = 0;

		// $2.2 相机Y轴运动标定
		dAyx = 0;
		dAyy = 1;
	}


	//将计算得到的转换参数赋值到标定结果矩阵中

	sc2Matrix CamPlatformTranferMatrix(dAxx,dAxy,dAyx, dAyy);
	m_vCalibratedInfos.at(nCamIndex)->SetCamPlatformTransferMatrix(CamPlatformTranferMatrix);
	m_vCalibratedInfos.at(nCamIndex)->SetValid(TRUE);
	
	
	return TRUE;
}

BOOL vcBaseAlignTool::ConvertSrcPosToDstPos(int nCalibPos,sc2Vector srcPos,sc2Vector& dstPos)
{
	if (0 == m_iMarkNum)
	{
		return FALSE;
	}
	if (nCalibPos < 0 || nCalibPos >= m_vAlignerCalibInfos.size())
	{
		return FALSE;
	}
	if (m_vAlignerCalibInfos.at(nCalibPos) == NULL || !m_vAlignerCalibInfos.at(nCalibPos)->IsValid())
	{
		return FALSE;
	}
	double h[9];
	memset(h, 0.0, sizeof(double)*9);
	m_vAlignerCalibInfos.at(nCalibPos)->GetPlatformTransferH(h);
	dstPos = sfHomographyProject(srcPos,h);
	return TRUE;
}

// 启用畸变矫正功能，如下参数有实际意义
// bImageDisCor =  TURE：srcvPos传入为图像坐标；
// bImageDisCor = FALSE：dstvPos传入为图像坐标；
BOOL vcBaseAlignTool::ConvertSrcPosToDstPos(std::vector<sc2Vector> &srcvPos,std::vector<sc2Vector> &dstvPos,sc2Vector srcPos,sc2Vector &dstPos, BOOL bImageDisCor, int nIndex)
{
	CString strInfo;
	strInfo.Format(_T("二维码标定建立临时映射矩阵开始--------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	int nRemIndex = nIndex%m_iMarkNum;
	if(m_vpCalibrateParam.at(nRemIndex)->m_nEnableDisCor)
	{
		CString strOut, strTmp;
		strOut.Format(_T("畸变矫正开始："));
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		double p[15];
		memset(p, 0.0, sizeof(double)*15);
		scCalibrateResult result = m_vAlignerCalibInfos.at(nIndex)->m_result;
		result.GetNonlinearProjectResult(p);
		double dRms = result.GetRMS();
		strOut.Format("畸变参数: ");
		for (int i=0;i<15; i++)
		{
			strTmp.Format(_T("P%d:%.6f "), i, p[i]);
			strOut += strTmp;
		}
		strTmp.Format(_T("P15:%.6f "),dRms);
		strOut += strTmp;
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		// bImageDisCor =  TURE：srcvPos传入为图像坐标；
		if (bImageDisCor)
		{
			strOut.Format("畸变校正前图像坐标: ");
			for (int i=0; i<srcvPos.size(); i++)
			{
				strTmp.Format(_T("srcvPosPos%d(%.6f, %.6f, %.6f) "), i, srcvPos.at(i).GetX(), srcvPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);


			// 畸变矫正
			for (int i=0; i<srcvPos.size(); i++)
			{
				CCoordPos srcvPosDisCor;
				ExecuteDisCorPoint(nIndex, CCoordPos(srcvPos.at(i).GetX(), srcvPos.at(i).GetY(), 0), srcvPosDisCor);
				srcvPos.at(i) = sc2Vector(srcvPosDisCor.GetPosX(), srcvPosDisCor.GetPosY());
			}

			// 注意：图像转换为二维码坐标，需先进行畸变矫正后进行转换
			CCoordPos ImageDisCor;
			ExecuteDisCorPoint(nIndex, CCoordPos(srcPos.GetX(), srcPos.GetY(), 0), ImageDisCor);
			srcPos = sc2Vector(ImageDisCor.GetPosX(), ImageDisCor.GetPosY());


			strOut.Format("畸变校正后图像坐标: ");
			for (int i=0; i<srcvPos.size(); i++)
			{
				strTmp.Format(_T("srcvPosPos%d(%.6f, %.6f, %.6f) "), i, srcvPos.at(i).GetX(), srcvPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);

		}
		// bImageDisCor = FALSE：dstvPos传入为图像坐标；
		else
		{
			strOut.Format("畸变校正前图像坐标: ");
			for (int i=0; i<srcvPos.size(); i++)
			{
				strTmp.Format(_T("dstvPosPos%d(%.6f, %.6f, %.6f) "), i, dstvPos.at(i).GetX(), dstvPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);


			for (int i = 0; i < dstvPos.size(); i++)
			{
				CCoordPos imageDisCorPos;
				ExecuteDisCorPoint(nIndex, CCoordPos(dstvPos.at(i).GetX(), dstvPos.at(i).GetY(), 0), imageDisCorPos);
				dstvPos.at(i) = sc2Vector(imageDisCorPos.GetPosX(), imageDisCorPos.GetPosY());
			}

			strOut.Format("畸变校后前图像坐标: ");
			for (int i=0; i<srcvPos.size(); i++)
			{
				strTmp.Format(_T("dstvPosPos%d(%.6f, %.6f, %.6f) "), i, dstvPos.at(i).GetX(), dstvPos.at(i).GetY());
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);
		}

		strOut.Format(_T("畸变矫正结束："));
		AlignToolLogRecord(strOut,m_nPlatformIndex);
	}


	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(srcvPos,dstvPos,h))
	{
		return FALSE;
	}

	strInfo = _T("临时映射矩阵h：");
	CString strTmp;
	for (int i=0;i<9;i++)
	{
		strTmp.Format(_T(" h[%d]:%.6f"),i,h[i]);
		strInfo = strInfo + strTmp;
	}
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	dstPos = sfHomographyProject(srcPos,h);

	strInfo.Format(_T("二维码标定建立临时映射矩阵结束--------------"));
	AlignToolLogRecord(strInfo,m_nPlatformIndex);

	return TRUE;
}



// BOOL vcBaseAlignTool::ConvertSrcPosToDstPos(std::vector<sc2Vector> &srcvPos,std::vector<sc2Vector> &dstvPos,sc2Vector srcPos,sc2Vector &dstPos)
// {
// 	CString strInfo;
// 	strInfo.Format(_T("二维码标定建立临时映射矩阵开始--------------"));
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	// 计算H变换矩阵
// 	double h[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 
// 	if(!sfGetHomography(srcvPos,dstvPos,h))
// 	{
// 		return FALSE;
// 	}
// 
// 	strInfo = _T("临时映射矩阵h：");
// 	CString strTmp;
// 	for (int i=0;i<9;i++)
// 	{
// 		strTmp.Format(_T(" h[%d]:%.6f"),i,h[i]);
// 		strInfo = strInfo + strTmp;
// 	}
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	dstPos = sfHomographyProject(srcPos,h);
// 
// 	strInfo.Format(_T("二维码标定建立临时映射矩阵结束--------------"));
// 	AlignToolLogRecord(strInfo,m_nPlatformIndex);
// 
// 	return TRUE;
// }

BOOL vcBaseAlignTool::ConvertSrcPosToDstPos(const std::vector<sc2Vector> &srcvPos,const std::vector<sc2Vector> &dstvPos,std::vector<sc2Vector> &vSrcTranseferPos,std::vector<sc2Vector> &vDstTranseferPos)
{
	// 计算H变换矩阵
	double h[9];
	memset(h, 0.0, sizeof(double)*9);

	if(!sfGetHomography(srcvPos,dstvPos,h))
	{
		return FALSE;
	}

	vDstTranseferPos.clear();
	sc2Vector tmpVec;
	for (int i=0;i<vSrcTranseferPos.size();i++)
	{
		tmpVec = sfHomographyProject(vSrcTranseferPos.at(i),h);
		vDstTranseferPos.push_back(tmpVec);
	}
	
	return TRUE;
}

// 获取标定信息
std::vector<CCalibratedInfo*> vcBaseAlignTool::GetCalibratedInfo()
{	
	int nPosCalibrated = 0;
	if (m_bEnableMultiCalibExtension)
	{
		nPosCalibrated = m_iMarkNum * (m_nMultiCalibExtensionMaxNum + 1);
	} 
	else
	{
		nPosCalibrated = m_iMarkNum;
	}
	for(int k = 0; k < nPosCalibrated; k++)
	{
		if(m_vCalibratedInfos.at(k) == NULL)
		{
			if (k < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k] != NULL)
			{
				if (m_vCalibratedInfos.at(k)!=NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(*m_vAlignerCalibInfos[k]);
			}
			else
			{
				if (m_vCalibratedInfos.at(k)!=NULL)
				{
					delete m_vCalibratedInfos.at(k);
					m_vCalibratedInfos.at(k) = NULL;
				}
				m_vCalibratedInfos.at(k) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
			}
		}
	}
	return	m_vCalibratedInfos;
}

CCalibratedInfo* vcBaseAlignTool::GetSingleCalibratedInfo(int nCamIndex)
{
	if (nCamIndex<0 || nCamIndex >= m_iMarkNum)
		return NULL;
	
	return	m_vCalibratedInfos.at(nCamIndex);
}


BOOL vcBaseAlignTool::SetSameCalibrateInfo(int nSrcPos,std::vector<int>vnPos)							//将nSrc位置的标定信息拷贝到其他位置中
{
	if (vnPos.size() > m_vCalibratedInfos.size() || nSrcPos < 0||nSrcPos >= m_vCalibratedInfos.size())
	{
		return FALSE;
	}
	for (int i=0;i<vnPos.size();i++)
	{
		if (vnPos.at(i) < 0 || vnPos.at(i) >= m_vCalibratedInfos.size())
		{
			return FALSE;
		}
		if (m_vCalibratedInfos.at(nSrcPos) == NULL)
		{
			return FALSE;
		}
		if (m_vCalibratedInfos.at(vnPos.at(i)) == NULL)
		{
			m_vCalibratedInfos.at(vnPos.at(i)) = new CCalibratedInfo(m_pPlatformParam->GetPlatformType(),m_pCamPlatformInfo->GetCamPlatformType());
		}
		*m_vCalibratedInfos.at(vnPos.at(i)) = *m_vCalibratedInfos.at(nSrcPos);
	}

	return TRUE;
}


/********************************对位*************************************/

bool vcBaseAlignTool::InitCalibratedInfos(std::vector<CCalibratedInfo*> vCalibratedInfos)
{
	if (0 == vCalibratedInfos.size())
	{
		return false;
	}

	for (int i=0; i<m_vCalibratedInfos.size(); i++)
	{	
		if (m_vCalibratedInfos.at(i) != NULL)
		{
			delete m_vCalibratedInfos.at(i);
			m_vCalibratedInfos.at(i) = NULL;
		}
	}


	for (int j=0; j<vCalibratedInfos.size(); j++)
	{	
		m_vCalibratedInfos.at(j) = new CCalibratedInfo(*((CCalibratedInfo*)vCalibratedInfos.at(j)));
	}

	return true;
}
// 设置产品标定信息
bool vcBaseAlignTool::SetProductCalibratedInfo(std::vector<CCalibratedInfo*> vCalibratedInfos)
{
	if (0 == vCalibratedInfos.size())
	{
		return false;
	}
	
	for (int i=0; i<m_vAlignerCalibInfos.size(); i++)
	{	
		if (m_vAlignerCalibInfos.at(i) != NULL)
		{
			delete m_vAlignerCalibInfos.at(i);
			m_vAlignerCalibInfos.at(i) = NULL;
		}
	}


	for (int j=0; j<vCalibratedInfos.size(); j++)
	{	
		m_vAlignerCalibInfos.at(j) = new CCalibratedInfo(*((CCalibratedInfo*)vCalibratedInfos.at(j)));
	}

	return true;
}

bool vcBaseAlignTool::SetProductCalibratedInfoSingleCam(int nCamIndex, CCalibratedInfo* vCalibratedInfos )
{
	if (nCamIndex<0 || nCamIndex >= m_iMarkNum)
		return false;
	if (NULL == vCalibratedInfos)
		return false;

	if (m_vAlignerCalibInfos.at(nCamIndex) != NULL)
	{
		delete m_vAlignerCalibInfos.at(nCamIndex);
		m_vAlignerCalibInfos.at(nCamIndex) = NULL;
	}

	//将标定得到的数据写入，包括转换矩阵，基准mark平台坐标，俩坐标系夹角
	//还有平台轴位置，相机轴位置，基准mark的图像坐标
	m_vAlignerCalibInfos.at(nCamIndex) = new CCalibratedInfo(*((CCalibratedInfo*)vCalibratedInfos));

	return true;
// 	m_vAlignerCalibInfos.at(nCamIndex)->SetPlatformAxisPos(m_PlatformAxisPos);
// 	m_vAlignerCalibInfos.at(nCamIndex)->SetCamPlatformAxisPos(m_vCamPlatformInitAxisPos.at(nCamIndex));
// 	m_vAlignerCalibInfos.at(nCamIndex)->SetMarkImgCoordPos(m_vCalibPlatformMoveResults.at(nCamIndex));
}






//////////////////////////////////////////////////////////////////////////
// 实时目标

void vcBaseAlignTool::SetTargetPlatformPos(std::vector<CPlatformAxisPos*> pPlatformAxisPos)
{
	int i=0;
	for (i=0;i<m_pTargetPlatformAxisPos.size();i++)
	{
		if (m_pTargetPlatformAxisPos.at(i)!= NULL)
		{
			delete m_pTargetPlatformAxisPos.at(i);
			m_pTargetPlatformAxisPos.at(i) = NULL;
		}
	}
	m_pTargetPlatformAxisPos.clear();

	for (i=0;i<pPlatformAxisPos.size();i++)
	{
		if ( ePlatformXYD== pPlatformAxisPos.at(i)->GetPlatformType())
		{	
			CPlatformAxisPos * platformAxisPos;
			platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos.at(i)));
			m_pTargetPlatformAxisPos.push_back(platformAxisPos); 
		}
	}
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetTargetPlatformPos()
{
	return m_pTargetPlatformAxisPos;
}

void vcBaseAlignTool::SetTargetPlatformPos(CPlatformAxisPos* pPlatformAxisPos,int nIndex)
{

	if (nIndex<0|| pPlatformAxisPos==NULL)
	{
		return;
	}
	if (nIndex+1 > m_pTargetPlatformAxisPos.size())
	{
		m_pTargetPlatformAxisPos.resize(nIndex+1);
	}//????


	if (m_pTargetPlatformAxisPos.at(nIndex)!= NULL)
	{
		delete m_pTargetPlatformAxisPos.at(nIndex);
		m_pTargetPlatformAxisPos.at(nIndex) = NULL;
	}	

	if ( ePlatformXYD== pPlatformAxisPos->GetPlatformType())
	{
		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
		m_pTargetPlatformAxisPos.at(nIndex)=platformAxisPos; 
	}

}

CPlatformAxisPos* vcBaseAlignTool::GetTargetPlatformPos(int nIndex)
{
	if (nIndex<0 || nIndex>=m_pTargetPlatformAxisPos.size())
	{
		return NULL;
	}
	if (m_pTargetPlatformAxisPos.at(nIndex)==NULL)
	{
		return NULL;
	}
	return m_pTargetPlatformAxisPos.at(nIndex);
}

void vcBaseAlignTool::SetTargetCameraPos(CPlatformAxisPos* pCamPlatformAxisPos, int nIndex)
{
	if(nIndex < 0 || pCamPlatformAxisPos == NULL)
	{
		return;
	}

	if(nIndex + 1 > m_vTargetCamPlatformAxisPos.size())
	{
		m_vTargetCamPlatformAxisPos.resize(nIndex+1);
	}

	if(m_vTargetCamPlatformAxisPos.at(nIndex) != NULL)
	{
		delete m_vTargetCamPlatformAxisPos.at(nIndex);
		m_vTargetCamPlatformAxisPos.at(nIndex) = NULL;
	}

	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos));
	m_vTargetCamPlatformAxisPos.at(nIndex) = pAxisPos;

}

void vcBaseAlignTool::SetTargetCameraPos(std::vector<CPlatformAxisPos*> pCamPlatformAxisPos)
{
	for (int i=0; i<m_vTargetCamPlatformAxisPos.size(); i++)
	{
		if (m_vTargetCamPlatformAxisPos.at(i)!= NULL)
		{
			delete m_vTargetCamPlatformAxisPos.at(i);
			m_vTargetCamPlatformAxisPos.at(i) = NULL;
		}
	}
	m_vTargetCamPlatformAxisPos.clear();
	for (int j=0; j<pCamPlatformAxisPos.size(); j++)
	{	
		if (pCamPlatformAxisPos.at(j) != NULL)
		{	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos.at(j)));
			m_vTargetCamPlatformAxisPos.push_back(pAxisPos);
		}
	}
}

void vcBaseAlignTool::SetTargetCameraPos(std::vector<CPlatformAxisPos*> pCamPlatformAxisPos,int nCamPos)
{
	if (m_vTargetCamPlatformAxisPos.size()!= pCamPlatformAxisPos.size())
	{
		for (int i=0; i<m_vTargetCamPlatformAxisPos.size(); i++)
		{
			if (m_vTargetCamPlatformAxisPos.at(i)!= NULL)
			{
				delete m_vTargetCamPlatformAxisPos.at(i);
				m_vTargetCamPlatformAxisPos.at(i) = NULL;
			}
		}
		m_vTargetCamPlatformAxisPos.clear();

		for (int j=0; j<pCamPlatformAxisPos.size(); j++)
		{	
			if (pCamPlatformAxisPos.at(j) != NULL)
			{
				CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos.at(j)));
			   m_vTargetCamPlatformAxisPos.push_back(pAxisPos);
			}
		}
		
	}
	else
	{
		if (m_vTargetCamPlatformAxisPos.at(nCamPos)!= NULL)
		{
			delete m_vTargetCamPlatformAxisPos.at(nCamPos);
			m_vTargetCamPlatformAxisPos.at(nCamPos) = NULL;
		}

		if (pCamPlatformAxisPos.at(nCamPos) != NULL)
		{
			m_vTargetCamPlatformAxisPos.at(nCamPos) = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos.at(nCamPos)));
		
		}

	}
	

}	

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetTargetCameraPos()
{
	return m_vTargetCamPlatformAxisPos;
}

void vcBaseAlignTool::SetTargetCamAxisPlatformAxisPos(std::vector<CPlatformAxisPos*> pCamPlatformAxisPos)
{
	for (int i=0; i<m_vTargetCamAxisPlatformAxisPos.size(); i++)
	{
		if (m_vTargetCamAxisPlatformAxisPos.at(i)!= NULL)
		{
			delete m_vTargetCamAxisPlatformAxisPos.at(i);
			m_vTargetCamAxisPlatformAxisPos.at(i) = NULL;
		}
	}
	m_vTargetCamAxisPlatformAxisPos.clear();
	for (int j=0; j<pCamPlatformAxisPos.size(); j++)
	{	
		if (pCamPlatformAxisPos.at(j) != NULL)
		{	
			CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos.at(j)));
			m_vTargetCamAxisPlatformAxisPos.push_back(pAxisPos);
		}
	}
}

void vcBaseAlignTool::SetTargetCamAxisPlatformAxisPos(CPlatformAxisPos* pCamAxisPlatformAxisPos, int nIndex)
{
	if(nIndex < 0 || pCamAxisPlatformAxisPos == NULL)
	{
		return;
	}

	if(nIndex + 1 > m_vTargetCamAxisPlatformAxisPos.size())
	{
		m_vTargetCamAxisPlatformAxisPos.resize(nIndex+1);
	}

	if(m_vTargetCamAxisPlatformAxisPos.at(nIndex) != NULL)
	{
		delete m_vTargetCamAxisPlatformAxisPos.at(nIndex);
		m_vTargetCamAxisPlatformAxisPos.at(nIndex) = NULL;
	}

	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos));
	m_vTargetCamAxisPlatformAxisPos.at(nIndex) = pAxisPos;

}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetTargetCamAxisPlatformAxisPos()
{
	return m_vTargetCamAxisPlatformAxisPos;
}

void vcBaseAlignTool::SetTargetCamAxisPos_MultiEx(CPlatformAxisPos* pCamPlatformAxisPos,int nIndex)
{
	if(nIndex < 0 || pCamPlatformAxisPos == NULL)
	{
		return;
	}

	int nExProductIndex = GetAlignExProductIndex();
	if (nExProductIndex >= m_vvpTargetCamPlatformAxisPosMultiEx.size())
	{
		m_vvpTargetCamPlatformAxisPosMultiEx.resize(nExProductIndex+1);
	}

	if(nIndex + 1 > m_vvpTargetCamPlatformAxisPosMultiEx.at(nExProductIndex).size())
	{
		m_vvpTargetCamPlatformAxisPosMultiEx.at(nExProductIndex).resize(nIndex+1);
	}

	if(m_vvpTargetCamPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) != NULL)
	{
		delete m_vvpTargetCamPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex);
		m_vvpTargetCamPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) = NULL;
	}

	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos));
	m_vvpTargetCamPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) = pAxisPos;

}

void vcBaseAlignTool::SetTargetCamAxisPos_MultiEx(std::vector<std::vector<CPlatformAxisPos*>> vvpCamPlatformAxisPos)
{
	for (int i=0;i<m_vvpTargetCamPlatformAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpTargetCamPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpTargetCamPlatformAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpTargetCamPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpTargetCamPlatformAxisPosMultiEx.at(i).at(j) =NULL;
			}
		}
		m_vvpTargetCamPlatformAxisPosMultiEx.at(i).clear();
	}
	m_vvpTargetCamPlatformAxisPosMultiEx.clear();
	m_vvpTargetCamPlatformAxisPosMultiEx.resize(vvpCamPlatformAxisPos.size());
	for (int i=0;i<vvpCamPlatformAxisPos.size();i++)
	{
		m_vvpTargetCamPlatformAxisPosMultiEx.at(i).resize(vvpCamPlatformAxisPos.at(i).size());
	}
	CPlatformXYAxisPos* pCamAxisPos = NULL;
	for (int i=0;i<vvpCamPlatformAxisPos.size();i++)
	{
		for (int j=0;j<vvpCamPlatformAxisPos.at(i).size();j++)
		{
			if (vvpCamPlatformAxisPos.at(i).at(j)!=NULL)
			{
				pCamAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)vvpCamPlatformAxisPos.at(i).at(j)));
			}
			else
			{
				pCamAxisPos = new CPlatformXYAxisPos();
			}
			
			m_vvpTargetCamPlatformAxisPosMultiEx.at(i).at(j)=pCamAxisPos;
		}
		
	}
}

void vcBaseAlignTool::SetTargetCamAxisPlatformAxisPos_MultiEx(CPlatformAxisPos* pCamAxisPlatformAxisPos,int nIndex)
{
	if(nIndex < 0 || pCamAxisPlatformAxisPos == NULL)
	{
		return;
	}
	int nExProductIndex = GetAlignExProductIndex();
	if (nExProductIndex >= m_vvpTargetCamAxisPlatformAxisPosMultiEx.size())
	{
		m_vvpTargetCamAxisPlatformAxisPosMultiEx.resize(nExProductIndex+1);
	}
	if(nIndex + 1 > m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).size())
	{
		m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).resize(nIndex+1);
	}
	if(m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) != NULL)
	{
		delete m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex);
		m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) = NULL;
	}
	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos));
	m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) = pAxisPos;
}

void vcBaseAlignTool::SetTargetCamAxisPlatformAxisPos_MultiEx(std::vector<std::vector<CPlatformAxisPos*>> vvpCamAxisPlatformAxisPos)
{
	for (int i=0;i<m_vvpTargetCamAxisPlatformAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j) =NULL;
			}
		}
		m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).clear();
	}
	m_vvpTargetCamAxisPlatformAxisPosMultiEx.clear();
	m_vvpTargetCamAxisPlatformAxisPosMultiEx.resize(vvpCamAxisPlatformAxisPos.size());
	for (int i=0;i<vvpCamAxisPlatformAxisPos.size();i++)
	{
		m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).resize(vvpCamAxisPlatformAxisPos.at(i).size());
	}
	CPlatformXYAxisPos* pCamAxisPos = NULL;

	for (int i=0;i<vvpCamAxisPlatformAxisPos.size();i++)
	{
		for (int j=0;j<vvpCamAxisPlatformAxisPos.at(i).size();j++)
		{
			if (vvpCamAxisPlatformAxisPos.at(i).at(j)!=NULL)
			{
				pCamAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)vvpCamAxisPlatformAxisPos.at(i).at(j)));
			}
			else
			{
				pCamAxisPos = new CPlatformXYAxisPos();
			}

			m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(i).at(j)=pCamAxisPos;
		}

	}
}

void vcBaseAlignTool::SetTargetMarkSearchResults(CMarkImagePos ImageResults)
{
	m_TargetSearchResults = ImageResults;
}



CMarkImagePos vcBaseAlignTool::GetTargetMarkSearchResults()
{
	return m_TargetSearchResults;
}

BOOL vcBaseAlignTool::SetTargetMarkPlatformPos(CMarkPlatformPos &tarPlatPos)
{
	if (m_TargetMarkPlatformPos.m_vPos.size() != tarPlatPos.m_vPos.size())
	{
		return FALSE;
	}
	m_TargetMarkPlatformPos = tarPlatPos;
	return TRUE;
}

// 获取目标Mark的全局平台坐标值
CMarkPlatformPos vcBaseAlignTool::GetTargetMarkPlatformPosForAlign()
{
	//针对每个相机的图像mark计算其平台坐标值
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("目标平台坐标计算开始------------------\n\n");
	AlignToolLogRecord(str,nPlatformIndex);

	if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTargetObjectCamSeparate == TRUE && m_bTarObjCamSepNoAxisCalib)
	{
		for (int k=0;k<m_pTargetPlatformAxisPos.size();k++)
		{
			int nBaseIndex = 0;
			if (k< m_iMarkNum/2)
			{
				nBaseIndex = k;
			} 
			else
			{
				nBaseIndex = k - m_iMarkNum/2;
			}

			if (GetMidPlatformType() == ePlatformXYD)
			{
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dPosX = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosX;
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dPosY = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosY;
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dAngle = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dAngle;
			}
			else if(GetMidPlatformType() == ePlatformYD)
			{
				//由于目标在X轴上，所以需要使用X轴的实时位置
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dPosY = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosY;
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dAngle = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dAngle;
			}
			else if(GetMidPlatformType() == ePlatformXD)
			{
				//由于目标在Y轴上，所以需要使用Y轴的实时位置
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dPosX = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosX;
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dAngle = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dAngle;
			}

		}
	}


	for (int i=0; i<m_iMarkNum; i++)
	{	
		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{
			str.Format("目标平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
				m_pTargetPlatformAxisPos.at(i));

			str.Format("目标平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		else
		{
			str.Format("目标平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			if (m_bEnableMultiCalibExtension)
			{
				*((CPlatformXYAxisPos*)(m_vTargetCamPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpTargetCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
				*((CPlatformXYAxisPos*)(m_vTargetCamAxisPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
			}

			ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
				m_pTargetPlatformAxisPos.at(i), m_vTargetCamPlatformAxisPos.at(i), m_vTargetCamAxisPlatformAxisPos.at(i));

			str.Format("目标平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		m_TargetMarkPlatformPos.m_vbOK.at(i) = TRUE;
	}

	str.Format("------------------目标平台坐标计算结束\n\n");
	AlignToolLogRecord(str,nPlatformIndex);

	return m_TargetMarkPlatformPos;

}



// 获取目标Mark的全局平台坐标值
CMarkPlatformPos vcBaseAlignTool::GetTargetMarkPlatformPos()
{
	//针对每个相机的图像mark计算其平台坐标值
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("目标平台坐标计算开始------------------");
	AlignToolLogRecord(str,nPlatformIndex);

	if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTargetObjectCamSeparate == TRUE && m_bTarObjCamSepNoAxisCalib)
	{
		for (int k=0;k<m_pTargetPlatformAxisPos.size();k++)
		{
			int nBaseIndex = 0;
			if (k< m_iMarkNum/2)
			{
				nBaseIndex = k;
			} 
			else
			{
				nBaseIndex = k - m_iMarkNum/2;
			}
			if (GetMidPlatformType() == ePlatformXYD)
			{
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dPosX = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosX;
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dPosY = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosY;
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dAngle = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dAngle;
			}
			else if(GetMidPlatformType() == ePlatformYD)
			{
				//由于目标在X轴上，所以需要使用X轴的实时位置
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dPosY = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosY;
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dAngle = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dAngle;
			}
			else if(GetMidPlatformType() == ePlatformXD)
			{
				//由于目标在Y轴上，所以需要使用Y轴的实时位置
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dPosX = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosX;
				((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k))->m_dAngle = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dAngle;
			}

		}
	}

	for (int i=0; i<m_iMarkNum; i++)
	{	
		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{
			str.Format("目标平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);
			ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
				m_pTargetPlatformAxisPos.at(i));

			str.Format("目标平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		else
		{
			//MFQ-20190319
			//ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
			//m_pTargetPlatformAxisPos.at(i), m_vTargetCamPlatformAxisPos.at(i));
			str.Format("目标平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);
			if (m_bEnableMultiCalibExtension)
			{
				*((CPlatformXYAxisPos*)(m_vTargetCamPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpTargetCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
				*((CPlatformXYAxisPos*)(m_vTargetCamAxisPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
			}
			ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
				m_pTargetPlatformAxisPos.at(i), m_vTargetCamPlatformAxisPos.at(i), m_vTargetCamAxisPlatformAxisPos.at(i));
			str.Format("目标平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		m_TargetMarkPlatformPos.m_vbOK.at(i) = TRUE;
	}

	//重新构造新的对位点//================================================================================
	if (FALSE && m_bTargetObjectCamSeparate && m_iMarkNum == 8 
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		CCoordPos tmpPos[4];

		CString str;
		int k;
		for ( k=m_iMarkNum/2;k<m_iMarkNum;k++)
		{
			tmpPos[k-m_iMarkNum/2] = m_TargetMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_TargetMarkPlatformPos.m_vPos.at(k).m_dPosX,m_TargetMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		CCoordPos ResultPos[4];
		scLine ResultLine[4];
		sc2Vector UsePoint[8];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;
		UsePoint[0].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).GetAuxiliaryPosX(0));
		UsePoint[0].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).GetAuxiliaryPosY(0));
		UsePoint[1].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).GetAuxiliaryPosX(0));
		UsePoint[1].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).GetAuxiliaryPosY(0));
		ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

		UsePoint[2].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).GetAuxiliaryPosX(1));
		UsePoint[2].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).GetAuxiliaryPosY(1));
		UsePoint[3].SetX(m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).GetAuxiliaryPosX(1));
		UsePoint[3].SetY(m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).GetAuxiliaryPosY(1));
		ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

		UsePoint[4].SetX(m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).GetAuxiliaryPosX(0));
		UsePoint[4].SetY(m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).GetAuxiliaryPosY(0));
		UsePoint[5].SetX(m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).GetAuxiliaryPosX(0));
		UsePoint[5].SetY(m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).GetAuxiliaryPosY(0));
		ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		UsePoint[6].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).GetAuxiliaryPosX(1));
		UsePoint[6].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).GetAuxiliaryPosY(1));
		UsePoint[7].SetX(m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).GetAuxiliaryPosX(1));
		UsePoint[7].SetY(m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).GetAuxiliaryPosY(1));
		ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

		if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosY = crossPointArray.at(0).GetY();
		}


		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosY = crossPointArray.at(0).GetY();
		}


		if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosY = crossPointArray.at(0).GetY();
		}


		if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosY = crossPointArray.at(0).GetY();
		}

		for (k=m_iMarkNum/2;k<m_iMarkNum;k++)
		{
			str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_TargetMarkPlatformPos.m_vPos.at(k).m_dPosX,m_TargetMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=m_iMarkNum/2;k<m_iMarkNum;k++)
		{
			double ddx = tmpPos[k-m_iMarkNum/2].GetPosX() - m_TargetMarkPlatformPos.m_vPos.at(k).GetPosX();
			double ddy = tmpPos[k-m_iMarkNum/2].GetPosY() - m_TargetMarkPlatformPos.m_vPos.at(k).GetPosY();
			str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	else if (FALSE && ((m_bTargetObjectCamSeparate && m_iMarkNum == 4)||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		int nIndexOffset = (m_bTargetObjectCamSeparate && m_iMarkNum == 4) ? 2 : 0;

		CCoordPos tmpPos[2];
		int k = 0;
		for (k=0;k<2;k++)
		{
			tmpPos[k] = m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset);
			str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k+nIndexOffset,m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).m_dPosX, m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		CCoordPos ResultPos[3];
		scLine ResultLine[3];
		sc2Vector UsePoint[6];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;

		// 判断公共边是水平边还是垂直边
		scLine tpmLine = scLineSeg(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPos(), m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPos()).GetLine();
		double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
		BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;
		str.Format("修正前目标角点连线角度[-90,90): %f ,直线是否水平线: %d", tmpAngle, bHorDirection);
		AlignToolLogRecord(str,nPlatformIndex);

		if (bHorDirection == TRUE)
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[0].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
			UsePoint[1].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[1].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[2].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPosX());
				UsePoint[3].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[4].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPosX());
				UsePoint[5].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}
		else
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[0].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
			UsePoint[1].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[1].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[2].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPosX());
				UsePoint[3].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[4].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPosX());
				UsePoint[5].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}

		// 直线0和1交点，覆盖点0
		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
		}

		// 直线0和2交点，覆盖点1
		if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
		}

		for (k=0;k<2;k++)
		{
			str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k+nIndexOffset,m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).m_dPosX, m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<2;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).GetPosY();
			str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k+nIndexOffset,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	//================================================================================


	str.Format("------------------目标平台坐标计算结束");
	AlignToolLogRecord(str,nPlatformIndex);
	return m_TargetMarkPlatformPos;
}

// 获取目标Mark的全局平台坐标值(把各位置的平台坐标归一化到指定平台位置,用检查产品尺寸)
CMarkPlatformPos vcBaseAlignTool::GetTargetMarkPlatformPosForCheck()
{
	//针对每个相机的图像mark计算其平台坐标值
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("检查目标平台坐标计算开始------------------");
	AlignToolLogRecord(str,nPlatformIndex);
	int i=0;
	for (i=0; i<m_iMarkNum; i++)
	{	
		bool bFahl = GetUseAlignFAHLex();
		if (bFahl)
		{
			str.Format("目标平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);
			CCoordPos TargetPos;
			double H[9];
			{
				svStd vector<sc2Vector> TargetPoints; // 下面平面点
				TargetPoints.clear();
				svStd vector<sc2Vector> ObjectPoints;	//上面平面点
				ObjectPoints.clear();
				sc2Vector TargetPoint;
				sc2Vector ObjectPoint;
				for(int m=0;m<CALIBMOVEPOSNUM;m++)
				{
					if(m == 12)
					{
						continue;
					}
					TargetPoint.SetX(m_vAlignerCalibInfos.at(i)->m_cpTargetMarkImgCoordPos[m].m_dPosX);
					TargetPoint.SetY(m_vAlignerCalibInfos.at(i)->m_cpTargetMarkImgCoordPos[m].m_dPosY);
					ObjectPoint.SetX(m_vAlignerCalibInfos.at(i)->m_cpObjectMarkImgCoordPos[m].m_dPosX);
					ObjectPoint.SetY(m_vAlignerCalibInfos.at(i)->m_cpObjectMarkImgCoordPos[m].m_dPosY);
					TargetPoints.push_back(TargetPoint);
					ObjectPoints.push_back(ObjectPoint);
					str.Format("第%d个膜平面数据坐标:X%d:%f,Y%d:%f",m,m,ObjectPoint.GetX(),m,ObjectPoint.GetY());
					AlignToolLogRecord(str,0);
					str.Format("第%d个孔平面数据坐标:X%d:%f,Y%d:%f",m,m,TargetPoint.GetX(),m,TargetPoint.GetY());
					AlignToolLogRecord(str,0);
				}
				if(!sfGetHomography(TargetPoints,ObjectPoints,H))
					return m_TargetMarkPlatformPos;
				str.Format("矩阵:%f,%f,%f,%f,%f,%f,%f,%f,%f",H[0],H[1],H[2],H[3],H[4],H[5],H[6],H[7],H[8]);
				AlignToolLogRecord(str,i);
			}
			{
				sc2Vector TargetPointImg;
				sc2Vector ObjectPointImg;
				TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_dPosX);
				TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_dPosY);
				ObjectPointImg = sfHomographyProject(TargetPointImg,H);
				TargetPos.m_dPosX = ObjectPointImg.GetX();
				TargetPos.m_dPosY = ObjectPointImg.GetY();
				for(int j = 0; j < m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.size(); j++)
				{
					TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(j));
					TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(j));	
					ObjectPointImg = sfHomographyProject(TargetPointImg,H);
					TargetPos.m_vdAuxiliaryPosX.at(j) = ObjectPointImg.GetX();
					TargetPos.m_vdAuxiliaryPosY.at(j) = ObjectPointImg.GetY();
				}
			}	
			str.Format("胶框图像(在上平面中)坐标:CH%d: %f,%f；辅助点0：%f,%f；辅助点1：%f,%f;辅助点2：%f,%f  ",i,
				TargetPos.m_dPosX,TargetPos.m_dPosY,
				TargetPos.m_vdAuxiliaryPosX.at(0),TargetPos.m_vdAuxiliaryPosY.at(0),
				TargetPos.m_vdAuxiliaryPosX.at(1),TargetPos.m_vdAuxiliaryPosY.at(1),
				TargetPos.m_vdAuxiliaryPosX.at(2),TargetPos.m_vdAuxiliaryPosY.at(2));
			AlignToolLogRecord(str,m_nPlatformIndex);
			str.Format("[原图像坐标]胶框图像(在下平面中)坐标:CH%d: %f,%f；辅助点0：%f,%f；辅助点1：%f,%f;辅助点2：%f,%f    ",i,
				m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,
				m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(0),m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(0),
				m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(1),m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(1),
				m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(2),m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(2));
			AlignToolLogRecord(str,m_nPlatformIndex);
			{
				BOOL bflag = ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i, TargetPos,
					m_pTargetPlatformAxisPos.at(i)/*m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()-1)*/); // 用对象第二个位置的轴坐标，iyo
				str.Format("目标平台坐标%d结束",i);
				AlignToolLogRecord(str,nPlatformIndex);
			}
		}
		else // 一般情况
		{
			if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
			{
				str.Format("目标平台坐标%d开始",i);
				AlignToolLogRecord(str,nPlatformIndex);

				ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
					m_pTargetPlatformAxisPos.at(i));

				str.Format("目标平台坐标%d结束",i);
				AlignToolLogRecord(str,nPlatformIndex);
			}
			else
			{
				str.Format("目标平台坐标%d开始",i);
				AlignToolLogRecord(str,nPlatformIndex);

				if (m_bEnableMultiCalibExtension)
				{
					*((CPlatformXYAxisPos*)(m_vTargetCamPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpTargetCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
					*((CPlatformXYAxisPos*)(m_vTargetCamAxisPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
				}

				ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
					m_pTargetPlatformAxisPos.at(i), m_vTargetCamPlatformAxisPos.at(i), m_vTargetCamAxisPlatformAxisPos.at(i));

				str.Format("目标平台坐标%d结束",i);
				AlignToolLogRecord(str,nPlatformIndex);

			}
		}
// 		else // 一般情况
// 		{
// 			if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
// 			{
// 				str.Format("目标平台坐标%d开始",i);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
// 					m_pTargetPlatformAxisPos.at(i));
// 
// 				str.Format("目标平台坐标%d结束",i);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 			else
// 			{
// 				if (m_bEnableMultiCalibExtension)
// 				{
// 					*(m_vTargetCamPlatformAxisPos.at(i))=*(m_vvpTargetCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i));
// 					*(m_vTargetCamAxisPlatformAxisPos.at(i))=*(m_vvpTargetCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i));
// 				}
// 				ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_TargetSearchResults.m_vPos.at(i), 
// 					m_pTargetPlatformAxisPos.at(i), m_vTargetCamPlatformAxisPos.at(i), m_vTargetCamAxisPlatformAxisPos.at(i));
// 			}
// 		}

		m_TargetMarkPlatformPos.m_vbOK.at(i) = TRUE;
	}

	// 把各位置的平台坐标归一化到指定平台位置
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
	for (i=0; i<m_iMarkNum; i++)
	{
		// $2、实时目标Mark的图像坐标值转化为平台坐标值
		//目标mark为实时mark
		str.Format("目标图像坐标%d:TargetImageX=%f,TargetImageY=%f,TargetImageD=%f",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX,m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY,m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		// $3、对目标Mark的平台坐标值进行修正(平台XY轴移动影响影响结果)
		double dPlatformOffsetX = 0;
		double dPlatformOffsetY = 0;
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;


		// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
		if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}
		else
		{
			dPlatformOffsetX = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
			dPlatformOffsetY = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
		}

		if (m_bTargetObjectCamSeparate)
		{
			if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
			{
				CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at( i%(m_iMarkNum/2) )->GetPlatformAxisPos());
				dPlatformOffsetX = pPlatformBenchAxisPos->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = pPlatformBenchAxisPos->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
			}
			else
			{
// 				dPlatformOffsetX = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
// 				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 				dPlatformOffsetY = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
// 				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

				//CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at( i%(m_iMarkNum/2) )->GetPlatformAxisPos());
				//dPlatformOffsetX = pPlatformBenchAxisPos->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
				//if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				//dPlatformOffsetY = pPlatformBenchAxisPos->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
				//if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
			}
		}

		if (GetMidPlatformType()==ePlatformXYPD)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}		

		m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX -= dPlatformOffsetX;
		m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY -= dPlatformOffsetY;

		// 辅助位置
		//if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
		//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
		//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
		//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2
		//	|| (m_bTargetObjectCamSeparate && m_iMarkNum == 8 
		//		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		//			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		//			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4
		//			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_Weight
		//			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight)))
		{
			for(int j = 0; j < m_TargetMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.size(); j++)
			{
				m_TargetMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(j) -= dPlatformOffsetX;
				m_TargetMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(j) -= dPlatformOffsetY;
			}

		}

		str.Format("平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX,m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY,m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

	}

	//重新构造新的对位点//================================================================================
	if (m_bTargetObjectCamSeparate && m_iMarkNum == 8 
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		CCoordPos tmpPos[4];

		CString str;
		int k;
		for ( k=m_iMarkNum/2;k<m_iMarkNum;k++)
		{
			tmpPos[k-m_iMarkNum/2] = m_TargetMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_TargetMarkPlatformPos.m_vPos.at(k).m_dPosX,m_TargetMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		CCoordPos ResultPos[4];
		scLine ResultLine[4];
		sc2Vector UsePoint[8];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;
		UsePoint[0].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).GetAuxiliaryPosX(0));
		UsePoint[0].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).GetAuxiliaryPosY(0));
		UsePoint[1].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).GetAuxiliaryPosX(0));
		UsePoint[1].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).GetAuxiliaryPosY(0));
		ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

		UsePoint[2].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).GetAuxiliaryPosX(1));
		UsePoint[2].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).GetAuxiliaryPosY(1));
		UsePoint[3].SetX(m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).GetAuxiliaryPosX(1));
		UsePoint[3].SetY(m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).GetAuxiliaryPosY(1));
		ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

		UsePoint[4].SetX(m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).GetAuxiliaryPosX(0));
		UsePoint[4].SetY(m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).GetAuxiliaryPosY(0));
		UsePoint[5].SetX(m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).GetAuxiliaryPosX(0));
		UsePoint[5].SetY(m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).GetAuxiliaryPosY(0));
		ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		UsePoint[6].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).GetAuxiliaryPosX(1));
		UsePoint[6].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).GetAuxiliaryPosY(1));
		UsePoint[7].SetX(m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).GetAuxiliaryPosX(1));
		UsePoint[7].SetY(m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).GetAuxiliaryPosY(1));
		ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

		//lzk 0407 易天覆膜机-位置虚拟-目标检查模式
		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode&&m_bEnableTargetAndObjectPositionVirtualMode)
		{
			sc2Vector ResultPoint[4];
			// 目标位置虚拟模式:56拍照78虚拟
			if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 0)
			{
				//  5   6
				// (7) (8)
				ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
				ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点

				m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosX = ResultPoint[0].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosY = ResultPoint[0].GetY();
				m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosX = ResultPoint[1].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosY = ResultPoint[1].GetY();

// 				// 目标位置方向模式: 0：位置12水平
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					//  5   6
// 					// (7) (8)
// 					ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosX = ResultPoint[0].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosY = ResultPoint[0].GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosX = ResultPoint[1].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosY = ResultPoint[1].GetY();
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式:1：位置12竖直；
// 				{
// 					// (7)  5
// 					// (8)  6
// 
// 				}

				str.Format("目标位置虚拟模式：56拍照78虚拟");
				AlignToolLogRecord(str,nPlatformIndex);
			}
			// 目标位置虚拟模式:78拍照56虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 1)
			{
				// (5) (6)
				//  7   8
				ResultPoint[2] = ResultLine[2].Project(UsePoint[7]); // 计算给定点p在当前直线上的投影点
				ResultPoint[3] = ResultLine[2].Project(UsePoint[3]); // 计算给定点p在当前直线上的投影点

				m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosX = ResultPoint[2].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosY = ResultPoint[2].GetY();
				m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosX = ResultPoint[3].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosY = ResultPoint[3].GetY();


// 				// 目标位置方向模式: 0：位置12水平；
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					// (5) (6)
// 					//  7   8
// 					ResultPoint[2] = ResultLine[2].Project(UsePoint[7]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[3] = ResultLine[2].Project(UsePoint[3]); // 计算给定点p在当前直线上的投影点
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosX = ResultPoint[2].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosY = ResultPoint[2].GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosX = ResultPoint[3].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosY = ResultPoint[3].GetY();
// 
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式: 1：位置12竖直；
// 				{
// 					//	7  (5)
// 					//  8  (6)	
// 				}

				str.Format("目标位置虚拟模式：78拍照56虚拟");
				AlignToolLogRecord(str,nPlatformIndex);

			}
			// 目标位置虚拟模式:57拍照68虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 2)
			{
				//	5  (6)
				//  7  (8)
				ResultPoint[0] = ResultLine[3].Project(UsePoint[0]); // 计算给定点p在当前直线上的投影点
				ResultPoint[2] = ResultLine[3].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点

				m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosX = ResultPoint[0].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosY = ResultPoint[0].GetY();
				m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosX = ResultPoint[2].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosY = ResultPoint[2].GetY();


// 				// 目标位置方向模式: 0：位置12水平；
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					//	5  (6)
// 					//  7  (8)
// 					ResultPoint[0] = ResultLine[3].Project(UsePoint[0]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[2] = ResultLine[3].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosX = ResultPoint[0].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosY = ResultPoint[0].GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosX = ResultPoint[2].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosY = ResultPoint[2].GetY();
// 
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式: 1：位置12竖直；
// 				{
// 					//	7	5
// 					// (8) (6)	
// 				}

				str.Format("目标位置虚拟模式：57拍照68虚拟");
				AlignToolLogRecord(str,nPlatformIndex);

			}
			// 目标位置虚拟模式:68拍照57虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 3)
			{
				//	（5） 6
				//  （7） 8
				ResultPoint[1] = ResultLine[1].Project(UsePoint[1]); // 计算给定点p在当前直线上的投影点
				ResultPoint[3] = ResultLine[1].Project(UsePoint[5]); // 计算给定点p在当前直线上的投影点

				m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosX = ResultPoint[1].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosY = ResultPoint[1].GetY();
				m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosX = ResultPoint[3].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosY = ResultPoint[3].GetY();


// 				// 目标位置方向模式: 0：位置12水平；
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					//	（5） 6
// 					//  （7） 8
// 					ResultPoint[1] = ResultLine[1].Project(UsePoint[1]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[3] = ResultLine[1].Project(UsePoint[5]); // 计算给定点p在当前直线上的投影点
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosX = ResultPoint[1].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosY = ResultPoint[1].GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosX = ResultPoint[3].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosY = ResultPoint[3].GetY();
// 
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式: 1：位置12竖直；
// 				{
// 					//	  （7）（5）
// 					//		8    6
// 
// 				}

				str.Format("目标位置虚拟模式：68拍照57虚拟");
				AlignToolLogRecord(str,nPlatformIndex);
			}
			// 目标位置虚拟模式:57拍照68虚拟
			else
			{
				//  5   6
				// (7) (8)
				ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
				ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点

				m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosX = ResultPoint[0].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosY = ResultPoint[0].GetY();
				m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosX = ResultPoint[1].GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosY = ResultPoint[1].GetY();

// 				// 目标位置方向模式: 0：位置12水平
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					//  5   6
// 					// (7) (8)
// 					ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosX = ResultPoint[0].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosY = ResultPoint[0].GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosX = ResultPoint[1].GetX(); 
// 					m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosY = ResultPoint[1].GetY();
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式:1：位置12竖直；
// 				{
// 					// (7)  5
// 					// (8)  6
// 
// 				}

				str.Format("目标位置虚拟模式：56拍照78虚拟");
				AlignToolLogRecord(str,nPlatformIndex);

			}
		}
		else
		{
			if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosX = crossPointArray.at(0).GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(0+m_iMarkNum/2).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosX = crossPointArray.at(0).GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(1+m_iMarkNum/2).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosX = crossPointArray.at(0).GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(2+m_iMarkNum/2).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosX = crossPointArray.at(0).GetX(); 
				m_TargetMarkPlatformPos.m_vPos.at(3+m_iMarkNum/2).m_dPosY = crossPointArray.at(0).GetY();
			}

		}

		for (k=m_iMarkNum/2;k<m_iMarkNum;k++)
		{
			str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_TargetMarkPlatformPos.m_vPos.at(k).m_dPosX,m_TargetMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=m_iMarkNum/2;k<m_iMarkNum;k++)
		{
			double ddx = tmpPos[k-m_iMarkNum/2].GetPosX() - m_TargetMarkPlatformPos.m_vPos.at(k).GetPosX();
			double ddy = tmpPos[k-m_iMarkNum/2].GetPosY() - m_TargetMarkPlatformPos.m_vPos.at(k).GetPosY();
			str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	else if (!m_bTargetObjectCamSeparate && m_iMarkNum == 4 
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		CCoordPos tmpPos[4];
		CString str;
		int k;
		for ( k=0;k<m_iMarkNum;k++)
		{
			tmpPos[k] = m_TargetMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,tmpPos[k].m_dPosX,tmpPos[k].m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		CCoordPos ResultPos[4];
		scLine ResultLine[4];
		sc2Vector UsePoint[8];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;
		UsePoint[0] = m_TargetMarkPlatformPos.m_vPos[0].GetAuxPos(0);
		UsePoint[1] = m_TargetMarkPlatformPos.m_vPos[1].GetAuxPos(0);
		ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);
		UsePoint[2] = m_TargetMarkPlatformPos.m_vPos[1].GetAuxPos(1);
		UsePoint[3] = m_TargetMarkPlatformPos.m_vPos[3].GetAuxPos(1);
		ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);
		UsePoint[4] = m_TargetMarkPlatformPos.m_vPos[2].GetAuxPos(0);
		UsePoint[5] = m_TargetMarkPlatformPos.m_vPos[3].GetAuxPos(0);
		ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		UsePoint[6] = m_TargetMarkPlatformPos.m_vPos[0].GetAuxPos(1);
		UsePoint[7] = m_TargetMarkPlatformPos.m_vPos[2].GetAuxPos(1);
		ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);
		if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos[0].m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos[0].m_dPosY = crossPointArray.at(0).GetY();
		}
		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos[1].m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos[1].m_dPosY = crossPointArray.at(0).GetY();
		}
		if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos[2].m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos[2].m_dPosY = crossPointArray.at(0).GetY();
		}
		if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos[3].m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos[3].m_dPosY = crossPointArray.at(0).GetY();
		}
		for (k=0;k<m_iMarkNum;k++)
		{
			str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_TargetMarkPlatformPos.m_vPos[k].GetPosX(),m_TargetMarkPlatformPos.m_vPos[k].GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<m_iMarkNum;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_TargetMarkPlatformPos.m_vPos[k].GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_TargetMarkPlatformPos.m_vPos[k].GetPosY();
			str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4)||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		int nIndexOffset = (m_bTargetObjectCamSeparate && m_iMarkNum == 4) ? 2 : 0;

		CCoordPos tmpPos[2];
		int k = 0;
		for (k=0;k<2;k++)
		{
			tmpPos[k] = m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset);
			str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k+nIndexOffset,m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).m_dPosX, m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		CCoordPos ResultPos[3];
		scLine ResultLine[3];
		sc2Vector UsePoint[6];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;

		// 判断公共边是水平边还是垂直边
		scLine tpmLine = scLineSeg(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPos(), m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPos()).GetLine();
		double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
		BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;
		str.Format("修正前目标角点连线角度[-90,90): %f ,直线是否水平线: %d", tmpAngle, bHorDirection);
		AlignToolLogRecord(str,nPlatformIndex);

		if (bHorDirection == TRUE)
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[0].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
			UsePoint[1].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[1].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[2].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPosX());
				UsePoint[3].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[4].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPosX());
				UsePoint[5].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}
		else
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[0].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
			UsePoint[1].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[1].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[2].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPosX());
				UsePoint[3].SetY(m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[4].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPosX());
				UsePoint[5].SetY(m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}

		// 直线0和1交点，覆盖点0
		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos.at(0+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
		}

		// 直线0和2交点，覆盖点1
		if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
			m_TargetMarkPlatformPos.m_vPos.at(1+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
		}

		for (k=0;k<2;k++)
		{
			str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k+nIndexOffset,m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).m_dPosX, m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<2;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_TargetMarkPlatformPos.m_vPos.at(k+nIndexOffset).GetPosY();
			str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k+nIndexOffset,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	//================================================================================

	//lzk 0407 易天覆膜机-位置虚拟-目标检查模式
	if ((m_bTargetObjectCamSeparate && m_iMarkNum == 8) && m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
	{
		str.Format("---开始根据目标产品尺寸计算虚拟对位点---");
		AlignToolLogRecord(str,nPlatformIndex);

		double dTargetX[8];			//存储目标mark图像坐标
		double dTargetY[8];
		double dTargetD[8];
		memset(dTargetX, 0.0, sizeof(double)*8);
		memset(dTargetY, 0.0, sizeof(double)*8);
		memset(dTargetD, 0.0, sizeof(double)*8);

		for(int i = 0; i < m_iMarkNum; i++)
		{
			dTargetX[i] = m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX();
			dTargetY[i] = m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY();
			dTargetD[i] = m_TargetMarkPlatformPos.m_vPos.at(i).GetAngle();
		}

		{
			//根据目标产品尺寸和目标56/78平台坐标虚拟目标78/56平台坐标 
			if ((m_AlignermentParam.GetProductSizeInfo().m_dTargetL2 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dTargetW2 <= 0))
			{
				str.Format("目标尺寸信息错误:TargetL2=%f,TargetW2=%f",m_AlignermentParam.GetProductSizeInfo().m_dTargetL2,m_AlignermentParam.GetProductSizeInfo().m_dTargetW2);
				AlignToolLogRecord(str,nPlatformIndex);

				str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
				AlignToolLogRecord(str,nPlatformIndex);

				return m_TargetMarkPlatformPos;
			}

			str.Format("目标尺寸信息:TargetL2=%f,TargetW2=%f",m_AlignermentParam.GetProductSizeInfo().m_dTargetL2,m_AlignermentParam.GetProductSizeInfo().m_dTargetW2);
			AlignToolLogRecord(str,nPlatformIndex);

			// 目标位置虚拟模式:56拍照78虚拟	
			if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 0)
			{
				//	5   6
				// (7) (8)
				sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
				sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
				double dXLength = (ptTarget6 - ptTarget5).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
				scRadian xRot;
				(ptTarget6 - ptTarget5).Angle(xRot);
				xRot = xRot.SignedNormMod180();

				str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));

				ptTarget5 = affrect.GetCornerPo();
				ptTarget6 = affrect.GetCornerPx();
				sc2Vector ptTarget7 = affrect.GetCornerPy();
				sc2Vector ptTarget8 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosX = ptTarget7.GetX();
				m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosY = ptTarget7.GetY();
				m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosX = ptTarget8.GetX();
				m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosY = ptTarget8.GetY();


// 				// 目标位置方向模式: 0：位置56水平
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					//	5   6
// 					// (7) (8)
// 					sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
// 					sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
// 					double dXLength = (ptTarget6 - ptTarget5).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
// 					scRadian xRot;
// 					(ptTarget6 - ptTarget5).Angle(xRot);
// 					xRot = xRot.SignedNormMod180();
// 
// 					str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));
// 
// 					ptTarget5 = affrect.GetCornerPo();
// 					ptTarget6 = affrect.GetCornerPx();
// 					sc2Vector ptTarget7 = affrect.GetCornerPy();
// 					sc2Vector ptTarget8 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosX = ptTarget7.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosY = ptTarget7.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosX = ptTarget8.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosY = ptTarget8.GetY();
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式:1：位置56竖直；
// 				{
// 					//	(7)  5
// 					//  (8)  6
// 					sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
// 					sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
// 					double dXLength = (ptTarget6 - ptTarget5).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
// 					scRadian xRot;
// 					(ptTarget6 - ptTarget5).Angle(xRot);
// 					xRot = xRot.NormMod180();
// 
// 					str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));
// 
// 					ptTarget5 = affrect.GetCornerPo();
// 					ptTarget6 = affrect.GetCornerPx();
// 					sc2Vector ptTarget7 = affrect.GetCornerPy();
// 					sc2Vector ptTarget8 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosX = ptTarget7.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosY = ptTarget7.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosX = ptTarget8.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosY = ptTarget8.GetY();
// 				}
// 				else
// 				{
// 					return m_TargetMarkPlatformPos;
// 				}

			}
			// 目标位置虚拟模式:78拍照56虚拟	
			else if(m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 1)
			{
				// (5) (6)
				//  7   8
				sc2Vector ptTarget7 = sc2Vector(dTargetX[6], dTargetY[6]);
				sc2Vector ptTarget8 = sc2Vector(dTargetX[7], dTargetY[7]);
				double dXLength = (ptTarget8 - ptTarget7).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
				scRadian xRot;
				(ptTarget8 - ptTarget7).Angle(xRot);
				xRot = xRot.SignedNormMod180();

				str.Format("目标78坐标:7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标78连线角度:78Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget7, dXLength, dYLength, xRot, scRadian(skPI));

				ptTarget7 = affrect.GetCornerPo();
				ptTarget8 = affrect.GetCornerPx();
				sc2Vector ptTarget5 = affrect.GetCornerPy();
				sc2Vector ptTarget6 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosX = ptTarget5.GetX();
				m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosY = ptTarget5.GetY();
				m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosX = ptTarget6.GetX();
				m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosY = ptTarget6.GetY();


// 				// 目标位置方向模式: 0：位置56水平
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					// (5) (6)
// 					//  7   8
// 					sc2Vector ptTarget7 = sc2Vector(dTargetX[6], dTargetY[6]);
// 					sc2Vector ptTarget8 = sc2Vector(dTargetX[7], dTargetY[7]);
// 					double dXLength = (ptTarget8 - ptTarget7).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
// 					scRadian xRot;
// 					(ptTarget8 - ptTarget7).Angle(xRot);
// 					xRot = xRot.SignedNormMod180();
// 
// 					str.Format("目标78坐标:7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标78连线角度:78Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget7, dXLength, dYLength, xRot, scRadian(skPI));
// 
// 					ptTarget7 = affrect.GetCornerPo();
// 					ptTarget8 = affrect.GetCornerPx();
// 					sc2Vector ptTarget5 = affrect.GetCornerPy();
// 					sc2Vector ptTarget6 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosX = ptTarget5.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosY = ptTarget5.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosX = ptTarget6.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosY = ptTarget6.GetY();
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式:1：位置56竖直；
// 				{
// 					//	7  (5)
// 					//  8  (6)
// 					sc2Vector ptTarget7 = sc2Vector(dTargetX[6], dTargetY[6]);
// 					sc2Vector ptTarget8 = sc2Vector(dTargetX[7], dTargetY[7]);
// 					double dXLength = (ptTarget8 - ptTarget7).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
// 					scRadian xRot;
// 					(ptTarget8 - ptTarget7).Angle(xRot);
// 					xRot = xRot.NormMod180();
// 
// 					str.Format("目标78坐标:7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标78连线角度:78Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget7, dXLength, dYLength, xRot, scRadian(skPI));
// 
// 					ptTarget7 = affrect.GetCornerPo();
// 					ptTarget8 = affrect.GetCornerPx();
// 					sc2Vector ptTarget5 = affrect.GetCornerPy();
// 					sc2Vector ptTarget6 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosX = ptTarget5.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosY = ptTarget5.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosX = ptTarget6.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosY = ptTarget6.GetY();
// 				}
// 				else
// 				{
// 					return m_TargetMarkPlatformPos;
// 				}

			}
			// 目标位置虚拟模式:57拍照68虚拟	
			else if(m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 2)
			{
				//	5  (6)
				//  7 （8）
				sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
				sc2Vector ptTarget7 = sc2Vector(dTargetX[6], dTargetY[6]);
				double dYLength = (ptTarget7 - ptTarget5).Length();
				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
				scRadian xRot;
				(ptTarget7 - ptTarget5).Angle(xRot);
				xRot = xRot.NormMod180();

				str.Format("目标57坐标:5X=%f,5Y=%f,7X=%f,7Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget7.GetX(),ptTarget7.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标57连线角度:57Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dYLength, dXLength, xRot, scRadian(skPI));

				ptTarget5 = affrect.GetCornerPo();
				ptTarget7 = affrect.GetCornerPx();
				sc2Vector ptTarget6 = affrect.GetCornerPy();
				sc2Vector ptTarget8 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosX = ptTarget6.GetX();
				m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosY = ptTarget6.GetY();
				m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosX = ptTarget8.GetX();
				m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosY = ptTarget8.GetY();

// 				// 目标位置方向模式: 0：位置56水平
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					//	5  (6)
// 					//  7 （8）
// 					sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
// 					sc2Vector ptTarget7 = sc2Vector(dTargetX[6], dTargetY[6]);
// 					double dYLength = (ptTarget7 - ptTarget5).Length();
// 					double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
// 					scRadian xRot;
// 					(ptTarget7 - ptTarget5).Angle(xRot);
// 					xRot = xRot.NormMod180();
// 
// 					str.Format("目标57坐标:5X=%f,5Y=%f,7X=%f,7Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget7.GetX(),ptTarget7.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标57连线角度:57Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dYLength, dXLength, xRot, scRadian(skPI));
// 
// 					ptTarget5 = affrect.GetCornerPo();
// 					ptTarget7 = affrect.GetCornerPx();
// 					sc2Vector ptTarget6 = affrect.GetCornerPy();
// 					sc2Vector ptTarget8 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosX = ptTarget6.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosY = ptTarget6.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosX = ptTarget8.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosY = ptTarget8.GetY();
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式: 1：位置56竖直；
// 				{
// 					//	  7    5
// 					//  （8） (6)
// 					sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
// 					sc2Vector ptTarget7 = sc2Vector(dTargetX[6], dTargetY[6]);
// 					double dXLength = (ptTarget5 - ptTarget7).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
// 					scRadian xRot;
// 					(ptTarget5 - ptTarget7).Angle(xRot);
// 					xRot = xRot.NormMod180();
// 
// 					str.Format("目标57坐标:5X=%f,5Y=%f,7X=%f,7Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget7.GetX(),ptTarget7.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标75连线角度:78Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget7, dXLength, dYLength, xRot, scRadian(0));
// 
// 					ptTarget7 = affrect.GetCornerPo();
// 					ptTarget5 = affrect.GetCornerPx();
// 					sc2Vector ptTarget8 = affrect.GetCornerPy();
// 					sc2Vector ptTarget6 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosX = ptTarget6.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(5).m_dPosY = ptTarget6.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosX = ptTarget8.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosY = ptTarget8.GetY();
// 				}
// 				else
// 				{
// 					return m_TargetMarkPlatformPos;
// 				}

			}
			// 目标位置虚拟模式:68拍照57虚拟	
			else if(m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 3)
			{
				//  （5）  6
				//  （7）  8
				sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
				sc2Vector ptTarget8 = sc2Vector(dTargetX[7], dTargetY[7]);
				double dYLength = (ptTarget8 - ptTarget6).Length();
				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
				scRadian xRot;
				(ptTarget8 - ptTarget6).Angle(xRot);
				xRot = xRot.NormMod180();

				str.Format("目标68坐标:6X=%f,6Y=%f,8X=%f,8Y=%f",ptTarget6.GetX(),ptTarget6.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标68连线角度:68Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget6, dYLength, dXLength, xRot, scRadian(0));

				ptTarget6 = affrect.GetCornerPo();
				ptTarget8 = affrect.GetCornerPx();
				sc2Vector ptTarget5 = affrect.GetCornerPy();
				sc2Vector ptTarget7 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosX = ptTarget5.GetX();
				m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosY = ptTarget5.GetY();
				m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosX = ptTarget7.GetX();
				m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosY = ptTarget7.GetY();


// 				// 目标位置方向模式: 0：位置56水平
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					//  （5）  6
// 					//  （7）  8
// 					sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
// 					sc2Vector ptTarget8 = sc2Vector(dTargetX[7], dTargetY[7]);
// 					double dYLength = (ptTarget8 - ptTarget6).Length();
// 					double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
// 					scRadian xRot;
// 					(ptTarget8 - ptTarget6).Angle(xRot);
// 					xRot = xRot.NormMod180();
// 
// 					str.Format("目标68坐标:6X=%f,6Y=%f,8X=%f,8Y=%f",ptTarget6.GetX(),ptTarget6.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标68连线角度:68Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget6, dYLength, dXLength, xRot, scRadian(0));
// 
// 					ptTarget6 = affrect.GetCornerPo();
// 					ptTarget8 = affrect.GetCornerPx();
// 					sc2Vector ptTarget5 = affrect.GetCornerPy();
// 					sc2Vector ptTarget7 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosX = ptTarget5.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosY = ptTarget5.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosX = ptTarget7.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosY = ptTarget7.GetY();
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式: 0：位置56水平；1：位置56竖直；
// 				{
// 					//	(7)  (5)
// 					//   8    6
// 					sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
// 					sc2Vector ptTarget8 = sc2Vector(dTargetX[7], dTargetY[7]);
// 					double dXLength = (ptTarget6 - ptTarget8).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
// 					scRadian xRot;
// 					(ptTarget6 - ptTarget8).Angle(xRot);
// 					xRot = xRot.SignedNormMod180();
// 
// 					str.Format("目标68坐标:6X=%f,6Y=%f,8X=%f,8Y=%f",ptTarget6.GetX(),ptTarget6.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标68连线角度:78Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget8, dXLength, dYLength, xRot, scRadian(skPI));
// 
// 					ptTarget8 = affrect.GetCornerPo();
// 					ptTarget6 = affrect.GetCornerPx();
// 					sc2Vector ptTarget7 = affrect.GetCornerPy();
// 					sc2Vector ptTarget5 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosX = ptTarget5.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosY = ptTarget5.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosX = ptTarget7.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosY = ptTarget7.GetY();
// 				}
// 				else
// 				{
// 					return m_TargetMarkPlatformPos;
// 				}

			}
			// 目标位置虚拟模式:56拍照78虚拟	
			else
			{
// 				// 目标位置方向模式: 0：位置56水平
// 				if (m_bTargetPositionDirectionMode == 0)
// 				{
// 					//	5   6
// 					// (7) (8)
// 					sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
// 					sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
// 					double dXLength = (ptTarget6 - ptTarget5).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
// 					scRadian xRot;
// 					(ptTarget6 - ptTarget5).Angle(xRot);
// 					xRot = xRot.SignedNormMod180();
// 
// 					str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));
// 
// 					ptTarget5 = affrect.GetCornerPo();
// 					ptTarget6 = affrect.GetCornerPx();
// 					sc2Vector ptTarget7 = affrect.GetCornerPy();
// 					sc2Vector ptTarget8 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosX = ptTarget7.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosY = ptTarget7.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosX = ptTarget8.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosY = ptTarget8.GetY();
// 				}
// 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式:1：位置56竖直；
// 				{
// 					//	(7)  5
// 					//  (8)  6
// 					sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
// 					sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
// 					double dXLength = (ptTarget6 - ptTarget5).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
// 					scRadian xRot;
// 					(ptTarget6 - ptTarget5).Angle(xRot);
// 					xRot = xRot.NormMod180();
// 
// 					str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));
// 
// 					ptTarget5 = affrect.GetCornerPo();
// 					ptTarget6 = affrect.GetCornerPx();
// 					sc2Vector ptTarget7 = affrect.GetCornerPy();
// 					sc2Vector ptTarget8 = affrect.GetCornerPopp();
// 
// 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosX = ptTarget7.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(6).m_dPosY = ptTarget7.GetY();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosX = ptTarget8.GetX();
// 					m_TargetMarkPlatformPos.m_vPos.at(7).m_dPosY = ptTarget8.GetY();
// 				}
// 				else
// 				{
// 					return m_TargetMarkPlatformPos;
// 				}

			}

			str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
			AlignToolLogRecord(str,nPlatformIndex);

		}

	}

	str.Format("------------------检查目标平台坐标计算结束");
	AlignToolLogRecord(str,nPlatformIndex);

	return m_TargetMarkPlatformPos;
}

// 一组目标相机对应两组对象相机
// CMarkPlatformPos vcBaseAlignTool::GetSpecialTargetMarkPlatformPos()
// {
// 	if (m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		int nPlatformIndex = m_nPlatformIndex;
// 		CString str;
// 		str.Format(_T("扩展编号为%d的目标平台坐标计算开始------------------"),m_nAlignnExProductIndex);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 		for (int i = 0; i < m_iMarkNum; i++)
// 		{
// 			m_TargetMarkPlatformPos.m_vPos.at(i) = CCoordPos(0, 0, 0);
// 			m_TargetMarkPlatformPos.m_vbOK.at(i) = FALSE;
// 		}
// 
// 		if (m_iMarkNum == 8)
// 		{
// 			int nMark = m_iMarkNum/2;
// 			int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;
// 
// 			for (int i=0; i<m_iMarkNum/4; i++)
// 			{	
// 				if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
// 				{
// 					str.Format("目标平台坐标%d开始",i + nMark + nExMark);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_TargetMarkPlatformPos.m_vbOK.at(i + nMark + nExMark) = 
// 						ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i + nMark + nExMark),  i + nMark + nExMark, m_TargetSearchResults.m_vPos.at(i + nMark + nExMark), 
// 						m_pTargetPlatformAxisPos.at(i + nMark + nExMark));
// 
// 					str.Format("目标平台坐标%d结束",i + nMark + nExMark);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 				}
// 				else
// 				{
// 					m_TargetMarkPlatformPos.m_vbOK.at(i + nMark + nExMark) = 
// 						ConvertImagePosToCurPlatformPos(m_TargetMarkPlatformPos.m_vPos.at(i + nMark + nExMark), i + nMark + nExMark, m_TargetSearchResults.m_vPos.at(i + nMark + nExMark), 
// 						m_pTargetPlatformAxisPos.at(i + nMark + nExMark), m_vTargetCamPlatformAxisPos.at(i + nMark + nExMark));
// 				}
// 
// 				//				m_TargetMarkPlatformPos.m_vbOK.at(i + nMark + nExMark) = TRUE;
// 			}
// 		}
// 
// 		str.Format(_T("------------------扩展编号为%d的目标平台坐标计算结束"),m_nAlignnExProductIndex);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 	}
// 
// 	return m_TargetMarkPlatformPos;
// 
// }

// 获取目标平台坐标距离，八字对位使用
BOOL vcBaseAlignTool::GetTargetMarkPlatformDistance(double &dDistance)
{

	if (!m_TargetMarkPlatformPos.IsAllMarkPlatformPosOK())
	{
		return FALSE;
	}

	sc2Vector vMark[2];	
	dDistance = 0;

	if (m_iMarkNum == 2)
	{

		// 计算目标距离
		vMark[0].SetX(m_TargetMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX);
		vMark[0].SetY(m_TargetMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY);
		vMark[1].SetX(m_TargetMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX);
		vMark[1].SetY(m_TargetMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY);
		dDistance = vMark[0].Distance(vMark[1]);


	}
	else if (m_iMarkNum == 4 && m_bTargetObjectCamSeparate == TRUE)
	{

		// 计算目标距离
		vMark[0].SetX(m_TargetMarkPlatformPos.GetMarkPlatformPos(2).m_dPosX);
		vMark[0].SetY(m_TargetMarkPlatformPos.GetMarkPlatformPos(2).m_dPosY);
		vMark[1].SetX(m_TargetMarkPlatformPos.GetMarkPlatformPos(3).m_dPosX);
		vMark[1].SetY(m_TargetMarkPlatformPos.GetMarkPlatformPos(3).m_dPosY);
		dDistance = vMark[0].Distance(vMark[1]);


	}
	else if (m_iMarkNum == 8 && m_bTargetObjectCamSeparate == TRUE)
	{
		// 计算目标距离

		vMark[0].SetX(m_TargetMarkPlatformPos.GetMarkPlatformPos(4).m_dPosX);
		vMark[0].SetY(m_TargetMarkPlatformPos.GetMarkPlatformPos(4).m_dPosY);
		vMark[1].SetX(m_TargetMarkPlatformPos.GetMarkPlatformPos(5).m_dPosX);
		vMark[1].SetY(m_TargetMarkPlatformPos.GetMarkPlatformPos(5).m_dPosY);
		dDistance= vMark[0].Distance(vMark[1]);
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

// XY+D平台，目标角度旋转后的平台坐标
CCoordPos vcBaseAlignTool::GetImageCoordPosAfterRotate(int nPosIndex)
{
	if (nPosIndex<0 || nPosIndex>=MAXTARGETPOS)
	{
		CCoordPos coordPos;
		return coordPos;
	}

	//for(int i=0;i<MAXTARGETPOS;i++)
	{
		CCoordPos platformPos;
		platformPos.m_dPosX = m_dTargetX[nPosIndex];
		platformPos.m_dPosY = m_dTargetY[nPosIndex];

		ConvertCurPlatformPosToImagePos(m_ImageCoordPos[nPosIndex],nPosIndex,platformPos,m_pTargetPlatformAxisPos.at(nPosIndex));
	}

	return m_ImageCoordPos[nPosIndex];
}

// 根据目标图像到对象图像映射结果，将目标图像坐标映射到对象图像中
BOOL vcBaseAlignTool::ConvertTarImgPosToObjImgPosUsingImageHomographyProject(CCoordPos& ObjImgPos, int nIndex, CCoordPos TarImgPos)
{
	// 应用场景要求目标和对象分离，并且关联标定不使用靶标，不读取轴位置
	if (FALSE == m_bTargetObjectCamSeparate/* || TRUE == m_bTargetCalibUseBoard || FALSE == m_bTarObjCamSepNoAxisCalib*/)
	{
		return FALSE;
	}

	// 索引值只能为目标索引
	if (nIndex<m_iMarkNum/2 || nIndex>m_iMarkNum)
	{
		return FALSE;
	}

	if (TRUE == m_bTarObjCamSepNoAxisCalib) //像素映射，不考虑轴位置
	{
		sc2Vector vSrcTarget;
		sc2Vector vDstObject;
		vSrcTarget.SetX(TarImgPos.m_dPosX);
		vSrcTarget.SetY(TarImgPos.m_dPosY);

		// 图像坐标系投影映射
		if (GetMidPlatformType() == ePlatformXYPD && m_bTargetObjectCamSeparate)
		{
			vDstObject = sfHomographyInverseProject(vSrcTarget, m_vAlignerCalibInfos.at(nIndex-m_iMarkNum/2)->m_PlatformTranferH);
		}
		else
		{
			vDstObject = sfHomographyProject(vSrcTarget, m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
		}
		

		ObjImgPos.m_dPosX = vDstObject.GetX();
		ObjImgPos.m_dPosY = vDstObject.GetY();

		CString str;
		str.Format("目标%d图像坐标：X=%f,Y=%f", nIndex, TarImgPos.m_dPosX, TarImgPos.m_dPosY);
		AlignToolLogRecord(str, m_nPlatformIndex);
		str.Format("目标%d映射到对象图像坐标：X=%f,Y=%f", nIndex, ObjImgPos.m_dPosX, ObjImgPos.m_dPosY);
		AlignToolLogRecord(str, m_nPlatformIndex);
	}
	else
	{
		//计算目标平台坐标
		CCoordPos TarMarkPlatformPos;	

		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() ||eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{

			ConvertImagePosToCurPlatformPos(TarMarkPlatformPos,  nIndex, TarImgPos, 
				m_pTargetPlatformAxisPos.at(nIndex));
		}
		else
		{
			ConvertImagePosToCurPlatformPos(TarMarkPlatformPos,nIndex, TarImgPos, 
				m_pTargetPlatformAxisPos.at(nIndex), m_vTargetCamPlatformAxisPos.at(nIndex));
		}

		//转换为对象位置图像坐标
		if (!ConvertCurPlatformPosToImagePos(ObjImgPos,nIndex-m_iMarkNum/2 ,TarMarkPlatformPos,m_pTargetPlatformAxisPos.at(nIndex/*-m_iMarkNum/2*/ )))
		{
			return FALSE;
		}

	}


	return TRUE;
}

// 将当前平台坐标转化为图像坐标
bool vcBaseAlignTool::ConvertCurPlatformPosToImagePos(CCoordPos &imageCoordPos, int nIndex, CCoordPos platformCoordPos, CPlatformAxisPos* pPlatformAxisPos)
{
	if (m_bTargetObjectCamSeparate == TRUE && m_bTarObjCamSepNoAxisCalib == TRUE
		&&((GetMidPlatformType() != ePlatformXYPD && nIndex >= m_iMarkNum/2)
		||(GetMidPlatformType() == ePlatformXYPD && nIndex < m_iMarkNum/2))
		)
	{
		// 如果是相机分离的，且标定目标（或XY+D平台对象）位置时不用平台轴位置，而是直接将目标相机与对象相机映射的情况
		// 转换图像坐标到平台坐标

		int nBaseIndex = nIndex - m_iMarkNum/2;
		if (GetMidPlatformType() == ePlatformXYPD)
		{
			// 当平台为XY+D平台时，对象图像坐标转换到目标平台坐标系下
			// 例如：4相机2Vs2时，对象位置0、位置1转换到目标位置2、位置3的平台坐标系下，即基础的索引为2、3
			nBaseIndex = nIndex + m_iMarkNum/2;
		}
		else
		{
			// 当平台是XYD平台等（不是XY+D平台）时，目标图像坐标转换到对象平台坐标系下，
			// 例如：4相机2Vs2时，目标位置2、位置3转换到对象位置0、位置1的平台坐标系下，即基础的索引为0、1
			nBaseIndex = nIndex - m_iMarkNum/2;
		}

		if (nIndex<0 || nIndex >= m_iMarkNum)
			return false;

		if (NULL == m_vAlignerCalibInfos.at(nIndex))
			return false;
		if (NULL == m_vAlignerCalibInfos.at(nBaseIndex))
			return false;

		if (m_PlatformCalibType == ePlatformCalib9Point)
		{
			if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
			{
				return false;
			}
			if (!m_vAlignerCalibInfos.at(nBaseIndex)->IsValid())
			{
				return false;
			}
		}
		int nPlatformIndex = m_nPlatformIndex;
		CString str;
		//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
		//相机平台类型没有基类，不用改；
		CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex)->GetPlatformAxisPos());
		CPlatformXYDAxisPos*  pPlatformXYDAxisPos =		 (CPlatformXYDAxisPos*)pPlatformAxisPos;
		CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 
		//	CString str;

		if (NULL == pPlatformBenchAxisPos || NULL == pPlatformXYDAxisPos  || NULL == pPlatformParam)
		{
			return false;
		}

		str.Format("轴基准坐标：X=%f,Y=%f,D=%f",pPlatformBenchAxisPos->m_dPosX,pPlatformBenchAxisPos->m_dPosY,pPlatformBenchAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("当前轴坐标：X=%f,Y=%f,D=%f",pPlatformXYDAxisPos->m_dPosX,pPlatformXYDAxisPos->m_dPosY,pPlatformXYDAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
		//标定参数
		double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkPlatformCoordPos().GetPosX();
		double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkPlatformCoordPos().GetPosY();
		//平台各轴的方向	
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

		// 实际平台XY轴偏移量
		double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
		double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;

		if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
		if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
		if ( GetMidPlatformType() ==ePlatformXDPY || GetMidPlatformType() ==ePlatformXDPY1)
		{
			dPlatformOffsetY =0 ;
		}
		else if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
		{

		}
		else if ( GetMidPlatformType() ==ePlatformXYPD)
		{
			dPlatformOffsetX =0 ;
			dPlatformOffsetY =0 ;
		}


		str.Format("Mark平台基准位置：X=%f,Y=%f",dPlatformBenchMarkX,dPlatformBenchMarkY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("轴平移量：X=%f,Y=%f",dPlatformOffsetX,dPlatformOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		//平台XY平移量对基准mark平台坐标的影响方向相反
		dPlatformBenchMarkX -= dPlatformOffsetX;
		dPlatformBenchMarkY -= dPlatformOffsetY;

		double dImgOffsetRealDistanceX = 0;
		double dImgOffsetRealDistanceY = 0;

		//图像偏差距离等于当前平台坐标减去基准平台坐标
		dImgOffsetRealDistanceX = platformCoordPos.m_dPosX - dPlatformBenchMarkX;
		dImgOffsetRealDistanceY = platformCoordPos.m_dPosY - dPlatformBenchMarkY ;
		str.Format("图像像素平台移动量：X=%f,Y=%f",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
		AlignToolLogRecord(str,nPlatformIndex);

		// $2、根据标定后得到的变换矩阵和像素位置偏差对应的实际平台移动量基准Mark的图像坐标值，计算图像坐标

		double dImgOffsetX = 0;//imageDstObjectCoordPos.m_dPosX - m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosX;
		double dImgOffsetY = 0;//imageDstObjectCoordPos.m_dPosY - m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosY;
		sc2Matrix matrix = m_vAlignerCalibInfos.at(nBaseIndex)->GetPlatformTransferMatrix();
		sc2Matrix invertMatrix;
		if (HSuccess !=matrix.Inverse(invertMatrix))
		{
			return FALSE;
		}
		dImgOffsetX  = invertMatrix.GetElement(0,0)*dImgOffsetRealDistanceX+ invertMatrix.GetElement(0,1)*dImgOffsetRealDistanceY;
		dImgOffsetY  = invertMatrix.GetElement(1,0)*dImgOffsetRealDistanceX+ invertMatrix.GetElement(1,1)*dImgOffsetRealDistanceY;



		str.Format("基准图像位置：X=%f,Y=%f",m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosX,m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);	
		str.Format("图像像素移动量：X=%f,Y=%f",dImgOffsetX,dImgOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		{
			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vDst.SetX(dImgOffsetRealDistanceX);
				vDst.SetY(dImgOffsetRealDistanceY);
				vSrc = sfHomographyInverseProject(vDst,m_vAlignerCalibInfos.at(nBaseIndex)->m_PlatformTranferH);
				dImgOffsetX= vSrc.GetX();
				dImgOffsetY= vSrc.GetY();
			}
		}

		str.Format("图像像素偏差：X=%f,Y=%f",dImgOffsetX,dImgOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);


		// $4、内容相加，即为相机实时Mark的平台坐标值
		CCoordPos imageDstObjectCoordPos;

		imageDstObjectCoordPos.m_dPosX = m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosX + dImgOffsetX ;
		imageDstObjectCoordPos.m_dPosY = m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosY + dImgOffsetY ;

		str.Format("像素坐标标值：X=%f,Y=%f",imageDstObjectCoordPos.m_dPosX,imageDstObjectCoordPos.m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);

		// 将对象相机的图像坐标转换为目标相机的图像坐标
		sc2Vector vSrcTarget;
		sc2Vector vDstObject;
		vDstObject.SetX(imageDstObjectCoordPos.m_dPosX);
		vDstObject.SetY(imageDstObjectCoordPos.m_dPosY);
		vSrcTarget = sfHomographyInverseProject(vDstObject,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);

		imageCoordPos.m_dPosX = vSrcTarget.GetX();
		imageCoordPos.m_dPosY = vSrcTarget.GetY();


		str.Format("映射像素坐标标值：X=%f,Y=%f",imageCoordPos.m_dPosX,imageCoordPos.m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		return true;
	}
	else
	{
		if (nIndex<0 || nIndex >= m_iMarkNum)
			return false;

		if (NULL == m_vAlignerCalibInfos.at(nIndex))
			return false;

		if (m_PlatformCalibType == ePlatformCalib9Point)
		{
			if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
			{
				return false;
			}
		}
		int nPlatformIndex = m_nPlatformIndex;
		CString str;
		//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
		//相机平台类型没有基类，不用改；
		CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetPlatformAxisPos());
		CPlatformXYDAxisPos*  pPlatformXYDAxisPos =		 (CPlatformXYDAxisPos*)pPlatformAxisPos;
		CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 
		//	CString str;

		if (NULL == pPlatformBenchAxisPos || NULL == pPlatformXYDAxisPos  || NULL == pPlatformParam)
		{
			return false;
		}

		str.Format("轴基准坐标：X=%f,Y=%f,D=%f",pPlatformBenchAxisPos->m_dPosX,pPlatformBenchAxisPos->m_dPosY,pPlatformBenchAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("当前轴坐标：X=%f,Y=%f,D=%f",pPlatformXYDAxisPos->m_dPosX,pPlatformXYDAxisPos->m_dPosY,pPlatformXYDAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
		//标定参数
		double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosX();
		double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosY();
		//平台各轴的方向	
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

		// 实际平台XY轴偏移量
		double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
		double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;

		if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
		if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
		if ( GetMidPlatformType() ==ePlatformXDPY || GetMidPlatformType() ==ePlatformXDPY1)
		{
			dPlatformOffsetY =0 ;
		}
		else if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
		{

		}
		else if ( GetMidPlatformType() ==ePlatformXYPD || GetMidPlatformType() ==ePlatformXY || GetMidPlatformType() == ePlatformX || GetMidPlatformType() == ePlatformY)
		{
			dPlatformOffsetX =0 ;
			dPlatformOffsetY =0 ;
		}


		str.Format("Mark平台基准位置：X=%f,Y=%f",dPlatformBenchMarkX,dPlatformBenchMarkY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("轴平移量：X=%f,Y=%f",dPlatformOffsetX,dPlatformOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		//平台XY平移量对基准mark平台坐标的影响方向相反
		dPlatformBenchMarkX -= dPlatformOffsetX;
		dPlatformBenchMarkY -= dPlatformOffsetY;


		// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
		double dImgOffsetRealDistanceX = 0;
		double dImgOffsetRealDistanceY = 0;

		//图像偏差距离等于当前平台坐标减去基准平台坐标
		dImgOffsetRealDistanceX = platformCoordPos.m_dPosX - dPlatformBenchMarkX;
		dImgOffsetRealDistanceY = platformCoordPos.m_dPosY - dPlatformBenchMarkY ;

		str.Format("图像偏差带来的平台距离：X=%f,Y=%f",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
		AlignToolLogRecord(str,nPlatformIndex);

		// $2、根据标定后得到的变换矩阵和像素位置偏差对应的实际平台移动量基准Mark的图像坐标值，计算图像坐标

		double dImgOffsetX = 0;//imageDstObjectCoordPos.m_dPosX - m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosX;
		double dImgOffsetY = 0;//imageDstObjectCoordPos.m_dPosY - m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosY;
		sc2Matrix matrix = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix();
		sc2Matrix invertMatrix;
		if (HSuccess !=matrix.Inverse(invertMatrix))
		{
			return FALSE;
		}
		dImgOffsetX  = invertMatrix.GetElement(0,0)*dImgOffsetRealDistanceX+ invertMatrix.GetElement(0,1)*dImgOffsetRealDistanceY;
		dImgOffsetY  = invertMatrix.GetElement(1,0)*dImgOffsetRealDistanceX+ invertMatrix.GetElement(1,1)*dImgOffsetRealDistanceY;



		if (m_bTargetObjectCamSeparate)
		{
			if (GetMidPlatformType() ==ePlatformXYPD)
			{
				if (nIndex >= m_iMarkNum/2)
				{
					if (m_PlatformCalibType == ePlatformCalib9Point)
					{
						sc2Vector vSrc;
						sc2Vector vDst;
						vDst.SetX(dImgOffsetRealDistanceX);
						vDst.SetY(dImgOffsetRealDistanceY);
						vSrc = sfHomographyInverseProject(vDst,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
						dImgOffsetX= vSrc.GetX();
						dImgOffsetY= vSrc.GetY();
					}
				}
				else
				{

				}
			}
			else
			{
				if (nIndex < m_iMarkNum/2)
				{
					if (m_PlatformCalibType == ePlatformCalib9Point)
					{
						sc2Vector vSrc;
						sc2Vector vDst;
						vDst.SetX(dImgOffsetRealDistanceX);
						vDst.SetY(dImgOffsetRealDistanceY);
						vSrc = sfHomographyInverseProject(vDst,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
						dImgOffsetX= vSrc.GetX();
						dImgOffsetY= vSrc.GetY();
					}
				}
				else
				{
					//					if (m_bTargetCalibUseBoard == TRUE)
					//					{
					//						// 虚拟平台偏移量
					//						double dVirtualPlatformOffsetX = 0.0;
					//						double dVirtualPlatformOffsetY = 0.0;
					//
					//						//使用相机中心计算偏差量
					//						{
					//							//计算对象位置0的图像中心的平台坐标
					//							double dObjectPos0PlaCenX,dObjectPos0PlaCenY;
					//							double dTargetPos0PlaCenX,dTargetPos0PlaCenY;
					//							double dImageSizeX = 0;
					//							double dImageSizeY = 0;
					//
					//							{
					//								// FM 2017.08.21
					//// 								if (m_pVisionAlignerTool != NULL)
					//// 								{									
					//// 									dImageSizeX = ((vcXYDVisionAlign*)m_pVisionAlignerTool)->GetPosDisplay(0)->GetImageWidth();
					//// 									dImageSizeY = ((vcXYDVisionAlign*)m_pVisionAlignerTool)->GetPosDisplay(0)->GetImageHeight();
					////								}
					//								dImageSizeX = m_ImageSizes.GetMarkImagePos(0).GetPosX();
					//								dImageSizeY = m_ImageSizes.GetMarkImagePos(0).GetPosY();
					//								//标定参数
					//								double dTranferA11 = m_vAlignerCalibInfos.at(0)->GetPlatformTransferMatrix().GetElement(0,0);
					//								double dTranferA12 = m_vAlignerCalibInfos.at(0)->GetPlatformTransferMatrix().GetElement(0,1);
					//								double dTranferA21 = m_vAlignerCalibInfos.at(0)->GetPlatformTransferMatrix().GetElement(1,0);
					//								double dTranferA22 = m_vAlignerCalibInfos.at(0)->GetPlatformTransferMatrix().GetElement(1,1);
					//
					//								double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(0)->GetMarkPlatformCoordPos().GetPosX();
					//								double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(0)->GetMarkPlatformCoordPos().GetPosY();
					//
					//								// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
					//								double dImgOffsetRealDistanceX = 0;
					//								double dImgOffsetRealDistanceY = 0;
					//								double dImgOffsetX = dImageSizeX * 0.5 - m_vAlignerCalibInfos.at(0)->GetMarkImgCoordPos().m_dPosX;
					//								double dImgOffsetY = dImageSizeY * 0.5 - m_vAlignerCalibInfos.at(0)->GetMarkImgCoordPos().m_dPosY;
					//								dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
					//								dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;
					//
					//								if (m_PlatformCalibType == ePlatformCalib9Point)
					//								{
					//									sc2Vector vSrc;
					//									sc2Vector vDst;
					//									vSrc.SetX(dImgOffsetX);
					//									vSrc.SetY(dImgOffsetY);
					//									vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(0)->m_PlatformTranferH);
					//									dImgOffsetRealDistanceX = vDst.GetX();
					//									dImgOffsetRealDistanceY = vDst.GetY();
					//								}
					//
					//								dObjectPos0PlaCenX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
					//								dObjectPos0PlaCenY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
					//							}
					//							str.Format("位置1（CH0）的图像中心平台坐标：X=%f,Y=%f",dObjectPos0PlaCenX,dObjectPos0PlaCenY);
					//							AlignToolLogRecord(str,nPlatformIndex);
					//							//计算目标位置2的图像中心的平台坐标
					//							{
					//								// FM 2017.08.21
					//// 								if (m_pVisionAlignerTool != NULL)
					//// 								{									
					//// 									dImageSizeX = ((vcXYDVisionAlign*)m_pVisionAlignerTool)->GetPosDisplay(m_iMarkNum/2)->GetImageWidth();
					//// 									dImageSizeY = ((vcXYDVisionAlign*)m_pVisionAlignerTool)->GetPosDisplay(m_iMarkNum/2)->GetImageHeight();
					////								}
					//								dImageSizeX = m_ImageSizes.GetMarkImagePos(m_iMarkNum/2).GetPosX();
					//								dImageSizeY = m_ImageSizes.GetMarkImagePos(m_iMarkNum/2).GetPosY();
					//
					//								//标定参数
					//								double dTranferA11 = m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformTransferMatrix().GetElement(0,0);
					//								double dTranferA12 = m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformTransferMatrix().GetElement(0,1);
					//								double dTranferA21 = m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformTransferMatrix().GetElement(1,0);
					//								double dTranferA22 = m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformTransferMatrix().GetElement(1,1);
					//
					//								double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetMarkPlatformCoordPos().GetPosX();
					//								double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetMarkPlatformCoordPos().GetPosY();
					//
					//								// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
					//								double dImgOffsetRealDistanceX = 0;
					//								double dImgOffsetRealDistanceY = 0;
					//								double dImgOffsetX = dImageSizeX * 0.5 - m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetMarkImgCoordPos().m_dPosX;
					//								double dImgOffsetY = dImageSizeY * 0.5 - m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetMarkImgCoordPos().m_dPosY;
					//								dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
					//								dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;
					//
					//								dTargetPos0PlaCenX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
					//								dTargetPos0PlaCenY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
					//							}
					//							str.Format("位置%d（CH%d）的图像中心平台坐标：X=%f,Y=%f",m_iMarkNum/2+1,m_iMarkNum/2,dTargetPos0PlaCenX,dTargetPos0PlaCenY);
					//							AlignToolLogRecord(str,nPlatformIndex);
					//
					//							// 目标标定轴相对于对象标定轴位置偏移量
					//							CPlatformXYDAxisPos*  pTargetPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformAxisPos());
					//							CPlatformXYDAxisPos*  pObjectPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());
					//
					//							double dVirtualPlatformAixsOffsetX = pObjectPlatformXYDBenchAxisPos->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
					//							double dVirtualPlatformAixsOffsetY = pObjectPlatformXYDBenchAxisPos->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
					//
					//							if (eDirectNegative == iPlatformXCoordType) dVirtualPlatformAixsOffsetX = -1*dVirtualPlatformAixsOffsetX;	
					//							if (eDirectNegative == iPlatformYCoordType) dVirtualPlatformAixsOffsetY = -1*dVirtualPlatformAixsOffsetY;
					//
					//
					//							dVirtualPlatformOffsetX = dObjectPos0PlaCenX - dTargetPos0PlaCenX + dVirtualPlatformAixsOffsetX;
					//							dVirtualPlatformOffsetY = dObjectPos0PlaCenY - dTargetPos0PlaCenY + dVirtualPlatformAixsOffsetY;
					//
					//						}
					//						//使用基准位置计算偏差量
					//						if (0)
					//						{
					//							dVirtualPlatformOffsetX = m_vAlignerCalibInfos.at(0)->GetMarkPlatformCoordPos().GetPosX() - m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetMarkPlatformCoordPos().GetPosX();
					//							dVirtualPlatformOffsetY = m_vAlignerCalibInfos.at(0)->GetMarkPlatformCoordPos().GetPosY() - m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetMarkPlatformCoordPos().GetPosY();
					//							str.Format("位置1（CH0）的基准平台坐标：X=%f,Y=%f",m_vAlignerCalibInfos.at(0)->GetMarkPlatformCoordPos().GetPosX(),m_vAlignerCalibInfos.at(0)->GetMarkPlatformCoordPos().GetPosY());
					//							AlignToolLogRecord(str,nPlatformIndex);
					//							str.Format("位置%d（CH%d）的基准平台坐标：X=%f,Y=%f",m_iMarkNum/2+1,m_iMarkNum/2,
					//								m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetMarkPlatformCoordPos().GetPosX(),m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetMarkPlatformCoordPos().GetPosY());
					//							AlignToolLogRecord(str,nPlatformIndex);
					//
					//						}
					//
					//						str.Format("虚拟平台偏移量：X=%f,Y=%f",dVirtualPlatformOffsetX,dVirtualPlatformOffsetY);
					//						AlignToolLogRecord(str,nPlatformIndex);
					//
					//						dPlatformBenchMarkX += dVirtualPlatformOffsetX;
					//						dPlatformBenchMarkY += dVirtualPlatformOffsetY;
					//						str.Format("偏移后的平台基准Mark位置：X=%f,Y=%f",dPlatformBenchMarkX,dPlatformBenchMarkY);
					//						AlignToolLogRecord(str,nPlatformIndex);
					//
					//						//////////////////////////////////////////////////////////////////////////
					//						//新基准重新计算图像偏差
					//						//图像偏差距离等于当前平台坐标减去基准平台坐标
					//						dImgOffsetRealDistanceX = platformCoordPos.m_dPosX - dPlatformBenchMarkX;
					//						dImgOffsetRealDistanceY = platformCoordPos.m_dPosY - dPlatformBenchMarkY ;
					//
					//						str.Format("图像偏差带来的平台距离：X=%f,Y=%f",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
					//						AlignToolLogRecord(str,nPlatformIndex);
					//
					//						// $2、根据标定后得到的变换矩阵和像素位置偏差对应的实际平台移动量基准Mark的图像坐标值，计算图像坐标
					//
					//						dImgOffsetX  = invertMatrix.GetElement(0,0)*dImgOffsetRealDistanceX+ invertMatrix.GetElement(0,1)*dImgOffsetRealDistanceY;
					//						dImgOffsetY  = invertMatrix.GetElement(1,0)*dImgOffsetRealDistanceX+ invertMatrix.GetElement(1,1)*dImgOffsetRealDistanceY;
					//
					//						//////////////////////////////////////////////////////////////////////////
					//					}

				}
			}

		}
		else
		{
			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vDst.SetX(dImgOffsetRealDistanceX);
				vDst.SetY(dImgOffsetRealDistanceY);
				vSrc = sfHomographyInverseProject(vDst,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
				dImgOffsetX= vSrc.GetX();
				dImgOffsetY= vSrc.GetY();
			}
		}

		str.Format("图像像素偏差：X=%f,Y=%f",dImgOffsetX,dImgOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);


		// $4、内容相加，即为相机实时Mark的平台坐标值
		imageCoordPos.m_dPosX = m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX + dImgOffsetX ;
		imageCoordPos.m_dPosY = m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY + dImgOffsetY ;

		str.Format("图像坐标值：X=%f,Y=%f",imageCoordPos.m_dPosX,imageCoordPos.m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		return true;
	}

	return false;
}

// 目标是否重构	
BOOL vcBaseAlignTool:: IsTargetReConstruct()
{
	BOOL bReConstruct = FALSE;

	if (m_bTargetObjectCamSeparate && m_iMarkNum == 8 
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		bReConstruct = TRUE;
	}
	else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4)||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		bReConstruct = TRUE;
	}

	return bReConstruct;
}

// 目标综合对位点重构
BOOL vcBaseAlignTool::ExecuteTargetPlatformPosRestruct(std::vector<CCoordPos>& vcpTarPlatPos)
{
	if (((m_bTargetObjectCamSeparate && m_iMarkNum == 8 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 4 ))
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		||m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4	
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		// 日志记录
		int nPlatformIndex = m_nPlatformIndex;
		CString str;

		str.Format(_T("目标重构点计算开始(4VS4)，对位方式： %d ,"), m_AlignermentParam.GetAligner4Vs4Type());
		AlignToolLogRecord(str,nPlatformIndex);

		int nIndexOffset = (m_bTargetObjectCamSeparate) ? m_iMarkNum/2 : 0;
		std::vector<CCoordPos> vcpTempTarPlatPos;
		vcpTempTarPlatPos.resize(8);

		for (int k = nIndexOffset; k < m_iMarkNum; k++)
		{
			vcpTempTarPlatPos.at(k) = vcpTarPlatPos.at(k);

			str.Format("修正前目标平台坐标%d： X = %f ,Y = %f ,", k, vcpTarPlatPos.at(k).GetPosX(), vcpTarPlatPos.at(k).GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		scLine ResultLine[4];
		sc2Vector UsePoint[8];
		bool bIntersect = false;
		std::vector<sc2Vector> crossPointArray;

		UsePoint[0] = vcpTarPlatPos[0 + nIndexOffset].GetAuxPos(0);
		UsePoint[1] = vcpTarPlatPos[1 + nIndexOffset].GetAuxPos(0);
		ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

		UsePoint[2] = vcpTarPlatPos[1 + nIndexOffset].GetAuxPos(1);
		UsePoint[3] = vcpTarPlatPos[3 + nIndexOffset].GetAuxPos(1);
		ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

		UsePoint[4] = vcpTarPlatPos[2 + nIndexOffset].GetAuxPos(0);
		UsePoint[5] = vcpTarPlatPos[3 + nIndexOffset].GetAuxPos(0);
		ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		UsePoint[6] = vcpTarPlatPos[0 + nIndexOffset].GetAuxPos(1);
		UsePoint[7] = vcpTarPlatPos[2 + nIndexOffset].GetAuxPos(1);
		ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

		// 			UsePoint[0] = vcpTarPlatPos[0+m_iMarkNum/2].GetAuxPos(0);
		// 			UsePoint[1] = vcpTarPlatPos[1+m_iMarkNum/2].GetAuxPos(0);
		// 			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);
		// 
		// 			UsePoint[2] = vcpTarPlatPos[1+m_iMarkNum/2].GetAuxPos(1);
		// 			UsePoint[3] = vcpTarPlatPos[3+m_iMarkNum/2].GetAuxPos(1);
		// 			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);
		// 
		// 			UsePoint[4] = vcpTarPlatPos[2+m_iMarkNum/2].GetAuxPos(0);
		// 			UsePoint[5] = vcpTarPlatPos[3+m_iMarkNum/2].GetAuxPos(0);
		// 			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		// 
		// 			UsePoint[6] = vcpTarPlatPos[0+m_iMarkNum/2].GetAuxPos(1);
		// 			UsePoint[7] = vcpTarPlatPos[2+m_iMarkNum/2].GetAuxPos(1);
		// 			ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);


		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode && m_iMarkNum == 8)
		{
			sc2Vector ResultPoint[4];

			int nTargetPositionVirtualMode = m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode;
			switch(nTargetPositionVirtualMode)
			{
			case 0:
				{
					//  5   6
					// (7) (8)
					ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
					ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点

					vcpTarPlatPos[0 + nIndexOffset].m_dPosX = ResultPoint[0].GetX(); 
					vcpTarPlatPos[0 + nIndexOffset].m_dPosY = ResultPoint[0].GetY();
					vcpTarPlatPos[1 + nIndexOffset].m_dPosX = ResultPoint[1].GetX(); 
					vcpTarPlatPos[1 + nIndexOffset].m_dPosY = ResultPoint[1].GetY();
				}
				break;

			case 1:
				{
					// (5) (6)
					//  7   8
					ResultPoint[2] = ResultLine[2].Project(UsePoint[7]); // 计算给定点p在当前直线上的投影点
					ResultPoint[3] = ResultLine[2].Project(UsePoint[3]); // 计算给定点p在当前直线上的投影点

					vcpTarPlatPos[2 + nIndexOffset].m_dPosX = ResultPoint[2].GetX(); 
					vcpTarPlatPos[2 + nIndexOffset].m_dPosY = ResultPoint[2].GetY();
					vcpTarPlatPos[3 + nIndexOffset].m_dPosX = ResultPoint[3].GetX(); 
					vcpTarPlatPos[3 + nIndexOffset].m_dPosY = ResultPoint[3].GetY();
				}
				break;

			case 2:
				{
					//	5  (6)
					//  7  (8)
					ResultPoint[0] = ResultLine[3].Project(UsePoint[0]); // 计算给定点p在当前直线上的投影点
					ResultPoint[2] = ResultLine[3].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点

					vcpTarPlatPos[0 + nIndexOffset].m_dPosX = ResultPoint[0].GetX(); 
					vcpTarPlatPos[0 + nIndexOffset].m_dPosY = ResultPoint[0].GetY();
					vcpTarPlatPos[2 + nIndexOffset].m_dPosX = ResultPoint[2].GetX(); 
					vcpTarPlatPos[2 + nIndexOffset].m_dPosY = ResultPoint[2].GetY();
				}
				break;

			case 3:
				{
					//	（5） 6
					//  （7） 8
					ResultPoint[1] = ResultLine[1].Project(UsePoint[1]); // 计算给定点p在当前直线上的投影点
					ResultPoint[3] = ResultLine[1].Project(UsePoint[5]); // 计算给定点p在当前直线上的投影点


					vcpTarPlatPos[1 + nIndexOffset].m_dPosX = ResultPoint[1].GetX(); 
					vcpTarPlatPos[1 + nIndexOffset].m_dPosY = ResultPoint[1].GetY();
					vcpTarPlatPos[3 + nIndexOffset].m_dPosX = ResultPoint[3].GetX(); 
					vcpTarPlatPos[3 + nIndexOffset].m_dPosY = ResultPoint[3].GetY();
				}
				break;

			default:
				{
					return FALSE;
				}
				break;

			}

		}
		else
		{
			if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpTarPlatPos[0 + nIndexOffset].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[0 + nIndexOffset].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpTarPlatPos[1 + nIndexOffset].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[1 + nIndexOffset].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpTarPlatPos[2 + nIndexOffset].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[2 + nIndexOffset].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpTarPlatPos[3 + nIndexOffset].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[3 + nIndexOffset].m_dPosY = crossPointArray.at(0).GetY();
			}

		}

		// 日志记录
		for (int k = nIndexOffset; k < m_iMarkNum; k++)
		{
			str.Format("修正后目标平台坐标%d： X = %f , Y = %f , ", k, vcpTarPlatPos.at(k).GetPosX() , vcpTarPlatPos.at(k).GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		for (int k = nIndexOffset; k < m_iMarkNum; k++)
		{
			double dOffsetX = vcpTempTarPlatPos.at(k).GetPosX() - vcpTarPlatPos.at(k).GetPosX();
			double dOffsetY = vcpTempTarPlatPos.at(k).GetPosY() - vcpTarPlatPos.at(k).GetPosY();

			str.Format("修正前后目标位置平台坐标差%d： X = %f , Y = %f ,", k, dOffsetX, dOffsetY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		str.Format(_T("目标重构点计算结束，对位方式： %d ,\n\n"), m_AlignermentParam.GetAligner4Vs4Type());
		AlignToolLogRecord(str,nPlatformIndex);

		return TRUE;

	}
	else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4)||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		// 日志记录
		int nPlatformIndex = m_nPlatformIndex;
		CString str;

		str.Format(_T("目标重构点计算开始(2VS2)，对位方式： %d ,"), m_AlignermentParam.GetAligner2Vs2Type());
		AlignToolLogRecord(str,nPlatformIndex);

		int nIndexOffset = (m_bTargetObjectCamSeparate) ? m_iMarkNum/2 : 0;
		std::vector<CCoordPos> vcpTempTarPlatPos;
		vcpTempTarPlatPos.resize(8);

		for (int k = nIndexOffset; k < m_iMarkNum; k++)
		{
			vcpTempTarPlatPos.at(k) = vcpTarPlatPos.at(k);

			str.Format("修正前目标平台坐标%d： X = %f ,Y = %f ,", k, vcpTempTarPlatPos.at(k).GetPosX(), vcpTempTarPlatPos.at(k).GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);

		}


		CCoordPos ResultPos[3];
		scLine ResultLine[3];
		sc2Vector UsePoint[6];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;

		// 判断公共边是水平边还是垂直边
		scLine tpmLine = scLineSeg(vcpTarPlatPos.at(0+nIndexOffset).GetPos(), vcpTarPlatPos.at(1+nIndexOffset).GetPos()).GetLine();
		double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
		BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;

		if (bHorDirection == TRUE)
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[0].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
			UsePoint[1].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[1].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[2].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetPosX());
				UsePoint[3].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[4].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetPosX());
				UsePoint[5].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}
		else
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[0].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
			UsePoint[1].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
			UsePoint[1].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[2].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetPosX());
				UsePoint[3].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
			UsePoint[4].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetPosX());
				UsePoint[5].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}

		// 直线0和1交点，覆盖点0
		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			vcpTarPlatPos.at(0+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
			vcpTarPlatPos.at(0+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
		}

		// 直线0和2交点，覆盖点1
		if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			vcpTarPlatPos.at(1+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
			vcpTarPlatPos.at(1+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
		}


		// 日志记录
		for (int k = nIndexOffset; k < m_iMarkNum; k++)
		{
			str.Format("修正后目标平台坐标%d： X = %f , Y = %f , ", k, vcpTarPlatPos.at(k).GetPosX() , vcpTarPlatPos.at(k).GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		for (int k = nIndexOffset; k < m_iMarkNum; k++)
		{
			double dOffsetX = vcpTempTarPlatPos.at(k).GetPosX() - vcpTarPlatPos.at(k).GetPosX();
			double dOffsetY = vcpTempTarPlatPos.at(k).GetPosY() - vcpTarPlatPos.at(k).GetPosY();

			str.Format("修正前后目标位置平台坐标差%d： X = %f , Y = %f ,", k, dOffsetX, dOffsetY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		str.Format(_T("目标重构点计算结束，对位方式： %d ,\n\n"), m_AlignermentParam.GetAligner2Vs2Type());
		AlignToolLogRecord(str,nPlatformIndex);

		return TRUE;
	}


	return TRUE;
}

bool vcBaseAlignTool::GetDefaultTargetFixOffset(CCoordPos &offset)
{
	offset.SetPos(0.0,0.0);
	CString str;
	str.Format("计算默认目标固定补偿开始");
	AlignToolLogRecord(str,m_nPlatformIndex);
	// 虚拟平台偏移量
	double dVirtualPlatformOffsetX = 0.0;
	double dVirtualPlatformOffsetY = 0.0;
	CPlatformXYDInfo*     pPlatformParam =(CPlatformXYDInfo*)m_pPlatformParam; 
	//平台各轴的方向	
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	//使用相机中心计算偏差量
	{
		//计算对象位置0的图像中心的平台坐标
		double dObjectPos0PlaCenX,dObjectPos0PlaCenY;
		double dTargetPos0PlaCenX,dTargetPos0PlaCenY;
		double dImageSizeX = 0;
		double dImageSizeY = 0;

		{
			dImageSizeX = m_ImageSizes.GetMarkImagePos(0).GetPosX();
			dImageSizeY = m_ImageSizes.GetMarkImagePos(0).GetPosY();

			//标定参数
			double dTranferA11 = m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformTransferMatrix().GetElement(0,0);
			double dTranferA12 = m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformTransferMatrix().GetElement(0,1);
			double dTranferA21 = m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformTransferMatrix().GetElement(1,0);
			double dTranferA22 = m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformTransferMatrix().GetElement(1,1);

			double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetMarkPlatformCoordPos().GetPosX();
			double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetMarkPlatformCoordPos().GetPosY();

			// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
			double dImgOffsetRealDistanceX = 0;
			double dImgOffsetRealDistanceY = 0;
			double dImgOffsetX = dImageSizeX * 0.5 - m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetMarkImgCoordPos().m_dPosX;
			double dImgOffsetY = dImageSizeY * 0.5 - m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetMarkImgCoordPos().m_dPosY;
			dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
			dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vSrc.SetX(dImgOffsetX);
				vSrc.SetY(dImgOffsetY);
				vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->m_PlatformTranferH);
				dImgOffsetRealDistanceX = vDst.GetX();
				dImgOffsetRealDistanceY = vDst.GetY();
			}

			dObjectPos0PlaCenX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
			dObjectPos0PlaCenY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
		}
		str.Format("位置1（CH0）的图像中心平台坐标：X=%f,Y=%f",dObjectPos0PlaCenX,dObjectPos0PlaCenY);
		AlignToolLogRecord(str,m_nPlatformIndex);
		//计算目标位置2的图像中心的平台坐标
		{

			dImageSizeX = m_ImageSizes.GetMarkImagePos(m_iMarkNum/2).GetPosX();
			dImageSizeY = m_ImageSizes.GetMarkImagePos(m_iMarkNum/2).GetPosY();

			//标定参数
			double dTranferA11 = m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformTransferMatrix().GetElement(0,0);
			double dTranferA12 = m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformTransferMatrix().GetElement(0,1);
			double dTranferA21 = m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformTransferMatrix().GetElement(1,0);
			double dTranferA22 = m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformTransferMatrix().GetElement(1,1);

			double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetMarkPlatformCoordPos().GetPosX();
			double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetMarkPlatformCoordPos().GetPosY();

			// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
			double dImgOffsetRealDistanceX = 0;
			double dImgOffsetRealDistanceY = 0;
			double dImgOffsetX = dImageSizeX * 0.5 - m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetMarkImgCoordPos().m_dPosX;
			double dImgOffsetY = dImageSizeY * 0.5 - m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetMarkImgCoordPos().m_dPosY;
			dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
			dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

			if ( m_AlignermentParam.GetCalibTargetMarkPatternMode() == eDmCodeCalib)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vSrc.SetX(dImgOffsetX);
				vSrc.SetY(dImgOffsetY);
				vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->m_PlatformTranferH);
				dImgOffsetRealDistanceX = vDst.GetX();
				dImgOffsetRealDistanceY = vDst.GetY();
				str.Format("使用3*3矩阵计算图像像素移动量：X=%f,Y=%f",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
				AlignToolLogRecord(str,m_nPlatformIndex);
			}
			else
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vSrc.SetX(dImgOffsetX);
				vSrc.SetY(dImgOffsetY);
				double h[9];
				memset(h, 0.0, sizeof(double)*9);
				h[0]=dTranferA11;h[1]=dTranferA12;h[3]=dTranferA21;h[4]=dTranferA22;h[8]=1;
				vDst = sfHomographyProject(vSrc,h);
				dImgOffsetRealDistanceX = vDst.GetX();
				dImgOffsetRealDistanceY = vDst.GetY();
				str.Format("使用3*3矩阵计算图像像素移动量：X=%f,Y=%f",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
				AlignToolLogRecord(str,m_nPlatformIndex);
			}

			dTargetPos0PlaCenX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
			dTargetPos0PlaCenY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
		}
		str.Format("位置%d（CH%d）的图像中心平台坐标：X=%f,Y=%f",m_iMarkNum/2+1,m_iMarkNum/2,dTargetPos0PlaCenX,dTargetPos0PlaCenY);
		AlignToolLogRecord(str,m_nPlatformIndex);

		// 目标标定轴相对于对象标定轴位置偏移量
		CPlatformXYDAxisPos*  pTargetPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(m_iMarkNum/2+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos());
		CPlatformXYDAxisPos*  pObjectPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0+m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos());

		double dVirtualPlatformAixsOffsetX = pObjectPlatformXYDBenchAxisPos->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
		double dVirtualPlatformAixsOffsetY = pObjectPlatformXYDBenchAxisPos->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;

		if (eDirectNegative == iPlatformXCoordType) dVirtualPlatformAixsOffsetX = -1*dVirtualPlatformAixsOffsetX;	
		if (eDirectNegative == iPlatformYCoordType) dVirtualPlatformAixsOffsetY = -1*dVirtualPlatformAixsOffsetY;


		dVirtualPlatformOffsetX = dObjectPos0PlaCenX - dTargetPos0PlaCenX + dVirtualPlatformAixsOffsetX;
		dVirtualPlatformOffsetY = dObjectPos0PlaCenY - dTargetPos0PlaCenY + dVirtualPlatformAixsOffsetY;

		str.Format("虚拟平台偏移量：X=%f,Y=%f",dVirtualPlatformOffsetX,dVirtualPlatformOffsetY);
		AlignToolLogRecord(str,m_nPlatformIndex);

	}
	offset.SetPos(dVirtualPlatformOffsetX,dVirtualPlatformOffsetY);
	str.Format("计算默认目标固定补偿结束");
	AlignToolLogRecord(str,m_nPlatformIndex);
	return true;

}










//////////////////////////////////////////////////////////////////////////
// 实时对象

// 实时对象Mark搜索时平台和相机各轴所在的绝对位置
void vcBaseAlignTool::SetObjectPlatformPos(std::vector<CPlatformAxisPos*> pPlatformAxisPos)
{
	int i=0;
	for (i=0;i<m_pObjectPlatformAxisPos.size();i++)
	{
		if (m_pObjectPlatformAxisPos.at(i)!= NULL)
		{
			delete m_pObjectPlatformAxisPos.at(i);
			m_pObjectPlatformAxisPos.at(i) = NULL;
		}
	}
	m_pObjectPlatformAxisPos.clear();

	for (i=0;i<pPlatformAxisPos.size();i++)
	{
		if ( ePlatformXYD== pPlatformAxisPos.at(i)->GetPlatformType())
		{	
			CPlatformAxisPos* platformAxisPos;
			platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos.at(i)));
			m_pObjectPlatformAxisPos.push_back(platformAxisPos); 
		}
	}

}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetObjectPlatformPos()
{
	return m_pObjectPlatformAxisPos;
}

// 实时对象Mark搜索时平台和相机各轴所在的绝对位置
void vcBaseAlignTool::SetObjectPlatformPos(CPlatformAxisPos* pPlatformAxisPos,int nIndex)
{
	if (nIndex<0|| pPlatformAxisPos==NULL)
	{
		return;
	}
	if (nIndex+1>m_pObjectPlatformAxisPos.size())
	{
		m_pObjectPlatformAxisPos.resize(nIndex+1);
	}//????


	if (m_pObjectPlatformAxisPos.at(nIndex)!= NULL)
	{
		delete m_pObjectPlatformAxisPos.at(nIndex);
		m_pObjectPlatformAxisPos.at(nIndex) = NULL;
	}	

	if ( ePlatformXYD== pPlatformAxisPos->GetPlatformType())
	{
		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
		m_pObjectPlatformAxisPos.at(nIndex)=platformAxisPos; 
	}
}

CPlatformAxisPos* vcBaseAlignTool::GetObjectPlatformPos(int nIndex)
{
	if (nIndex<0 || nIndex>=m_pObjectPlatformAxisPos.size())
	{
		return NULL;
	}
	if (m_pObjectPlatformAxisPos.at(nIndex)==NULL)
	{
		return NULL;
	}
	return m_pObjectPlatformAxisPos.at(nIndex);
}

// 定位实时对象时，相机平台位置
void vcBaseAlignTool::SetObjectCameraPos(std::vector<CPlatformAxisPos*> pCamPlatformAxisPos)
{
	for (int i=0; i<m_vObjectCamPlatformAxisPos.size(); i++)
	{
		if (m_vObjectCamPlatformAxisPos.at(i)!= NULL)
		{
			delete m_vObjectCamPlatformAxisPos.at(i);
			m_vObjectCamPlatformAxisPos.at(i) = NULL;
		}
	}
	m_vObjectCamPlatformAxisPos.clear();
	
	for (int j=0; j<pCamPlatformAxisPos.size(); j++)
	{	
		if (pCamPlatformAxisPos.at(j) != NULL)
		{
			CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos.at(j)));
			m_vObjectCamPlatformAxisPos.push_back(pAxisPos);
		}
	}
}

void vcBaseAlignTool::SetObjectCameraPos(CPlatformAxisPos* pCamPlatformAxisPos,int nIndex)
{
	if(nIndex < 0 || pCamPlatformAxisPos == NULL)
	{
		return;
	}
	if(nIndex + 1 > m_vObjectCamPlatformAxisPos.size())
	{
		m_vObjectCamPlatformAxisPos.resize(nIndex+1);
	}
	if(m_vObjectCamPlatformAxisPos.at(nIndex) != NULL)
	{
		delete m_vObjectCamPlatformAxisPos.at(nIndex);
		m_vObjectCamPlatformAxisPos.at(nIndex) = NULL;
	}
	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos));
	m_vObjectCamPlatformAxisPos.at(nIndex) = pAxisPos;
}

void vcBaseAlignTool::SetObjectCamAxisPlatformAxisPos(std::vector<CPlatformAxisPos*> pCamPlatformAxisPos)
{
	for (int i=0; i<m_vObjectCamAxisPlatformAxisPos.size(); i++)
	{
		if (m_vObjectCamAxisPlatformAxisPos.at(i)!= NULL)
		{
			delete m_vObjectCamAxisPlatformAxisPos.at(i);
			m_vObjectCamAxisPlatformAxisPos.at(i) = NULL;
		}
	}
	m_vObjectCamAxisPlatformAxisPos.clear();

	for (int j=0; j<pCamPlatformAxisPos.size(); j++)
	{	
		if (pCamPlatformAxisPos.at(j) != NULL)
		{
			CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos.at(j)));
			m_vObjectCamAxisPlatformAxisPos.push_back(pAxisPos);
		}
	}
}

void vcBaseAlignTool::SetObjectCamAxisPlatformAxisPos(CPlatformAxisPos* pCamAxisPlatformAxisPos,int nIndex)
{
	if(nIndex < 0 || pCamAxisPlatformAxisPos == NULL)
	{
		return;
	}
	if(nIndex + 1 > m_vObjectCamAxisPlatformAxisPos.size())
	{
		m_vObjectCamAxisPlatformAxisPos.resize(nIndex+1);
	}
	if(m_vObjectCamAxisPlatformAxisPos.at(nIndex) != NULL)
	{
		delete m_vObjectCamAxisPlatformAxisPos.at(nIndex);
		m_vObjectCamAxisPlatformAxisPos.at(nIndex) = NULL;
	}
	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos));
	m_vObjectCamAxisPlatformAxisPos.at(nIndex) = pAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetObjectCameraPos()
{
	return m_vObjectCamPlatformAxisPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetObjectCamAxisPlatformAxisPos()
{
	return m_vObjectCamAxisPlatformAxisPos;
}

//设置扩展各产品的对象相机实时小轴位置
void vcBaseAlignTool::SetObjectCamAxisPos_MultiEx(CPlatformAxisPos* pCamPlatformAxisPos,int nIndex)
{
	if(nIndex < 0 || pCamPlatformAxisPos == NULL)
	{
		return;
	}
	int nExProductIndex = GetAlignExProductIndex();
	if (nExProductIndex >= m_vvpObjectCamPlatformAxisPosMultiEx.size())
	{
		m_vvpObjectCamPlatformAxisPosMultiEx.resize(nExProductIndex+1);
	}
	if(nIndex + 1 > m_vvpObjectCamPlatformAxisPosMultiEx.at(nExProductIndex).size())
	{
		m_vvpObjectCamPlatformAxisPosMultiEx.at(nExProductIndex).resize(nIndex+1);
	}
	if(m_vvpObjectCamPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) != NULL)
	{
		delete m_vvpObjectCamPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex);
		m_vvpObjectCamPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) = NULL;
	}
	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos));
	m_vvpObjectCamPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) = pAxisPos;
}

void vcBaseAlignTool::SetObjectCamAxisPos_MultiEx(std::vector<std::vector<CPlatformAxisPos*>> vvpCamPlatformAxisPos)
{
	for (int i=0;i<m_vvpObjectCamPlatformAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpObjectCamPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpObjectCamPlatformAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpObjectCamPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpObjectCamPlatformAxisPosMultiEx.at(i).at(j) =NULL;
			}
		}
		m_vvpObjectCamPlatformAxisPosMultiEx.at(i).clear();
	}
	m_vvpObjectCamPlatformAxisPosMultiEx.clear();
	m_vvpObjectCamPlatformAxisPosMultiEx.resize(vvpCamPlatformAxisPos.size());
	for (int i=0;i<vvpCamPlatformAxisPos.size();i++)
	{
		m_vvpObjectCamPlatformAxisPosMultiEx.at(i).resize(vvpCamPlatformAxisPos.at(i).size());
	}
	CPlatformXYAxisPos* pCamAxisPos = NULL;
	for (int i=0;i<vvpCamPlatformAxisPos.size();i++)
	{
		for (int j=0;j<vvpCamPlatformAxisPos.at(i).size();j++)
		{
			if (vvpCamPlatformAxisPos.at(i).at(j)!=NULL)
			{
				pCamAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)vvpCamPlatformAxisPos.at(i).at(j)));
			}
			else
			{
				pCamAxisPos = new CPlatformXYAxisPos();
			}

			m_vvpObjectCamPlatformAxisPosMultiEx.at(i).at(j)=pCamAxisPos;
		}

	}
}

//设置扩展各产品的对象相机实时大轴位置
void vcBaseAlignTool::SetObjectCamAxisPlatformAxisPos_MultiEx(CPlatformAxisPos* pCamAxisPlatformAxisPos,int nIndex)
{
	if(nIndex < 0 || pCamAxisPlatformAxisPos == NULL)
	{
		return;
	}
	int nExProductIndex = GetAlignExProductIndex();
	if (nExProductIndex >= m_vvpObjectCamAxisPlatformAxisPosMultiEx.size())
	{
		m_vvpObjectCamAxisPlatformAxisPosMultiEx.resize(nExProductIndex+1);
	}
	if(nIndex + 1 > m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).size())
	{
		m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).resize(nIndex+1);
	}
	if(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) != NULL)
	{
		delete m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex);
		m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) = NULL;
	}
	CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamAxisPlatformAxisPos));
	m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(nExProductIndex).at(nIndex) = pAxisPos;
}

void vcBaseAlignTool::SetObjectCamAxisPlatformAxisPos_MultiEx(std::vector<std::vector<CPlatformAxisPos*>> vvpCamAxisPlatformAxisPos)
{
	for (int i=0;i<m_vvpObjectCamAxisPlatformAxisPosMultiEx.size();i++)
	{
		for (int j=0;j<m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).size();j++)
		{
			if (m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j)!=NULL)
			{
				delete m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j);
				m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j) =NULL;
			}
		}
		m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).clear();
	}
	m_vvpObjectCamAxisPlatformAxisPosMultiEx.clear();
	m_vvpObjectCamAxisPlatformAxisPosMultiEx.resize(vvpCamAxisPlatformAxisPos.size());
	for (int i=0;i<vvpCamAxisPlatformAxisPos.size();i++)
	{
		m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).resize(vvpCamAxisPlatformAxisPos.at(i).size());
	}
	CPlatformXYAxisPos* pCamAxisPos = NULL;
	for (int i=0;i<vvpCamAxisPlatformAxisPos.size();i++)
	{
		for (int j=0;j<vvpCamAxisPlatformAxisPos.at(i).size();j++)
		{
			if (vvpCamAxisPlatformAxisPos.at(i).at(j)!=NULL)
			{
				pCamAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)vvpCamAxisPlatformAxisPos.at(i).at(j)));
			}
			else
			{
				pCamAxisPos = new CPlatformXYAxisPos();
			}

			m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(i).at(j)=pCamAxisPos;
		}

	}
}

// 对象Mark的图像搜索结果
void vcBaseAlignTool::SetObjectMarkSearchResults(CMarkImagePos ImageResults)
{
	m_ObjectSearchResults = ImageResults;
}

CMarkImagePos vcBaseAlignTool::GetObjectMarkSearchResults()
{
	return m_ObjectSearchResults;
}

// 获取对象Mark的全局平台坐标值
CMarkPlatformPos vcBaseAlignTool::GetObjectMarkPlatformPosForAlign()
{
	if (eObjectBench == m_AlignermentParam.GetObjectMarkType())
	{
		int nPlatformIndex = m_nPlatformIndex;
		CString str;
		str.Format("对象平台坐标计算开始------------------\n\n");
		AlignToolLogRecord(str,nPlatformIndex);

		for (int i=0; i<m_iMarkNum; i++)
		{
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			m_ObjectMarkPlatformPos.m_vPos.at(i) = m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex)->GetMarkPlatformCoordPos();
			m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		str.Format("------------------对象平台坐标计算结束\n\n");
		AlignToolLogRecord(str,nPlatformIndex);

		return m_ObjectMarkPlatformPos;
	}

	if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTargetObjectCamSeparate == TRUE && m_bTarObjCamSepNoAxisCalib)
	{
		for (int k=0;k<m_pObjectPlatformAxisPos.size();k++)
		{

			if (GetMidPlatformType() == ePlatformXYD)
			{
				//((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dPosX = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosX;
				//((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dPosY = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosY;
				//((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dAngle = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dAngle;
			}
			else if(GetMidPlatformType() == ePlatformYD)
			{
				//由于对象在YD轴上，所以需要使用YD轴的实时位置
				((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dPosX = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosX;
			}
			else if(GetMidPlatformType() == ePlatformXD)
			{
				//由于目标在XD轴上，所以需要使用XD轴的实时位置
				((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dPosY = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosY;
			}
		}
	}

	//针对每个相机的图像mark计算其平台坐标值
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("对象平台坐标计算开始------------------\n\n");
	AlignToolLogRecord(str,nPlatformIndex);

//	BOOL bConvert = FALSE;
	for (int i=0; i<m_iMarkNum; i++)
	{	

		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{	
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i),	m_pObjectPlatformAxisPos.at(i));

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		else
		{

			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			if (m_bEnableMultiCalibExtension)
			{
				*((CPlatformXYAxisPos*)(m_vObjectCamPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpObjectCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
				*((CPlatformXYAxisPos*)(m_vObjectCamAxisPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
			}

			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
				m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i) , m_vObjectCamAxisPlatformAxisPos.at(i));

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);

		}

		m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;

	}

	if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
	{

	}
	else if ( ((GetMidPlatformType() ==ePlatformXYPD) ||  (GetMidPlatformType() ==ePlatformXY)) 
		&& ((m_bTargetObjectCamSeparate == TRUE && m_iMarkNum >= 4) || (m_bTargetObjectCamSeparate == FALSE && m_iMarkNum >= 2)))
	{
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
		std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;

		int k=0;
		for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
		{
			pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置

		}
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
		if ( pObjectPlatformAxisPos.at(1)!= pObjectPlatformAxisPos.at(0))
		{
			double offsetX = 0;
			double offsetY = 0;
			offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
			offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX+=offsetX;
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY+=offsetY;
		}

		{
			int nAuxiPosIndex = 0;
			for(nAuxiPosIndex = 0; nAuxiPosIndex < m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				double offsetX = 0;
				double offsetY = 0;
				offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
				offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

				m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosX.at(nAuxiPosIndex)+=offsetX;
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosY.at(nAuxiPosIndex)+=offsetY;
			}
		}
	}

	str.Format("------------------对象平台坐标计算结束\n\n");
	AlignToolLogRecord(str,nPlatformIndex);

	return m_ObjectMarkPlatformPos;

}

// 获取对象Mark的全局平台坐标值
CMarkPlatformPos vcBaseAlignTool::GetObjectMarkPlatformPos()
{
	if (eObjectBench == m_AlignermentParam.GetObjectMarkType())
	{
		int nPlatformIndex = m_nPlatformIndex;
		CString str;
		str.Format("对象平台坐标计算开始------------------");
		AlignToolLogRecord(str,nPlatformIndex);

		for (int i=0; i<m_iMarkNum; i++)
		{
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			m_ObjectMarkPlatformPos.m_vPos.at(i) = m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex)->GetMarkPlatformCoordPos();
			m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		str.Format("------------------对象平台坐标计算结束");
		AlignToolLogRecord(str,nPlatformIndex);

		return m_ObjectMarkPlatformPos;
	}

	if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTargetObjectCamSeparate == TRUE && m_bTarObjCamSepNoAxisCalib)
	{
		for (int k=0;k<m_pObjectPlatformAxisPos.size();k++)
		{

			if (GetMidPlatformType() == ePlatformXYD)
			{
				//((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dPosX = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosX;
				//((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dPosY = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosY;
				//((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dAngle = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dAngle;
			}
			else if(GetMidPlatformType() == ePlatformYD)
			{
				//由于对象在YD轴上，所以需要使用YD轴的实时位置
				((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dPosX = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosX;
			}
			else if(GetMidPlatformType() == ePlatformXD)
			{
				//由于目标在XD轴上，所以需要使用XD轴的实时位置
				((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(k))->m_dPosY = ((CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->GetPlatformAxisPos()))->m_dPosY;
			}
		}
	}

	//确保目标mark的平台坐标向量的长度与mark数量相同(在SetMarkNum中统一设置)
	// 	m_TargetMarkPlatformPos.m_vPos.resize(m_iMarkNum);
	// 	m_TargetMarkPlatformPos.m_vbOK.resize(m_iMarkNum);
	//针对每个相机的图像mark计算其平台坐标值
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("对象平台坐标计算开始------------------");
	AlignToolLogRecord(str,nPlatformIndex);
	for (int i=0; i<m_iMarkNum; i++)
	{	

		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{	
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i),	m_pObjectPlatformAxisPos.at(i));
			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		else
		{
			//MFQ 20190319
			//ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
			//	m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i));
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);
			if (m_bEnableMultiCalibExtension)
			{
				*((CPlatformXYAxisPos*)(m_vObjectCamPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpObjectCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
				*((CPlatformXYAxisPos*)(m_vObjectCamAxisPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
			}
			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
				m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i) , m_vObjectCamAxisPlatformAxisPos.at(i));
			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;

	}

	if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
	{

	}
	else if ( ((GetMidPlatformType() ==ePlatformXYPD) ||  (GetMidPlatformType() ==ePlatformXY)) 
		&& ((m_bTargetObjectCamSeparate == TRUE && m_iMarkNum >= 4) || (m_bTargetObjectCamSeparate == FALSE && m_iMarkNum >= 2)))
	{
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
		std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;

		int k=0;
		for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
		{
			pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置

		}
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
		if ( pObjectPlatformAxisPos.at(1)!= pObjectPlatformAxisPos.at(0))
		{
			double offsetX = 0;
			double offsetY = 0;
			offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
			offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX+=offsetX;
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY+=offsetY;
		}

		{
			// 2017.05.19
			// 对于Mark是边的情况，计算边的起点和终点（辅助定位结果点）平台坐标
			//if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12
			//	|| (m_iMarkNum == 8 && (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_Weight
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight)))
			{
				int nAuxiPosIndex = 0;
				for(nAuxiPosIndex = 0; nAuxiPosIndex < m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
				{
					double offsetX = 0;
					double offsetY = 0;
					offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
					offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

					m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosX.at(nAuxiPosIndex)+=offsetX;
					m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosY.at(nAuxiPosIndex)+=offsetY;
				}
			}
		}

	}

	//重新构造新的对位点================================================================================
	if (((m_bTargetObjectCamSeparate && m_iMarkNum == 8 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 4 ))
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		CCoordPos tmpPos[4];
		int iMarkNum = 8;
		int k = 0;
		for (k=0;k<iMarkNum/2;k++)
		{
			tmpPos[k] = m_ObjectMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		CCoordPos ResultPos[4];
		scLine ResultLine[4];
		sc2Vector UsePoint[8];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;
		UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
		UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
		UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
		UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
		ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

		UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
		UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
		UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosX(1));
		UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosY(1));
		ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

		UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosX(0));
		UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosY(0));
		UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosX(0));
		UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosY(0));
		ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		UsePoint[6].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
		UsePoint[6].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
		UsePoint[7].SetX(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosX(1));
		UsePoint[7].SetY(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosY(1));
		ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

		//lzk 0407  易天覆膜机-位置虚拟-对象对位
		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
		{	
			sc2Vector ResultPoint[4];
			// 对象位置虚拟模式:12拍照34虚拟
			if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
			{
				//  1   2
				// (3) (4)
				ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
				ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();


				// 				// 对象位置方向模式: 0：位置12水平
				// 				if (m_bObjectPositionDirectionMode == 0)
				// 				{
				// 					//  1   2
				// 					// (3) (4)
				// 					ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
				// 					ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
				// 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
				// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();
				// 				}
				// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式:1：位置12竖直；
				// 				{
				// 					// (3)  1
				// 					// (4)  2
				// 
				// 				}

				str.Format("对象位置虚拟模式：12拍照34虚拟");
				AlignToolLogRecord(str,nPlatformIndex);
			}
			// 对象位置虚拟模式:34拍照12虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
			{
				// (1) (2)
				//  3   4
				ResultPoint[2] = ResultLine[2].Project(UsePoint[7]); // 计算给定点p在当前直线上的投影点
				ResultPoint[3] = ResultLine[2].Project(UsePoint[3]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = ResultPoint[2].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = ResultPoint[2].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = ResultPoint[3].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = ResultPoint[3].GetY();


				// 				// 对象位置方向模式: 0：位置12水平；
				// 				if (m_bObjectPositionDirectionMode == 0)
				// 				{
				// 					// (1) (2)
				// 					//  3   4
				// 					ResultPoint[2] = ResultLine[2].Project(UsePoint[7]); // 计算给定点p在当前直线上的投影点
				// 					ResultPoint[3] = ResultLine[2].Project(UsePoint[3]); // 计算给定点p在当前直线上的投影点
				// 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = ResultPoint[2].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = ResultPoint[2].GetY();
				// 					m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = ResultPoint[3].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = ResultPoint[3].GetY();
				// 
				// 				}
				// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
				// 				{
				// 					//	3  (1)
				// 					//  4  (2)	
				// 				}

				str.Format("对象位置虚拟模式：34拍照12虚拟");
				AlignToolLogRecord(str,nPlatformIndex);

			}
			// 对象位置虚拟模式:13拍照24虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
			{
				//	1  (2)
				//  3  (4)
				ResultPoint[0] = ResultLine[3].Project(UsePoint[0]); // 计算给定点p在当前直线上的投影点
				ResultPoint[2] = ResultLine[3].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = ResultPoint[2].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = ResultPoint[2].GetY();


				// 				// 对象位置方向模式: 0：位置12水平；
				// 				if (m_bObjectPositionDirectionMode == 0)
				// 				{
				// 					//	1  (2)
				// 					//  3  (4)
				// 					ResultPoint[0] = ResultLine[3].Project(UsePoint[0]); // 计算给定点p在当前直线上的投影点
				// 					ResultPoint[2] = ResultLine[3].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
				// 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
				// 					m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = ResultPoint[2].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = ResultPoint[2].GetY();
				// 
				// 				}
				// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
				// 				{
				// 					//	3	1
				// 					// (4) (2)	
				// 				}

				str.Format("对象位置虚拟模式：13拍照24虚拟");
				AlignToolLogRecord(str,nPlatformIndex);

			}
			// 对象位置虚拟模式:24拍照13虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
			{
				//	（1） 2
				//  （3） 4
				ResultPoint[1] = ResultLine[1].Project(UsePoint[1]); // 计算给定点p在当前直线上的投影点
				ResultPoint[3] = ResultLine[1].Project(UsePoint[5]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = ResultPoint[3].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = ResultPoint[3].GetY();


				// 				// 对象位置方向模式: 0：位置12水平；
				// 				if (m_bObjectPositionDirectionMode == 0)
				// 				{
				// 					//	（1） 2
				// 					//  （3） 4
				// 					ResultPoint[1] = ResultLine[1].Project(UsePoint[1]); // 计算给定点p在当前直线上的投影点
				// 					ResultPoint[3] = ResultLine[1].Project(UsePoint[5]); // 计算给定点p在当前直线上的投影点
				// 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();
				// 					m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = ResultPoint[3].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = ResultPoint[3].GetY();
				// 
				// 				}
				// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
				// 				{
				// 					//	  （3）（1）
				// 					//		4    2
				// 
				// 				}
				str.Format("对象位置虚拟模式：24拍照13虚拟");
				AlignToolLogRecord(str,nPlatformIndex);
			}
			// 对象位置虚拟模式:12拍照34虚拟
			else
			{
				//  1   2
				// (3) (4)
				ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
				ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();


				// 				// 对象位置方向模式: 0：位置12水平
				// 				if (m_bObjectPositionDirectionMode == 0)
				// 				{
				// 					//  1   2
				// 					// (3) (4)
				// 					ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
				// 					ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
				// 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
				// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
				// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();
				// 
				// 				}
				// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式:1：位置12竖直；
				// 				{
				// 					// (3)  1
				// 					// (4)  2	
				// 				}
				str.Format("对象位置虚拟模式：34拍照12虚拟");
				AlignToolLogRecord(str,nPlatformIndex);

			}
		}
		else
		{ 

			if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = crossPointArray.at(0).GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = crossPointArray.at(0).GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = crossPointArray.at(0).GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = crossPointArray.at(0).GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = crossPointArray.at(0).GetY();
			}

		}

		for (k=0;k<iMarkNum/2;k++)
		{
			str.Format("修正后对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<iMarkNum/2;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosY();
			str.Format("修正前后对象位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		CCoordPos tmpPos[2];
		int k = 0;
		for (k=0;k<2;k++)
		{
			tmpPos[k] = m_ObjectMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX, m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		CCoordPos ResultPos[3];
		scLine ResultLine[3];
		sc2Vector UsePoint[6];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;

		// 判断公共边是水平边还是垂直边
		scLine tpmLine = scLineSeg(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPos(), m_ObjectMarkPlatformPos.m_vPos.at(1).GetPos()).GetLine();
		double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
		BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;
		str.Format("修正前对象角点连线角度[-90,90): %f ,直线是否水平线: %d", tmpAngle, bHorDirection);
		AlignToolLogRecord(str,nPlatformIndex);

		if (bHorDirection == TRUE)
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
			UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
			UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
			UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
			UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosX());
				UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
			UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosX());
				UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}
		else
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
			UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
			UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
			UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
			UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosX());
				UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
			UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosX());
				UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}

		// 直线0和1交点，覆盖点0
		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = crossPointArray.at(0).GetY();
		}

		// 直线0和2交点，覆盖点1
		if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = crossPointArray.at(0).GetY();
		}

		for (k=0;k<2;k++)
		{
			str.Format("修正后对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX, m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<2;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosY();
			str.Format("修正前后对象位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	//================================================================================


	str.Format("------------------对象平台坐标计算结束");
	AlignToolLogRecord(str,nPlatformIndex);
	return m_ObjectMarkPlatformPos;
}

// 获取对象Mark的全局平台坐标值(把各位置的平台坐标归一化到指定平台位置,用检查产品尺寸)
CMarkPlatformPos vcBaseAlignTool::GetObjectMarkPlatformPosForCheck()
{
	if (eObjectBench == m_AlignermentParam.GetObjectMarkType())
	{
		int nPlatformIndex = m_nPlatformIndex;
		CString str;
		str.Format("对象平台坐标计算开始------------------");
		AlignToolLogRecord(str,nPlatformIndex);

		for (int i=0; i<m_iMarkNum; i++)
		{
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			m_ObjectMarkPlatformPos.m_vPos.at(i) = m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex)->GetMarkPlatformCoordPos();
			m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		str.Format("------------------对象平台坐标计算结束");
		AlignToolLogRecord(str,nPlatformIndex);

		return m_ObjectMarkPlatformPos;
	}

	//确保目标mark的平台坐标向量的长度与mark数量相同(在SetMarkNum中统一设置)
	// 	m_TargetMarkPlatformPos.m_vPos.resize(m_iMarkNum);
	// 	m_TargetMarkPlatformPos.m_vbOK.resize(m_iMarkNum);
	//针对每个相机的图像mark计算其平台坐标值
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("检查对象平台坐标计算开始------------------");
	AlignToolLogRecord(str,nPlatformIndex);

// 	for (int i=0; i<m_iMarkNum; i++)
// 	{	
// 		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
// 		{	
// 			str.Format("对象平台坐标%d开始",i);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i),	m_pObjectPlatformAxisPos.at(i));
// 			str.Format("对象平台坐标%d结束",i);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 		else
// 		{
// 			if (m_bEnableMultiCalibExtension)
// 			{
// 				*(m_vObjectCamPlatformAxisPos.at(i))=*(m_vvpObjectCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i));
// 				*(m_vObjectCamAxisPlatformAxisPos.at(i))=*(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i));
// 			}
// 			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
// 				m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i),m_vObjectCamAxisPlatformAxisPos.at(i));
// 		}
// 
// 		m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;
// 
// 	}

	for (int i=0; i<m_iMarkNum; i++)
	{	

		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{	
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i),	m_pObjectPlatformAxisPos.at(i));

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		else
		{
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			if (m_bEnableMultiCalibExtension)
			{
				*((CPlatformXYAxisPos*)(m_vObjectCamPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpObjectCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
				*((CPlatformXYAxisPos*)(m_vObjectCamAxisPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
			}

			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
				m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i),m_vObjectCamAxisPlatformAxisPos.at(i));

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;


	}


	if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
	{

	}
	else if ( ((GetMidPlatformType() ==ePlatformXYPD) ||  (GetMidPlatformType() ==ePlatformXY)) 
		&& ((m_bTargetObjectCamSeparate == TRUE && m_iMarkNum >= 4) || (m_bTargetObjectCamSeparate == FALSE && m_iMarkNum >= 2)))
	{
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
		std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;

		int k=0;
		for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
		{
			pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置

		}
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
		if ( pObjectPlatformAxisPos.at(1)!= pObjectPlatformAxisPos.at(0))
		{
			double offsetX = 0;
			double offsetY = 0;
			offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
			offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX+=offsetX;
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY+=offsetY;
		}

		{
			// 2017.05.19
			// 对于Mark是边的情况，计算边的起点和终点（辅助定位结果点）平台坐标
			//if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12
			//	|| (m_iMarkNum == 8 && (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_Weight
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight)))
			{
				int nAuxiPosIndex = 0;
				for(nAuxiPosIndex = 0; nAuxiPosIndex < m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
				{
					double offsetX = 0;
					double offsetY = 0;
					offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
					offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

					m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosX.at(nAuxiPosIndex)+=offsetX;
					m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosY.at(nAuxiPosIndex)+=offsetY;
				}
			}
		}

	}


	//重新构造新的对位点================================================================================
	if (((m_bTargetObjectCamSeparate && m_iMarkNum == 8 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 4 ))
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		CCoordPos tmpPos[4];
		int iMarkNum = 8;
		int k = 0;
		for (k=0;k<iMarkNum/2;k++)
		{
			tmpPos[k] = m_ObjectMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		CCoordPos ResultPos[4];
		scLine ResultLine[4];
		sc2Vector UsePoint[8];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;
		UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
		UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
		UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
		UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
		ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

		UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
		UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
		UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosX(1));
		UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosY(1));
		ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

		UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosX(0));
		UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosY(0));
		UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosX(0));
		UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosY(0));
		ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		UsePoint[6].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
		UsePoint[6].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
		UsePoint[7].SetX(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosX(1));
		UsePoint[7].SetY(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosY(1));
		ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

		//lzk	易天覆膜机-位置虚拟-对象检查模式
		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
		{	
			sc2Vector ResultPoint[4];
			// 对象位置虚拟模式:12拍照34虚拟
			if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
			{
				//  1   2
				// (3) (4)
				ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
				ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();

// 				// 对象位置方向模式: 0：位置12水平
// 				if (m_bObjectPositionDirectionMode == 0)
// 				{
// 					//  1   2
// 					// (3) (4)
// 					ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
// 
// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();
// 				}
// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式:1：位置12竖直；
// 				{
// 					// (3)  1
// 					// (4)  2
// 
// 				}

				str.Format("对象位置虚拟模式：12拍照34虚拟");
				AlignToolLogRecord(str,nPlatformIndex);
			}
			// 对象位置虚拟模式:34拍照12虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
			{
				// (1) (2)
				//  3   4
				ResultPoint[2] = ResultLine[2].Project(UsePoint[7]); // 计算给定点p在当前直线上的投影点
				ResultPoint[3] = ResultLine[2].Project(UsePoint[3]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = ResultPoint[2].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = ResultPoint[2].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = ResultPoint[3].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = ResultPoint[3].GetY();

// 				// 对象位置方向模式: 0：位置12水平；
// 				if (m_bObjectPositionDirectionMode == 0)
// 				{
// 					// (1) (2)
// 					//  3   4
// 					ResultPoint[2] = ResultLine[2].Project(UsePoint[7]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[3] = ResultLine[2].Project(UsePoint[3]); // 计算给定点p在当前直线上的投影点
// 
// 					m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = ResultPoint[2].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = ResultPoint[2].GetY();
// 					m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = ResultPoint[3].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = ResultPoint[3].GetY();
// 
// 				}
// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
// 				{
// 					//	3  (1)
// 					//  4  (2)	
// 				}

				str.Format("对象位置虚拟模式：34拍照12虚拟");
				AlignToolLogRecord(str,nPlatformIndex);

			}
			// 对象位置虚拟模式:13拍照24虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
			{
				//	1  (2)
				//  3  (4)
				ResultPoint[0] = ResultLine[3].Project(UsePoint[0]); // 计算给定点p在当前直线上的投影点
				ResultPoint[2] = ResultLine[3].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = ResultPoint[2].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = ResultPoint[2].GetY();

// 				// 对象位置方向模式: 0：位置12水平；
// 				if (m_bObjectPositionDirectionMode == 0)
// 				{
// 					//	1  (2)
// 					//  3  (4)
// 					ResultPoint[0] = ResultLine[3].Project(UsePoint[0]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[2] = ResultLine[3].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
// 
// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
// 					m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = ResultPoint[2].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = ResultPoint[2].GetY();
// 
// 				}
// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
// 				{
// 					//	3	1
// 					// (4) (2)	
// 				}

				str.Format("对象位置虚拟模式：13拍照24虚拟");
				AlignToolLogRecord(str,nPlatformIndex);

			}
			// 对象位置虚拟模式:24拍照13虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
			{
				//	（1） 2
				//  （3） 4
				ResultPoint[1] = ResultLine[1].Project(UsePoint[1]); // 计算给定点p在当前直线上的投影点
				ResultPoint[3] = ResultLine[1].Project(UsePoint[5]); // 计算给定点p在当前直线上的投影点

				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = ResultPoint[3].GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = ResultPoint[3].GetY();

// 				// 对象位置方向模式: 0：位置12水平；
// 				if (m_bObjectPositionDirectionMode == 0)
// 				{
// 					//	（1） 2
// 					//  （3） 4
// 					ResultPoint[1] = ResultLine[1].Project(UsePoint[1]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[3] = ResultLine[1].Project(UsePoint[5]); // 计算给定点p在当前直线上的投影点
// 
// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();
// 					m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = ResultPoint[3].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = ResultPoint[3].GetY();
// 
// 				}
// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
// 				{
// 					//	  （3）（1）
// 					//		4    2
// 
// 				}

				str.Format("对象位置虚拟模式：24拍照13虚拟");
				AlignToolLogRecord(str,nPlatformIndex);
			}
			// 对象位置虚拟模式:12拍照34虚拟
			else
			{
// 				// 对象位置方向模式: 0：位置12水平
// 				if (m_bObjectPositionDirectionMode == 0)
// 				{
// 					//  1   2
// 					// (3) (4)
// 					ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
// 					ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
// 
// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = ResultPoint[0].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = ResultPoint[0].GetY();
// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = ResultPoint[1].GetX(); 
// 					m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = ResultPoint[1].GetY();
// 
// 				}
// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式:1：位置12竖直；
// 				{
// 					// (3)  1
// 					// (4)  2	
// 				}
// 				str.Format("对象位置虚拟模式：34拍照12虚拟");
// 				AlignToolLogRecord(str,nPlatformIndex);

			}
		}
		else
		{ 

			if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = crossPointArray.at(0).GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = crossPointArray.at(0).GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = crossPointArray.at(0).GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = crossPointArray.at(0).GetX(); 
				m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = crossPointArray.at(0).GetY();
			}
		}

		for (k=0;k<iMarkNum/2;k++)
		{
			str.Format("修正后对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<iMarkNum/2;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosY();
			str.Format("修正前后对象位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		CCoordPos tmpPos[2];
		int k = 0;
		for (k=0;k<2;k++)
		{
			tmpPos[k] = m_ObjectMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX, m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		CCoordPos ResultPos[3];
		scLine ResultLine[3];
		sc2Vector UsePoint[6];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;

		// 判断公共边是水平边还是垂直边
		scLine tpmLine = scLineSeg(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPos(), m_ObjectMarkPlatformPos.m_vPos.at(1).GetPos()).GetLine();
		double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
		BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;
		str.Format("修正前对象角点连线角度[-90,90): %f ,直线是否水平线: %d", tmpAngle, bHorDirection);
		AlignToolLogRecord(str,nPlatformIndex);

		if (bHorDirection == TRUE)
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
			UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
			UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
			UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
			UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosX());
				UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
			UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosX());
				UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}
		else
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
			UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
			UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
			UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
			UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosX());
				UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
			UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosX());
				UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}

		// 直线0和1交点，覆盖点0
		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = crossPointArray.at(0).GetY();
		}

		// 直线0和2交点，覆盖点1
		if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = crossPointArray.at(0).GetY();
		}

		for (k=0;k<2;k++)
		{
			str.Format("修正后对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX, m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<2;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosY();
			str.Format("修正前后对象位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	//================================================================================

	//lzk 0406 易天覆膜机-位置虚拟-对象检查模式
	if (((m_bTargetObjectCamSeparate && m_iMarkNum == 8 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 4 )) 
		&& m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
	{
		str.Format("---开始根据对象产品尺寸计算虚拟对位点---");
		AlignToolLogRecord(str,nPlatformIndex);

		double dTempObjectX[8];			//存储对象mark图像坐标
		double dTempObjectY[8];
		double dTempObjectD[8];

		memset(dTempObjectX, 0.0, sizeof(double)*8);
		memset(dTempObjectY, 0.0, sizeof(double)*8);
		memset(dTempObjectD, 0.0, sizeof(double)*8);

		//根据对象产品尺寸和对象12/34平台坐标虚拟目标34/12平台坐标 
		if ((m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0))
		{
			str.Format("对象尺寸信息错误:ObjectL1=%f,ObjectW1=%f",m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1);
			AlignToolLogRecord(str,nPlatformIndex);

			str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
			AlignToolLogRecord(str,nPlatformIndex);

			return m_ObjectMarkPlatformPos;
		}

		str.Format("对象尺寸信息:ObjectL1=%f,ObjectW1=%f",m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1);
		AlignToolLogRecord(str,nPlatformIndex);

		for (int i = 0; i < m_iMarkNum; i++)
		{
			dTempObjectX[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX;
			dTempObjectY[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY;
			dTempObjectD[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle;
		}

		// 对象位置虚拟模式:12拍照34虚拟
		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
		{
			//  1   2
			// (3) (4)

			// 放射矩形
			sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
			sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
			double dXLength = (ptObject2 - ptObject1).Length();
			double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
			scRadian xRot;
			(ptObject2 - ptObject1).Angle(xRot);
			// 对象1点、2点连线为水平方向，应将其归一化到-90-90
			xRot = xRot.SignedNormMod180();
			// 对象1点、2点连线为垂直方向，应将其归一化到0-180
			//xRot = xRot.NormMod180();

			str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));

			ptObject1 = affrect.GetCornerPo();
			ptObject2 = affrect.GetCornerPx();
			sc2Vector ptObject3 = affrect.GetCornerPy();
			sc2Vector ptObject4 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[2] = ptObject3.GetX();
			dTempObjectY[2] = ptObject3.GetY();
			dTempObjectX[3] = ptObject4.GetX();
			dTempObjectY[3] = ptObject4.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}


// 			// 对象位置方向模式: 0：位置12水平
// 			if (m_bObjectPositionDirectionMode == 0)
// 			{
// 				//  1   2
// 				// (3) (4)
// 
// 				// 放射矩形
// 				sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// 				sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// 				double dXLength = (ptObject2 - ptObject1).Length();
// 				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
// 				scRadian xRot;
// 				(ptObject2 - ptObject1).Angle(xRot);
// 				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 				xRot = xRot.SignedNormMod180();
// 				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 				//xRot = xRot.NormMod180();
// 
// 				str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));
// 
// 				ptObject1 = affrect.GetCornerPo();
// 				ptObject2 = affrect.GetCornerPx();
// 				sc2Vector ptObject3 = affrect.GetCornerPy();
// 				sc2Vector ptObject4 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[2] = ptObject3.GetX();
// 				dTempObjectY[2] = ptObject3.GetY();
// 				dTempObjectX[3] = ptObject4.GetX();
// 				dTempObjectY[3] = ptObject4.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 
// 
// 			}
// 			else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式:1：位置12竖直；
// 			{
// 				// (3)  1
// 				// (4)  2
// 
// 				// 放射矩形
// 				sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// 				sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// 				double dXLength = (ptObject2 - ptObject1).Length();
// 				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// 				scRadian xRot;
// 				(ptObject2 - ptObject1).Angle(xRot);
// 				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 				//				xRot = xRot.SignedNormMod180();
// 				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 				xRot = xRot.NormMod180();
// 
// 				str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));
// 
// 				ptObject1 = affrect.GetCornerPo();
// 				ptObject2 = affrect.GetCornerPx();
// 				sc2Vector ptObject3 = affrect.GetCornerPy();
// 				sc2Vector ptObject4 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[2] = ptObject3.GetX();
// 				dTempObjectY[2] = ptObject3.GetY();
// 				dTempObjectX[3] = ptObject4.GetX();
// 				dTempObjectY[3] = ptObject4.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 
// 			}
// 			else
// 			{
// 				return m_ObjectMarkPlatformPos;
// 			}
		}
		// 对象位置虚拟模式:34拍照12虚拟
		else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
		{
			// (1) (2)
			//  3   4
			sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
			sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
			double dXLength = (ptObject4 - ptObject3).Length();
			double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
			scRadian xRot;
			(ptObject4 - ptObject3).Angle(xRot);
			// 对象1点、2点连线为水平方向，应将其归一化到-90-90
			xRot = xRot.SignedNormMod180();
			// 对象1点、2点连线为垂直方向，应将其归一化到0-180
			//xRot = xRot.NormMod180();

			str.Format("对象34坐标:3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象34连线角度:34Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));

			ptObject3 = affrect.GetCornerPo();
			ptObject4 = affrect.GetCornerPx();
			sc2Vector ptObject1 = affrect.GetCornerPy();
			sc2Vector ptObject2 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[0] = ptObject1.GetX();
			dTempObjectY[0] = ptObject1.GetY();
			dTempObjectX[1] = ptObject2.GetX();
			dTempObjectY[1] = ptObject2.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}

// 			// 对象位置方向模式: 0：位置12水平；
// 			if (m_bObjectPositionDirectionMode == 0)
// 			{
// 				// (1) (2)
// 				//  3   4
// 				sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
// 				sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
// 				double dXLength = (ptObject4 - ptObject3).Length();
// 				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
// 				scRadian xRot;
// 				(ptObject4 - ptObject3).Angle(xRot);
// 				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 				xRot = xRot.SignedNormMod180();
// 				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 				//xRot = xRot.NormMod180();
// 
// 				str.Format("对象34坐标:3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象34连线角度:34Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));
// 
// 				ptObject3 = affrect.GetCornerPo();
// 				ptObject4 = affrect.GetCornerPx();
// 				sc2Vector ptObject1 = affrect.GetCornerPy();
// 				sc2Vector ptObject2 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[0] = ptObject1.GetX();
// 				dTempObjectY[0] = ptObject1.GetY();
// 				dTempObjectX[1] = ptObject2.GetX();
// 				dTempObjectY[1] = ptObject2.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 			}
// 			else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
// 			{
// 				//	3  (1)
// 				//  4  (2)
// 				sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
// 				sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
// 				double dXLength = (ptObject4 - ptObject3).Length();
// 				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// 				scRadian xRot;
// 				(ptObject4 - ptObject3).Angle(xRot);
// 				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 				//				xRot = xRot.SignedNormMod180();
// 				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 				xRot = xRot.NormMod180();
// 
// 				str.Format("对象34坐标:3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象34连线角度:34Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));
// 
// 				ptObject3 = affrect.GetCornerPo();
// 				ptObject4 = affrect.GetCornerPx();
// 				sc2Vector ptObject1 = affrect.GetCornerPy();
// 				sc2Vector ptObject2 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[0] = ptObject1.GetX();
// 				dTempObjectY[0] = ptObject1.GetY();
// 				dTempObjectX[1] = ptObject2.GetX();
// 				dTempObjectY[1] = ptObject2.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 			}
// 			else
// 			{
// 				return m_ObjectMarkPlatformPos;
// 			}

		}
		// 对象位置虚拟模式:13拍照24虚拟
		else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
		{
			//	1  (2)
			//  3  (4)
			sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
			sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
			double dYLength = (ptObject3 - ptObject1).Length();
			double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
			scRadian xRot;
			(ptObject3 - ptObject1).Angle(xRot);
			// 对象1点、3点连线为水平方向，应将其归一化到-90-90
			//				xRot = xRot.SignedNormMod180();
			// 对象1点、3点连线为垂直方向，应将其归一化到0-180
			xRot = xRot.NormMod180();

			str.Format("对象13坐标:1X=%f,1Y=%f,3X=%f,3Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject3.GetX(),ptObject3.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象13连线角度:13Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dYLength, dXLength, xRot, scRadian(skPI));

			ptObject1 = affrect.GetCornerPo();
			ptObject3 = affrect.GetCornerPx();
			sc2Vector ptObject2 = affrect.GetCornerPy();
			sc2Vector ptObject4 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[1] = ptObject2.GetX();
			dTempObjectY[1] = ptObject2.GetY();
			dTempObjectX[3] = ptObject4.GetX();
			dTempObjectY[3] = ptObject4.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}


// 			// 对象位置方向模式: 0：位置12水平；
// 			if (m_bObjectPositionDirectionMode == 0)
// 			{
// 				//	1  (2)
// 				//  3  (4)
// 				sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// 				sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
// 				double dYLength = (ptObject3 - ptObject1).Length();
// 				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// 				scRadian xRot;
// 				(ptObject3 - ptObject1).Angle(xRot);
// 				// 对象1点、3点连线为水平方向，应将其归一化到-90-90
// 				//				xRot = xRot.SignedNormMod180();
// 				// 对象1点、3点连线为垂直方向，应将其归一化到0-180
// 				xRot = xRot.NormMod180();
// 
// 				str.Format("对象13坐标:1X=%f,1Y=%f,3X=%f,3Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject3.GetX(),ptObject3.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象13连线角度:13Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dYLength, dXLength, xRot, scRadian(skPI));
// 
// 				ptObject1 = affrect.GetCornerPo();
// 				ptObject3 = affrect.GetCornerPx();
// 				sc2Vector ptObject2 = affrect.GetCornerPy();
// 				sc2Vector ptObject4 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[1] = ptObject2.GetX();
// 				dTempObjectY[1] = ptObject2.GetY();
// 				dTempObjectX[3] = ptObject4.GetX();
// 				dTempObjectY[3] = ptObject4.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 			}
// 			else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
// 			{
// 				//	3	1
// 				// (4) (2)
// 				sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// 				sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
// 				double dXLength = (ptObject1 - ptObject3).Length();
// 				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
// 				scRadian xRot;
// 				(ptObject1 - ptObject3).Angle(xRot);
// 				// 对象1点、3点连线为水平方向，应将其归一化到-90-90
// 				//				xRot = xRot.SignedNormMod180();
// 				// 对象1点、3点连线为垂直方向，应将其归一化到0-180  
// 				xRot = xRot.SignedNormMod180();
// 
// 				str.Format("对象13坐标:1X=%f,1Y=%f,3X=%f,3Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject3.GetX(),ptObject3.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象31连线角度:31Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot,  scRadian(0));
// 
// 				ptObject3 = affrect.GetCornerPo();
// 				ptObject1 = affrect.GetCornerPx();
// 				sc2Vector ptObject4 = affrect.GetCornerPy();
// 				sc2Vector ptObject2 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[1] = ptObject2.GetX();
// 				dTempObjectY[1] = ptObject2.GetY();
// 				dTempObjectX[3] = ptObject4.GetX();
// 				dTempObjectY[3] = ptObject4.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 			}
// 			else
// 			{
// 				return m_ObjectMarkPlatformPos;
// 			}

		}
		// 对象位置虚拟模式:24拍照13虚拟
		else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
		{
			//	（1） 2
			//  （3） 4
			// 放射矩形
			sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
			sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
			double dYLength = (ptObject4 - ptObject2).Length();
			double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
			scRadian xRot;
			(ptObject4 - ptObject2).Angle(xRot);
			// 对象1点、3点连线为水平方向，应将其归一化到-90-90
			//				xRot = xRot.SignedNormMod180();
			// 对象1点、3点连线为垂直方向，应将其归一化到0-180
			xRot = xRot.NormMod180();

			str.Format("对象24坐标:2X=%f,2Y=%f,4X=%f,4Y=%f",ptObject2.GetX(),ptObject2.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象24连线角度:24Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject2, dYLength, dXLength, xRot, scRadian(0));

			ptObject2= affrect.GetCornerPo();
			ptObject4 = affrect.GetCornerPx();
			sc2Vector ptObject1 = affrect.GetCornerPy();
			sc2Vector ptObject3 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[0] = ptObject1.GetX();
			dTempObjectY[0] = ptObject1.GetY();
			dTempObjectX[2] = ptObject3.GetX();
			dTempObjectY[2] = ptObject3.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}

// 			// 对象位置方向模式: 0：位置12水平；
// 			if (m_bObjectPositionDirectionMode == 0)
// 			{
// 				//	（1） 2
// 				//  （3） 4
// 				// 放射矩形
// 				sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// 				sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
// 				double dYLength = (ptObject4 - ptObject2).Length();
// 				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// 				scRadian xRot;
// 				(ptObject4 - ptObject2).Angle(xRot);
// 				// 对象1点、3点连线为水平方向，应将其归一化到-90-90
// 				//				xRot = xRot.SignedNormMod180();
// 				// 对象1点、3点连线为垂直方向，应将其归一化到0-180
// 				xRot = xRot.NormMod180();
// 
// 				str.Format("对象24坐标:2X=%f,2Y=%f,4X=%f,4Y=%f",ptObject2.GetX(),ptObject2.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象24连线角度:24Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject2, dYLength, dXLength, xRot, scRadian(0));
// 
// 				ptObject2= affrect.GetCornerPo();
// 				ptObject4 = affrect.GetCornerPx();
// 				sc2Vector ptObject1 = affrect.GetCornerPy();
// 				sc2Vector ptObject3 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[0] = ptObject1.GetX();
// 				dTempObjectY[0] = ptObject1.GetY();
// 				dTempObjectX[2] = ptObject3.GetX();
// 				dTempObjectY[2] = ptObject3.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 			}
// 			else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 1：位置12竖直；
// 			{
// 				//	  （3）（1）
// 				//		4    2
// 				sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// 				sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
// 				double dXLength = (ptObject2 - ptObject4).Length();
// 				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// 				scRadian xRot;
// 				(ptObject2 - ptObject4).Angle(xRot);
// 				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 				//				xRot = xRot.SignedNormMod180();
// 				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 				xRot = xRot.SignedNormMod180();
// 
// 				str.Format("对象24坐标:2X=%f,2Y=%f,4X=%f,4Y=%f",ptObject2.GetX(),ptObject2.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象42连线角度:34Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject4, dXLength, dYLength, xRot, scRadian(skPI));
// 
// 				ptObject4 = affrect.GetCornerPo();
// 				ptObject2 = affrect.GetCornerPx();
// 				sc2Vector ptObject3 = affrect.GetCornerPy();
// 				sc2Vector ptObject1 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[0] = ptObject1.GetX();
// 				dTempObjectY[0] = ptObject1.GetY();
// 				dTempObjectX[2] = ptObject3.GetX();
// 				dTempObjectY[2] = ptObject3.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 			}
// 			else
// 			{
// 				return m_ObjectMarkPlatformPos;
// 			}

		}
		// 对象位置虚拟模式:12拍照34虚拟
		else
		{
// 			// 对象位置方向模式: 0：位置12水平
// 			if (m_bObjectPositionDirectionMode == 0)
// 			{
// 				//  1   2
// 				// (3) (4)
// 
// 				// 放射矩形
// 				sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// 				sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// 				double dXLength = (ptObject2 - ptObject1).Length();
// 				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
// 				scRadian xRot;
// 				(ptObject2 - ptObject1).Angle(xRot);
// 				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 				xRot = xRot.SignedNormMod180();
// 				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 				//xRot = xRot.NormMod180();
// 
// 				str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));
// 
// 				ptObject1 = affrect.GetCornerPo();
// 				ptObject2 = affrect.GetCornerPx();
// 				sc2Vector ptObject3 = affrect.GetCornerPy();
// 				sc2Vector ptObject4 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[2] = ptObject3.GetX();
// 				dTempObjectY[2] = ptObject3.GetY();
// 				dTempObjectX[3] = ptObject4.GetX();
// 				dTempObjectY[3] = ptObject4.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 			}
// 			else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式:1：位置12竖直；
// 			{
// 				// (3)  1
// 				// (4)  2
// 
// 				// 放射矩形
// 				sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// 				sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// 				double dXLength = (ptObject2 - ptObject1).Length();
// 				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// 				scRadian xRot;
// 				(ptObject2 - ptObject1).Angle(xRot);
// 				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 				//				xRot = xRot.SignedNormMod180();
// 				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 				xRot = xRot.NormMod180();
// 
// 				str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				scAffineRect affrect;
// 				affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));
// 
// 				ptObject1 = affrect.GetCornerPo();
// 				ptObject2 = affrect.GetCornerPx();
// 				sc2Vector ptObject3 = affrect.GetCornerPy();
// 				sc2Vector ptObject4 = affrect.GetCornerPopp();
// 
// 				str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				dTempObjectX[2] = ptObject3.GetX();
// 				dTempObjectY[2] = ptObject3.GetY();
// 				dTempObjectX[3] = ptObject4.GetX();
// 				dTempObjectY[3] = ptObject4.GetY();
// 
// 				for (int i = 0; i < m_iMarkNum; i++)
// 				{
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 				}
// 
// 			}
// 			else
// 			{
// 				return m_ObjectMarkPlatformPos;
// 			}
		}

	}


	// 根据对象产品尺寸计算虚拟点位置
// 	if (m_bTargetObjectCamSeparate && m_bEnableObjectPositionVirtualMode)
// 	{
// 		str.Format("---开始根据对象产品尺寸计算虚拟对位点---");
// 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 		double dTempObjectX[8];			//存储对象mark图像坐标
// 		double dTempObjectY[8];
// 		double dTempObjectD[8];
// 
// 		memset(dTempObjectX, 0.0, sizeof(double)*8);
// 		memset(dTempObjectY, 0.0, sizeof(double)*8);
// 		memset(dTempObjectD, 0.0, sizeof(double)*8);
// 
// 		if ((m_nObjectPositionNum == 2) && (m_nTargetPositionNum == 4))
// 		{
// 			//根据对象产品尺寸和对象12/34平台坐标虚拟目标34/12平台坐标 
// 			if ((m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0))
// 			{
// 				str.Format("对象尺寸信息错误:ObjectL1=%f,ObjectW1=%f",m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				return m_ObjectMarkPlatformPos;
// 			}
// 
// 			str.Format("对象尺寸信息:ObjectL1=%f,ObjectW1=%f",m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			for (int i = 0; i < m_iMarkNum; i++)
// 			{
// 				dTempObjectX[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX;
// 				dTempObjectY[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY;
// 				dTempObjectD[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle;
// 
// 			}
// 
// 			// 对象位置虚拟模式:0-34虚拟;1-12虚拟
// 			if (m_nObjectPositionVirtualMode == 0)
// 			{
// 				// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 				if (m_bObjectPositionDirectionMode == 0)
// 				{
// 					//  1   2
// 					// (3) (4)
// 
// 					// 放射矩形
// 					sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// 					sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// 					double dXLength = (ptObject2 - ptObject1).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
// 					scRadian xRot;
// 					(ptObject2 - ptObject1).Angle(xRot);
// 					// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 					xRot = xRot.SignedNormMod180();
// 					// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 					//xRot = xRot.NormMod180();
// 
// 					str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));
// 
// 					ptObject1 = affrect.GetCornerPo();
// 					ptObject2 = affrect.GetCornerPx();
// 					sc2Vector ptObject3 = affrect.GetCornerPy();
// 					sc2Vector ptObject4 = affrect.GetCornerPopp();
// 
// 					str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					dTempObjectX[2] = ptObject3.GetX();
// 					dTempObjectY[2] = ptObject3.GetY();
// 					dTempObjectX[3] = ptObject4.GetX();
// 					dTempObjectY[3] = ptObject4.GetY();
// 
// 					for (int i = 0; i < m_iMarkNum; i++)
// 					{
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 					}
// 				}
// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 				{
// 					// (3)  1
// 					// (4)  2
// 
// 					// 放射矩形
// 					sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// 					sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// 					double dXLength = (ptObject2 - ptObject1).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// 					scRadian xRot;
// 					(ptObject2 - ptObject1).Angle(xRot);
// 					// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 					//				xRot = xRot.SignedNormMod180();
// 					// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 					xRot = xRot.NormMod180();
// 
// 					str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));
// 
// 					ptObject1 = affrect.GetCornerPo();
// 					ptObject2 = affrect.GetCornerPx();
// 					sc2Vector ptObject3 = affrect.GetCornerPy();
// 					sc2Vector ptObject4 = affrect.GetCornerPopp();
// 
// 					str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					dTempObjectX[2] = ptObject3.GetX();
// 					dTempObjectY[2] = ptObject3.GetY();
// 					dTempObjectX[3] = ptObject4.GetX();
// 					dTempObjectY[3] = ptObject4.GetY();
// 
// 					for (int i = 0; i < m_iMarkNum; i++)
// 					{
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 					}
// 
// 				}
// 				else
// 				{
// 					return m_ObjectMarkPlatformPos;
// 				}
// 
// 
// 
// 			}
// 			// 对象位置虚拟模式:0-34虚拟;1-12虚拟
// 			else
// 			{
// 				// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 				if (m_bObjectPositionDirectionMode == 0)
// 				{
// 					// (1) (2)
// 					//  3   4
// 					sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
// 					sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
// 					double dXLength = (ptObject4 - ptObject3).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
// 					scRadian xRot;
// 					(ptObject4 - ptObject3).Angle(xRot);
// 					// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 					xRot = xRot.SignedNormMod180();
// 					// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 					//xRot = xRot.NormMod180();
// 
// 					str.Format("对象34坐标:3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("对象34连线角度:34Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));
// 
// 					ptObject3 = affrect.GetCornerPo();
// 					ptObject4 = affrect.GetCornerPx();
// 					sc2Vector ptObject1 = affrect.GetCornerPy();
// 					sc2Vector ptObject2 = affrect.GetCornerPopp();
// 
// 					str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					dTempObjectX[0] = ptObject1.GetX();
// 					dTempObjectY[0] = ptObject1.GetY();
// 					dTempObjectX[1] = ptObject2.GetX();
// 					dTempObjectY[1] = ptObject2.GetY();
// 
// 					for (int i = 0; i < m_iMarkNum; i++)
// 					{
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 					}
// 				}
// 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 				{
// 					//	3  (1)
// 					//  4  (2)
// 					sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
// 					sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
// 					double dXLength = (ptObject4 - ptObject3).Length();
// 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// 					scRadian xRot;
// 					(ptObject4 - ptObject3).Angle(xRot);
// 					// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// 					//				xRot = xRot.SignedNormMod180();
// 					// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// 					xRot = xRot.NormMod180();
// 
// 					str.Format("对象34坐标:3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("对象34连线角度:34Angle=%f",scDegree(xRot).ToDouble());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 					str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					scAffineRect affrect;
// 					affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));
// 
// 					ptObject3 = affrect.GetCornerPo();
// 					ptObject4 = affrect.GetCornerPx();
// 					sc2Vector ptObject1 = affrect.GetCornerPy();
// 					sc2Vector ptObject2 = affrect.GetCornerPopp();
// 
// 					str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					dTempObjectX[0] = ptObject1.GetX();
// 					dTempObjectY[0] = ptObject1.GetY();
// 					dTempObjectX[1] = ptObject2.GetX();
// 					dTempObjectY[1] = ptObject2.GetY();
// 
// 					for (int i = 0; i < m_iMarkNum; i++)
// 					{
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// 					}
// 				}
// 				else
// 				{
// 					return m_ObjectMarkPlatformPos;
// 				}
// 
// 			}
// 
// 		}
// 	}


	str.Format("------------------检查对象平台坐标计算结束");
	AlignToolLogRecord(str,nPlatformIndex);
	return m_ObjectMarkPlatformPos;
}

CMarkPlatformPos vcBaseAlignTool::GetObjectMarkPlatformPos(BOOL bReConstruct)
{
	if (eObjectBench == m_AlignermentParam.GetObjectMarkType())
	{
		int nPlatformIndex = m_nPlatformIndex;
		CString str;
		str.Format("对象平台坐标计算开始------------------");
		AlignToolLogRecord(str,nPlatformIndex);

		for (int i=0; i<m_iMarkNum; i++)
		{
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			m_ObjectMarkPlatformPos.m_vPos.at(i) = m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex)->GetMarkPlatformCoordPos();
			m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		str.Format("------------------对象平台坐标计算结束");
		AlignToolLogRecord(str,nPlatformIndex);

		return m_ObjectMarkPlatformPos;
	}

	//确保目标mark的平台坐标向量的长度与mark数量相同(在SetMarkNum中统一设置)
	// 	m_TargetMarkPlatformPos.m_vPos.resize(m_iMarkNum);
	// 	m_TargetMarkPlatformPos.m_vbOK.resize(m_iMarkNum);
	//针对每个相机的图像mark计算其平台坐标值
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("对象平台坐标计算开始------------------");
	AlignToolLogRecord(str,nPlatformIndex);

// 	for (int i=0; i<m_iMarkNum; i++)
// 	{	
// 
// 		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
// 		{	
// 			str.Format("对象平台坐标%d开始",i);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i),	m_pObjectPlatformAxisPos.at(i));
// 			str.Format("对象平台坐标%d结束",i);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 		else
// 		{
// 			//MFQ 20190319
// 			//ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
// 			//	m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i));
// 			str.Format("对象平台坐标%d开始",i);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			if (m_bEnableMultiCalibExtension)
// 			{
// 				*(m_vObjectCamPlatformAxisPos.at(i))=*(m_vvpObjectCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i));
// 				*(m_vObjectCamAxisPlatformAxisPos.at(i))=*(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i));
// 			}
// 			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
// 				m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i) , m_vObjectCamAxisPlatformAxisPos.at(i));
// 
// 			str.Format("对象平台坐标%d结束",i);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 
// 		m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;
// 
// 	}

	for (int i=0; i<m_iMarkNum; i++)
	{	

		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{	
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i),	m_pObjectPlatformAxisPos.at(i));
			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		else
		{
			str.Format("对象平台坐标%d开始",i);
			AlignToolLogRecord(str,nPlatformIndex);

			if (m_bEnableMultiCalibExtension)
			{
				*((CPlatformXYAxisPos*)(m_vObjectCamPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpObjectCamPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
				*((CPlatformXYAxisPos*)(m_vObjectCamAxisPlatformAxisPos.at(i)))=*((CPlatformXYAxisPos*)(m_vvpObjectCamAxisPlatformAxisPosMultiEx.at(m_nAlignnExProductIndex).at(i)));
			}

			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
				m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i) , m_vObjectCamAxisPlatformAxisPos.at(i));

			str.Format("对象平台坐标%d结束",i);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;

	}

	if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
	{

	}
	else if ( ((GetMidPlatformType() ==ePlatformXYPD) ||  (GetMidPlatformType() ==ePlatformXY)) 
		&& ((m_bTargetObjectCamSeparate == TRUE && m_iMarkNum >= 4) || (m_bTargetObjectCamSeparate == FALSE && m_iMarkNum >= 2)))
	{
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
		std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;

		int k=0;
		for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
		{
			pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置

		}
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
		if ( pObjectPlatformAxisPos.at(1)!= pObjectPlatformAxisPos.at(0))
		{
			double offsetX = 0;
			double offsetY = 0;
			offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
			offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX+=offsetX;
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY+=offsetY;
		}

		{
			// 2017.05.19
			// 对于Mark是边的情况，计算边的起点和终点（辅助定位结果点）平台坐标
			//if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
			//	|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12
			//	|| (m_iMarkNum == 8 && (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_Weight
			//							|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight)))
			{
				int nAuxiPosIndex = 0;
				for(nAuxiPosIndex = 0; nAuxiPosIndex < m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
				{
					double offsetX = 0;
					double offsetY = 0;
					offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
					offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

					m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosX.at(nAuxiPosIndex)+=offsetX;
					m_ObjectMarkPlatformPos.m_vPos.at(0).m_vdAuxiliaryPosY.at(nAuxiPosIndex)+=offsetY;
				}
			}
		}

	}

	//重新构造新的对位点================================================================================
	if ( bReConstruct && ((m_bTargetObjectCamSeparate && m_iMarkNum == 8 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 4 ))
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		CCoordPos tmpPos[4];
		int iMarkNum = 8;
		int k = 0;
		for (k=0;k<iMarkNum/2;k++)
		{
			tmpPos[k] = m_ObjectMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		CCoordPos ResultPos[4];
		scLine ResultLine[4];
		sc2Vector UsePoint[8];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;
		UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
		UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
		UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
		UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
		ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

		UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
		UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
		UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosX(1));
		UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosY(1));
		ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

		UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosX(0));
		UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosY(0));
		UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosX(0));
		UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosY(0));
		ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		UsePoint[6].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
		UsePoint[6].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
		UsePoint[7].SetX(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosX(1));
		UsePoint[7].SetY(m_ObjectMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosY(1));
		ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

		if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = crossPointArray.at(0).GetY();
		}


		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = crossPointArray.at(0).GetY();
		}


		if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(2).m_dPosY = crossPointArray.at(0).GetY();
		}


		if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(3).m_dPosY = crossPointArray.at(0).GetY();
		}

		for (k=0;k<iMarkNum/2;k++)
		{
			str.Format("修正后对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<iMarkNum/2;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosY();
			str.Format("修正前后对象位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		CCoordPos tmpPos[2];
		int k = 0;
		for (k=0;k<2;k++)
		{
			tmpPos[k] = m_ObjectMarkPlatformPos.m_vPos.at(k);
			str.Format("修正前对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX, m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		CCoordPos ResultPos[3];
		scLine ResultLine[3];
		sc2Vector UsePoint[6];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;

		// 判断公共边是水平边还是垂直边
		scLine tpmLine = scLineSeg(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPos(), m_ObjectMarkPlatformPos.m_vPos.at(1).GetPos()).GetLine();
		double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
		BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;
		str.Format("修正前对象角点连线角度[-90,90): %f ,直线是否水平线: %d", tmpAngle, bHorDirection);
		AlignToolLogRecord(str,nPlatformIndex);

		if (bHorDirection == TRUE)
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
			UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
			UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
			UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
			UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosX());
				UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
			UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosX());
				UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}
		else
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
			UsePoint[0].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
			UsePoint[1].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
			UsePoint[1].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
			UsePoint[2].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosX());
				UsePoint[3].SetY(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
			UsePoint[4].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosX());
				UsePoint[5].SetY(m_ObjectMarkPlatformPos.m_vPos.at(1).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
		}

		// 直线0和1交点，覆盖点0
		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY = crossPointArray.at(0).GetY();
		}

		// 直线0和2交点，覆盖点1
		if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = crossPointArray.at(0).GetX(); 
			m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = crossPointArray.at(0).GetY();
		}

		for (k=0;k<2;k++)
		{
			str.Format("修正后对象位置%d 平台坐标 X:, %f ,Y:, %f ,",k,m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosX, m_ObjectMarkPlatformPos.m_vPos.at(k).m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
		}
		for (k=0;k<2;k++)
		{
			double ddx = tmpPos[k].GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosX();
			double ddy = tmpPos[k].GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(k).GetPosY();
			str.Format("修正前后对象位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	//================================================================================


	str.Format("------------------对象平台坐标计算结束");
	AlignToolLogRecord(str,nPlatformIndex);
	return m_ObjectMarkPlatformPos;
}

// CMarkPlatformPos vcBaseAlignTool::GetSpecialObjectMarkPlatformPos()
// {
// 	if (m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		int nPlatformIndex = m_nPlatformIndex;
// 		CString str;
// 		str.Format(_T("扩展编号为%d的对象平台坐标计算开始------------------"),m_nAlignnExProductIndex);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 		for (int i = 0; i < m_iMarkNum; i++)
// 		{
// 			m_ObjectMarkPlatformPos.m_vPos.at(i) = CCoordPos(0, 0, 0);
// 			m_ObjectMarkPlatformPos.m_vbOK.at(i) = FALSE;
// 		}
// 
// 		if (m_iMarkNum == 8)
// 		{
// 			int nMark = m_iMarkNum / 2;
// 			int nExMark = (m_iMarkNum / 4) * m_nAlignnExProductIndex;
// 
// 			for (int i=0; i<m_iMarkNum/4; i++)
// 			{	
// 
// 				if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
// 				{	
// 					str.Format("对象平台坐标%d开始",i + nExMark);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					m_ObjectMarkPlatformPos.m_vbOK.at(i + nExMark) = 
// 						ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i + nExMark),  i + nExMark, m_ObjectSearchResults.m_vPos.at(i + nExMark),	m_pObjectPlatformAxisPos.at(i + nExMark));
// 
// 					str.Format("对象平台坐标%d结束",i + nExMark);
// 					AlignToolLogRecord(str,nPlatformIndex);
// 				}
// 				else
// 				{
// 					m_ObjectMarkPlatformPos.m_vbOK.at(i + nExMark) = 
// 						ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i + nExMark),  i + nExMark, m_ObjectSearchResults.m_vPos.at(i + nExMark), 
// 						m_pObjectPlatformAxisPos.at(i + nExMark), m_vObjectCamPlatformAxisPos.at(i + nExMark));
// 				}
// 
// 				//				m_ObjectMarkPlatformPos.m_vbOK.at(i + nExMark) = TRUE;
// 
// 			}
// 		}
// 
// 		str.Format(_T("------------------扩展编号为%d的对象平台坐标计算结束"), m_nAlignnExProductIndex);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 	}
// 
// 	return m_ObjectMarkPlatformPos;
// 
// }

BOOL vcBaseAlignTool::GetObjectMarkPlatformDistance(double &dDistance)
{
	if (!m_ObjectMarkPlatformPos.IsAllMarkPlatformPosOK())
	{
		return FALSE;
	}

	sc2Vector vMark[2];
	dDistance = 0;

	if (m_iMarkNum == 2)
	{
		// 计算对象距离
		vMark[0].SetX(m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX);
		vMark[0].SetY(m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY);
		vMark[1].SetX(m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX);
		vMark[1].SetY(m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY);
		dDistance = vMark[0].Distance(vMark[1]);


	}
	else if (m_iMarkNum == 4 && m_bTargetObjectCamSeparate == TRUE)
	{

		// 计算对象距离

		vMark[0].SetX(m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX);
		vMark[0].SetY(m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY);
		vMark[1].SetX(m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX);
		vMark[1].SetY(m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY);
		dDistance = vMark[0].Distance(vMark[1]);


	}
	else if (m_iMarkNum == 8 && m_bTargetObjectCamSeparate == TRUE)
	{
		// 计算对象距离

		vMark[0].SetX(m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX);
		vMark[0].SetY(m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY);
		vMark[1].SetX(m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX);
		vMark[1].SetY(m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY);
		dDistance = vMark[0].Distance(vMark[1]);

	}
	else
	{
		return FALSE;
	}


	return TRUE;

}

// 对象综合对位点重构
BOOL vcBaseAlignTool::ExecuteObjectPlatformPosRestruct(std::vector<CCoordPos>& vcpObjectPos)
{

	if (((m_bTargetObjectCamSeparate && m_iMarkNum == 8 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 4 ))
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		// 日志记录
		int nPlatformIndex = m_nPlatformIndex;
		CString str;

		str.Format(_T("对象重构点计算开始(4VS4)，对位方式： %d ,"), m_AlignermentParam.GetAligner4Vs4Type());
		AlignToolLogRecord(str,nPlatformIndex);

		int nMarkNum = m_iMarkNum;
		int nIndexOffset = (m_bTargetObjectCamSeparate) ? nMarkNum/2 : nMarkNum;
		std::vector<CCoordPos> vcpTempObjectPos;
		vcpTempObjectPos.resize(8);

		for (int k = 0; k < nIndexOffset; k++)
		{
			vcpTempObjectPos.at(k) = vcpObjectPos.at(k);

			str.Format("修正前对象平台坐标%d： X = %f ,Y = %f ,", k, vcpObjectPos.at(k).GetPosX(), vcpObjectPos.at(k).GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		scLine ResultLine[4];
		sc2Vector UsePoint[8];
		bool bIntersect = false;
		std::vector<sc2Vector> crossPointArray;

		UsePoint[0] = vcpObjectPos[0].GetAuxPos(0);
		UsePoint[1] = vcpObjectPos[1].GetAuxPos(0);
		ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

		UsePoint[2] = vcpObjectPos[1].GetAuxPos(1);
		UsePoint[3] = vcpObjectPos[3].GetAuxPos(1);
		ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);


		UsePoint[4] = vcpObjectPos[2].GetAuxPos(0);
		UsePoint[5] = vcpObjectPos[3].GetAuxPos(0);
		ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		UsePoint[6] = vcpObjectPos[0].GetAuxPos(1);
		UsePoint[7] = vcpObjectPos[2].GetAuxPos(1);
		ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

		//lzk 0407  易天覆膜机-位置虚拟-对象对位
		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode && m_iMarkNum == 8)
		{	
			sc2Vector ResultPoint[4];
			int nObjectPositionVirtualMode = m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;

			switch(nObjectPositionVirtualMode)
			{
			case 0:
				{
					//  1   2
					// (3) (4)
					ResultPoint[0] = ResultLine[0].Project(UsePoint[6]); // 计算给定点p在当前直线上的投影点
					ResultPoint[1] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点

					vcpObjectPos[0].m_dPosX = ResultPoint[0].GetX();
					vcpObjectPos[0].m_dPosY = ResultPoint[0].GetY();
					vcpObjectPos[1].m_dPosX = ResultPoint[1].GetX();
					vcpObjectPos[1].m_dPosY = ResultPoint[1].GetY();
				}
				break;

			case 1:
				{
					// (1) (2)
					//  3   4
					ResultPoint[2] = ResultLine[2].Project(UsePoint[7]); // 计算给定点p在当前直线上的投影点
					ResultPoint[3] = ResultLine[2].Project(UsePoint[3]); // 计算给定点p在当前直线上的投影点

					vcpObjectPos[2].m_dPosX = ResultPoint[2].GetX(); 
					vcpObjectPos[2].m_dPosY = ResultPoint[2].GetY();
					vcpObjectPos[3].m_dPosX = ResultPoint[3].GetX(); 
					vcpObjectPos[3].m_dPosY = ResultPoint[3].GetY();
				}
				break;

			case 2:
				{
					//	1  (2)
					//  3  (4)
					ResultPoint[0] = ResultLine[3].Project(UsePoint[0]); // 计算给定点p在当前直线上的投影点
					ResultPoint[2] = ResultLine[3].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点

					vcpObjectPos[0].m_dPosX = ResultPoint[0].GetX(); 
					vcpObjectPos[0].m_dPosY = ResultPoint[0].GetY();
					vcpObjectPos[2].m_dPosX = ResultPoint[2].GetX(); 
					vcpObjectPos[2].m_dPosY = ResultPoint[2].GetY();
				}
				break;

			case 3:
				{
					//	（1） 2
					//  （3） 4
					ResultPoint[1] = ResultLine[1].Project(UsePoint[1]); // 计算给定点p在当前直线上的投影点
					ResultPoint[3] = ResultLine[1].Project(UsePoint[5]); // 计算给定点p在当前直线上的投影点

					vcpObjectPos[1].m_dPosX = ResultPoint[1].GetX(); 
					vcpObjectPos[1].m_dPosY = ResultPoint[1].GetY();
					vcpObjectPos[3].m_dPosX = ResultPoint[3].GetX(); 
					vcpObjectPos[3].m_dPosY = ResultPoint[3].GetY();
				}
				break;

			default:
				{
					return FALSE;
				}
				break;

			}
		}
		else
		{
			if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpObjectPos[0].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpObjectPos[0].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpObjectPos[1].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpObjectPos[1].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpObjectPos[2].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpObjectPos[2].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpObjectPos[3].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpObjectPos[3].m_dPosY = crossPointArray.at(0).GetY();
			}
		}

		for (int k = 0; k < nIndexOffset; k++)
		{
			str.Format("修正后对象平台坐标%d： X = %f , Y = %f , ", k, vcpObjectPos.at(k).GetPosX() , vcpObjectPos.at(k).GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		for (int k = 0; k < nIndexOffset; k++)
		{
			double dOffsetX = vcpTempObjectPos.at(k).GetPosX() - vcpObjectPos.at(k).GetPosX();
			double dOffsetY = vcpTempObjectPos.at(k).GetPosY() - vcpObjectPos.at(k).GetPosY();

			str.Format("修正前后对象位置平台坐标差%d： X = %f , Y = %f ,", k, dOffsetX, dOffsetY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		str.Format(_T("对象重构点计算结束，对位方式： %d \n\n,"), m_AlignermentParam.GetAligner4Vs4Type());
		AlignToolLogRecord(str,nPlatformIndex);

		return TRUE;

	}
	else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		// 日志记录
		int nPlatformIndex = m_nPlatformIndex;
		CString str;

		str.Format(_T("对象重构点计算开始(2VS2)，对位方式： %d ,"), m_AlignermentParam.GetAligner2Vs2Type());
		AlignToolLogRecord(str,nPlatformIndex);

//		int nMarkNum = m_iMarkNum;
		int nIndexOffset = (m_bTargetObjectCamSeparate) ? m_iMarkNum/2 : m_iMarkNum;
		std::vector<CCoordPos> vcpTempObjectPos;
		vcpTempObjectPos.resize(8);

		for (int k = 0; k < nIndexOffset; k++)
		{
			vcpTempObjectPos.at(k) = vcpObjectPos.at(k);

			str.Format("修正前对象平台坐标%d： X = %f ,Y = %f ,", k, vcpTempObjectPos.at(k).GetPosX(), vcpTempObjectPos.at(k).GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		CCoordPos ResultPos[3];
		scLine ResultLine[3];
		sc2Vector UsePoint[6];
		bool bIntersect;
		std::vector<sc2Vector> crossPointArray;

		// 判断公共边是水平边还是垂直边
		scLine tpmLine = scLineSeg(m_ObjectMarkPlatformPos.m_vPos.at(0).GetPos(), m_ObjectMarkPlatformPos.m_vPos.at(1).GetPos()).GetLine();
		double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
		BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;

		str.Format("修正前对象角点连线角度[-90,90): %f ,直线是否水平线: %d", tmpAngle, bHorDirection);
		AlignToolLogRecord(str,nPlatformIndex);

		if (bHorDirection == TRUE)
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(vcpObjectPos.at(0).GetAuxiliaryPosX(0));
			UsePoint[0].SetY(vcpObjectPos.at(0).GetAuxiliaryPosY(0));
			UsePoint[1].SetX(vcpObjectPos.at(1).GetAuxiliaryPosX(0));
			UsePoint[1].SetY(vcpObjectPos.at(1).GetAuxiliaryPosY(0));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);


			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(vcpObjectPos.at(0).GetAuxiliaryPosX(1));
			UsePoint[2].SetY(vcpObjectPos.at(0).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(vcpObjectPos.at(0).GetPosX());
				UsePoint[3].SetY(vcpObjectPos.at(0).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);


			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(vcpObjectPos.at(1).GetAuxiliaryPosX(1));
			UsePoint[4].SetY(vcpObjectPos.at(1).GetAuxiliaryPosY(1));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(vcpObjectPos.at(1).GetPosX());
				UsePoint[5].SetY(vcpObjectPos.at(1).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		}
		else
		{
			// 直线0：公共边上的点组合构成
			UsePoint[0].SetX(vcpObjectPos.at(0).GetAuxiliaryPosX(1));
			UsePoint[0].SetY(vcpObjectPos.at(0).GetAuxiliaryPosY(1));
			UsePoint[1].SetX(vcpObjectPos.at(1).GetAuxiliaryPosX(1));
			UsePoint[1].SetY(vcpObjectPos.at(1).GetAuxiliaryPosY(1));
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);


			// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[2].SetX(vcpObjectPos.at(0).GetAuxiliaryPosX(0));
			UsePoint[2].SetY(vcpObjectPos.at(0).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[3].SetX(vcpObjectPos.at(0).GetPosX());
				UsePoint[3].SetY(vcpObjectPos.at(0).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);


			// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
			UsePoint[4].SetX(vcpObjectPos.at(1).GetAuxiliaryPosX(0));
			UsePoint[4].SetY(vcpObjectPos.at(1).GetAuxiliaryPosY(0));
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
			{
				UsePoint[5].SetX(vcpObjectPos.at(1).GetPosX());
				UsePoint[5].SetY(vcpObjectPos.at(1).GetPosY());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{
				UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
			}
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

		}

		// 直线0和1交点，覆盖点0
		if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			vcpObjectPos.at(0).m_dPosX = crossPointArray.at(0).GetX(); 
			vcpObjectPos.at(0).m_dPosY = crossPointArray.at(0).GetY();
		}

		// 直线0和2交点，覆盖点1
		if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
			&& crossPointArray.size() > 0)
		{
			vcpObjectPos.at(1).m_dPosX = crossPointArray.at(0).GetX(); 
			vcpObjectPos.at(1).m_dPosY = crossPointArray.at(0).GetY();
		}

		for (int k = 0; k < nIndexOffset; k++)
		{
			str.Format("修正后对象平台坐标%d： X = %f , Y = %f , ", k, vcpObjectPos.at(k).GetPosX() , vcpObjectPos.at(k).GetPosY());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		for (int k = 0; k < nIndexOffset; k++)
		{
			double dOffsetX = vcpTempObjectPos.at(k).GetPosX() - vcpObjectPos.at(k).GetPosX();
			double dOffsetY = vcpTempObjectPos.at(k).GetPosY() - vcpObjectPos.at(k).GetPosY();

			str.Format("修正前后对象位置平台坐标差%d： X = %f , Y = %f ,", k, dOffsetX, dOffsetY);
			AlignToolLogRecord(str,nPlatformIndex);
		}

		str.Format(_T("对象重构点计算结束，对位方式： %d \n\n,"), m_AlignermentParam.GetAligner2Vs2Type());
		AlignToolLogRecord(str,nPlatformIndex);

		return TRUE;

	}

	return TRUE;
}

// 对象综合对位点重构
BOOL vcBaseAlignTool::IsObjectReConstruct()
{
	BOOL bReConstruct = FALSE;

	if (((m_bTargetObjectCamSeparate && m_iMarkNum == 8 )||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 4 ))
		&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
		|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
	{
		bReConstruct = TRUE;
	}
	else if (FALSE && ((m_bTargetObjectCamSeparate && m_iMarkNum == 4)||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
		&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
	{
		bReConstruct = TRUE;
	}
	return bReConstruct;
}




CCoordPos vcBaseAlignTool::CalculateTempPlatformPos()
{
	m_TempPlatformPos = CCoordPos(0,0,0);

	for (int i=0; i</*m_iMarkNum*/1; i++)
	{
		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() && eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{
			if ( (GetMidPlatformType() == ePlatformXYPD) && (m_bTargetObjectCamSeparate) && (m_iMarkNum == 4) )
			{
				CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

				int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
				int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

				// 此时的标定轴位置：关联时获取的平台基准轴位置；（对象拍照位的位置）
				CPlatformXYDAxisPos* pPlatformBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(i)->GetPlatformAxisPos());
				CPlatformXYDAxisPos* pObjectPlatformAxisPos = (CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(i));


				double offsetX = 0;
				double offsetY = 0;

				offsetX = pObjectPlatformAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;

				offsetY = pObjectPlatformAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

				m_TempPlatformPos.m_dPosX+=offsetX;
				m_TempPlatformPos.m_dPosY+=offsetY;

			}
		}
	}

	return m_TempPlatformPos;

}

CCoordPos vcBaseAlignTool::GetCalculateTempPlatformPos()
{
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	CCoordPos TempPos = m_TempPlatformPos;

	if (eDirectNegative == iPlatformXCoordType) TempPos.m_dPosX = -1*TempPos.m_dPosX;
	if (eDirectNegative == iPlatformYCoordType) TempPos.m_dPosY = -1*TempPos.m_dPosY;

	return TempPos;
}


//////////////////////////////////////////////////////////////////////////
// 虚拟Mark
void vcBaseAlignTool::SetVirtualPlatformPos(CPlatformAxisPos* pPlatformAxisPos)
{
	if (m_pVirtualPlatformAxisPos!= NULL)
	{
		delete m_pVirtualPlatformAxisPos;
		m_pVirtualPlatformAxisPos = NULL;
	}

	if ( ePlatformXYD== pPlatformAxisPos->GetPlatformType())
	{	
		m_pVirtualPlatformAxisPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
	}
}

void vcBaseAlignTool::SetVirtualPlatformPos(std::vector<CPlatformAxisPos*> pPlatformAxisPos)
{
	int i=0;
	for (i=0;i<m_vpVirtualPlatformAxisPos.size();i++)
	{
		if (m_vpVirtualPlatformAxisPos.at(i)!= NULL)
		{
			delete m_vpVirtualPlatformAxisPos.at(i);
			m_vpVirtualPlatformAxisPos.at(i) = NULL;
		}
	}
	m_vpVirtualPlatformAxisPos.clear();

	for (i=0;i<pPlatformAxisPos.size();i++)
	{
		if ( ePlatformXYD== pPlatformAxisPos.at(i)->GetPlatformType())
		{	
			CPlatformAxisPos* platformAxisPos;
			platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos.at(i)));
			m_vpVirtualPlatformAxisPos.push_back(platformAxisPos); 
		}
	}

}

void vcBaseAlignTool::SetVirtualPlatformPos(CPlatformAxisPos* pPlatformAxisPos,int nIndex)
{
	if (nIndex<0|| pPlatformAxisPos==NULL)
	{
		return;
	}
	if (nIndex+1>m_vpVirtualPlatformAxisPos.size())
	{
		m_vpVirtualPlatformAxisPos.resize(nIndex+1);
	}//????


	if (m_vpVirtualPlatformAxisPos.at(nIndex)!= NULL)
	{
		delete m_vpVirtualPlatformAxisPos.at(nIndex);
		m_vpVirtualPlatformAxisPos.at(nIndex) = NULL;
	}	

	if ( ePlatformXYD== pPlatformAxisPos->GetPlatformType())
	{
		CPlatformAxisPos *platformAxisPos;
		platformAxisPos= new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)pPlatformAxisPos));
		m_vpVirtualPlatformAxisPos.at(nIndex)=platformAxisPos; 
	}
}

CPlatformAxisPos* vcBaseAlignTool::GetVirtualPlatformPos()
{
	return m_pVirtualPlatformAxisPos;
}

CPlatformAxisPos* vcBaseAlignTool::GetVirtualPlatformPos(int nIndex)
{
	if (nIndex<0 || nIndex>=m_vpVirtualPlatformAxisPos.size())
	{
		return NULL;
	}

	if (m_vpVirtualPlatformAxisPos.at(nIndex)==NULL)
	{
		return NULL;
	}

	return m_vpVirtualPlatformAxisPos.at(nIndex); 
}

void vcBaseAlignTool::SetVirtualMarkSearchResults(CMarkImagePos ImageResults)
{
	m_VirtualSearchResults = ImageResults;	
}

CMarkImagePos vcBaseAlignTool::GetVirtualMarkSearchResults()
{
	return m_VirtualSearchResults;
}

void vcBaseAlignTool::SetVirtualCameraPos(std::vector<CPlatformAxisPos*> pCamPlatformAxisPos)
{
	for (int i=0; i<m_vVirtualCamPlatformAxisPos.size(); i++)
	{
		if (m_vVirtualCamPlatformAxisPos.at(i)!= NULL)
		{
			delete m_vVirtualCamPlatformAxisPos.at(i);
			m_vVirtualCamPlatformAxisPos.at(i) = NULL;
		}
	}
	m_vVirtualCamPlatformAxisPos.clear();

	for (int j=0; j<pCamPlatformAxisPos.size(); j++)
	{
		if (pCamPlatformAxisPos.at(j) != NULL)
		{
			CPlatformXYAxisPos* pAxisPos = new CPlatformXYAxisPos(*((CPlatformXYAxisPos*)pCamPlatformAxisPos.at(j)));
			m_vVirtualCamPlatformAxisPos.push_back(pAxisPos);
		}
	}
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetVirtualCameraPos()
{
	return m_vVirtualCamPlatformAxisPos;
}


// 获取虚拟Mark的全局平台坐标值
CMarkPlatformPos vcBaseAlignTool::GetVirtualMarkPltfmPos()
{
	 //针对每个图像mark计算其平台坐标值
	 for (int i=0; i<m_iMarkNum; i++)
	 {
		 if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() ||eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		 {
			 ConvertImagePosToCurPlatformPos(m_VirtualMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_VirtualSearchResults.m_vPos.at(i), 
				 m_vpVirtualPlatformAxisPos.at(i));
		 }
		 else
		 {
			 ConvertImagePosToCurPlatformPos(m_VirtualMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_VirtualSearchResults.m_vPos.at(i), 
				 m_vpVirtualPlatformAxisPos.at(i), m_vVirtualCamPlatformAxisPos.at(i));
		 }

		 m_VirtualMarkPlatformPos.m_vbOK.at(i) = TRUE;
	 }

	 return m_VirtualMarkPlatformPos;
 }

 // 获取基于标定角度情况下的虚拟Mark的全局平台坐标值
CMarkPlatformPos vcBaseAlignTool::GetVirtualMarkPltfmPosEX()
{
	//针对每个图像mark计算其平台坐标值
	for (int i=0; i<m_iMarkNum; i++)
	{
		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() ||eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{
			ConvertImagePosToCurPlatformPos(m_VirtualMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_VirtualSearchResults.m_vPos.at(i), 
				m_vpVirtualPlatformAxisPos.at(i), FALSE);
		}
		else
		{
			ConvertImagePosToCurPlatformPos(m_VirtualMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_VirtualSearchResults.m_vPos.at(i), 
				m_vpVirtualPlatformAxisPos.at(i), m_vVirtualCamPlatformAxisPos.at(i));
		}
		m_VirtualMarkPlatformPos.m_vbOK.at(i) = TRUE;
	}

	if ( GetMidPlatformType() ==ePlatformXYPD)
	{
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
		std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;
		std::vector<CPlatformXYDAxisPos*> pVirtualPlatformAxisPos;

		int k=0;
		for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
		{
			pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置

		}
		for (k=0;k<m_vpVirtualPlatformAxisPos.size();k++)
		{
			pVirtualPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_vpVirtualPlatformAxisPos.at(k)));
		}
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
		for (int m=0;m<m_iMarkNum;m++)
		{
			if (pVirtualPlatformAxisPos.at(m)!=pObjectPlatformAxisPos.at(1))
			{
				double offsetX = 0;
				double offsetY = 0;
				offsetX = pVirtualPlatformAxisPos.at(m)->m_dPosX - pObjectPlatformAxisPos.at(1)->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
				offsetY =  pVirtualPlatformAxisPos.at(m)->m_dPosY - pObjectPlatformAxisPos.at(1)->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

				m_VirtualMarkPlatformPos.m_vPos.at(m).m_dPosX-=offsetX;
				m_VirtualMarkPlatformPos.m_vPos.at(m).m_dPosY-=offsetY;
			}
		}
	}

	return m_VirtualMarkPlatformPos;
}

// 基于标定角度情况下的对象Mark的全局平台坐标值（虚拟Mark）
CMarkPlatformPos vcBaseAlignTool::GetObjectMarkPlatformPosEX()
{
	for (int i=0; i<m_iMarkNum; i++)
	{	

		if (eCamPlatformSepX != m_pCamPlatformInfo->GetCamPlatformType() ||eCamPlatformSepXY != m_pCamPlatformInfo->GetCamPlatformType() )
		{
			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i),	m_pObjectPlatformAxisPos.at(i), FALSE);
		}
		else
		{
			ConvertImagePosToCurPlatformPos(m_ObjectMarkPlatformPos.m_vPos.at(i),  i + m_iMarkNum*m_nAlignnExProductIndex, m_ObjectSearchResults.m_vPos.at(i), 
				m_pObjectPlatformAxisPos.at(i), m_vObjectCamPlatformAxisPos.at(i));
		}

		m_ObjectMarkPlatformPos.m_vbOK.at(i) = TRUE;
	}


	if ( GetMidPlatformType() ==ePlatformXYPD || GetMidPlatformType()==ePlatformXY || GetMidPlatformType() == ePlatformX || GetMidPlatformType() == ePlatformY)
	{
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
		std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;

		int k=0;
		for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
		{
			pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置

		}
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
		if ( pObjectPlatformAxisPos.at(1)!= pObjectPlatformAxisPos.at(0))
		{
			double offsetX = 0;
			double offsetY = 0;
			offsetX = pObjectPlatformAxisPos.at(1)->m_dPosX - pObjectPlatformAxisPos.at(0)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) offsetX = -1*offsetX;
			offsetY =  pObjectPlatformAxisPos.at(1)->m_dPosY - pObjectPlatformAxisPos.at(0)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) offsetY = -1*offsetY;

			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosX+=offsetX;
			m_ObjectMarkPlatformPos.m_vPos.at(0).m_dPosY+=offsetY;
		}

	}
	return m_ObjectMarkPlatformPos;


}


// 计算对象Mark到虚拟Mark之间的位置关系
BOOL vcBaseAlignTool::CalculateObjectToVirtualMarkOffset(std::vector<CCoordPos>& vObjectToVirtualOffsets)
{	
	for(int k = 0; k < m_iMarkNum; k++)
	{	
		if (k + m_iMarkNum*m_nAlignnExProductIndex < m_vAlignerCalibInfos.size() && m_vAlignerCalibInfos[k + m_iMarkNum*m_nAlignnExProductIndex] != NULL)
		{
			if (!m_vAlignerCalibInfos.at(k + m_iMarkNum*m_nAlignnExProductIndex)->IsValid())
			{
				return FALSE;
			}
		}
	}
	//前面再加上保护
	if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK())
	{
		return FALSE;
	}
	if (FALSE == m_VirtualSearchResults.IsAllMarkImagePosOK())
	{
		return FALSE;
	}
	if (m_iMarkNum != m_VirtualSearchResults.GetMarkImagePosNum())
	{
		return FALSE;
	}
	if (m_iMarkNum != m_ObjectSearchResults.GetMarkImagePosNum())
	{
		return FALSE;
	}		


// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		// 判断对象轴位置以及虚拟对象轴位置的D轴是否一致
// 		int m;
// 		for(m = 0; m < m_pObjectPlatformAxisPos.size()/4; m++)
// 		{
// 			if (fabs(((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(0))->m_dAngle - ((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m))->m_dAngle) > 0.000001/*DBL_EPSILON*/ )
// 			{
// 				return FALSE;
// 			}
// 		}
// 
// 		for(m = 0; m < m_pObjectPlatformAxisPos.size()/4 && m < m_vpVirtualPlatformAxisPos.size()/4; m++)
// 		{
// 			if (fabs(((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(0))->m_dAngle - ((CPlatformXYDAxisPos*)m_vpVirtualPlatformAxisPos.at(m))->m_dAngle) > 0.000001/*DBL_EPSILON*/)
// 			{
// 				return FALSE;
// 			}
// 		}
// 
// 		for(m = 0; m < m_pObjectPlatformAxisPos.size()/4; m++)
// 		{
// 			if (fabs(((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(2))->m_dAngle - ((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m+2))->m_dAngle) > 0.000001/*DBL_EPSILON*/ )
// 			{
// 				return FALSE;
// 			}
// 		}
// 
// 		for(m = 0; m < m_pObjectPlatformAxisPos.size()/4 && m < m_vpVirtualPlatformAxisPos.size()/4; m++)
// 		{
// 			if (fabs(((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(2))->m_dAngle - ((CPlatformXYDAxisPos*)m_vpVirtualPlatformAxisPos.at(m+2))->m_dAngle) > 0.000001/*DBL_EPSILON*/)
// 			{
// 				return FALSE;
// 			}
// 		}
// 
// 
// 		// $1   实时对象Mark和虚拟Mark的图像坐标值转化为平台坐标值（标准方向）
// 		m_ObjectMarkPlatformPos = GetObjectMarkPlatformPosEX();	
// 		m_VirtualMarkPlatformPos = GetVirtualMarkPltfmPosEX();	
// 		vObjectToVirtualOffsets.resize(m_iMarkNum);
// 
// 		double dDegLx = 0; 
// 		for (int i=0; i<m_iMarkNum/2;i++)
// 		{
// 			//过mark点建立坐标系
// 			double dMarkX = m_ObjectMarkPlatformPos.GetMarkPlatformPos(i).m_dPosX;
// 			double dMarkY = m_ObjectMarkPlatformPos.GetMarkPlatformPos(i).m_dPosY;
// 			double dVirtualMarkX = m_VirtualMarkPlatformPos.GetMarkPlatformPos(i).m_dPosX;
// 			double dVirtualMarkY = m_VirtualMarkPlatformPos.GetMarkPlatformPos(i).m_dPosY;
// 			scLine Lx, Ly;
// 			Lx.SetPos(sc2Vector(dMarkX, dMarkY));
// 			Lx.SetRotation(scDegree(dDegLx));
// 			Ly.SetPos(sc2Vector(dMarkX, dMarkY));
// 			Ly.SetRotation(scDegree(dDegLx+90));
// 
// 			//计算虚拟mark点到直线Lx，Ly的投影点坐标和距离
// 			double dx, dy;
// 			double dProjectToLxLength = 0, dProjectToLyLength = 0;
// 			sc2Vector ProjectToLxPt, ProjectToLyPt;
// 			ProjectToLxPt = Lx.Project(sc2Vector(dVirtualMarkX, dVirtualMarkY));
// 			ProjectToLyPt = Ly.Project(sc2Vector(dVirtualMarkX, dVirtualMarkY));
// 
// 			dx = ProjectToLxPt.GetX() - dMarkX;
// 			dy = ProjectToLxPt.GetY() - dMarkY;
// 			dProjectToLxLength = sqrt(dx*dx + dy*dy);
// 			if (dx < 0) dProjectToLxLength = -1*dProjectToLxLength;
// 
// 			dx = ProjectToLyPt.GetX() - dMarkX;
// 			dy = ProjectToLyPt.GetY() - dMarkY;
// 			dProjectToLyLength = sqrt(dx*dx + dy*dy);
// 			if (dy < 0) dProjectToLyLength = -1*dProjectToLyLength;
// 
// 			//记录结果
// 			CCoordPos pos;
// 			pos.m_dPosX = dProjectToLxLength;
// 			pos.m_dPosY  = dProjectToLyLength;
// 			vObjectToVirtualOffsets.at(i) = pos;
// 
// 		}
// 
// 		return TRUE;
// 	}

	if (m_bTargetObjectCamSeparate)
	{
		// 判断对象轴位置以及虚拟对象轴位置的D轴是否一致
		int m;
		for(m = 0; m < m_pObjectPlatformAxisPos.size()/2; m++)
		{
			if (fabs(((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(0))->m_dAngle - ((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m))->m_dAngle) > 0.000001/*DBL_EPSILON*/ )
			{
				return FALSE;
			}
		}

		for(m = 0; m < m_pObjectPlatformAxisPos.size()/2 && m < m_vpVirtualPlatformAxisPos.size()/2; m++)
		{
			if (fabs(((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(0))->m_dAngle - ((CPlatformXYDAxisPos*)m_vpVirtualPlatformAxisPos.at(m))->m_dAngle) > 0.000001/*DBL_EPSILON*/)
			{
				return FALSE;
			}
		}



		// 	//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
		// 	//相机平台类型没有基类，不用改；
		// 	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
		// 	CPlatformXYDAxisPos* pObjectPlatformAxisPos = (CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos;
		// 	CPlatformXYDAxisPos* pVirtualPlatformAxisPos = (CPlatformXYDAxisPos*)m_pVirtualPlatformAxisPos;

		CString str;

		// $1   实时对象Mark和虚拟Mark的图像坐标值转化为平台坐标值（标准方向）
		m_ObjectMarkPlatformPos = GetObjectMarkPlatformPosEX();	
		m_VirtualMarkPlatformPos = GetVirtualMarkPltfmPosEX();	
		vObjectToVirtualOffsets.resize(m_iMarkNum);
		// 	str.Format("MarkPlatformPos0: X=%f,Y=%f",m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX,m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY);
		// 	AlignToolLogRecord(str);
		// 	str.Format("MarkPlatformPos1: X=%f,Y=%f",m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX,m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY);
		// 	AlignToolLogRecord(str);
		// 
		// 	str.Format("VirtualMarkPlatformPos0: X=%f,Y=%f",m_VirtualMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX,m_VirtualMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY);
		// 	AlignToolLogRecord(str);
		// 	str.Format("VirtualMarkPlatformPos1: X=%f,Y=%f",m_VirtualMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX,m_VirtualMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY);
		// 	AlignToolLogRecord(str);

		double dDegLx;//mark坐标系与平台坐标系的夹角
		if (4 == m_iMarkNum)
		{
			double dCH0X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX;
			double dCH0Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY;
			double dCH1X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX;
			double dCH1Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY;
			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
			Lx.SetFromLineSeg(lineSeg);
			dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
			// 		str.Format("dDegLx=%f",dDegLx);
			// 		AlignToolLogRecord(str);
		}
		else
		{
			return FALSE;
		}


		for (int i=0; i<m_iMarkNum/2;i++)
		{
			//过mark点建立坐标系
			double dMarkX = m_ObjectMarkPlatformPos.GetMarkPlatformPos(i).m_dPosX;
			double dMarkY = m_ObjectMarkPlatformPos.GetMarkPlatformPos(i).m_dPosY;
			double dVirtualMarkX = m_VirtualMarkPlatformPos.GetMarkPlatformPos(i).m_dPosX;
			double dVirtualMarkY = m_VirtualMarkPlatformPos.GetMarkPlatformPos(i).m_dPosY;
			scLine Lx, Ly;
			Lx.SetPos(sc2Vector(dMarkX, dMarkY));
			Lx.SetRotation(scDegree(dDegLx));
			Ly.SetPos(sc2Vector(dMarkX, dMarkY));
			Ly.SetRotation(scDegree(dDegLx+90));

			//计算虚拟mark点到直线Lx，Ly的投影点坐标和距离
			double dx, dy;
			double dProjectToLxLength = 0, dProjectToLyLength = 0;
			sc2Vector ProjectToLxPt, ProjectToLyPt;
			ProjectToLxPt = Lx.Project(sc2Vector(dVirtualMarkX, dVirtualMarkY));
			ProjectToLyPt = Ly.Project(sc2Vector(dVirtualMarkX, dVirtualMarkY));
			// 		str.Format("Mark%d: ProjectTOLXPt=%f,ProjectToLyPt=%f",i,ProjectToLxPt,ProjectToLyPt);
			// 		AlignToolLogRecord(str);

			dx = ProjectToLxPt.GetX() - dMarkX;
			dy = ProjectToLxPt.GetY() - dMarkY;
			dProjectToLxLength = sqrt(dx*dx + dy*dy);
			if (dx < 0) dProjectToLxLength = -1*dProjectToLxLength;

			dx = ProjectToLyPt.GetX() - dMarkX;
			dy = ProjectToLyPt.GetY() - dMarkY;
			dProjectToLyLength = sqrt(dx*dx + dy*dy);
			if (dy < 0) dProjectToLyLength = -1*dProjectToLyLength;
			// 		str.Format("Mark%d: dProjectToLxLength=%f,dProjectToLyLength=%f",i,dProjectToLxLength,dProjectToLyLength);
			// 		AlignToolLogRecord(str);

			//记录结果
			CCoordPos pos;
			pos.m_dPosX = dProjectToLxLength;
			pos.m_dPosY  = dProjectToLyLength;
			vObjectToVirtualOffsets.at(i) = pos;

		}

		return TRUE;
	}

	// 判断对象轴位置以及虚拟对象轴位置的D轴是否一致
	int m;
	for(m = 0; m < m_pObjectPlatformAxisPos.size(); m++)
	{
		if (fabs(((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(0))->m_dAngle - ((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m))->m_dAngle) > 0.000001/*DBL_EPSILON*/ )
		{
			return FALSE;
		}
	}

	for(m = 0; m < m_pObjectPlatformAxisPos.size() && m < m_vpVirtualPlatformAxisPos.size(); m++)
	{
		if (fabs(((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(0))->m_dAngle - ((CPlatformXYDAxisPos*)m_vpVirtualPlatformAxisPos.at(m))->m_dAngle) > 0.000001/*DBL_EPSILON*/)
		{
			return FALSE;
		}
	}



	// 	//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
	// 	//相机平台类型没有基类，不用改；
	// 	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
	// 	CPlatformXYDAxisPos* pObjectPlatformAxisPos = (CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos;
	// 	CPlatformXYDAxisPos* pVirtualPlatformAxisPos = (CPlatformXYDAxisPos*)m_pVirtualPlatformAxisPos;

	CString str;

	// $1   实时对象Mark和虚拟Mark的图像坐标值转化为平台坐标值（标准方向）
	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPosEX();	
	m_VirtualMarkPlatformPos = GetVirtualMarkPltfmPosEX();	
	vObjectToVirtualOffsets.resize(m_iMarkNum);
	// 	str.Format("MarkPlatformPos0: X=%f,Y=%f",m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX,m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY);
	// 	AlignToolLogRecord(str);
	// 	str.Format("MarkPlatformPos1: X=%f,Y=%f",m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX,m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY);
	// 	AlignToolLogRecord(str);
	// 
	// 	str.Format("VirtualMarkPlatformPos0: X=%f,Y=%f",m_VirtualMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX,m_VirtualMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY);
	// 	AlignToolLogRecord(str);
	// 	str.Format("VirtualMarkPlatformPos1: X=%f,Y=%f",m_VirtualMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX,m_VirtualMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY);
	// 	AlignToolLogRecord(str);

	double dDegLx;//mark坐标系与平台坐标系的夹角
	if (2 == m_iMarkNum)
	{
		double dCH0X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosX;
		double dCH0Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(0).m_dPosY;
		double dCH1X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX;
		double dCH1Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY;
		// 构造实时mark对直线Lx
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
		Lx.SetFromLineSeg(lineSeg);
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
		// 		str.Format("dDegLx=%f",dDegLx);
		// 		AlignToolLogRecord(str);
	}
	else if (3 == m_iMarkNum)
	{
		double dCH1X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX;
		double dCH1Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY;
		double dCH2X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(2).m_dPosX;
		double dCH2Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(2).m_dPosY;
		// 构造实时mark对直线Lx
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
		Lx.SetFromLineSeg(lineSeg);
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else if (4 == m_iMarkNum)
	{
		double dCH1X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosX;
		double dCH1Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(1).m_dPosY;
		double dCH2X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(2).m_dPosX;
		double dCH2Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(2).m_dPosY;
		// 构造实时mark对直线Lx
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
		Lx.SetFromLineSeg(lineSeg);
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else if (5 == m_iMarkNum)
	{
		double dCH2X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(2).m_dPosX;
		double dCH2Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(2).m_dPosY;
		double dCH3X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(3).m_dPosX;
		double dCH3Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(3).m_dPosY;
		// 构造实时mark对直线Lx
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH3X, dCH3Y));
		Lx.SetFromLineSeg(lineSeg);
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else if (6 == m_iMarkNum)
	{
		double dCH2X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(2).m_dPosX;
		double dCH2Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(2).m_dPosY;
		double dCH3X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(3).m_dPosX;
		double dCH3Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(3).m_dPosY;
		double dCH4X = m_ObjectMarkPlatformPos.GetMarkPlatformPos(4).m_dPosX;
		double dCH4Y = m_ObjectMarkPlatformPos.GetMarkPlatformPos(4).m_dPosY;
		// 构造实时mark对直线Lx
		scLine L23,Lx;
		scLineSeg lineSeg23(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH3X, dCH3Y));
		L23.SetFromLineSeg(lineSeg23);
		sc2Vector PtCenter = L23.Project(sc2Vector(dCH4X, dCH4Y));
		scLineSeg lineSeg(PtCenter, sc2Vector(dCH4X, dCH4Y));
		Lx.SetFromLineSeg(lineSeg);		
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else
		return FALSE;


	for (int i=0; i<m_iMarkNum;i++)
	{
		//过mark点建立坐标系
		double dMarkX = m_ObjectMarkPlatformPos.GetMarkPlatformPos(i).m_dPosX;
		double dMarkY = m_ObjectMarkPlatformPos.GetMarkPlatformPos(i).m_dPosY;
		double dVirtualMarkX = m_VirtualMarkPlatformPos.GetMarkPlatformPos(i).m_dPosX;
		double dVirtualMarkY = m_VirtualMarkPlatformPos.GetMarkPlatformPos(i).m_dPosY;
		scLine Lx, Ly;
		Lx.SetPos(sc2Vector(dMarkX, dMarkY));
		Lx.SetRotation(scDegree(dDegLx));
		Ly.SetPos(sc2Vector(dMarkX, dMarkY));
		Ly.SetRotation(scDegree(dDegLx+90));

		//计算虚拟mark点到直线Lx，Ly的投影点坐标和距离
		double dx, dy;
		double dProjectToLxLength = 0, dProjectToLyLength = 0;
		sc2Vector ProjectToLxPt, ProjectToLyPt;
		ProjectToLxPt = Lx.Project(sc2Vector(dVirtualMarkX, dVirtualMarkY));
		ProjectToLyPt = Ly.Project(sc2Vector(dVirtualMarkX, dVirtualMarkY));
		// 		str.Format("Mark%d: ProjectTOLXPt=%f,ProjectToLyPt=%f",i,ProjectToLxPt,ProjectToLyPt);
		// 		AlignToolLogRecord(str);

		dx = ProjectToLxPt.GetX() - dMarkX;
		dy = ProjectToLxPt.GetY() - dMarkY;
		dProjectToLxLength = sqrt(dx*dx + dy*dy);
		if (dx < 0) dProjectToLxLength = -1*dProjectToLxLength;

		dx = ProjectToLyPt.GetX() - dMarkX;
		dy = ProjectToLyPt.GetY() - dMarkY;
		dProjectToLyLength = sqrt(dx*dx + dy*dy);
		if (dy < 0) dProjectToLyLength = -1*dProjectToLyLength;
		// 		str.Format("Mark%d: dProjectToLxLength=%f,dProjectToLyLength=%f",i,dProjectToLxLength,dProjectToLyLength);
		// 		AlignToolLogRecord(str);

		//记录结果
		CCoordPos pos;
		pos.m_dPosX = dProjectToLxLength;
		pos.m_dPosY  = dProjectToLyLength;
		vObjectToVirtualOffsets.at(i) = pos;

	}

	return TRUE;

}

//	设置对象Mark到虚拟Mark之间的位置关系
void vcBaseAlignTool::SetObjectMarkToVirtualMarkOffset(std::vector<CCoordPos> vObjectToVirtualOffsets)
{
	//获取mark个数
	// 安登奎 （m_AlignermentParam->m_vObjectVirtualMarkOffset与vObjectToVirtualOffsets大小关系容错处理）
	// 	vObjectToVirtualOffsets.resize(m_iMarkNum);

	for (int i=0; i<m_iMarkNum; i++)
	{
		CCoordPos pos = vObjectToVirtualOffsets.at(i);
		m_AlignermentParam.SetVirtualObjectMarkOffset(i, pos);
	}

	for (int i=0; i<vObjectToVirtualOffsets.size(); i++)
	{
		CCoordPos pos = vObjectToVirtualOffsets.at(i);
		m_AlignermentParam.SetVirtualObjectMarkOffset(i, pos);
	}
}


BOOL vcBaseAlignTool::ConvertObjectPltfmPtToVirtualPltfmPt( std::vector<CCoordPos> vObjectPlatformPos,
	std::vector<CCoordPos>& vVirtualPlatformPos)
{

// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		double dDegLx;//mark坐标系与平台坐标系的夹角
// 
// 
// 		int nMark = m_iMarkNum/2;
// 		int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;
// 
// 		if (m_iMarkNum == 8)
// 		{
// 			double dCH0X = vObjectPlatformPos.at(0 + nExMark).m_dPosX;
// 			double dCH0Y = vObjectPlatformPos.at(0 + nExMark).m_dPosY;
// 			double dCH1X = vObjectPlatformPos.at(1 + nExMark).m_dPosX;
// 			double dCH1Y = vObjectPlatformPos.at(1 + nExMark).m_dPosY;
// 			// 构造实时mark对直线Lx、LyCH0、LyCH1
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 			dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
// 
// 		}
// 		else
// 		{
// 			return FALSE;
// 		}
// 
// 
// 		for (int i=0; i<m_iMarkNum/4;i++)
// 		{
// 			// 对相机各通道虚拟Mark点的平台坐标值进行修正
// 			double dValue;
// 			sc2Vector Px, Py;
// 			sc2Vector PtIntersect;
// 			dValue = vObjectPlatformPos.at(i + nExMark).m_dPosX + cos(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i + nExMark).m_dPosX;
// 			Px.SetX(dValue);
// 			dValue = vObjectPlatformPos.at(i + nExMark).m_dPosY + sin(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i + nExMark).m_dPosX;
// 			Px.SetY(dValue);
// 
// 			dValue = vObjectPlatformPos.at(i + nExMark).m_dPosX - sin(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i + nExMark).m_dPosY;
// 			Py.SetX(dValue);
// 			dValue = vObjectPlatformPos.at(i + nExMark).m_dPosY + cos(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i + nExMark).m_dPosY;
// 			Py.SetY(dValue);
// 			scLine Lx2;
// 			Lx2.SetPos(Px);
// 			Lx2.SetRotation(scDegree(dDegLx+90));
// 			PtIntersect = Lx2.Project(Py);
// 			//记录结果
// 			CCoordPos pos;
// 			pos.m_dPosX = PtIntersect.GetX();
// 			pos.m_dPosY  = PtIntersect.GetY();
// 			vVirtualPlatformPos.at(i + nExMark) = pos;
// 
// 		}
// 
// 
// 		return TRUE;
// 	}

	double dDegLx;//mark坐标系与平台坐标系的夹角

	if (m_bTargetObjectCamSeparate)
	{
		if (m_iMarkNum == 4)
		{
			double dCH0X = vObjectPlatformPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformPos.at(1).m_dPosY;
			// 构造实时mark对直线Lx、LyCH0、LyCH1
			scLine Lx;
			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
			Lx.SetFromLineSeg(lineSeg);
			dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
		}
		else
		{
			return FALSE;
		}


		for (int i=0; i<m_iMarkNum/2;i++)
		{
			// 对相机各通道虚拟Mark点的平台坐标值进行修正
			double dValue;
			sc2Vector Px, Py;
			sc2Vector PtIntersect;
			dValue = vObjectPlatformPos.at(i).m_dPosX + cos(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i).m_dPosX;
			Px.SetX(dValue);
			dValue = vObjectPlatformPos.at(i).m_dPosY + sin(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i).m_dPosX;
			Px.SetY(dValue);

			dValue = vObjectPlatformPos.at(i).m_dPosX - sin(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i).m_dPosY;
			Py.SetX(dValue);
			dValue = vObjectPlatformPos.at(i).m_dPosY + cos(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i).m_dPosY;
			Py.SetY(dValue);
			scLine Lx2;
			Lx2.SetPos(Px);
			Lx2.SetRotation(scDegree(dDegLx+90));
			PtIntersect = Lx2.Project(Py);
			//记录结果
			CCoordPos pos;
			pos.m_dPosX = PtIntersect.GetX();
			pos.m_dPosY  = PtIntersect.GetY();
			vVirtualPlatformPos.at(i) = pos;

		}

		return TRUE;
	}

	if (2 == m_iMarkNum)
	{
		double dCH0X = vObjectPlatformPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformPos.at(1).m_dPosY;
		// 构造实时mark对直线Lx、LyCH0、LyCH1
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
		Lx.SetFromLineSeg(lineSeg);
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else if (3 == m_iMarkNum)
	{
		double dCH1X = vObjectPlatformPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformPos.at(1).m_dPosY;
		double dCH2X = vObjectPlatformPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformPos.at(2).m_dPosY;
		// 构造实时mark对直线Lx、LyCH0、LyCH1
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
		Lx.SetFromLineSeg(lineSeg);
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else if (4 == m_iMarkNum)
	{
		double dCH1X = vObjectPlatformPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformPos.at(1).m_dPosY;
		double dCH2X = vObjectPlatformPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformPos.at(2).m_dPosY;
		// 构造实时mark对直线Lx、LyCH0、LyCH1
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
		Lx.SetFromLineSeg(lineSeg);
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else if (5 == m_iMarkNum)
	{
		double dCH2X = vObjectPlatformPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformPos.at(2).m_dPosY;
		double dCH3X = vObjectPlatformPos.at(3).m_dPosX;
		double dCH3Y = vObjectPlatformPos.at(3).m_dPosY;
		// 构造实时mark对直线Lx、LyCH0、LyCH1
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH3X, dCH3Y), sc2Vector(dCH2X, dCH2Y));
		Lx.SetFromLineSeg(lineSeg);
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else if (6 == m_iMarkNum)
	{
		double dCH2X = vObjectPlatformPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformPos.at(2).m_dPosY;
		double dCH3X = vObjectPlatformPos.at(3).m_dPosX;
		double dCH3Y = vObjectPlatformPos.at(3).m_dPosY;
		double dCH4X = vObjectPlatformPos.at(4).m_dPosX;
		double dCH4Y = vObjectPlatformPos.at(4).m_dPosY;
		// 构造实时mark对直线Lx
		scLine L23,Lx;
		scLineSeg lineSeg23(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH3X, dCH3Y));
		L23.SetFromLineSeg(lineSeg23);
		sc2Vector PtCenter = L23.Project(sc2Vector(dCH4X, dCH4Y));
		scLineSeg lineSeg(PtCenter, sc2Vector(dCH4X, dCH4Y));
		Lx.SetFromLineSeg(lineSeg);		
		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else
		return FALSE;


	for (int i=0; i<m_iMarkNum;i++)
	{
		// 对相机各通道虚拟Mark点的平台坐标值进行修正
		double dValue;
		sc2Vector Px, Py;
		sc2Vector PtIntersect;
		dValue = vObjectPlatformPos.at(i).m_dPosX + cos(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i + m_iMarkNum*m_nAlignnExProductIndex).m_dPosX;
		Px.SetX(dValue);
		dValue = vObjectPlatformPos.at(i).m_dPosY + sin(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i + m_iMarkNum*m_nAlignnExProductIndex).m_dPosX;
		Px.SetY(dValue);

		dValue = vObjectPlatformPos.at(i).m_dPosX - sin(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i + m_iMarkNum*m_nAlignnExProductIndex).m_dPosY;
		Py.SetX(dValue);
		dValue = vObjectPlatformPos.at(i).m_dPosY + cos(scDegree(dDegLx))*m_AlignermentParam.m_vObjectVirtualMarkOffset.at(i + m_iMarkNum*m_nAlignnExProductIndex).m_dPosY;
		Py.SetY(dValue);
		scLine Lx2;
		Lx2.SetPos(Px);
		Lx2.SetRotation(scDegree(dDegLx+90));
		PtIntersect = Lx2.Project(Py);
		//记录结果
		CCoordPos pos;
		pos.m_dPosX = PtIntersect.GetX();
		pos.m_dPosY  = PtIntersect.GetY();
		vVirtualPlatformPos.at(i) = pos;

	}

	return TRUE;
}


bool vcBaseAlignTool::ConvertImagePosToCurPlatformPos(CCoordPos& platformCoordPos, int nIndex, CCoordPos imageCoordPos, 
	CPlatformAxisPos* pPlatformAxisPos, BOOL bBaseOnCaliAxisbAngle)
{

	if (m_bEnableMultiCalibExtension == TRUE)
	{
		if (nIndex<0 || nIndex >= m_iMarkNum*(m_nMultiCalibExtensionMaxNum+1))
			return false;
	}
	else
	{
		if (nIndex<0 || nIndex >= m_iMarkNum)
			return false;
	}
	if (NULL == m_vAlignerCalibInfos.at(nIndex))
		return false;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
		{
			return false;
		}
	}

	int nRemIndex = nIndex%m_iMarkNum;

	if(m_vpCalibrateParam.at(nRemIndex)->m_nEnableDisCor)
	{
		CString strOut, strTmp;
		double p[15];
		memset(p, 0.0, sizeof(double)*15);
		scCalibrateResult result = m_vAlignerCalibInfos.at(nIndex)->m_result;
		result.GetNonlinearProjectResult(p);
		double dRms = result.GetRMS();
		strOut.Format("畸变参数: ");
		for (int i=0;i<15; i++)
		{
			strTmp.Format(_T("P%d:%.6f "), i, p[i]);
			strOut += strTmp;
		}
		strTmp.Format(_T("P15:%.6f "),dRms);
		strOut += strTmp;
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		strOut.Format("畸变校正前图像坐标: ");
		strTmp.Format(_T("Pos(%.6f, %.6f, %.6f) "), imageCoordPos.m_dPosX, imageCoordPos.m_dPosY, imageCoordPos.m_dAngle);
		strOut += strTmp;
		for (int i=0; i<imageCoordPos.m_vdAuxiliaryPosX.size(); i++)
		{
			strTmp.Format(_T("AuxiliaryPos%d(%.6f, %.6f, %.6f) "), i, imageCoordPos.m_vdAuxiliaryPosX.at(i), imageCoordPos.m_vdAuxiliaryPosY.at(i), imageCoordPos.m_vdAuxiliaryAngle.at(i));
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		CCoordPos imageDisCorPos;
		ExecuteDisCorPoint(nIndex, imageCoordPos, imageDisCorPos);
		imageCoordPos = imageDisCorPos;

		strOut.Format("畸变校正后图像坐标: ");
		strTmp.Format(_T("Pos(%.6f, %.6f, %.6f) "), imageCoordPos.m_dPosX, imageCoordPos.m_dPosY, imageCoordPos.m_dAngle);
		strOut += strTmp;
		for (int i=0; i<imageCoordPos.m_vdAuxiliaryPosX.size(); i++)
		{
			strTmp.Format(_T("AuxiliaryPos%d(%.6f, %.6f, %.6f) "), i, imageCoordPos.m_vdAuxiliaryPosX.at(i), imageCoordPos.m_vdAuxiliaryPosY.at(i), imageCoordPos.m_vdAuxiliaryAngle.at(i));
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);
	}

	//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
	//相机平台类型没有基类，不用改；
	CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetPlatformAxisPos());
	CPlatformXYDAxisPos*  pPlatformXYDAxisPos =		 (CPlatformXYDAxisPos*)pPlatformAxisPos;
	CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 

	if (NULL == pPlatformBenchAxisPos || NULL == pPlatformXYDAxisPos  || NULL == pPlatformParam)
	{
		return false;
	}

	// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
	//标定参数
	double dTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosX();
	double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosY();
	//平台各轴的方向	
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	// 实际平台XY轴偏移量
	double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
	double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;
	double dPlatformOffsetD = pPlatformXYDAxisPos->m_dAngle - pPlatformBenchAxisPos->m_dAngle;

	if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
	if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
	if (eDirectNegative == iPlatformDCoordType) dPlatformOffsetD = -1*dPlatformOffsetD;
	if ( GetMidPlatformType() ==ePlatformXDPY || GetMidPlatformType() ==ePlatformXDPY1)
	{
		dPlatformOffsetY =0 ;
	}
	else if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
	{

	}
	else if (GetMidPlatformType() ==ePlatformXYPD || GetMidPlatformType() ==ePlatformXY || GetMidPlatformType() ==ePlatformX || GetMidPlatformType() == ePlatformY)
	{
		dPlatformOffsetX =0 ;
		dPlatformOffsetY =0 ;
	}


	//平台XY平移量对基准mark平台坐标的影响方向相反
	dPlatformBenchMarkX -= dPlatformOffsetX;
	dPlatformBenchMarkY -= dPlatformOffsetY;

	// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
	double dImgOffsetRealDistanceX = 0;
	double dImgOffsetRealDistanceY = 0;
	double dImgOffsetX = imageCoordPos.m_dPosX - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX;
	double dImgOffsetY = imageCoordPos.m_dPosY - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY;
	dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
	dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

	if (m_bTargetObjectCamSeparate)
	{
		if (nIndex < m_iMarkNum/2)
		{
			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vSrc.SetX(dImgOffsetX);
				vSrc.SetY(dImgOffsetY);
				vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
				dImgOffsetRealDistanceX = vDst.GetX();
				dImgOffsetRealDistanceY = vDst.GetY();
			}
		}
		else
		{

		}
	}
	else
	{
		if (m_PlatformCalibType == ePlatformCalib9Point)
		{
			sc2Vector vSrc;
			sc2Vector vDst;
			vSrc.SetX(dImgOffsetX);
			vSrc.SetY(dImgOffsetY);
			vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
			dImgOffsetRealDistanceX = vDst.GetX();
			dImgOffsetRealDistanceY = vDst.GetY();
		}
	}



	double dX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
	double dY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;


	// 旋转平台坐标到标定时的角度
	if (bBaseOnCaliAxisbAngle)
	{
		platformCoordPos.m_dPosX = cos(scDegree(-dPlatformOffsetD)) * dX - sin(scDegree(-dPlatformOffsetD)) * dY;
		platformCoordPos.m_dPosY = sin(scDegree(-dPlatformOffsetD)) * dX + cos(scDegree(-dPlatformOffsetD)) * dY;
	}
	else
	{
		platformCoordPos.m_dPosX = dX;
		platformCoordPos.m_dPosY = dY;
	}

	// $4、内容相加，即为相机实时Mark的平台坐标值
	// 	platformCoordPos.m_dPosX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
	// 	platformCoordPos.m_dPosY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
	//mark为线时，平台mark线的角度为图像线的角度+图像平台坐标之间的夹角；
	platformCoordPos.m_dAngle = imageCoordPos.GetAngle() + 	m_vAlignerCalibInfos.at(nIndex)->m_dImageToPlatformAnlge;

	return true;
}


//////////////////////////////////////////////////////////////////////////
// 对位

void vcBaseAlignTool::SetInnerAlignBench(BOOL bInnerAlignBench)
{
	m_bInnerAlignBench = bInnerAlignBench;
}

BOOL vcBaseAlignTool::GetInnerAlignBench()
{
	return m_bInnerAlignBench;
}

void vcBaseAlignTool::SetImageSize(int nIndex, BOOL bOK, CCoordPos cpImageSize)
{
	m_ImageSizes.SetMarkImagePos(nIndex, bOK, cpImageSize);
}

CCoordPos vcBaseAlignTool::GetImageSize(int nIndex)
{
	return m_ImageSizes.GetMarkImagePos(nIndex);
}

void vcBaseAlignTool::SetAlignReservedIndex(int nAlignReservedIndex)
{
	m_nAlignReservedIndex = nAlignReservedIndex;
}
int vcBaseAlignTool::GetAlignReservedIndex()
{
	return m_nAlignReservedIndex;
}

void vcBaseAlignTool::SetAlignBenchOffsetIndex(int nAlignBenchOffsetIndex)
{
	m_nAlignBenchOffsetIndex = nAlignBenchOffsetIndex;
}
int vcBaseAlignTool::GetAlignBenchOffsetIndex()
{
	return m_nAlignBenchOffsetIndex;
}

void vcBaseAlignTool::SetAlignExProductIndex(int nAlignExProductIndex)
{
	if (nAlignExProductIndex<0 || nAlignExProductIndex>=m_nMultiCalibExtensionMaxNum+1)
	{
		m_nAlignnExProductIndex = 0;
		return;
	}
	m_nAlignnExProductIndex = nAlignExProductIndex;
}
int vcBaseAlignTool::GetAlignExProductIndex()
{
	return m_nAlignnExProductIndex;
}





// BOOL vcBaseAlignTool::CaculateTargetFixOffset(CCoordPos &offset)
// {
// 	if (!(m_bTargetObjectCamSeparate && m_bTargetCalibUseBoard))
// 	{
// 		return FALSE;
// 	}
// 	int nPlatformIndex = m_nPlatformIndex;
// 	CString str;
// 	CString strTempInfo;
// 	CString strInfo;
// 	str.Format("目标固定补偿计算开始:------------------------------------------------------------");
// 	AlignToolLogRecord(str,nPlatformIndex);
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//1. 加各种保护
// 	// 1.1 判断目标是否定位成功
// 	// 1.2 判断对象是否定位成功
// 	std::vector<int> nObjectPosIndex;
// 	std::vector<int> nTargetPosIndex;
// 
// 	{
// 		long i=0;
// 
// 		// 对象保护
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			nObjectPosIndex.push_back(i);
// 		}
// 
// 		if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(nObjectPosIndex))
// 		{
// 			return FALSE;
// 		}
// 
// 
// 		// 目标保护
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			nTargetPosIndex.push_back(i + m_iMarkNum/2);
// 		}
// 
// 		if (!m_bReadTargetPlatformPos)
// 		{
// 			if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(nTargetPosIndex))
// 			{
// 				return FALSE;
// 			}
// 		}
// 	}
// 
// // 	if (m_bEnableTargetPositionVirtualMode)
// // 	{
// // 		// 对象保护
// // 		for (long i=0; i<m_nObjectPositionNum; i++)
// // 		{
// // 			nObjectPosIndex.push_back(i);
// // 		}
// // 
// // 		// 目标保护
// // 		// 说明：目标位置虚拟模式:0-78虚拟;1-56虚拟	
// // 		if (m_nTargetPositionVirtualMode == 0)
// // 		{
// // 			for (long i=0; i<m_nTargetPositionNum; i++)
// // 			{
// // 				nTargetPosIndex.push_back(i + m_iMarkNum/2);
// // 			}
// // 		}
// // 		else
// // 		{
// // 			for (long i=0; i<m_nTargetPositionNum; i++)
// // 			{
// // 				nTargetPosIndex.push_back(i+m_nTargetPositionNum + m_iMarkNum/2);
// // 			}
// // 		}
// // 		if (!m_bReadTargetPlatformPos)
// // 		{
// // 			if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(nTargetPosIndex))
// // 			{
// // 				return FALSE;
// // 			}
// // 
// // 		}
// // 
// // 		if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(nObjectPosIndex))
// // 		{
// // 			return FALSE;
// // 		}
// // 
// // 	}
// // 	else if (m_bEnableObjectPositionVirtualMode)
// // 	{
// // 		// 对象保护
// // 		// 说明：对象位置虚拟模式:0-34虚拟;1-12虚拟
// // 		if (m_nObjectPositionVirtualMode == 0)
// // 		{
// // 			for (long i=0; i<m_nObjectPositionNum; i++)
// // 			{
// // 				nObjectPosIndex.push_back(i);
// // 			}
// // 		}
// // 		else
// // 		{
// // 			for (long i=0; i<m_nObjectPositionNum; i++)
// // 			{
// // 				nObjectPosIndex.push_back(i+m_nObjectPositionNum);
// // 			}
// // 		}
// // 
// // 		// 目标保护
// // 		for (long i=0; i<m_nTargetPositionNum; i++)
// // 		{
// // 			nTargetPosIndex.push_back(i + m_iMarkNum/2);
// // 		}
// // 
// // 		if (!m_bReadTargetPlatformPos)
// // 		{
// // 			if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(nTargetPosIndex))
// // 			{
// // 				return FALSE;
// // 			}
// // 		}
// // 
// // 		if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(nObjectPosIndex))
// // 		{
// // 			return FALSE;
// // 		}
// // 
// // 	}
// // 	else
// // 	{
// // 		long i=0;
// // 
// // 		// 对象保护
// // 		for (i=0; i<m_nObjectPositionNum; i++)
// // 		{
// // 			nObjectPosIndex.push_back(i);
// // 		}
// // 
// // 		// 目标保护
// // 		for (i=0; i<m_nTargetPositionNum; i++)
// // 		{
// // 			nTargetPosIndex.push_back(i + m_iMarkNum/2);
// // 		}
// // 		if (!m_bReadTargetPlatformPos)
// // 		{
// // 			if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(nTargetPosIndex))
// // 			{
// // 				return FALSE;
// // 			}
// // 		}
// // 		if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(nObjectPosIndex))
// // 		{
// // 			return FALSE;
// // 		}
// // 	}
// 
// 
// 	
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//2. 记录对象、目标平台轴位置（临时变量）
// 	//	2.1 目标mark坐标补偿时用到这些参数（对象、目标平台轴位置）
// 
// 	//目标mark坐标补偿时用到这些参数
// 	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
//     std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;
// 	
// 	int k=0;
// 	for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
// 	{
// 		pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置
// 		str.Format("搜索对象mark%d 轴位置 X=%f,Y=%f,D=%f",k,pObjectPlatformAxisPos.at(k)->m_dPosX,pObjectPlatformAxisPos.at(k)->m_dPosY,pObjectPlatformAxisPos.at(k)->m_dAngle);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 	}
// 	std::vector<CPlatformXYDAxisPos*> pTargetPlatformAxisPos;
// 	for (k=0;k<m_pTargetPlatformAxisPos.size();k++)
// 	{
// 		pTargetPlatformAxisPos.push_back((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k));//搜索目标mark轴位置
// 		str.Format("搜索目标mark%d 轴位置 X=%f,Y=%f,D=%f",k,pTargetPlatformAxisPos.at(k)->m_dPosX,pTargetPlatformAxisPos.at(k)->m_dPosY,pTargetPlatformAxisPos.at(k)->m_dAngle);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 	}
// 	if(pTargetPlatformAxisPos.size()<m_iMarkNum)
// 	{
// 		pTargetPlatformAxisPos.resize(m_iMarkNum);
// 
// 	}
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	// 3. 对象、目标临时平台坐标变量
// 	//  3.1 对象临时平台坐标变量(包含辅助点)
// 	//  3.2 目标临时平台坐标变量(包含辅助点)
// 
// 	std::vector<CCoordPos> vcpObjPlatPos;		// 对象位置
// 	std::vector<CCoordPos> vcpTarPlatPos;		// 目标位置
// 
// 	vcpObjPlatPos.resize(8);
// 	vcpTarPlatPos.resize(8);
// 
// 	double dObjectXforCam0[8];		//*计算相机平台移动量*1存储相机检测的实时对象mark图像坐标
// 	double dObjectYforCam0[8];		
// 	double dObjectXforCam1[8];		//*计算相机平台移动量*2存储平台移动后的检测的实时对象mark图像坐标
// 	double dObjectYforCam1[8];	
// 
// 	double dPltfmXforCam[8];		//*计算相机平台移动量*3根据前面两组数据计算平台各轴移动量
// 	double dPltfmYforCam[8];
// 	double dCameraPltfmX[8];		//*计算相机平台移动量*4转化为相机各轴移动量
// 	double dCameraPltfmY[8];
// 
// 	memset(dObjectXforCam0, 0.0, sizeof(double)*8);
// 	memset(dObjectYforCam0, 0.0, sizeof(double)*8);
// 	memset(dObjectXforCam1, 0.0, sizeof(double)*8);
// 	memset(dObjectYforCam1, 0.0, sizeof(double)*8);
// 	
// 	memset(dPltfmXforCam, 0.0, sizeof(double)*8);
// 	memset(dPltfmYforCam, 0.0, sizeof(double)*8);
// 	memset(dCameraPltfmX, 0.0, sizeof(double)*8);
// 	memset(dCameraPltfmY, 0.0, sizeof(double)*8);
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//4.实时对象Mark的图像坐标值转化为平台坐标值
// 
// 	// $1、实时对象Mark的图像坐标值转化为平台坐标值
// 		
// 	// $1.1 将实时对象Mark的图像坐标值转换为实时对象Mark搜索时的全局平台坐标值
// 	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPos();
// 
// 	if (FALSE == m_ObjectMarkPlatformPos.IsAllMarkPlatformPosOK())
// 	{
// 		return FALSE;
// 	}
// 	int i=0;
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	// 此处对象点变换可以放到计算对象平台坐标里面
// 	if(eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type() && m_iMarkNum == 6)
// 	{
// 		scLine BaseLine;
// 		CCoordPos Pos0 = m_ObjectMarkPlatformPos.m_vPos.at(0);
// 		CCoordPos Pos1 = m_ObjectMarkPlatformPos.m_vPos.at(1);
// 		CCoordPos Pos2 = m_ObjectMarkPlatformPos.m_vPos.at(2);
// 		sc2Vector vPos1(Pos1.m_dPosX,Pos1.m_dPosY);
// 		sc2Vector NewvPos1(Pos1.m_dPosX,Pos1.m_dPosY);
// 		BaseLine.SetFromStartEnd(sc2Vector(Pos0.m_dPosX,Pos0.m_dPosY),sc2Vector(Pos2.m_dPosX,Pos2.m_dPosY));
// 		NewvPos1 = BaseLine.Project(vPos1);
// 		m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = NewvPos1.GetX();
// 		m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = NewvPos1.GetY();
// 	}
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//5.实时目标Mark的图像坐标值转化为平台坐标值
// 	if (eTargetBench != m_AlignermentParam.GetTargetMarkType())
// 	{
// 		if (!m_bReadTargetPlatformPos)
// 		{
// 			m_TargetMarkPlatformPos = GetTargetMarkPlatformPos();
// 		}		
// 		if (FALSE == m_TargetMarkPlatformPos.IsAllMarkPlatformPosOK())
// 		{
// 			return FALSE;
// 		}
// 	}
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	// 此处目标点变换可以放到目标修正后完成
// 	if(eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type() && m_iMarkNum == 6)
// 	{
// 		scLine BaseLine;
// 		CCoordPos Pos0 = m_TargetMarkPlatformPos.m_vPos.at(3);
// 		CCoordPos Pos1 = m_TargetMarkPlatformPos.m_vPos.at(4);
// 		CCoordPos Pos2 = m_TargetMarkPlatformPos.m_vPos.at(5);
// 		sc2Vector vPos1(Pos1.m_dPosX,Pos1.m_dPosY);
// 		sc2Vector NewvPos1(Pos1.m_dPosX,Pos1.m_dPosY);
// 		BaseLine.SetFromStartEnd(sc2Vector(Pos0.m_dPosX,Pos0.m_dPosY),sc2Vector(Pos2.m_dPosX,Pos2.m_dPosY));
// 		NewvPos1 = BaseLine.Project(vPos1);
// 		m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosX = NewvPos1.GetX();
// 		m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosY = NewvPos1.GetY();
// 	}
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//6.记录对象信息
// 	// 6.1对象拍照轴位置
// 	// 6.2对象图像坐标
// 	// 6.3对象平台坐标
// 	// 6.4对象尺寸
// 
// 	if (4 == m_iMarkNum)
// 	{
// 		strTempInfo.Format(" 4相机2Vs2对位 , ");
// 		strInfo += strTempInfo;
// 
// 		for (k=0;k<m_pObjectPlatformAxisPos.size()/2;k++)
// 		{
// 			strTempInfo.Format("对象mark%d轴位置 X:, %f ,Y:, %f ,D:, %f ,",k,pObjectPlatformAxisPos.at(k)->m_dPosX,pObjectPlatformAxisPos.at(k)->m_dPosY,pObjectPlatformAxisPos.at(k)->m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的图像坐标
// 			strTempInfo.Format("对象mark%d图像坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的坐标
// 			strTempInfo.Format("对象mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			pt[i] = sc2Vector(m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY);
// 		}
// 
// 		//记录对象距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("对象01距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;		
// 
// 
// 	}
// 	else if (6 == m_iMarkNum)
// 	{
// 		strTempInfo.Format(" 6相机3Vs3对位 , ");
// 		strInfo += strTempInfo;
// 
// 		for (k=0;k<m_pObjectPlatformAxisPos.size()/2;k++)
// 		{
// 			strTempInfo.Format("对象mark%d轴位置 X:, %f ,Y:, %f ,D:, %f ,",k,pObjectPlatformAxisPos.at(k)->m_dPosX,pObjectPlatformAxisPos.at(k)->m_dPosY,pObjectPlatformAxisPos.at(k)->m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的图像坐标
// 			strTempInfo.Format("对象mark%d图像坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的坐标
// 			strTempInfo.Format("对象mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			pt[i] = sc2Vector(m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY);
// 		}
// 
// 		//记录对象距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("对象01距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;	
// 
// 		dLen[1] = (pt[1] - pt[2]).Length();
// 		(pt[1] - pt[2]).Angle(raAngle[1]);
// 		strTempInfo.Format("对象12距离角度 L:, %f ,D:, %f ,", dLen[1], scDegree(raAngle[1]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[2] = (pt[2] - pt[0]).Length();
// 		(pt[2] - pt[0]).Angle(raAngle[2]);
// 		strTempInfo.Format("对象02距离角度 L:, %f ,D:, %f ,", dLen[2], scDegree(raAngle[2]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 	}
// 	else if (8 == m_iMarkNum)
// 	{
// 		strTempInfo.Format(" 8相机4Vs4对位模式类型, %d , ",m_AlignermentParam.GetAligner4Vs4Type());
// 		strInfo += strTempInfo;
// 
// 		for (k=0;k<m_pObjectPlatformAxisPos.size()/2;k++)
// 		{
// 			strTempInfo.Format("对象mark%d轴位置 X:, %f ,Y:, %f ,D:, %f ,",k,pObjectPlatformAxisPos.at(k)->m_dPosX,pObjectPlatformAxisPos.at(k)->m_dPosY,pObjectPlatformAxisPos.at(k)->m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的图像坐标
// 			strTempInfo.Format("对象mark%d图像坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的坐标
// 			strTempInfo.Format("对象mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			pt[i] = sc2Vector(m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY);
// 		}
// 		
// 		//记录对象距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("对象01距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[1] = (pt[3] - pt[2]).Length();
// 		(pt[3] - pt[2]).Angle(raAngle[1]);
// 		strTempInfo.Format("对象23距离角度 L:, %f ,D:, %f ,", dLen[1], scDegree(raAngle[1]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[2] = (pt[2] - pt[0]).Length();
// 		(pt[2] - pt[0]).Angle(raAngle[2]);
// 		strTempInfo.Format("对象02距离角度 L:, %f ,D:, %f ,", dLen[2], scDegree(raAngle[2]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[3] = (pt[3] - pt[1]).Length();
// 		(pt[3] - pt[1]).Angle(raAngle[3]);
// 		strTempInfo.Format("对象13距离角度 L:, %f ,D:, %f ,", dLen[3], scDegree(raAngle[3]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("对象02-01角度D:, %f ,", scDegree(raAngle[2]-raAngle[0]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("对象13-01角度D: %f ,", scDegree(raAngle[3]-raAngle[0]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("对象02-23角度D:, %f ,", scDegree(raAngle[2]-raAngle[1]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("对象13-23角度D:, %f ,", scDegree(raAngle[3]-raAngle[1]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 	}
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//7.根据对象产品尺寸计算虚拟点位置
// 
// 	double dTempObjectX[8];			//存储对象mark图像坐标
// 	double dTempObjectY[8];
// 	double dTempObjectD[8];
// 
// 	memset(dTempObjectX, 0.0, sizeof(double)*8);
// 	memset(dTempObjectY, 0.0, sizeof(double)*8);
// 	memset(dTempObjectD, 0.0, sizeof(double)*8);
// 
// 
// 	// 根据对象产品尺寸计算虚拟点位置
// // 	if (m_bEnableObjectPositionVirtualMode)
// // 	{
// // 		str.Format("---开始根据对象产品尺寸计算虚拟对位点---");
// // 		AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 		if ((m_nObjectPositionNum == 2) && (m_nTargetPositionNum == 4))
// // 		{
// // 			//根据对象产品尺寸和对象12/34平台坐标虚拟目标34/12平台坐标 
// // 			if ((m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0))
// // 			{
// // 				str.Format("对象尺寸信息错误:ObjectL1=%f,ObjectW1=%f",m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1);
// // 				AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 				str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
// // 				AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 				return FALSE;
// // 			}
// // 
// // 			str.Format("对象尺寸信息:ObjectL1=%f,ObjectW1=%f",m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1);
// // 			AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 			for (int i = 0; i < m_iMarkNum; i++)
// // 			{
// // 				dTempObjectX[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX;
// // 				dTempObjectY[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY;
// // 				dTempObjectD[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle;
// // 
// // 			}
// // 
// // 			// 对象位置虚拟模式:0-34虚拟;1-12虚拟
// // 			if (m_nObjectPositionVirtualMode == 0)
// // 			{
// // 				// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// // 				if (m_bObjectPositionDirectionMode == 0)
// // 				{
// // 					//  1   2
// // 					// (3) (4)
// // 
// // 					// 放射矩形
// // 					sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// // 					sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// // 					double dXLength = (ptObject2 - ptObject1).Length();
// // 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
// // 					scRadian xRot;
// // 					(ptObject2 - ptObject1).Angle(xRot);
// // 					// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// // 					xRot = xRot.SignedNormMod180();
// // 					// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// // 					//xRot = xRot.NormMod180();
// // 
// // 					str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					scAffineRect affrect;
// // 					affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));
// // 
// // 					ptObject1 = affrect.GetCornerPo();
// // 					ptObject2 = affrect.GetCornerPx();
// // 					sc2Vector ptObject3 = affrect.GetCornerPy();
// // 					sc2Vector ptObject4 = affrect.GetCornerPopp();
// // 
// // 					str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					dTempObjectX[2] = ptObject3.GetX();
// // 					dTempObjectY[2] = ptObject3.GetY();
// // 					dTempObjectX[3] = ptObject4.GetX();
// // 					dTempObjectY[3] = ptObject4.GetY();
// // 
// // 					for (int i = 0; i < m_iMarkNum; i++)
// // 					{
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// // 					}
// // 				}
// // 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// // 				{
// // 					// (3)  1
// // 					// (4)  2
// // 
// // 					// 放射矩形
// // 					sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
// // 					sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
// // 					double dXLength = (ptObject2 - ptObject1).Length();
// // 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// // 					scRadian xRot;
// // 					(ptObject2 - ptObject1).Angle(xRot);
// // 					// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// // 					//				xRot = xRot.SignedNormMod180();
// // 					// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// // 					xRot = xRot.NormMod180();
// // 
// // 					str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					scAffineRect affrect;
// // 					affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));
// // 
// // 					ptObject1 = affrect.GetCornerPo();
// // 					ptObject2 = affrect.GetCornerPx();
// // 					sc2Vector ptObject3 = affrect.GetCornerPy();
// // 					sc2Vector ptObject4 = affrect.GetCornerPopp();
// // 
// // 					str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					dTempObjectX[2] = ptObject3.GetX();
// // 					dTempObjectY[2] = ptObject3.GetY();
// // 					dTempObjectX[3] = ptObject4.GetX();
// // 					dTempObjectY[3] = ptObject4.GetY();
// // 
// // 					for (int i = 0; i < m_iMarkNum; i++)
// // 					{
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// // 					}
// // 					
// // 				}
// // 				else
// // 				{
// // 					return FALSE;
// // 				}
// // 
// // 
// // 
// // 			}
// // 			// 对象位置虚拟模式:0-34虚拟;1-12虚拟
// // 			else
// // 			{
// // 				// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// // 				if (m_bObjectPositionDirectionMode == 0)
// // 				{
// // 					// (1) (2)
// // 					//  3   4
// // 					sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
// // 					sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
// // 					double dXLength = (ptObject4 - ptObject3).Length();
// // 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
// // 					scRadian xRot;
// // 					(ptObject4 - ptObject3).Angle(xRot);
// // 					// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// // 					xRot = xRot.SignedNormMod180();
// // 					// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// // 					//xRot = xRot.NormMod180();
// // 
// // 					str.Format("对象34坐标:3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("对象34连线角度:34Angle=%f",scDegree(xRot).ToDouble());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					scAffineRect affrect;
// // 					affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));
// // 
// // 					ptObject3 = affrect.GetCornerPo();
// // 					ptObject4 = affrect.GetCornerPx();
// // 					sc2Vector ptObject1 = affrect.GetCornerPy();
// // 					sc2Vector ptObject2 = affrect.GetCornerPopp();
// // 
// // 					str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					dTempObjectX[0] = ptObject1.GetX();
// // 					dTempObjectY[0] = ptObject1.GetY();
// // 					dTempObjectX[1] = ptObject2.GetX();
// // 					dTempObjectY[1] = ptObject2.GetY();
// // 
// // 					for (int i = 0; i < m_iMarkNum; i++)
// // 					{
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// // 					}
// // 				}
// // 				else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// // 				{
// // 					//	3  (1)
// // 					//  4  (2)
// // 					sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
// // 					sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
// // 					double dXLength = (ptObject4 - ptObject3).Length();
// // 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
// // 					scRadian xRot;
// // 					(ptObject4 - ptObject3).Angle(xRot);
// // 					// 对象1点、2点连线为水平方向，应将其归一化到-90-90
// // 	//				xRot = xRot.SignedNormMod180();
// // 					// 对象1点、2点连线为垂直方向，应将其归一化到0-180
// // 					xRot = xRot.NormMod180();
// // 
// // 					str.Format("对象34坐标:3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("对象34连线角度:34Angle=%f",scDegree(xRot).ToDouble());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					scAffineRect affrect;
// // 					affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));
// // 
// // 					ptObject3 = affrect.GetCornerPo();
// // 					ptObject4 = affrect.GetCornerPx();
// // 					sc2Vector ptObject1 = affrect.GetCornerPy();
// // 					sc2Vector ptObject2 = affrect.GetCornerPopp();
// // 
// // 					str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					dTempObjectX[0] = ptObject1.GetX();
// // 					dTempObjectY[0] = ptObject1.GetY();
// // 					dTempObjectX[1] = ptObject2.GetX();
// // 					dTempObjectY[1] = ptObject2.GetY();
// // 
// // 					for (int i = 0; i < m_iMarkNum; i++)
// // 					{
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
// // 						m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
// // 					}
// // 				}
// // 				else
// // 				{
// // 					return FALSE;
// // 				}
// // 
// // 			}
// // 
// // 		}
// // 	}
// 
// 
// 
// 	// 记录对象信息
// 	if (8 == m_iMarkNum)
// 	{
// 		strTempInfo.Format(" 8相机4VS4（虚拟）, %d , ",m_AlignermentParam.GetAligner4Vs4Type());
// 		strInfo += strTempInfo;
// 
// 		// 			for (k=0;k<m_pObjectPlatformAxisPos.size()/2;k++)
// 		// 			{
// 		// 				strTempInfo.Format("对象mark%d轴位置 X:, %f ,Y:, %f ,D:, %f ,",k,pObjectPlatformAxisPos.at(k)->m_dPosX,pObjectPlatformAxisPos.at(k)->m_dPosY,pObjectPlatformAxisPos.at(k)->m_dAngle);
// 		// 				strInfo += strTempInfo;
// 		// 			}
// 
// 		// 			for (i=0; i<m_iMarkNum/2; i++)
// 		// 			{
// 		// 				//记录相机对象mark的图像坐标
// 		// 				strTempInfo.Format("对象mark%d图像坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
// 		// 				strInfo += strTempInfo;
// 		// 			}
// 
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的坐标
// 			strTempInfo.Format("对象mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			pt[i] = sc2Vector(m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY);
// 		}
// 
// 		//记录对象距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("对象01距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[1] = (pt[3] - pt[2]).Length();
// 		(pt[3] - pt[2]).Angle(raAngle[1]);
// 		strTempInfo.Format("对象23距离角度 L:, %f ,D:, %f ,", dLen[1], scDegree(raAngle[1]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[2] = (pt[2] - pt[0]).Length();
// 		(pt[2] - pt[0]).Angle(raAngle[2]);
// 		strTempInfo.Format("对象02距离角度 L:, %f ,D:, %f ,", dLen[2], scDegree(raAngle[2]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[3] = (pt[3] - pt[1]).Length();
// 		(pt[3] - pt[1]).Angle(raAngle[3]);
// 		strTempInfo.Format("对象13距离角度 L:, %f ,D:, %f ,", dLen[3], scDegree(raAngle[3]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("对象02-01角度D:, %f ,", scDegree(raAngle[2]-raAngle[0]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("对象13-01角度D: %f ,", scDegree(raAngle[3]-raAngle[0]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("对象02-23角度D:, %f ,", scDegree(raAngle[2]-raAngle[1]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("对象13-23角度D:, %f ,", scDegree(raAngle[3]-raAngle[1]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 	}
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//8. 对对象平台坐标进行补偿
// 	// 8.1 虚拟Mark补偿对象平台坐标
// 	// 8.2 固定补偿对象平台坐标
// //	int i=0;
// 	for (i=0; i<m_iMarkNum; i++)
// 	{
// 		//记录相机对象mark的坐标
// 		vcpObjPlatPos[i] = m_ObjectMarkPlatformPos.m_vPos[i];
// 
// 		dObjectXforCam0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX;
// 		dObjectYforCam0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY;
// 		
// 		str.Format("对象图像坐标%d:ObjectImageX=%f,ObjectImageY=%f,ObjectImageD=%f",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
// 		AlignToolLogRecord(str,nPlatformIndex);
// // 		str.Format("对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,dObjectX[i],dObjectY[i],dObjectD[i]);
// // 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 		str.Format("对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 		AlignToolLogRecord(str,nPlatformIndex);
// 		
// 		// $1.2 实时对象为虚拟Mark，则将实时对象Mark的平台坐标值转换为虚拟Mark的平台坐标值
// 		if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
// 		{
// 			if (FALSE == ConvertObjectPltfmPtToVirtualPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos))
// 				return FALSE;
// 
// 			vcpObjPlatPos[i] = m_VirtualMarkPlatformPos.m_vPos[i];
// 
// 
// //// 			dObjectX[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_dPosX;
// //// 			dObjectY[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_dPosY;
// //// 			dObjectD[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_dAngle;
// //
// //			// 辅助位置
// //			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// //				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// //				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// //				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// //			{
// //// 				dAuxiliaryObjectX0[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// //// 				dAuxiliaryObjectY0[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// //// 				dAuxiliaryObjectD0[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
// //// 				dAuxiliaryObjectX1[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// //// 				dAuxiliaryObjectY1[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// //// 				dAuxiliaryObjectD1[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
// //			}
// 
// // 			str.Format("虚拟对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,dObjectX[i],dObjectY[i],dObjectD[i]);
// // 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			str.Format("虚拟对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 	}
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//8. 对目标平台坐标进行修正
// 	// 8.1 
// 
// 	//读取每个相机对应的对象mark和平台mark的坐标值
// 	for (i=0; i<m_iMarkNum; i++)
// 	{
// 		// $2、实时目标Mark的图像坐标值转化为平台坐标值
// 		// 目标Mark为基准Mark
// 		if (eTargetBench == m_AlignermentParam.GetTargetMarkType())
// 		{	
// 		//	CPlatformXYDAxisPos* pBenchFixPlatformAxisPos = (CPlatformXYDAxisPos*)(m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetFixPlatformPos());//基准修正时轴位置
// 
// 			//如果没有进行基准修正，则使用标定后的基准mark平台坐标
// 			if (FALSE == m_AlignermentParam.GetBenchTargetMarkFixEnable())
// 			{
// 				CPlatformXYDAxisPos* pBenchPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());//标定基准轴位置
// 
// 				vcpTarPlatPos[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos;
// 
// // 				dTargetX[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos.GetPosX();
// // 				dTargetY[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos.GetPosY();
// // 				dTargetD[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos.GetAngle();
// 				pTargetPlatformAxisPos.at(i) = pBenchPlatformAxisPos;
// 			}
// 			else//进行基准修正，使用修正后的基准坐标
// 			{
// 				CPlatformXYDAxisPos* pBenchFixPlatformAxisPos = (CPlatformXYDAxisPos*)(m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetFixPlatformPos(i));//基准修正时轴位置
// 				
// 				vcpTarPlatPos[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i);
// 
// // 				dTargetX[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i).GetPosX();
// // 				dTargetY[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i).GetPosY();
// // 				dTargetD[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i).GetAngle();
// 				pTargetPlatformAxisPos.at(i) = pBenchFixPlatformAxisPos;
// 			}
// 		}
// 		else//目标mark为实时mark
// 		{
// 			//记录相机目标mark的坐标
// 			vcpTarPlatPos[i] = m_TargetMarkPlatformPos.m_vPos[i];
// 
// 		}
// 
// 		str.Format("目标图像坐标%d:TargetImageX=%f,TargetImageY=%f,TargetImageD=%f",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
// 		AlignToolLogRecord(str,nPlatformIndex);
// // 		str.Format("目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,dTargetX[i],dTargetY[i],dTargetD[i]);
// // 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 		str.Format("目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 	// $3、对目标Mark的平台坐标值进行修正(平台XY轴移动影响影响结果)
// 		double dPlatformOffsetX = 0;
// 		double dPlatformOffsetY = 0;
// 		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
// 		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
// 
// 		//修正回读取目标平台坐标时，已经重构点的轴位置偏移
// 		 if (m_bReadTargetPlatformPos)
// 		{
// 			//if (m_bTargetObjectCamSeparate && m_iMarkNum == 8 
// 			//	&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
// 			//	||m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4	
// 			//	|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4 
// 			//	|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
// 			{
// 				// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
// 				if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
// 				{
// 					dPlatformOffsetX = 0;
// 					dPlatformOffsetY = 0;
// 				}
// 				else
// 				{
// 					dPlatformOffsetX = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
// 					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 					dPlatformOffsetY = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
// 					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// 				}
// 
// 				if (GetMidPlatformType()==ePlatformXYPD)
// 				{
// 					dPlatformOffsetX = 0;
// 					dPlatformOffsetY = 0;
// 				}		
// 
// 				vcpTarPlatPos[i].Offset(dPlatformOffsetX, dPlatformOffsetY);
// 			}
// 
// 		}
// 		
// 		if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
// 		{
// 			dPlatformOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// 			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 			dPlatformOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// 			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// 		}
// 		else
// 		{
// 			dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// 			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 			dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// 			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// 
// // 			if (m_bEnableObjectPositionVirtualMode)
// // 			{
// // 				if ((m_nTargetPositionNum == 4) && (m_nObjectPositionNum == 2))
// // 				{
// // 					// 对象位置虚拟模式:0-34虚拟;1-12虚拟
// // 					if (m_nObjectPositionVirtualMode == 0)
// // 					{
// // 						dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// // 						if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// // 						dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// // 						if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// // 					}
// // 					else if(m_nObjectPositionVirtualMode == 1)// 对象位置虚拟模式:0-34虚拟;1-12虚拟
// // 					{					
// // 						dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// // 						if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// // 						dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// // 						if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// // 					}
// // 				}
// // 			}		
// 		}
// 
// 		if (GetMidPlatformType()==ePlatformXYPD)
// 		{
// 			 dPlatformOffsetX = 0;
// 			 dPlatformOffsetY = 0;
// 
// 		}
// 
//         if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTarObjCamSepNoAxisCalib)
//         {
//             dPlatformOffsetX = 0;
//             dPlatformOffsetY = 0;
//         }
// 
// 		else if (GetMidPlatformType()==ePlatformXY)
// 		{
// 			dPlatformOffsetX = 0;
// 			dPlatformOffsetY = 0;
// 		}
// 		
// 		if (m_bTargetObjectCamSeparate && m_bTargetCalibUseBoard)
// 		{
// 			// 目标标定轴相对于对象标定轴位置偏移量
// 			CPlatformXYDAxisPos*  pTargetPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformAxisPos());
// 			/*CPlatformXYDAxisPos*  pObjectPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());*/
// 
// 			double dVirtualPlatformAixsOffsetX = 0;
// 			double dVirtualPlatformAixsOffsetY = 0;
// 			if ((eTargetMoveByPlatform == m_eAlignerTargetMoveType))
// 			{
// 				dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
// 				dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
// 			}
// 			else
// 			{
// 				dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
// 				dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
// 			}
// 			
// 			if (eDirectNegative == iPlatformXCoordType) dVirtualPlatformAixsOffsetX = -1*dVirtualPlatformAixsOffsetX;	
// 			if (eDirectNegative == iPlatformYCoordType) dVirtualPlatformAixsOffsetY = -1*dVirtualPlatformAixsOffsetY;
// 
// 			dPlatformOffsetX = dPlatformOffsetX - dVirtualPlatformAixsOffsetX;
// 			dPlatformOffsetY = dPlatformOffsetY - dVirtualPlatformAixsOffsetY;
// 		}
// 
// 
// 		vcpTarPlatPos[i].Offset(-dPlatformOffsetX, -dPlatformOffsetY);
// 
// 		str.Format("平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 		AlignToolLogRecord(str,nPlatformIndex);
// 	}
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//8. 综合对位重新构造新的目标对位点
// 	// 8.1 综合对位构造新的目标对位点
// 
// 	if (!m_bReadTargetPlatformPos)
// 	{
// 		//重新构造新的对位点//================================================================================
// 		if (m_bTargetObjectCamSeparate && m_iMarkNum == 8 
// 			&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
// 			||m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4	
// 			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4 
// 			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
// 		{
// 			CCoordPos tmpPos[4];
// 
// 			CString str;
// 			int k;
// 			for ( k=m_iMarkNum/2;k<m_iMarkNum;k++)
// 			{
// 
// 				tmpPos[k-m_iMarkNum/2] = vcpTarPlatPos[k];
// 
// 				str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,tmpPos[k-m_iMarkNum/2].m_dPosX,tmpPos[k-m_iMarkNum/2].m_dPosY);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 			CCoordPos ResultPos[4];
// 			scLine ResultLine[4];
// 			sc2Vector UsePoint[8];
// 			bool bIntersect;
// 			std::vector<sc2Vector> crossPointArray;
// 
// 			UsePoint[0] = vcpTarPlatPos[0+m_iMarkNum/2].GetAuxPos(0);
// 			UsePoint[1] = vcpTarPlatPos[1+m_iMarkNum/2].GetAuxPos(0);
// 			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);
// 
// 			UsePoint[2] = vcpTarPlatPos[1+m_iMarkNum/2].GetAuxPos(1);
// 			UsePoint[3] = vcpTarPlatPos[3+m_iMarkNum/2].GetAuxPos(1);
// 			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);
// 
// 			UsePoint[4] = vcpTarPlatPos[2+m_iMarkNum/2].GetAuxPos(0);
// 			UsePoint[5] = vcpTarPlatPos[3+m_iMarkNum/2].GetAuxPos(0);
// 			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
// 
// 			UsePoint[6] = vcpTarPlatPos[0+m_iMarkNum/2].GetAuxPos(1);
// 			UsePoint[7] = vcpTarPlatPos[2+m_iMarkNum/2].GetAuxPos(1);
// 			ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);
// 
// 			if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
// 				&& crossPointArray.size() > 0)
// 			{
// 				vcpTarPlatPos[0+m_iMarkNum/2].m_dPosX = crossPointArray.at(0).GetX(); 
// 				vcpTarPlatPos[0+m_iMarkNum/2].m_dPosY = crossPointArray.at(0).GetY();
// 			}
// 
// 
// 			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
// 				&& crossPointArray.size() > 0)
// 			{
// 
// 				vcpTarPlatPos[1+m_iMarkNum/2].m_dPosX = crossPointArray.at(0).GetX(); 
// 				vcpTarPlatPos[1+m_iMarkNum/2].m_dPosY = crossPointArray.at(0).GetY();
// 			}
// 
// 
// 			if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
// 				&& crossPointArray.size() > 0)
// 			{
// 				vcpTarPlatPos[2+m_iMarkNum/2].m_dPosX = crossPointArray.at(0).GetX(); 
// 				vcpTarPlatPos[2+m_iMarkNum/2].m_dPosY = crossPointArray.at(0).GetY();
// 			}
// 
// 
// 			if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
// 				&& crossPointArray.size() > 0)
// 			{
// 
// 				vcpTarPlatPos[3+m_iMarkNum/2].m_dPosX = crossPointArray.at(0).GetX(); 
// 				vcpTarPlatPos[3+m_iMarkNum/2].m_dPosY = crossPointArray.at(0).GetY();
// 			}
// 
// 			for (k=m_iMarkNum/2;k<m_iMarkNum;k++)
// 			{
// 
// 				str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,vcpTarPlatPos[k].GetPosX(),vcpTarPlatPos[k].GetPosY());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 			for (k=m_iMarkNum/2;k<m_iMarkNum;k++)
// 			{
// 				double ddx = tmpPos[k-m_iMarkNum/2].GetPosX() - vcpTarPlatPos[k].GetPosX();
// 				double ddy = tmpPos[k-m_iMarkNum/2].GetPosY() - vcpTarPlatPos[k].GetPosY();
// 				str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 		}
// 		else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4)||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
// 			&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
// 		{
// 			int nIndexOffset = (m_bTargetObjectCamSeparate && m_iMarkNum == 4) ? 2 : 0;
// 
// 			CCoordPos tmpPos[2];
// 			int k = 0;
// 			for (k=0;k<2;k++)
// 			{
// 				tmpPos[k] = vcpTarPlatPos.at(k+nIndexOffset);
// 				str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k+nIndexOffset,vcpTarPlatPos.at(k+nIndexOffset).m_dPosX, vcpTarPlatPos.at(k+nIndexOffset).m_dPosY);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 
// 			CCoordPos ResultPos[3];
// 			scLine ResultLine[3];
// 			sc2Vector UsePoint[6];
// 			bool bIntersect;
// 			std::vector<sc2Vector> crossPointArray;
// 
// 			// 判断公共边是水平边还是垂直边
// 			scLine tpmLine = scLineSeg(vcpTarPlatPos.at(0+nIndexOffset).GetPos(), vcpTarPlatPos.at(1+nIndexOffset).GetPos()).GetLine();
// 			double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
// 			BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;
// 			str.Format("修正前目标角点连线角度[-90,90): %f ,直线是否水平线: %d", tmpAngle, bHorDirection);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			if (bHorDirection == TRUE)
// 			{
// 				// 直线0：公共边上的点组合构成
// 				UsePoint[0].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
// 				UsePoint[0].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
// 				UsePoint[1].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
// 				UsePoint[1].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
// 				ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);
// 
// 				// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
// 				UsePoint[2].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
// 				UsePoint[2].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
// 				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
// 				{
// 					UsePoint[3].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetPosX());
// 					UsePoint[3].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetPosY());
// 				}
// 				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
// 				{
// 					UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
// 				}
// 				ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);
// 
// 				// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
// 				UsePoint[4].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
// 				UsePoint[4].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
// 				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
// 				{
// 					UsePoint[5].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetPosX());
// 					UsePoint[5].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetPosY());
// 				}
// 				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
// 				{
// 					UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
// 				}
// 				ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
// 			}
// 			else
// 			{
// 				// 直线0：公共边上的点组合构成
// 				UsePoint[0].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
// 				UsePoint[0].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
// 				UsePoint[1].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
// 				UsePoint[1].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
// 				ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);
// 
// 				// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
// 				UsePoint[2].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
// 				UsePoint[2].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
// 				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
// 				{
// 					UsePoint[3].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetPosX());
// 					UsePoint[3].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetPosY());
// 				}
// 				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
// 				{
// 					UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
// 				}
// 				ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);
// 
// 				// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
// 				UsePoint[4].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
// 				UsePoint[4].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
// 				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
// 				{
// 					UsePoint[5].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetPosX());
// 					UsePoint[5].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetPosY());
// 				}
// 				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
// 				{
// 					UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
// 				}
// 				ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
// 			}
// 
// 			// 直线0和1交点，覆盖点0
// 			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
// 				&& crossPointArray.size() > 0)
// 			{
// 				vcpTarPlatPos.at(0+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
// 				vcpTarPlatPos.at(0+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
// 			}
// 
// 			// 直线0和2交点，覆盖点1
// 			if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
// 				&& crossPointArray.size() > 0)
// 			{
// 				vcpTarPlatPos.at(1+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
// 				vcpTarPlatPos.at(1+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
// 			}
// 
// 			for (k=0;k<2;k++)
// 			{
// 				str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k+nIndexOffset,vcpTarPlatPos.at(k+nIndexOffset).m_dPosX, vcpTarPlatPos.at(k+nIndexOffset).m_dPosY);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 			for (k=0;k<2;k++)
// 			{
// 				double ddx = tmpPos[k].GetPosX() - vcpTarPlatPos.at(k+nIndexOffset).GetPosX();
// 				double ddy = tmpPos[k].GetPosY() - vcpTarPlatPos.at(k+nIndexOffset).GetPosY();
// 				str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k+nIndexOffset,ddx,ddy);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 		}
// 	}
// 	
// 	//////////////////////////////////////////////////////////////////////////
// 	//9. 虚拟目标位置构造另外的目标对位点
// 	// 9.1 虚拟目标位置构造另外的目标对位点，根据产品尺寸
// 
// 	// 根据目标产品尺寸计算虚拟点位置
// // 	if (m_bEnableTargetPositionVirtualMode)
// // 	{
// // 		str.Format("---开始根据目标产品尺寸计算虚拟对位点---");
// // 		AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 		if ((m_nObjectPositionNum == 4) && (m_nTargetPositionNum == 2))
// // 		{
// // 			//根据目标产品尺寸和目标56/78平台坐标虚拟目标78/56平台坐标 
// // 			if ((m_AlignermentParam.GetProductSizeInfo().m_dTargetL2 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dTargetW2 <= 0))
// // 			{
// // 				str.Format("目标尺寸信息错误:TargetL2=%f,TargetW2=%f",m_AlignermentParam.GetProductSizeInfo().m_dTargetL2,m_AlignermentParam.GetProductSizeInfo().m_dTargetW2);
// // 				AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 				str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
// // 				AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 				return FALSE;
// // 			}
// // 
// // 			str.Format("目标尺寸信息:TargetL2=%f,TargetW2=%f",m_AlignermentParam.GetProductSizeInfo().m_dTargetL2,m_AlignermentParam.GetProductSizeInfo().m_dTargetW2);
// // 			AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 			// 目标位置虚拟模式:0-78虚拟;1-56虚拟	
// // 			if (m_nTargetPositionVirtualMode == 0)
// // 			{
// // 				// 目标位置方向模式: 0：位置56水平；1：位置56竖直；
// // 				if (m_bTargetPositionDirectionMode == 0)
// // 				{
// // 					//	5   6
// // 					// (7) (8)
// // // 					sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
// // // 					sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
// // 
// // 					sc2Vector ptTarget5 = vcpTarPlatPos[4].GetPos();
// // 					sc2Vector ptTarget6 = vcpTarPlatPos[5].GetPos();
// // 
// // 					double dXLength = (ptTarget6 - ptTarget5).Length();
// // 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
// // 					scRadian xRot;
// // 					(ptTarget6 - ptTarget5).Angle(xRot);
// // 					xRot = xRot.SignedNormMod180();
// // 
// // 					str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					scAffineRect affrect;
// // 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));
// // 
// // 					ptTarget5 = affrect.GetCornerPo();
// // 					ptTarget6 = affrect.GetCornerPx();
// // 					sc2Vector ptTarget7 = affrect.GetCornerPy();
// // 					sc2Vector ptTarget8 = affrect.GetCornerPopp();
// // 
// // 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // // 					dTargetX[6] = ptTarget7.GetX();
// // // 					dTargetY[6] = ptTarget7.GetY();
// // // 					dTargetX[7] = ptTarget8.GetX();
// // // 					dTargetY[7] = ptTarget8.GetY();
// // 
// // 					vcpTarPlatPos[6].SetPos(ptTarget7);
// // 					vcpTarPlatPos[7].SetPos(ptTarget8);
// // 				}
// // 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式: 0：位置56水平；1：位置56竖直；
// // 				{
// // 					//	(7)  5
// // 					//  (8)  6
// // // 					sc2Vector ptTarget5 = sc2Vector(dTargetX[4], dTargetY[4]);
// // // 					sc2Vector ptTarget6 = sc2Vector(dTargetX[5], dTargetY[5]);
// // 
// // 					sc2Vector ptTarget5 = vcpTarPlatPos[4].GetPos();
// // 					sc2Vector ptTarget6 = vcpTarPlatPos[5].GetPos();
// // 
// // 					double dXLength = (ptTarget6 - ptTarget5).Length();
// // 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
// // 					scRadian xRot;
// // 					(ptTarget6 - ptTarget5).Angle(xRot);
// // 					xRot = xRot.NormMod180();
// // 
// // 					str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					scAffineRect affrect;
// // 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));
// // 
// // 					ptTarget5 = affrect.GetCornerPo();
// // 					ptTarget6 = affrect.GetCornerPx();
// // 					sc2Vector ptTarget7 = affrect.GetCornerPy();
// // 					sc2Vector ptTarget8 = affrect.GetCornerPopp();
// // 
// // 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // // 					dTargetX[6] = ptTarget7.GetX();
// // // 					dTargetY[6] = ptTarget7.GetY();
// // // 					dTargetX[7] = ptTarget8.GetX();
// // // 					dTargetY[7] = ptTarget8.GetY();
// // 
// // 					vcpTarPlatPos[6].SetPos(ptTarget7);
// // 					vcpTarPlatPos[7].SetPos(ptTarget8);
// // 				}
// // 				else
// // 				{
// // 					return FALSE;
// // 				}
// // 
// // 			}
// // 			// 目标位置虚拟模式:0-78虚拟;1-56虚拟	
// // 			else
// // 			{
// // 				// 目标位置方向模式: 0：位置56水平；1：位置56竖直；
// // 				if (m_bTargetPositionDirectionMode == 0)
// // 				{
// // 					// (5) (6)
// // 					//  7   8
// // // 					sc2Vector ptTarget7 = sc2Vector(dTargetX[6], dTargetY[6]);
// // // 					sc2Vector ptTarget8 = sc2Vector(dTargetX[7], dTargetY[7]);
// // 
// // 					sc2Vector ptTarget7 = vcpTarPlatPos[6].GetPos();
// // 					sc2Vector ptTarget8 = vcpTarPlatPos[7].GetPos();
// // 
// // 					double dXLength = (ptTarget8 - ptTarget7).Length();
// // 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
// // 					scRadian xRot;
// // 					(ptTarget8 - ptTarget7).Angle(xRot);
// // 					xRot = xRot.SignedNormMod180();
// // 
// // 					str.Format("目标78坐标:7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("目标78连线角度:78Angle=%f",scDegree(xRot).ToDouble());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					scAffineRect affrect;
// // 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget7, dXLength, dYLength, xRot, scRadian(skPI));
// // 
// // 					ptTarget7 = affrect.GetCornerPo();
// // 					ptTarget8 = affrect.GetCornerPx();
// // 					sc2Vector ptTarget5 = affrect.GetCornerPy();
// // 					sc2Vector ptTarget6 = affrect.GetCornerPopp();
// // 
// // 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // // 					dTargetX[4] = ptTarget5.GetX();
// // // 					dTargetY[4] = ptTarget5.GetY();
// // // 					dTargetX[5] = ptTarget6.GetX();
// // // 					dTargetY[5] = ptTarget6.GetY();
// // 
// // 					vcpTarPlatPos[4].SetPos(ptTarget5);
// // 					vcpTarPlatPos[5].SetPos(ptTarget6);
// // 				}
// // 				else if (m_bTargetPositionDirectionMode == 1)// 目标位置方向模式: 0：位置56水平；1：位置56竖直；
// // 				{
// // 					//	7  (5)
// // 					//  8  (6)
// // // 					sc2Vector ptTarget7 = sc2Vector(dTargetX[6], dTargetY[6]);
// // // 					sc2Vector ptTarget8 = sc2Vector(dTargetX[7], dTargetY[7]);
// // 
// // 					sc2Vector ptTarget7 = vcpTarPlatPos[6].GetPos();
// // 					sc2Vector ptTarget8 = vcpTarPlatPos[7].GetPos();
// // 
// // 					double dXLength = (ptTarget8 - ptTarget7).Length();
// // 					double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
// // 					scRadian xRot;
// // 					(ptTarget8 - ptTarget7).Angle(xRot);
// // 					xRot = xRot.NormMod180();
// // 
// // 					str.Format("目标78坐标:7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("目标78连线角度:78Angle=%f",scDegree(xRot).ToDouble());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 					str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 					scAffineRect affrect;
// // 					affrect.SetCornerPoLengthsRotAndSkew(ptTarget7, dXLength, dYLength, xRot, scRadian(skPI));
// // 
// // 					ptTarget7 = affrect.GetCornerPo();
// // 					ptTarget8 = affrect.GetCornerPx();
// // 					sc2Vector ptTarget5 = affrect.GetCornerPy();
// // 					sc2Vector ptTarget6 = affrect.GetCornerPopp();
// // 
// // 					str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
// // 					AlignToolLogRecord(str,nPlatformIndex);
// // 
// // // 					dTargetX[4] = ptTarget5.GetX();
// // // 					dTargetY[4] = ptTarget5.GetY();
// // // 					dTargetX[5] = ptTarget6.GetX();
// // // 					dTargetY[5] = ptTarget6.GetY();
// // 
// // 					vcpTarPlatPos[4].SetPos(ptTarget5);
// // 					vcpTarPlatPos[5].SetPos(ptTarget6);
// // 				}
// // 				else
// // 				{
// // 					return FALSE;
// // 				}
// // 				
// // 			}
// // 
// // 
// // 			str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
// // 			AlignToolLogRecord(str,nPlatformIndex);
// // 
// // 		}
// // 
// // 	}
// 
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//10. 记录补偿修正后的相机对象、目标位置信息
// 	// 10.1 记录补偿修正后的相机对象位置信息
// 	// 10.2 记录补偿修正后的相机目标位置信息
// 	// 10.3 记录补偿修正后的相机对象、目标位置对应点的距离信息
// 
// 	//记录相机对象
// 	if (4 == m_iMarkNum || 6 == m_iMarkNum)
// 	{
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的坐标
// 			strTempInfo.Format("补偿后对象mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			pt[i] = vcpObjPlatPos[i].GetPos();
// 		}
// 
// 		//记录对象距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("补偿后对象01距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;
// 	}
// 	else if (6 == m_iMarkNum)
// 	{
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的坐标
// 			strTempInfo.Format("补偿后对象mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			pt[i] = vcpObjPlatPos[i].GetPos();
// 		}
// 
// 		//记录对象距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("补偿后对象01距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[1] = (pt[1] - pt[2]).Length();
// 		(pt[1] - pt[2]).Angle(raAngle[1]);
// 		strTempInfo.Format("补偿后对象12距离角度 L:, %f ,D:, %f ,", dLen[1], scDegree(raAngle[1]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[2] = (pt[2] - pt[0]).Length();
// 		(pt[2] - pt[0]).Angle(raAngle[2]);
// 		strTempInfo.Format("补偿后对象02距离角度 L:, %f ,D:, %f ,", dLen[2], scDegree(raAngle[2]).ToDouble());
// 		strInfo += strTempInfo;
// 	}
// 	else if (8 == m_iMarkNum)
// 	{
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			//记录相机对象mark的坐标
// 			strTempInfo.Format("补偿后对象mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			pt[i] = vcpObjPlatPos[i].GetPos();
// 		}
// 
// 		//记录对象距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("补偿后对象01距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[1] = (pt[3] - pt[2]).Length();
// 		(pt[3] - pt[2]).Angle(raAngle[1]);
// 		strTempInfo.Format("补偿后对象23距离角度 L:, %f ,D:, %f ,", dLen[1], scDegree(raAngle[1]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[2] = (pt[2] - pt[0]).Length();
// 		(pt[2] - pt[0]).Angle(raAngle[2]);
// 		strTempInfo.Format("补偿后对象02距离角度 L:, %f ,D:, %f ,", dLen[2], scDegree(raAngle[2]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[3] = (pt[3] - pt[1]).Length();
// 		(pt[3] - pt[1]).Angle(raAngle[3]);
// 		strTempInfo.Format("补偿后对象13距离角度 L:, %f ,D:, %f ,", dLen[3], scDegree(raAngle[3]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("补偿后对象02-01角度D:, %f ,", scDegree(raAngle[2]-raAngle[0]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("补偿后对象13-01角度D:, %f ,", scDegree(raAngle[3]-raAngle[0]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("补偿后对象02-23角度D:, %f ,", scDegree(raAngle[2]-raAngle[1]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("补偿后对象13-23角度D:, %f ,", scDegree(raAngle[3]-raAngle[1]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 	}
// 	//记录相机目标
// 	if (4 == m_iMarkNum)
// 	{
// 		for (k=m_iMarkNum/2;k<m_pTargetPlatformAxisPos.size();k++)
// 		{
// 			strTempInfo.Format("目标mark%d轴位置 X:, %f ,Y:, %f ,D:, %f ,",k,pTargetPlatformAxisPos.at(k)->m_dPosX,pTargetPlatformAxisPos.at(k)->m_dPosY,pTargetPlatformAxisPos.at(k)->m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			//记录相机目标mark的坐标
// 			strTempInfo.Format("修正后目标mark%d图像坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			//记录相机目标mark的坐标
// // 			strTempInfo.Format("修正后目标mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,dTargetX[i],dTargetY[i],dTargetD[i]);
// // 			strInfo += strTempInfo;
// 
// 			strTempInfo.Format("修正后目标mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			pt[i-m_iMarkNum/2] = vcpTarPlatPos[i].GetPos();
// 		}
// 
// 		//记录目标距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("修正后目标23距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;
// 	}
// 	else if (6 == m_iMarkNum)
// 	{
// 		for (k=m_iMarkNum/2;k<m_pTargetPlatformAxisPos.size();k++)
// 		{
// 			strTempInfo.Format("目标mark%d轴位置 X:, %f ,Y:, %f ,D:, %f ,",k,pTargetPlatformAxisPos.at(k)->m_dPosX,pTargetPlatformAxisPos.at(k)->m_dPosY,pTargetPlatformAxisPos.at(k)->m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			//记录相机目标mark的坐标
// 			strTempInfo.Format("修正后目标mark%d图像坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			//记录相机目标mark的坐标
// 
// 			strTempInfo.Format("修正后目标mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			pt[i-m_iMarkNum/2] = vcpTarPlatPos[i].GetPos();
// 		}
// 
// 		//记录目标距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		memset(dLen, 0, sizeof(double)*4);
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("修正后目标34距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[1] = (pt[1] - pt[2]).Length();
// 		(pt[1] - pt[2]).Angle(raAngle[1]);
// 		strTempInfo.Format("修正后目标45距离角度 L:, %f ,D:, %f ,", dLen[1], scDegree(raAngle[1]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[3] = (pt[2] - pt[0]).Length();
// 		(pt[2] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("修正后目标35距离角度 L:, %f ,D:, %f ,", dLen[2], scDegree(raAngle[2]).ToDouble());
// 		strInfo += strTempInfo;
// 	}
// 	else if (8 == m_iMarkNum)
// 	{
// 		for (k=m_iMarkNum/2;k<m_pTargetPlatformAxisPos.size();k++)
// 		{
// 			strTempInfo.Format("目标mark%d轴位置 X:, %f ,Y:, %f ,D:, %f ,",k,pTargetPlatformAxisPos.at(k)->m_dPosX,pTargetPlatformAxisPos.at(k)->m_dPosY,pTargetPlatformAxisPos.at(k)->m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			//记录相机目标mark的坐标
// 			strTempInfo.Format("修正后目标mark%d图像坐标 X:, %f ,Y:, %f ,D:, %f ,",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
// 			strInfo += strTempInfo;
// 		}
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			//记录相机目标mark的坐标
// 
// 			strTempInfo.Format("修正后目标mark%d平台坐标 X:, %f ,Y:, %f ,D:, %f ,",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 			strInfo += strTempInfo;
// 		}
// 
// 		sc2Vector pt[4];
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			pt[i-m_iMarkNum/2] = vcpTarPlatPos[i].GetPos();
// 		}
// 
// 		//记录目标距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		dLen[0] = (pt[1] - pt[0]).Length();
// 		(pt[1] - pt[0]).Angle(raAngle[0]);
// 		strTempInfo.Format("修正后目标45距离角度 L:, %f ,D:, %f ,", dLen[0], scDegree(raAngle[0]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[1] = (pt[3] - pt[2]).Length();
// 		(pt[3] - pt[2]).Angle(raAngle[1]);
// 		strTempInfo.Format("修正后目标67距离角度 L:, %f ,D:, %f ,", dLen[1], scDegree(raAngle[1]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[2] = (pt[2] - pt[0]).Length();
// 		(pt[2] - pt[0]).Angle(raAngle[2]);
// 		strTempInfo.Format("修正后目标46距离角度 L:, %f ,D:, %f ,", dLen[2], scDegree(raAngle[2]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		dLen[3] = (pt[3] - pt[1]).Length();
// 		(pt[3] - pt[1]).Angle(raAngle[3]);
// 		strTempInfo.Format("修正后目标57距离角度 L:, %f ,D:, %f ,", dLen[3], scDegree(raAngle[3]).ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("修正后目标46-45角度D:, %f ,", scDegree(raAngle[2]-raAngle[0]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("修正后目标57-45角度D:, %f ,", scDegree(raAngle[3]-raAngle[0]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("修正后目标46-67角度D:, %f ,", scDegree(raAngle[2]-raAngle[1]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 		strTempInfo.Format("修正后目标57-67角度D:, %f ,", scDegree(raAngle[3]-raAngle[1]).SignedNorm().ToDouble());
// 		strInfo += strTempInfo;
// 
// 	}
// 
// 	//记录相机对象-目标距离
// 	if (4 == m_iMarkNum)
// 	{
// 		sc2Vector ptObject[4];
// 		sc2Vector ptTarget[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			ptObject[i] = vcpObjPlatPos[i].GetPos();
// 		}
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			ptTarget[i-m_iMarkNum/2] = vcpTarPlatPos[i].GetPos();
// 		}
// 
// 		//记录目标距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			dLen[i] = (ptTarget[i] - ptObject[i]).Length();
// 			strTempInfo.Format("对位前目标%d-对象%d距离 L:, %f ,", i+m_iMarkNum/2, i, dLen[i]);
// 			strInfo += strTempInfo;
// 		}
// 	}
// 	else if (6 == m_iMarkNum)
// 	{
// 		sc2Vector ptObject[4];
// 		sc2Vector ptTarget[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			ptObject[i] = vcpObjPlatPos[i].GetPos();
// 		}
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			ptTarget[i-m_iMarkNum/2] = vcpTarPlatPos[i].GetPos();
// 		}
// 
// 		//记录目标距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			dLen[i] = (ptTarget[i] - ptObject[i]).Length();
// 			strTempInfo.Format("对位前目标%d-对象%d距离 L:, %f ,", i+m_iMarkNum/2, i, dLen[i]);
// 			strInfo += strTempInfo;
// 		}
// 	}
// 	else if (8 == m_iMarkNum)
// 	{
// 		sc2Vector ptObject[4];
// 		sc2Vector ptTarget[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			ptObject[i] = vcpObjPlatPos[i].GetPos();
// 		}
// 		for (i=m_iMarkNum/2; i<m_iMarkNum; i++)
// 		{
// 			ptTarget[i-m_iMarkNum/2] = vcpTarPlatPos[i].GetPos();
// 		}
// 
// 		//记录目标距离角度
// 		double dLen[4];
// 		scRadian raAngle[4];
// 		for (i=0; i<m_iMarkNum/2; i++)
// 		{
// 			dLen[i] = (ptTarget[i] - ptObject[i]).Length();
// 			strTempInfo.Format("对位前目标%d-对象%d距离 L:, %f ,", i+m_iMarkNum/2, i, dLen[i]);
// 			strInfo += strTempInfo;
// 		}
// 		//记录目标和中心和对象的中心
// 		double dTargetCenX,dTargetCenY;
// 
// 		dTargetCenX = (vcpTarPlatPos[4].GetPosX() + vcpTarPlatPos[5].GetPosX() + vcpTarPlatPos[6].GetPosX() + vcpTarPlatPos[7].GetPosX())/4;
// 		dTargetCenY = (vcpTarPlatPos[4].GetPosY() + vcpTarPlatPos[5].GetPosY() + vcpTarPlatPos[6].GetPosY() + vcpTarPlatPos[7].GetPosY())/4;
// 
// 		strTempInfo.Format("对位前目标中心:, %f , %f ,",dTargetCenX,dTargetCenY);
// 		strInfo += strTempInfo;
// 
// 		double dObjectCenX,dObjectCenY;
// 		dObjectCenX = (vcpObjPlatPos[0].GetPosX() + vcpObjPlatPos[1].GetPosX() + vcpObjPlatPos[2].GetPosX() + vcpObjPlatPos[3].GetPosX())/4;
// 		dObjectCenY = (vcpObjPlatPos[0].GetPosY() + vcpObjPlatPos[1].GetPosY() + vcpObjPlatPos[2].GetPosY() + vcpObjPlatPos[3].GetPosY())/4;
// 
// 		strTempInfo.Format("对位前对象中心:, %f , %f ,",dObjectCenX,dObjectCenY);
// 		strInfo += strTempInfo;
// 	}
// 
// 	AlignToolLogRecordProduct(strInfo,nPlatformIndex);
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//12. 目标Mark与对象Mark在平台坐标下进行对位，计算旋转角度及XY轴偏移量
// 	// 12.1 目标Mark与对象Mark在平台坐标下进行对位，计算旋转角度及XY轴偏移量
// 
// 	// $4、目标Mark与对象Mark在平台坐标下进行对位，计算旋转角度及XY轴偏移量
// 	if (m_bTargetObjectCamSeparate)
// 	{
// 		m_PlatformOffset.m_dPosX  = 0;		
// 		m_PlatformOffset.m_dPosY  = 0;
// 		m_PlatformOffset.m_dAngle = 0;
// 
// 		m_ProductOffset.m_dPosX  = 0;		
// 		m_ProductOffset.m_dPosY  = 0;
// 		m_ProductOffset.m_dAngle = 0;
// 
// 		m_ProductOffsetXYPD.m_dPosX  = 0;		
// 		m_ProductOffsetXYPD.m_dPosY  = 0;
// 		m_ProductOffsetXYPD.m_dAngle = 0;
// 
// 		int nPosNum = m_iMarkNum/2;							// 实际对位的位置数量
// 		std::vector<CCoordPos> vcpObjectPlatformPos;		// 对象位置
// 		std::vector<CCoordPos> vcpTargetPlatformPos;		// 目标位置
// 		std::vector<CCoordPos> vcpAlginedObjectPlatformPos; // 对位后对象位置
// 		std::vector<CCoordPos> vcpAlginedTargetPlatformPos; // 对位后目标位置
// 		for (int nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
// 		{
// 			// 对象位置
// 			CCoordPos cpObjectPlatformPos;
// 
// 			cpObjectPlatformPos = vcpObjPlatPos[nPosIndex];
// 
// 			vcpObjectPlatformPos.push_back(cpObjectPlatformPos);
// 
// 
// 			// 目标位置
// 			CCoordPos cpTargetPlatformPos;
// 			if (m_bInnerAlignBench)
// 			{	
// 				cpTargetPlatformPos = vcpTarPlatPos[nPosIndex];
// 			}
// 			else
// 			{
// 				cpTargetPlatformPos = vcpTarPlatPos[nPosNum + nPosIndex];
// 			}
// 
// 			vcpTargetPlatformPos.push_back(cpTargetPlatformPos);
// 		}
// 		vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
// 		vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;
// 
// 		/////方式1
// 		if (GetMidPlatformType()==ePlatformXYPD)
// 		{
// 			std::vector<CCoordPos> vcpPreTargetPlatformPos;		// 上一次目标位置旋转后新的目标位置
// 			if (1)
// 			{
// 				vcpPreTargetPlatformPos = vcpAlginedTargetPlatformPos;
// 			}
// 			else
// 			{
// 				for (int j=0;j<nPosNum;j++)
// 				{
// 					CCoordPos pos;
// 					pos.m_dPosX = m_dTargetX[j];
// 					pos.m_dPosY = m_dTargetY[j];
// 
// 					vcpPreTargetPlatformPos.push_back(pos);
// 				}
// 			}
// 			CCoordPos tempplatformOffset;
// 
// 			// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
// 			if (!GetAlginOffset(vcpObjectPlatformPos, vcpPreTargetPlatformPos, m_ProductOffsetXYPD, tempplatformOffset, 
// 				vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
// 			{
// 				str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(失败)");
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				return FALSE;
// 			}
// 
// 			str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(成功)");
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 
// 		// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
// 		if (!GetAlginOffset(vcpObjectPlatformPos, vcpTargetPlatformPos, m_ProductOffset, m_PlatformOffset, 
// 			vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
// 		{
// 			str.Format("------------------------------------------------------------计算目标固定补偿(失败)");
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			return FALSE;
// 		}
// 
// 		// 获取产品位置（旋转中心）和角度
// 
// 		sc2Vector vTargetPos;
// 		sc2Vector vObjectPos;	
// 		sc2Vector vFixedTargetPos;
// 		std::vector<sc2Vector> vTransferTarPos;
// 		std::vector<sc2Vector> vTransferObjPos;
// 		for (int i=0;i<m_iMarkNum/2;i++)
// 		{
// 			vObjectPos.SetX(vcpObjPlatPos.at(i).m_dPosX);
// 			vObjectPos.SetY(vcpObjPlatPos.at(i).m_dPosY);
// 			vTransferObjPos.push_back(vObjectPos);
// 		}
// 		for (int i=m_iMarkNum/2;i<m_iMarkNum && i<vcpTarPlatPos.size();i++)
// 		{
// 			vTargetPos.SetX(vcpTarPlatPos.at(i).m_dPosX);
// 			vTargetPos.SetY(vcpTarPlatPos.at(i).m_dPosY);
// 			vFixedTargetPos = vfGetTransformRotateShiftPoint(vTargetPos, scDegree(-m_ProductOffset.m_dAngle), 0,0);
// 			vTransferTarPos.push_back(vFixedTargetPos);
// 		}
// 
// 		double objX =0;
// 		double objY =0;
// 		double tarX = 0;
// 		double tarY=0;
// 		for (int i=0;i<vTransferObjPos.size()&&i<vTransferTarPos.size();i++)
// 		{
// 			objX = objX + vTransferObjPos.at(i).GetX();
// 			objY = objY + vTransferObjPos.at(i).GetY();
// 			tarX = tarX + vTransferTarPos.at(i).GetX();
// 			tarY = tarY + vTransferTarPos.at(i).GetY();
// 		}
// 		objX = objX/vTransferObjPos.size();
// 		objY = objY/vTransferObjPos.size();
// 		tarX = tarX/vTransferTarPos.size();
// 		tarY = tarY/vTransferTarPos.size();
// 
// 		str.Format("------------------------------------------------------------计算目标固定补偿（成功）");
// 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 		offset.m_dPosX = objX - tarX;
// 		offset.m_dPosY = objY - tarY;
// 		offset.m_dAngle = -m_ProductOffset.m_dAngle;
// 		//offset.m_dPosX = -m_PlatformOffset.m_dPosX;
// 		//offset.m_dPosY = -m_PlatformOffset.m_dPosY;
// 		//offset.m_dAngle = -m_ProductOffset.m_dAngle;
// 
// 		///////方式2
// 		//sc2Vector vProductObjectPos;
// 		//scDegree  degProductObjectAngle;
// 		//GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos, degProductObjectAngle);
// 
// 		//sc2Vector vProductTargetPos;
// 		//scDegree  degProductTargetAngle;
// 		//GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos, degProductTargetAngle);
// 
// 		//scDegree degTempProductOffsetD = (degProductObjectAngle - degProductTargetAngle).SignedNormMod180();
// 
// 		//sc2Vector vTempProductTargetPos;		// 临时目标位置
// 		//sc2Vector vTempProductObjectPos;		// 临时对象位置
// 
// 		//vTempProductTargetPos = vfGetTransformRotateShiftPoint(vProductTargetPos, degTempProductOffsetD, 0, 0);
// 		//vTempProductObjectPos = vProductObjectPos;
// 
// 		//sc2Vector vTempPlatformOffsetXY = vTempProductObjectPos - vTempProductTargetPos;
// 
// 		//offset.m_dPosX = vTempPlatformOffsetXY.GetX();
// 		//offset.m_dPosY = vTempPlatformOffsetXY.GetY();
// 		//offset.m_dAngle = degTempProductOffsetD.ToDouble();
// 
// 		////方式3
// 		//double objX =0;
// 		//double objY =0;
// 		//double tarX = 0;
// 		//double tarY=0;
// 		////for (int i=0;i<vcpTarPlatPos.size()&&i<vcpObjPlatPos.size();i++)
// 		////{
// 		////	objX = objX + vcpObjPlatPos.at(i).GetPosX();
// 		////	objY = objY + vcpObjPlatPos.at(i).GetPosY();
// 		////	tarX = tarX + vcpTarPlatPos.at(i).GetPosX();
// 		////	tarY = tarY + vcpTarPlatPos.at(i).GetPosY();
// 		////}
// 		////objX = objX/vcpObjPlatPos.size();
// 		////objY = objY/vcpObjPlatPos.size();
// 		////tarX = tarX/vcpTarPlatPos.size();
// 		////tarY = tarY/vcpTarPlatPos.size();
// 
// 
// 
// 		//objX = vcpObjPlatPos.at(0).GetPosX();
// 		//objY =  vcpObjPlatPos.at(0).GetPosY();
// 		//tarX = vcpTarPlatPos.at(0).GetPosX();
// 		//tarY = vcpTarPlatPos.at(0).GetPosY();
// 
// 
// 
// 		//str.Format("------------------------------------------------------------计算目标固定补偿（成功）");
// 		//AlignToolLogRecord(str,nPlatformIndex);
// 
// 		//offset.m_dPosX = objX - tarX;
// 		//offset.m_dPosY = objY - tarY;
// 		//offset.m_dAngle = 0;
// 		return TRUE;
// 	}
// 	return FALSE;
// }

BOOL vcBaseAlignTool::CaculateTargetFixOffset(CCoordPos &offset)
{
	int nTargetFixOffsetType = m_AlignermentParam.GetTargetOffsetType();

	switch(nTargetFixOffsetType)
	{
	case 0:
		{
			return CaculateTargetFixOffsetForProduct(offset);
		}
		break;

	case 1:
		{
			return CaculateTargetFixOffsetForDmCode(offset);
		}
		break;

	default:
		{
			return FALSE;
		}
		break;
	}

	return FALSE;
}


BOOL vcBaseAlignTool::CaculateTargetFixOffsetForDmCode(CCoordPos &offset)
{
	if (!(m_bTargetObjectCamSeparate && m_bTargetCalibUseBoard))
	{
		return FALSE;
	}

	int nPlatformIndex = m_nPlatformIndex;

	CString str;
	str.Format("目标固定补偿计算开始（二维码关联）:------------------------------------------------------------");
	AlignToolLogRecord(str,nPlatformIndex);

	std::vector<int> nObjectPosIndex;
	std::vector<int> nTargetPosIndex;

	for (int i=0; i<m_iMarkNum/2; i++)
	{
		nTargetPosIndex.push_back(i + m_iMarkNum/2);
	}

	for (int j=0; j<m_iMarkNum/2; j++)
	{
		nObjectPosIndex.push_back(j);
	}


	if (!m_bReadTargetPlatformPos)
	{
		if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(nTargetPosIndex))
		{
			return FALSE;
		}
	}

	if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(nObjectPosIndex))
	{
		return FALSE;
	}

	//目标mark坐标补偿时用到这些参数
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
	std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;

	int k=0;
	for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
	{
		pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置
		str.Format("搜索对象mark%d 轴位置 X=%f,Y=%f,D=%f",k,pObjectPlatformAxisPos.at(k)->m_dPosX,pObjectPlatformAxisPos.at(k)->m_dPosY,pObjectPlatformAxisPos.at(k)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
	}

	std::vector<CPlatformXYDAxisPos*> pTargetPlatformAxisPos;
	for (k=0;k<m_pTargetPlatformAxisPos.size();k++)
	{
		pTargetPlatformAxisPos.push_back((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k));//搜索目标mark轴位置
		str.Format("搜索目标mark%d 轴位置 X=%f,Y=%f,D=%f",k,pTargetPlatformAxisPos.at(k)->m_dPosX,pTargetPlatformAxisPos.at(k)->m_dPosY,pTargetPlatformAxisPos.at(k)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
	}

	if(pTargetPlatformAxisPos.size()<m_iMarkNum)
	{
		pTargetPlatformAxisPos.resize(m_iMarkNum);
	}


	std::vector<CCoordPos> vcpObjPlatPos;		// 对象位置
	std::vector<CCoordPos> vcpTarPlatPos;		// 目标位置

	vcpObjPlatPos.resize(8);
	vcpTarPlatPos.resize(8);


	//////////////////////////////////////////////////////////////////////////
	//4.实时对象Mark的图像坐标值转化为平台坐标值

	// $1、实时对象Mark的图像坐标值转化为平台坐标值

	// $1.1 将实时对象Mark的图像坐标值转换为实时对象Mark搜索时的全局平台坐标值
	//	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPos();
	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPosForAlign();

	if (FALSE == m_ObjectMarkPlatformPos.IsAllMarkPlatformPosOK())
	{
		return FALSE;
	}
	int i=0;


	//////////////////////////////////////////////////////////////////////////
	//5.实时目标Mark的图像坐标值转化为平台坐标值
	if (eTargetBench != m_AlignermentParam.GetTargetMarkType())
	{
		if (!m_bReadTargetPlatformPos)
		{
//			m_TargetMarkPlatformPos = GetTargetMarkPlatformPos();
			m_TargetMarkPlatformPos = GetTargetMarkPlatformPosForAlign();
		}

		if (FALSE == m_TargetMarkPlatformPos.IsAllMarkPlatformPosOK())
		{
			return FALSE;
		}
	}


	for (i=0; i<m_iMarkNum; i++)
	{
		//记录相机对象mark的坐标
		vcpObjPlatPos[i] = m_ObjectMarkPlatformPos.m_vPos[i];

		str.Format("对象图像坐标%d:ObjectImageX=%f,ObjectImageY=%f,ObjectImageD=%f",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);
	}


	//////////////////////////////////////////////////////////////////////////
	//8. 对目标平台坐标进行修正
	// 8.1 

	//读取每个相机对应的对象mark和平台mark的坐标值
	for (i=0; i<m_iMarkNum; i++)
	{
		// $2、实时目标Mark的图像坐标值转化为平台坐标值
		// 目标Mark为基准Mark
		if (eTargetBench == m_AlignermentParam.GetTargetMarkType())
		{	
			//如果没有进行基准修正，则使用标定后的基准mark平台坐标
			if (FALSE == m_AlignermentParam.GetBenchTargetMarkFixEnable())
			{
				CPlatformXYDAxisPos* pBenchPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());//标定基准轴位置

				vcpTarPlatPos[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos;

				pTargetPlatformAxisPos.at(i) = pBenchPlatformAxisPos;
			}
			else//进行基准修正，使用修正后的基准坐标
			{
				CPlatformXYDAxisPos* pBenchFixPlatformAxisPos = (CPlatformXYDAxisPos*)(m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetFixPlatformPos(i));//基准修正时轴位置

				vcpTarPlatPos[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i);

				pTargetPlatformAxisPos.at(i) = pBenchFixPlatformAxisPos;
			}
		}
		else//目标mark为实时mark
		{
			//记录相机目标mark的坐标
			vcpTarPlatPos[i] = m_TargetMarkPlatformPos.m_vPos[i];

		}

		str.Format("目标图像坐标%d:TargetImageX=%f,TargetImageY=%f,TargetImageD=%f",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);


		str.Format("目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

		// $3、对目标Mark的平台坐标值进行修正(平台XY轴移动影响影响结果)
		double dPlatformOffsetX = 0;
		double dPlatformOffsetY = 0;
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

		// 修正回读取目标平台坐标时，已经重构点的轴位置偏移
		if (m_bReadTargetPlatformPos)
		{
			// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
			if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
			{
				dPlatformOffsetX = 0;
				dPlatformOffsetY = 0;
			}
			else
			{
				dPlatformOffsetX = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
			}

			if (GetMidPlatformType()==ePlatformXYPD)
			{
				dPlatformOffsetX = 0;
				dPlatformOffsetY = 0;
			}		

			vcpTarPlatPos[i].Offset(dPlatformOffsetX, dPlatformOffsetY);

			str.Format("1-平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);

		}

		if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
		{
			dPlatformOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
			dPlatformOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
		}
		else
		{
			dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
			dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

			str.Format("2-平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);

			if ((m_bTargetObjectCamSeparate && m_iMarkNum == 8 ) && m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
			{
				//对象位置虚拟模式：12拍照34虚拟
				if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
				{
					//  1   2
					// (3) (4)

					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

				}
				//对象位置虚拟模式：34拍照12虚拟
				else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
				{
					// (1) (2)
					//  3   4

					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
				}
				//对象位置虚拟模式：13拍照24虚拟
				else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
				{
					//	1  (2)
					//  3  (4)

					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;


				}
				//对象位置虚拟模式：24拍照13虚拟
				else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
				{
					//	（1） 2
					//  （3） 4

					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
				}

				str.Format("3-平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
				AlignToolLogRecord(str,nPlatformIndex);
			}

		}

		if (GetMidPlatformType()==ePlatformXYPD)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTarObjCamSepNoAxisCalib)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}
		else if (GetMidPlatformType()==ePlatformXY)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		if (m_bTargetObjectCamSeparate && m_bTargetCalibUseBoard)
		{
			// 目标标定轴相对于对象标定轴位置偏移量
			CPlatformXYDAxisPos*  pTargetPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformAxisPos());

			double dVirtualPlatformAixsOffsetX = 0;
			double dVirtualPlatformAixsOffsetY = 0;
			if ((eTargetMoveByPlatform == m_eAlignerTargetMoveType))
			{
				dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
				dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
			}
			else
			{
				dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
				dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;

				if ((m_bTargetObjectCamSeparate && m_iMarkNum == 8 ) && m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
				{
					//对象位置虚拟模式：12拍照34虚拟
					if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
					{
						//  1   2
						// (3) (4)

						dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
						dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;

					}
					//对象位置虚拟模式：34拍照12虚拟
					else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
					{
						// (1) (2)
						//  3   4

						dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
						dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
					}
					//对象位置虚拟模式：13拍照24虚拟
					else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
					{
						//	1  (2)
						//  3  (4)

						dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
						dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;


					}
					//对象位置虚拟模式：24拍照13虚拟
					else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
					{
						//	（1） 2
						//  （3） 4

						dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
						dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
					}
				}
			}

			if (eDirectNegative == iPlatformXCoordType) dVirtualPlatformAixsOffsetX = -1*dVirtualPlatformAixsOffsetX;	
			if (eDirectNegative == iPlatformYCoordType) dVirtualPlatformAixsOffsetY = -1*dVirtualPlatformAixsOffsetY;

			dPlatformOffsetX = dPlatformOffsetX - dVirtualPlatformAixsOffsetX;
			dPlatformOffsetY = dPlatformOffsetY - dVirtualPlatformAixsOffsetY;
		}


		vcpTarPlatPos[i].Offset(-dPlatformOffsetX, -dPlatformOffsetY);

		str.Format("4-平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);
	}

	if (m_bTargetObjectCamSeparate)
	{
		m_PlatformOffset.m_dPosX  = 0;		
		m_PlatformOffset.m_dPosY  = 0;
		m_PlatformOffset.m_dAngle = 0;

		m_ProductOffset.m_dPosX  = 0;		
		m_ProductOffset.m_dPosY  = 0;
		m_ProductOffset.m_dAngle = 0;

		m_ProductOffsetXYPD.m_dPosX  = 0;		
		m_ProductOffsetXYPD.m_dPosY  = 0;
		m_ProductOffsetXYPD.m_dAngle = 0;

		int nPosNum = m_iMarkNum/2;							// 实际对位的位置数量
		std::vector<CCoordPos> vcpObjectPlatformPos;		// 对象位置
		std::vector<CCoordPos> vcpTargetPlatformPos;		// 目标位置
		std::vector<CCoordPos> vcpAlginedObjectPlatformPos; // 对位后对象位置
		std::vector<CCoordPos> vcpAlginedTargetPlatformPos; // 对位后目标位置
		for (int nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
		{
			// 对象位置
			CCoordPos cpObjectPlatformPos;

			cpObjectPlatformPos = vcpObjPlatPos[nPosIndex];

			vcpObjectPlatformPos.push_back(cpObjectPlatformPos);


			// 目标位置
			CCoordPos cpTargetPlatformPos;
			if (m_bInnerAlignBench)
			{	
				cpTargetPlatformPos = vcpTarPlatPos[nPosIndex];
			}
			else
			{
				cpTargetPlatformPos = vcpTarPlatPos[nPosNum + nPosIndex];
			}

			vcpTargetPlatformPos.push_back(cpTargetPlatformPos);
		}
		vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
		vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;

		// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
		if (!GetAlginOffset(vcpObjectPlatformPos, vcpTargetPlatformPos, m_ProductOffset, m_PlatformOffset, 
			vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
		{
			str.Format("------------------------------------------------------------计算目标固定补偿(失败)");
			AlignToolLogRecord(str,nPlatformIndex);
			return FALSE;
		}

		// 获取产品位置（旋转中心）和角度

		sc2Vector vTargetPos;
		sc2Vector vObjectPos;	
		sc2Vector vFixedTargetPos;
		std::vector<sc2Vector> vTransferTarPos;
		std::vector<sc2Vector> vTransferObjPos;

		for (int i=0;i<m_iMarkNum/2;i++)
		{
			vObjectPos.SetX(vcpObjPlatPos.at(i).m_dPosX);
			vObjectPos.SetY(vcpObjPlatPos.at(i).m_dPosY);
			vTransferObjPos.push_back(vObjectPos);
		}

		for (int i=m_iMarkNum/2;i<m_iMarkNum && i<vcpTarPlatPos.size();i++)
		{
			vTargetPos.SetX(vcpTarPlatPos.at(i).m_dPosX);
			vTargetPos.SetY(vcpTarPlatPos.at(i).m_dPosY);
			vFixedTargetPos = vfGetTransformRotateShiftPoint(vTargetPos, scDegree(-m_ProductOffset.m_dAngle), 0,0);
			vTransferTarPos.push_back(vFixedTargetPos);
		}

		double objX =0;
		double objY =0;
		double tarX = 0;
		double tarY=0;

		for (int i=0;i<vTransferObjPos.size()&&i<vTransferTarPos.size();i++)
		{
			objX = objX + vTransferObjPos.at(i).GetX();
			objY = objY + vTransferObjPos.at(i).GetY();
			tarX = tarX + vTransferTarPos.at(i).GetX();
			tarY = tarY + vTransferTarPos.at(i).GetY();
		}

		objX = objX/vTransferObjPos.size();
		objY = objY/vTransferObjPos.size();
		tarX = tarX/vTransferTarPos.size();
		tarY = tarY/vTransferTarPos.size();

		offset.m_dPosX = objX - tarX;
		offset.m_dPosY = objY - tarY;
		offset.m_dAngle = -m_ProductOffset.m_dAngle;


		str.Format("目标固定补偿:X=%f,Y=%f,D=%f", offset.m_dPosX, offset.m_dPosY, offset.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("------------------------------------------------------------（二维码）计算目标固定补偿（成功）");
		AlignToolLogRecord(str,nPlatformIndex);



		return TRUE;
	}

	return FALSE;
}

BOOL vcBaseAlignTool::CaculateTargetFixOffsetForProduct(CCoordPos &offset)
{
	if (!(m_bTargetObjectCamSeparate && m_bTargetCalibUseBoard))
	{
		return FALSE;
	}

	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("目标固定补偿计算开始（产品）:------------------------------------------------------------");
	AlignToolLogRecord(str,nPlatformIndex);


	std::vector<int> nObjectPosIndex;
	std::vector<int> nTargetPosIndex;


	//lzk 0407 易天覆膜机-位置虚拟-目标检查模式判断是否进入
	if (m_bEnableTargetAndObjectPositionVirtualMode)
	{
		//对象位置虚拟
		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode)
		{
			//对象位置虚拟模式：12拍照34虚拟
			if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
			{
				nObjectPosIndex.push_back(0);
				nObjectPosIndex.push_back(1);
			}
			//对象位置虚拟模式：34拍照12虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
			{
				nObjectPosIndex.push_back(2);
				nObjectPosIndex.push_back(3);
			}
			//对象位置虚拟模式：13拍照24虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
			{
				nObjectPosIndex.push_back(0);
				nObjectPosIndex.push_back(2);
			}
			//对象位置虚拟模式：24拍照13虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
			{
				nObjectPosIndex.push_back(1);
				nObjectPosIndex.push_back(3);
			}
		}
		else
		{
			for (int j=0; j<m_iMarkNum/2; j++)
			{
				nObjectPosIndex.push_back(j);
			}
		}

		if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(nObjectPosIndex))
		{
			return FALSE;
		}




		//目标位置虚拟
		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode)
		{
			//目标位置虚拟模式：56拍照78虚拟
			if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 0)
			{
				nTargetPosIndex.push_back(4);
				nTargetPosIndex.push_back(5);
			}
			//目标位置虚拟模式：78拍照56虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 1)
			{
				nTargetPosIndex.push_back(6);
				nTargetPosIndex.push_back(7);
			}
			//目标位置虚拟模式：57拍照68虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 2)
			{
				nTargetPosIndex.push_back(4);
				nTargetPosIndex.push_back(6);
			}
			//目标位置虚拟模式：68拍照57虚拟
			else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 3)
			{
				nTargetPosIndex.push_back(5);
				nTargetPosIndex.push_back(7);
			}
		}
		else
		{			
			for (int i=0; i<m_iMarkNum/2; i++)
			{
				nTargetPosIndex.push_back(i + m_iMarkNum/2);
			}
		}


		if (!m_bReadTargetPlatformPos)
		{
			if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(nTargetPosIndex))
			{
				return FALSE;
			}
		}
	}
	else
	{

		for (int i=0; i<m_iMarkNum/2; i++)
		{
			nTargetPosIndex.push_back(i + m_iMarkNum/2);
		}

		for (int j=0; j<m_iMarkNum/2; j++)
		{
			nObjectPosIndex.push_back(j);
		}

		if (!m_bReadTargetPlatformPos)
		{
			if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(nTargetPosIndex))
			{
				return FALSE;
			}
		}


		if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(nObjectPosIndex))
		{
			return FALSE;
		}
	}




	//////////////////////////////////////////////////////////////////////////
	//2. 记录对象、目标平台轴位置（临时变量）
	//	2.1 目标mark坐标补偿时用到这些参数（对象、目标平台轴位置）

	//目标mark坐标补偿时用到这些参数
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
	std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;

	int k=0;
	for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
	{
		pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置
		str.Format("搜索对象mark%d 轴位置 X=%f,Y=%f,D=%f",k,pObjectPlatformAxisPos.at(k)->m_dPosX,pObjectPlatformAxisPos.at(k)->m_dPosY,pObjectPlatformAxisPos.at(k)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
	}

	std::vector<CPlatformXYDAxisPos*> pTargetPlatformAxisPos;
	for (k=0;k<m_pTargetPlatformAxisPos.size();k++)
	{
		pTargetPlatformAxisPos.push_back((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k));//搜索目标mark轴位置
		str.Format("搜索目标mark%d 轴位置 X=%f,Y=%f,D=%f",k,pTargetPlatformAxisPos.at(k)->m_dPosX,pTargetPlatformAxisPos.at(k)->m_dPosY,pTargetPlatformAxisPos.at(k)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
	}

	if(pTargetPlatformAxisPos.size()<m_iMarkNum)
	{
		pTargetPlatformAxisPos.resize(m_iMarkNum);
	}

	//////////////////////////////////////////////////////////////////////////
	// 3. 对象、目标临时平台坐标变量
	//  3.1 对象临时平台坐标变量(包含辅助点)
	//  3.2 目标临时平台坐标变量(包含辅助点)

	std::vector<CCoordPos> vcpObjPlatPos;		// 对象位置
	std::vector<CCoordPos> vcpTarPlatPos;		// 目标位置

	vcpObjPlatPos.resize(8);
	vcpTarPlatPos.resize(8);


	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPos();

	if (FALSE == m_ObjectMarkPlatformPos.IsAllMarkPlatformPosOK())
	{
		return FALSE;
	}
	int i=0;

	if (eTargetBench != m_AlignermentParam.GetTargetMarkType())
	{
		if (!m_bReadTargetPlatformPos)
		{
			m_TargetMarkPlatformPos = GetTargetMarkPlatformPos();
		}		
		if (FALSE == m_TargetMarkPlatformPos.IsAllMarkPlatformPosOK())
		{
			return FALSE;
		}
	}


	double dTempObjectX[8];			//存储对象mark图像坐标
	double dTempObjectY[8];
	double dTempObjectD[8];

	memset(dTempObjectX, 0.0, sizeof(double)*8);
	memset(dTempObjectY, 0.0, sizeof(double)*8);
	memset(dTempObjectD, 0.0, sizeof(double)*8);

	//lzk 0407  易天覆膜机-位置虚拟-对象对位
	if ((m_bTargetObjectCamSeparate && m_iMarkNum == 8 ) && m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
	{
		str.Format("---开始根据对象产品尺寸计算虚拟对位点---");
		AlignToolLogRecord(str,nPlatformIndex);

		//根据对象产品尺寸和对象12/34平台坐标虚拟目标34/12平台坐标 
		if ((m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0))
		{
			str.Format("对象尺寸信息错误:ObjectL1=%f,ObjectW1=%f",m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1);
			AlignToolLogRecord(str,nPlatformIndex);

			str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
			AlignToolLogRecord(str,nPlatformIndex);

			return FALSE;
		}

		str.Format("对象尺寸信息:ObjectL1=%f,ObjectW1=%f",m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1);
		AlignToolLogRecord(str,nPlatformIndex);

		for (int i = 0; i < m_iMarkNum; i++)
		{
			dTempObjectX[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX;
			dTempObjectY[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY;
			dTempObjectD[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle;
		}

		// 对象位置虚拟模式:12拍照34虚拟
		if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
		{
			//  1   2
			// (3) (4)

			// 放射矩形
			sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
			sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
			double dXLength = (ptObject2 - ptObject1).Length();
			double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
			scRadian xRot;
			(ptObject2 - ptObject1).Angle(xRot);
			// 对象1点、2点连线为水平方向，应将其归一化到-90-90
			xRot = xRot.SignedNormMod180();
			// 对象1点、2点连线为垂直方向，应将其归一化到0-180
			//xRot = xRot.NormMod180();

			str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));

			ptObject1 = affrect.GetCornerPo();
			ptObject2 = affrect.GetCornerPx();
			sc2Vector ptObject3 = affrect.GetCornerPy();
			sc2Vector ptObject4 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[2] = ptObject3.GetX();
			dTempObjectY[2] = ptObject3.GetY();
			dTempObjectX[3] = ptObject4.GetX();
			dTempObjectY[3] = ptObject4.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}
		}
		// 对象位置虚拟模式:34拍照12虚拟
		else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
		{
			// (1) (2)
			//  3   4
			sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
			sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
			double dXLength = (ptObject4 - ptObject3).Length();
			double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
			scRadian xRot;
			(ptObject4 - ptObject3).Angle(xRot);
			// 对象1点、2点连线为水平方向，应将其归一化到-90-90
			xRot = xRot.SignedNormMod180();
			// 对象1点、2点连线为垂直方向，应将其归一化到0-180
			//xRot = xRot.NormMod180();

			str.Format("对象34坐标:3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象34连线角度:34Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));

			ptObject3 = affrect.GetCornerPo();
			ptObject4 = affrect.GetCornerPx();
			sc2Vector ptObject1 = affrect.GetCornerPy();
			sc2Vector ptObject2 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[0] = ptObject1.GetX();
			dTempObjectY[0] = ptObject1.GetY();
			dTempObjectX[1] = ptObject2.GetX();
			dTempObjectY[1] = ptObject2.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}
		}
		// 对象位置虚拟模式:13拍照24虚拟
		else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
		{
			//	1  (2)
			//  3  (4)
			sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
			sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
			double dYLength = (ptObject3 - ptObject1).Length();
			double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
			scRadian xRot;
			(ptObject3 - ptObject1).Angle(xRot);
			// 对象1点、3点连线为水平方向，应将其归一化到-90-90
			//				xRot = xRot.SignedNormMod180();
			// 对象1点、3点连线为垂直方向，应将其归一化到0-180
			xRot = xRot.NormMod180();

			str.Format("对象13坐标:1X=%f,1Y=%f,3X=%f,3Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject3.GetX(),ptObject3.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象13连线角度:13Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dYLength, dXLength, xRot, scRadian(skPI));

			ptObject1 = affrect.GetCornerPo();
			ptObject3 = affrect.GetCornerPx();
			sc2Vector ptObject2 = affrect.GetCornerPy();
			sc2Vector ptObject4 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[1] = ptObject2.GetX();
			dTempObjectY[1] = ptObject2.GetY();
			dTempObjectX[3] = ptObject4.GetX();
			dTempObjectY[3] = ptObject4.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}
		}
		// 对象位置虚拟模式:24拍照13虚拟
		else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
		{
			//	（1） 2
			//  （3） 4
			// 放射矩形
			sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
			sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
			double dYLength = (ptObject4 - ptObject2).Length();
			double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
			scRadian xRot;
			(ptObject4 - ptObject2).Angle(xRot);
			// 对象1点、3点连线为水平方向，应将其归一化到-90-90
			//				xRot = xRot.SignedNormMod180();
			// 对象1点、3点连线为垂直方向，应将其归一化到0-180
			xRot = xRot.NormMod180();

			str.Format("对象24坐标:2X=%f,2Y=%f,4X=%f,4Y=%f",ptObject2.GetX(),ptObject2.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象24连线角度:24Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject2, dYLength, dXLength, xRot, scRadian(0));

			ptObject2= affrect.GetCornerPo();
			ptObject4 = affrect.GetCornerPx();
			sc2Vector ptObject1 = affrect.GetCornerPy();
			sc2Vector ptObject3 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[0] = ptObject1.GetX();
			dTempObjectY[0] = ptObject1.GetY();
			dTempObjectX[2] = ptObject3.GetX();
			dTempObjectY[2] = ptObject3.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}

		}
		// 对象位置虚拟模式:12拍照34虚拟
		else
		{
			//  1   2
			// (3) (4)

			// 放射矩形
			sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
			sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
			double dXLength = (ptObject2 - ptObject1).Length();
			double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
			scRadian xRot;
			(ptObject2 - ptObject1).Angle(xRot);
			// 对象1点、2点连线为水平方向，应将其归一化到-90-90
			xRot = xRot.SignedNormMod180();
			// 对象1点、2点连线为垂直方向，应将其归一化到0-180
			//xRot = xRot.NormMod180();

			str.Format("对象12坐标:1X=%f,1Y=%f,2X=%f,2Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象12连线角度:12Angle=%f",scDegree(xRot).ToDouble());
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("对象矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
			AlignToolLogRecord(str,nPlatformIndex);

			scAffineRect affrect;
			affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));

			ptObject1 = affrect.GetCornerPo();
			ptObject2 = affrect.GetCornerPx();
			sc2Vector ptObject3 = affrect.GetCornerPy();
			sc2Vector ptObject4 = affrect.GetCornerPopp();

			str.Format("对象1234坐标(虚拟):1X=%f,1Y=%f,2X=%f,2Y=%f,3X=%f,3Y=%f,4X=%f,4Y=%f",ptObject1.GetX(),ptObject1.GetY(),ptObject2.GetX(),ptObject2.GetY(),ptObject3.GetX(),ptObject3.GetY(),ptObject4.GetX(),ptObject4.GetY());
			AlignToolLogRecord(str,nPlatformIndex);

			dTempObjectX[2] = ptObject3.GetX();
			dTempObjectY[2] = ptObject3.GetY();
			dTempObjectX[3] = ptObject4.GetX();
			dTempObjectY[3] = ptObject4.GetY();

			for (int i = 0; i < m_iMarkNum; i++)
			{
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
				m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
			}
		}

	}


	for (i=0; i<m_iMarkNum; i++)
	{
		//记录相机对象mark的坐标
		vcpObjPlatPos[i] = m_ObjectMarkPlatformPos.m_vPos[i];

		str.Format("对象图像坐标%d:ObjectImageX=%f,ObjectImageY=%f,ObjectImageD=%f",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

		// $1.2 实时对象为虚拟Mark，则将实时对象Mark的平台坐标值转换为虚拟Mark的平台坐标值
		if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
		{
			if (FALSE == ConvertObjectPltfmPtToVirtualPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos))
				return FALSE;

			vcpObjPlatPos[i] = m_VirtualMarkPlatformPos.m_vPos[i];

			str.Format("虚拟对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}


	//////////////////////////////////////////////////////////////////////////
	//8. 对目标平台坐标进行修正
	// 8.1 

	//读取每个相机对应的对象mark和平台mark的坐标值
	for (i=0; i<m_iMarkNum; i++)
	{
		// $2、实时目标Mark的图像坐标值转化为平台坐标值
		// 目标Mark为基准Mark
		if (eTargetBench == m_AlignermentParam.GetTargetMarkType())
		{	
			//如果没有进行基准修正，则使用标定后的基准mark平台坐标
			if (FALSE == m_AlignermentParam.GetBenchTargetMarkFixEnable())
			{
				CPlatformXYDAxisPos* pBenchPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());//标定基准轴位置

				vcpTarPlatPos[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos;

				pTargetPlatformAxisPos.at(i) = pBenchPlatformAxisPos;
			}
			else//进行基准修正，使用修正后的基准坐标
			{
				CPlatformXYDAxisPos* pBenchFixPlatformAxisPos = (CPlatformXYDAxisPos*)(m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetFixPlatformPos(i));//基准修正时轴位置

				vcpTarPlatPos[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i);

				pTargetPlatformAxisPos.at(i) = pBenchFixPlatformAxisPos;
			}
		}
		else//目标mark为实时mark
		{
			vcpTarPlatPos[i] = m_TargetMarkPlatformPos.m_vPos[i];
		}

		str.Format("目标图像坐标%d:TargetImageX=%f,TargetImageY=%f,TargetImageD=%f",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);


		str.Format("目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

		// $3、对目标Mark的平台坐标值进行修正(平台XY轴移动影响影响结果)
		double dPlatformOffsetX = 0;
		double dPlatformOffsetY = 0;
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

		//修正回读取目标平台坐标时，已经重构点的轴位置偏移
		if (m_bReadTargetPlatformPos)
		{
			// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
			if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
			{
				dPlatformOffsetX = 0;
				dPlatformOffsetY = 0;
			}
			else
			{
				dPlatformOffsetX = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
			}

			if (GetMidPlatformType()==ePlatformXYPD)
			{
				dPlatformOffsetX = 0;
				dPlatformOffsetY = 0;
			}		

			vcpTarPlatPos[i].Offset(dPlatformOffsetX, dPlatformOffsetY);
		}


		if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
		{
			dPlatformOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
			dPlatformOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
		}
		else
		{
			dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
			dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

			if ((m_bTargetObjectCamSeparate && m_iMarkNum == 8 ) && m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
			{
				//对象位置虚拟模式：12拍照34虚拟
				if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
				{
					//  1   2
					// (3) (4)

					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

				}
				//对象位置虚拟模式：34拍照12虚拟
				else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
				{
					// (1) (2)
					//  3   4

					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
				}
				//对象位置虚拟模式：13拍照24虚拟
				else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
				{
					//	1  (2)
					//  3  (4)

					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;


				}
				//对象位置虚拟模式：24拍照13虚拟
				else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
				{
					//	（1） 2
					//  （3） 4

					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
				}
			}

		}

		if (GetMidPlatformType()==ePlatformXYPD)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTarObjCamSepNoAxisCalib)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		else if (GetMidPlatformType()==ePlatformXY)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		if (m_bTargetObjectCamSeparate && m_bTargetCalibUseBoard)
		{
			// 目标标定轴相对于对象标定轴位置偏移量
			CPlatformXYDAxisPos*  pTargetPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformAxisPos());

			double dVirtualPlatformAixsOffsetX = 0;
			double dVirtualPlatformAixsOffsetY = 0;
			if ((eTargetMoveByPlatform == m_eAlignerTargetMoveType))
			{
				dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
				dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
			}
			else
			{
				dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
				dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;

				if ((m_bTargetObjectCamSeparate && m_iMarkNum == 8 ) && m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
				{
					//对象位置虚拟模式：12拍照34虚拟
					if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 0)
					{
						//  1   2
						// (3) (4)

						dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
						dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;

					}
					//对象位置虚拟模式：34拍照12虚拟
					else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 1)
					{
						// (1) (2)
						//  3   4

						dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
						dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
					}
					//对象位置虚拟模式：13拍照24虚拟
					else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 2)
					{
						//	1  (2)
						//  3  (4)

						dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
						dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;


					}
					//对象位置虚拟模式：24拍照13虚拟
					else if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode == 3)
					{
						//	（1） 2
						//  （3） 4

						dVirtualPlatformAixsOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
						dVirtualPlatformAixsOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;
					}
				}
			}

			if (eDirectNegative == iPlatformXCoordType) dVirtualPlatformAixsOffsetX = -1*dVirtualPlatformAixsOffsetX;	
			if (eDirectNegative == iPlatformYCoordType) dVirtualPlatformAixsOffsetY = -1*dVirtualPlatformAixsOffsetY;

			dPlatformOffsetX = dPlatformOffsetX - dVirtualPlatformAixsOffsetX;
			dPlatformOffsetY = dPlatformOffsetY - dVirtualPlatformAixsOffsetY;
		}


		vcpTarPlatPos[i].Offset(-dPlatformOffsetX, -dPlatformOffsetY);

		str.Format("平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);
	}


	//////////////////////////////////////////////////////////////////////////
	//8. 综合对位重新构造新的目标对位点
	// 8.1 综合对位构造新的目标对位点

	if (!m_bReadTargetPlatformPos)
	{
		//重新构造新的对位点//================================================================================
		if (m_bTargetObjectCamSeparate && m_iMarkNum == 8 
			&& (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
			||m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4	
			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4 
			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight))
		{
			CCoordPos tmpPos[4];

			CString str;
			int k;
			for ( k=m_iMarkNum/2;k<m_iMarkNum;k++)
			{

				tmpPos[k-m_iMarkNum/2] = vcpTarPlatPos[k];

				str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,tmpPos[k-m_iMarkNum/2].m_dPosX,tmpPos[k-m_iMarkNum/2].m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
			}
			CCoordPos ResultPos[4];
			scLine ResultLine[4];
			sc2Vector UsePoint[8];
			bool bIntersect;
			std::vector<sc2Vector> crossPointArray;

			UsePoint[0] = vcpTarPlatPos[0+m_iMarkNum/2].GetAuxPos(0);
			UsePoint[1] = vcpTarPlatPos[1+m_iMarkNum/2].GetAuxPos(0);
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			UsePoint[2] = vcpTarPlatPos[1+m_iMarkNum/2].GetAuxPos(1);
			UsePoint[3] = vcpTarPlatPos[3+m_iMarkNum/2].GetAuxPos(1);
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			UsePoint[4] = vcpTarPlatPos[2+m_iMarkNum/2].GetAuxPos(0);
			UsePoint[5] = vcpTarPlatPos[3+m_iMarkNum/2].GetAuxPos(0);
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

			UsePoint[6] = vcpTarPlatPos[0+m_iMarkNum/2].GetAuxPos(1);
			UsePoint[7] = vcpTarPlatPos[2+m_iMarkNum/2].GetAuxPos(1);
			ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

			if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpTarPlatPos[0+m_iMarkNum/2].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[0+m_iMarkNum/2].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{

				vcpTarPlatPos[1+m_iMarkNum/2].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[1+m_iMarkNum/2].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpTarPlatPos[2+m_iMarkNum/2].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[2+m_iMarkNum/2].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{

				vcpTarPlatPos[3+m_iMarkNum/2].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[3+m_iMarkNum/2].m_dPosY = crossPointArray.at(0).GetY();
			}

			for (k=m_iMarkNum/2;k<m_iMarkNum;k++)
			{

				str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,vcpTarPlatPos[k].GetPosX(),vcpTarPlatPos[k].GetPosY());
				AlignToolLogRecord(str,nPlatformIndex);
			}
			for (k=m_iMarkNum/2;k<m_iMarkNum;k++)
			{
				double ddx = tmpPos[k-m_iMarkNum/2].GetPosX() - vcpTarPlatPos[k].GetPosX();
				double ddy = tmpPos[k-m_iMarkNum/2].GetPosY() - vcpTarPlatPos[k].GetPosY();
				str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
				AlignToolLogRecord(str,nPlatformIndex);
			}
		}
		else if (((m_bTargetObjectCamSeparate && m_iMarkNum == 4)||(FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 2))
			&& (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12 || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V))
		{
			int nIndexOffset = (m_bTargetObjectCamSeparate && m_iMarkNum == 4) ? 2 : 0;

			CCoordPos tmpPos[2];
			int k = 0;
			for (k=0;k<2;k++)
			{
				tmpPos[k] = vcpTarPlatPos.at(k+nIndexOffset);
				str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k+nIndexOffset,vcpTarPlatPos.at(k+nIndexOffset).m_dPosX, vcpTarPlatPos.at(k+nIndexOffset).m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
			}

			CCoordPos ResultPos[3];
			scLine ResultLine[3];
			sc2Vector UsePoint[6];
			bool bIntersect;
			std::vector<sc2Vector> crossPointArray;

			// 判断公共边是水平边还是垂直边
			scLine tpmLine = scLineSeg(vcpTarPlatPos.at(0+nIndexOffset).GetPos(), vcpTarPlatPos.at(1+nIndexOffset).GetPos()).GetLine();
			double tmpAngle = scDegree(tpmLine.GetRotation().SignedNormMod180()).ToDouble();
			BOOL bHorDirection = (fabs(tmpAngle) < 45) ? TRUE : FALSE;
			str.Format("修正前目标角点连线角度[-90,90): %f ,直线是否水平线: %d", tmpAngle, bHorDirection);
			AlignToolLogRecord(str,nPlatformIndex);

			if (bHorDirection == TRUE)
			{
				// 直线0：公共边上的点组合构成
				UsePoint[0].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
				UsePoint[0].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
				UsePoint[1].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
				UsePoint[1].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
				ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

				// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
				UsePoint[2].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
				UsePoint[2].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
				{
					UsePoint[3].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetPosX());
					UsePoint[3].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetPosY());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
				{
					UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
				}
				ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

				// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
				UsePoint[4].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
				UsePoint[4].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
				{
					UsePoint[5].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetPosX());
					UsePoint[5].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetPosY());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
				{
					UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
				}
				ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
			}
			else
			{
				// 直线0：公共边上的点组合构成
				UsePoint[0].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(1));
				UsePoint[0].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(1));
				UsePoint[1].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(1));
				UsePoint[1].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(1));
				ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

				// 直线1：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
				UsePoint[2].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosX(0));
				UsePoint[2].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetAuxiliaryPosY(0));
				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
				{
					UsePoint[3].SetX(vcpTarPlatPos.at(0+nIndexOffset).GetPosX());
					UsePoint[3].SetY(vcpTarPlatPos.at(0+nIndexOffset).GetPosY());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
				{
					UsePoint[3] = ResultLine[0].Project(UsePoint[2]); // 计算给定点p在当前直线上的投影点
				}
				ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

				// 直线2：垂直边上的点与角点连线，或经过垂直边上的点向公共直线做垂线
				UsePoint[4].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosX(0));
				UsePoint[4].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetAuxiliaryPosY(0));
				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12)
				{
					UsePoint[5].SetX(vcpTarPlatPos.at(1+nIndexOffset).GetPosX());
					UsePoint[5].SetY(vcpTarPlatPos.at(1+nIndexOffset).GetPosY());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
				{
					UsePoint[5] = ResultLine[0].Project(UsePoint[4]); // 计算给定点p在当前直线上的投影点
				}
				ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
			}

			// 直线0和1交点，覆盖点0
			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpTarPlatPos.at(0+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos.at(0+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
			}

			// 直线0和2交点，覆盖点1
			if (sfInterSectLineLine(ResultLine[0], ResultLine[2], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
				vcpTarPlatPos.at(1+nIndexOffset).m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos.at(1+nIndexOffset).m_dPosY = crossPointArray.at(0).GetY();
			}

			for (k=0;k<2;k++)
			{
				str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k+nIndexOffset,vcpTarPlatPos.at(k+nIndexOffset).m_dPosX, vcpTarPlatPos.at(k+nIndexOffset).m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
			}
			for (k=0;k<2;k++)
			{
				double ddx = tmpPos[k].GetPosX() - vcpTarPlatPos.at(k+nIndexOffset).GetPosX();
				double ddy = tmpPos[k].GetPosY() - vcpTarPlatPos.at(k+nIndexOffset).GetPosY();
				str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k+nIndexOffset,ddx,ddy);
				AlignToolLogRecord(str,nPlatformIndex);
			}
		}
	}

	//lzk  0407 易天覆膜机-位置虚拟-目标对位
	if ((m_bTargetObjectCamSeparate && m_iMarkNum == 8) && m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode && m_bEnableTargetAndObjectPositionVirtualMode)
	{
		str.Format("---开始根据目标产品尺寸计算虚拟对位点---");
		AlignToolLogRecord(str,nPlatformIndex);
		{
			//根据目标产品尺寸和目标56/78平台坐标虚拟目标78/56平台坐标 
			if ((m_AlignermentParam.GetProductSizeInfo().m_dTargetL2 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dTargetW2 <= 0))
			{

				str.Format("目标尺寸信息错误:TargetL2=%f,TargetW2=%f",m_AlignermentParam.GetProductSizeInfo().m_dTargetL2,m_AlignermentParam.GetProductSizeInfo().m_dTargetW2);
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
				AlignToolLogRecord(str,nPlatformIndex);

				return FALSE;
			}

			str.Format("目标尺寸信息:TargetL2=%f,TargetW2=%f",m_AlignermentParam.GetProductSizeInfo().m_dTargetL2,m_AlignermentParam.GetProductSizeInfo().m_dTargetW2);
			AlignToolLogRecord(str,nPlatformIndex);

			// 目标位置虚拟模式:56拍照78虚拟	
			if (m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 0)
			{
				//	5   6
				// (7) (8)
				sc2Vector ptTarget5 = vcpTarPlatPos[4].GetPos();
				sc2Vector ptTarget6 = vcpTarPlatPos[5].GetPos();
				double dXLength = (ptTarget6 - ptTarget5).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
				scRadian xRot;
				(ptTarget6 - ptTarget5).Angle(xRot);
				xRot = xRot.SignedNormMod180();

				str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));

				ptTarget5 = affrect.GetCornerPo();
				ptTarget6 = affrect.GetCornerPx();
				sc2Vector ptTarget7 = affrect.GetCornerPy();
				sc2Vector ptTarget8 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				vcpTarPlatPos[6].SetPos(ptTarget7);
				vcpTarPlatPos[7].SetPos(ptTarget8);

			}
			// 目标位置虚拟模式:78拍照56虚拟	
			else if(m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 1)
			{
				// (5) (6)
				//  7   8
				sc2Vector ptTarget7 = vcpTarPlatPos[6].GetPos();
				sc2Vector ptTarget8 = vcpTarPlatPos[7].GetPos();;
				double dXLength = (ptTarget8 - ptTarget7).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
				scRadian xRot;
				(ptTarget8 - ptTarget7).Angle(xRot);
				xRot = xRot.SignedNormMod180();

				str.Format("目标78坐标:7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标78连线角度:78Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget7, dXLength, dYLength, xRot, scRadian(skPI));

				ptTarget7 = affrect.GetCornerPo();
				ptTarget8 = affrect.GetCornerPx();
				sc2Vector ptTarget5 = affrect.GetCornerPy();
				sc2Vector ptTarget6 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				vcpTarPlatPos[4].SetPos(ptTarget5);
				vcpTarPlatPos[5].SetPos(ptTarget6);


			}
			// 目标位置虚拟模式:57拍照68虚拟	
			else if(m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 2)
			{
				//	5  (6)
				//  7 （8）
				sc2Vector ptTarget5 = vcpTarPlatPos[4].GetPos();
				sc2Vector ptTarget7 = vcpTarPlatPos[6].GetPos();
				double dYLength = (ptTarget7 - ptTarget5).Length();
				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
				scRadian xRot;
				(ptTarget7 - ptTarget5).Angle(xRot);
				xRot = xRot.NormMod180();

				str.Format("目标57坐标:5X=%f,5Y=%f,7X=%f,7Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget7.GetX(),ptTarget7.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标57连线角度:57Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dYLength, dXLength, xRot, scRadian(skPI));

				ptTarget5 = affrect.GetCornerPo();
				ptTarget7 = affrect.GetCornerPx();
				sc2Vector ptTarget6 = affrect.GetCornerPy();
				sc2Vector ptTarget8 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				vcpTarPlatPos[5].SetPos(ptTarget6);
				vcpTarPlatPos[7].SetPos(ptTarget8);

			}
			// 目标位置虚拟模式:68拍照57虚拟	
			else if(m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode == 3)
			{
				//  （5）  6
				//  （7）  8
				sc2Vector ptTarget6 = vcpTarPlatPos[5].GetPos();
				sc2Vector ptTarget8 = vcpTarPlatPos[7].GetPos();
				double dYLength = (ptTarget8 - ptTarget6).Length();
				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
				scRadian xRot;
				(ptTarget8 - ptTarget6).Angle(xRot);
				xRot = xRot.NormMod180();

				str.Format("目标68坐标:6X=%f,6Y=%f,8X=%f,8Y=%f",ptTarget6.GetX(),ptTarget6.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标68连线角度:68Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget6, dYLength, dXLength, xRot, scRadian(0));

				ptTarget6 = affrect.GetCornerPo();
				ptTarget8 = affrect.GetCornerPx();
				sc2Vector ptTarget5 = affrect.GetCornerPy();
				sc2Vector ptTarget7 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				vcpTarPlatPos[4].SetPos(ptTarget5);
				vcpTarPlatPos[6].SetPos(ptTarget7);

			}
			// 目标位置虚拟模式:56拍照78虚拟	
			else
			{
				//	5   6
				// (7) (8)
				sc2Vector ptTarget5 = vcpTarPlatPos[4].GetPos();
				sc2Vector ptTarget6 = vcpTarPlatPos[5].GetPos();
				double dXLength = (ptTarget6 - ptTarget5).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
				scRadian xRot;
				(ptTarget6 - ptTarget5).Angle(xRot);
				xRot = xRot.SignedNormMod180();

				str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));

				ptTarget5 = affrect.GetCornerPo();
				ptTarget6 = affrect.GetCornerPx();
				sc2Vector ptTarget7 = affrect.GetCornerPy();
				sc2Vector ptTarget8 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				vcpTarPlatPos[6].SetPos(ptTarget7);
				vcpTarPlatPos[7].SetPos(ptTarget8);

			}

			str.Format("---结束根据目标产品尺寸计算虚拟对位点---");
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}

	if (m_bTargetObjectCamSeparate)
	{
		m_PlatformOffset.m_dPosX  = 0;		
		m_PlatformOffset.m_dPosY  = 0;
		m_PlatformOffset.m_dAngle = 0;

		m_ProductOffset.m_dPosX  = 0;		
		m_ProductOffset.m_dPosY  = 0;
		m_ProductOffset.m_dAngle = 0;

		m_ProductOffsetXYPD.m_dPosX  = 0;		
		m_ProductOffsetXYPD.m_dPosY  = 0;
		m_ProductOffsetXYPD.m_dAngle = 0;

		int nPosNum = m_iMarkNum/2;							// 实际对位的位置数量
		std::vector<CCoordPos> vcpObjectPlatformPos;		// 对象位置
		std::vector<CCoordPos> vcpTargetPlatformPos;		// 目标位置
		std::vector<CCoordPos> vcpAlginedObjectPlatformPos; // 对位后对象位置
		std::vector<CCoordPos> vcpAlginedTargetPlatformPos; // 对位后目标位置
		for (int nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
		{
			// 对象位置
			CCoordPos cpObjectPlatformPos;

			cpObjectPlatformPos = vcpObjPlatPos[nPosIndex];

			vcpObjectPlatformPos.push_back(cpObjectPlatformPos);


			// 目标位置
			CCoordPos cpTargetPlatformPos;
			if (m_bInnerAlignBench)
			{	
				cpTargetPlatformPos = vcpTarPlatPos[nPosIndex];
			}
			else
			{
				cpTargetPlatformPos = vcpTarPlatPos[nPosNum + nPosIndex];
			}

			vcpTargetPlatformPos.push_back(cpTargetPlatformPos);
		}
		vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
		vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;

		/////方式1
		if (GetMidPlatformType()==ePlatformXYPD)
		{
			std::vector<CCoordPos> vcpPreTargetPlatformPos;		// 上一次目标位置旋转后新的目标位置
			if (1)
			{
				vcpPreTargetPlatformPos = vcpAlginedTargetPlatformPos;
			}
			else
			{
				for (int j=0;j<nPosNum;j++)
				{
					CCoordPos pos;
					pos.m_dPosX = m_dTargetX[j];
					pos.m_dPosY = m_dTargetY[j];

					vcpPreTargetPlatformPos.push_back(pos);
				}
			}
			CCoordPos tempplatformOffset;

			// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
			if (!GetAlginOffset(vcpObjectPlatformPos, vcpPreTargetPlatformPos, m_ProductOffsetXYPD, tempplatformOffset, 
				vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
			{
				str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(失败)");
				AlignToolLogRecord(str,nPlatformIndex);
				return FALSE;
			}

			str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(成功)");
			AlignToolLogRecord(str,nPlatformIndex);
		}

		// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
		if (!GetAlginOffset(vcpObjectPlatformPos, vcpTargetPlatformPos, m_ProductOffset, m_PlatformOffset, 
			vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
		{
			str.Format("------------------------------------------------------------计算目标固定补偿(失败)");
			AlignToolLogRecord(str,nPlatformIndex);
			return FALSE;
		}

		// 获取产品位置（旋转中心）和角度

		sc2Vector vTargetPos;
		sc2Vector vObjectPos;	
		sc2Vector vFixedTargetPos;
		std::vector<sc2Vector> vTransferTarPos;
		std::vector<sc2Vector> vTransferObjPos;
		for (int i=0;i<m_iMarkNum/2;i++)
		{
			vObjectPos.SetX(vcpObjPlatPos.at(i).m_dPosX);
			vObjectPos.SetY(vcpObjPlatPos.at(i).m_dPosY);
			vTransferObjPos.push_back(vObjectPos);
		}
		for (int i=m_iMarkNum/2;i<m_iMarkNum && i<vcpTarPlatPos.size();i++)
		{
			vTargetPos.SetX(vcpTarPlatPos.at(i).m_dPosX);
			vTargetPos.SetY(vcpTarPlatPos.at(i).m_dPosY);
			vFixedTargetPos = vfGetTransformRotateShiftPoint(vTargetPos, scDegree(-m_ProductOffset.m_dAngle), 0,0);
			vTransferTarPos.push_back(vFixedTargetPos);
		}

		double objX =0;
		double objY =0;
		double tarX = 0;
		double tarY=0;
		for (int i=0;i<vTransferObjPos.size()&&i<vTransferTarPos.size();i++)
		{
			objX = objX + vTransferObjPos.at(i).GetX();
			objY = objY + vTransferObjPos.at(i).GetY();
			tarX = tarX + vTransferTarPos.at(i).GetX();
			tarY = tarY + vTransferTarPos.at(i).GetY();
		}
		objX = objX/vTransferObjPos.size();
		objY = objY/vTransferObjPos.size();
		tarX = tarX/vTransferTarPos.size();
		tarY = tarY/vTransferTarPos.size();

		offset.m_dPosX = objX - tarX;
		offset.m_dPosY = objY - tarY;
		offset.m_dAngle = -m_ProductOffset.m_dAngle;

		str.Format("目标固定补偿:X=%f,Y=%f,D=%f", offset.m_dPosX, offset.m_dPosY, offset.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("------------------------------------------------------------（产品）计算目标固定补偿（成功）");
		AlignToolLogRecord(str,nPlatformIndex);


		return TRUE;
	}

	return FALSE;
}

// 当目标和对象不在同一个平面时，对位偏差计算：成功，返回TRUE；否则，返回FALSE（补偿相机及旋转中心变化量，计算各轴移动偏移量）
BOOL vcBaseAlignTool::ExecuteAlignExHLLayer(int nAlnIndex, std::vector<CCoordPos> vcpCurCrossPos)
{
// 	if (m_bTargetObjectCamSeparate)
// 	{
// 		return ExecuteAlignEx();
// 	}

	//加各种保护
	if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK())
	{
		return FALSE;
	}
	if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK())
	{
		return FALSE;
	}

// 	if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable()&&FALSE == m_VirtualSearchResults.IsAllMarkImagePosOK())
// 	{
// 		return FALSE;
// 	}
	if (m_AlignermentParam.m_bCheckAlnTargetOffsetEnable && !m_bInnerAlignBench)
	{
		nAlnIndex=1; //使用多次对位偏移模式时，始终用胶框目标位置对位
	}
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("对位计算开始:序号[%d]------------------------------------------------------------",nAlnIndex);
	AlignToolLogRecord(str,nPlatformIndex);
	//目标mark坐标补偿时用到这些参数
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
    std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;
	
	int k=0;
	for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
	{
		pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置
		str.Format("搜索对象mark%d 轴位置 X=%f,Y=%f,D=%f",k,pObjectPlatformAxisPos.at(k)->m_dPosX,pObjectPlatformAxisPos.at(k)->m_dPosY,pObjectPlatformAxisPos.at(k)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
	}
	std::vector<CPlatformXYDAxisPos*> pTargetPlatformAxisPos;
	for (k=0;k<m_pTargetPlatformAxisPos.size();k++)
	{
		pTargetPlatformAxisPos.push_back((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k));//搜索目标mark轴位置
		str.Format("搜索目标mark%d 轴位置 X=%f,Y=%f,D=%f",k,pTargetPlatformAxisPos.at(k)->m_dPosX,pTargetPlatformAxisPos.at(k)->m_dPosY,pTargetPlatformAxisPos.at(k)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
	}
	if(pTargetPlatformAxisPos.size()<m_iMarkNum)
	{
		pTargetPlatformAxisPos.resize(m_iMarkNum);

	}

	std::vector<CCoordPos> vcpObjPlatPos;		// 对象位置
	std::vector<CCoordPos> vcpTarPlatPos;		// 目标位置

	vcpObjPlatPos.resize(6);
	vcpTarPlatPos.resize(6);

// 	double dObjectX[6];			//存储对象mark图像坐标
// 	double dObjectY[6];
// 	double dObjectD[6];
// 	double dTargetX[6];			//存储目标mark图像坐标
// 	double dTargetY[6];
// 	double dTargetD[6];
// 
// 
// 	double dAuxiliaryObjectX0[6];			//存储对象辅助mark图像坐标0
// 	double dAuxiliaryObjectY0[6];
// 	double dAuxiliaryObjectD0[6];
// 	double dAuxiliaryObjectX1[6];			//存储对象辅助mark图像坐标1
// 	double dAuxiliaryObjectY1[6];
// 	double dAuxiliaryObjectD1[6];
// 	double dAuxiliaryObjectX2[8];			//存储对象辅助mark图像坐标1
// 	double dAuxiliaryObjectY2[8];
// 	double dAuxiliaryObjectD2[8];
// 
// 
// 	double dAuxiliaryTargetX0[6];			//存储目标辅助mark图像坐标0
// 	double dAuxiliaryTargetY0[6];
// 	double dAuxiliaryTargetD0[6];
// 	double dAuxiliaryTargetX1[6];			//存储目标辅助mark图像坐标1
// 	double dAuxiliaryTargetY1[6];
// 	double dAuxiliaryTargetD1[6];
// 	double dAuxiliaryTargetX2[8];			//存储目标辅助mark图像坐标1
// 	double dAuxiliaryTargetY2[8];
// 	double dAuxiliaryTargetD2[8];


	double dObjectXforCam0[6];		//*计算相机平台移动量*1存储相机检测的实时对象mark图像坐标
	double dObjectYforCam0[6];		
	double dObjectXforCam1[6];		//*计算相机平台移动量*2存储平台移动后的检测的实时对象mark图像坐标
	double dObjectYforCam1[6];	

	double dPltfmXforCam[6];		//*计算相机平台移动量*3根据前面两组数据计算平台各轴移动量
	double dPltfmYforCam[6];
	double dCameraPltfmX[6];		//*计算相机平台移动量*4转化为相机各轴移动量
	double dCameraPltfmY[6];

// 	memset(dObjectX, 0.0, sizeof(double)*6);
// 	memset(dObjectY, 0.0, sizeof(double)*6);
// 	memset(dObjectD, 0.0, sizeof(double)*6);
// 	memset(dTargetX, 0.0, sizeof(double)*6);
// 	memset(dTargetY, 0.0, sizeof(double)*6);
// 	memset(dTargetD, 0.0, sizeof(double)*6);
// 
// 
// 	memset(dAuxiliaryObjectX0, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryObjectY0, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryObjectD0, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryObjectX1, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryObjectY1, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryObjectD1, 0.0, sizeof(double)*6);
// 
// 	memset(dAuxiliaryTargetX0, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryTargetY0, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryTargetD0, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryTargetX1, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryTargetY1, 0.0, sizeof(double)*6);
// 	memset(dAuxiliaryTargetD1, 0.0, sizeof(double)*6);

	memset(dObjectXforCam0, 0.0, sizeof(double)*6);
	memset(dObjectYforCam0, 0.0, sizeof(double)*6);
	memset(dObjectXforCam1, 0.0, sizeof(double)*6);
	memset(dObjectYforCam1, 0.0, sizeof(double)*6);
	
	memset(dPltfmXforCam, 0.0, sizeof(double)*6);
	memset(dPltfmYforCam, 0.0, sizeof(double)*6);
	memset(dCameraPltfmX, 0.0, sizeof(double)*6);
	memset(dCameraPltfmY, 0.0, sizeof(double)*6);

	// $1、实时对象Mark的图像坐标值转化为平台坐标值
		
	// $1.1 将实时对象Mark的图像坐标值转换为实时对象Mark搜索时的全局平台坐标值
	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPos();

	if (FALSE == m_ObjectMarkPlatformPos.IsAllMarkPlatformPosOK())
	{
		return FALSE;
	}

	CMarkPlatformPos ObjectHoleMarkPlatformPos;
	ObjectHoleMarkPlatformPos.SetMarkPlatformPosNum(m_iMarkNum);

	int i=0;

	//读取每个相机对应的对象mark和平台mark的坐标值
	for (i=0; i<m_iMarkNum; i++)
	{
		//记录相机对象mark的坐标
		vcpObjPlatPos[i] = m_ObjectMarkPlatformPos.m_vPos[i];

// 		dObjectX[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX;
// 		dObjectY[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY;
// 		dObjectD[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle;
// 
// 		// 辅助位置
// 		if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 		{
// 			dAuxiliaryObjectX0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// 			dAuxiliaryObjectY0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// 			dAuxiliaryObjectD0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
// 			dAuxiliaryObjectX1[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// 			dAuxiliaryObjectY1[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// 			dAuxiliaryObjectD1[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
// 		}
// 	
// 		if (/*m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_C5 ||*/ 
// 			m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_Weight || 
// 			m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight)
// 		{
// 			dAuxiliaryObjectX0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// 			dAuxiliaryObjectY0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// 			dAuxiliaryObjectD0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
// 
// 			dAuxiliaryObjectX1[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// 			dAuxiliaryObjectY1[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// 			dAuxiliaryObjectD1[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
// 
// 			dAuxiliaryObjectX2[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(2);
// 			dAuxiliaryObjectY2[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(2);
// 			dAuxiliaryObjectD2[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(2);
// 		}
		//*计算相机平台移动量*1存储相机检测的对象mark图像坐标
		dObjectXforCam0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX;
		dObjectYforCam0[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY;
		
		str.Format("对象图像坐标%d:ObjectImageX=%f,ObjectImageY=%f,ObjectImageD=%f",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
// 		str.Format("对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,dObjectX[i],dObjectY[i],dObjectD[i]);
// 		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);
		
		// $1.2 实时对象为虚拟Mark，则将实时对象Mark的平台坐标值转换为虚拟Mark的平台坐标值
		if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
		{
			if (FALSE == ConvertObjectPltfmPtToVirtualPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos))
				return FALSE;

			vcpObjPlatPos[i] = m_VirtualMarkPlatformPos.m_vPos[i];

// 			dObjectX[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_dPosX;
// 			dObjectY[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_dPosY;
// 			dObjectD[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_dAngle;
// 
// 			// 辅助位置
// 			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 			{
// 				dAuxiliaryObjectX0[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// 				dAuxiliaryObjectY0[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// 				dAuxiliaryObjectD0[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
// 				dAuxiliaryObjectX1[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// 				dAuxiliaryObjectY1[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// 				dAuxiliaryObjectD1[i] = m_VirtualMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
// 			}
// 
// 			str.Format("虚拟对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,dObjectX[i],dObjectY[i],dObjectD[i]);
// 			AlignToolLogRecord(str,nPlatformIndex);

			str.Format("虚拟对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		if (!m_bInnerAlignBench && (nAlnIndex != 0))
		{
			// $1.3 对象Mark的全局平台坐标值补偿
			//当不需要基准修正时，考虑要不要对对象mark进行补偿

			CMarkPlatformPos m_ObjectAddRotationOffsetPos;
			m_ObjectAddRotationOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddRotationOffsetPos.m_vbOK.resize(m_iMarkNum);
			CMarkPlatformPos m_ObjectAddMoveOffsetPos;
			m_ObjectAddMoveOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddMoveOffsetPos.m_vbOK.resize(m_iMarkNum);

			if (eMarkCoord == m_AlignermentParam.GetAlignerOffsetCoordType())// Mark坐标系下补偿
			{
				// Mark坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
				{
					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
						MarkCoordOffsetRotationObjectPlatformPos(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
					else
						MarkCoordOffsetRotationObjectPlatformPos(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);

					// Mark坐标系下XY轴平移量进行补偿
					MarkCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];

// 					dObjectX[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosX;
// 					dObjectY[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosY;
// 					dObjectD[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dAngle;
// 
// 					// 辅助位置
// 					if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 					{
// 						dAuxiliaryObjectX0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// 						dAuxiliaryObjectY0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// 						dAuxiliaryObjectD0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
// 						dAuxiliaryObjectX1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// 						dAuxiliaryObjectY1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// 						dAuxiliaryObjectD1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
// 					}
// 
// 					if (/*m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_C5 ||*/ 
// 						m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_Weight 
// 						|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight)
// 					{
// 						dAuxiliaryObjectX0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// 						dAuxiliaryObjectY0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// 						dAuxiliaryObjectD0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
// 
// 						dAuxiliaryObjectX1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// 						dAuxiliaryObjectY1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// 						dAuxiliaryObjectD1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
// 
// 						dAuxiliaryObjectX2[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(2);
// 						dAuxiliaryObjectY2[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(2);
// 						dAuxiliaryObjectD2[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(2);
// 					}

				}
			}
			else if (eMarkCoordDiagonal == m_AlignermentParam.GetAlignerOffsetCoordType())// 对角Mark坐标系下补偿		//20160510增加对角补偿
			{
				if ( (m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0) 
					|| (m_AlignermentParam.GetProductSizeInfo().m_dTargetL2 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dTargetW2 <= 0) )
				{
					str.Format("对角补偿对象平台坐标%d错误:ObjectL1=%f,ObjectW1=%f,TargetL2=%f,TargetW2=%f",i,
						m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1,
						m_AlignermentParam.GetProductSizeInfo().m_dTargetL2,m_AlignermentParam.GetProductSizeInfo().m_dTargetW2);
					AlignToolLogRecord(str,nPlatformIndex);
					return FALSE;
				}

				if ( (m_AlignermentParam.GetPositionModeInfo() < 0) || (m_AlignermentParam.GetPositionModeInfo() > 1) )
				{
					str.Format("对角补偿对象平台坐标%d错误:PositionMode=%d",i,m_AlignermentParam.GetPositionModeInfo());
					AlignToolLogRecord(str,nPlatformIndex);
					return FALSE;
				}

				// 对角Mark坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
				{
					scDegree degRotate1 = scDegree(0);
					scDegree degRotate2 = scDegree(m_AlignermentParam.GetAlignerOffset().GetAngle()+m_AlignermentParam.GetAlignerBaseOffset().GetAngle());

					// 旋转角度
					if (m_AlignermentParam.GetProductOffsetInfo().m_bEnableProductOffsetDDirection)
					{
						degRotate2 = -degRotate2;
					}

					if (!AngleOffsetCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
						m_AlignermentParam.GetProductSizeInfo().m_dTargetL2, m_AlignermentParam.GetProductSizeInfo().m_dTargetW2,
						m_AlignermentParam.GetPositionModeInfo(), degRotate1))
					{
						return FALSE;
					}
					scDegree degRotate = degRotate1 + degRotate2;

					std::vector<CCoordPos> vObjectPlatformCoordPosDirection;

					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
					{
						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
						vObjectPlatformCoordPosDirection = m_VirtualMarkPlatformPos.m_vPos;
					}
					else
					{
						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
						vObjectPlatformCoordPosDirection = m_ObjectMarkPlatformPos.m_vPos;
					}

					// 对角Mark坐标系下XY轴平移量进行补偿
					sc2Vector offsetXY = sc2Vector(m_AlignermentParam.GetAlignerOffset().GetPosX()+m_AlignermentParam.GetAlignerBaseOffset().GetPosX(),	m_AlignermentParam.GetAlignerOffset().GetPosY()+m_AlignermentParam.GetAlignerBaseOffset().GetPosY());

					// 方向X
					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXDirection)
					{
						offsetXY = sc2Vector(-offsetXY.GetX(), offsetXY.GetY());
					}

					// 方向Y
					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYDirection)
					{
						offsetXY = sc2Vector(offsetXY.GetX(), -offsetXY.GetY());
					}

					// X补偿与Y补偿对调
					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXSetting/* || m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYSetting*/)
					{
						offsetXY = sc2Vector(offsetXY.GetY(), offsetXY.GetX());
					}

					if (m_AlignermentParam.GetProductSizeInfo().m_bOffsetXYEnable)
					{
						double dOffsetX = 0, dOffsetY = 0;
						if (!XYOffsetCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
							m_AlignermentParam.GetProductSizeInfo().m_dTargetL2, m_AlignermentParam.GetProductSizeInfo().m_dTargetW2,
							m_AlignermentParam.GetProductSizeInfo().m_dF1, m_AlignermentParam.GetProductSizeInfo().m_dF2,
							m_AlignermentParam.GetPositionModeInfo(), dOffsetX, dOffsetY))
						{
							return FALSE;
						}
						offsetXY += sc2Vector(dOffsetX, dOffsetY);
					}
					MarkCoordDiagonalOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, vObjectPlatformCoordPosDirection, offsetXY, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
					
// 					dObjectX[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosX;
// 					dObjectY[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosY;
// 					dObjectD[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dAngle;
				}

				// 辅助位置
				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
				{
					return FALSE;
				}
			}
			else if (eMarkCoordDiagonal2 == m_AlignermentParam.GetAlignerOffsetCoordType())// 对角Mark坐标系下补偿		//20160510增加对角补偿
			{
				if ( (m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0) 
					|| (m_AlignermentParam.GetProductSizeInfo().m_dTargetL2 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dTargetW2 <= 0) )
				{
					str.Format("对角补偿对象平台坐标%d错误:ObjectL1=%f,ObjectW1=%f,TargetL2=%f,TargetW2=%f",i,
						m_AlignermentParam.GetProductSizeInfo().m_dObjectL1,m_AlignermentParam.GetProductSizeInfo().m_dObjectW1,
						m_AlignermentParam.GetProductSizeInfo().m_dTargetL2,m_AlignermentParam.GetProductSizeInfo().m_dTargetW2);
					AlignToolLogRecord(str,nPlatformIndex);
					return FALSE;
				}

				if ( (m_AlignermentParam.GetPositionModeInfo() < 0) || (m_AlignermentParam.GetPositionModeInfo() > 1) )
				{
					str.Format("对角补偿对象平台坐标%d错误:PositionMode=%d",i,m_AlignermentParam.GetPositionModeInfo());
					AlignToolLogRecord(str,nPlatformIndex);
					return FALSE;
				}

				// 对角Mark坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
				{
					scDegree degRotate1 = scDegree(0);
					scDegree degRotate2 = scDegree(m_AlignermentParam.GetAlignerOffset().GetAngle()+m_AlignermentParam.GetAlignerBaseOffset().GetAngle());

					// 旋转角度
					if (m_AlignermentParam.GetProductOffsetInfo().m_bEnableProductOffsetDDirection)
					{
						degRotate2 = -degRotate2;
					}

					if (!AngleOffsetCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
						m_AlignermentParam.GetProductSizeInfo().m_dTargetL2, m_AlignermentParam.GetProductSizeInfo().m_dTargetW2,
						m_AlignermentParam.GetPositionModeInfo(), degRotate1))
					{
						return FALSE;
					}
					scDegree degRotate = degRotate1 + degRotate2;

					std::vector<CCoordPos> vObjectPlatformCoordPosDirection;

					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
					{
						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
						vObjectPlatformCoordPosDirection = m_VirtualMarkPlatformPos.m_vPos;
						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate2, m_VirtualMarkPlatformPos.m_vPos, vObjectPlatformCoordPosDirection);
					}
					else
					{
						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
						vObjectPlatformCoordPosDirection = m_ObjectMarkPlatformPos.m_vPos;
						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate2, m_ObjectMarkPlatformPos.m_vPos, vObjectPlatformCoordPosDirection);
					}

					// 对角Mark坐标系下XY轴平移量进行补偿
					sc2Vector offsetXY = sc2Vector(m_AlignermentParam.GetAlignerOffset().GetPosX()+m_AlignermentParam.GetAlignerBaseOffset().GetPosX(),	m_AlignermentParam.GetAlignerOffset().GetPosY()+m_AlignermentParam.GetAlignerBaseOffset().GetPosY());

					// 方向X
					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXDirection)
					{
						offsetXY = sc2Vector(-offsetXY.GetX(), offsetXY.GetY());
					}

					// 方向Y
					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYDirection)
					{
						offsetXY = sc2Vector(offsetXY.GetX(), -offsetXY.GetY());
					}

					// X补偿与Y补偿对调
					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXSetting/* || m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYSetting*/)
					{
						offsetXY = sc2Vector(offsetXY.GetY(), offsetXY.GetX());
					}

					if (m_AlignermentParam.GetProductSizeInfo().m_bOffsetXYEnable)
					{
						double dOffsetX = 0, dOffsetY = 0;
						if (!XYOffsetCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
							m_AlignermentParam.GetProductSizeInfo().m_dTargetL2, m_AlignermentParam.GetProductSizeInfo().m_dTargetW2,
							m_AlignermentParam.GetProductSizeInfo().m_dF1, m_AlignermentParam.GetProductSizeInfo().m_dF2,
							m_AlignermentParam.GetPositionModeInfo(), dOffsetX, dOffsetY))
						{
							return FALSE;
						}
						offsetXY += sc2Vector(dOffsetX, dOffsetY);
					}
					MarkCoordDiagonalOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, vObjectPlatformCoordPosDirection, offsetXY, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];

					// 					dObjectX[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosX;
					// 					dObjectY[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosY;
					// 					dObjectD[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dAngle;
				}


				// 辅助位置
				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
				{
					return FALSE;
				}
			}
			else if (eMarkPlatformCoord == m_AlignermentParam.GetAlignerOffsetCoordType())// Mark平台混合坐标系下补偿
			{
				// 全局平台坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
				{			
					// 					// 全局平台坐标系下旋转角度进行补偿
					// 					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
					// 						PltfmCoordOffsetRotationObjectPltfmPt(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
					// 					else
					//						PltfmCoordOffsetRotationObjectPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);

					// Mark坐标系下旋转角度进行补偿
					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
						MarkCoordOffsetRotationObjectPlatformPos(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
					else
						MarkCoordOffsetRotationObjectPlatformPos(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);

					// 全局平台坐标系下XY轴平移量进行补偿
					PltfmCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];

					// 					dObjectX[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosX;
					// 					dObjectY[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosY;
					// 					dObjectD[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dAngle;
					// 
					// 					// 辅助位置
					// 					if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
					// 					{
					// 						dAuxiliaryObjectX0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
					// 						dAuxiliaryObjectY0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
					// 						dAuxiliaryObjectD0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
					// 						dAuxiliaryObjectX1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
					// 						dAuxiliaryObjectY1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
					// 						dAuxiliaryObjectD1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
					// 					}
				}
			}
			else// 平台坐标系下补偿
			{
				// 全局平台坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
				{			
					// 全局平台坐标系下旋转角度进行补偿
					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
						PltfmCoordOffsetRotationObjectPltfmPt(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
					else
						PltfmCoordOffsetRotationObjectPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);

					// 全局平台坐标系下XY轴平移量进行补偿
					PltfmCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];

					// 					dObjectX[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosX;
					// 					dObjectY[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosY;
					// 					dObjectD[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dAngle;
					// 
					// 					// 辅助位置
					// 					if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
					// 					{
					// 						dAuxiliaryObjectX0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
					// 						dAuxiliaryObjectY0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
					// 						dAuxiliaryObjectD0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
					// 						dAuxiliaryObjectX1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
					// 						dAuxiliaryObjectY1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
					// 						dAuxiliaryObjectD1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
					// 					}
				}
			}

			// 			str.Format("补偿后对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,dObjectX[i],dObjectY[i],dObjectD[i]);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			str.Format("补偿后对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}
		else
		{
			// $1.3 对象Mark的全局平台坐标值补偿
			//当不需要基准修正时，考虑要不要对对象mark进行补偿

			CMarkPlatformPos m_ObjectAddRotationOffsetPos;
			m_ObjectAddRotationOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddRotationOffsetPos.m_vbOK.resize(m_iMarkNum);
			CMarkPlatformPos m_ObjectAddMoveOffsetPos;
			m_ObjectAddMoveOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddMoveOffsetPos.m_vbOK.resize(m_iMarkNum);

			if (1/*eMarkCoord == m_AlignermentParam.GetAlignerOffsetCoordType()*/)// Mark坐标系下补偿
			{
				// Mark坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBenchOffset().GetAngle()||m_AlignermentParam.GetAlignerBenchOffset().GetPosX()||m_AlignermentParam.GetAlignerBenchOffset().GetPosY())
				{
					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
						MarkCoordOffsetRotationObjectPlatformPos(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
					else
						MarkCoordOffsetRotationObjectPlatformPos(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);

					// Mark坐标系下XY轴平移量进行补偿
					MarkCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];

					// 					dObjectX[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosX;
					// 					dObjectY[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dPosY;
					// 					dObjectD[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_dAngle;
					// 
					// 					// 辅助位置
					// 					if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
					// 						|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
					// 					{
					// 						dAuxiliaryObjectX0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
					// 						dAuxiliaryObjectY0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
					// 						dAuxiliaryObjectD0[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
					// 						dAuxiliaryObjectX1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
					// 						dAuxiliaryObjectY1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
					// 						dAuxiliaryObjectD1[i] = m_ObjectAddMoveOffsetPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
					// 					}

					// 					strTempInfo.Format("Mark补偿后对象mark%d平台坐标 X: %f ,Y: %f ,D: %f ,",i,dObjectX[i],dObjectY[i],dObjectD[i]);
					// 					strInfo += strTempInfo;
				}
			}
			// 			str.Format("补偿后对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,dObjectX[i],dObjectY[i],dObjectD[i]);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			str.Format("补偿后对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}


	}

		//读取每个相机对应的对象mark和平台mark的坐标值
	for (i=0; i<m_iMarkNum; i++)
	{
		// $2、实时目标Mark的图像坐标值转化为平台坐标值
		CCoordPos TargetPos;
		double H[9];
		//计算H矩阵
		{
			//1>首先获得标定时两个平面的图像坐标

			svStd vector<sc2Vector> TargetPoints; // 下面平面点
			TargetPoints.clear();
			svStd vector<sc2Vector> ObjectPoints;	//上面平面点
			ObjectPoints.clear();

			sc2Vector TargetPoint;
			sc2Vector ObjectPoint;


			for(int m=0;m<CALIBMOVEPOSNUM;m++)
			{
				if(m == 12)
				{
					continue;
				}
				TargetPoint.SetX(m_vAlignerCalibInfos.at(i)->m_cpTargetMarkImgCoordPos[m].m_dPosX);
				TargetPoint.SetY(m_vAlignerCalibInfos.at(i)->m_cpTargetMarkImgCoordPos[m].m_dPosY);
				ObjectPoint.SetX(m_vAlignerCalibInfos.at(i)->m_cpObjectMarkImgCoordPos[m].m_dPosX);
				ObjectPoint.SetY(m_vAlignerCalibInfos.at(i)->m_cpObjectMarkImgCoordPos[m].m_dPosY);

				TargetPoints.push_back(TargetPoint);
				ObjectPoints.push_back(ObjectPoint);
				str.Format("第%d个膜平面数据坐标:X%d:%f,Y%d:%f",m,m,ObjectPoint.GetX(),m,ObjectPoint.GetY());
				AlignToolLogRecord(str,i);
				str.Format("第%d个孔平面数据坐标:X%d:%f,Y%d:%f",m,m,TargetPoint.GetX(),m,TargetPoint.GetY());
				AlignToolLogRecord(str,i);

			}
			//2>计算孔平面图像坐标对应的膜平面的图像坐标
			if(!sfGetHomography(TargetPoints,ObjectPoints,H))
				return FALSE;
			str.Format("矩阵:%f,%f,%f,%f,%f,%f,%f,%f,%f",H[0],H[1],H[2],H[3],H[4],H[5],H[6],H[7],H[8]);
			AlignToolLogRecord(str,i);
		}
		//获得胶框的平台坐标=========================
		if (nAlnIndex == 0)//第一次对位使用十字标位置
		{	
			//=======================================================
			//第一次对位时计算胶框的平台坐标
			if (0)
			{

			}
			//====================================================================
			//十字标图像坐标
			if (m_iMarkNum != vcpCurCrossPos.size())
			{
				return FALSE;
			}
			sc2Vector CrossTargetPointImg;
			sc2Vector CrossObjectPointImg;		
			CrossTargetPointImg.SetX(vcpCurCrossPos.at(i).m_dPosX);
			CrossTargetPointImg.SetY(vcpCurCrossPos.at(i).m_dPosY);	

			CrossObjectPointImg = sfHomographyProject(CrossTargetPointImg,H);

			TargetPos.m_dPosX = CrossObjectPointImg.GetX();
			TargetPos.m_dPosY = CrossObjectPointImg.GetY();

			// 辅助位置
			for(int j = 0; j < vcpCurCrossPos.at(i).m_vdAuxiliaryPosX.size(); j++)
			{
				CrossTargetPointImg.SetX(vcpCurCrossPos.at(i).m_vdAuxiliaryPosX.at(j));
				CrossTargetPointImg.SetY(vcpCurCrossPos.at(i).m_vdAuxiliaryPosY.at(j));	

				CrossObjectPointImg = sfHomographyProject(CrossTargetPointImg,H);

				TargetPos.m_vdAuxiliaryPosX.at(j) = CrossObjectPointImg.GetX();
				TargetPos.m_vdAuxiliaryPosY.at(j) = CrossObjectPointImg.GetY();
			}

// 			// 辅助位置
// 			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 			{
// 				CrossTargetPointImg.SetX(vcpCurCrossPos.at(i).m_vdAuxiliaryPosX.at(0));
// 				CrossTargetPointImg.SetY(vcpCurCrossPos.at(i).m_vdAuxiliaryPosY.at(0));	
// 
// 				CrossObjectPointImg = sfHomographyProject(CrossTargetPointImg,H);
// 
// 				TargetPos.m_vdAuxiliaryPosX.at(0) = CrossObjectPointImg.GetX();
// 				TargetPos.m_vdAuxiliaryPosY.at(0) = CrossObjectPointImg.GetY();
// 
// 
// 				CrossTargetPointImg.SetX(vcpCurCrossPos.at(i).m_vdAuxiliaryPosX.at(1));
// 				CrossTargetPointImg.SetY(vcpCurCrossPos.at(i).m_vdAuxiliaryPosY.at(1));	
// 
// 				CrossObjectPointImg = sfHomographyProject(CrossTargetPointImg,H);
// 
// 				TargetPos.m_vdAuxiliaryPosX.at(1) = CrossObjectPointImg.GetX();
// 				TargetPos.m_vdAuxiliaryPosY.at(1) = CrossObjectPointImg.GetY();
// 			}

		}
		else//第二次对位使用胶框坐标
		{
			sc2Vector TargetPointImg;
			sc2Vector ObjectPointImg;

			TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_dPosX);
			TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_dPosY);

			ObjectPointImg = sfHomographyProject(TargetPointImg,H);

			TargetPos.m_dPosX = ObjectPointImg.GetX();
			TargetPos.m_dPosY = ObjectPointImg.GetY();

			// 辅助位置
			for(int j = 0; j < m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.size(); j++)
			{
				TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(j));
				TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(j));	

				ObjectPointImg = sfHomographyProject(TargetPointImg,H);

				TargetPos.m_vdAuxiliaryPosX.at(j) = ObjectPointImg.GetX();
				TargetPos.m_vdAuxiliaryPosY.at(j) = ObjectPointImg.GetY();
			}

// 			// 辅助位置
// 			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 			{
// 				TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(0));
// 				TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(0));	
// 
// 				ObjectPointImg = sfHomographyProject(TargetPointImg,H);
// 
// 				TargetPos.m_vdAuxiliaryPosX.at(0) = ObjectPointImg.GetX();
// 				TargetPos.m_vdAuxiliaryPosY.at(0) = ObjectPointImg.GetY();
// 
// 
// 				TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(1));
// 				TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(1));	
// 
// 				ObjectPointImg = sfHomographyProject(TargetPointImg,H);
// 
// 				TargetPos.m_vdAuxiliaryPosX.at(0) = ObjectPointImg.GetX();
// 				TargetPos.m_vdAuxiliaryPosY.at(0) = ObjectPointImg.GetY();
// 			}
// 
// 			/////////////////////////////////////////////////////////////////////////////////////////
// 			///////////////////////////bai////////////////////////////////////////////////////
// 			// 辅助位置
// 			if(m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
// 				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4 
// 				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4 
// 				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
// 				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_Weight 
// 				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight)
// 			{
// 				TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(0));
// 				TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(0));	
// 
// 				ObjectPointImg = sfHomographyProject(TargetPointImg,H);
// 
// 				TargetPos.m_vdAuxiliaryPosX.at(0) = ObjectPointImg.GetX();
// 				TargetPos.m_vdAuxiliaryPosY.at(0) = ObjectPointImg.GetY();
// 
// 
// 				TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(1));
// 				TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(1));	
// 
// 				ObjectPointImg = sfHomographyProject(TargetPointImg,H);
// 
// 				TargetPos.m_vdAuxiliaryPosX.at(1) = ObjectPointImg.GetX();
// 				TargetPos.m_vdAuxiliaryPosY.at(1) = ObjectPointImg.GetY();
// 
// 				TargetPointImg.SetX(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(2)); // circle
// 				TargetPointImg.SetY(m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(2));	
// 
// 				ObjectPointImg = sfHomographyProject(TargetPointImg,H);
// 
// 				TargetPos.m_vdAuxiliaryPosX.at(2) = ObjectPointImg.GetX();
// 				TargetPos.m_vdAuxiliaryPosY.at(2) = ObjectPointImg.GetY();
// 			}
// 			///////////////////////////bai////////////////////////////////////////////////////

		}	
		str.Format("胶框图像(在上平面中)坐标:CH%d: %f,%f；辅助点0：%f,%f；辅助点1：%f,%f  ",i,TargetPos.m_dPosX,TargetPos.m_dPosY,TargetPos.m_vdAuxiliaryPosX.at(0),TargetPos.m_vdAuxiliaryPosY.at(0),TargetPos.m_vdAuxiliaryPosX.at(1),TargetPos.m_vdAuxiliaryPosY.at(1));
		AlignToolLogRecord(str,m_nPlatformIndex);

		str.Format("[原图像坐标]胶框图像(在下平面中)坐标:CH%d: %f,%f；辅助点0：%f,%f；辅助点1：%f,%f  ",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(0),m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(0),m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosX.at(1),m_TargetSearchResults.m_vPos.at(i).m_vdAuxiliaryPosY.at(1));
		AlignToolLogRecord(str,m_nPlatformIndex);

		str.Format("目标平台坐标%d开始======",i);
		AlignToolLogRecord(str,nPlatformIndex);


		//计算胶框平面的图像坐标对应的平台坐标
		if (i == 0)
		{
			//BOOL bflag = ConvertImagePosToCurPlatformPos(ObjectHoleMarkPlatformPos.m_vPos.at(i),  i, TargetPos, m_pObjectPlatformAxisPos.at(i));
			BOOL bflag = ConvertImagePosToCurPlatformPos(ObjectHoleMarkPlatformPos.m_vPos.at(i),  i, TargetPos, m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()-1));
			if (!bflag)
			{
				return bflag;
			}
			vcpTarPlatPos[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i);

// 			dTargetX[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_dPosX;
// 			dTargetY[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_dPosY;
// 
// 			// 辅助位置
// 			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 			{
// 				dAuxiliaryTargetX0[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// 				dAuxiliaryTargetY0[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// 				dAuxiliaryTargetX1[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// 				dAuxiliaryTargetY1[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// 			}
		}
		else
		{
			//BOOL bflag = ConvertImagePosToCurPlatformPos(ObjectHoleMarkPlatformPos.m_vPos.at(i),  i, TargetPos, m_pObjectPlatformAxisPos.at(i)/*,m_vObjectCamPlatformAxisPos.at(0)*/);
			BOOL bflag = ConvertImagePosToCurPlatformPos(ObjectHoleMarkPlatformPos.m_vPos.at(i),  i, TargetPos, m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()-1)/*,m_vObjectCamPlatformAxisPos.at(0)*/);
			if (!bflag)
			{
				return bflag;
			}
			vcpTarPlatPos[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i);

// 			dTargetX[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_dPosX;
// 			dTargetY[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_dPosY;
// 
// 			// 辅助位置
// 			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 			{
// 				dAuxiliaryTargetX0[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// 				dAuxiliaryTargetY0[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// 				dAuxiliaryTargetX1[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// 				dAuxiliaryTargetY1[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// 			}
// 
// 			if (/*m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_C5 || */
// 				m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_1234_Weight || 
// 				m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight)
// 			{
// 				dAuxiliaryTargetX0[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(0);
// 				dAuxiliaryTargetY0[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(0);
// 				dAuxiliaryTargetD0[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(0);
// 
// 				dAuxiliaryTargetX1[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(1);
// 				dAuxiliaryTargetY1[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(1);
// 				dAuxiliaryTargetD1[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(1);
// 
// 				dAuxiliaryTargetX2[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosX.at(2);
// 				dAuxiliaryTargetY2[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryPosY.at(2);
// 				dAuxiliaryTargetD2[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_vdAuxiliaryAngle.at(2);
// 			}

		}

		str.Format("目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("目标平台坐标%d结束======",i);
		AlignToolLogRecord(str,nPlatformIndex);


	}

	///////////////////////////////组合对位工具的使用//////////////////////////////////////
	{
		//重新构造新的对位点//================================================================================
		if ( FALSE == m_bTargetObjectCamSeparate && m_iMarkNum == 4 && 
			(m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4
			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
			|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Weight) )
		{
			CCoordPos tmpPos[4];

			CString str;
			int k;
			for ( k=0;k<m_iMarkNum;k++)
			{
// 				tmpPos[k] = ObjectHoleMarkPlatformPos.m_vPos.at(k);
// 				str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,ObjectHoleMarkPlatformPos.m_vPos.at(k).m_dPosX,ObjectHoleMarkPlatformPos.m_vPos.at(k).m_dPosY);
// 				AlignToolLogRecord(str,nPlatformIndex);

				tmpPos[k] = vcpTarPlatPos[k];
				str.Format("修正前目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,tmpPos[k].m_dPosX,tmpPos[k].m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
			}
			CCoordPos ResultPos[4];
			scLine ResultLine[4];
			sc2Vector UsePoint[8];
			bool bIntersect;
			std::vector<sc2Vector> crossPointArray;
// 			UsePoint[0].SetX(ObjectHoleMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(0));
// 			UsePoint[0].SetY(ObjectHoleMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(0));
// 			UsePoint[1].SetX(ObjectHoleMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(0));
// 			UsePoint[1].SetY(ObjectHoleMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(0));
// 			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);
// 
// 			UsePoint[2].SetX(ObjectHoleMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosX(1));
// 			UsePoint[2].SetY(ObjectHoleMarkPlatformPos.m_vPos.at(1).GetAuxiliaryPosY(1));
// 			UsePoint[3].SetX(ObjectHoleMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosX(1));
// 			UsePoint[3].SetY(ObjectHoleMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosY(1));
// 			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);
// 
// 			UsePoint[4].SetX(ObjectHoleMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosX(0));
// 			UsePoint[4].SetY(ObjectHoleMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosY(0));
// 			UsePoint[5].SetX(ObjectHoleMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosX(0));
// 			UsePoint[5].SetY(ObjectHoleMarkPlatformPos.m_vPos.at(3).GetAuxiliaryPosY(0));
// 			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);
// 
// 			UsePoint[6].SetX(ObjectHoleMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosX(1));
// 			UsePoint[6].SetY(ObjectHoleMarkPlatformPos.m_vPos.at(0).GetAuxiliaryPosY(1));
// 			UsePoint[7].SetX(ObjectHoleMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosX(1));
// 			UsePoint[7].SetY(ObjectHoleMarkPlatformPos.m_vPos.at(2).GetAuxiliaryPosY(1));
// 			ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

			UsePoint[0] = vcpTarPlatPos[0].GetAuxPos(0);
			UsePoint[1] = vcpTarPlatPos[1].GetAuxPos(0);
			ResultLine[0].SetFromStartEnd(UsePoint[0],UsePoint[1]);

			UsePoint[2] = vcpTarPlatPos[1].GetAuxPos(1);
			UsePoint[3] = vcpTarPlatPos[3].GetAuxPos(1);
			ResultLine[1].SetFromStartEnd(UsePoint[2],UsePoint[3]);

			UsePoint[4] = vcpTarPlatPos[2].GetAuxPos(0);
			UsePoint[5] = vcpTarPlatPos[3].GetAuxPos(0);
			ResultLine[2].SetFromStartEnd(UsePoint[4],UsePoint[5]);

			UsePoint[6] = vcpTarPlatPos[0].GetAuxPos(1);
			UsePoint[7] = vcpTarPlatPos[2].GetAuxPos(1);
			ResultLine[3].SetFromStartEnd(UsePoint[6],UsePoint[7]);

			if (sfInterSectLineLine(ResultLine[0], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
// 				ObjectHoleMarkPlatformPos.m_vPos.at(0).m_dPosX = crossPointArray.at(0).GetX(); 
// 				ObjectHoleMarkPlatformPos.m_vPos.at(0).m_dPosY = crossPointArray.at(0).GetY();

				vcpTarPlatPos[0].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[0].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[0], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
// 				ObjectHoleMarkPlatformPos.m_vPos.at(1).m_dPosX = crossPointArray.at(0).GetX(); 
// 				ObjectHoleMarkPlatformPos.m_vPos.at(1).m_dPosY = crossPointArray.at(0).GetY();

				vcpTarPlatPos[1].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[1].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[3], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
// 				ObjectHoleMarkPlatformPos.m_vPos.at(2).m_dPosX = crossPointArray.at(0).GetX(); 
// 				ObjectHoleMarkPlatformPos.m_vPos.at(2).m_dPosY = crossPointArray.at(0).GetY();

				vcpTarPlatPos[2].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[2].m_dPosY = crossPointArray.at(0).GetY();
			}


			if (sfInterSectLineLine(ResultLine[2], ResultLine[1], bIntersect, crossPointArray)
				&& crossPointArray.size() > 0)
			{
// 				ObjectHoleMarkPlatformPos.m_vPos.at(3).m_dPosX = crossPointArray.at(0).GetX(); 
// 				ObjectHoleMarkPlatformPos.m_vPos.at(3).m_dPosY = crossPointArray.at(0).GetY();

				vcpTarPlatPos[3].m_dPosX = crossPointArray.at(0).GetX(); 
				vcpTarPlatPos[3].m_dPosY = crossPointArray.at(0).GetY();
			}

			for (k=0;k<m_iMarkNum;k++)
			{
				str.Format("修正后目标位置%d 平台坐标 X:, %f ,Y:, %f ,",k,vcpTarPlatPos[k].GetPosX(),vcpTarPlatPos[k].GetPosY());
				AlignToolLogRecord(str,nPlatformIndex);
			}
			for (k=0;k<m_iMarkNum;k++)
			{
// 				double ddx = tmpPos[k].GetPosX() - ObjectHoleMarkPlatformPos.m_vPos.at(k).GetPosX();
// 				double ddy = tmpPos[k].GetPosY() - ObjectHoleMarkPlatformPos.m_vPos.at(k).GetPosY();

				double ddx = tmpPos[k].GetPosX() - vcpTarPlatPos[k].GetPosX();
				double ddy = tmpPos[k].GetPosY() - vcpTarPlatPos[k].GetPosY();
				str.Format("修正前后目标位置%d 平台坐标差 X:, %f ,Y:, %f ,",k,ddx,ddy);
				AlignToolLogRecord(str,nPlatformIndex);
			}

// 			//读取每个相机对应的对象mark和平台mark的坐标值
// 			for (int i=0; i<m_iMarkNum; i++)
// 			{
// 				//记录相机对象mark的坐标
// 				dTargetX[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_dPosX;
// 				dTargetY[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_dPosY;
// 				dTargetD[i] = ObjectHoleMarkPlatformPos.m_vPos.at(i).m_dAngle;
// 			}
		}
		//================================================================================
	}

	if (m_AlignermentParam.m_bCheckAlnTargetOffsetEnable && !m_bInnerAlignBench)
	{
		if (m_AlignermentParam.m_dAlnTargetOffsetX!=0 || m_AlignermentParam.m_dAlnTargetOffsetY!=0 )
		{
			for(int k=0;k<m_iMarkNum;k++)
			{
				vcpTarPlatPos[k].Offset(-m_AlignermentParam.m_dAlnTargetOffsetX, -m_AlignermentParam.m_dAlnTargetOffsetY);

// 				dTargetX[k]-=m_AlignermentParam.m_dAlnTargetOffsetX;
// 				dTargetY[k]-=m_AlignermentParam.m_dAlnTargetOffsetY;
// 
// 				// 辅助位置
// 				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 				{
// 					dAuxiliaryTargetX0[k] -= m_AlignermentParam.m_dAlnTargetOffsetX;
// 					dAuxiliaryTargetY0[k] -= m_AlignermentParam.m_dAlnTargetOffsetY;
// 					dAuxiliaryTargetX1[k] -= m_AlignermentParam.m_dAlnTargetOffsetX;
// 					dAuxiliaryTargetY1[k] -= m_AlignermentParam.m_dAlnTargetOffsetY;
// 				}
			}
		}
	}

	// $4、目标Mark与对象Mark在平台坐标下进行对位，计算旋转角度及XY轴偏移量

	m_PlatformOffset.m_dPosX  = 0;		
	m_PlatformOffset.m_dPosY  = 0;
	m_PlatformOffset.m_dAngle = 0;

	m_ProductOffset.m_dPosX  = 0;		
	m_ProductOffset.m_dPosY  = 0;
	m_ProductOffset.m_dAngle = 0;

	m_ProductOffsetXYPD.m_dPosX  = 0;		
	m_ProductOffsetXYPD.m_dPosY  = 0;
	m_ProductOffsetXYPD.m_dAngle = 0;

	int nPosNum = m_iMarkNum;							// 实际对位的位置数量
	std::vector<CCoordPos> vcpObjectPlatformPos;		// 对象位置
	std::vector<CCoordPos> vcpTargetPlatformPos;		// 目标位置
	std::vector<CCoordPos> vcpAlginedObjectPlatformPos; // 对位后对象位置
	std::vector<CCoordPos> vcpAlginedTargetPlatformPos; // 对位后目标位置
	for (int nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
	{
		// 对象位置
		CCoordPos cpObjectPlatformPos;
// 		cpObjectPlatformPos.m_dPosX = dObjectX[nPosIndex];
// 		cpObjectPlatformPos.m_dPosY = dObjectY[nPosIndex];
// 		cpObjectPlatformPos.m_dAngle = dObjectD[nPosIndex];
// 
// 		cpObjectPlatformPos.m_vdAuxiliaryPosX.at(0)= dAuxiliaryObjectX0[nPosIndex];
// 		cpObjectPlatformPos.m_vdAuxiliaryPosY.at(0)= dAuxiliaryObjectY0[nPosIndex];
// 		cpObjectPlatformPos.m_vdAuxiliaryAngle.at(0)= dAuxiliaryObjectD0[nPosIndex];
// 		cpObjectPlatformPos.m_vdAuxiliaryPosX.at(1)= dAuxiliaryObjectX1[nPosIndex];
// 		cpObjectPlatformPos.m_vdAuxiliaryPosY.at(1)= dAuxiliaryObjectY1[nPosIndex];
// 		cpObjectPlatformPos.m_vdAuxiliaryAngle.at(1)= dAuxiliaryObjectD1[nPosIndex];
// 		cpObjectPlatformPos.m_vdAuxiliaryPosX.at(2)= dAuxiliaryObjectX2[nPosIndex];
// 		cpObjectPlatformPos.m_vdAuxiliaryPosY.at(2)= dAuxiliaryObjectY2[nPosIndex];
// 		cpObjectPlatformPos.m_vdAuxiliaryAngle.at(2)= dAuxiliaryObjectD2[nPosIndex];

		cpObjectPlatformPos = vcpObjPlatPos[nPosIndex];
		vcpObjectPlatformPos.push_back(cpObjectPlatformPos);

		// 目标位置
		CCoordPos cpTargetPlatformPos;
// 		cpTargetPlatformPos.m_dPosX = dTargetX[nPosIndex];
// 		cpTargetPlatformPos.m_dPosY = dTargetY[nPosIndex];
// 		cpTargetPlatformPos.m_dAngle = dTargetD[nPosIndex];
// 
// 		cpTargetPlatformPos.m_vdAuxiliaryPosX.at(0)= dAuxiliaryTargetX0[nPosIndex];
// 		cpTargetPlatformPos.m_vdAuxiliaryPosY.at(0)= dAuxiliaryTargetY0[nPosIndex];
// 		cpTargetPlatformPos.m_vdAuxiliaryAngle.at(0)= dAuxiliaryTargetD0[nPosIndex];
// 		cpTargetPlatformPos.m_vdAuxiliaryPosX.at(1)= dAuxiliaryTargetX1[nPosIndex];
// 		cpTargetPlatformPos.m_vdAuxiliaryPosY.at(1)= dAuxiliaryTargetY1[nPosIndex];
// 		cpTargetPlatformPos.m_vdAuxiliaryAngle.at(1)= dAuxiliaryTargetD1[nPosIndex];
// 		cpTargetPlatformPos.m_vdAuxiliaryPosX.at(2)= dAuxiliaryTargetX2[nPosIndex];
// 		cpTargetPlatformPos.m_vdAuxiliaryPosY.at(2)= dAuxiliaryTargetY2[nPosIndex];
// 		cpTargetPlatformPos.m_vdAuxiliaryAngle.at(2)= dAuxiliaryTargetD2[nPosIndex];

		cpTargetPlatformPos = vcpTarPlatPos[nPosIndex];
		vcpTargetPlatformPos.push_back(cpTargetPlatformPos);
	}
	vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
	vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;

	// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
	if (!GetAlginOffset(vcpObjectPlatformPos, vcpTargetPlatformPos, m_ProductOffset, m_PlatformOffset, 
		vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
	{
		str.Format("------------------------------------------------------------对位计算结束(失败)");
		AlignToolLogRecord(str,nPlatformIndex);
		return FALSE;
	}

	str.Format("------------------------------------------------------------对位计算结束(成功)");
	AlignToolLogRecord(str,nPlatformIndex);

	return TRUE;





	// $6、当左右相机单独XY轴控制时，为完成迭代对位，计算左右相机平移量
	double dAlignerDegree = 0;
	double dAlignerX = 0;
	double dAlignerY = 0;

	dAlignerX = m_PlatformOffset.m_dPosX;		
	dAlignerY = m_PlatformOffset.m_dPosY ;
	dAlignerDegree = m_PlatformOffset.m_dAngle;
	int CamPlatformType = m_pCamPlatformInfo->GetCamPlatformType();
	if ( eCamPlatformSepXY == CamPlatformType)
	{	
		// 计算全局平台坐标系下，被检测的对象Mark的平台移动量
		for (int j=0; j<m_iMarkNum; j++)
		{
			dObjectXforCam1[j] = cos(scDegree(-1*dAlignerDegree))*dObjectXforCam0[j] 
							   - sin(scDegree(-1*dAlignerDegree))*dObjectYforCam0[j];
			dObjectYforCam1[j] = sin(scDegree(-1*dAlignerDegree))*dObjectXforCam0[j] 
							   + cos(scDegree(-1*dAlignerDegree))*dObjectYforCam0[j];
			dPltfmXforCam[j] = dObjectXforCam1[j] - dObjectXforCam0[j] + dAlignerX;
			dPltfmYforCam[j] = dObjectYforCam1[j] - dObjectYforCam0[j] + dAlignerY;
			// 计算相机变换矩阵的逆矩阵
			sc2Matrix TDMatrix, TDMatrixInvert;
			TDMatrix = m_vAlignerCalibInfos.at(j)->GetCamPlatformTransferMatrix();
			TDMatrix.Inverse(TDMatrixInvert);
			dCameraPltfmX[j] = TDMatrix.GetElement(0,0)*dPltfmXforCam[j] + TDMatrix.GetElement(0,1)*dPltfmYforCam[j];
			dCameraPltfmY[j] = TDMatrix.GetElement(1,0)*dPltfmXforCam[j] + TDMatrix.GetElement(1,1)*dPltfmYforCam[j];

			// 马丽加(防止内存泄漏)
			if (m_vCamPlatformMovement.at(j)!=NULL)
			{
				delete m_vCamPlatformMovement.at(j);
				m_vCamPlatformMovement.at(j) = NULL;
			}
		
			m_vCamPlatformMovement.at(j) = new CPlatformXYAxisPos;
			((CPlatformXYAxisPos*)m_vCamPlatformMovement.at(j))->m_dPosX = dCameraPltfmX[j];
			((CPlatformXYAxisPos*)m_vCamPlatformMovement.at(j))->m_dPosY = dCameraPltfmY[j];
		}
	}
	else if (eCamPlatformSepX == CamPlatformType)
	{
		for (int j=0; j<m_iMarkNum; j++)
		{
			dObjectXforCam1[j] = cos(scDegree(-1*dAlignerDegree))*dObjectXforCam0[j] 
				- sin(scDegree(-1*dAlignerDegree))*dObjectYforCam0[j];
			dObjectYforCam1[j] = sin(scDegree(-1*dAlignerDegree))*dObjectXforCam0[j] 
				+ cos(scDegree(-1*dAlignerDegree))*dObjectYforCam0[j];
			dPltfmXforCam[j] = dObjectXforCam1[j] - dObjectXforCam0[j] + dAlignerX;
			dPltfmYforCam[j] = dObjectYforCam1[j] - dObjectYforCam0[j] + dAlignerY;
			// 计算相机变换矩阵的AXX和AXY
			sc2Matrix TDMatrix;
			TDMatrix = m_vAlignerCalibInfos.at(j)->GetCamPlatformTransferMatrix();
			dCameraPltfmX[j] = 0.5*(dPltfmXforCam[j]/TDMatrix.GetElement(0,0) + dPltfmYforCam[j]/TDMatrix.GetElement(0,1));
			dCameraPltfmY[j] = 0;

			// 马丽加(防止内存泄漏)
			if (m_vCamPlatformMovement.at(j)!=NULL)
			{
				delete m_vCamPlatformMovement.at(j);
				m_vCamPlatformMovement.at(j) = NULL;
			}

			m_vCamPlatformMovement.at(j) = new CPlatformXYAxisPos;
			((CPlatformXYAxisPos*)m_vCamPlatformMovement.at(j))->m_dPosX = dCameraPltfmX[j];
			((CPlatformXYAxisPos*)m_vCamPlatformMovement.at(j))->m_dPosY = dCameraPltfmY[j];	
		}
	}

	else
	{
		for (int j=0; j<m_iMarkNum; j++)
		{
			// 马丽加(防止内存泄漏)
			if (m_vCamPlatformMovement.at(j)!=NULL)
			{
				delete m_vCamPlatformMovement.at(j);
				m_vCamPlatformMovement.at(j) = NULL;
			}

			m_vCamPlatformMovement.at(j) = new CPlatformXYAxisPos;
			((CPlatformXYAxisPos*)m_vCamPlatformMovement.at(j))->m_dPosX = 0;
			((CPlatformXYAxisPos*)m_vCamPlatformMovement.at(j))->m_dPosY = 0;
		}
	}
	
	//对位偏移量计算成功，对位次数加一
//	m_AlignermentTimes++;
	return TRUE;
}


//判断整个对位过程是否结束
//当对位次数小于最大次数时，判断是否达到精度要求，达到则对位成功，且对位结束，否则不成功，未结束；
//当对位次数达到最大次数时，判断是否达到精度要求，达到则对位成功，否则不成功，对位结束。

// BOOL vcBaseAlignTool::IsPCBPrecisionInspectFinished(int nInsTpye, std::vector<BOOL>& vbPosIndex,std::vector<double>&vdOffsetX,std::vector<double>&vdOffsetY)
// {
// // 	if ( ePlatformXYD != GetMidPlatformType())
// // 	{
// // 		return FALSE;
// // 	}
// 
// 	if (nInsTpye == 0)
// 	{
// 		if (fabs(m_ProductOffset.GetAngle()) <= m_AlignermentParam.GetPCBInfo().m_PCBInsPre.m_dAngle)
// 		{
// 			if (fabs(m_ProductOffset.GetPosY()) <= m_AlignermentParam.GetPCBInfo().m_PCBInsPre.m_dPosY)
// 			{
// 				if (fabs(m_ProductOffset.GetPosX()) <= m_AlignermentParam.m_PCBInfo.m_PCBInsPre.m_dPosX)
// 				{							
// 					return TRUE;
// 				}
// 				else
// 				{
// 					for (int i = 0; i < vbPosIndex.size(); i++)
// 					{
// 						vbPosIndex.at(i) = FALSE;
// 					}
// 				}
// 			}
// 			else
// 			{
// 				for (int i = 0; i < vbPosIndex.size(); i++)
// 				{
// 					vbPosIndex.at(i) = FALSE;
// 				}
// 			}
// 		}
// 		else
// 		{
// 			for (int i = 0; i < vbPosIndex.size(); i++)
// 			{
// 				vbPosIndex.at(i) = FALSE;
// 			}
// 		}
// 
// 		return FALSE;
// 
// 	}
// 	else if (nInsTpye == 1)
// 	{
// 		int nOKNum = 0;
// 		for (int i=0; i<m_iMarkNum; i++)
// 		{	
// 			vdOffsetX.at(i) = 0;
// 			vdOffsetY.at(i) = 0;
// 			//PCB定制
// 			if (m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align)
// 			{
// 				int a = (int)(m_PointMethodType)-1;
// 				// 如果 i+1和m_PointMethodType 数值相等，则表示该位置没有定位，不参与计算；
// 				if (i == a)
// 				{
// 					continue;
// 				}
// 			}
// 			double dPosX = (m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX());
// 			double dPosY = (m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY());
// 
// 			vdOffsetX.at(i) = dPosX;
// 			vdOffsetY.at(i) = dPosY;
// 			if (fabs(m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX()) <= m_AlignermentParam.GetPCBInfo().m_PCBInsPre.GetPosX())
// 			{
// 				if (fabs(m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY()) <= m_AlignermentParam.GetPCBInfo().m_PCBInsPre.GetPosY())
// 				{
// 					nOKNum = nOKNum + 1;
// 
// 					vbPosIndex.at(i) = TRUE;
// 				}
// 				else
// 				{
// 					vbPosIndex.at(i) = FALSE;
// 				}
// 			}
// 			else
// 			{
// 				vbPosIndex.at(i) = FALSE;
// 			}
// 		}
// 
// 		if (nOKNum == 4)
// 		{
// 			return TRUE;
// 		}
// 		else
// 		{
// 			if (m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align)
// 			{
// 				if(nOKNum == 3)
// 				{
// 					return TRUE;
// 				}
// 				else
// 				{
// 					return FALSE;
// 				}
// 
// 			}
// 			else
// 			{
// 				return FALSE;
// 			}
// 			
// 		}
// 
// 	}
// 	else if (nInsTpye == 2)
// 	{
// 		int nOKNum = 0;
// 
// 		for (int i=0; i<m_iMarkNum; i++)
// 		{
// 			vdOffsetX.at(i) = 0;
// 			vdOffsetY.at(i) = 0;
// 			//PCB定制
// 			if (m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align)
// 			{
// 				int a = (int)(m_PointMethodType)-1;
// 				// 如果 i+1和m_PointMethodType 数值相等，则表示该位置没有定位，不参与计算；
// 				if (i == a)
// 				{
// 					continue;
// 				}
// 			}
// 			double dPosX = (m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX());
// 			double dPosY = (m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY() - m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY());
// 
// 			vdOffsetX.at(i) = dPosX;
// 			vdOffsetY.at(i) = dPosY;
// 
// 			if (fabs(m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX() - m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX()) <= m_AlignermentParam.GetPCBInfo().m_PCBInsPre.GetPosX())
// 			{
// 				if (fabs(m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY()-m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY())<=m_AlignermentParam.GetPCBInfo().m_PCBInsPre.GetPosY())
// 				{
// 					nOKNum = nOKNum + 1;
// 
// 					vbPosIndex.at(i) = TRUE;
// 				}
// 				else
// 				{
// 					vbPosIndex.at(i) = FALSE;
// 				}
// 			}
// 			else
// 			{
// 				vbPosIndex.at(i) = FALSE;
// 			}
// 		}
// 
// 		if ( (nOKNum == 3) || (nOKNum == 4))
// 		{
// 			return TRUE;
// 		}
// 		else
// 		{
// 			return FALSE;
// 		}
// 	}
// 	else 
// 	{
// 		return FALSE;
// 	}
// 
// 
// }


BOOL vcBaseAlignTool::IsAlignFinished( int nTimes, BOOL bMulAligner)
{	
	if (bMulAligner)
	{
		if (nTimes <= m_AlignermentParam.GetAlignerMaxTime())
		{
			if (ePlatformXYPD == GetMidPlatformType())
			{
				if (fabs(m_PlatformOffset.GetAngle()) <= m_AlignermentParam.GetAlignerPrecision().GetAngle())
				{
					if (fabs(m_PlatformOffset.GetPosY()) <= m_AlignermentParam.GetAlignerPrecision().GetPosY())
					{
						if (fabs(m_PlatformOffset.GetPosX()) <= m_AlignermentParam.GetAlignerPrecision().GetPosX())
						{				
							m_bIsAlignerSuccess = TRUE;	
							return TRUE;
						}
					}
				}

				m_bIsAlignerSuccess = FALSE;	
				return FALSE;
			}
		}
		else
		{
			if (ePlatformXYPD == GetMidPlatformType())
			{
				if (fabs(m_PlatformOffset.GetAngle()) <= m_AlignermentParam.GetAlignerPrecision().GetAngle())
				{
					if (fabs(m_PlatformOffset.GetPosY()) <= m_AlignermentParam.GetAlignerPrecision().GetPosY())
					{
						if (fabs(m_PlatformOffset.GetPosX()) <= m_AlignermentParam.GetAlignerPrecision().GetPosX())
						{	
							m_bIsAlignerSuccess = TRUE;
							return TRUE;
						}
					}
				}

				m_bIsAlignerSuccess = FALSE;
				return TRUE;

			}
		}
	}



	if (nTimes <= m_AlignermentParam.GetAlignerMaxTime())
	{	
		if (ePlatformXYPD == GetMidPlatformType() || ePlatformXY == GetMidPlatformType() || ePlatformX== GetMidPlatformType() || ePlatformY == GetMidPlatformType())
		{
			if (fabs(m_PlatformOffset.GetPosY()) <= m_AlignermentParam.GetAlignerPrecision().GetPosY())
			{
				if (fabs(m_PlatformOffset.GetPosX()) <= m_AlignermentParam.GetAlignerPrecision().GetPosX())
				{				
					m_bIsAlignerSuccess = TRUE;	
					return TRUE;
				}
			}
			m_bIsAlignerSuccess = FALSE;	
			return FALSE;

		}
		else
		{
			
			if (fabs(m_ProductOffset.GetAngle()) <= m_AlignermentParam.GetAlignerPrecision().GetAngle())
			{
				if (fabs(m_ProductOffset.GetPosY()) <= m_AlignermentParam.GetAlignerPrecision().GetPosY())
				{
					if (fabs(m_ProductOffset.GetPosX()) <= m_AlignermentParam.GetAlignerPrecision().GetPosX())
					{				
			//if (fabs(m_PlatformOffset.GetAngle()) <= m_AlignermentParam.GetAlignerPrecision().GetAngle())
			//{
			//	if (fabs(m_PlatformOffset.GetPosY()) <= m_AlignermentParam.GetAlignerPrecision().GetPosY())
			//	{
			//		if (fabs(m_PlatformOffset.GetPosX()) <= m_AlignermentParam.GetAlignerPrecision().GetPosX())
			//		{				
						m_bIsAlignerSuccess = TRUE;	
						return TRUE;
					}
				}
			}
			m_bIsAlignerSuccess = FALSE;	
			return FALSE;
		}
		
	}
	else 
	{	
		if (ePlatformXYPD == GetMidPlatformType()|| ePlatformXY == GetMidPlatformType() || ePlatformX == GetMidPlatformType() || ePlatformY == GetMidPlatformType())
		{
			if (fabs(m_PlatformOffset.GetPosY()) <= m_AlignermentParam.GetAlignerPrecision().GetPosY())
			{
				if (fabs(m_PlatformOffset.GetPosX()) <= m_AlignermentParam.GetAlignerPrecision().GetPosX())
				{	
					m_bIsAlignerSuccess = TRUE;
					return TRUE;
				}
			}
			m_bIsAlignerSuccess = FALSE;
			return TRUE;

		}
		else
		{
			if (fabs(m_ProductOffset.GetAngle()) <= m_AlignermentParam.GetAlignerPrecision().GetAngle())
			{
				if (fabs(m_ProductOffset.GetPosY()) <= m_AlignermentParam.GetAlignerPrecision().GetPosY())
				{
					if (fabs(m_ProductOffset.GetPosX()) <= m_AlignermentParam.GetAlignerPrecision().GetPosX())
					{	
			//if (fabs(m_PlatformOffset.GetAngle()) <= m_AlignermentParam.GetAlignerPrecision().GetAngle())
			//{
			//	if (fabs(m_PlatformOffset.GetPosY()) <= m_AlignermentParam.GetAlignerPrecision().GetPosY())
			//	{
			//		if (fabs(m_PlatformOffset.GetPosX()) <= m_AlignermentParam.GetAlignerPrecision().GetPosX())
			//		{	
						m_bIsAlignerSuccess = TRUE;
						return TRUE;
					}
				}
			}
			m_bIsAlignerSuccess = FALSE;
			return TRUE;
		}

	}

}

// 整个对位过程是否成功
BOOL vcBaseAlignTool::IsAlignSucceed( void )
{
   return m_bIsAlignerSuccess;	
}

// 对位偏差计算成功后，获取对位结果
CPlatformAxisPos* vcBaseAlignTool::GetAlignPlatformMovementResults(BOOL bUseOffset/* = FALSE*/)
{	
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
	CPlatformXYDAxisPos* pPlatformPos = NULL;
	if (m_bTargetObjectCamSeparate)
	{
// 		if (m_bPlatformTarCamWithDiffObjCam)
// 		{
// 			if (m_nAlignnExProductIndex == 0)
// 			{
// 				pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()/4 - 1)));
// 			}
// 			else if (m_nAlignnExProductIndex == 1)
// 			{
// 				pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()/2 - 1)));
// 			}
// 			else
// 			{
// 				pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()/2 - 1)));
// 			}
// 		}
		/*else*/ if (m_bEnableTargetAndObjectPositionVirtualMode)
		{
			BOOL bObjectVirtual = m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;
			int nObjectPositionVirtualMode = m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;

			if (bObjectVirtual)
			{
				switch(nObjectPositionVirtualMode)
				{
					// 对象位置虚拟模式：12拍照34虚拟
				case 0:
					{
						pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(0)));
					}
					break;

					// 对象位置虚拟模式：34拍照12虚拟
				case 1:
					{
						pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(2)));
					}
					break;

					// 对象位置虚拟模式：13拍照24虚拟
				case 2:
					{
						pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(0)));
					}
					break;

					// 对象位置虚拟模式：24拍照13虚拟
				case 3:
					{
						pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(1)));
					}
					break;

				default:
					{
						pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()/2 - 1)));
					}
					break;
				}
			}
			else
			{
				pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()/2 - 1)));
			}
		}
		else
		{
			pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()/2 - 1)));
		}
	}
	else
	{
		pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size() - 1)));
	}



	//先搜索目标mark,再搜索对象mark.保证m_pPlatformPos的值是当前轴的位置。
	//首先把目标mark搜索时的轴位置（即当前位置）付给m_pPlatformPos，再加上对位偏移量；
	double dPosX = m_PlatformOffset.m_dPosX;
	double dPosY = m_PlatformOffset.m_dPosY;
	double dAngle = m_PlatformOffset.m_dAngle;

	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	if (eDirectNegative == iPlatformXCoordType) dPosX = -1*dPosX;
	if (eDirectNegative == iPlatformYCoordType) dPosY = -1*dPosY;
	if (eDirectNegative == iPlatformDCoordType) dAngle = -1*dAngle;

	if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
	{
		double dStartAngle = 0;
		if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
		{
			if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
			{
				dStartAngle = scDegree(scRadian(asin(pPlatformPos->m_dAngle/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
				dAngle = (sin(scDegree(dStartAngle + dAngle)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
			}
			else
			{
				dStartAngle = scDegree(scRadian(atan(pPlatformPos->m_dAngle/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
				dAngle = (tan(scDegree(dStartAngle + dAngle)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
			}
		}
	}

	if ((ePlatformXDPY == m_eMidPlatformType) || (ePlatformXDPY1 == m_eMidPlatformType))
	{
		dPosY = -1*dPosY;
	}

	if (m_AlignermentParam.m_bAlignOffsetReverseX)
	{
		dPosX = -1*dPosX;
	}
	if (m_AlignermentParam.m_bAlignOffsetReverseY)
	{
		dPosY = -1*dPosY;
	}
	if (m_AlignermentParam.m_bAlignOffsetReverseD)
	{
		dAngle = -1*dAngle;
	}


	if (bUseOffset)
	{
		if ( (GetMidPlatformType() == ePlatformXYPD) && (m_bTargetObjectCamSeparate) && (m_iMarkNum == 4) )
		{
			CCoordPos TempPos = m_TempPlatformPos;
			if (eDirectNegative == iPlatformXCoordType) TempPos.m_dPosX = -1*TempPos.m_dPosX;
			if (eDirectNegative == iPlatformYCoordType) TempPos.m_dPosY = -1*TempPos.m_dPosY;

			pPlatformPos->m_dPosX += TempPos.m_dPosX;
			pPlatformPos->m_dPosY += TempPos.m_dPosY;

		}
	}

	pPlatformPos->m_dAngle += dAngle;
	pPlatformPos->m_dPosX += dPosX;
	pPlatformPos->m_dPosY += dPosY;

	// 马丽加(防止内存泄漏)
	if (m_pPlatformPos!=NULL)
	{
		delete m_pPlatformPos;
		m_pPlatformPos = NULL;
	}

	m_pPlatformPos = pPlatformPos;

	return m_pPlatformPos;
}

// 对位偏差计算成功后，获取对位结果
CPlatformAxisPos* vcBaseAlignTool::GetAdjustAlignPlatformMovementResults(double dratioX,double dratioY,double dratioD /*= 1.0*/)
{	
	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
	CPlatformXYDAxisPos* pPlatformPos = NULL;
	if (m_bTargetObjectCamSeparate)
	{
		pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size()/2 - 1)));
	}
	else
	{
		pPlatformPos = new CPlatformXYDAxisPos(*((CPlatformXYDAxisPos*)m_pObjectPlatformAxisPos.at(m_pObjectPlatformAxisPos.size() - 1)));
	}

	//先搜索目标mark,再搜索对象mark.保证m_pPlatformPos的值是当前轴的位置。
	//首先把目标mark搜索时的轴位置（即当前位置）付给m_pPlatformPos，再加上对位偏移量；
	double dPosX = m_PlatformOffset.m_dPosX;
	double dPosY = m_PlatformOffset.m_dPosY;
	double dAngle = m_PlatformOffset.m_dAngle;

	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	if (eDirectNegative == iPlatformXCoordType) dPosX = -1*dPosX;
	if (eDirectNegative == iPlatformYCoordType) dPosY = -1*dPosY;
	if (eDirectNegative == iPlatformDCoordType) dAngle = -1*dAngle;

	if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
	{
		double dStartAngle = 0;
		if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
		{
			if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
			{
				dStartAngle = scDegree(scRadian(asin(pPlatformPos->m_dAngle/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
				dAngle = (sin(scDegree(dStartAngle + dAngle)) - sin(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
			}
			else
			{
				dStartAngle = scDegree(scRadian(atan(pPlatformPos->m_dAngle/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
				dAngle = (tan(scDegree(dStartAngle + dAngle)) - tan(scDegree(dStartAngle)))*pPlatformParam->m_dPlatformRotationLength;
			}
		}
	}

	if ((ePlatformXDPY == m_eMidPlatformType) || (ePlatformXDPY1 == m_eMidPlatformType))
	{
		dPosY = -1*dPosY;
	}

	pPlatformPos->m_dAngle += (dAngle*dratioD);
	pPlatformPos->m_dPosX += (dPosX*dratioX);
	pPlatformPos->m_dPosY += (dPosY*dratioY);

	// 马丽加(防止内存泄漏)
	if (m_pPlatformPos!=NULL)
	{
		delete m_pPlatformPos;
		m_pPlatformPos = NULL;
	}

	m_pPlatformPos = pPlatformPos;

	return m_pPlatformPos;
}

// 中间对位过程，当左右相机由独立的XY轴控制时，获取左右相机移动量
std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetAlignCameraMovementResults()
{
	return m_vCamPlatformMovement;
}

//////////////////////////////////////////////////////////////////////////
// Mark坐标系下的补偿
// 获取用于补偿的产品位置和角度（产品位置即产品旋转中心，与相应的对位模式相关）
BOOL vcBaseAlignTool::GetProductPosAngle(std::vector<CCoordPos> vObjectPlatformCoordPos, sc2Vector& vProductPos, scDegree& degProductAngle)
{
// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		int nMark = m_iMarkNum/2;
// 		int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;
// 
// 
// 		double dCH0X = vObjectPlatformCoordPos.at(0 + nExMark).m_dPosX;
// 		double dCH0Y = vObjectPlatformCoordPos.at(0 + nExMark).m_dPosY;
// 		double dCH1X = vObjectPlatformCoordPos.at(1 + nExMark).m_dPosX;
// 		double dCH1Y = vObjectPlatformCoordPos.at(1 + nExMark).m_dPosY;
// 
// 		if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_CTo3
// 			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12
// 			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
// 		{				
// 			// 旋转中心
// 			double dRotationCenterX, dRotationCenterY;
// 			dRotationCenterX = (dCH0X + dCH1X)/2.0;
// 			dRotationCenterY = (dCH0Y + dCH1Y)/2.0;
// 
// 			// 产品位置
// 			vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt0;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt1;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1L2)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt0;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2L1)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt1;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt0;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg(ptStart, ptEnd);
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt1;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg(ptStart, ptEnd);
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1)
// 		{
// 
// 			sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
// 			sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg0(pt00, pt01);
// 			scLineSeg lineSeg1(pt10, pt11);
// 			scLine line0 = lineSeg0.GetLine();
// 			scLine line1 = lineSeg1.GetLine();
// 			svStd vector< sc2Vector > ptCenter;
// 			bool IsInterSect = true;
// 			if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
// 				return FALSE;
// 
// 			// 产品位置
// 			vProductPos = ptCenter.at(0);
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg(ptStart, ptEnd);
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 		{
// 			sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
// 			sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg0(pt00, pt01);
// 			scLineSeg lineSeg1(pt10, pt11);
// 			scLine line0 = lineSeg0.GetLine();
// 			scLine line1 = lineSeg1.GetLine();
// 			svStd vector< sc2Vector > ptCenter;
// 			bool IsInterSect = true;
// 			if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
// 				return FALSE;
// 
// 			// 产品位置
// 			vProductPos = ptCenter.at(0);
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg(ptStart, ptEnd);
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 
// 		return TRUE;
// 	}


	if (m_bTargetObjectCamSeparate)
	{
		if (2 == m_iMarkNum)
		{
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;

			// 产品位置
			vProductPos = sc2Vector(dCH0X, dCH0Y);

			// 产品角度:暂时认为产品角度是0°，后续可根据实际情况增加对位模式
			degProductAngle = scDegree(0);
		}
		else if (4 == m_iMarkNum)
		{
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;

			// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_CTo3
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{				
				// 旋转中心
				double dRotationCenterX, dRotationCenterY;
				dRotationCenterX = (dCH0X + dCH1X)/2.0;
				dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

				// 产品位置
				vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt0;

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());

			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt1;

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1L2)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt0;

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2L1)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt1;

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
				
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt0;

				// 构造实时mark对直线Lx
				scLine Lx;
				sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
				sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg(ptStart, ptEnd);
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt1;

				// 构造实时mark对直线Lx
				scLine Lx;
				sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
				sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg(ptStart, ptEnd);
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1)
			{

				sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
				sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
				sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
				sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg0(pt00, pt01);
				scLineSeg lineSeg1(pt10, pt11);
				scLine line0 = lineSeg0.GetLine();
				scLine line1 = lineSeg1.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
					return FALSE;

				// 产品位置
				vProductPos = ptCenter.at(0);

				// 构造实时mark对直线Lx
				scLine Lx;
				sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
				sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg(ptStart, ptEnd);
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());

			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
			{
				sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
				sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
				sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
				sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg0(pt00, pt01);
				scLineSeg lineSeg1(pt10, pt11);
				scLine line0 = lineSeg0.GetLine();
				scLine line1 = lineSeg1.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
					return FALSE;

				// 产品位置
				vProductPos = ptCenter.at(0);

				// 构造实时mark对直线Lx
				scLine Lx;
				sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
				sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg(ptStart, ptEnd);
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto_Weigth  // jjh0618
				||m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1_Weigth
				||m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2_Weigth)//jjh0601
			{
				//圆权重为1  以圆心为基准对位  以辅助圆为基准进行补偿
				if (m_AlignermentParam.m_dAlignerWeight == 1.0)
				{
					// 旋转中心

					double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
					double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
					double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
					double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
					double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
					double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

					double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
					double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
					double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
					double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
					double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
					double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

					svStd vector< sc2Vector > ptCenter;

					// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					// 圆辅助点坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆辅助点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else
				{
					if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto_Weigth)
					{
						// 旋转中心(点12组成的线段中点是旋转中心)
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1_Weigth)
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH0X, dCH0Y);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2_Weigth)
					{
						// 旋转中心(点2是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH1X, dCH1Y);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

				}
			}

		}
		else if (6 == m_iMarkNum)
		{				
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
			double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
			double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;

			// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			if (eAlignerPos123_Auto == m_AlignermentParam.GetAligner3Vs3Type())
			{

				// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = (pt0 + pt1 + pt2) / 3;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				double dlineSeg12Length = lineSeg12.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (dlineSeg02Length > dlineSeg01Length*1.1)
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}
				else
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C1 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = pt0;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				double dlineSeg12Length = lineSeg12.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (dlineSeg02Length > dlineSeg01Length*1.1)
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}
				else
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}

				// 产品角度
				degProductAngle = scDegree(dDegLx);
				
			}
			else if (eAlignerPos123_123C2 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = pt1;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				double dlineSeg12Length = lineSeg12.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (dlineSeg02Length > dlineSeg01Length*1.1)
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}
				else
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C3 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = pt2;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				double dlineSeg12Length = lineSeg12.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (dlineSeg02Length > dlineSeg01Length*1.1)
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}
				else
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C13L12 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = (pt0 + pt2)/2;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				double dlineSeg12Length = lineSeg12.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				lineSeg.Set(pt0,pt1);


				Lx.SetFromLineSeg(lineSeg);
				double dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C13AL12 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = (pt0 + pt2)/2;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				lineSeg.Set(pt0,pt1);


				Lx.SetFromLineSeg(lineSeg);
				double dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C2L13 == m_AlignermentParam.GetAligner3Vs3Type() || eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = (pt1 + pt1)/2;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				lineSeg.Set(pt0,pt2);


				Lx.SetFromLineSeg(lineSeg);

				double dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				dDegLx -= 90;

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
						//jjh0618
			else if (eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type()  
				||eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
				||eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())  //jjh0612
			{
				// 圆权重为1，以圆为基准进行对位,以圆为基准进行补偿
				if (m_AlignermentParam.m_dAlignerWeight == 1.0)
				{
					svStd vector< sc2Vector > ptCenter;
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					// 圆心坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					// 圆点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else 
				{
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_Auto_Weigth)//两角点中心对位
					{

						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH1X + dCH2X)/2.0;
							dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH2X)/2.0;
							dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH1X)/2.0;
							dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

					}
					else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C1_Weigth) //角点1对位
					{
						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
					}
					else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C2_Weigth)//角点2对位
					{
						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH2X, dCH2Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH2X, dCH2Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
					}
				}

			}
			else if (eAlignerPos123_Auto_L1C_Weigth == m_AlignermentParam.GetAligner3Vs3Type()) //jjh0619  
			{
				if (m_AlignermentParam.m_dAlignerWeight != 0) //以圆为中心进行补偿
				{
					svStd vector< sc2Vector > ptCenter;
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					// 圆心坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					// 圆点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else //角点补偿  以角点中心为旋转中心 以圆心到第一个点的连线为角度 
				{
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH1X + dCH2X)/2.0;
						dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y)); //圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH2X)/2.0;
						dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
			}
		}
		else if (8 == m_iMarkNum)
		{
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
			double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
			double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;
			double dCH3X = vObjectPlatformCoordPos.at(3).m_dPosX;
			double dCH3Y = vObjectPlatformCoordPos.at(3).m_dPosY;

			// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(3).m_dPosX=%f, vObjectPlatformCoordPos.at(3).m_dPosY=%f", vObjectPlatformCoordPos.at(3).m_dPosX, vObjectPlatformCoordPos.at(3).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			if (eAlignerPos1234_Auto == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);
				scLineSeg lineSeg12(pt1, pt2);
				scLineSeg lineSeg03(pt0, pt3);
				scLine line12 = lineSeg12.GetLine();
				scLine line03 = lineSeg03.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(line03,line12,IsInterSect,ptCenter))
					return FALSE;

				// 产品位置
				vProductPos = ptCenter.at(0);

				
				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);
				
				BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
				if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
				{
					bHorDirection = FALSE;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (bHorDirection)
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;

					// 根据对象产品尺寸计算虚拟点位置
// 					if (m_bEnableObjectPositionVirtualMode)
// 					{
// 						if ((m_nObjectPositionNum == 2) && (m_nTargetPositionNum == 4))
// 						{
// 							// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 							if (m_bObjectPositionDirectionMode == 0)
// 							{
// 								dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 							}
// 							else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 							{
// 								dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
// 							}
// 						}
// 					}
										
				}
				else
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}

					// 根据对象产品尺寸计算虚拟点位置
// 					if (m_bEnableObjectPositionVirtualMode)
// 					{
// 						if ((m_nObjectPositionNum == 2) && (m_nTargetPositionNum == 4))
// 						{
// 							// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 							if (m_bObjectPositionDirectionMode == 0)
// 							{
// 								dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
// 								if (dDegLx > 45)
// 								{
// 									dDegLx -= 90.0;
// 								}
// 							}
// 							else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 							{
// 								dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 							}
// 						}
// 					}
				}				

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos1234_123C1 == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);				

				svStd vector< sc2Vector > ptCenter;
				ptCenter.push_back(pt0);

				// 产品位置
				vProductPos = ptCenter.at(0);

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
				if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
				{
					bHorDirection = FALSE;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (bHorDirection)
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}
				else
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}

				// 产品角度
				degProductAngle = scDegree(dDegLx);
				
			}
			else if (eAlignerPos1234_124C2 == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);
				
				svStd vector< sc2Vector > ptCenter;
				ptCenter.push_back(pt1);

				// 产品位置
				vProductPos = ptCenter.at(0);

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt1,pt3);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
				if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
				{
					bHorDirection = FALSE;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (bHorDirection)
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}
				else
				{
					lineSeg.Set(pt1,pt3);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}
				
				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos1234_134C3 == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				svStd vector< sc2Vector > ptCenter;
				ptCenter.push_back(pt2);


				// 产品位置
				vProductPos = ptCenter.at(0);


				//各边的长度
				scLineSeg lineSeg01(pt2,pt3);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
				if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
				{
					bHorDirection = FALSE;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (bHorDirection)
				{
					lineSeg.Set(pt2,pt3);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}
				else
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos1234_234C4 == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				svStd vector< sc2Vector > ptCenter;
				ptCenter.push_back(pt3);

				// 产品位置
				vProductPos = ptCenter.at(0);

				//各边的长度
				scLineSeg lineSeg01(pt2,pt3);
				scLineSeg lineSeg02(pt1,pt3);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
				if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
				{
					bHorDirection = FALSE;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (bHorDirection)
				{
					lineSeg.Set(pt2,pt3);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}
				else
				{
					lineSeg.Set(pt1,pt3);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}
				
				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos1234_Combine == m_AlignermentParam.GetAligner4Vs4Type() 
					|| eAlignerPos1234_Combine_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type()
					|| eAlignerPos1234_Combine_Object_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type()
					|| eAlignerPos1234_Combine_Target_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type()
					||eAlignerPos1234_Center == m_AlignermentParam.GetAligner4Vs4Type())
			{

				// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				sc2Vector pt01 = (pt0 + pt1)/2;
				sc2Vector pt23 = (pt2 + pt3)/2;
				sc2Vector pt02 = (pt0 + pt2)/2;
				sc2Vector pt13 = (pt1 + pt3)/2;
				scLineSeg lineVer(pt01,pt23);
				scLineSeg lineHor(pt02,pt13);
				scLine lineV = lineVer.GetLine();
				scLine lineH = lineHor.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
					return FALSE;
				// 产品位置
				vProductPos = ptCenter.at(0);

				str.Format("产品中心=%f,%f",vProductPos.GetX(),vProductPos.GetY());
				AlignToolLogRecord(str, m_nPlatformIndex);
				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
				if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
				{
					bHorDirection = FALSE;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (bHorDirection)
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;

					// 根据对象产品尺寸计算虚拟点位置
// 					if (m_bEnableObjectPositionVirtualMode)
// 					{
// 						if ((m_nObjectPositionNum == 2) && (m_nTargetPositionNum == 4))
// 						{
// 							// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 							if (m_bObjectPositionDirectionMode == 0)
// 							{
// 								dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 							}
// 							else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 							{
// 								dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
// 							}
// 						}
// 					}
				}
				else
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
					// 根据对象产品尺寸计算虚拟点位置
// 					if (m_bEnableObjectPositionVirtualMode)
// 					{
// 						if ((m_nObjectPositionNum == 2) && (m_nTargetPositionNum == 4))
// 						{
// 							// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 							if (m_bObjectPositionDirectionMode == 0)
// 							{
// 								dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
// 								if (dDegLx > 45)
// 								{
// 									dDegLx -= 90.0;
// 								}
// 							}
// 							else if (m_bObjectPositionDirectionMode == 1)// 对象位置方向模式: 0：位置12水平；1：位置12竖直；
// 							{
// 								dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;    ///error???
// 							}
// 						}
// 					}
				}				

				// 产品角度
				degProductAngle = scDegree(dDegLx);
				str.Format("产品角度=%f",degProductAngle.ToDouble());
				AlignToolLogRecord(str, m_nPlatformIndex);
			}
			// 均方误差最小对位角度，均方误差最小（X1,Y1）+ 圆（X2,Y2）,根据权重系数计算（X,Y）
			else if ( (eAlignerPos1234_1234_Weight == m_AlignermentParam.GetAligner4Vs4Type()) )
			{
				// 圆权重为1，以圆为基准进行对位,以辅助圆为基准进行补偿
				if (m_AlignermentParam.m_dAlignerWeight == 1.0)
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
					double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
					double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
					double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
					double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
					double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

					double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
					double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
					double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
					double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
					double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
					double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

					double dCH2_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(0);
					double dCH2_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(0);
					double dCH2_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(1);
					double dCH2_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(1);
					double dCH2_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(2);
					double dCH2_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(2);

					double dCH3_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(0);
					double dCH3_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(0);
					double dCH3_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(1);
					double dCH3_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(1);
					double dCH3_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(2);
					double dCH3_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(2);


					svStd vector< sc2Vector > ptCenter;

					// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;
					BOOL bCH3_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					case 3:
						bCH3_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					// 圆辅助点坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));
					}

					// 圆辅助点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));
					}

					// 圆辅助点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2));
					}

					// 圆辅助点坐标在相机CH3中
					if (bCH3_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH3_AuxiliaryPosX2,dCH3_AuxiliaryPosY2));
					}

					vProductPos = ptCenter.at(0);




					//各边的长度
					scLineSeg lineSeg01(pt2,pt3);
					scLineSeg lineSeg02(pt1,pt3);

					double dlineSeg01Length = lineSeg01.Perimeter();	
					double dlineSeg02Length = lineSeg02.Perimeter();	
					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
					// 			AlignToolLogRecord(str,nPlatformIndex);

					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
					if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
					{
						bHorDirection = FALSE;
					}


					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg;
					double dDegLx = 0;
					if (bHorDirection)
					{
						lineSeg.Set(pt2,pt3);
						Lx.SetFromLineSeg(lineSeg);
						dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
					}
					else
					{
						lineSeg.Set(pt1,pt3);
						Lx.SetFromLineSeg(lineSeg);
						dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
						if (dDegLx > 45)
						{
							dDegLx -= 90.0;
						}
					}

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else
				{
					// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					scLineSeg lineSeg12(pt1, pt2);
					scLineSeg lineSeg03(pt0, pt3);
					scLine line12 = lineSeg12.GetLine();
					scLine line03 = lineSeg03.GetLine();

					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(line03,line12,IsInterSect,ptCenter))
						return FALSE;

					// 产品位置
					vProductPos = ptCenter.at(0);


					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);

					double dlineSeg01Length = lineSeg01.Perimeter();	
					double dlineSeg02Length = lineSeg02.Perimeter();	
					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
					// 			AlignToolLogRecord(str,nPlatformIndex);

					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
					if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
					{
						bHorDirection = FALSE;
					}


					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg;
					double dDegLx = 0;
					if (bHorDirection)
					{
						lineSeg.Set(pt0,pt1);
						Lx.SetFromLineSeg(lineSeg);
						dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
					}
					else
					{
						lineSeg.Set(pt0,pt2);
						Lx.SetFromLineSeg(lineSeg);
						dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
						if (dDegLx > 45)
						{
							dDegLx -= 90.0;
						}
					}				

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}

			}
			// 长边对位角度，四个位置组合构成直线，四边中点（X1,Y1）+ 圆（X2,Y2），根据权重系数计算（X,Y）
			else if ((eAlignerPos1234_Combine_Weight == m_AlignermentParam.GetAligner4Vs4Type()))
			{
				// 圆权重为1，以圆为基准进行对位,以辅助圆为基准进行补偿
				if (m_AlignermentParam.m_dAlignerWeight == 1.0)
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
					double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
					double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
					double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
					double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
					double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

					double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
					double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
					double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
					double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
					double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
					double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

					double dCH2_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(0);
					double dCH2_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(0);
					double dCH2_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(1);
					double dCH2_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(1);
					double dCH2_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(2);
					double dCH2_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(2);

					double dCH3_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(0);
					double dCH3_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(0);
					double dCH3_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(1);
					double dCH3_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(1);
					double dCH3_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(2);
					double dCH3_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(2);


					svStd vector< sc2Vector > ptCenter;

					// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;
					BOOL bCH3_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					case 3:
						bCH3_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					// 圆辅助点坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));
					}

					// 圆辅助点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));
					}

					// 圆辅助点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2));
					}

					// 圆辅助点坐标在相机CH3中
					if (bCH3_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH3_AuxiliaryPosX2,dCH3_AuxiliaryPosY2));
					}

					vProductPos = ptCenter.at(0);




					//各边的长度
					scLineSeg lineSeg01(pt2,pt3);
					scLineSeg lineSeg02(pt1,pt3);

					double dlineSeg01Length = lineSeg01.Perimeter();	
					double dlineSeg02Length = lineSeg02.Perimeter();	
					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
					// 			AlignToolLogRecord(str,nPlatformIndex);

					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
					if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
					{
						bHorDirection = FALSE;
					}


					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg;
					double dDegLx = 0;
					if (bHorDirection)
					{
						lineSeg.Set(pt2,pt3);
						Lx.SetFromLineSeg(lineSeg);
						dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
					}
					else
					{
						lineSeg.Set(pt1,pt3);
						Lx.SetFromLineSeg(lineSeg);
						dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
						if (dDegLx > 45)
						{
							dDegLx -= 90.0;
						}
					}

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else
				{
					// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					sc2Vector pt01 = (pt0 + pt1)/2;
					sc2Vector pt23 = (pt2 + pt3)/2;
					sc2Vector pt02 = (pt0 + pt2)/2;
					sc2Vector pt13 = (pt1 + pt3)/2;
					scLineSeg lineVer(pt01,pt23);
					scLineSeg lineHor(pt02,pt13);
					scLine lineV = lineVer.GetLine();
					scLine lineH = lineHor.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
						return FALSE;
					// 产品位置
					vProductPos = ptCenter.at(0);

					str.Format("产品中心=%f,%f",vProductPos.GetX(),vProductPos.GetY());
					AlignToolLogRecord(str, m_nPlatformIndex);
					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);

					double dlineSeg01Length = lineSeg01.Perimeter();	
					double dlineSeg02Length = lineSeg02.Perimeter();	
					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
					// 			AlignToolLogRecord(str,nPlatformIndex);

					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
					if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
					{
						bHorDirection = FALSE;
					}


					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg;
					double dDegLx = 0;
					if (bHorDirection)
					{
						lineSeg.Set(pt0,pt1);
						Lx.SetFromLineSeg(lineSeg);
						dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
					}
					else
					{
						lineSeg.Set(pt0,pt2);
						Lx.SetFromLineSeg(lineSeg);
						dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
						if (dDegLx > 45)
						{
							dDegLx -= 90.0;
						}
					}				

					// 产品角度
					degProductAngle = scDegree(dDegLx);
					str.Format("产品角度=%f",degProductAngle.ToDouble());
					AlignToolLogRecord(str, m_nPlatformIndex);
				}

			}
			else if (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_56_4V2)
			{
				//if (m_bAlignerPos1234_56_Object)
				{
					// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					sc2Vector pt01 = (pt0 + pt1)/2;
					sc2Vector pt23 = (pt2 + pt3)/2;
					sc2Vector pt02 = (pt0 + pt2)/2;
					sc2Vector pt13 = (pt1 + pt3)/2;
					scLineSeg lineVer(pt01,pt23);
					scLineSeg lineHor(pt02,pt13);
					scLine lineV = lineVer.GetLine();
					scLine lineH = lineHor.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
						return FALSE;
					// 产品位置
					vProductPos = ptCenter.at(0);

					double dDegLx = 0;

					{
						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg23(pt2,pt3);

						scLine line01;
						scLine line23;

						line01.SetFromLineSeg(lineSeg01);
						line23.SetFromLineSeg(lineSeg23);

						dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();

					}

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
			}
		}
		else
		{
			return  FALSE;
		}

		return TRUE;
	}

	//m_iMarkNum为mark数量
	if (1 == m_iMarkNum)
	{
		CString str;
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;

		// 产品位置
		vProductPos = sc2Vector(dCH0X, dCH0Y);

		// 产品角度:暂时认为产品角度是0°，后续可根据实际情况增加对位模式
		degProductAngle = scDegree(0);
	}
	else if (2 == m_iMarkNum)
	{
		CString str;
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;

		// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);

		if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto || m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_CTo3
			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12
			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
		{				
			// 旋转中心
			double dRotationCenterX, dRotationCenterY;
			dRotationCenterX = (dCH0X + dCH1X)/2.0;
			dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

			// 产品位置
			vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());
		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1)
		{
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);

			// 产品位置
			vProductPos = pt0;

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());

		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2)
		{
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);

			// 产品位置
			vProductPos = pt1;

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());
		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1L2)
		{
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);

			// 产品位置
			vProductPos = pt0;

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());
		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2L1)
		{
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);

			// 产品位置
			vProductPos = pt1;

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());

		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2)
		{
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);

			// 产品位置
			vProductPos = pt0;

			// 构造实时mark对直线Lx
			scLine Lx;
			sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
			sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
			scLineSeg lineSeg(ptStart, ptEnd);
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());
		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1)
		{
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);

			// 产品位置
			vProductPos = pt1;

			// 构造实时mark对直线Lx
			scLine Lx;
			sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
			sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
			scLineSeg lineSeg(ptStart, ptEnd);
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());
		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1)
		{

			sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
			sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
			sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
			sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
			scLineSeg lineSeg0(pt00, pt01);
			scLineSeg lineSeg1(pt10, pt11);
			scLine line0 = lineSeg0.GetLine();
			scLine line1 = lineSeg1.GetLine();
			svStd vector< sc2Vector > ptCenter;
			bool IsInterSect = true;
			if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
				return FALSE;

			// 产品位置
			vProductPos = ptCenter.at(0);

			// 构造实时mark对直线Lx
			scLine Lx;
			sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
			sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
			scLineSeg lineSeg(ptStart, ptEnd);
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());

		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
		{
			sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
			sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
			sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
			sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
			scLineSeg lineSeg0(pt00, pt01);
			scLineSeg lineSeg1(pt10, pt11);
			scLine line0 = lineSeg0.GetLine();
			scLine line1 = lineSeg1.GetLine();
			svStd vector< sc2Vector > ptCenter;
			bool IsInterSect = true;
			if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
				return FALSE;

			// 产品位置
			vProductPos = ptCenter.at(0);

			// 构造实时mark对直线Lx
			scLine Lx;
			sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
			sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
			scLineSeg lineSeg(ptStart, ptEnd);
			Lx.SetFromLineSeg(lineSeg);

			// 产品角度
			degProductAngle = scDegree(Lx.GetRotation());
		}
		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto_Weigth  // jjh0619
			||m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1_Weigth
			||m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2_Weigth)//
		{
			//圆权重为1  以圆心为基准对位  以辅助圆为基准进行补偿
			if (m_AlignermentParam.m_dAlignerWeight == 1.0)
			{
				// 旋转中心

				double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
				double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
				double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
				double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
				double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
				double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

				double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
				double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
				double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
				double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
				double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
				double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

				svStd vector< sc2Vector > ptCenter;

				// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}

				// 圆辅助点坐标在相机CH0中
				if (bCH0_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}

				// 圆辅助点坐标在相机CH1中
				if (bCH1_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
			}
			else
			{
				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto_Weigth)
				{
					// 旋转中心(点12组成的线段中点是旋转中心)
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH0X + dCH1X)/2.0;
					dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1_Weigth)
				{
					// 旋转中心(点1是旋转中心)
					// 产品位置
					vProductPos = sc2Vector(dCH0X, dCH0Y);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2_Weigth)
				{
					// 旋转中心(点2是旋转中心)
					// 产品位置
					vProductPos = sc2Vector(dCH1X, dCH1Y);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}

			}
		}

	}
	else if (3 == m_iMarkNum)
	{				
		CString str;
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
		double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;

		// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);

		if (eAlignerPos123_Auto == m_AlignermentParam.GetAligner3Vs3Type())
		{

			// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector ptCenter = (pt0 + pt1 + pt2) / 3;

			// 产品位置
			vProductPos = ptCenter;

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);
			scLineSeg lineSeg12(pt1,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			double dlineSeg12Length = lineSeg12.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (dlineSeg02Length > dlineSeg01Length*1.1)
			{
				lineSeg.Set(pt0,pt2);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}
			else
			{
				lineSeg.Set(pt0,pt1);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (eAlignerPos123_123C1 == m_AlignermentParam.GetAligner3Vs3Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector ptCenter = pt0;

			// 产品位置
			vProductPos = ptCenter;

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);
			scLineSeg lineSeg12(pt1,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			double dlineSeg12Length = lineSeg12.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (dlineSeg02Length > dlineSeg01Length*1.1)
			{
				lineSeg.Set(pt0,pt2);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}
			else
			{
				lineSeg.Set(pt0,pt1);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}

			// 产品角度
			degProductAngle = scDegree(dDegLx);

		}
		else if (eAlignerPos123_123C2 == m_AlignermentParam.GetAligner3Vs3Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector ptCenter = pt1;

			// 产品位置
			vProductPos = ptCenter;

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);
			scLineSeg lineSeg12(pt1,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			double dlineSeg12Length = lineSeg12.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (dlineSeg02Length > dlineSeg01Length*1.1)
			{
				lineSeg.Set(pt0,pt2);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}
			else
			{
				lineSeg.Set(pt0,pt1);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (eAlignerPos123_123C3 == m_AlignermentParam.GetAligner3Vs3Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector ptCenter = pt2;

			// 产品位置
			vProductPos = ptCenter;

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);
			scLineSeg lineSeg12(pt1,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			double dlineSeg12Length = lineSeg12.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (dlineSeg02Length > dlineSeg01Length*1.1)
			{
				lineSeg.Set(pt0,pt2);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}
			else
			{
				lineSeg.Set(pt0,pt1);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (eAlignerPos123_123C13L12 == m_AlignermentParam.GetAligner3Vs3Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector ptCenter = (pt0 + pt2)/2;

			// 产品位置
			vProductPos = ptCenter;

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);
			scLineSeg lineSeg12(pt1,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			double dlineSeg12Length = lineSeg12.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			lineSeg.Set(pt0,pt1);


			Lx.SetFromLineSeg(lineSeg);
			double dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (eAlignerPos123_123C13AL12 == m_AlignermentParam.GetAligner3Vs3Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector ptCenter = (pt0 + pt2)/2;

			// 产品位置
			vProductPos = ptCenter;

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	


			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			lineSeg.Set(pt0,pt1);


			Lx.SetFromLineSeg(lineSeg);
			double dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (eAlignerPos123_123C2L13 == m_AlignermentParam.GetAligner3Vs3Type() || eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector ptCenter = (pt1 + pt1)/2;

			// 产品位置
			vProductPos = ptCenter;

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			lineSeg.Set(pt0,pt2);


			Lx.SetFromLineSeg(lineSeg);

			double dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
			dDegLx -= 90;

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		//jjh0618
		else if (eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type()  
			||eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
			||eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())  //jjh0612
		{
			// 圆权重为1，以圆为基准进行对位,以圆为基准进行补偿
			if (m_AlignermentParam.m_dAlignerWeight == 1.0)
			{
				svStd vector< sc2Vector > ptCenter;
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}
				// 圆心坐标在相机CH0中
				if (bCH0_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}

				// 圆点坐标在相机CH1中
				if (bCH1_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				// 圆点坐标在相机CH2中
				if (bCH2_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
			}
			else 
			{
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}
				if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_Auto_Weigth)//以两角点中心为基准进行补偿
				{

					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH1X + dCH2X)/2.0;
						dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH2X)/2.0;
						dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

				}
				else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C1_Weigth) //角点1为基准进行补偿
				{
					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH1X, dCH1Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH0X, dCH0Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH0X, dCH0Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C2_Weigth)//角点2为基准进行补偿
				{
					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH2X, dCH2Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH2X, dCH2Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH1X, dCH1Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
			}

		}
	}
	else if (4 == m_iMarkNum)
	{
		CString str;
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
		double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;
		double dCH3X = vObjectPlatformCoordPos.at(3).m_dPosX;
		double dCH3Y = vObjectPlatformCoordPos.at(3).m_dPosY;

		// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(3).m_dPosX=%f, vObjectPlatformCoordPos.at(3).m_dPosY=%f", vObjectPlatformCoordPos.at(3).m_dPosX, vObjectPlatformCoordPos.at(3).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);

		if (eAlignerPos1234_Auto == m_AlignermentParam.GetAligner4Vs4Type()|| eAlignerPos1234_Center == m_AlignermentParam.GetAligner4Vs4Type())
		{
// 			if (m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align)  // PCB 定制
// 			{	
// 				str.Format("use PCB 定制 ");
// 				AlignToolLogRecord(str,m_nPlatformIndex);
// 				 // 四点对四点；
// 				if (eAligner1234_1234 == m_PointMethodType)
// 				{
// 					str.Format("use eAligner1234_1234 ");
// 					AlignToolLogRecord(str,m_nPlatformIndex);
// 					// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
// 					sc2Vector pt0(dCH0X, dCH0Y);
// 					sc2Vector pt1(dCH1X, dCH1Y);
// 					sc2Vector pt2(dCH2X, dCH2Y);
// 					sc2Vector pt3(dCH3X, dCH3Y);
// 					sc2Vector pt01 = (pt0 + pt1)/2;
// 					sc2Vector pt23 = (pt2 + pt3)/2;
// 					sc2Vector pt02 = (pt0 + pt2)/2;
// 					sc2Vector pt13 = (pt1 + pt3)/2;
// 
// 					scLineSeg lineVer(pt01,pt23);
// 					scLineSeg lineHor(pt02,pt13);
// 					scLine lineV = lineVer.GetLine();
// 					scLine lineH = lineHor.GetLine();
// 
// 					svStd vector< sc2Vector > ptCenter;
// 					bool IsInterSect = true;
// 					if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
// 						return FALSE;
// 					// 旋转中心
// 					vProductPos = ptCenter.at(0);
// 
// 
// 					//各边的长度
// 					scLineSeg lineSeg01(pt0,pt1);
// 					scLineSeg lineSeg02(pt0,pt2);
// 					double dlineSeg01Length = lineSeg01.Perimeter();	
// 					double dlineSeg02Length = lineSeg02.Perimeter();	
// 					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 					// 			AlignToolLogRecord(str,nPlatformIndex);
// 					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 					if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 					{
// 						bHorDirection = FALSE;
// 					}
// 
// 					// 长边均值为角度；
// 					double dDegLx = 0;
// 					if (bHorDirection)
// 					{
// 						scLineSeg lineSeg01(pt0,pt1);
// 						scLineSeg lineSeg23(pt2,pt3);
// 						scLine line01;
// 						scLine line23;
// 						line01.SetFromLineSeg(lineSeg01);
// 						line23.SetFromLineSeg(lineSeg23);
// 						dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();
// 					}else
// 					{
// 						scLineSeg lineSeg02(pt0,pt2);
// 						scLineSeg lineSeg13(pt1,pt3);
// 						scLine line02;
// 						scLine line13;
// 						line02.SetFromLineSeg(lineSeg02);
// 						line13.SetFromLineSeg(lineSeg13);
// 						dDegLx = (scDegree((line02.GetRotation() + line13.GetRotation())/2)).SignedNorm().ToDouble();
// 					}
// 					// 产品角度
// 					degProductAngle = scDegree(dDegLx);
// 
// 				}
// 				// 2、3、4点组成的三角形中点为旋转中心，单长边为角度
// 				else if (eAligner234_234 == m_PointMethodType) 
// 				{
// 					str.Format("use eAligner234_234 ");
// 					AlignToolLogRecord(str,m_nPlatformIndex);
// 					// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
// 					sc2Vector pt0(dCH0X, dCH0Y);
// 					sc2Vector pt1(dCH1X, dCH1Y);
// 					sc2Vector pt2(dCH2X, dCH2Y);
// 					sc2Vector pt3(dCH3X, dCH3Y);
// 					sc2Vector ptCenter = (pt1 + pt2 + pt3)/3;					
// 					// 旋转中心
// 					vProductPos = ptCenter;
// 
// 
// 					//各边的长度
// 					scLineSeg lineSeg31(pt3,pt1);
// 					scLineSeg lineSeg32(pt3,pt2);
// 					double dlineSeg31Length = lineSeg31.Perimeter();	
// 					double dlineSeg32Length = lineSeg32.Perimeter();	
// 					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 					// 			AlignToolLogRecord(str,nPlatformIndex);
// 					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 					if (dlineSeg31Length > dlineSeg32Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 					{
// 						bHorDirection = FALSE;
// 					}
// 
// 					// 长边均值为角度；
// 					double dDegLx = 0;
// 					if (bHorDirection) // 2、3为长边
// 					{
// 						scLineSeg lineSeg23(pt2,pt3);
// 						scLine line23;
// 						line23.SetFromLineSeg(lineSeg23);
// 						dDegLx = (line23.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 					}else  // 1、3为长边
// 					{
// 						scLineSeg lineSeg13(pt1,pt3);
// 						scLine line13;
// 						line13.SetFromLineSeg(lineSeg13);
// 						dDegLx = (line13.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 					}
// 					// 产品角度
// 					degProductAngle = scDegree(dDegLx);	
// 				}
// 				// 1、3、4点组成的三角形中点为旋转中心，单长边为角度
// 				else if (eAligner134_134 == m_PointMethodType) 
// 				{
// 					str.Format("use eAligner134_134 ");
// 					AlignToolLogRecord(str,m_nPlatformIndex);
// 					// 旋转中心
// 					sc2Vector pt0(dCH0X, dCH0Y);
// 					sc2Vector pt1(dCH1X, dCH1Y);
// 					sc2Vector pt2(dCH2X, dCH2Y);
// 					sc2Vector pt3(dCH3X, dCH3Y);
// 					sc2Vector ptCenter = (pt0 + pt2 + pt3)/3;					
// 					// 旋转中心
// 					vProductPos = ptCenter;
// 
// 
// 					//各边的长度
// 					scLineSeg lineSeg20(pt3,pt1);
// 					scLineSeg lineSeg23(pt3,pt2);
// 					double dlineSeg20Length = lineSeg20.Perimeter();	
// 					double dlineSeg23Length = lineSeg23.Perimeter();	
// 					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 					// 			AlignToolLogRecord(str,nPlatformIndex);
// 					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 					if (dlineSeg20Length > dlineSeg23Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 					{
// 						bHorDirection = FALSE;
// 					}
// 
// 					// 长边均值为角度；
// 					double dDegLx = 0;
// 					if (bHorDirection) // 2、3为长边
// 					{
// 						scLineSeg lineSeg23(pt2,pt3);
// 						scLine line23;
// 						line23.SetFromLineSeg(lineSeg23);
// 						dDegLx = (line23.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 					}else  // 0、2为长边
// 					{
// 						scLineSeg lineSeg02(pt0,pt2);
// 						scLine line02;
// 						line02.SetFromLineSeg(lineSeg02);
// 						dDegLx = (line02.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 					}
// 					// 产品角度
// 					degProductAngle = scDegree(dDegLx);	
// 
// 				}
// 				//  1、2、4点组成的三角形中点为旋转中心，单长边为角度
// 				else if (eAligner124_124 == m_PointMethodType)
// 				{
// 					str.Format("use eAligner124_124 ");
// 					AlignToolLogRecord(str,m_nPlatformIndex);
// 					// 旋转中心
// 					sc2Vector pt0(dCH0X, dCH0Y);
// 					sc2Vector pt1(dCH1X, dCH1Y);
// 					sc2Vector pt2(dCH2X, dCH2Y);
// 					sc2Vector pt3(dCH3X, dCH3Y);
// 					sc2Vector ptCenter = (pt0 + pt1 + pt3)/3;					
// 					// 旋转中心
// 					vProductPos = ptCenter;
// 
// 
// 					//各边的长度
// 					scLineSeg lineSeg10(pt0,pt1);
// 					scLineSeg lineSeg13(pt3,pt1);
// 					double dlineSeg10Length = lineSeg10.Perimeter();	
// 					double dlineSeg13Length = lineSeg13.Perimeter();	
// 					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 					// 			AlignToolLogRecord(str,nPlatformIndex);
// 					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 					if (dlineSeg13Length > dlineSeg10Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 					{
// 						bHorDirection = FALSE;
// 					}
// 
// 					// 长边均值为角度；
// 					double dDegLx = 0;
// 					if (bHorDirection) // 0、1为长边
// 					{
// 						scLineSeg lineSeg01(pt0,pt1);
// 						scLine line01;
// 						line01.SetFromLineSeg(lineSeg01);
// 						dDegLx = (line01.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 					}else  // 1、3为长边
// 					{
// 						scLineSeg lineSeg13(pt1,pt3);
// 						scLine line13;
// 						line13.SetFromLineSeg(lineSeg13);
// 						dDegLx = (line13.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 					}
// 					// 产品角度
// 					degProductAngle = scDegree(dDegLx);	
// 				}
// 				//  1、2、3点组成的三角形中点为旋转中心，单长边为角度
// 				else if (eAligner123_123 == m_PointMethodType)
// 				{
// 					str.Format("use eAligner123_123 ");
// 					AlignToolLogRecord(str,m_nPlatformIndex);
// 					// 旋转中心
// 					sc2Vector pt0(dCH0X, dCH0Y);
// 					sc2Vector pt1(dCH1X, dCH1Y);
// 					sc2Vector pt2(dCH2X, dCH2Y);
// 					sc2Vector pt3(dCH3X, dCH3Y);
// 					sc2Vector ptCenter = (pt0 + pt1 + pt2)/3;					
// 					// 旋转中心
// 					vProductPos = ptCenter;
// 
// 
// 					//各边的长度
// 					scLineSeg lineSeg01(pt0,pt1);
// 					scLineSeg lineSeg02(pt0,pt2);
// 					double dlineSeg01Length = lineSeg01.Perimeter();	
// 					double dlineSeg02Length = lineSeg02.Perimeter();	
// 					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 					// 			AlignToolLogRecord(str,nPlatformIndex);
// 					BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 					if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 					{
// 						bHorDirection = FALSE;
// 					}
// 
// 					// 长边均值为角度；
// 					double dDegLx = 0;
// 					if (bHorDirection) // 0、1为长边
// 					{
// 						scLineSeg lineSeg01(pt0,pt1);
// 						scLine line01;
// 						line01.SetFromLineSeg(lineSeg01);
// 						dDegLx = (line01.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 					}else  // 0、2为长边
// 					{
// 						scLineSeg lineSeg02(pt0,pt2);
// 						scLine line02;
// 						line02.SetFromLineSeg(lineSeg02);
// 						dDegLx = (line02.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 					}
// 					// 产品角度
// 					degProductAngle = scDegree(dDegLx);	
// 				}
// 
// 			}
// 			else
			{
			    // 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
			    sc2Vector pt0(dCH0X, dCH0Y);
			    sc2Vector pt1(dCH1X, dCH1Y);
			    sc2Vector pt2(dCH2X, dCH2Y);
			    sc2Vector pt3(dCH3X, dCH3Y);
			    scLineSeg lineSeg12(pt1, pt2);
			    scLineSeg lineSeg03(pt0, pt3);
			    scLine line12 = lineSeg12.GetLine();
			    scLine line03 = lineSeg03.GetLine();
			    svStd vector< sc2Vector > ptCenter;
			    bool IsInterSect = true;
			    if (false == sfInterSectLineLine(line03,line12,IsInterSect,ptCenter))
				    return FALSE;

			    // 产品位置
			    vProductPos = ptCenter.at(0);


			    //各边的长度
			    scLineSeg lineSeg01(pt0,pt1);
			    scLineSeg lineSeg02(pt0,pt2);

			    double dlineSeg01Length = lineSeg01.Perimeter();	
			    double dlineSeg02Length = lineSeg02.Perimeter();	
			    // 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
			    // 			AlignToolLogRecord(str,nPlatformIndex);

			    BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
			    if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
			    {
			    	bHorDirection = FALSE;
			    }


			    // 构造实时mark对直线Lx
			    scLine Lx;
			    scLineSeg lineSeg;
			    double dDegLx = 0;
			    if (bHorDirection)
			    {
			    	lineSeg.Set(pt0,pt1);
			    	Lx.SetFromLineSeg(lineSeg);
			    	dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			    }
			    else
			    {
			    	lineSeg.Set(pt0,pt2);
			    	Lx.SetFromLineSeg(lineSeg);
			    	dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
			    	if (dDegLx > 45)
				    {
				    	dDegLx -= 90.0;
				    }
			    }				

			     // 产品角度
			    degProductAngle = scDegree(dDegLx);
            }
		}
		else if (eAlignerPos1234_123C1 == m_AlignermentParam.GetAligner4Vs4Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector pt3(dCH3X, dCH3Y);				

			svStd vector< sc2Vector > ptCenter;
			ptCenter.push_back(pt0);

			// 产品位置
			vProductPos = ptCenter.at(0);

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
			if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
			{
				bHorDirection = FALSE;
			}


			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (bHorDirection)
			{
				lineSeg.Set(pt0,pt1);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}
			else
			{
				lineSeg.Set(pt0,pt2);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}

			// 产品角度
			degProductAngle = scDegree(dDegLx);

		}
		else if (eAlignerPos1234_124C2 == m_AlignermentParam.GetAligner4Vs4Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector pt3(dCH3X, dCH3Y);

			svStd vector< sc2Vector > ptCenter;
			ptCenter.push_back(pt1);

			// 产品位置
			vProductPos = ptCenter.at(0);

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt1,pt3);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
			if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
			{
				bHorDirection = FALSE;
			}


			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (bHorDirection)
			{
				lineSeg.Set(pt0,pt1);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}
			else
			{
				lineSeg.Set(pt1,pt3);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (eAlignerPos1234_134C3 == m_AlignermentParam.GetAligner4Vs4Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector pt3(dCH3X, dCH3Y);

			svStd vector< sc2Vector > ptCenter;
			ptCenter.push_back(pt2);


			// 产品位置
			vProductPos = ptCenter.at(0);


			//各边的长度
			scLineSeg lineSeg01(pt2,pt3);
			scLineSeg lineSeg02(pt0,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
			if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
			{
				bHorDirection = FALSE;
			}


			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (bHorDirection)
			{
				lineSeg.Set(pt2,pt3);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}
			else
			{
				lineSeg.Set(pt0,pt2);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (eAlignerPos1234_234C4 == m_AlignermentParam.GetAligner4Vs4Type())
		{
			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector pt3(dCH3X, dCH3Y);

			svStd vector< sc2Vector > ptCenter;
			ptCenter.push_back(pt3);

			// 产品位置
			vProductPos = ptCenter.at(0);

			//各边的长度
			scLineSeg lineSeg01(pt2,pt3);
			scLineSeg lineSeg02(pt1,pt3);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
			if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
			{
				bHorDirection = FALSE;
			}


			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (bHorDirection)
			{
				lineSeg.Set(pt2,pt3);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}
			else
			{
				lineSeg.Set(pt1,pt3);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (eAlignerPos1234_Combine == m_AlignermentParam.GetAligner4Vs4Type() 
				|| eAlignerPos1234_Combine_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type()
				|| eAlignerPos1234_Combine_Target_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type()
				|| eAlignerPos1234_Center == m_AlignermentParam.GetAligner4Vs4Type())
		{

			// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector pt3(dCH3X, dCH3Y);

			sc2Vector pt01 = (pt0 + pt1)/2;
			sc2Vector pt23 = (pt2 + pt3)/2;
			sc2Vector pt02 = (pt0 + pt2)/2;
			sc2Vector pt13 = (pt1 + pt3)/2;
			scLineSeg lineVer(pt01,pt23);
			scLineSeg lineHor(pt02,pt13);
			scLine lineV = lineVer.GetLine();
			scLine lineH = lineHor.GetLine();
			svStd vector< sc2Vector > ptCenter;
			bool IsInterSect = true;
			if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
				return FALSE;
			// 产品位置
			vProductPos = ptCenter.at(0);
			str.Format("产品中心=%f,%f",vProductPos.GetX(),vProductPos.GetY());
			AlignToolLogRecord(str, m_nPlatformIndex);

			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
			if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
			{
				bHorDirection = FALSE;
			}


			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (bHorDirection)
			{
				lineSeg.Set(pt0,pt1);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}
			else
			{
				lineSeg.Set(pt0,pt2);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}				

			// 产品角度
			degProductAngle = scDegree(dDegLx);

			str.Format("产品角度=%f",degProductAngle.ToDouble());
			AlignToolLogRecord(str, m_nPlatformIndex);
		}
		else if (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_56_4V2)
		{
			//if (m_bAlignerPos1234_56_Object)
			{
				// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				sc2Vector pt01 = (pt0 + pt1)/2;
				sc2Vector pt23 = (pt2 + pt3)/2;
				sc2Vector pt02 = (pt0 + pt2)/2;
				sc2Vector pt13 = (pt1 + pt3)/2;
				scLineSeg lineVer(pt01,pt23);
				scLineSeg lineHor(pt02,pt13);
				scLine lineV = lineVer.GetLine();
				scLine lineH = lineHor.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
					return FALSE;
				// 产品位置
				vProductPos = ptCenter.at(0);

				double dDegLx = 0;

				{
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg23(pt2,pt3);

					scLine line01;
					scLine line23;

					line01.SetFromLineSeg(lineSeg01);
					line23.SetFromLineSeg(lineSeg23);

					dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();

				}

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
		}
		//////////////iyo
		// 长边对位角度，四个位置组合构成直线，四边中点（X1,Y1）+ 圆（X2,Y2），根据权重系数计算（X,Y）
		else if ((eAlignerPos1234_Combine_Weight == m_AlignermentParam.GetAligner4Vs4Type()))
		{
			// 圆权重为1，以圆为基准进行对位,以辅助圆为基准进行补偿
			if (m_AlignermentParam.m_dAlignerWeight == 1.0)
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
				double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
				double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
				double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
				double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
				double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

				double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
				double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
				double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
				double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
				double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
				double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

				double dCH2_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(0);
				double dCH2_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(0);
				double dCH2_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(1);
				double dCH2_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(1);
				double dCH2_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(2);
				double dCH2_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(2);

				double dCH3_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(0);
				double dCH3_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(0);
				double dCH3_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(1);
				double dCH3_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(1);
				double dCH3_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(2);
				double dCH3_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(2);


				svStd vector< sc2Vector > ptCenter;

				// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;
				BOOL bCH3_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				case 3:
					bCH3_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}

				// 圆辅助点坐标在相机CH0中
				if (bCH0_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));
				}

				// 圆辅助点坐标在相机CH1中
				if (bCH1_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));
				}

				// 圆辅助点坐标在相机CH2中
				if (bCH2_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2));
				}

				// 圆辅助点坐标在相机CH3中
				if (bCH3_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH3_AuxiliaryPosX2,dCH3_AuxiliaryPosY2));
				}

				vProductPos = ptCenter.at(0);

				//各边的长度
				scLineSeg lineSeg01(pt2,pt3);
				scLineSeg lineSeg02(pt1,pt3);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
				if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
				{
					bHorDirection = FALSE;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (bHorDirection)
				{
					lineSeg.Set(pt2,pt3);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}
				else
				{
					lineSeg.Set(pt1,pt3);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else
			{
				// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				sc2Vector pt01 = (pt0 + pt1)/2;
				sc2Vector pt23 = (pt2 + pt3)/2;
				sc2Vector pt02 = (pt0 + pt2)/2;
				sc2Vector pt13 = (pt1 + pt3)/2;
				scLineSeg lineVer(pt01,pt23);
				scLineSeg lineHor(pt02,pt13);
				scLine lineV = lineVer.GetLine();
				scLine lineH = lineHor.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
					return FALSE;
				// 产品位置
				vProductPos = ptCenter.at(0);

				str.Format("11111产品中心=%f,%f",vProductPos.GetX(),vProductPos.GetY());
				AlignToolLogRecord(str, m_nPlatformIndex);
				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
				if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
				{
					bHorDirection = FALSE;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				double dDegLx = 0;
				if (bHorDirection)
				{
					lineSeg.Set(pt0,pt1);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
				}
				else
				{
					lineSeg.Set(pt0,pt2);
					Lx.SetFromLineSeg(lineSeg);
					dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
					if (dDegLx > 45)
					{
						dDegLx -= 90.0;
					}
				}				

				// 产品角度
				degProductAngle = scDegree(dDegLx);
				str.Format("产品角度=%f",degProductAngle.ToDouble());
				AlignToolLogRecord(str, m_nPlatformIndex);
			}

		}
		///////////////////////
		else
		{
			//其它情况用旋转中心；
			// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector pt3(dCH3X, dCH3Y);
			scLineSeg lineSeg12(pt1, pt2);
			scLineSeg lineSeg03(pt0, pt3);
			scLine line12 = lineSeg12.GetLine();
			scLine line03 = lineSeg03.GetLine();
			svStd vector< sc2Vector > ptCenter;
			bool IsInterSect = true;
			if (false == sfInterSectLineLine(line03,line12,IsInterSect,ptCenter))
				return FALSE;

			// 产品位置
			vProductPos = ptCenter.at(0);


			//各边的长度
			scLineSeg lineSeg01(pt0,pt1);
			scLineSeg lineSeg02(pt0,pt2);

			double dlineSeg01Length = lineSeg01.Perimeter();	
			double dlineSeg02Length = lineSeg02.Perimeter();	
			// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
			if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
			{
				bHorDirection = FALSE;
			}


			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg;
			double dDegLx = 0;
			if (bHorDirection)
			{
				lineSeg.Set(pt0,pt1);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
			}
			else
			{
				lineSeg.Set(pt0,pt2);
				Lx.SetFromLineSeg(lineSeg);
				dDegLx = (Lx.GetRotation().NormMod180()).ToDouble()*180.0/skPI;
				if (dDegLx > 45)
				{
					dDegLx -= 90.0;
				}
			}				

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
	}
	else if (5 == m_iMarkNum)
	{
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
		double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;
		double dCH3X = vObjectPlatformCoordPos.at(3).m_dPosX;
		double dCH3Y = vObjectPlatformCoordPos.at(3).m_dPosY;
		double dCH4X = vObjectPlatformCoordPos.at(4).m_dPosX;
		double dCH4Y = vObjectPlatformCoordPos.at(4).m_dPosY;


		// 旋转中心
		sc2Vector pt0(dCH0X, dCH0Y);
		sc2Vector pt1(dCH1X, dCH1Y);
		sc2Vector pt2(dCH2X, dCH2Y);
		sc2Vector pt3(dCH3X, dCH3Y);
		sc2Vector pt4(dCH4X, dCH4Y);
		scLineSeg lineSeg23(pt2, pt3);

		scLine line23 = lineSeg23.GetLine();
		sc2Vector ptCenter = line23.Project(pt4);

		// 产品位置
		vProductPos = ptCenter;

		// 构造实时mark对直线Lx
		scLine Lx;
		scLineSeg lineSeg( sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH3X, dCH3Y));
		Lx.SetFromLineSeg(lineSeg);
		double dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;

		// 产品角度
		degProductAngle = scDegree(dDegLx);
	}
	else if (6 == m_iMarkNum)
	{
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
		double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;
		double dCH3X = vObjectPlatformCoordPos.at(3).m_dPosX;
		double dCH3Y = vObjectPlatformCoordPos.at(3).m_dPosY;
		double dCH4X = vObjectPlatformCoordPos.at(4).m_dPosX;
		double dCH4Y = vObjectPlatformCoordPos.at(4).m_dPosY;
		double dCH5X = vObjectPlatformCoordPos.at(5).m_dPosX;
		double dCH5Y = vObjectPlatformCoordPos.at(5).m_dPosY;

		
		// 旋转中心)
		sc2Vector pt0(dCH0X, dCH0Y);
		sc2Vector pt1(dCH1X, dCH1Y);
		sc2Vector pt2(dCH2X, dCH2Y);
		sc2Vector pt3(dCH3X, dCH3Y);
		sc2Vector pt4(dCH4X, dCH4Y);
		sc2Vector pt5(dCH5X, dCH5Y);

		scLineSeg lineSeg01(pt0, pt1);
		scLineSeg lineSeg23(pt2, pt3);
		scLine line01 = lineSeg01.GetLine();
		scLine line23 = lineSeg23.GetLine();

		sc2Vector ptProjectX= line01.Project(pt5);
		sc2Vector ptProjectY = line23.Project(pt4);
		sc2Vector ptCenter(ptProjectX.GetX(), ptProjectY.GetY());

		// 产品位置
		vProductPos = ptCenter;

		// 构造实时mark对直线Lx
		scLine L23,Lx;
		L23.SetFromLineSeg(lineSeg23);
		sc2Vector PtCenter = L23.Project(sc2Vector(dCH4X, dCH4Y));
		scLineSeg lineSeg(PtCenter, sc2Vector(dCH4X, dCH4Y));
		Lx.SetFromLineSeg(lineSeg);		
		double dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;

		// 产品角度
		degProductAngle = scDegree(dDegLx);
	}

	return TRUE;
}

// 在Mark坐标系下，根据系统对位补偿量，对对象Mark的平台坐标值进行旋转修正
void vcBaseAlignTool::MarkCoordOffsetRotationObjectPlatformPos(std::vector<CCoordPos> vObjectPlatformCoordPos,
	std::vector<CCoordPos>& vFixedObjectPlatformCoordPos)
{

	// 获取产品位置（旋转中心）和角度
	sc2Vector vProductPos;
	scDegree  degProductAngle;
	GetProductPosAngle(vObjectPlatformCoordPos, vProductPos, degProductAngle);

	// 旋转角度
	double dOffsetD = m_AlignermentParam.GetAlignerOffset().m_dAngle + m_AlignermentParam.GetAlignerBaseOffset().m_dAngle;

	if (m_bInnerAlignBench)
	{
		dOffsetD = m_AlignermentParam.GetAlignerBenchOffset().m_dAngle;
	}

	// 旋转角度
	if (m_AlignermentParam.GetProductOffsetInfo().m_bEnableProductOffsetDDirection)
	{
		dOffsetD = -dOffsetD;
	}

	// 角度补偿
// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		int nMark = m_iMarkNum/2;
// 		int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;
// 
// 
// 		CCoordPos pos;
// 		sc2Vector vObjectPos;
// 		sc2Vector vFixedObjectPos;
// 		int i = 0;
// 		for(i = 0; i < m_iMarkNum/4 && i < vObjectPlatformCoordPos.size(); i++)
// 		{
// 			vObjectPos.SetX(vObjectPlatformCoordPos.at(i + nExMark).m_dPosX);
// 			vObjectPos.SetY(vObjectPlatformCoordPos.at(i + nExMark).m_dPosY);
// 
// // 			str.Format("Mark角度补偿前对象平台坐标%d:ObjectX=%f,ObjectY=%f",i+nExMark,vObjectPos.GetX(),vObjectPos.GetY());
// // 			AlignToolLogRecord(str, m_nPlatformIndex);
// 
// 			vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);
// 
// // 			str.Format("Mark角度补偿后对象平台坐标%d:ObjectX=%f,ObjectY=%f",i+nExMark,vFixedObjectPos.GetX(),vFixedObjectPos.GetY());
// // 			AlignToolLogRecord(str, m_nPlatformIndex);
// 
// 			pos.m_dPosX = vFixedObjectPos.GetX();
// 			pos.m_dPosY = vFixedObjectPos.GetY();
// 
// 			// 辅助位置
// 			int nAuxiPosIndex = 0;
// 			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
// 			{
// 				vObjectPos.SetX(vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
// 				vObjectPos.SetY(vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
// 				vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);
// 
// 				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vFixedObjectPos.GetX();
// 				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vFixedObjectPos.GetY();
// 			}
// 
// 			vFixedObjectPlatformCoordPos.at(i + nExMark) = pos;
// 		}
// 
// 		return;
// 	}



	
	// 角度补偿
	if (m_bTargetObjectCamSeparate)
	{		
		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum/2 && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
				vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
				vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);

				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vFixedObjectPos.GetX();
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vFixedObjectPos.GetY();
			}

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}
	}
	else
	{
		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
				vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
				vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);

				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vFixedObjectPos.GetX();
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vFixedObjectPos.GetY();
			}

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}
	}
	
}

// 在Mark坐标系下，根据系统对位补偿量，对对象Mark的平台坐标值进行平移修正
void vcBaseAlignTool::MarkCoordOffsetXYObjectPltfmPt(std::vector<CCoordPos> vObjectPlatformCoordPos,
	std::vector<CCoordPos>& vFixedObjectPlatformCoordPos)
{
	// 获取产品位置（旋转中心）和角度
	sc2Vector vProductPos;
	scDegree  degProductAngle;
	GetProductPosAngle(vObjectPlatformCoordPos, vProductPos, degProductAngle);

	// XY补偿
	double dOffsetX = m_AlignermentParam.GetAlignerOffset().m_dPosX+m_AlignermentParam.GetAlignerBaseOffset().m_dPosX;
	double dOffsetY = m_AlignermentParam.GetAlignerOffset().m_dPosY+m_AlignermentParam.GetAlignerBaseOffset().m_dPosY;
	
	if (m_bInnerAlignBench)
	{
		dOffsetX = m_AlignermentParam.GetAlignerBenchOffset().m_dPosX;
		dOffsetY = m_AlignermentParam.GetAlignerBenchOffset().m_dPosY;
	}  //dOffsetY = m_AlignermentParam.GetAlignerBenchOffset().m_dPosY;	//20180505hk

	// 方向X
	if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXDirection)
	{
		dOffsetX = -dOffsetX;
	}

	// 方向Y
	if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYDirection)
	{
		dOffsetY = -dOffsetY;
	}



	// X补偿与Y补偿对调
	if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXSetting/* || m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYSetting*/)
	{
		double dTempOffsetX = 0, dTempOffsetY = 0;

		dTempOffsetX = dOffsetX;
		dTempOffsetY = dOffsetY;

		dOffsetX = dTempOffsetY;
		dOffsetY = dTempOffsetX;

	}

	// XY补偿
// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		int nMark = m_iMarkNum/2;
// 		int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;
// 
// 		CCoordPos pos;
// 		sc2Vector vObjectPos;
// 		sc2Vector vFixedObjectPos;
// 		int i = 0;
// 		for(i = 0; i < m_iMarkNum/4 && i < vObjectPlatformCoordPos.size(); i++)
// 		{
// 			vObjectPos.SetX(vObjectPlatformCoordPos.at(i + nExMark).m_dPosX);
// 			vObjectPos.SetY(vObjectPlatformCoordPos.at(i + nExMark).m_dPosY);
// 
// // 			str.Format("Mark平移补偿前对象平台坐标%d:ObjectX=%f,ObjectY=%f",i+nExMark,vObjectPos.GetX(),vObjectPos.GetY());
// // 			AlignToolLogRecord(str, m_nPlatformIndex);
// 
// 			vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);
// 
// // 			str.Format("Mark平移补偿后对象平台坐标%d:ObjectX=%f,ObjectY=%f",i+nExMark,vFixedObjectPos.GetX(),vFixedObjectPos.GetY());
// // 			AlignToolLogRecord(str, m_nPlatformIndex);
// 
// 			pos.m_dPosX = vFixedObjectPos.GetX();
// 			pos.m_dPosY = vFixedObjectPos.GetY();
// 
// 			// 辅助位置
// 			int nAuxiPosIndex = 0;
// 			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
// 			{
// 				vObjectPos.SetX(vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
// 				vObjectPos.SetY(vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
// 				vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);
// 
// 				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vFixedObjectPos.GetX();
// 				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vFixedObjectPos.GetY();
// 			}
// 
// 			vFixedObjectPlatformCoordPos.at(i + nExMark) = pos;
// 		}
// 
// 		return;
// 	}

	// XY补偿
	if (m_bTargetObjectCamSeparate)
	{		
		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum/2 && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
				vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
				vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vFixedObjectPos.GetX();
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vFixedObjectPos.GetY();
			}

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}
	}
	else
	{
		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
				vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
				vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vFixedObjectPos.GetX();
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vFixedObjectPos.GetY();
			}

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}
	}
	
}


//八字补偿 在Mark坐标系下，指定补偿量，对对象Mark的平台坐标值进行平移修正
void vcBaseAlignTool::MarkCoordOffsetXYObjectPltfmPt(std::vector<CCoordPos> vObjectPlatformCoordPos,
	std::vector<CCoordPos>& vFixedObjectPlatformCoordPos,double dOffsetX,double dOffsetY)
{
	// 获取产品位置（旋转中心）和角度
	sc2Vector vProductPos;
	scDegree  degProductAngle;
	GetProductPosAngle(vObjectPlatformCoordPos, vProductPos, degProductAngle);

	// XY补偿
	if (m_bTargetObjectCamSeparate)
	{		
		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum/2 && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
				vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
				vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vFixedObjectPos.GetX();
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vFixedObjectPos.GetY();
			}

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}
	}
	else
	{
		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
				vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
				vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vFixedObjectPos.GetX();
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vFixedObjectPos.GetY();
			}

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}
	}
}

//////////////////////////////////////////////////////////////////////////
// 对角Mark坐标系下的补偿

//20160510增加对角补偿
// 在对角Mark坐标系下，根据系统对位补偿量，对对象Mark的平台坐标值进行旋转修正
void vcBaseAlignTool::MarkCoordDiagonalOffsetRotationObjectPlatformPos(scDegree degRotate, std::vector<CCoordPos> vObjectPlatformCoordPos,
	std::vector<CCoordPos>& vFixedObjectPlatformCoordPos)
{
	if (m_bTargetObjectCamSeparate)
	{
		if (4 == m_iMarkNum)
		{
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;

			// 旋转角度
			double dOffsetD = degRotate.ToDouble();

			// 旋转中心
			double dRotationCenterX, dRotationCenterY;
			dRotationCenterX = (dCH0X + dCH1X)/2.0;
			dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

			sc2Vector vProductPos(dRotationCenterX,dRotationCenterY);

			CCoordPos pos;
			sc2Vector vObjectPos;
			sc2Vector vFixedObjectPos;
			int i = 0;
			for(i = 0; i < m_iMarkNum/2 && i < vObjectPlatformCoordPos.size(); i++)
			{
				vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
				vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
				vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);

				pos.m_dPosX = vFixedObjectPos.GetX();
				pos.m_dPosY = vFixedObjectPos.GetY();

				vFixedObjectPlatformCoordPos.at(i) = pos;
			}
		}
		else if (6 == m_iMarkNum)//  jjhxg
		{
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
			double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
			double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;

			// 旋转角度
			double dOffsetD = degRotate.ToDouble();

			sc2Vector vProductPos(0,0);

			scDegree degProductAngle;

			// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			//jjh0618
			if (eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type()  
				||eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
				||eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())  //jjh0612
			{
				// 圆权重为1，以圆为基准进行对位,以圆为基准进行补偿
				if (m_AlignermentParam.m_dAlignerWeight == 1.0)
				{
					svStd vector< sc2Vector > ptCenter;
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					// 圆心坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					// 圆点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else 
				{
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_Auto_Weigth)//两角点中心对位
					{

						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH1X + dCH2X)/2.0;
							dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH2X)/2.0;
							dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH1X)/2.0;
							dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

					}
					else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C1_Weigth) //角点1对位
					{
						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
					}
					else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C2_Weigth)//角点2对位
					{
						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH2X, dCH2Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH2X, dCH2Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
					}
				}

			}
			else if (eAlignerPos123_Auto_L1C_Weigth == m_AlignermentParam.GetAligner3Vs3Type()) //jjh0619  
			{
				if (m_AlignermentParam.m_dAlignerWeight != 0) //以圆为中心进行补偿
				{
					svStd vector< sc2Vector > ptCenter;
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					// 圆心坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					// 圆点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else //角点补偿  以角点中心为旋转中心 以圆心到第一个点的连线为角度 
				{
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH1X + dCH2X)/2.0;
						dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y)); //圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH2X)/2.0;
						dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
			}
			//由前面的对位方式得到对象平台坐标  角度是传值进来的dOffsetD    不用对位方式算出来的degProductAngle
			CCoordPos pos;
			sc2Vector vObjectPos;
			sc2Vector vFixedObjectPos;
			int i = 0;
			for(i = 0; i < m_iMarkNum/2 && i < vObjectPlatformCoordPos.size(); i++)
			{
				vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
				vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
				vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);

				pos.m_dPosX = vFixedObjectPos.GetX();
				pos.m_dPosY = vFixedObjectPos.GetY();

				vFixedObjectPlatformCoordPos.at(i) = pos;
			}
		}
		else
		{
			return;
		}

		return;
	}

	//	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
	//m_iMarkNum为mark数量
	if (2 == m_iMarkNum)
	{
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;

		// 旋转角度
		double dOffsetD = degRotate.ToDouble();

		// 旋转中心
		double dRotationCenterX, dRotationCenterY;
		dRotationCenterX = (dCH0X + dCH1X)/2.0;
		dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

		sc2Vector vProductPos(dRotationCenterX,dRotationCenterY);

		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}

	}
	else if (3 == m_iMarkNum)
	{
		CString str;
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
		double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;

		// 旋转角度
		double dOffsetD = degRotate.ToDouble();

		sc2Vector vProductPos(0,0);

		scDegree degProductAngle;

		// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		//jjh0618
		if (eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type()  
			||eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
			||eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())  //jjh0612
		{
			// 圆权重为1，以圆为基准进行对位,以圆为基准进行补偿
			if (m_AlignermentParam.m_dAlignerWeight == 1.0)
			{
				svStd vector< sc2Vector > ptCenter;
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}
				// 圆心坐标在相机CH0中
				if (bCH0_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}

				// 圆点坐标在相机CH1中
				if (bCH1_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				// 圆点坐标在相机CH2中
				if (bCH2_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
			}
			else 
			{
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}
				if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_Auto_Weigth)//两角点中心对位
				{

					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH1X + dCH2X)/2.0;
						dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH2X)/2.0;
						dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

				}
				else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C1_Weigth) //角点1对位
				{
					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH1X, dCH1Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH0X, dCH0Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH0X, dCH0Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C2_Weigth)//角点2对位
				{
					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH2X, dCH2Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH2X, dCH2Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH1X, dCH1Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
			}

		}
		else if (eAlignerPos123_Auto_L1C_Weigth == m_AlignermentParam.GetAligner3Vs3Type()) //jjh0619  
		{
			if (m_AlignermentParam.m_dAlignerWeight != 0) //以圆为中心进行补偿
			{
				svStd vector< sc2Vector > ptCenter;
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}
				// 圆心坐标在相机CH0中
				if (bCH0_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}

				// 圆点坐标在相机CH1中
				if (bCH1_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				// 圆点坐标在相机CH2中
				if (bCH2_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));
					Lx.SetFromLineSeg(lineSeg);


					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
			}
			else //角点补偿  以角点中心为旋转中心 以圆心到第一个点的连线为角度 
			{
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}

				if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
				{
					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH1X + dCH2X)/2.0;
					dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y)); //圆心和第一个点的连线角度
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
				{
					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH0X + dCH2X)/2.0;
					dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
				{
					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH0X + dCH1X)/2.0;
					dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
			}
		}
		//由前面的对位方式得到对象平台坐标  角度是传值进来的dOffsetD    不用对位方式算出来的degProductAngle
		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformRotateShiftPoint(vObjectPos, scDegree(dOffsetD), 0, 0, vProductPos);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}
	}
	else
		return;
}

//20160510增加对角补偿
// 在对角Mark坐标系下，根据系统对位补偿量，对对象Mark的平台坐标值进行平移修正
void vcBaseAlignTool::MarkCoordDiagonalOffsetXYObjectPltfmPt(std::vector<CCoordPos> vObjectPlatformCoordPos,std::vector<CCoordPos> vObjectPlatformCoordPosDirection,
	sc2Vector offsetXY,std::vector<CCoordPos>& vFixedObjectPlatformCoordPos)
{
	//	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;

	scDegree angleDiagonal = scDegree(0);
	if (!AngleDiagonalCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
		m_AlignermentParam.GetPositionModeInfo(), angleDiagonal))
	{
		return;
	}

	double dDegLx;//mark坐标系与平台坐标系的夹角
	if (m_bTargetObjectCamSeparate)
	{
		if (4 == m_iMarkNum)
		{
			double dCH0X = vObjectPlatformCoordPosDirection.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPosDirection.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPosDirection.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPosDirection.at(1).m_dPosY;
			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
			Lx.SetFromLineSeg(lineSeg);

			Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

			dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
		}
		else if (6 == m_iMarkNum)  //jjhbc
		{
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
			double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
			double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;

			// 旋转角度
			//double dOffsetD = degRotate.ToDouble();

			sc2Vector vProductPos(0,0);
			// 旋转角度
			//double degProductAngle = 0;

			// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			//jjh0618
			if (eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type()  
				||eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
				||eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())  //jjh0612
			{
				// 圆权重为1，以圆为基准进行对位,以圆为基准进行补偿
				if (m_AlignermentParam.m_dAlignerWeight == 1.0)
				{
					svStd vector< sc2Vector > ptCenter;
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					// 圆心坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						//jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);

						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					// 圆点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else 
				{
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_Auto_Weigth)//两角点中心对位
					{

						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH1X + dCH2X)/2.0;
							dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH2X)/2.0;
							dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH1X)/2.0;
							dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}

					}
					else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C1_Weigth) //角点1对位
					{
						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}
					}
					else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C2_Weigth)//角点2对位
					{
						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH2X, dCH2Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH2X, dCH2Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);
							//产品角度 jjhbc 按照4点的方式求角度
							Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

							dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
							// 产品角度
							//degProductAngle = scDegree(Lx.GetRotation());
						}
					}
				}

			}
			else if (eAlignerPos123_Auto_L1C_Weigth == m_AlignermentParam.GetAligner3Vs3Type()) //jjh0619  
			{
				if (m_AlignermentParam.m_dAlignerWeight != 0) //以圆为中心进行补偿
				{
					svStd vector< sc2Vector > ptCenter;
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					// 圆心坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));
						Lx.SetFromLineSeg(lineSeg);

						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					// 圆点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));
						Lx.SetFromLineSeg(lineSeg);

						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else //角点补偿  以角点中心为旋转中心 以圆心到第一个点的连线为角度 
				{
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH1X + dCH2X)/2.0;
						dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y)); //圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH2X)/2.0;
						dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
				}
			}
		}
		else
		{
			return;
		}


		// 产品角度
		scDegree degProductAngle(dDegLx);

		// XY补偿
		double dOffsetX = offsetXY.GetX();
		double dOffsetY = offsetXY.GetY();

		CCoordPos pos;
		sc2Vector vObjectPos;
		sc2Vector vFixedObjectPos;
		int i = 0;
		for(i = 0; i < m_iMarkNum/2 && i < vObjectPlatformCoordPos.size(); i++)
		{
			vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
			vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
			vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

			pos.m_dPosX = vFixedObjectPos.GetX();
			pos.m_dPosY = vFixedObjectPos.GetY();

			vFixedObjectPlatformCoordPos.at(i) = pos;
		}

		return;
	}


	if (2 == m_iMarkNum)
	{
		double dCH0X = vObjectPlatformCoordPosDirection.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPosDirection.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPosDirection.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPosDirection.at(1).m_dPosY;
		// 构造实时mark对直线Lx
		scLine Lx;
		scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
		Lx.SetFromLineSeg(lineSeg);

		Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

		dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
	}
	else if (3 == m_iMarkNum)  // jjhbc
	{
		CString str;
		double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
		double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
		double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
		double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
		double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;

		// 旋转角度
		//double dOffsetD = degRotate.ToDouble();

		sc2Vector vProductPos(0,0);
		// 旋转角度
		//double degProductAngle = 0;

		// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
		// 			AlignToolLogRecord(str,nPlatformIndex);
		//jjh0618
		if (eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type()  
			||eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
			||eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())  //jjh0612
		{
			// 圆权重为1，以圆为基准进行对位,以圆为基准进行补偿
			if (m_AlignermentParam.m_dAlignerWeight == 1.0)
			{
				svStd vector< sc2Vector > ptCenter;
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}
				// 圆心坐标在相机CH0中
				if (bCH0_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
					Lx.SetFromLineSeg(lineSeg);

					//jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}

				// 圆点坐标在相机CH1中
				if (bCH1_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
					Lx.SetFromLineSeg(lineSeg);

					//产品角度 jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}
				// 圆点坐标在相机CH2中
				if (bCH2_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					//产品角度 jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}
			}
			else 
			{
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}
				if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_Auto_Weigth)//两角点中心对位
				{

					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH1X + dCH2X)/2.0;
						dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH2X)/2.0;
						dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}

				}
				else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C1_Weigth) //角点1对位
				{
					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH1X, dCH1Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH0X, dCH0Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH0X, dCH0Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C2_Weigth)//角点2对位
				{
					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH2X, dCH2Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH2X, dCH2Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH1X, dCH1Y); 

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);
						//产品角度 jjhbc 按照4点的方式求角度
						Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

						dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
						// 产品角度
						//degProductAngle = scDegree(Lx.GetRotation());
					}
				}
			}

		}
		else if (eAlignerPos123_Auto_L1C_Weigth == m_AlignermentParam.GetAligner3Vs3Type()) //jjh0619  
		{
			if (m_AlignermentParam.m_dAlignerWeight != 0) //以圆为中心进行补偿
			{
				svStd vector< sc2Vector > ptCenter;
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}
				// 圆心坐标在相机CH0中
				if (bCH0_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					//产品角度 jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}

				// 圆点坐标在相机CH1中
				if (bCH1_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));
					Lx.SetFromLineSeg(lineSeg);

					//产品角度 jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}
				// 圆点坐标在相机CH2中
				if (bCH2_Auxiliary)
				{
					ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));
					Lx.SetFromLineSeg(lineSeg);

					//产品角度 jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品位置
					vProductPos = ptCenter.at(0);
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}
			}
			else //角点补偿  以角点中心为旋转中心 以圆心到第一个点的连线为角度 
			{
				// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
				BOOL bCH0_Auxiliary = FALSE;
				BOOL bCH1_Auxiliary = FALSE;
				BOOL bCH2_Auxiliary = FALSE;

				int nPos = m_AlignermentParam.GetAlignerCirclePos();

				switch(nPos)
				{
				case 0:
					bCH0_Auxiliary = TRUE;
					break;
				case 1:
					bCH1_Auxiliary = TRUE;
					break;
				case 2:
					bCH2_Auxiliary = TRUE;
					break;
				default:
					bCH0_Auxiliary = TRUE;
					break;
				}

				if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
				{
					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH1X + dCH2X)/2.0;
					dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y)); //圆心和第一个点的连线角度
					Lx.SetFromLineSeg(lineSeg);
					//产品角度 jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
				{
					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH0X + dCH2X)/2.0;
					dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
					Lx.SetFromLineSeg(lineSeg);
					//产品角度 jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
				{
					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH0X + dCH1X)/2.0;
					dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
					Lx.SetFromLineSeg(lineSeg);
					//产品角度 jjhbc 按照4点的方式求角度
					Lx.SetRotation(Lx.GetRotation().SignedNormMod180() - scRadian(angleDiagonal));	//20160510增加对角补偿

					dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;
					// 产品角度
					//degProductAngle = scDegree(Lx.GetRotation());
				}
			}
		}
	}
	else
		return ;


	// 产品角度
	scDegree degProductAngle(dDegLx);

	// XY补偿
	double dOffsetX = offsetXY.GetX();
	double dOffsetY = offsetXY.GetY();

	CCoordPos pos;
	sc2Vector vObjectPos;
	sc2Vector vFixedObjectPos;
	int i = 0;
	for(i = 0; i < m_iMarkNum && i < vObjectPlatformCoordPos.size(); i++)
	{
		vObjectPos.SetX(vObjectPlatformCoordPos.at(i).m_dPosX);
		vObjectPos.SetY(vObjectPlatformCoordPos.at(i).m_dPosY);
		vFixedObjectPos = vfGetTransformShiftAlongRotateAnglePoint(vObjectPos, degProductAngle, dOffsetX, dOffsetY);

		pos.m_dPosX = vFixedObjectPos.GetX();
		pos.m_dPosY = vFixedObjectPos.GetY();

		vFixedObjectPlatformCoordPos.at(i) = pos;
	}

}


//////////////////////////////////////////////////////////////////////////
// 平台坐标系下的补偿
// 在全局平台坐标系下，根据系统对位补偿量，对对象Mark的平台坐标值进行旋转补偿
void vcBaseAlignTool::PltfmCoordOffsetRotationObjectPltfmPt(std::vector<CCoordPos> vObjectPlatformCoordPos,
															  std::vector<CCoordPos>& vFixedObjectPlatformCoordPos)
{
//	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
	
	// 旋转角度
	double dOffsetD = m_AlignermentParam.GetAlignerOffset().m_dAngle + m_AlignermentParam.GetAlignerBaseOffset().m_dAngle;
	if (m_AlignermentParam.GetProductOffsetInfo().m_bEnableProductOffsetDDirection)
	{
		dOffsetD = -dOffsetD;
	}

// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		int nMark = m_iMarkNum/2;
// 		int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;
// 
// 
// 		for (int i=0; i<m_iMarkNum/4; i++)
// 		{
// 			double dCH0X = vObjectPlatformCoordPos.at(i + nExMark).m_dPosX;
// 			double dCH0Y = vObjectPlatformCoordPos.at(i + nExMark).m_dPosY;
// 			//// 旋转角度
// 			//double dOffsetD = m_AlignermentParam.GetAlignerOffset().m_dAngle + m_AlignermentParam.GetAlignerBaseOffset().m_dAngle;
// 			//// 		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType) dOffsetD = -1*dOffsetD;// 平台逆时针旋转为正
// 			//记录结果	
// 			CCoordPos pos;		
// 			pos.m_dPosX = dCH0X*cos(scDegree(dOffsetD)) - dCH0Y*sin(scDegree(dOffsetD)); 
// 			pos.m_dPosY = dCH0X*sin(scDegree(dOffsetD)) + dCH0Y*cos(scDegree(dOffsetD));
// 
// 
// 			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 			{
// 				// 辅助位置
// 				int nAuxiPosIndex = 0;
// 				for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
// 				{
// 					pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.at(nAuxiPosIndex)*cos(scDegree(dOffsetD)) 
// 						- vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosY.at(nAuxiPosIndex)*sin(scDegree(dOffsetD)); 
// 					pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.at(nAuxiPosIndex)*sin(scDegree(dOffsetD)) 
// 						+ vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosY.at(nAuxiPosIndex)*cos(scDegree(dOffsetD));
// 				}
// 			}
// 
// 
// 			vFixedObjectPlatformCoordPos.at(i + nExMark) = pos;
// 		}
// 
// 		return;
// 
// 	}

	if (m_bTargetObjectCamSeparate)
	{
		for (int i=0; i<m_iMarkNum/2; i++)
		{
			double dCH0X = vObjectPlatformCoordPos.at(i).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(i).m_dPosY;
			//// 旋转角度
			//double dOffsetD = m_AlignermentParam.GetAlignerOffset().m_dAngle + m_AlignermentParam.GetAlignerBaseOffset().m_dAngle;
			//// 		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType) dOffsetD = -1*dOffsetD;// 平台逆时针旋转为正
			//记录结果	
			CCoordPos pos;		
			pos.m_dPosX = dCH0X*cos(scDegree(dOffsetD)) - dCH0Y*sin(scDegree(dOffsetD)); 
			pos.m_dPosY = dCH0X*sin(scDegree(dOffsetD)) + dCH0Y*cos(scDegree(dOffsetD));
			
			
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
			{
				// 辅助位置
				int nAuxiPosIndex = 0;
				for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
				{
					pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex)*cos(scDegree(dOffsetD)) 
						- vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex)*sin(scDegree(dOffsetD)); 
					pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex)*sin(scDegree(dOffsetD)) 
						+ vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex)*cos(scDegree(dOffsetD));
				}
			}


			vFixedObjectPlatformCoordPos.at(i) = pos;
		}

		return;
	}

 	//m_iMarkNum为mark个数
	for (int i=0; i<m_iMarkNum; i++)
	{
		double dCH0X = vObjectPlatformCoordPos.at(i).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(i).m_dPosY;
//		// 旋转角度
// 		double dOffsetD = m_AlignermentParam.GetAlignerOffset().m_dAngle + m_AlignermentParam.GetAlignerBaseOffset().m_dAngle;
//// 		if (eDirectNegative == pPlatformParam->m_nPlatformDCoordType) dOffsetD = -1*dOffsetD;// 平台逆时针旋转为正
		//记录结果	
		CCoordPos pos;		
		pos.m_dPosX = dCH0X*cos(scDegree(dOffsetD)) - dCH0Y*sin(scDegree(dOffsetD)); 
		pos.m_dPosY = dCH0X*sin(scDegree(dOffsetD)) + dCH0Y*cos(scDegree(dOffsetD));

		if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
		{
			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex)*cos(scDegree(dOffsetD)) 
					- vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex)*sin(scDegree(dOffsetD)); 
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex)*sin(scDegree(dOffsetD)) 
					+ vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex)*cos(scDegree(dOffsetD));
			}
		}

		vFixedObjectPlatformCoordPos.at(i) = pos;
	}
}


// 在全局平台坐标系下，根据系统对位补偿量，对对象Mark的平台坐标值进行平移修正
// 读取的偏移量是全局平台坐标系的方向，即X右，Y下，D顺时针
void vcBaseAlignTool::PltfmCoordOffsetXYObjectPltfmPt(std::vector<CCoordPos> vObjectPlatformCoordPos,
														std::vector<CCoordPos>& vFixedObjectPlatformCoordPos)
{
//	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
	
	// XY补偿
	double dOffsetX = m_AlignermentParam.GetAlignerOffset().m_dPosX+m_AlignermentParam.GetAlignerBaseOffset().m_dPosX;
	double dOffsetY = m_AlignermentParam.GetAlignerOffset().m_dPosY+m_AlignermentParam.GetAlignerBaseOffset().m_dPosY;

	// 方向X
	if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXDirection)
	{
		dOffsetX = -dOffsetX;
	}

	// 方向Y
	if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYDirection)
	{
		dOffsetY = -dOffsetY;
	}

	// X补偿与Y补偿对调
	if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXSetting/* || m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYSetting*/)
	{
		double dTempOffsetX = 0, dTempOffsetY = 0;

		dTempOffsetX = dOffsetX;
		dTempOffsetY = dOffsetY;

		dOffsetX = dTempOffsetY;
		dOffsetY = dTempOffsetX;

	}

// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		int nMark = m_iMarkNum/2;
// 		int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;
// 
// 		for (int i=0; i<m_iMarkNum/4; i++)
// 		{
// 			double dCH0X = vObjectPlatformCoordPos.at(i + nExMark).m_dPosX;
// 			double dCH0Y = vObjectPlatformCoordPos.at(i + nExMark).m_dPosY;
// 
// 			//double dOffsetX,  dOffsetY;
// 			//dOffsetX =  m_AlignermentParam.GetAlignerOffset().m_dPosX+m_AlignermentParam.GetAlignerBaseOffset().m_dPosX;
// 			//dOffsetY =  m_AlignermentParam.GetAlignerOffset().m_dPosY+m_AlignermentParam.GetAlignerBaseOffset().m_dPosY;
// 
// 			//记录结果	
// 			CCoordPos pos;		
// 			pos.m_dPosX = dCH0X + dOffsetX;
// 			pos.m_dPosY = dCH0Y + dOffsetY;
// 
// 			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 			{
// 				// 辅助位置
// 				int nAuxiPosIndex = 0;
// 				for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
// 				{
// 					pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosX.at(nAuxiPosIndex) + dOffsetX; 
// 					pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i + nExMark).m_vdAuxiliaryPosY.at(nAuxiPosIndex) + dOffsetY;
// 				}
// 			}
// 
// 			vFixedObjectPlatformCoordPos.at(i + nExMark) = pos;
// 
// 		}
// 
// 		return;
// 
// 	}

	if (m_bTargetObjectCamSeparate)
	{
		for (int i=0; i<m_iMarkNum/2; i++)
		{
			double dCH0X = vObjectPlatformCoordPos.at(i).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(i).m_dPosY;

			//double dOffsetX,  dOffsetY;
			//dOffsetX =  m_AlignermentParam.GetAlignerOffset().m_dPosX+m_AlignermentParam.GetAlignerBaseOffset().m_dPosX;
			//dOffsetY =  m_AlignermentParam.GetAlignerOffset().m_dPosY+m_AlignermentParam.GetAlignerBaseOffset().m_dPosY;
			////已经是平台坐标值了，方向是标准方向，给出的补偿值也是标准方向，为什么还要转化方向呢？放在基类中????
			////是不是平台坐标系下的补偿就是实际平台坐标方向？？那么UVW给出的也是UVW偏移量？？
			////代码中，给定的偏移量是实际轴方向的偏移量
			//// 		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
			//// 		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
			//// 		if (eDirectNegative == iPlatformYCoordType) dOffsetY = -1*dOffsetY;// 转换为全局平台坐标系
			//// 		if (eDirectNegative == iPlatformXCoordType) dOffsetX = -1*dOffsetX;

			//记录结果	
			CCoordPos pos;		
			pos.m_dPosX = dCH0X + dOffsetX;
			pos.m_dPosY = dCH0Y + dOffsetY;

			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
			{
				// 辅助位置
				int nAuxiPosIndex = 0;
				for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
				{
					pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex) + dOffsetX; 
					pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex) + dOffsetY;
				}
			}

			vFixedObjectPlatformCoordPos.at(i) = pos;

		}

		return;
	}

	//m_iMarkNum为mark个数
	for (int i=0; i<m_iMarkNum; i++)
	{
		double dCH0X = vObjectPlatformCoordPos.at(i).m_dPosX;
		double dCH0Y = vObjectPlatformCoordPos.at(i).m_dPosY;
	
//		double dOffsetX,  dOffsetY;
//		dOffsetX =  m_AlignermentParam.GetAlignerOffset().m_dPosX+m_AlignermentParam.GetAlignerBaseOffset().m_dPosX;
//		dOffsetY =  m_AlignermentParam.GetAlignerOffset().m_dPosY+m_AlignermentParam.GetAlignerBaseOffset().m_dPosY;
//		//已经是平台坐标值了，方向是标准方向，给出的补偿值也是标准方向，为什么还要转化方向呢？放在基类中????
//		//是不是平台坐标系下的补偿就是实际平台坐标方向？？那么UVW给出的也是UVW偏移量？？
//		//代码中，给定的偏移量是实际轴方向的偏移量
//// 		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
//// 		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
//// 		if (eDirectNegative == iPlatformYCoordType) dOffsetY = -1*dOffsetY;// 转换为全局平台坐标系
//// 		if (eDirectNegative == iPlatformXCoordType) dOffsetX = -1*dOffsetX;

		//记录结果	
		CCoordPos pos;		
		pos.m_dPosX = dCH0X + dOffsetX;
		pos.m_dPosY = dCH0Y + dOffsetY;

		if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
		{
			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex) + dOffsetX; 
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vObjectPlatformCoordPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex) + dOffsetY;
			}
		}

		vFixedObjectPlatformCoordPos.at(i) = pos;

	}
}



// 用靶标标定时，将图像坐标值转换为虚拟平台坐标值
bool vcBaseAlignTool::ConvertImagePosToCurPlatformPosBoard(CCoordPos& platformCoordPos, int nIndex, CCoordPos imageCoordPos, 
	CPlatformAxisPos* pPlatformAxisPos,BOOL DistortionCorrected /*= FALSE*/)
{
	if (nIndex<0 || nIndex >= m_iMarkNum)
		return false;
	if (NULL == m_vAlignerCalibInfos.at(nIndex))
		return false;
	if (NULL == m_vpCalibrateParam.at(nIndex))
		return false;
	if (!DistortionCorrected)
	{
		if(m_vpCalibrateParam.at(nIndex)->m_nEnableDisCor)
		{
			CString strOut, strTmp;
			double p[15];
			memset(p, 0.0, sizeof(double)*15);
			scCalibrateResult result = m_vAlignerCalibInfos.at(nIndex)->m_result;
			result.GetNonlinearProjectResult(p);
			double dRms = result.GetRMS();
			strOut.Format("畸变参数: ");
			for (int i=0;i<15; i++)
			{
				strTmp.Format(_T("P%d:%.6f "), i, p[i]);
				strOut += strTmp;
			}
			strTmp.Format(_T("P15:%.6f "),dRms);
			strOut += strTmp;
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			strOut.Format("畸变校正前图像坐标: ");
			strTmp.Format(_T("Pos(%.6f, %.6f, %.6f) "), imageCoordPos.m_dPosX, imageCoordPos.m_dPosY, imageCoordPos.m_dAngle);
			strOut += strTmp;
			for (int i=0; i<imageCoordPos.m_vdAuxiliaryPosX.size(); i++)
			{
				strTmp.Format(_T("AuxiliaryPos%d(%.6f, %.6f, %.6f) "), i, imageCoordPos.m_vdAuxiliaryPosX.at(i), imageCoordPos.m_vdAuxiliaryPosY.at(i), imageCoordPos.m_vdAuxiliaryAngle.at(i));
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);

			CCoordPos imageDisCorPos;
			ExecuteDisCorPoint(nIndex, imageCoordPos, imageDisCorPos);
			imageCoordPos = imageDisCorPos;

			strOut.Format("畸变校正后图像坐标: ");
			strTmp.Format(_T("Pos(%.6f, %.6f, %.6f) "), imageCoordPos.m_dPosX, imageCoordPos.m_dPosY, imageCoordPos.m_dAngle);
			strOut += strTmp;
			for (int i=0; i<imageCoordPos.m_vdAuxiliaryPosX.size(); i++)
			{
				strTmp.Format(_T("AuxiliaryPos%d(%.6f, %.6f, %.6f) "), i, imageCoordPos.m_vdAuxiliaryPosX.at(i), imageCoordPos.m_vdAuxiliaryPosY.at(i), imageCoordPos.m_vdAuxiliaryAngle.at(i));
				strOut += strTmp;
			}
			AlignToolLogRecord(strOut,m_nPlatformIndex);
		}
	}


	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
		{
			return false;
		}
	}
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
	//相机平台类型没有基类，不用改；
	CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetPlatformAxisPos());
	CPlatformXYDAxisPos*  pPlatformXYDAxisPos =		 (CPlatformXYDAxisPos*)pPlatformAxisPos;
	CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 
	//	CString str;

	if (NULL == pPlatformBenchAxisPos || NULL == pPlatformXYDAxisPos  || NULL == pPlatformParam)
	{
		return false;
	}

	str.Format("轴基准坐标：X=%f,Y=%f,D=%f",pPlatformBenchAxisPos->m_dPosX,pPlatformBenchAxisPos->m_dPosY,pPlatformBenchAxisPos->m_dAngle);
	AlignToolLogRecord(str,nPlatformIndex);
	str.Format("当前轴坐标：X=%f,Y=%f,D=%f",pPlatformXYDAxisPos->m_dPosX,pPlatformXYDAxisPos->m_dPosY,pPlatformXYDAxisPos->m_dAngle);
	AlignToolLogRecord(str,nPlatformIndex);

	// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
	//标定参数
	double dTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	str.Format("矩阵：dTranferA11=%f,dTranferA12=%f,dTranferA21=%f,dTranferA22=%f",dTranferA11,dTranferA12,dTranferA21,dTranferA22);
	AlignToolLogRecord(str,nPlatformIndex);

	double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosX();
	double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosY();
	//平台各轴的方向	
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

	// 实际平台XY轴偏移量
	double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
	double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;

	if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
	if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
	if ( GetMidPlatformType() ==ePlatformXDPY || GetMidPlatformType() ==ePlatformXDPY1)
	{
		dPlatformOffsetY =0 ;
	}
	else if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
	{

	}
	else if ( GetMidPlatformType() ==ePlatformXYPD)
	{
		dPlatformOffsetX =0 ;
		dPlatformOffsetY =0 ;
	}

	str.Format("Mark平台基准位置：X=%f,Y=%f",dPlatformBenchMarkX,dPlatformBenchMarkY);
	AlignToolLogRecord(str,nPlatformIndex);
	str.Format("轴平移量：X=%f,Y=%f",dPlatformOffsetX,dPlatformOffsetY);
	AlignToolLogRecord(str,nPlatformIndex);

	//平台XY平移量对基准mark平台坐标的影响方向相反
	dPlatformBenchMarkX -= dPlatformOffsetX;
	dPlatformBenchMarkY -= dPlatformOffsetY;

	// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
	double dImgOffsetRealDistanceX = 0;
	double dImgOffsetRealDistanceY = 0;
	double dImgOffsetX = imageCoordPos.m_dPosX - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX;
	double dImgOffsetY = imageCoordPos.m_dPosY - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY;
	dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
	dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

	str.Format("基准图像位置：X=%f,Y=%f",m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX,m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY);
	AlignToolLogRecord(str,nPlatformIndex);
	str.Format("当前图像位置：X=%f,Y=%f",imageCoordPos.m_dPosX,imageCoordPos.m_dPosY);
	AlignToolLogRecord(str,nPlatformIndex);
	str.Format("图像像素移动量：X=%f,Y=%f",dImgOffsetX,dImgOffsetY);
	AlignToolLogRecord(str,nPlatformIndex);

	if (m_bTargetObjectCamSeparate)
	{
		if (nIndex < m_iMarkNum/2)
		{
			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vSrc.SetX(dImgOffsetX);
				vSrc.SetY(dImgOffsetY);
				vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
				dImgOffsetRealDistanceX = vDst.GetX();
				dImgOffsetRealDistanceY = vDst.GetY();
			}
		}
		else
		{

		}
	}
	else
	{
		if (m_PlatformCalibType == ePlatformCalib9Point)
		{
			sc2Vector vSrc;
			sc2Vector vDst;
			vSrc.SetX(dImgOffsetX);
			vSrc.SetY(dImgOffsetY);
			vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
			dImgOffsetRealDistanceX = vDst.GetX();
			dImgOffsetRealDistanceY = vDst.GetY();
		}
	}

	str.Format("图像像素平台移动量：X=%f,Y=%f",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
	AlignToolLogRecord(str,nPlatformIndex);


	// $4、内容相加，即为相机实时Mark的平台坐标值
	platformCoordPos.m_dPosX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
	platformCoordPos.m_dPosY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
	//mark为线时，平台mark线的角度为图像线的角度+图像平台坐标之间的夹角；
	platformCoordPos.m_dAngle = imageCoordPos.GetAngle() + 	m_vAlignerCalibInfos.at(nIndex)->m_dImageToPlatformAnlge;

	str.Format("平台坐标值：X=%f,Y=%f,D=%f",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY,platformCoordPos.m_dAngle);
	AlignToolLogRecord(str,nPlatformIndex);
	return true;
}

CCoordPos vcBaseAlignTool::GetAlignProductOffset()
{
//	return m_ProductOffset;

	CCoordPos realOffset;
	realOffset = m_ProductOffset;

	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	if (eDirectNegative == iPlatformXCoordType) realOffset.m_dPosX = -1*realOffset.m_dPosX;
	if (eDirectNegative == iPlatformYCoordType) realOffset.m_dPosY = -1*realOffset.m_dPosY;
	if (eDirectNegative == iPlatformDCoordType) realOffset.m_dAngle= -1*realOffset.m_dAngle;

	if ((ePlatformXDPY == m_eMidPlatformType) || (ePlatformXDPY1 == m_eMidPlatformType))
	{
		realOffset.m_dPosY = -1*realOffset.m_dPosY;
	}

	return realOffset;
}

CCoordPos vcBaseAlignTool::GetAlignProductOffsetXYPD()
{
//	return m_ProductOffsetXYPD;

	CCoordPos realOffset;
	realOffset = m_ProductOffsetXYPD;

	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	if (eDirectNegative == iPlatformXCoordType) realOffset.m_dPosX = -1*realOffset.m_dPosX;
	if (eDirectNegative == iPlatformYCoordType) realOffset.m_dPosY = -1*realOffset.m_dPosY;
	if (eDirectNegative == iPlatformDCoordType) realOffset.m_dAngle= -1*realOffset.m_dAngle;

	return realOffset;
}

CCoordPos vcBaseAlignTool::GetAlignPlatformOffset( void )
{
//	return m_PlatformOffset;

	CCoordPos realOffset;
	realOffset = m_PlatformOffset;

	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	if (eDirectNegative == iPlatformXCoordType) realOffset.m_dPosX = -1*realOffset.m_dPosX ;
	if (eDirectNegative == iPlatformYCoordType) realOffset.m_dPosY = -1*realOffset.m_dPosY;
	if (eDirectNegative == iPlatformDCoordType) realOffset.m_dAngle= -1*realOffset.m_dAngle;

	if ((ePlatformXDPY == m_eMidPlatformType) || (ePlatformXDPY1 == m_eMidPlatformType))
	{
		realOffset.m_dPosY = -1*realOffset.m_dPosY;
	}

	return realOffset;
}

//获取对位各轴偏差量计算结果，用于输出控制轴运动
CCoordPos vcBaseAlignTool::GetAlignPlatformPosOffset(void)
{
//	return m_PlatformOffset;

	CCoordPos realOffset;
	realOffset = m_PlatformOffset;

	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	if (eDirectNegative == iPlatformXCoordType) realOffset.m_dPosX = -1*realOffset.m_dPosX ;
	if (eDirectNegative == iPlatformYCoordType) realOffset.m_dPosY = -1*realOffset.m_dPosY;
	if (eDirectNegative == iPlatformDCoordType) realOffset.m_dAngle= -1*realOffset.m_dAngle;

	if ((ePlatformXDPY == m_eMidPlatformType)|| (ePlatformXDPY1 == m_eMidPlatformType))
	{
		realOffset.m_dPosY = -1*realOffset.m_dPosY;
	}

	if (m_AlignermentParam.m_bAlignOffsetReverseX)
	{
		realOffset.m_dPosX = -1*realOffset.m_dPosX;
	}
	if (m_AlignermentParam.m_bAlignOffsetReverseY)
	{
		realOffset.m_dPosY = -1*realOffset.m_dPosY;
	}
	if (m_AlignermentParam.m_bAlignOffsetReverseD)
	{
		realOffset.m_dAngle = -1*realOffset.m_dAngle;
	}

	if (ePlatformXYD == m_eMidPlatformType
		|| ePlatformXYPD == m_eMidPlatformType
		|| ePlatformXD == m_eMidPlatformType
		|| ePlatformYD == m_eMidPlatformType
		|| ePlatformXDPY == m_eMidPlatformType
		|| ePlatformXDPY1 == m_eMidPlatformType)
	{
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			CPlatformXYDAxisPos* pPlatformPos = NULL;
			pPlatformPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			double dEndAngle = 0;
			double dAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dEndAngle = scDegree(scRadian(asin(pPlatformPos->m_dAngle/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dAngle = pPlatformPos->m_dAngle - sin(scDegree(dEndAngle - realOffset.m_dAngle))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dEndAngle = scDegree(scRadian(atan(pPlatformPos->m_dAngle/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dAngle = pPlatformPos->m_dAngle - tan(scDegree(dEndAngle - realOffset.m_dAngle))*pPlatformParam->m_dPlatformRotationLength;
				}
			}

			realOffset.m_dAngle = dAngle;
		}		
	}

	return realOffset;
}

CCoordPos vcBaseAlignTool::GetAlignPlatformPosOffsetPickRevise()
{
//	return m_PlatformOffsetRevise;

	CCoordPos realOffset;
	realOffset = m_PlatformOffsetRevise;

	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数

	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformDCoordType = pPlatformParam->m_nPlatformDCoordType;

	if (eDirectNegative == iPlatformXCoordType) realOffset.m_dPosX = -1*realOffset.m_dPosX ;
	if (eDirectNegative == iPlatformYCoordType) realOffset.m_dPosY = -1*realOffset.m_dPosY;
	if (eDirectNegative == iPlatformDCoordType) realOffset.m_dAngle= -1*realOffset.m_dAngle;

	if ((ePlatformXDPY == m_eMidPlatformType)|| (ePlatformXDPY1 == m_eMidPlatformType))
	{
		realOffset.m_dPosY = -1*realOffset.m_dPosY;
	}

	if (m_AlignermentParam.m_bAlignOffsetReverseX)
	{
		realOffset.m_dPosX = -1*realOffset.m_dPosX;
	}
	if (m_AlignermentParam.m_bAlignOffsetReverseY)
	{
		realOffset.m_dPosY = -1*realOffset.m_dPosY;
	}
	if (m_AlignermentParam.m_bAlignOffsetReverseD)
	{
		realOffset.m_dAngle = -1*realOffset.m_dAngle;
	}

	if (ePlatformXYD == m_eMidPlatformType
		|| ePlatformXYPD == m_eMidPlatformType
		|| ePlatformXD == m_eMidPlatformType
		|| ePlatformYD == m_eMidPlatformType
		|| ePlatformXDPY == m_eMidPlatformType
		|| ePlatformXDPY1 == m_eMidPlatformType)
	{
		if (eDriveLine == pPlatformParam->m_nPlatformDDriveType)//直线驱动
		{
			CPlatformXYDAxisPos* pPlatformPos = NULL;
			pPlatformPos = (CPlatformXYDAxisPos*)GetAlignPlatformMovementResults();

			double dEndAngle = 0;
			double dAngle = 0;
			if (pPlatformParam->m_dPlatformRotationLength > DBL_EPSILON)
			{
				if (pPlatformParam->m_nPlatformDDriveLineType == eDriveLineShift)
				{
					dEndAngle = scDegree(scRadian(asin(pPlatformPos->m_dAngle/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dAngle = pPlatformPos->m_dAngle - sin(scDegree(dEndAngle - realOffset.m_dAngle))*pPlatformParam->m_dPlatformRotationLength;
				}
				else
				{
					dEndAngle = scDegree(scRadian(atan(pPlatformPos->m_dAngle/pPlatformParam->m_dPlatformRotationLength))).ToDouble();
					dAngle = pPlatformPos->m_dAngle - tan(scDegree(dEndAngle - realOffset.m_dAngle))*pPlatformParam->m_dPlatformRotationLength;
				}
			}

			realOffset.m_dAngle = dAngle;
		}		
	}

	return realOffset;
}



// 说明：nRecordName = 0，记录对位过程日志；nRecordName = 1，记录标定过程日志
void vcBaseAlignTool::AlignToolLogRecord(CString strlog,int nPlatformIndex)
{
	if (m_bLogRecordEnable)
	{

		SYSTEMTIME sys; 
		GetLocalTime( &sys ); 
		CString t;
		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
		CString strPath;


		CString strTemp = "";
		strTemp += t;
		strTemp += strlog;
		strTemp+= "\n";
		FILE *stream;

		CString strDir;
		CFileFind findFile;
		BOOL IsFild, IsDir;
		IsFild = FALSE;
		IsDir = FALSE;

		strDir  = "D:\\VisionASMLog";

		IsFild = findFile.FindFile(strDir);
		while (IsFild)
		{
			IsFild = findFile.FindNextFile();
			IsDir = findFile.IsDirectory();
			if(IsDir) break;
		}	
		if (!IsDir)
		{
			if (!CreateDirectory(strDir, NULL))// 创建文件夹
			{

				return ;
			}
		}

		strPath.Format("D:\\VisionASMLog\\AlignToolInf_Platform%d.txt",nPlatformIndex);

		stream = fopen(strPath, _T("a+t"));
		if (stream != NULL)
		{
			fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
			fclose(stream);	
		}

		CFileStatus fs;
		CFile::GetStatus(strPath,fs);
		if (fs.m_size > 5000000)//1048576)
		{
		 	::DeleteFile(strPath);
		}
	}
}

// void vcBaseAlignTool:: AlignToolLogRecord(CString strPathFileName,CString strlog,int nPlatformIndex)
// {
// 	if (m_bLogRecordEnable)
// 	{
// 
// 		SYSTEMTIME sys; 
// 		GetLocalTime( &sys ); 
// 		CString t;
// 		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
// 		
// 
// 
// 		CString strTemp = "";
// 		strTemp += t;
// 		strTemp += strlog;
// 		strTemp+= "\n";
// 		FILE *stream;
// 
// 		CString strDir;
// 		CFileFind findFile;
// 		BOOL IsFild, IsDir;
// 		IsFild = FALSE;
// 		IsDir = FALSE;
// 
// 		strDir  = "D:\\VisionASMLog";
// 
// 		IsFild = findFile.FindFile(strDir);
// 		while (IsFild)
// 		{
// 			IsFild = findFile.FindNextFile();
// 			IsDir = findFile.IsDirectory();
// 			if(IsDir) break;
// 		}	
// 		if (!IsDir)
// 		{
// 			if (!CreateDirectory(strDir, NULL))// 创建文件夹
// 			{
// 
// 				return ;
// 			}
// 		}
// 
// 
// 
// 		stream = fopen(strPathFileName, _T("a+t"));
// 		if (stream != NULL)
// 		{
// 			fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
// 			fclose(stream);	
// 		}
// 
// 		CFileStatus fs;
// 		CFile::GetStatus(strPathFileName,fs);
// 		if (fs.m_size > 5000000)//1048576)
// 		{
// 			::DeleteFile(strPathFileName);
// 		}
// 	}
// }

// void vcBaseAlignTool::AlignToolLogRecordFormat(CString strlog,int nPlatformIndex)
// {
// 	if (m_bLogRecordEnable)
// 	{
// 		CString strPath;
// 
// 
// 		CString strTemp = "";
// 		strTemp += strlog;
// 		FILE *stream;
// 
// 		CString strDir;
// 		CFileFind findFile;
// 		BOOL IsFild, IsDir;
// 		IsFild = FALSE;
// 		IsDir = FALSE;
// 
// 		strDir  = "D:\\VisionASMLog";
// 
// 		IsFild = findFile.FindFile(strDir);
// 		while (IsFild)
// 		{
// 			IsFild = findFile.FindNextFile();
// 			IsDir = findFile.IsDirectory();
// 			if(IsDir) break;
// 		}	
// 		if (!IsDir)
// 		{
// 			if (!CreateDirectory(strDir, NULL))// 创建文件夹
// 			{
// 
// 				return ;
// 			}
// 		}
// 
// 
// 		strPath.Format("D:\\VisionASMLog\\AlignToolInfo_Format_PlatFormIndex%d.txt",nPlatformIndex);
// 		stream = fopen(strPath, _T("a+t"));
// 		if (stream == NULL)
// 		{
// 			return;
// 		}
// 		fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
// 		fclose(stream);	
// 
// 		CFileStatus fs;
// 		CFile::GetStatus(strPath,fs);
// 		if (fs.m_size > 5000000)//1048576)
// 		{
// 			::DeleteFile(strPath);
// 		}
// 	}
// }

void vcBaseAlignTool::AlignToolLogRecordProduct(CString strlog,int nPlatformIndex)
{
	if (m_bLogRecordEnable)
	{

		SYSTEMTIME sys; 
		GetLocalTime( &sys ); 
		CString t;
		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
		CString strPath;

		// 多次对位时方便查看每一片产品的对位记录信息
// 		if (2 == m_iMarkNum)
// 		{
// 			if (m_bIsAlignerSuccess)
// 			{
// 				t = _T("\n\n") + t;
// 			}
// 			else
// 			{
// 
// 			}
// 		}


		CString strTemp = "";
		strTemp += t;
		strTemp += strlog;
		strTemp+= "\n";
		FILE *stream;

		CString strDir;
		CFileFind findFile;
		BOOL IsFild, IsDir;
		IsFild = FALSE;
		IsDir = FALSE;

		strDir  = "D:\\VisionASMLog";

		IsFild = findFile.FindFile(strDir);
		while (IsFild)
		{
			IsFild = findFile.FindNextFile();
			IsDir = findFile.IsDirectory();
			if(IsDir) break;
		}	
		if (!IsDir)
		{
			if (!CreateDirectory(strDir, NULL))// 创建文件夹
			{

				return ;
			}
		}


		strPath.Format("D:\\VisionASMLog\\AlignToolProductInfo_Platform%d.txt",nPlatformIndex);
		stream = fopen(strPath, _T("a+t"));
		if (stream != NULL)
		{
			fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
			fclose(stream);	
		}

		CFileStatus fs;
		CFile::GetStatus(strPath,fs);
		if (fs.m_size > 5000000)//1048576)
		{
			::DeleteFile(strPath);
		}
	}
}





// iyo
// void vcBaseAlignTool::GetAlignerResultStateType(enumAlignerResultStateType & _TempenumAlignerResultStateType,CMarkImagePos ImageResults)
// {
// 	_TempenumAlignerResultStateType = eAlignerResultOK;
// 
// 	int nNGNumber = 0;
// 	for (int i=0; i<ImageResults.m_vPos.size(); i++)
// 	{
// 		if(FALSE == ImageResults.m_vbOK.at(i))	
// 		{
// 			nNGNumber++;
// 		}
// 	}
// 	if (nNGNumber == 0)
// 	{
// 		return;
// 	}
// 	if (nNGNumber == 1)
// 	{
// 		for (int i=0; i<ImageResults.m_vPos.size(); i++)
// 		{
// 			if(FALSE == ImageResults.m_vbOK.at(i))	
// 			{
// 				_TempenumAlignerResultStateType = (enumAlignerResultStateType)(i+1);
// 			}
// 		}
// 	}
// 	else
// 	{
// 		_TempenumAlignerResultStateType = eAlignerResultNG;
// 	}
// 	return;
// }

//计算并保存关联映射的数据
// void vcBaseAlignTool::SaveCalibTargetProjectData(int nCamIndex,int nBaseCamIndex,std::vector<sc2Vector>& tarImgPos,std::vector<sc2Vector>& objImgPos)
// {
// 
// 	CString strRecordFilePath("D:\\VisionASMLog\\");
// 	CreateMultipleDirectory(strRecordFilePath,'\\');
// 	std::vector<sc2Vector> tar2objImgPos;
// 	std::vector<sc2Vector> obj2tarImgPos;
// 	 
// 	if(tarImgPos.size()!= objImgPos.size())
// 	{
// 		return;
// 	}
// 
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 	int nRemBaseCamIndex = nBaseCamIndex%m_iMarkNum;
// 	int nProductIndex = m_AlignermentParam.GetProductIndex();
// 	double h[9],hBase[9];
// 	memset(h, 0.0, sizeof(double)*9);
// 	memset(hBase, 0.0, sizeof(double)*9);
// 	m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferH(h);
// 	m_vCalibratedInfos.at(nBaseCamIndex)->GetPlatformTransferH(hBase);
// 
// 	if (m_bTarObjCamSepNoAxisCalib == TRUE)
// 	{
// 
// 		for(int i=0;i<tarImgPos.size();i++)
// 		{
// 			tar2objImgPos.push_back(sfHomographyProject(tarImgPos.at(i),h));
// 		}
// 		for(int i=0;i<objImgPos.size();i++)
// 		{
// 			obj2tarImgPos.push_back(sfHomographyInverseProject(objImgPos.at(i),h));
// 		}
// 
// 	}
// 	else
// 	{
// 
// 		std::vector<CCoordPos> objImgCoordPos;
// 
// 		std::vector<sc2Vector> tar2PlatPos;
// 		std::vector<CCoordPos> obj2PlatCoordPos;
// 
// 		tar2PlatPos.resize(tarImgPos.size());
// 		obj2PlatCoordPos.resize(objImgPos.size());
// 		for(int i=0;i<tarImgPos.size();i++)
// 		{
// 			//tar2PlatPos[i] = sfHomographyProject(tarImgPos.at(i) - m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos().GetPos(),h)+
// 			//	m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPos();
// 			sc2Vector tarMarkPlatPos=m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPos();
// 			sc2Vector objMarkPlatPos=m_vCalibratedInfos.at(nBaseCamIndex)->GetMarkPlatformCoordPos().GetPos();
// 			sc2Vector tarObjAxisOffset;
// 			CPlatformXYDInfo*     pPlatformParam =	(CPlatformXYDInfo*)m_pPlatformParam; 
// 
// 			tarObjAxisOffset.SetX(pPlatformParam->m_nPlatformXCoordType * (
// 				((CPlatformXYDAxisPos*)m_vCalibratedInfos.at(nCamIndex)->GetPlatformAxisPos())->m_dPosX - 
// 				((CPlatformXYDAxisPos*)m_vCalibratedInfos.at(nBaseCamIndex)->GetPlatformAxisPos())->m_dPosX));
// 				
// 			tarObjAxisOffset.SetY(pPlatformParam->m_nPlatformYCoordType * (
// 				((CPlatformXYDAxisPos*)m_vCalibratedInfos.at(nCamIndex)->GetPlatformAxisPos())->m_dPosY - 
// 				((CPlatformXYDAxisPos*)m_vCalibratedInfos.at(nBaseCamIndex)->GetPlatformAxisPos())->m_dPosY));
// 
// 			sc2Vector tar2objPlatOffset =sfHomographyProject(tarImgPos.at(i)-m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos().GetPos(),h) + tarMarkPlatPos - objMarkPlatPos + tarObjAxisOffset;
// 
// 			//sc2Vector tar2objPlatOffset = tar2PlatPos.at(i) - m_vCalibratedInfos.at(nBaseCamIndex)->GetMarkPlatformCoordPos().GetPos();
// 			sc2Vector tar2objImgOffset = sfHomographyInverseProject(tar2objPlatOffset,hBase);
// 			tar2objImgPos.push_back(tar2objImgOffset + m_vCalibratedInfos.at(nBaseCamIndex)->GetMarkImgCoordPos().GetPos());
// 		}
// 
// 		for(int i=0;i<objImgPos.size();i++)
// 		{
// 			objImgCoordPos.push_back(CCoordPos(objImgPos.at(i).GetX(),	objImgPos.at(i).GetY(),	0));
// 			if(!ConvertImagePosToCurPlatformPos(obj2PlatCoordPos[i],  nBaseCamIndex, objImgCoordPos[i], m_pTargetPlatformAxisPos.at(nRemBaseCamIndex)))
// 			{
// 				return;
// 			}
// 			sc2Vector obj2tarPlatOffset = obj2PlatCoordPos.at(i).GetPos() - m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPos();
// 			sc2Vector obj2tarImgOffset = sfHomographyInverseProject(obj2tarPlatOffset,h);
// 			obj2tarImgPos.push_back(obj2tarImgOffset + m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos().GetPos());
// 		}
// 		
// 	}
// 	int nCurProdcutIndex = m_AlignermentParam.GetProductIndex();
// 	CString strRecordFileFullPath;
// 	strRecordFileFullPath.Format(_T("%s_CorrelationLog.txt"),strRecordFileFullPathLog);
// 	
// 
// 	CString strTmpSave;
// 	
// 	strTmpSave.AppendFormat(_T("\n位置 %d 关联定位点投影、反投影校验信息:\n"),nCamIndex);
// 	strTmpSave.AppendFormat("CameraIndex is %d ,TransferH:\n%0.8f\t%0.8f\t%0.8f\n%0.8f\t%0.8f\t%0.8f\n%0.8f\t%0.8f\t%0.8f\n",nCamIndex,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8]);
// 	strTmpSave.AppendFormat("BaseCameraIndex is %d ,BaseTransferH:\n%0.8f\t%0.8f\t%0.8f\n%0.8f\t%0.8f\t%0.8f\n%0.8f\t%0.8f\t%0.8f\n",nBaseCamIndex,hBase[0],hBase[1],hBase[2],hBase[3],hBase[4],hBase[5],hBase[6],hBase[7],hBase[8]);
// 
// 	strTmpSave.AppendFormat(_T("Index\t"));
// 	strTmpSave.AppendFormat(_T("TarX\tTarY\t"));
// 	strTmpSave.AppendFormat(_T("O2TX\tO2TY\t"));
// 	strTmpSave.AppendFormat(_T("O2TErrX\tO2TErrY\t"));
// 	strTmpSave.AppendFormat(_T("ObjX\tObjY\t"));
// 	strTmpSave.AppendFormat(_T("T2OX\tT2OY\t"));
// 	strTmpSave.AppendFormat(_T("T2OErrX\tT2OErrY\n"));
// 	for (int nIndex = 0; nIndex < tarImgPos.size(); nIndex++)
// 	{
// 		// 编号
// 		strTmpSave.AppendFormat("%d\t ",nIndex);
// 		// 目标点
// 		strTmpSave.AppendFormat("%0.2lf\t%0.2lf\t",tarImgPos.at(nIndex).GetX(),tarImgPos.at(nIndex).GetY());
// 		//对象转换到目标的点
// 		strTmpSave.AppendFormat("%0.2lf\t%0.2lf\t",obj2tarImgPos.at(nIndex).GetX(),obj2tarImgPos.at(nIndex).GetY());
// 		//对象转换到目标的点与目标点的误差
// 		strTmpSave.AppendFormat("%0.2lf\t%0.2lf\t",obj2tarImgPos.at(nIndex).GetX()-tarImgPos.at(nIndex).GetX(),
// 			obj2tarImgPos.at(nIndex).GetY()-tarImgPos.at(nIndex).GetY());
// 
// 		// 对象点
// 		strTmpSave.AppendFormat("%0.2lf\t%0.2lf\t",objImgPos.at(nIndex).GetX(),objImgPos.at(nIndex).GetY());
// 		//目标转换到对象的点
// 		strTmpSave.AppendFormat("%0.2lf\t%0.2lf\t",tar2objImgPos.at(nIndex).GetX(),tar2objImgPos.at(nIndex).GetY());
// 		//目标转换到对象的点与对象点的误差
// 		strTmpSave.AppendFormat("%0.2lf\t%0.2lf\t\n",tar2objImgPos.at(nIndex).GetX()-objImgPos.at(nIndex).GetX(),
// 			tar2objImgPos.at(nIndex).GetY()-objImgPos.at(nIndex).GetY());
// 	}
// 	AlignToolCalibTargetLogRecord(strRecordFileFullPath,strTmpSave);
// 	
// }


void vcBaseAlignTool::CalculateCalibTargetProcessData(int nCamIndex,int nBaseCamIndex,
	std::vector<sc2Vector>& tarImgPos, std::vector<sc2Vector>& objImgPos,
	std::vector<sc2Vector>& TarImagTransferObjImage,std::vector<sc2Vector>& ObjImagTransferTarImage)
{
	if ( (tarImgPos.size() == 0) || (objImgPos.size() == 0) )
	{
		return;
	}

	if ( (TarImagTransferObjImage.size() == 0) || (ObjImagTransferTarImage.size() == 0))
	{
		return;
	}

	if(tarImgPos.size()!= objImgPos.size())
	{
		return;
	}



	if(TarImagTransferObjImage.size()!= ObjImagTransferTarImage.size())
	{
		return;
	}


	int nRemCamIndex = nCamIndex%m_iMarkNum;
	int nRemBaseCamIndex = nBaseCamIndex%m_iMarkNum;

	double h[9],hBase[9];
	memset(h, 0.0, sizeof(double)*9);
	memset(hBase, 0.0, sizeof(double)*9);
	m_vCalibratedInfos.at(nCamIndex)->GetPlatformTransferH(h);
	m_vCalibratedInfos.at(nBaseCamIndex)->GetPlatformTransferH(hBase);

	std::vector<sc2Vector> tar2objImgPos;		// 目标到对象图像坐标
	std::vector<sc2Vector> obj2tarImgPos;		// 对象到目标图像坐标

	if (m_bTarObjCamSepNoAxisCalib == TRUE)
	{
		for(int i=0;i<tarImgPos.size();i++)
		{
			tar2objImgPos.push_back(sfHomographyProject(tarImgPos.at(i),h));

			TarImagTransferObjImage.at(i) = tar2objImgPos.at(i);
		}

		for(int i=0;i<objImgPos.size();i++)
		{
			obj2tarImgPos.push_back(sfHomographyInverseProject(objImgPos.at(i),h));

			ObjImagTransferTarImage.at(i) = obj2tarImgPos.at(i);
		}

	}
	else
	{
		// 目标到对象图像坐标
		for(int i=0;i<tarImgPos.size();i++)
		{
			sc2Vector tarMarkPlatPos=m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPos();
			sc2Vector objMarkPlatPos=m_vCalibratedInfos.at(nBaseCamIndex)->GetMarkPlatformCoordPos().GetPos();
			sc2Vector tarObjAxisOffset;
			CPlatformXYDInfo*     pPlatformParam =	(CPlatformXYDInfo*)m_pPlatformParam; 

			tarObjAxisOffset.SetX(pPlatformParam->m_nPlatformXCoordType * (
				((CPlatformXYDAxisPos*)m_vCalibratedInfos.at(nCamIndex)->GetPlatformAxisPos())->m_dPosX - 
				((CPlatformXYDAxisPos*)m_vCalibratedInfos.at(nBaseCamIndex)->GetPlatformAxisPos())->m_dPosX));

			tarObjAxisOffset.SetY(pPlatformParam->m_nPlatformYCoordType * (
				((CPlatformXYDAxisPos*)m_vCalibratedInfos.at(nCamIndex)->GetPlatformAxisPos())->m_dPosY - 
				((CPlatformXYDAxisPos*)m_vCalibratedInfos.at(nBaseCamIndex)->GetPlatformAxisPos())->m_dPosY));

			sc2Vector tar2objPlatOffset =sfHomographyProject(tarImgPos.at(i)-m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos().GetPos(),h) + tarMarkPlatPos - objMarkPlatPos + tarObjAxisOffset;

			sc2Vector tar2objImgOffset = sfHomographyInverseProject(tar2objPlatOffset,hBase);
			tar2objImgPos.push_back(tar2objImgOffset + m_vCalibratedInfos.at(nBaseCamIndex)->GetMarkImgCoordPos().GetPos());

			TarImagTransferObjImage.at(i) = tar2objImgPos.at(i);
		}

		// 对象到目标图像坐标
		std::vector<CCoordPos> objImgCoordPos;
		std::vector<CCoordPos> objPlatCoordPos;
		for(int i=0;i<objImgPos.size();i++)
		{
			objImgCoordPos.push_back(CCoordPos(objImgPos.at(i).GetX(),	objImgPos.at(i).GetY(),	0));
			objPlatCoordPos.push_back(CCoordPos(0, 0, 0));

			if(!ConvertImagePosToCurPlatformPos(objPlatCoordPos[i],  nBaseCamIndex, objImgCoordPos[i], m_pTargetPlatformAxisPos.at(nRemBaseCamIndex)))
			{
				return;
			}

			sc2Vector obj2tarPlatOffset = objPlatCoordPos.at(i).GetPos() - m_vCalibratedInfos.at(nCamIndex)->GetMarkPlatformCoordPos().GetPos();
			sc2Vector obj2tarImgOffset = sfHomographyInverseProject(obj2tarPlatOffset,h);
			obj2tarImgPos.push_back(obj2tarImgOffset + m_vCalibratedInfos.at(nCamIndex)->GetMarkImgCoordPos().GetPos());

			ObjImagTransferTarImage.at(i) = obj2tarImgPos.at(i);
		}

	}

}


// void vcBaseAlignTool::SaveCalibTargetProcessData(int nCamIndex,int nBaseCamIndex,int nOutNum ,int nTotolNum,double* h,std::vector<sc2Vector>& tarImgInputPos,std::vector<sc2Vector>& objImgInputPos,std::vector<sc2Vector>& tarImgPosDisCor, std::vector<sc2Vector>& objImgPosDisCor, std::vector<sc2Vector>& tagToObjError, std::vector<sc2Vector>& objToTagError)
// {
// 	int nRemCamIndex = nCamIndex%m_iMarkNum;
// 	int nRemBaseCamIndex = nBaseCamIndex%m_iMarkNum;
// 	{
// 		int nCurProdcutIndex = m_AlignermentParam.GetProductIndex();
// 		//CString strImageFileDirt;
// 		char ch = '\\';
// 		//strImageFileDirt.Format(m_strDataRecord + _T("\\CalibRecordData\\ProdcutIndex%d\\GuanLian\\Ex%d\\"),nCurProdcutIndex,m_nAlignnExProductIndex);
// 		CString strRecordFilePath("D:\\VisionASMLog\\");
// 		CreateMultipleDirectory(strRecordFilePath,'\\');
// 		int nProductIndex = m_AlignermentParam.GetProductIndex();
// 		/*CString strRecordFileName;
// 		strRecordFileName.Format(_T("%s Pos%d_InterCrossPoint.txt"),strImageFileDirt,nRemCamIndex);*/
// 		CString strRecordFileFullPath;
// 		//strRecordFileFullPath.Format(_T("%s工位%d_扩展%03d_CorrelationLog.txt"),strRecordFilePath,m_nPlatformIndex+1,nProductIndex+1);
// 
// 		
// 		strRecordFileFullPath.Format(_T("%s_CorrelationLog.txt"),strRecordFileFullPathLog);
// 		
// 
// 		CString strTmpSave;
// 		strTmpSave.Format("H,%0.6f,%0.6f,%0.6f,%0.6f,%0.6f,%0.6f,%0.6f,%0.6f,%0.6f",h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8]);
// 		AlignToolCalibTargetLogRecord(strRecordFileFullPath,strTmpSave,true);
// 		strTmpSave.Format(_T("Sum,%d, OutLine,%d\n"),nTotolNum,nOutNum);
// 		strTmpSave.AppendFormat(_T("Index\t TarX,TarY\t"));
// 		if ( m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor )
// 		{
// 			strTmpSave.AppendFormat(_T(" TarDisCorX,TarDisCorY\t"));
// 		}
// 		strTmpSave.AppendFormat(_T(" ObjX,ObjY\t"));
// 		if (m_vpCalibrateParam[nRemBaseCamIndex]->m_nEnableDisCor)
// 		{
// 			strTmpSave.AppendFormat(_T("ObjDisCorX,ObjDisCorY\t"));
// 		}
// 
// 		//strTmpSave.AppendFormat(_T("目标投影对象X\t目标投影对象Y\t"));
// 		strTmpSave.AppendFormat(_T("ProjectErrorX,ProjectErrorY,ProjectErrorD\t"));
// 		strTmpSave.AppendFormat(_T("InvProjectErrorX,InvProjectErrorY,InvProjectErrorD"));
// 		AlignToolCalibTargetLogRecord(strRecordFileFullPath,strTmpSave);
// 
// 		sc2Vector tarSrcPoint;
// 		sc2Vector tarProjectToObj;
// 		strTmpSave = _T("");
// 		double dTmpX = 0.0;
// 		double dTmpY = 0.0;
// 		for (int nIndex = 0; nIndex < tarImgInputPos.size(); nIndex++)
// 		{
// 			// 目标点，校正前后
// 			strTmpSave.AppendFormat("%d\t",nIndex);
// 			strTmpSave.AppendFormat("%0.2lf, %0.2lf\t",tarImgInputPos.at(nIndex).GetX(),tarImgInputPos.at(nIndex).GetY());
// 
// 			if (m_vpCalibrateParam[nRemCamIndex]->m_nEnableDisCor)
// 			{
// 				strTmpSave.AppendFormat("%0.2lf, %0.2lf\t",tarImgPosDisCor.at(nIndex).GetX(),tarImgPosDisCor.at(nIndex).GetY());
// 				tarSrcPoint = tarImgPosDisCor.at(nIndex);
// 			}else
// 			{
// 				tarSrcPoint = tarImgInputPos.at(nIndex);	
// 			}
// 			tarProjectToObj = sfHomographyProject(tarSrcPoint,h);
// 
// 			// 对象点校正前后
// 			strTmpSave.AppendFormat("%5.2lf, %5.2lf\t",objImgInputPos.at(nIndex).GetX(),objImgInputPos.at(nIndex).GetY());
// 			if (m_vpCalibrateParam[nRemBaseCamIndex]->m_nEnableDisCor)
// 			{
// 				strTmpSave.AppendFormat("%5.2lf, %5.2lf\t",objImgPosDisCor.at(nIndex).GetX(),objImgPosDisCor.at(nIndex).GetY());
// 			}
// 
// 			// 目标转换到对象的点
// 			//strTmpSave.AppendFormat("%0.2lf, %0.2lf\t",tarProjectToObj.GetX(),tarProjectToObj.GetY());
// 
// 			// 目标到对象的投影误差
// 			dTmpX = tagToObjError.at(nIndex).GetX();
// 			dTmpY = tagToObjError.at(nIndex).GetY();
// 			strTmpSave.AppendFormat("%5.2lf, %5.2lf, %5.2lf\t",dTmpX, dTmpY, sqrt(dTmpX*dTmpX + dTmpY*dTmpY));
// 
// 			// 目标到对象的反投影误差
// 			dTmpX = objToTagError.at(nIndex).GetX();
// 			dTmpY = objToTagError.at(nIndex).GetY();
// 			strTmpSave.AppendFormat("%5.2lf, %5.2lf, %5.2lf\n",dTmpX, dTmpY, sqrt(dTmpX*dTmpX + dTmpY*dTmpY));
// 		}
// 		AlignToolCalibTargetLogRecord(strRecordFileFullPath,strTmpSave);
// 	}
// }



/* 
功能：
	创建多级目录
参数：
	CString& szPath	文件路径名
	char split		分割字符，根据路径设置
*/
/************************************************************************/
// bool vcBaseAlignTool::CreateMultipleDirectory(CString& szPath, char split)
// {
// 	CString strDir(szPath);
// 	//	检测路径是否以 结尾
// 	if (strDir.GetAt(strDir.GetLength()-1) != split)
// 	{
// 		strDir.AppendChar(split);
// 	}
// 	std::vector<CString> vPath;	//	存放每一层目录字符串
// 	CString strTemp;			//	临时变量,存放目录字符串
// 	bool bSuccess = false;		//	成功标志
// 	// 遍历要创建的字符串
// 	for (int i=0;i<strDir.GetLength();++i)
// 	{
// 		if (strDir.GetAt(i) != split) // 如果当前字符不是 split('\','//')
// 		{
// 			strTemp.AppendChar(strDir.GetAt(i));
// 		}
// 		else //如果当前字符是'\\'
// 		{
// 			vPath.push_back(strTemp);//将当前层的字符串添加到数组中
// 			strTemp.AppendChar(split);
// 		}
// 	}
// 
// 	//	遍历存放目录的数组,创建每层目录
// 	std::vector<CString>::const_iterator vIter;
// 	for (vIter = vPath.begin(); vIter != vPath.end(); vIter++) 
// 	{
// 		//	如果CreateDirectory执行成功,返回true,否则返回false
// 		bSuccess = CreateDirectory(*vIter, NULL) ? true : false;    
// 	}
// 
// 	return bSuccess;
// }

// void vcBaseAlignTool::AlignToolCalibTargetLogRecord(CString strPathFileName,CString strLog,bool bLogTimeEnable)
// {
// 	CString strTemp = "";
// 	if (bLogTimeEnable)
// 	{
// 		SYSTEMTIME sys; 
// 		GetLocalTime( &sys ); 
// 		CString t;
// 		t.Format("[%02d_%02d_%02d_%02d_%02d_%03d]\n",sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
// 		strTemp += t;
// 	}
// 
// 	strTemp += strLog;
// 	strTemp += "\n";
// 	FILE *stream;
// 
// 	CString strPath;
// 	strPath = strPathFileName;
// 	stream = fopen(strPath, _T("a+t"));
// 	if (stream != NULL)
// 	{
// 		fwrite(strTemp, sizeof(TCHAR), strTemp.GetLength(), stream);
// 		fclose(stream);	
// 	}
// 
// 	CFileStatus fs;
// 	CFile::GetStatus(strPath,fs);
// 	if (fs.m_size > 5000000)//1048576)
// 	{
// 		::DeleteFile(strPath);
// 	}
// }

BOOL vcBaseAlignTool::IsExecuteCoordinateCompensation()
{
	double dAlignerBaseOffsetX = m_AlignermentParam.GetAlignerBaseOffset().GetPosX();
	double dAlignerBaseOffsetY = m_AlignermentParam.GetAlignerBaseOffset().GetPosY();
	double dAlignerBaseOffsetD = m_AlignermentParam.GetAlignerBaseOffset().GetAngle();

	double dAlignerOffsetX = m_AlignermentParam.GetAlignerOffset().GetPosX();
	double dAlignerOffsetY = m_AlignermentParam.GetAlignerOffset().GetPosY();
	double dAlignerOffsetD = m_AlignermentParam.GetAlignerOffset().GetAngle();

	BOOL bCoordinateCompensation = (fabs(dAlignerBaseOffsetX) > 0.000001) || (fabs(dAlignerBaseOffsetY) > 0.000001) || (fabs(dAlignerBaseOffsetD) > 0.000001) || 
		(fabs(dAlignerOffsetX) > 0.000001)     || (fabs(dAlignerOffsetY) > 0.000001)     || (fabs(dAlignerOffsetD) > 0.000001);

	return bCoordinateCompensation;
}

BOOL vcBaseAlignTool::ExecuteCoordinateCompensation(std::vector<CCoordPos> vObjectPlatformPos, std::vector<CCoordPos> vVirtualObjectPlatformPos, std::vector<CCoordPos>& vFixedObjectPlatformPos)
{
	double dAlignerBaseOffsetX = m_AlignermentParam.GetAlignerBaseOffset().GetPosX();
	double dAlignerBaseOffsetY = m_AlignermentParam.GetAlignerBaseOffset().GetPosY();
	double dAlignerBaseOffsetD = m_AlignermentParam.GetAlignerBaseOffset().GetAngle();

	double dAlignerOffsetX = m_AlignermentParam.GetAlignerOffset().GetPosX();
	double dAlignerOffsetY = m_AlignermentParam.GetAlignerOffset().GetPosY();
	double dAlignerOffsetD = m_AlignermentParam.GetAlignerOffset().GetAngle();

	BOOL bOffset = (fabs(dAlignerBaseOffsetX) > 0.000001) || (fabs(dAlignerBaseOffsetY) > 0.000001) || (fabs(dAlignerBaseOffsetD) > 0.000001) || 
		(fabs(dAlignerOffsetX) > 0.000001)     || (fabs(dAlignerOffsetY) > 0.000001)     || (fabs(dAlignerOffsetD) > 0.000001);


	CProductSizeInfo ProductSizeInfo = m_AlignermentParam.GetProductSizeInfo();
	int nPositionModeInfo = m_AlignermentParam.GetPositionModeInfo();


	std::vector<CCoordPos> vObjectRotationPlatformPos;
	std::vector<CCoordPos> vObjectTranslationPlatformPos;
	vObjectRotationPlatformPos.resize(m_iMarkNum);
	vObjectTranslationPlatformPos.resize(m_iMarkNum);

	CString str;
	int nPlatformIndex = m_nPlatformIndex;
	switch(m_AlignermentParam.GetAlignerOffsetCoordType())
	{
	case eMarkCoord:
		{
			if (bOffset)
			{
				if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
				{
					MarkCoordOffsetRotationObjectPlatformPos(vVirtualObjectPlatformPos, vObjectRotationPlatformPos);
				}
				else
				{
					MarkCoordOffsetRotationObjectPlatformPos(vObjectPlatformPos, vObjectRotationPlatformPos);
				}

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("Mark角度补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectRotationPlatformPos.at(i).GetPosX(), vObjectRotationPlatformPos.at(i).GetPosY(), vObjectRotationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				MarkCoordOffsetXYObjectPltfmPt(vObjectRotationPlatformPos, vObjectTranslationPlatformPos);
				

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("Mark平移补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectTranslationPlatformPos.at(i).GetPosX(), vObjectTranslationPlatformPos.at(i).GetPosY(), vObjectTranslationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				vFixedObjectPlatformPos = vObjectTranslationPlatformPos;
			}
			else
			{
				vFixedObjectPlatformPos = vObjectPlatformPos;
			}
		}
		break;

	case ePlatformCoord:
		{
			if (bOffset)
			{					
				if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
				{
					PltfmCoordOffsetRotationObjectPltfmPt(vVirtualObjectPlatformPos, vObjectRotationPlatformPos);
				}
				else
				{
					PltfmCoordOffsetRotationObjectPltfmPt(vObjectPlatformPos, vObjectRotationPlatformPos);
				}

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("平台角度补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectRotationPlatformPos.at(i).GetPosX(), vObjectRotationPlatformPos.at(i).GetPosY(), vObjectRotationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				PltfmCoordOffsetXYObjectPltfmPt(vObjectRotationPlatformPos, vObjectTranslationPlatformPos);

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("Mark平移补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectTranslationPlatformPos.at(i).GetPosX(), vObjectTranslationPlatformPos.at(i).GetPosY(), vObjectTranslationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				vFixedObjectPlatformPos = vObjectTranslationPlatformPos;

			}
			else
			{
				vFixedObjectPlatformPos = vObjectPlatformPos;
			}
		}
		break;

	case eMarkPlatformCoord:
		{
			if (bOffset)
			{			
				// Mark坐标系下旋转角度进行补偿
				if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
				{
					MarkCoordOffsetRotationObjectPlatformPos(vVirtualObjectPlatformPos, vObjectRotationPlatformPos);
				}
				else
				{
					MarkCoordOffsetRotationObjectPlatformPos(vObjectPlatformPos, vObjectRotationPlatformPos);
				}

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("混合角度补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectRotationPlatformPos.at(i).GetPosX(), vObjectRotationPlatformPos.at(i).GetPosY(), vObjectRotationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				// 全局平台坐标系下XY轴平移量进行补偿
				PltfmCoordOffsetXYObjectPltfmPt(vObjectRotationPlatformPos, vObjectTranslationPlatformPos);

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("混合平移补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectTranslationPlatformPos.at(i).GetPosX(), vObjectTranslationPlatformPos.at(i).GetPosY(), vObjectTranslationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				vFixedObjectPlatformPos = vObjectTranslationPlatformPos;

			}
			else
			{
				vFixedObjectPlatformPos = vObjectPlatformPos;
			}
		}
		break;

	case eMarkCoordDiagonal:
		{
			if ( (ProductSizeInfo.m_dObjectL1 <= 0) || (ProductSizeInfo.m_dObjectW1 <= 0) || (ProductSizeInfo.m_dTargetL2 <= 0) || (ProductSizeInfo.m_dTargetW2 <= 0) )
			{
				return FALSE;
			}

			if ( (nPositionModeInfo < 0) || (nPositionModeInfo > 1) )
			{
				return FALSE;
			}

			if (bOffset)
			{
				scDegree degRotate1 = scDegree(0);
				scDegree degRotate2 = scDegree(dAlignerOffsetD + dAlignerBaseOffsetD);

				// 旋转角度-界面补偿值
				if (m_AlignermentParam.GetProductOffsetInfo().m_bEnableProductOffsetDDirection)
				{
					degRotate2 = -degRotate2;
				}

				// 旋转角度-产品对角线角度
				if (!AngleOffsetCalculate(ProductSizeInfo.m_dObjectL1, ProductSizeInfo.m_dObjectW1, ProductSizeInfo.m_dTargetL2, ProductSizeInfo.m_dTargetW2,
					nPositionModeInfo, degRotate1))
				{
					return FALSE;
				}
				scDegree degRotate = degRotate1 + degRotate2;

				std::vector<CCoordPos> vObjectPlatformCoordPosDirection;
				if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
				{
					MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, vVirtualObjectPlatformPos, vObjectRotationPlatformPos);
					vObjectPlatformCoordPosDirection = vVirtualObjectPlatformPos;
				}
				else
				{
					MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, vObjectPlatformPos, vObjectRotationPlatformPos);
					vObjectPlatformCoordPosDirection = vObjectPlatformPos;
				}

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("对角1角度补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectRotationPlatformPos.at(i).GetPosX(), vObjectRotationPlatformPos.at(i).GetPosY(), vObjectRotationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}


				// 对角Mark坐标系下XY轴平移量进行补偿
				sc2Vector offsetXY = sc2Vector(dAlignerOffsetX + dAlignerBaseOffsetX, dAlignerOffsetY + dAlignerBaseOffsetY);

				// 方向X
				if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXDirection)
				{
					offsetXY = sc2Vector(-offsetXY.GetX(), offsetXY.GetY());
				}

				// 方向Y
				if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYDirection)
				{
					offsetXY = sc2Vector(offsetXY.GetX(), -offsetXY.GetY());
				}

				// X补偿与Y补偿对调
				if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXSetting)
				{
					offsetXY = sc2Vector(offsetXY.GetY(), offsetXY.GetX());
				}

				if (ProductSizeInfo.m_bOffsetXYEnable)
				{
					double dOffsetX = 0, dOffsetY = 0;
					if (!XYOffsetCalculate(ProductSizeInfo.m_dObjectL1, ProductSizeInfo.m_dObjectW1, ProductSizeInfo.m_dTargetL2, ProductSizeInfo.m_dTargetW2,
						ProductSizeInfo.m_dF1, ProductSizeInfo.m_dF2, nPositionModeInfo, dOffsetX, dOffsetY))
					{
						return FALSE;
					}

					offsetXY += sc2Vector(dOffsetX, dOffsetY);
				}

				MarkCoordDiagonalOffsetXYObjectPltfmPt(vObjectRotationPlatformPos, vObjectPlatformCoordPosDirection, offsetXY, vObjectTranslationPlatformPos);

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("对角1平移补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectTranslationPlatformPos.at(i).GetPosX(), vObjectTranslationPlatformPos.at(i).GetPosY(), vObjectTranslationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				vFixedObjectPlatformPos = vObjectTranslationPlatformPos;
			}
			else
			{
				vFixedObjectPlatformPos = vObjectPlatformPos;
			}

			// 辅助位置
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
			{
				return FALSE;
			}
		}
		break;

	case eMarkCoordDiagonal2:
		{
			if ( (ProductSizeInfo.m_dObjectL1 <= 0) || (ProductSizeInfo.m_dObjectW1 <= 0) || (ProductSizeInfo.m_dTargetL2 <= 0) || (ProductSizeInfo.m_dTargetW2 <= 0) )
			{
				return FALSE;
			}

			if ( (nPositionModeInfo < 0) || (nPositionModeInfo > 1) )
			{
				return FALSE;
			}

			// 对角Mark坐标系下旋转角度进行补偿
			if (bOffset)
			{
				scDegree degRotate1 = scDegree(0);
				scDegree degRotate2 = scDegree(dAlignerOffsetD + dAlignerBaseOffsetD);

				// 旋转角度
				if (m_AlignermentParam.GetProductOffsetInfo().m_bEnableProductOffsetDDirection)
				{
					degRotate2 = -degRotate2;
				}

				if (!AngleOffsetCalculate(ProductSizeInfo.m_dObjectL1, ProductSizeInfo.m_dObjectW1, ProductSizeInfo.m_dTargetL2, ProductSizeInfo.m_dTargetW2,
					nPositionModeInfo, degRotate1))
				{
					return FALSE;
				}
				scDegree degRotate = degRotate1 + degRotate2;

				std::vector<CCoordPos> vObjectPlatformCoordPosDirection;
				if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
				{
					MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, vVirtualObjectPlatformPos, vObjectRotationPlatformPos);
					vObjectPlatformCoordPosDirection = vVirtualObjectPlatformPos;
					MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate2, vVirtualObjectPlatformPos, vObjectPlatformCoordPosDirection);
				}
				else
				{
					MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, vObjectPlatformPos, vObjectRotationPlatformPos);
					vObjectPlatformCoordPosDirection = vObjectPlatformPos;
					MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate2, vObjectPlatformPos, vObjectPlatformCoordPosDirection);

				}

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("对角2角度补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectPlatformCoordPosDirection.at(i).GetPosX(), vObjectPlatformCoordPosDirection.at(i).GetPosY(), vObjectPlatformCoordPosDirection.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				// 对角Mark坐标系下XY轴平移量进行补偿
				sc2Vector offsetXY = sc2Vector(dAlignerOffsetX + dAlignerBaseOffsetX, dAlignerOffsetY + dAlignerBaseOffsetY);

				// 方向X
				if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXDirection)
				{
					offsetXY = sc2Vector(-offsetXY.GetX(), offsetXY.GetY());
				}

				// 方向Y
				if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYDirection)
				{
					offsetXY = sc2Vector(offsetXY.GetX(), -offsetXY.GetY());
				}

				// X补偿与Y补偿对调
				if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXSetting)
				{
					offsetXY = sc2Vector(offsetXY.GetY(), offsetXY.GetX());
				}

				if (m_AlignermentParam.GetProductSizeInfo().m_bOffsetXYEnable)
				{
					double dOffsetX = 0, dOffsetY = 0;
					if (!XYOffsetCalculate(ProductSizeInfo.m_dObjectL1, ProductSizeInfo.m_dObjectW1, ProductSizeInfo.m_dTargetL2, ProductSizeInfo.m_dTargetW2,
						ProductSizeInfo.m_dF1, ProductSizeInfo.m_dF2, nPositionModeInfo, dOffsetX, dOffsetY))
					{
						return FALSE;
					}

					offsetXY += sc2Vector(dOffsetX, dOffsetY);
				}

				MarkCoordDiagonalOffsetXYObjectPltfmPt(vObjectRotationPlatformPos, vObjectPlatformCoordPosDirection, offsetXY, vObjectTranslationPlatformPos);

				for (int i = 0; i < vObjectPlatformPos.size(); i++)
				{
					str.Format(_T("对角2平移补偿后平台坐标%d: X = %f, Y = %f, D = %f,"), i, vObjectTranslationPlatformPos.at(i).GetPosX(), vObjectTranslationPlatformPos.at(i).GetPosY(), vObjectTranslationPlatformPos.at(i).GetAngle());
					AlignToolLogRecord(str,nPlatformIndex);
				}

				vFixedObjectPlatformPos = vObjectTranslationPlatformPos;
			}
			else
			{
				vFixedObjectPlatformPos = vObjectPlatformPos;
			}

			// 辅助位置
			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
			{
				return FALSE;
			}

		}
		break;

	default:
		{
			return FALSE;
		}
		break;
	}

	return TRUE;
}


BOOL vcBaseAlignTool::GetAlignOffsetRevise(std::vector<CCoordPos> vcpObjectPlatformPos, std::vector<CCoordPos> vcpTargetPlatformPos, const CCoordPos& cpPlatformOffset, CCoordPos& cpPlatformOffsetRevise)
{
	if (m_bTargetObjectCamSeparate)
	{
		return false;
	}


	CString str;
	str.Format("计算回转角度开始-----");
	AlignToolLogRecord(str, m_nPlatformIndex);
	// 1.获取产品的对象位置和角度
	sc2Vector vProductObjectPos;
	scDegree  degProductObjectAngle;
	GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos, degProductObjectAngle,FALSE,TRUE);
	str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos.GetX(),vProductObjectPos.GetY(),degProductObjectAngle.ToDouble());
	AlignToolLogRecord(str, m_nPlatformIndex);

	// 2.获取产品的目标位置和角度
	sc2Vector vProductTargetPos;
	scDegree  degProductTargetAngle;
	GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos, degProductTargetAngle,FALSE,FALSE);
	str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos.GetX(),vProductTargetPos.GetY(),degProductTargetAngle.ToDouble());
	AlignToolLogRecord(str, m_nPlatformIndex);


	double dPlatformOffsetX1 = cpPlatformOffset.m_dPosX;
	double dPlatformOffsetY1 = cpPlatformOffset.m_dPosY;
	double dPlatformOffsetD1 = cpPlatformOffset.m_dAngle;

	double dPlatformOffestX2 = 0;
	double dPlatformOffsetY2 = 0;
	double dPlatformOffsetD2 = 0;




	if (GetMidPlatformType() == ePlatformXD)
	{
		dPlatformOffsetX1 = 0;
		dPlatformOffsetY2 = sin(scDegree(-dPlatformOffsetD1))*dPlatformOffsetX1 + cos(scDegree(-dPlatformOffsetD1))*dPlatformOffsetY1;	
		dPlatformOffestX2 = cos(scDegree(-dPlatformOffsetD1))*dPlatformOffsetX1 - sin(scDegree(-dPlatformOffsetD1))*dPlatformOffsetY1;

		dPlatformOffestX2 = -dPlatformOffestX2;
	}
	else if (GetMidPlatformType() == ePlatformYD)
	{
		dPlatformOffsetY1 = 0;

		dPlatformOffestX2 = cos(scDegree(-dPlatformOffsetD1))*dPlatformOffsetX1 - sin(scDegree(-dPlatformOffsetD1))*dPlatformOffsetY1;
		dPlatformOffsetY2 = sin(scDegree(-dPlatformOffsetD1))*dPlatformOffsetX1 + cos(scDegree(-dPlatformOffsetD1))*dPlatformOffsetY1;	
		dPlatformOffsetY2 = -dPlatformOffsetY2;
	}
	else if (GetMidPlatformType() == ePlatformXYD)
	{
		dPlatformOffestX2 = 0;
		dPlatformOffsetY2 = 0;
		dPlatformOffsetD2 = 0;
	}
	else
	{
		return FALSE;
	}


	str.Format(_T("三角函数值:COS(-D)=Y=%.6f Sin(-D)=%.6f"), 
		cos(scDegree(-dPlatformOffsetD1)), sin(scDegree(-dPlatformOffsetD1)));
	AlignToolLogRecord(str, m_nPlatformIndex);


	cpPlatformOffsetRevise.m_dPosX =  dPlatformOffestX2;
	cpPlatformOffsetRevise.m_dPosY =  dPlatformOffsetY2;
	cpPlatformOffsetRevise.m_dAngle = 0;

	str.Format(_T("修正平台X=%.6f 修正平台Y=%.6f"), 
		dPlatformOffestX2, dPlatformOffsetY2);
	AlignToolLogRecord(str, m_nPlatformIndex);

	str.Format("计算回转角度结束-----");
	AlignToolLogRecord(str, m_nPlatformIndex);

	return TRUE;
}



// 对位偏差计算：成功，返回TRUE；否则，返回FALSE
BOOL vcBaseAlignTool::ExecuteAlign(int nAlnIndex/* = 0*/, BOOL bInspect /*= TRUE*/)
{
	if (m_bPlatformPick)
	{
		return ExecuteAlignPick(nAlnIndex);
	}


	// 目标、对象不分离
	if (!m_bTargetObjectCamSeparate && !m_bEnableTargetAndObjectPositionVirtualMode /*&& !m_bPlatformTarCamWithDiffObjCam*/)
	{
		return ExecuteAlign_Case1(nAlnIndex);
	}

	// 目标、对象分离
	if (m_bTargetObjectCamSeparate && !m_bEnableTargetAndObjectPositionVirtualMode /*&& !m_bPlatformTarCamWithDiffObjCam*/)
	{
		return ExecuteAlign_Case2(nAlnIndex);
	}

	// 目标、对象分离，目标或者对象通过产品尺寸进行虚拟
	if (m_bTargetObjectCamSeparate && m_bEnableTargetAndObjectPositionVirtualMode /*&& !m_bPlatformTarCamWithDiffObjCam*/)
	{
		BOOL bObjectVirtual = m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;
		BOOL bTargetVirtual = m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode;

		if (bObjectVirtual || bTargetVirtual)
		{
			return ExecuteAlign_Case3(nAlnIndex);
		}
		else
		{
			return ExecuteAlign_Case2(nAlnIndex);
		}		
	}

	// 目标、对象分离，一组目标相机对应两组对象相机
// 	if (m_bTargetObjectCamSeparate && !m_bEnableTargetAndObjectPositionVirtualMode && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		return ExecuteAlign_Case4(nAlnIndex);
// 	}

	return FALSE;
}





// 目标、对象不分离
BOOL vcBaseAlignTool::ExecuteAlign_Case1(int nAlnIndex/* = 0*/, BOOL bInspect /*= TRUE*/)
{

	m_nAlnIndex = nAlnIndex;
//	m_nAlignErrNum = 0;

	for (int i = 0; i < m_iMarkNum; i++)
	{
		if (NULL == m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex))
		{
			m_nAlignErrNum = -1;
			return false;
		}

		if (!m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex)->IsValid())
		{
			m_nAlignErrNum = -2;
			return false;
		}
	}

	// PCB 曝光机定制
// 	if (m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align)
// 	{
// 		CString str;
// 		str.Format("USE PCB-madeSpecial");
// 		AlignToolLogRecord(str,m_nPlatformIndex);
// 
// 		GetAlignerResultStateType(m_targetAlignResultMode,m_TargetSearchResults);
// 
// 		GetAlignerResultStateType(m_objectAlignResultMode,m_ObjectSearchResults);
// 
// 		str.Format("m_targetAlignResultMode:%d,m_objectAlignResultMode:%d",m_targetAlignResultMode,m_objectAlignResultMode);
// 		AlignToolLogRecord(str,m_nPlatformIndex);
// 
// 
// 		if (eAlignerResultNG == m_targetAlignResultMode || eAlignerResultNG == m_objectAlignResultMode)
// 		{
// 			str.Format("USE PCB-madeSpecial,but failed,Because < 3point for align");
// 			AlignToolLogRecord(str,m_nPlatformIndex);
// 			m_PointMethodType = eAlignerErr;
// 			return FALSE;
// 		}
// 		else
// 		{
// 			if ((m_targetAlignResultMode == eAlignerResultNG1 && m_objectAlignResultMode == eAlignerResultOK)
// 				||(m_targetAlignResultMode == eAlignerResultNG1 && m_objectAlignResultMode == eAlignerResultNG1)
// 				||(m_objectAlignResultMode == eAlignerResultNG1 && m_targetAlignResultMode == eAlignerResultOK) )
// 			{
// 				m_PointMethodType = eAligner234_234;
// 			}
// 			else if ((m_targetAlignResultMode == eAlignerResultNG2 && m_objectAlignResultMode == eAlignerResultOK)
// 				||(m_targetAlignResultMode == eAlignerResultNG2 && m_objectAlignResultMode == eAlignerResultNG2)
// 				||(m_objectAlignResultMode == eAlignerResultNG2 && m_targetAlignResultMode == eAlignerResultOK) )
// 			{
// 				m_PointMethodType = eAligner134_134;
// 			}
// 			else if ((m_targetAlignResultMode == eAlignerResultNG3 && m_objectAlignResultMode == eAlignerResultOK)
// 				||(m_targetAlignResultMode == eAlignerResultNG3 && m_objectAlignResultMode == eAlignerResultNG3)
// 				||(m_objectAlignResultMode == eAlignerResultNG3 && m_targetAlignResultMode == eAlignerResultOK) )
// 			{
// 				m_PointMethodType = eAligner124_124;
// 			}
// 			else if ((m_targetAlignResultMode == eAlignerResultNG4 && m_objectAlignResultMode == eAlignerResultOK)
// 				||(m_targetAlignResultMode == eAlignerResultNG4 && m_objectAlignResultMode == eAlignerResultNG4)
// 				||(m_objectAlignResultMode == eAlignerResultNG4 && m_targetAlignResultMode == eAlignerResultOK) )
// 			{
// 				m_PointMethodType = eAligner123_123;
// 			}
// 			else if ((m_targetAlignResultMode == eAlignerResultOK)&&(m_objectAlignResultMode == eAlignerResultOK))
// 			{
// 				m_PointMethodType = eAligner1234_1234;
// 			}
// 			else
// 			{
// 				str.Format("USE PCB-madeSpecial,but failed");
// 				AlignToolLogRecord(str,m_nPlatformIndex);
// 				m_PointMethodType = eAlignerErr;
// 				return FALSE;
// 			}
// 		}
// 	}
// 	else
		if (eObjectBench != m_AlignermentParam.GetObjectMarkType() && FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK())
		{
			m_nAlignErrNum = -3;
			return FALSE;
		}

		//加各种保护
		if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.IsAllMarkImagePosOK())
		{
			m_nAlignErrNum = -4;
			return FALSE;
	}


	// 格式化日志
	CString strTempInfo;
	CString strInfo;

	strTempInfo.Format(",对位序号%d,", nAlnIndex);
	strInfo += strTempInfo;

	strTempInfo.Format("%d位置对位,", m_iMarkNum);
	strInfo += strTempInfo;



	// 详细日志
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("对位计算开始:序号[%d]------------------------------------------------------------",nAlnIndex);
	AlignToolLogRecord(str,nPlatformIndex);


	std::vector<CCoordPos> vcpObjPlatPos;		// 对象位置
	std::vector<CCoordPos> vcpTarPlatPos;		// 目标位置

	vcpObjPlatPos.resize(6);
	vcpTarPlatPos.resize(6);


	std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;	
	for (int k=0;k<m_pObjectPlatformAxisPos.size();k++)
	{
		pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置
	}

	std::vector<CPlatformXYDAxisPos*> pTargetPlatformAxisPos;
	for (int k=0;k<m_pTargetPlatformAxisPos.size();k++)
	{
		pTargetPlatformAxisPos.push_back((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k));//搜索目标mark轴位置
	}
	if(pTargetPlatformAxisPos.size()<m_iMarkNum)
	{
		pTargetPlatformAxisPos.resize(m_iMarkNum);
	}



	// 1. 实时对象Mark的图像坐标值转化为平台坐标值
	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPosForAlign();
	if (FALSE == m_ObjectMarkPlatformPos.IsAllMarkPlatformPosOK())
	{
		m_nAlignErrNum = -5;
		return FALSE;
	}

	// 2. 综合对位方式，对象点重构
	if (IsObjectReConstruct())
	{
		if (FALSE == ExecuteObjectPlatformPosRestruct(m_ObjectMarkPlatformPos.m_vPos))
		{
			m_nAlignErrNum = -6;
			return FALSE;
		}
	}

	// 补偿前对象格式化日志
	{
		for (int i = 0;i < m_pObjectPlatformAxisPos.size(); i++)
		{
			strTempInfo.Format("对象%d轴位置 X:%f Y:%f D:%f,", i, pObjectPlatformAxisPos.at(i)->m_dPosX,pObjectPlatformAxisPos.at(i)->m_dPosY,pObjectPlatformAxisPos.at(i)->m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i=0; i<m_iMarkNum; i++)
		{
			strTempInfo.Format("对象%d图像坐标 X:%f Y:%f D:%f,", i, m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}

		// 对象补偿前点平台坐标
		for (int i=0; i<m_iMarkNum; i++)
		{
			strTempInfo.Format("补偿前对象%d平台坐标 X:%f Y:%f D:%f,", i, m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}
	}


	// 3. 补偿每个相机对应的对象mark平台坐标值
	for (int i=0; i<m_iMarkNum; i++)
	{
		str.Format("对象轴位置%d: X = %f , Y = %f , D = %f ", i, pObjectPlatformAxisPos.at(i)->m_dPosX, pObjectPlatformAxisPos.at(i)->m_dPosY, pObjectPlatformAxisPos.at(i)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("对象图像坐标%d: X = %f , Y = %f , D = %f ",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("补偿前对象平台坐标%d: X = %f , Y = %f , D = %f ",i, m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX(), m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY(), m_ObjectMarkPlatformPos.m_vPos.at(i).GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

		// 记录相机对象mark的坐标
		vcpObjPlatPos[i] = m_ObjectMarkPlatformPos.m_vPos[i];


		// 实时对象为虚拟Mark，则将实时对象Mark的平台坐标值转换为虚拟Mark的平台坐标值
		if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
		{
			if (FALSE == ConvertObjectPltfmPtToVirtualPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos))
				return FALSE;

			vcpObjPlatPos[i] = m_VirtualMarkPlatformPos.m_vPos[i];

			str.Format("补偿前虚拟对象平台坐标%d: X = %f , Y = %f , D = %f ", i, vcpObjPlatPos[i].GetPosX(), vcpObjPlatPos[i].GetPosY(), vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		if (!m_bInnerAlignBench)
		{
			if (TRUE == bInspect)
			{
				// 对象Mark的全局平台坐标值补偿
				if (IsExecuteCoordinateCompensation())
				{
					std::vector<CCoordPos> vFixedObjectPlatformPos;
					vFixedObjectPlatformPos.resize(m_iMarkNum);

					BOOL bOffsetSuccess = ExecuteCoordinateCompensation(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos, vFixedObjectPlatformPos);

					vcpObjPlatPos[i] = vFixedObjectPlatformPos[i];

					if (!bOffsetSuccess)
					{
						m_nAlignErrNum = -7;
						return FALSE;
					}


				}

				str.Format("补偿后对象平台坐标%d: X = %f , Y = %f , D = %f ", i, vcpObjPlatPos[i].GetPosX(), vcpObjPlatPos[i].GetPosY(), vcpObjPlatPos[i].GetAngle());
				AlignToolLogRecord(str,nPlatformIndex);
			}
		}
		else
		{
			CMarkPlatformPos m_ObjectAddRotationOffsetPos;
			m_ObjectAddRotationOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddRotationOffsetPos.m_vbOK.resize(m_iMarkNum);
			CMarkPlatformPos m_ObjectAddMoveOffsetPos;
			m_ObjectAddMoveOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddMoveOffsetPos.m_vbOK.resize(m_iMarkNum);

			if (1/*eMarkCoord == m_AlignermentParam.GetAlignerOffsetCoordType()*/)// Mark坐标系下补偿
			{
				// Mark坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBenchOffset().GetAngle()||m_AlignermentParam.GetAlignerBenchOffset().GetPosX()||m_AlignermentParam.GetAlignerBenchOffset().GetPosY())
				{
					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
						MarkCoordOffsetRotationObjectPlatformPos(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
					else
						MarkCoordOffsetRotationObjectPlatformPos(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);

					// Mark坐标系下XY轴平移量进行补偿
					MarkCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
				}
			}

			str.Format("补偿后对象平台坐标%d: X = %f, Y = %f, D = %f ",i, vcpObjPlatPos[i].GetPosX(), vcpObjPlatPos[i].GetPosY(), vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}

	}


	// 对象补偿后格式化日志
	{

		// 当前使用的补偿类型及补偿数值
		strTempInfo.Format("补偿类型:%d 补偿序号:%d X:%f Y:%f D:%f,",m_AlignermentParam.GetAlignerOffsetCoordType(),m_AlignermentParam.GetCurAlignerOffsetIndex(),m_AlignermentParam.GetAlignerOffset().GetPosX() ,m_AlignermentParam.GetAlignerOffset().GetPosY(), m_AlignermentParam.GetAlignerOffset().GetAngle());
		strInfo += strTempInfo;

		// 实际参与对位计算对象点平台坐标
		for (int i=0; i<m_iMarkNum; i++)
		{
			strTempInfo.Format("补偿后对象%d平台坐标 X:%f Y:%f D:%f,", i, vcpObjPlatPos[i].GetPosX(), vcpObjPlatPos[i].GetPosY(), vcpObjPlatPos[i].GetAngle());
			strInfo += strTempInfo;
		}


		sc2Vector pt[4];
		for (int i=0; i<m_iMarkNum; i++)
		{
			pt[i] = sc2Vector(vcpObjPlatPos[i].GetPosX(), vcpObjPlatPos[i].GetPosY());
		}

		switch(m_iMarkNum)
		{
		case 2:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 3:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;	

				dLen[1] = (pt[1] - pt[2]).Length();
				(pt[1] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("对象12距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("对象02距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 4:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;

				dLen[1] = (pt[3] - pt[2]).Length();
				(pt[3] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("对象23距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("对象02距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;

				dLen[3] = (pt[3] - pt[1]).Length();
				(pt[3] - pt[1]).Angle(raAngle[3]);
				strTempInfo.Format("对象13距离角度 L:%f D:%f,", dLen[3], scDegree(raAngle[3]).ToDouble());
				strInfo += strTempInfo;

			}
			break;

		default:
			{

			}
			break;
		}
	}



	// 4. 实时目标Mark的图像坐标值转化为平台坐标值	
	if (eTargetBench == m_AlignermentParam.GetTargetMarkType())// 目标Mark为基准Mark
	{

	}
	else//目标mark为实时mark
	{
		m_TargetMarkPlatformPos = GetTargetMarkPlatformPosForAlign();
		if (FALSE == m_TargetMarkPlatformPos.IsAllMarkPlatformPosOK())
		{
			m_nAlignErrNum = -8;
			return FALSE;
		}
	}

	// 5. 综合对位模式，目标点重构
// 	if (IsTargetReConstruct())
// 	{
// 		if (FALSE == ExecuteTargetPlatformPosRestruct(m_TargetMarkPlatformPos.m_vPos))
// 		{
// 			return FALSE;
// 		}
// 	}


	// 目标修正前格式化数据记录
	{
		for (int i = 0; i < m_pTargetPlatformAxisPos.size(); i++)
		{
			strTempInfo.Format("目标%d轴位置 X:%f Y:%f D:%f,", i, pTargetPlatformAxisPos.at(i)->m_dPosX, pTargetPlatformAxisPos.at(i)->m_dPosY, pTargetPlatformAxisPos.at(i)->m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i=0; i<m_iMarkNum; i++)
		{
			strTempInfo.Format("目标%d图像坐标 X:%f Y:%f D:%f,",i, m_TargetSearchResults.m_vPos.at(i).m_dPosX, m_TargetSearchResults.m_vPos.at(i).m_dPosY, m_TargetSearchResults.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}

		// 目标点平台坐标
		for (int i=0; i<m_iMarkNum; i++)
		{
			strTempInfo.Format("修正前目标%d平台坐标 X:%f Y:%f D:%f,",i,m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX, m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY, m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}

	}

	// 6. 修正每个相机对应的目标mark平台坐标值
	for (int i=0; i<m_iMarkNum; i++)
	{
		str.Format("目标轴位置%d: X = %f , Y = %f , D = %f ", i, pTargetPlatformAxisPos.at(i)->m_dPosX, pTargetPlatformAxisPos.at(i)->m_dPosY, pTargetPlatformAxisPos.at(i)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("目标图像坐标%d: X = %f , Y = %f , D = %f ",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("轴修正前目标平台坐标%d: X = %f , Y = %f, D = %f ",i,m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX(),m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY(), m_TargetMarkPlatformPos.m_vPos.at(i).GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

		// 目标Mark为基准Mark
		if (eTargetBench == m_AlignermentParam.GetTargetMarkType())
		{	
			if (FALSE == m_AlignermentParam.GetBenchTargetMarkFixEnable())
			{
				CPlatformXYDAxisPos* pBenchPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());//标定基准轴位置

				vcpTarPlatPos[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos;

				pTargetPlatformAxisPos.at(i) = pBenchPlatformAxisPos;
			}
			else//进行基准修正，使用修正后的基准坐标
			{
				CPlatformXYDAxisPos* pBenchFixPlatformAxisPos = (CPlatformXYDAxisPos*)(m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetFixPlatformPos(i));//基准修正时轴位置

				vcpTarPlatPos[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i);

				pTargetPlatformAxisPos.at(i) = pBenchFixPlatformAxisPos;
			}
		}
		else//目标mark为实时mark
		{
			vcpTarPlatPos[i] = m_TargetMarkPlatformPos.m_vPos[i];
		}

		// 对目标Mark的平台坐标值进行修正(平台XY轴移动影响影响结果)
		double dPlatformOffsetX = 0;
		double dPlatformOffsetY = 0;
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;


		// 三力X+XYD上料，基准对象和实时目标对位，对象不拍照对象轴位置为零，目标只拍一次只对一次，因此轴位置变化不用再对目标平台坐标修正
		if (eObjectBench == m_AlignermentParam.GetObjectMarkType() && eTargetOnline == m_AlignermentParam.GetTargetMarkType())
		{
			dPlatformOffsetX = 0.0;
			dPlatformOffsetY = 0.0;
		}
		else
		{
			// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
			if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
			{
				dPlatformOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

			}
			else
			{
				dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

			}

			if ((GetMidPlatformType() ==ePlatformXDPY)  || (GetMidPlatformType() ==ePlatformXDPY1))
			{
				dPlatformOffsetY =0 ;
			}
			else if ( GetMidPlatformType() ==ePlatformXYPD)
			{
				dPlatformOffsetX =0 ;
				dPlatformOffsetY =0 ;
			}
			else if ((GetMidPlatformType() ==ePlatformXY) && (GetCamNum()==1) && (m_iMarkNum != 1) && (!m_AlignermentParam.GetWeldInfo().m_bEnableWeld))
			{
				dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

				dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = -1*dPlatformOffsetY;
			}
			else if ( GetMidPlatformType() == ePlatformXY )
			{
				dPlatformOffsetX =0 ;
				dPlatformOffsetY =0 ;
			}
			else if ( GetMidPlatformType() == ePlatformX )
			{
				dPlatformOffsetX =0 ;
				dPlatformOffsetY =0 ;
			}
			else if ( GetMidPlatformType() == ePlatformY )
			{
				dPlatformOffsetX =0 ;
				dPlatformOffsetY =0 ;
			}

			if ((m_bTargetCalibUseBoard == TRUE) && (FALSE == m_AlignermentParam.GetBendInfo().m_bBendAlignInspect || FALSE == m_bBendAlignProcess))
			{
				if (eDmCodeCalib == m_AlignermentParam.GetCalibTargetMarkPatternMode())
				{
					dPlatformOffsetX =0 ;
					dPlatformOffsetY =0 ;
				}
			}
		}		

		vcpTarPlatPos[i].Offset(-dPlatformOffsetX, -dPlatformOffsetY);

		str.Format("轴修正后目标平台坐标%d: X = %f , Y = %f, D = %f ",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

	}

	if (IsTargetReConstruct())
	{
		if (FALSE == ExecuteTargetPlatformPosRestruct(vcpTarPlatPos))
		{
			m_nAlignErrNum = -9;
			return FALSE;
		}
	}

	// 功能应用1：三力定制应用
// 	if (1)
// 	{
// 		// 将基准目标的平台坐标（实际为靶标坐标）转换成平台坐标
// 		// 应用场景：两位置，基准目标且实时对象，不分离且使用靶标标定
// 		// 如果不是基准目标，而是实时目标，则不进入该流程，一般情况下不配置基准目标
// 		// 暂不考虑基准修正
// 		if (m_iMarkNum == 2 && eTargetBench == m_AlignermentParam.GetTargetMarkType() && eObjectOnline == m_AlignermentParam.GetObjectMarkType() &&
// 			m_bTargetObjectCamSeparate == FALSE && m_bTargetCalibUseBoard == TRUE)
// 		{
// 			// 如果有关联标定，则根据3*3单应矩阵转换即可
// 			// 如果无关联标定，3*3单应矩阵等于单位矩阵，转换后等于原数值
// 
// 			str.Format("单应矩阵转换前，基准目标mark%d靶标坐标 X=%f, Y=%f, D=%f", 0, vcpTarPlatPos[0].GetPosX(), vcpTarPlatPos[0].GetPosY(), vcpTarPlatPos[0].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			str.Format("单应矩阵转换前，基准目标mark%d靶标坐标 X=%f, Y=%f, D=%f", 1, vcpTarPlatPos[1].GetPosX(), vcpTarPlatPos[1].GetPosY(), vcpTarPlatPos[1].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			sc2Vector platformPos0 = sfHomographyProject(vcpTarPlatPos[0].GetPos(), m_vAlignerCalibInfos.at(0)->m_PlatformTranferH);
// 			sc2Vector platformPos1 = sfHomographyProject(vcpTarPlatPos[1].GetPos(), m_vAlignerCalibInfos.at(1)->m_PlatformTranferH);
// 
// 			vcpTarPlatPos[0].SetPosAngle(platformPos0, 0);
// 			vcpTarPlatPos[1].SetPosAngle(platformPos1, 0);
// 
// 			str.Format("单应矩阵转换后，基准目标mark%d平台坐标 X=%f, Y=%f, D=%f", 0, vcpTarPlatPos[0].GetPosX(), vcpTarPlatPos[0].GetPosY(), vcpTarPlatPos[0].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			str.Format("单应矩阵转换后，基准目标mark%d平台坐标 X=%f, Y=%f, D=%f", 1, vcpTarPlatPos[1].GetPosX(), vcpTarPlatPos[1].GetPosY(), vcpTarPlatPos[1].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 
// 
// 		// 将对象和目标的平台坐标对调
// 		// 应用场景：两位置，不分离且使用靶标标定
// 		// 某些拾取应用中，定位时目标变化而对象不变，对位时对象运动而目标不动
// 		// 为了维护客户和客服的使用习惯，在软件配置时将两者取反，定位时目标不变而对象变化，因此这里进行对调
// 		if (m_iMarkNum == 2 && m_bTargetObjectCamSeparate == FALSE && m_bTargetCalibUseBoard == TRUE)
// 		{
// 			str.Format("对调前, 目标mark%d平台坐标 X=%f, Y=%f, D=%f", 0, vcpTarPlatPos[0].GetPosX(), vcpTarPlatPos[0].GetPosY(), vcpTarPlatPos[0].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			str.Format("对调前, 目标mark%d平台坐标 X=%f, Y=%f, D=%f", 1, vcpTarPlatPos[1].GetPosX(), vcpTarPlatPos[1].GetPosY(), vcpTarPlatPos[1].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			str.Format("对调前, 对象mark%d平台坐标 X=%f, Y=%f, D=%f", 0, vcpObjPlatPos[0].GetPosX(), vcpObjPlatPos[0].GetPosY(), vcpObjPlatPos[0].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			str.Format("对调前, 对象mark%d平台坐标 X=%f, Y=%f, D=%f", 1, vcpObjPlatPos[1].GetPosX(), vcpObjPlatPos[1].GetPosY(), vcpObjPlatPos[1].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			for (int i=0; i<2; i++)
// 			{
// 				// 获取当前索引的对象和目标平台坐标
// 				CCoordPos cpTempObjPlatPos = vcpObjPlatPos[i];
// 				CCoordPos cpTempTarPlatPos = vcpTarPlatPos[i];
// 
// 				// 将当前目标赋值给对象，将当前对象赋值给目标
// 				vcpObjPlatPos[i] = cpTempTarPlatPos;
// 				vcpTarPlatPos[i] = cpTempObjPlatPos;
// 
// 			}
// 
// 			str.Format("对调前, 目标mark%d平台坐标 X=%f, Y=%f, D=%f", 0, vcpTarPlatPos[0].GetPosX(), vcpTarPlatPos[0].GetPosY(), vcpTarPlatPos[0].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			str.Format("对调前, 目标mark%d平台坐标 X=%f, Y=%f, D=%f", 1, vcpTarPlatPos[1].GetPosX(), vcpTarPlatPos[1].GetPosY(), vcpTarPlatPos[1].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			str.Format("对调前, 对象mark%d平台坐标 X=%f, Y=%f, D=%f", 0, vcpObjPlatPos[0].GetPosX(), vcpObjPlatPos[0].GetPosY(), vcpObjPlatPos[0].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 			str.Format("对调前, 对象mark%d平台坐标 X=%f, Y=%f, D=%f", 1, vcpObjPlatPos[1].GetPosX(), vcpObjPlatPos[1].GetPosY(), vcpObjPlatPos[1].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 	}

	// 功能应用2：八字对位补偿
	if (m_AlignermentParam.GetEnableEightShapeAlign())
	{

		//对象距离
		double dlpanelDis = 0;
		//目标距离
		double dlcofDis = 0;

		if (GetTargetMarkPlatformDistance(dlcofDis)==FALSE)
		{
			return FALSE;
		}

		str.Format("八字补偿目标距离 cofDis: %f ,",dlcofDis);
		AlignToolLogRecord(str,nPlatformIndex);

		strTempInfo.Format("八字补偿目标距离 L:%f,", dlcofDis);
		strInfo += strTempInfo;

		//对象距离
		if (GetObjectMarkPlatformDistance(dlpanelDis)==FALSE)
		{
			return FALSE;					
		}
		str.Format("八字补偿对象距离 panelDis: %f ,",dlpanelDis);
		AlignToolLogRecord(str,nPlatformIndex);

		strTempInfo.Format("八字补偿对象距离 L:%f,", dlpanelDis);
		strInfo += strTempInfo;

		double doffsetX = 0;
		double doffsetY = 0;

		if (m_AlignermentParam.GetEightShapeAngle() != 0)
		{
			if (m_AlignermentParam.GetEightShapeAlignMode()==0)
			{
				// 顺八字
				// tan()函数参数是弧度而不是度，因此需要换算
				//				doffsetY = (dlfDis - dlpDis)/(2*tan(m_AlignermentParam.m_dEightShapeAngle*skPI/180.0));
				doffsetY = (dlcofDis - dlpanelDis)/(2*tan(m_AlignermentParam.m_dEightShapeAngle*skPI/180.0));
			}
			else
			{
				// 逆八字
				//				doffsetY = (dlpDis - dlfDis)/(2*tan(m_AlignermentParam.m_dEightShapeAngle*skPI/180.0));
				doffsetY = (dlpanelDis - dlcofDis)/(2*tan(m_AlignermentParam.m_dEightShapeAngle*skPI/180.0));
			}

		}

		str.Format("八字补偿Y方向偏差:doffsetY=%f ,",doffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		strTempInfo.Format("八字补偿Y方向偏差 L:%f,", doffsetY);
		strInfo += strTempInfo;

		if (doffsetY!=0)
		{
			CMarkPlatformPos objectPos;
			objectPos.m_vPos.resize(m_iMarkNum);
			objectPos.m_vbOK.resize(m_iMarkNum);
			CMarkPlatformPos objectAddEightMoveOffsetPos;
			objectAddEightMoveOffsetPos.m_vPos.resize(m_iMarkNum);
			objectAddEightMoveOffsetPos.m_vbOK.resize(m_iMarkNum);

			for (int m=0;m<m_iMarkNum;m++)
			{
				objectPos.m_vPos[m] = vcpObjPlatPos[m];
			}

			// 将Y补偿量取反
			// 因为按照补偿计算原理，当doffsetY为正时，是想让目标不动对象向下运动，因此需要补偿负数，构造一个虚拟的负补偿对象
			// 负补偿对象与目标居中对齐时，实际对象自然就跑到目标下方
			doffsetY = - doffsetY;
			MarkCoordOffsetXYObjectPltfmPt(objectPos.m_vPos, objectAddEightMoveOffsetPos.m_vPos,doffsetX,doffsetY);

			for (int m=0;m<m_iMarkNum;m++)
			{
				vcpObjPlatPos[m] = objectAddEightMoveOffsetPos.m_vPos[m];

				str.Format("八字补偿后对象平台坐标%d ObjectX: %f,ObjectY: %f,ObjectD: %f ,",m,vcpObjPlatPos[m].GetPosX(),vcpObjPlatPos[m].GetPosY(),vcpObjPlatPos[m].GetAngle());
				AlignToolLogRecord(str,nPlatformIndex);

				strTempInfo.Format("八字补偿后对象%d平台坐标 X:%f Y:%f D:%f,",m,vcpObjPlatPos[m].GetPosX(),vcpObjPlatPos[m].GetPosY(),vcpObjPlatPos[m].GetAngle());
				strInfo += strTempInfo;

			}					

		}		

	}//八字补偿

	// 功能应用3：目标补偿
	if (m_AlignermentParam.m_bCheckAlnTargetOffsetEnable && !m_bInnerAlignBench)
	{
		if (m_AlignermentParam.m_dAlnTargetOffsetX!=0 || m_AlignermentParam.m_dAlnTargetOffsetY!=0 )
		{
			for(int k=0;k<m_iMarkNum;k++)
			{
				vcpTarPlatPos[k].Offset(-m_AlignermentParam.m_dAlnTargetOffsetX, -m_AlignermentParam.m_dAlnTargetOffsetY);
			}
		}
	}


	// 目标修正后格式化数据记录
	{

		// 实际参与对位计算的目标点平台坐标
		for (int i=0; i<m_iMarkNum; i++)
		{
			strTempInfo.Format("修正后目标%d平台坐标 X:%f Y:%f D:%f,",i,vcpTarPlatPos[i].GetPosX(), vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
			strInfo += strTempInfo;
		}

		sc2Vector pt[4];
		for (int i=0; i<m_iMarkNum; i++)
		{
			pt[i] = sc2Vector(vcpTarPlatPos[i].GetPosX(), vcpTarPlatPos[i].GetPosY());
		}

		switch(m_iMarkNum)
		{
		case 2:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 3:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;	

				dLen[1] = (pt[1] - pt[2]).Length();
				(pt[1] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("目标12距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("目标02距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 4:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;

				dLen[1] = (pt[3] - pt[2]).Length();
				(pt[3] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("目标23距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("目标02距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;

				dLen[3] = (pt[3] - pt[1]).Length();
				(pt[3] - pt[1]).Angle(raAngle[3]);
				strTempInfo.Format("目标13距离角度 L:%f D:%f,", dLen[3], scDegree(raAngle[3]).ToDouble());
				strInfo += strTempInfo;

			}
			break;

		default:
			{

			}
			break;
		}
	}

	// $4、目标Mark与对象Mark在平台坐标下进行对位，计算旋转角度及XY轴偏移量
	m_PlatformOffset.m_dPosX  = 0;		
	m_PlatformOffset.m_dPosY  = 0;
	m_PlatformOffset.m_dAngle = 0;

	m_ProductOffset.m_dPosX  = 0;		
	m_ProductOffset.m_dPosY  = 0;
	m_ProductOffset.m_dAngle = 0;

	m_ProductOffsetXYPD.m_dPosX  = 0;		
	m_ProductOffsetXYPD.m_dPosY  = 0;
	m_ProductOffsetXYPD.m_dAngle = 0;

	int nPosNum = m_iMarkNum;							// 实际对位的位置数量
	std::vector<CCoordPos> vcpObjectPlatformPos;		// 对象位置
	std::vector<CCoordPos> vcpTargetPlatformPos;		// 目标位置
	std::vector<CCoordPos> vcpAlginedObjectPlatformPos; // 对位后对象位置
	std::vector<CCoordPos> vcpAlginedTargetPlatformPos; // 对位后目标位置
	for (int nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
	{
		// 对象位置
		CCoordPos cpObjectPlatformPos;

		cpObjectPlatformPos = vcpObjPlatPos[nPosIndex];
		vcpObjectPlatformPos.push_back(cpObjectPlatformPos);

		// 目标位置
		CCoordPos cpTargetPlatformPos;

		cpTargetPlatformPos = vcpTarPlatPos[nPosIndex];
		vcpTargetPlatformPos.push_back(cpTargetPlatformPos);
	}
	vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
	vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;

	if (GetMidPlatformType()==ePlatformXYPD)
	{
		std::vector<CCoordPos> vcpPreTargetPlatformPos;		// 上一次目标位置旋转后新的目标位置

		if (nAlnIndex == 0)
		{
			vcpPreTargetPlatformPos = vcpAlginedTargetPlatformPos;
		}
		else
		{
			for (int j=0;j<nPosNum;j++)
			{
				CCoordPos pos;
				pos.m_dPosX = m_dTargetX[j];
				pos.m_dPosY = m_dTargetY[j];

				vcpPreTargetPlatformPos.push_back(pos);
			}
		}

		CCoordPos tempplatformOffset;

		// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
		if (!GetAlginOffset(vcpObjectPlatformPos, vcpPreTargetPlatformPos, m_ProductOffsetXYPD, tempplatformOffset, 
			vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
		{
			m_nAlignErrNum = -10;

			str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(失败)");
			AlignToolLogRecord(str,nPlatformIndex);

			return FALSE;
		}

		str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(成功)");
		AlignToolLogRecord(str,nPlatformIndex);

	}


	// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
	if (!GetAlginOffset(vcpObjectPlatformPos, vcpTargetPlatformPos, m_ProductOffset, m_PlatformOffset, 
		vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
	{
		m_nAlignErrNum = -10;

		str.Format("------------------------------------------------------------对位计算结束(失败)");
		AlignToolLogRecord(str,nPlatformIndex);

		return FALSE;
	}

	//计算平台由缺少轴带来旋转中心的偏差
	if (m_AlignermentParam.GetAlignAccordingToPickPlatformEnable())
	{
		if(!GetAlignOffsetRevise(vcpObjectPlatformPos, vcpTargetPlatformPos, m_PlatformOffset, m_PlatformOffsetRevise))
		{
			str.Format("------------------------------------------------------------对位计算修正拾取结束(失败)");
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("------------------------------------------------------------对位计算结束(失败)");
			AlignToolLogRecord(str,nPlatformIndex);

			return FALSE;
		}
		str.Format("对位计算修正拾取: X=%.6f Y=%.6f D=%.6f", m_PlatformOffsetRevise.m_dPosY, m_PlatformOffsetRevise.m_dPosY, m_PlatformOffsetRevise.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
	}


	// 对位偏差量日志记录
	{
		if (GetMidPlatformType()==ePlatformXYPD)
		{
			strTempInfo.Format("产品偏差 X:%f Y:%f D:%f,", GetAlignProductOffsetXYPD().GetPosX(), GetAlignProductOffsetXYPD().GetPosY(), GetAlignProductOffsetXYPD().GetAngle());
			strInfo += strTempInfo;
		}
		else
		{
			strTempInfo.Format("产品偏差 X:%f Y:%f D:%f,", GetAlignProductOffset().GetPosX(), GetAlignProductOffset().GetPosY(), GetAlignProductOffset().GetAngle());
			strInfo += strTempInfo;
		}


		strTempInfo.Format("平台偏差 X:%f Y:%f D:%f,", GetAlignPlatformPosOffset().GetPosX(), GetAlignPlatformPosOffset().GetPosY(), GetAlignPlatformPosOffset().GetAngle());
		strInfo += strTempInfo;
	}

	AlignToolLogRecordProduct(strInfo,nPlatformIndex);


	str.Format("------------------------------------------------------------对位计算结束(成功)\n\n");
	AlignToolLogRecord(str,nPlatformIndex);

	return TRUE;

}

// 目标、对象分离
BOOL vcBaseAlignTool::ExecuteAlign_Case2(int nAlnIndex/* = 0*/, BOOL bInspect /*= TRUE*/)
{
	m_nAlnIndex = nAlnIndex;
//	m_nAlignErrNum = 0;

	if (!m_bTargetObjectCamSeparate)
	{
		return FALSE;
	}

	std::vector<int> vnObjectPosIndex;
	std::vector<int> vnTargetPosIndex;

	for (int i = 0; i < m_iMarkNum/2; i++)
	{
		vnObjectPosIndex.push_back(i);

		if (NULL == m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex))
		{
			m_nAlignErrNum = -1;
			return false;
		}

		if (!m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex)->IsValid())
		{
			m_nAlignErrNum = -2;
			return false;
		}
	}

	if (!m_bReadTargetPlatformPos)
	{
		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			vnTargetPosIndex.push_back(i);

			if (NULL == m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex))
			{
				m_nAlignErrNum = -1;
				return false;
			}

			if (!m_vAlignerCalibInfos.at(i + m_iMarkNum*m_nAlignnExProductIndex)->IsValid())
			{
				m_nAlignErrNum = -2;
				return false;
			}
		}
	}


	if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(vnObjectPosIndex))
	{
		m_nAlignErrNum = -3;
		return FALSE;
	}

	if (!m_bReadTargetPlatformPos)
	{
		if (FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(vnTargetPosIndex))
		{
			m_nAlignErrNum = -4;
			return FALSE;
		}
	}



	CString strTempInfo;
	CString strInfo;

	strTempInfo.Format(",对位序号%d,", nAlnIndex);
	strInfo += strTempInfo;

	strTempInfo.Format("%d位置分离对位,", m_iMarkNum);
	strInfo += strTempInfo;

	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("对位计算开始:序号[%d]------------------------------------------------------------",nAlnIndex);
	AlignToolLogRecord(str,nPlatformIndex);


	std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;
	for (int k=0;k<m_pObjectPlatformAxisPos.size();k++)
	{
		pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置
	}

	std::vector<CPlatformXYDAxisPos*> pTargetPlatformAxisPos;
	for (int k=0;k<m_pTargetPlatformAxisPos.size();k++)
	{
		pTargetPlatformAxisPos.push_back((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k));//搜索目标mark轴位置
	}
	if(pTargetPlatformAxisPos.size()<m_iMarkNum)
	{
		pTargetPlatformAxisPos.resize(m_iMarkNum);
	}


	std::vector<CCoordPos> vcpObjPlatPos;		// 对象位置
	std::vector<CCoordPos> vcpTarPlatPos;		// 目标位置

	vcpObjPlatPos.resize(8);
	vcpTarPlatPos.resize(8);

	//////////////////////////////////////////////////////////////////////////
	// 1. 实时对象Mark的图像坐标值转化为平台坐标值
	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPosForAlign();
	if (FALSE == m_ObjectMarkPlatformPos.IsAllMarkPlatformPosOK())
	{
		m_nAlignErrNum = -5;
		return FALSE;
	}

	// 2. 综合对位方式，对象点重构
	if (IsObjectReConstruct())
	{
		if (FALSE == ExecuteObjectPlatformPosRestruct(m_ObjectMarkPlatformPos.m_vPos))
		{
			m_nAlignErrNum = -6;
			return FALSE;
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// 此处对象点变换可以放到计算对象平台坐标里面
	if(eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type() && m_iMarkNum == 6)
	{
		scLine BaseLine;
		CCoordPos Pos0 = m_ObjectMarkPlatformPos.m_vPos.at(0);
		CCoordPos Pos1 = m_ObjectMarkPlatformPos.m_vPos.at(1);
		CCoordPos Pos2 = m_ObjectMarkPlatformPos.m_vPos.at(2);

		sc2Vector vPos1(Pos1.m_dPosX,Pos1.m_dPosY);
		sc2Vector NewvPos1(Pos1.m_dPosX,Pos1.m_dPosY);
		BaseLine.SetFromStartEnd(sc2Vector(Pos0.m_dPosX,Pos0.m_dPosY),sc2Vector(Pos2.m_dPosX,Pos2.m_dPosY));
		NewvPos1 = BaseLine.Project(vPos1);

		m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosX = NewvPos1.GetX();
		m_ObjectMarkPlatformPos.m_vPos.at(1).m_dPosY = NewvPos1.GetY();
	}


	// 对象补偿前格式化日志记录
	{
		for (int i = 0; i < m_pObjectPlatformAxisPos.size()/2; i++)
		{
			strTempInfo.Format("对象%d轴位置 X:%f Y:%f D:%f,", i, pObjectPlatformAxisPos.at(i)->m_dPosX,pObjectPlatformAxisPos.at(i)->m_dPosY,pObjectPlatformAxisPos.at(i)->m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i=0; i<m_iMarkNum/2; i++)
		{
			strTempInfo.Format("对象%d图像坐标 X:%f Y:%f D:%f,",i, m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i=0; i<m_iMarkNum/2; i++)
		{
			strTempInfo.Format("补偿前对象%d平台坐标 X:%f Y:%f D:%f,",i, m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}

	}


	// 2. 对象平台坐标进行补偿
	for (int i=0; i<m_iMarkNum; i++)
	{
		str.Format("对象轴位置%d: X = %f, Y = %f , D = %f ", i, pObjectPlatformAxisPos.at(i)->m_dPosX,pObjectPlatformAxisPos.at(i)->m_dPosY,pObjectPlatformAxisPos.at(i)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("对象图像坐标%d: X = %f, Y = %f , D = %f ",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("对象平台坐标%d: X = %f , Y = %f , D = %f ",i, m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX(),m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY(),m_ObjectMarkPlatformPos.m_vPos.at(i).GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

		//记录相机对象mark的坐标
		vcpObjPlatPos[i] = m_ObjectMarkPlatformPos.m_vPos[i];

		// 实时对象为虚拟Mark，则将实时对象Mark的平台坐标值转换为虚拟Mark的平台坐标值
		if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
		{
			if (FALSE == ConvertObjectPltfmPtToVirtualPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos))
				return FALSE;

			vcpObjPlatPos[i] = m_VirtualMarkPlatformPos.m_vPos[i];

			str.Format("补偿前虚拟对象平台坐标%d: X = %f , Y = %f , D = %f ", i, vcpObjPlatPos[i].GetPosX(), vcpObjPlatPos[i].GetPosY(), vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);

		}

		if (!m_bInnerAlignBench)
		{
			if (IsExecuteCoordinateCompensation())
			{
				std::vector<CCoordPos> vFixedObjectPlatformPos;
				vFixedObjectPlatformPos.resize(m_iMarkNum);

				BOOL bOffsetSuccess = ExecuteCoordinateCompensation(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos, vFixedObjectPlatformPos);

				vcpObjPlatPos[i] = vFixedObjectPlatformPos[i];

				if (!bOffsetSuccess)
				{
					m_nAlignErrNum = -7;
					return FALSE;
				}
			}


			str.Format("补偿后对象平台坐标%d: X = %f , Y = %f , D = %f", i, vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);

		}
		else
		{
			// $1.3 对象Mark的全局平台坐标值补偿
			//当不需要基准修正时，考虑要不要对对象mark进行补偿

			CMarkPlatformPos m_ObjectAddRotationOffsetPos;
			m_ObjectAddRotationOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddRotationOffsetPos.m_vbOK.resize(m_iMarkNum);
			CMarkPlatformPos m_ObjectAddMoveOffsetPos;
			m_ObjectAddMoveOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddMoveOffsetPos.m_vbOK.resize(m_iMarkNum);

			if (1/*eMarkCoord == m_AlignermentParam.GetAlignerOffsetCoordType()*/)// Mark坐标系下补偿
			{
				// Mark坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBenchOffset().GetAngle()||m_AlignermentParam.GetAlignerBenchOffset().GetPosX()||m_AlignermentParam.GetAlignerBenchOffset().GetPosY())
				{
					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
						MarkCoordOffsetRotationObjectPlatformPos(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
					else
						MarkCoordOffsetRotationObjectPlatformPos(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);

					// Mark坐标系下XY轴平移量进行补偿
					MarkCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
				}
			}

			str.Format("补偿后对象平台坐标%d: X = %f, Y = %f, D = %f ",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}

	}

	// 对象补偿后格式化日志记录
	{
		// 当前使用的补偿类型及补偿数值
		strTempInfo.Format("补偿类型:%d 补偿序号:%d X:%f Y:%f D:%f,",m_AlignermentParam.GetAlignerOffsetCoordType(),m_AlignermentParam.GetCurAlignerOffsetIndex(),m_AlignermentParam.GetAlignerOffset().GetPosX() ,m_AlignermentParam.GetAlignerOffset().GetPosY(), m_AlignermentParam.GetAlignerOffset().GetAngle());
		strInfo += strTempInfo;

		for (int i=0; i<m_iMarkNum/2; i++)
		{
			strTempInfo.Format("补偿后对象%d平台坐标 X:%f Y:%f D:%f,",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			strInfo += strTempInfo;
		}

		sc2Vector pt[4];
		for (int i=0; i<m_iMarkNum/2; i++)
		{
			pt[i] = sc2Vector(vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY());
		}

		switch(m_iMarkNum)
		{
		case 4:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;		
			}
			break;

		case 6:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;	

				dLen[1] = (pt[1] - pt[2]).Length();
				(pt[1] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("对象12距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("对象02距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 8:
			{
				//记录对象距离角度
				double dLen[4];
				scRadian raAngle[4];
				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;

				dLen[1] = (pt[3] - pt[2]).Length();
				(pt[3] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("对象23距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("对象02距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;

				dLen[3] = (pt[3] - pt[1]).Length();
				(pt[3] - pt[1]).Angle(raAngle[3]);
				strTempInfo.Format("对象13距离角度 L:%f D:%f,", dLen[3], scDegree(raAngle[3]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		default:
			{

			}
			break;

		}
	}

	// 3. 实时目标Mark的图像坐标值转化为平台坐标值
	if (eTargetBench != m_AlignermentParam.GetTargetMarkType())
	{
		if (!m_bReadTargetPlatformPos)
		{
			m_TargetMarkPlatformPos = GetTargetMarkPlatformPosForAlign();
		}

		if (FALSE == m_TargetMarkPlatformPos.IsAllMarkPlatformPosOK())
		{
			m_nAlignErrNum = -8;
			return FALSE;
		}
	}

	// 3. 综合对位模式，目标点重构
// 	if (!m_bReadTargetPlatformPos)
// 	{
		// 综合对位模式，目标点重构
// 		if (IsTargetReConstruct())
// 		{
// 			if (FALSE == ExecuteTargetPlatformPosRestruct(m_TargetMarkPlatformPos.m_vPos))
// 			{
// 				return FALSE;
// 			}
// 		}
// 	}

	// 此处目标点变换可以放到目标修正后完成
// 	if(eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type() && m_iMarkNum == 6)
// 	{
// 		scLine BaseLine;
// 		CCoordPos Pos0 = m_TargetMarkPlatformPos.m_vPos.at(3);
// 		CCoordPos Pos1 = m_TargetMarkPlatformPos.m_vPos.at(4);
// 		CCoordPos Pos2 = m_TargetMarkPlatformPos.m_vPos.at(5);
// 		sc2Vector vPos1(Pos1.m_dPosX,Pos1.m_dPosY);
// 		sc2Vector NewvPos1(Pos1.m_dPosX,Pos1.m_dPosY);
// 		BaseLine.SetFromStartEnd(sc2Vector(Pos0.m_dPosX,Pos0.m_dPosY),sc2Vector(Pos2.m_dPosX,Pos2.m_dPosY));
// 		NewvPos1 = BaseLine.Project(vPos1);
// 		m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosX = NewvPos1.GetX();
// 		m_TargetMarkPlatformPos.m_vPos.at(4).m_dPosY = NewvPos1.GetY();
// 	}


	// 目标修正前格式化日志记录
	{
		for (int i = m_iMarkNum/2; i < m_pTargetPlatformAxisPos.size(); i++)
		{
			strTempInfo.Format("目标%d轴位置 X:%f Y:%f D:%f,", i, pTargetPlatformAxisPos.at(i)->m_dPosX,pTargetPlatformAxisPos.at(i)->m_dPosY,pTargetPlatformAxisPos.at(i)->m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			strTempInfo.Format("目标%d图像坐标 X:%f Y:%f D:%f,",i, m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			strTempInfo.Format("修正前目标%d平台坐标 X:%f Y:%f D:%f,", i, m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX,m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY,m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}
	}


	// 4. 对目标平台坐标进行修正	
	for (int i=0; i<m_iMarkNum; i++)
	{
		str.Format("目标轴位置%d: X = %f , Y = %f , D = %f ", i, pTargetPlatformAxisPos.at(i)->m_dPosX, pTargetPlatformAxisPos.at(i)->m_dPosY, pTargetPlatformAxisPos.at(i)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("目标图像坐标%d: X = %f , Y = %f , D = %f ",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("轴修正前目标平台坐标%d: X = %f , Y = %f, D = %f ",i,m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX(),m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY(), m_TargetMarkPlatformPos.m_vPos.at(i).GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

		// 目标Mark为基准Mark
		if (eTargetBench == m_AlignermentParam.GetTargetMarkType())
		{	
			if (FALSE == m_AlignermentParam.GetBenchTargetMarkFixEnable())
			{
				CPlatformXYDAxisPos* pBenchPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());//标定基准轴位置

				vcpTarPlatPos[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos;

				pTargetPlatformAxisPos.at(i) = pBenchPlatformAxisPos;
			}
			else//进行基准修正，使用修正后的基准坐标
			{
				CPlatformXYDAxisPos* pBenchFixPlatformAxisPos = (CPlatformXYDAxisPos*)(m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetFixPlatformPos(i));//基准修正时轴位置

				vcpTarPlatPos[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i);

				pTargetPlatformAxisPos.at(i) = pBenchFixPlatformAxisPos;
			}
		}
		else//目标mark为实时mark
		{
			vcpTarPlatPos[i] = m_TargetMarkPlatformPos.m_vPos[i];
		}


		// 对目标Mark的平台坐标值进行修正(平台XY轴移动影响影响结果)
		double dPlatformOffsetX = 0;
		double dPlatformOffsetY = 0;
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

		//修正回读取目标平台坐标时，已经重构点的轴位置偏移
		if (m_bReadTargetPlatformPos)
		{
			// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
			if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
			{
				dPlatformOffsetX = 0;
				dPlatformOffsetY = 0;
			}
			else
			{
				dPlatformOffsetX = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
			}

			if (GetMidPlatformType()==ePlatformXYPD)
			{
				dPlatformOffsetX = 0;
				dPlatformOffsetY = 0;
			}		

			vcpTarPlatPos[i].Offset(dPlatformOffsetX, dPlatformOffsetY);
		}

		// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
		if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
		{
			dPlatformOffsetX = pObjectPlatformAxisPos.at( i%(m_iMarkNum/2) )->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
			dPlatformOffsetY = pObjectPlatformAxisPos.at( i%(m_iMarkNum/2) )->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

		}
		else
		{
			dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
			dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

		}

		if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTarObjCamSepNoAxisCalib)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		if (GetMidPlatformType()==ePlatformXYPD)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;

		}
		else if (GetMidPlatformType()==ePlatformXY)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		if (m_bTargetObjectCamSeparate && m_bTargetCalibUseBoard && m_AlignermentParam.m_bEnableAlnTargetFixOffset)
		{
			// 目标标定轴相对于对象标定轴位置偏移量
			CPlatformXYDAxisPos*  pTargetPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformAxisPos());
			CPlatformXYDAxisPos*  pObjectPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());

			double dVirtualPlatformAixsOffsetX = pObjectPlatformXYDBenchAxisPos->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
			double dVirtualPlatformAixsOffsetY = pObjectPlatformXYDBenchAxisPos->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;

			if (eDirectNegative == iPlatformXCoordType) dVirtualPlatformAixsOffsetX = -1*dVirtualPlatformAixsOffsetX;	
			if (eDirectNegative == iPlatformYCoordType) dVirtualPlatformAixsOffsetY = -1*dVirtualPlatformAixsOffsetY;

			dPlatformOffsetX = dPlatformOffsetX - dVirtualPlatformAixsOffsetX;
			dPlatformOffsetY = dPlatformOffsetY - dVirtualPlatformAixsOffsetY;
		}

		vcpTarPlatPos[i].Offset(-dPlatformOffsetX, -dPlatformOffsetY);

		str.Format("轴修正后目标平台坐标%d: X = %f , Y = %f, D = %f ",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

	}

 	if (!m_bReadTargetPlatformPos)
 	{
 		// 综合对位模式，目标点重构
 		BOOL bTarPosRestruct = ExecuteTargetPlatformPosRestruct(vcpTarPlatPos);

 		if (!bTarPosRestruct)
 		{
			m_nAlignErrNum = -9;
 			return FALSE;
 		}
 	}
	// 
	// 	// 此处目标点变换可以放到目标修正后完成
 	if(eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type() && m_iMarkNum == 6)
 	{
 		scLine BaseLine;
 		CCoordPos Pos0 = vcpTarPlatPos.at(3);
 		CCoordPos Pos1 = vcpTarPlatPos.at(4);
 		CCoordPos Pos2 = vcpTarPlatPos.at(5);
	// 
 		sc2Vector vPos1(Pos1.m_dPosX,Pos1.m_dPosY);
 		sc2Vector NewvPos1(Pos1.m_dPosX,Pos1.m_dPosY);
 		BaseLine.SetFromStartEnd(sc2Vector(Pos0.m_dPosX,Pos0.m_dPosY),sc2Vector(Pos2.m_dPosX,Pos2.m_dPosY));
 		NewvPos1 = BaseLine.Project(vPos1);
	// 
 		vcpTarPlatPos.at(4).m_dPosX = NewvPos1.GetX();
 		vcpTarPlatPos.at(4).m_dPosY = NewvPos1.GetY();
 	}

	// 功能应用1：八字对位补偿
	if (m_AlignermentParam.GetEnableEightShapeAlign())
	{

		//对象距离
		double dlpanelDis = 0;
		//目标距离
		double dlcofDis = 0;

		if (GetTargetMarkPlatformDistance(dlcofDis)==FALSE)
		{
			return FALSE;
		}

		str.Format("八字补偿目标距离 cofDis: %f ,",dlcofDis);
		AlignToolLogRecord(str,nPlatformIndex);

		strTempInfo.Format("八字补偿目标距离 L:%f,", dlcofDis);
		strInfo += strTempInfo;

		//对象距离
		if (GetObjectMarkPlatformDistance(dlpanelDis)==FALSE)
		{
			return FALSE;					
		}
		str.Format("八字补偿对象距离 panelDis: %f ,",dlpanelDis);
		AlignToolLogRecord(str,nPlatformIndex);

		strTempInfo.Format("八字补偿对象距离 L:%f,", dlpanelDis);
		strInfo += strTempInfo;

		double doffsetX = 0;
		double doffsetY = 0;

		if (m_AlignermentParam.GetEightShapeAngle() != 0)
		{
			if (m_AlignermentParam.GetEightShapeAlignMode()==0)
			{
				// 顺八字
				// tan()函数参数是弧度而不是度，因此需要换算
				//				doffsetY = (dlfDis - dlpDis)/(2*tan(m_AlignermentParam.m_dEightShapeAngle*skPI/180.0));
				doffsetY = (dlcofDis - dlpanelDis)/(2*tan(m_AlignermentParam.m_dEightShapeAngle*skPI/180.0));
			}
			else
			{
				// 逆八字
				//				doffsetY = (dlpDis - dlfDis)/(2*tan(m_AlignermentParam.m_dEightShapeAngle*skPI/180.0));
				doffsetY = (dlpanelDis - dlcofDis)/(2*tan(m_AlignermentParam.m_dEightShapeAngle*skPI/180.0));
			}

		}

		str.Format("八字补偿Y方向偏差:doffsetY=%f ,",doffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		strTempInfo.Format("八字补偿Y方向偏差 L:%f,", doffsetY);
		strInfo += strTempInfo;

		if (doffsetY!=0)
		{
			CMarkPlatformPos objectPos;
			objectPos.m_vPos.resize(m_iMarkNum);
			objectPos.m_vbOK.resize(m_iMarkNum);
			CMarkPlatformPos objectAddEightMoveOffsetPos;
			objectAddEightMoveOffsetPos.m_vPos.resize(m_iMarkNum);
			objectAddEightMoveOffsetPos.m_vbOK.resize(m_iMarkNum);

			for (int m=0;m<m_iMarkNum;m++)
			{
				objectPos.m_vPos[m] = vcpObjPlatPos[m];
			}

			// 将Y补偿量取反
			// 因为按照补偿计算原理，当doffsetY为正时，是想让目标不动对象向下运动，因此需要补偿负数，构造一个虚拟的负补偿对象
			// 负补偿对象与目标居中对齐时，实际对象自然就跑到目标下方
			doffsetY = - doffsetY;
			MarkCoordOffsetXYObjectPltfmPt(objectPos.m_vPos, objectAddEightMoveOffsetPos.m_vPos,doffsetX,doffsetY);

			for (int m=0;m<m_iMarkNum;m++)
			{
				vcpObjPlatPos[m] = objectAddEightMoveOffsetPos.m_vPos[m];

				str.Format("八字补偿后对象平台坐标%d ObjectX: %f,ObjectY: %f,ObjectD: %f ,",m,vcpObjPlatPos[m].GetPosX(),vcpObjPlatPos[m].GetPosY(),vcpObjPlatPos[m].GetAngle());
				AlignToolLogRecord(str,nPlatformIndex);

				strTempInfo.Format("八字补偿后对象%d平台坐标 X:%f Y:%f D:%f,",m,vcpObjPlatPos[m].GetPosX(),vcpObjPlatPos[m].GetPosY(),vcpObjPlatPos[m].GetAngle());
				strInfo += strTempInfo;

			}					

		}		

	}//八字补偿

	// 功能应用2：目标补偿
	if (m_AlignermentParam.m_bCheckAlnTargetOffsetEnable && !m_bInnerAlignBench)
	{
		if (m_AlignermentParam.m_dAlnTargetOffsetX!=0 || m_AlignermentParam.m_dAlnTargetOffsetY!=0 )
		{
			for(int k=0;k<m_iMarkNum;k++)
			{
				vcpTarPlatPos[k].Offset(-m_AlignermentParam.m_dAlnTargetOffsetX, -m_AlignermentParam.m_dAlnTargetOffsetY);
			}
		}
	}	

	// 功能应用3：不同控制器或不同工位目标固定补偿
	if (m_bTargetCalibUseBoard && !m_bInnerAlignBench)
	{
		if (m_AlignermentParam.m_bEnableAlnTargetFixOffset )
		{
			if (m_AlignermentParam.GetCurTargetFixOffset().GetPosX()!=0 || m_AlignermentParam.GetCurTargetFixOffset().GetPosY()!=0 || m_AlignermentParam.GetCurTargetFixOffset().GetAngle()!=0)
			{
				// 获取产品位置（旋转中心）和角度
				sc2Vector vTargetPos;
				sc2Vector vFixedTargetPos;
				for (int i=0;i<m_iMarkNum && i<vcpTarPlatPos.size();i++)
				{
					vTargetPos.SetX(vcpTarPlatPos.at(i).m_dPosX);
					vTargetPos.SetY(vcpTarPlatPos.at(i).m_dPosY);
					vFixedTargetPos = vfGetTransformRotateShiftPoint(vTargetPos, scDegree(m_AlignermentParam.GetCurTargetFixOffset().GetAngle()), m_AlignermentParam.GetCurTargetFixOffset().GetPosX(), m_AlignermentParam.GetCurTargetFixOffset().GetPosY());
					vcpTarPlatPos.at(i).SetPos(vFixedTargetPos);
					for (int j=0;j<vcpTarPlatPos.at(i).m_vdAuxiliaryPosX.size();j++)
					{
						vTargetPos.SetX(vcpTarPlatPos.at(i).GetAuxiliaryPosX(j));
						vTargetPos.SetY(vcpTarPlatPos.at(i).GetAuxiliaryPosY(j));
						vFixedTargetPos = vfGetTransformRotateShiftPoint(vTargetPos, scDegree(m_AlignermentParam.GetCurTargetFixOffset().GetAngle()), m_AlignermentParam.GetCurTargetFixOffset().GetPosX(), m_AlignermentParam.GetCurTargetFixOffset().GetPosY());
						vcpTarPlatPos.at(i).SetAuxPos(j,vFixedTargetPos);
					}
				}
			}
		}	
		else
		{
			CCoordPos TargetFixOffset;
			GetDefaultTargetFixOffset(TargetFixOffset);
			sc2Vector vTargetPos;
			sc2Vector vFixedTargetPos;
			for (int i=0;i<m_iMarkNum && i<vcpTarPlatPos.size();i++)
			{
				vTargetPos.SetX(vcpTarPlatPos.at(i).m_dPosX);
				vTargetPos.SetY(vcpTarPlatPos.at(i).m_dPosY);
				vcpTarPlatPos.at(i).Offset(TargetFixOffset.GetPosX(), TargetFixOffset.GetPosY());
			}
		}

		for (int i=0; i<m_iMarkNum; i++)
		{
			//记录相机目标mark的坐标
			str.Format("固定补偿后目标mark%d平台坐标 X:,%f,Y:,%f,D:,%f,",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}


	// 目标修正后格式化日志记录
	{
		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			strTempInfo.Format("修正后目标%d平台坐标 X:%f Y:%f D:%f,", i, vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
			strInfo += strTempInfo;
		}

		sc2Vector pt[4];
		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			pt[i-m_iMarkNum/2] = vcpTarPlatPos[i].GetPos();
		}


		switch(m_iMarkNum)
		{
		case 4:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标23距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 6:
			{
				double dLen[4];
				scRadian raAngle[4];

				memset(dLen, 0, sizeof(double)*4);
				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标34距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;

				dLen[1] = (pt[1] - pt[2]).Length();
				(pt[1] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("目标45距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[3] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标35距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 8:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标45距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;

				dLen[1] = (pt[3] - pt[2]).Length();
				(pt[3] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("目标67距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("目标46距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;

				dLen[3] = (pt[3] - pt[1]).Length();
				(pt[3] - pt[1]).Angle(raAngle[3]);
				strTempInfo.Format("目标57距离角度 L:%f D:%f,", dLen[3], scDegree(raAngle[3]).ToDouble());
				strInfo += strTempInfo;

			}
			break;

		default:
			{

			}
			break;

		}
	}


	m_PlatformOffset.m_dPosX  = 0;		
	m_PlatformOffset.m_dPosY  = 0;
	m_PlatformOffset.m_dAngle = 0;

	m_ProductOffset.m_dPosX  = 0;		
	m_ProductOffset.m_dPosY  = 0;
	m_ProductOffset.m_dAngle = 0;

	m_ProductOffsetXYPD.m_dPosX  = 0;		
	m_ProductOffsetXYPD.m_dPosY  = 0;
	m_ProductOffsetXYPD.m_dAngle = 0;

	int nPosNum = m_iMarkNum/2;							// 实际对位的位置数量
	std::vector<CCoordPos> vcpObjectPlatformPos;		// 对象位置
	std::vector<CCoordPos> vcpTargetPlatformPos;		// 目标位置
	std::vector<CCoordPos> vcpAlginedObjectPlatformPos; // 对位后对象位置
	std::vector<CCoordPos> vcpAlginedTargetPlatformPos; // 对位后目标位置
	for (int nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
	{
		// 对象位置
		CCoordPos cpObjectPlatformPos;
		cpObjectPlatformPos = vcpObjPlatPos[nPosIndex];
		vcpObjectPlatformPos.push_back(cpObjectPlatformPos);


		// 目标位置
		CCoordPos cpTargetPlatformPos;
		if (m_bInnerAlignBench)
		{	
			// 内部基准对位时的目标位置
			//cpTargetPlatformPos = vcpTarPlatPos[nPosIndex];
			// 修改前：目标对象分离时，下料居中对位使用目标0和1的平台坐标，物理意义是对象图像中心
			// 修改前问题：在使用相机轴功能时，标定结果0和1的相机轴坐标是对象相机轴，而目标0和1的相机轴坐标是0，两者相减相机轴变化会导致对位偏移量异常巨大
			// 修改后：目标对象分离时，下料居中对位使用目标2和3的平台坐标，物理意义是目标图像中心
			cpTargetPlatformPos = vcpTarPlatPos[nPosNum + nPosIndex];
		}
		else
		{
			// 实际目标位置
			cpTargetPlatformPos = vcpTarPlatPos[nPosNum + nPosIndex];
		}

		vcpTargetPlatformPos.push_back(cpTargetPlatformPos);
	}

	vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
	vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;

	if (GetMidPlatformType()==ePlatformXYPD)
	{
		std::vector<CCoordPos> vcpPreTargetPlatformPos;		// 上一次目标位置旋转后新的目标位置
		if (nAlnIndex == 0)
		{
			vcpPreTargetPlatformPos = vcpAlginedTargetPlatformPos;
		}
		else
		{
			for (int j=0;j<nPosNum;j++)
			{
				CCoordPos pos;
				pos.m_dPosX = m_dTargetX[j];
				pos.m_dPosY = m_dTargetY[j];

				vcpPreTargetPlatformPos.push_back(pos);
			}
		}
		CCoordPos tempplatformOffset;

		// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
		if (!GetAlginOffset(vcpObjectPlatformPos, vcpPreTargetPlatformPos, m_ProductOffsetXYPD, tempplatformOffset, 
			vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
		{
			m_nAlignErrNum = -10;

			str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(失败)");
			AlignToolLogRecord(str,nPlatformIndex);

			return FALSE;
		}

		str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(成功)");
		AlignToolLogRecord(str,nPlatformIndex);
	}

	// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
	if (!GetAlginOffset(vcpObjectPlatformPos, vcpTargetPlatformPos, m_ProductOffset, m_PlatformOffset, 
		vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
	{
		m_nAlignErrNum = -10;

		str.Format("------------------------------------------------------------对位计算结束(失败)");
		AlignToolLogRecord(str,nPlatformIndex);

		return FALSE;
	}

	// 对位偏差量日志记录
	{
		if (GetMidPlatformType()==ePlatformXYPD)
		{
			strTempInfo.Format("产品偏差 X:%f Y:%f D:%f,", GetAlignProductOffsetXYPD().GetPosX(), GetAlignProductOffsetXYPD().GetPosY(), GetAlignProductOffsetXYPD().GetAngle());
			strInfo += strTempInfo;
		}
		else
		{
			strTempInfo.Format("产品偏差 X:%f Y:%f D:%f,", GetAlignProductOffset().GetPosX(), GetAlignProductOffset().GetPosY(), GetAlignProductOffset().GetAngle());
			strInfo += strTempInfo;
		}


		strTempInfo.Format("平台偏差 X:%f Y:%f D:%f,", GetAlignPlatformPosOffset().GetPosX(), GetAlignPlatformPosOffset().GetPosY(), GetAlignPlatformPosOffset().GetAngle());
		strInfo += strTempInfo;
	}

	AlignToolLogRecordProduct(strInfo,nPlatformIndex);


	str.Format("------------------------------------------------------------对位计算结束（成功）\n\n");
	AlignToolLogRecord(str,nPlatformIndex);

	return TRUE;


}

// 目标、对象分离，目标或者对象通过产品尺寸进行虚拟
BOOL vcBaseAlignTool::ExecuteAlign_Case3(int nAlnIndex/* = 0*/, BOOL bInspect /*= TRUE*/)
{
	int nPlatformIndex = m_nPlatformIndex;
	CString str;
	str.Format("对位计算开始:序号[%d]------------------------------------------------------------",nAlnIndex);
	AlignToolLogRecord(str,nPlatformIndex);

	m_nAlnIndex = nAlnIndex;
//	m_nAlignErrNum = 0;

	if (!m_bTargetObjectCamSeparate)
	{
		AlignToolLogRecord(_T("1"),nPlatformIndex);
		return FALSE;
	}

	if (!m_bEnableTargetAndObjectPositionVirtualMode)
	{
		AlignToolLogRecord(_T("2"),nPlatformIndex);
		return FALSE;
	}

	BOOL bObjectVirtual = m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableObjectPositionVirtualMode;
	BOOL bTargetVirtual = m_AlignermentParam.GetProductPositionVirtualInfo().m_bEnableTargetPositionVirtualMode;
	int nObjectPositionVirtualMode = m_AlignermentParam.GetProductPositionVirtualInfo().m_nObjectPositionVirtualMode;
	int nTargetPositionVirtualMode = m_AlignermentParam.GetProductPositionVirtualInfo().m_nTargetPositionVirtualMode;

	if (bObjectVirtual)
	{
		//根据对象产品尺寸和对象12/34平台坐标虚拟目标34/12平台坐标 
		if ((m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0))
		{
			AlignToolLogRecord(_T("3"),nPlatformIndex);
			return FALSE;
		}
	}

	if (bTargetVirtual)
	{
		//根据目标产品尺寸和目标56/78平台坐标虚拟目标78/56平台坐标 
		if ((m_AlignermentParam.GetProductSizeInfo().m_dTargetL2 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dTargetW2 <= 0))
		{
			AlignToolLogRecord(_T("4"),nPlatformIndex);
			return FALSE;
		}
	}


	std::vector<int> nObjectPosIndex;
	std::vector<int> nTargetPosIndex;

	// 对象位置虚拟
	if (bObjectVirtual)
	{
		switch(nObjectPositionVirtualMode)
		{
			// 对象位置虚拟模式：12拍照34虚拟
		case 0:
			{
				nObjectPosIndex.push_back(0);
				nObjectPosIndex.push_back(1);
			}
			break;

			// 对象位置虚拟模式：34拍照12虚拟
		case 1:
			{
				nObjectPosIndex.push_back(2);
				nObjectPosIndex.push_back(3);
			}
			break;

			// 对象位置虚拟模式：13拍照24虚拟
		case 2:
			{
				nObjectPosIndex.push_back(0);
				nObjectPosIndex.push_back(2);
			}
			break;

			// 对象位置虚拟模式：24拍照13虚拟
		case 3:
			{
				nObjectPosIndex.push_back(1);
				nObjectPosIndex.push_back(3);
			}
			break;

		default:
			{
				return FALSE;
			}
			break;
		}


		for (int i = 0; i < nObjectPosIndex.size(); i++)
		{
			int nIndex = nObjectPosIndex.at(i);

			if (NULL == m_vAlignerCalibInfos.at(nIndex + m_iMarkNum*m_nAlignnExProductIndex))
			{
				m_nAlignErrNum = -1;
				return false;
			}

			if (!m_vAlignerCalibInfos.at(nIndex + m_iMarkNum*m_nAlignnExProductIndex)->IsValid())
			{
				m_nAlignErrNum = -2;
				return false;
			}
		}
	}
	else
	{
		for (int i = 0; i < m_iMarkNum/2; i++)
		{
			if (NULL == m_vAlignerCalibInfos.at(i + m_iMarkNum * m_nAlignnExProductIndex))
			{
				m_nAlignErrNum = -1;
				return false;
			}

			if (!m_vAlignerCalibInfos.at(i + m_iMarkNum * m_nAlignnExProductIndex)->IsValid())
			{
				m_nAlignErrNum = -2;
				return false;
			}
		}
	}

	// 目标位置虚拟
	if (bTargetVirtual)
	{
		switch(nTargetPositionVirtualMode)
		{
			// 目标位置虚拟模式：56拍照78虚拟
		case 0:
			{
				nTargetPosIndex.push_back(4);
				nTargetPosIndex.push_back(5);
			}
			break;

			// 目标位置虚拟模式：78拍照56虚拟
		case 1:
			{
				nTargetPosIndex.push_back(6);
				nTargetPosIndex.push_back(7);
			}
			break;

			// 目标位置虚拟模式：57拍照68虚拟
		case 2:
			{
				nTargetPosIndex.push_back(4);
				nTargetPosIndex.push_back(6);
			}
			break;

			// 目标位置虚拟模式：68拍照57虚拟
		case 3:
			{
				nTargetPosIndex.push_back(5);
				nTargetPosIndex.push_back(7);
			}
			break;

		default:
			{
				return FALSE;
			}
			break;

		}

		for (int i = 0; i < nTargetPosIndex.size(); i++)
		{
			int nIndex = nTargetPosIndex.at(i);

			if (NULL == m_vAlignerCalibInfos.at(nIndex + m_iMarkNum*m_nAlignnExProductIndex))
			{
				m_nAlignErrNum = -1;
				return false;
			}

			if (!m_vAlignerCalibInfos.at(nIndex + m_iMarkNum*m_nAlignnExProductIndex)->IsValid())
			{
				m_nAlignErrNum = -2;
				return false;
			}
		}
	}
	else
	{
		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			if (NULL == m_vAlignerCalibInfos.at(i + m_iMarkNum * m_nAlignnExProductIndex))
			{
				m_nAlignErrNum = -1;
				return false;
			}

			if (!m_vAlignerCalibInfos.at(i + m_iMarkNum * m_nAlignnExProductIndex)->IsValid())
			{
				m_nAlignErrNum = -2;
				return false;
			}
		}
	}

	if (FALSE == m_ObjectSearchResults.IsAllMarkImagePosOK(nObjectPosIndex))
	{
		m_nAlignErrNum = -3;
		return FALSE;
	}

	if (!m_bReadTargetPlatformPos)
	{
		if (FALSE == m_TargetSearchResults.IsAllMarkImagePosOK(nTargetPosIndex))
		{
			m_nAlignErrNum = -4;
			return FALSE;
		}
	}


	CString strTempInfo;
	CString strInfo;

	strTempInfo.Format(",对位序号%d,", nAlnIndex);
	strInfo += strTempInfo;

	strTempInfo.Format("%d位置分离对位-产品尺寸虚拟,", m_iMarkNum);
	strInfo += strTempInfo;



// 	int nPlatformIndex = m_nPlatformIndex;
// 	CString str;
// 	str.Format("对位计算开始:序号[%d]------------------------------------------------------------",nAlnIndex);
// 	AlignToolLogRecord(str,nPlatformIndex);

	std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;	
	for (int k=0;k<m_pObjectPlatformAxisPos.size();k++)
	{
		pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置
	}

	std::vector<CPlatformXYDAxisPos*> pTargetPlatformAxisPos;
	for (int k=0;k<m_pTargetPlatformAxisPos.size();k++)
	{
		pTargetPlatformAxisPos.push_back((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k));//搜索目标mark轴位置
	}
	if(pTargetPlatformAxisPos.size()<m_iMarkNum)
	{
		pTargetPlatformAxisPos.resize(m_iMarkNum);
	}


	std::vector<CCoordPos> vcpObjPlatPos;		// 对象位置
	std::vector<CCoordPos> vcpTarPlatPos;		// 目标位置

	vcpObjPlatPos.resize(8);
	vcpTarPlatPos.resize(8);


	// 1. 实时对象Mark的图像坐标值转化为平台坐标值
	m_ObjectMarkPlatformPos = GetObjectMarkPlatformPos();
	if (FALSE == m_ObjectMarkPlatformPos.IsAllMarkPlatformPosOK())
	{
		m_nAlignErrNum = -5;
		return FALSE;
	}


	// 2. 综合对位方式，对象点重构
	if (IsObjectReConstruct())
	{
		if (FALSE == ExecuteObjectPlatformPosRestruct(m_ObjectMarkPlatformPos.m_vPos))
		{
			m_nAlignErrNum = -6;
			return FALSE;
		}
	}

	double dTempObjectX[8];			// 存储对象mark平台坐标
	double dTempObjectY[8];
	double dTempObjectD[8];

	memset(dTempObjectX, 0.0, sizeof(double)*8);
	memset(dTempObjectY, 0.0, sizeof(double)*8);
	memset(dTempObjectD, 0.0, sizeof(double)*8);

	// 3. 对象虚拟点计算
	if (bObjectVirtual)
	{
		for (int i = 0; i < m_iMarkNum; i++)
		{
			dTempObjectX[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX;
			dTempObjectY[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY;
			dTempObjectD[i] = m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle;
		}

		switch(nObjectPositionVirtualMode)
		{
		case 0:
			{
				//  1   2
				// (3) (4)

				// 放射矩形
				sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
				sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
				double dXLength = (ptObject2 - ptObject1).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
				scRadian xRot;
				(ptObject2 - ptObject1).Angle(xRot);
				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
				xRot = xRot.SignedNormMod180();
				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
				//xRot = xRot.NormMod180();


				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dXLength, dYLength, xRot, scRadian(0));

				ptObject1 = affrect.GetCornerPo();
				ptObject2 = affrect.GetCornerPx();
				sc2Vector ptObject3 = affrect.GetCornerPy();
				sc2Vector ptObject4 = affrect.GetCornerPopp();

				dTempObjectX[2] = ptObject3.GetX();
				dTempObjectY[2] = ptObject3.GetY();
				dTempObjectX[3] = ptObject4.GetX();
				dTempObjectY[3] = ptObject4.GetY();

				for (int i = 0; i < m_iMarkNum; i++)
				{
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
				}
			}
			break;

		case 1:
			{
				// (1) (2)
				//  3   4
				sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
				sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
				double dXLength = (ptObject4 - ptObject3).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectW1;
				scRadian xRot;
				(ptObject4 - ptObject3).Angle(xRot);
				// 对象1点、2点连线为水平方向，应将其归一化到-90-90
				xRot = xRot.SignedNormMod180();
				// 对象1点、2点连线为垂直方向，应将其归一化到0-180
				//xRot = xRot.NormMod180();

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptObject3, dXLength, dYLength, xRot, scRadian(skPI));

				ptObject3 = affrect.GetCornerPo();
				ptObject4 = affrect.GetCornerPx();
				sc2Vector ptObject1 = affrect.GetCornerPy();
				sc2Vector ptObject2 = affrect.GetCornerPopp();

				dTempObjectX[0] = ptObject1.GetX();
				dTempObjectY[0] = ptObject1.GetY();
				dTempObjectX[1] = ptObject2.GetX();
				dTempObjectY[1] = ptObject2.GetY();

				for (int i = 0; i < m_iMarkNum; i++)
				{
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
				}
			}
			break;

		case 2:
			{
				//	1  (2)
				//  3  (4)
				sc2Vector ptObject1 = sc2Vector(dTempObjectX[0], dTempObjectY[0]);
				sc2Vector ptObject3 = sc2Vector(dTempObjectX[2], dTempObjectY[2]);
				double dYLength = (ptObject3 - ptObject1).Length();
				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
				scRadian xRot;
				(ptObject3 - ptObject1).Angle(xRot);
				xRot = xRot.NormMod180();

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptObject1, dYLength, dXLength, xRot, scRadian(skPI));

				ptObject1 = affrect.GetCornerPo();
				ptObject3 = affrect.GetCornerPx();
				sc2Vector ptObject2 = affrect.GetCornerPy();
				sc2Vector ptObject4 = affrect.GetCornerPopp();

				dTempObjectX[1] = ptObject2.GetX();
				dTempObjectY[1] = ptObject2.GetY();
				dTempObjectX[3] = ptObject4.GetX();
				dTempObjectY[3] = ptObject4.GetY();

				for (int i = 0; i < m_iMarkNum; i++)
				{
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
				}
			}
			break;

		case 3:
			{
				//	（1） 2
				//  （3） 4
				// 放射矩形
				sc2Vector ptObject2 = sc2Vector(dTempObjectX[1], dTempObjectY[1]);
				sc2Vector ptObject4 = sc2Vector(dTempObjectX[3], dTempObjectY[3]);
				double dYLength = (ptObject4 - ptObject2).Length();
				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dObjectL1;
				scRadian xRot;
				(ptObject4 - ptObject2).Angle(xRot);
				xRot = xRot.NormMod180();

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptObject2, dYLength, dXLength, xRot, scRadian(0));

				ptObject2= affrect.GetCornerPo();
				ptObject4 = affrect.GetCornerPx();
				sc2Vector ptObject1 = affrect.GetCornerPy();
				sc2Vector ptObject3 = affrect.GetCornerPopp();

				dTempObjectX[0] = ptObject1.GetX();
				dTempObjectY[0] = ptObject1.GetY();
				dTempObjectX[2] = ptObject3.GetX();
				dTempObjectY[2] = ptObject3.GetY();

				for (int i = 0; i < m_iMarkNum; i++)
				{
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempObjectX[i];
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempObjectY[i];
					m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempObjectD[i];
				}
			}
			break;

		default:
			{
				return FALSE;
			}
			break;
		}
	}


	// 对象补偿前格式化日志记录
	{
		for (int i = 0; i < m_pObjectPlatformAxisPos.size()/2; i++)
		{
			strTempInfo.Format("对象%d轴位置 X:%f Y:%f D:%f,", i, pObjectPlatformAxisPos.at(i)->m_dPosX,pObjectPlatformAxisPos.at(i)->m_dPosY,pObjectPlatformAxisPos.at(i)->m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i=0; i<m_iMarkNum/2; i++)
		{
			strTempInfo.Format("对象%d图像坐标 X:%f Y:%f D:%f,",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i=0; i<m_iMarkNum/2; i++)
		{
			strTempInfo.Format("补偿前对象%d平台坐标 X:%f Y:%f D:%f,",i,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosX,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dPosY,m_ObjectMarkPlatformPos.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}
	}


	//////////////////////////////////////////////////////////////////////////
	// 4. 对象平台坐标进行补偿
	for (int i=0; i<m_iMarkNum; i++)
	{
		str.Format("对象轴位置%d: X = %f, Y = %f , D = %f ", i, pObjectPlatformAxisPos.at(i)->m_dPosX,pObjectPlatformAxisPos.at(i)->m_dPosY,pObjectPlatformAxisPos.at(i)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("对象图像坐标%d: X = %f, Y = %f , D = %f ",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("对象平台坐标%d: X = %f , Y = %f , D = %f ",i, m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosX(),m_ObjectMarkPlatformPos.m_vPos.at(i).GetPosY(),m_ObjectMarkPlatformPos.m_vPos.at(i).GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);


		// 记录相机对象mark的坐标
		vcpObjPlatPos[i] = m_ObjectMarkPlatformPos.m_vPos[i];

		// $1.2 实时对象为虚拟Mark，则将实时对象Mark的平台坐标值转换为虚拟Mark的平台坐标值
		if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
		{
			if (FALSE == ConvertObjectPltfmPtToVirtualPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos))
				return FALSE;

			vcpObjPlatPos[i] = m_VirtualMarkPlatformPos.m_vPos[i];

			str.Format("补偿前虚拟对象平台坐标%d: X = %f , Y = %f , D = %f ", i, vcpObjPlatPos[i].GetPosX(), vcpObjPlatPos[i].GetPosY(), vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}

		if (!m_bInnerAlignBench)
		{
			if (IsExecuteCoordinateCompensation())
			{
				std::vector<CCoordPos> vFixedObjectPlatformPos;
				vFixedObjectPlatformPos.resize(m_iMarkNum);

				BOOL bOffsetSuccess = ExecuteCoordinateCompensation(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos, vFixedObjectPlatformPos);

				vcpObjPlatPos[i] = vFixedObjectPlatformPos[i];

				if (!bOffsetSuccess)
				{
					m_nAlignErrNum = -7;
					return FALSE;
				}
			}

			str.Format("补偿后对象平台坐标%d: X = %f , Y = %f , D = %f", i, vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);

		}
		else
		{
			// $1.3 对象Mark的全局平台坐标值补偿
			//当不需要基准修正时，考虑要不要对对象mark进行补偿

			CMarkPlatformPos m_ObjectAddRotationOffsetPos;
			m_ObjectAddRotationOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddRotationOffsetPos.m_vbOK.resize(m_iMarkNum);
			CMarkPlatformPos m_ObjectAddMoveOffsetPos;
			m_ObjectAddMoveOffsetPos.m_vPos.resize(m_iMarkNum);
			m_ObjectAddMoveOffsetPos.m_vbOK.resize(m_iMarkNum);

			if (1/*eMarkCoord == m_AlignermentParam.GetAlignerOffsetCoordType()*/)// Mark坐标系下补偿
			{
				// Mark坐标系下旋转角度进行补偿
				if (m_AlignermentParam.GetAlignerBenchOffset().GetAngle()||m_AlignermentParam.GetAlignerBenchOffset().GetPosX()||m_AlignermentParam.GetAlignerBenchOffset().GetPosY())
				{
					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
						MarkCoordOffsetRotationObjectPlatformPos(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
					else
						MarkCoordOffsetRotationObjectPlatformPos(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);

					// Mark坐标系下XY轴平移量进行补偿
					MarkCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
				}
			}

			str.Format("补偿后对象平台坐标%d: X = %f , Y = %f , D = %f", i, vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}

	}

	// 对象格式化日志记录
	{

		// 当前使用的补偿类型及补偿数值
		strTempInfo.Format("补偿类型:%d 补偿序号:%d X:%f Y:%f D:%f,",m_AlignermentParam.GetAlignerOffsetCoordType(),m_AlignermentParam.GetCurAlignerOffsetIndex(),m_AlignermentParam.GetAlignerOffset().GetPosX() ,m_AlignermentParam.GetAlignerOffset().GetPosY(), m_AlignermentParam.GetAlignerOffset().GetAngle());
		strInfo += strTempInfo;

		for (int i=0; i<m_iMarkNum/2; i++)
		{
			strTempInfo.Format("补偿后对象%d平台坐标 X:%f Y:%f D:%f,",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
			strInfo += strTempInfo;
		}


		sc2Vector pt[4];
		for (int i=0; i<m_iMarkNum/2; i++)
		{
			pt[i] = sc2Vector(vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY());
		}

		switch(m_iMarkNum)
		{
		case 4:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;		
			}
			break;

		case 6:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;	

				dLen[1] = (pt[1] - pt[2]).Length();
				(pt[1] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("对象12距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("对象02距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 8:
			{
				//记录对象距离角度
				double dLen[4];
				scRadian raAngle[4];
				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("对象01距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;

				dLen[1] = (pt[3] - pt[2]).Length();
				(pt[3] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("对象23距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("对象02距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;

				dLen[3] = (pt[3] - pt[1]).Length();
				(pt[3] - pt[1]).Angle(raAngle[3]);
				strTempInfo.Format("对象13距离角度 L:%f D:%f,", dLen[3], scDegree(raAngle[3]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		default:
			{

			}
			break;

		}
	}


	// 5. 实时目标Mark的图像坐标值转化为平台坐标值
	if (eTargetBench != m_AlignermentParam.GetTargetMarkType())
	{
		if (!m_bReadTargetPlatformPos)
		{
			m_TargetMarkPlatformPos = GetTargetMarkPlatformPosForAlign();
		}

		if (FALSE == m_TargetMarkPlatformPos.IsAllMarkPlatformPosOK())
		{
			m_nAlignErrNum = -8;
			return FALSE;
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//6. 综合对位重新构造新的目标对位点
// 	if (!m_bReadTargetPlatformPos)
// 	{
		// 综合对位模式，目标点重构
// 		if (IsTargetReConstruct())
// 		{
// 			if (FALSE == ExecuteTargetPlatformPosRestruct(m_TargetMarkPlatformPos.m_vPos))
// 			{
// 				return FALSE;
// 			}
// 		}
// 	}

	double dTempTargetX[8];			// 存储目标mark平台坐标
	double dTempTargetY[8];
	double dTempTargetD[8];

	memset(dTempTargetX, 0.0, sizeof(double)*8);
	memset(dTempTargetY, 0.0, sizeof(double)*8);
	memset(dTempTargetD, 0.0, sizeof(double)*8);

	// 7. 目标虚拟点计算
	if (bTargetVirtual)
	{
		for (int i = 0; i < m_iMarkNum; i++)
		{
			dTempTargetX[i] = m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX;
			dTempTargetY[i] = m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY;
			dTempTargetD[i] = m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle;
		}

		switch(nTargetPositionVirtualMode)
		{
		case 0:
			{
				//	5   6
				// (7) (8)
				// 				sc2Vector ptTarget5 = vcpTarPlatPos[4].GetPos();
				// 				sc2Vector ptTarget6 = vcpTarPlatPos[5].GetPos();
				sc2Vector ptTarget5 = sc2Vector(dTempTargetX[4], dTempTargetY[4]);
				sc2Vector ptTarget6 = sc2Vector(dTempTargetX[5], dTempTargetY[5]);
				double dXLength = (ptTarget6 - ptTarget5).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
				scRadian xRot;
				(ptTarget6 - ptTarget5).Angle(xRot);
				xRot = xRot.SignedNormMod180();

				str.Format("目标56坐标:5X=%f,5Y=%f,6X=%f,6Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标56连线角度:56Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dXLength, dYLength, xRot, scRadian(0));

				ptTarget5 = affrect.GetCornerPo();
				ptTarget6 = affrect.GetCornerPx();
				sc2Vector ptTarget7 = affrect.GetCornerPy();
				sc2Vector ptTarget8 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				// 				vcpTarPlatPos[6].SetPos(ptTarget7);
				// 				vcpTarPlatPos[7].SetPos(ptTarget8);
				for (int i = 0; i < m_iMarkNum; i++)
				{
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempTargetX[i];
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempTargetY[i];
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempTargetD[i];
				}

			}
			break;

		case 1:
			{
				// (5) (6)
				//  7   8
				// 				sc2Vector ptTarget7 = vcpTarPlatPos[6].GetPos();
				// 				sc2Vector ptTarget8 = vcpTarPlatPos[7].GetPos();
				sc2Vector ptTarget7 = sc2Vector(dTempTargetX[6], dTempTargetY[6]);
				sc2Vector ptTarget8 = sc2Vector(dTempTargetX[7], dTempTargetY[7]);
				double dXLength = (ptTarget8 - ptTarget7).Length();
				double dYLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetW2;
				scRadian xRot;
				(ptTarget8 - ptTarget7).Angle(xRot);
				xRot = xRot.SignedNormMod180();

				str.Format("目标78坐标:7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标78连线角度:78Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget7, dXLength, dYLength, xRot, scRadian(skPI));

				ptTarget7 = affrect.GetCornerPo();
				ptTarget8 = affrect.GetCornerPx();
				sc2Vector ptTarget5 = affrect.GetCornerPy();
				sc2Vector ptTarget6 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				// 				vcpTarPlatPos[4].SetPos(ptTarget5);
				// 				vcpTarPlatPos[5].SetPos(ptTarget6);
				for (int i = 0; i < m_iMarkNum; i++)
				{
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempTargetX[i];
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempTargetY[i];
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempTargetD[i];
				}
			}
			break;

		case 2:
			{
				//	5  (6)
				//  7 （8）
				// 				sc2Vector ptTarget5 = vcpTarPlatPos[4].GetPos();
				// 				sc2Vector ptTarget7 = vcpTarPlatPos[6].GetPos();
				sc2Vector ptTarget5 = sc2Vector(dTempTargetX[4], dTempTargetY[4]);
				sc2Vector ptTarget7 = sc2Vector(dTempTargetX[6], dTempTargetY[6]);
				double dYLength = (ptTarget7 - ptTarget5).Length();
				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
				scRadian xRot;
				(ptTarget7 - ptTarget5).Angle(xRot);
				xRot = xRot.NormMod180();

				str.Format("目标57坐标:5X=%f,5Y=%f,7X=%f,7Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget7.GetX(),ptTarget7.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标57连线角度:57Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget5, dYLength, dXLength, xRot, scRadian(skPI));

				ptTarget5 = affrect.GetCornerPo();
				ptTarget7 = affrect.GetCornerPx();
				sc2Vector ptTarget6 = affrect.GetCornerPy();
				sc2Vector ptTarget8 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				// 				vcpTarPlatPos[5].SetPos(ptTarget6);
				// 				vcpTarPlatPos[7].SetPos(ptTarget8);
				for (int i = 0; i < m_iMarkNum; i++)
				{
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempTargetX[i];
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempTargetY[i];
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempTargetD[i];
				}
			}
			break;

		case 3:
			{
				//  （5）  6
				//  （7）  8
				// 				sc2Vector ptTarget6 = vcpTarPlatPos[5].GetPos();
				// 				sc2Vector ptTarget8 = vcpTarPlatPos[7].GetPos();
				sc2Vector ptTarget6 = sc2Vector(dTempTargetX[5], dTempTargetY[5]);
				sc2Vector ptTarget8 = sc2Vector(dTempTargetX[7], dTempTargetY[7]);
				double dYLength = (ptTarget8 - ptTarget6).Length();
				double dXLength = m_AlignermentParam.GetProductSizeInfo().m_dTargetL2;
				scRadian xRot;
				(ptTarget8 - ptTarget6).Angle(xRot);
				xRot = xRot.NormMod180();

				str.Format("目标68坐标:6X=%f,6Y=%f,8X=%f,8Y=%f",ptTarget6.GetX(),ptTarget6.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标68连线角度:68Angle=%f",scDegree(xRot).ToDouble());
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("目标矩形尺寸:LX=%f,LY=%f",dXLength,dYLength);
				AlignToolLogRecord(str,nPlatformIndex);

				scAffineRect affrect;
				affrect.SetCornerPoLengthsRotAndSkew(ptTarget6, dYLength, dXLength, xRot, scRadian(0));

				ptTarget6 = affrect.GetCornerPo();
				ptTarget8 = affrect.GetCornerPx();
				sc2Vector ptTarget5 = affrect.GetCornerPy();
				sc2Vector ptTarget7 = affrect.GetCornerPopp();

				str.Format("目标5678坐标(虚拟):5X=%f,5Y=%f,6X=%f,6Y=%f7X=%f,7Y=%f,8X=%f,8Y=%f",ptTarget5.GetX(),ptTarget5.GetY(),ptTarget6.GetX(),ptTarget6.GetY(),ptTarget7.GetX(),ptTarget7.GetY(),ptTarget8.GetX(),ptTarget8.GetY());
				AlignToolLogRecord(str,nPlatformIndex);

				// 				vcpTarPlatPos[4].SetPos(ptTarget5);
				// 				vcpTarPlatPos[6].SetPos(ptTarget7);
				for (int i = 0; i < m_iMarkNum; i++)
				{
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosX = dTempTargetX[i];
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dPosY = dTempTargetY[i];
					m_TargetMarkPlatformPos.m_vPos.at(i).m_dAngle = dTempTargetD[i];
				}
			}
			break;

		default:
			{
				return FALSE;
			}
			break;

		}
	}

	// 目标修正前格式化日志记录
	{
		for (int i = m_iMarkNum/2; i < m_pTargetPlatformAxisPos.size(); i++)
		{
			strTempInfo.Format("目标%d轴位置 X:%f Y:%f D:%f,", i, pTargetPlatformAxisPos.at(i)->m_dPosX,pTargetPlatformAxisPos.at(i)->m_dPosY,pTargetPlatformAxisPos.at(i)->m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			strTempInfo.Format("目标%d图像坐标 X:%f Y:%f D:%f,",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
			strInfo += strTempInfo;
		}

		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
//			strTempInfo.Format("修正前目标%d平台坐标 X:%f Y:%f D:%f,", i, vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
			strTempInfo.Format("修正前目标%d平台坐标 X:%f Y:%f D:%f,", i, m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX(), m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY(),m_TargetMarkPlatformPos.m_vPos.at(i).GetAngle());
			strInfo += strTempInfo;
		}
	}


	// 8. 对目标平台坐标进行修正	
	for (int i=0; i<m_iMarkNum; i++)
	{
		str.Format("目标轴位置%d: X = %f , Y = %f , D = %f ", i, pTargetPlatformAxisPos.at(i)->m_dPosX, pTargetPlatformAxisPos.at(i)->m_dPosY, pTargetPlatformAxisPos.at(i)->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("目标图像坐标%d: X = %f , Y = %f , D = %f ",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("轴修正前目标平台坐标%d: X = %f , Y = %f, D = %f ",i,m_TargetMarkPlatformPos.m_vPos.at(i).GetPosX(),m_TargetMarkPlatformPos.m_vPos.at(i).GetPosY(), m_TargetMarkPlatformPos.m_vPos.at(i).GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);


		// 目标Mark为基准Mark
		if (eTargetBench == m_AlignermentParam.GetTargetMarkType())
		{	
			//如果没有进行基准修正，则使用标定后的基准mark平台坐标
			if (FALSE == m_AlignermentParam.GetBenchTargetMarkFixEnable())
			{
				CPlatformXYDAxisPos* pBenchPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());//标定基准轴位置

				vcpTarPlatPos[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos;

				pTargetPlatformAxisPos.at(i) = pBenchPlatformAxisPos;
			}
			else//进行基准修正，使用修正后的基准坐标
			{
				CPlatformXYDAxisPos* pBenchFixPlatformAxisPos = (CPlatformXYDAxisPos*)(m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetFixPlatformPos(i));//基准修正时轴位置

				vcpTarPlatPos[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i);

				pTargetPlatformAxisPos.at(i) = pBenchFixPlatformAxisPos;
			}
		}
		else//目标mark为实时mark
		{
			vcpTarPlatPos[i] = m_TargetMarkPlatformPos.m_vPos[i];
		}



		// $3、对目标Mark的平台坐标值进行修正(平台XY轴移动影响影响结果)
		double dPlatformOffsetX = 0;
		double dPlatformOffsetY = 0;
		CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

		//修正回读取目标平台坐标时，已经重构点的轴位置偏移
		if (m_bReadTargetPlatformPos)
		{
			// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
			if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
			{
				dPlatformOffsetX = 0;
				dPlatformOffsetY = 0;
			}
			else
			{
				dPlatformOffsetX = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosX - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosX;
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
				dPlatformOffsetY = ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(m_pTargetPlatformAxisPos.size()-1))->m_dPosY - ((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(i))->m_dPosY;
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
			}

			if (GetMidPlatformType()==ePlatformXYPD)
			{
				dPlatformOffsetX = 0;
				dPlatformOffsetY = 0;
			}		

			vcpTarPlatPos[i].Offset(dPlatformOffsetX, dPlatformOffsetY);
		}

		// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
// 		if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
// 		{
// 			dPlatformOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// 			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 			dPlatformOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// 			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

// 		}
// 		else
		{
			dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
			dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

			double dObjectPlatformAxisPosX = pObjectPlatformAxisPos.at( i%(m_iMarkNum/2) )->m_dPosX;
			double dObjectPlatformAxisPosY = pObjectPlatformAxisPos.at( i%(m_iMarkNum/2) )->m_dPosY;
			if (bObjectVirtual)
			{
				switch(nObjectPositionVirtualMode)
				{
				case 0:
					{
						// 对象位置虚拟模式：12拍照34虚拟
						dObjectPlatformAxisPosX = pObjectPlatformAxisPos.at(0)->m_dPosX;
						dObjectPlatformAxisPosY = pObjectPlatformAxisPos.at(0)->m_dPosY;
					}
					break;

					// 对象位置虚拟模式：34拍照12虚拟
				case 1:
					{
						dObjectPlatformAxisPosX = pObjectPlatformAxisPos.at(2)->m_dPosX;
						dObjectPlatformAxisPosY = pObjectPlatformAxisPos.at(2)->m_dPosY;
					}
					break;

					// 对象位置虚拟模式：13拍照24虚拟
				case 2:
					{
						dObjectPlatformAxisPosX = pObjectPlatformAxisPos.at(0)->m_dPosX;
						dObjectPlatformAxisPosY = pObjectPlatformAxisPos.at(0)->m_dPosY;
					}
					break;

					// 对象位置虚拟模式：24拍照13虚拟
				case 3:
					{
						dObjectPlatformAxisPosX = pObjectPlatformAxisPos.at(1)->m_dPosX;
						dObjectPlatformAxisPosY = pObjectPlatformAxisPos.at(1)->m_dPosY;
					}
					break;

				default:
					{
						return FALSE;
					}
					break;
				}
			}

			double dTargetPlatformAxisPosX = pTargetPlatformAxisPos.at(i)->m_dPosX;
			double dTargetPlatformAxisPosY = pTargetPlatformAxisPos.at(i)->m_dPosY;
			if (bTargetVirtual)
			{
				switch(nTargetPositionVirtualMode)
				{
					// 目标位置虚拟模式：56拍照78虚拟
				case 0:
					{
						dTargetPlatformAxisPosX = pTargetPlatformAxisPos.at(4)->m_dPosX;
						dTargetPlatformAxisPosY = pTargetPlatformAxisPos.at(4)->m_dPosY;
					}
					break;

					// 目标位置虚拟模式：78拍照56虚拟
				case 1:
					{
						dTargetPlatformAxisPosX = pTargetPlatformAxisPos.at(6)->m_dPosX;
						dTargetPlatformAxisPosY = pTargetPlatformAxisPos.at(6)->m_dPosY;
					}
					break;

					// 目标位置虚拟模式：57拍照68虚拟
				case 2:
					{				
						dTargetPlatformAxisPosX = pTargetPlatformAxisPos.at(4)->m_dPosX;
						dTargetPlatformAxisPosY = pTargetPlatformAxisPos.at(4)->m_dPosY;
					}
					break;

					// 目标位置虚拟模式：68拍照57虚拟
				case 3:
					{
						dTargetPlatformAxisPosX = pTargetPlatformAxisPos.at(5)->m_dPosX;
						dTargetPlatformAxisPosY = pTargetPlatformAxisPos.at(5)->m_dPosY;
					}
					break;

				default:
					{
						return FALSE;
					}
					break;

				}
			}

			if ( (bObjectVirtual) || (bTargetVirtual) )
			{
				dPlatformOffsetX = (dObjectPlatformAxisPosX - dTargetPlatformAxisPosX);
				if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
	
				dPlatformOffsetY = (dObjectPlatformAxisPosY - dTargetPlatformAxisPosY);
				if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
			}
		}

		if (m_bTargetUseFixedVirtualCoordinates == TRUE && m_bTarObjCamSepNoAxisCalib)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		if (GetMidPlatformType()==ePlatformXYPD)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;

		}
		else if (GetMidPlatformType()==ePlatformXY)
		{
			dPlatformOffsetX = 0;
			dPlatformOffsetY = 0;
		}

		if (m_bTargetObjectCamSeparate && m_bTargetCalibUseBoard && m_AlignermentParam.m_bEnableAlnTargetFixOffset)
		{
			// 目标标定轴相对于对象标定轴位置偏移量
			CPlatformXYDAxisPos*  pTargetPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(m_iMarkNum/2)->GetPlatformAxisPos());
			CPlatformXYDAxisPos*  pObjectPlatformXYDBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());

			double dVirtualPlatformAixsOffsetX = pObjectPlatformXYDBenchAxisPos->m_dPosX - pTargetPlatformXYDBenchAxisPos->m_dPosX;
			double dVirtualPlatformAixsOffsetY = pObjectPlatformXYDBenchAxisPos->m_dPosY - pTargetPlatformXYDBenchAxisPos->m_dPosY;

			if (eDirectNegative == iPlatformXCoordType) dVirtualPlatformAixsOffsetX = -1*dVirtualPlatformAixsOffsetX;	
			if (eDirectNegative == iPlatformYCoordType) dVirtualPlatformAixsOffsetY = -1*dVirtualPlatformAixsOffsetY;

			dPlatformOffsetX = dPlatformOffsetX - dVirtualPlatformAixsOffsetX;
			dPlatformOffsetY = dPlatformOffsetY - dVirtualPlatformAixsOffsetY;
		}

		vcpTarPlatPos[i].Offset(-dPlatformOffsetX, -dPlatformOffsetY);

		str.Format("轴修正后目标平台坐标%d: X = %f , Y = %f, D = %f ",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
		AlignToolLogRecord(str,nPlatformIndex);

	}


	// 	//////////////////////////////////////////////////////////////////////////
	// 	//7. 综合对位重新构造新的目标对位点
	if (!m_bReadTargetPlatformPos)
	{
 		// 综合对位模式，目标点重构
		if (IsTargetReConstruct())
		{
			if (FALSE == ExecuteTargetPlatformPosRestruct(vcpTarPlatPos))
			{
				m_nAlignErrNum = -9;
				return FALSE;
			}
		}
	}



	if (m_AlignermentParam.m_bCheckAlnTargetOffsetEnable && !m_bInnerAlignBench)
	{
		if (m_AlignermentParam.m_dAlnTargetOffsetX!=0 || m_AlignermentParam.m_dAlnTargetOffsetY!=0 )
		{
			for(int k=0;k<m_iMarkNum;k++)
			{
				vcpTarPlatPos[k].Offset(-m_AlignermentParam.m_dAlnTargetOffsetX, -m_AlignermentParam.m_dAlnTargetOffsetY);
			}
		}
	}	

	if (m_bTargetCalibUseBoard && !m_bInnerAlignBench)
	{
		if (m_AlignermentParam.m_bEnableAlnTargetFixOffset )
		{
			if (m_AlignermentParam.GetCurTargetFixOffset().GetPosX()!=0 || m_AlignermentParam.GetCurTargetFixOffset().GetPosY()!=0 || m_AlignermentParam.GetCurTargetFixOffset().GetAngle()!=0)
			{
				// 获取产品位置（旋转中心）和角度
				sc2Vector vTargetPos;
				sc2Vector vFixedTargetPos;
				for (int i=0;i<m_iMarkNum && i<vcpTarPlatPos.size();i++)
				{
					vTargetPos.SetX(vcpTarPlatPos.at(i).m_dPosX);
					vTargetPos.SetY(vcpTarPlatPos.at(i).m_dPosY);
					vFixedTargetPos = vfGetTransformRotateShiftPoint(vTargetPos, scDegree(m_AlignermentParam.GetCurTargetFixOffset().GetAngle()), m_AlignermentParam.GetCurTargetFixOffset().GetPosX(), m_AlignermentParam.GetCurTargetFixOffset().GetPosY());
					vcpTarPlatPos.at(i).SetPos(vFixedTargetPos);
					for (int j=0;j<vcpTarPlatPos.at(i).m_vdAuxiliaryPosX.size();j++)
					{
						vTargetPos.SetX(vcpTarPlatPos.at(i).GetAuxiliaryPosX(j));
						vTargetPos.SetY(vcpTarPlatPos.at(i).GetAuxiliaryPosY(j));
						vFixedTargetPos = vfGetTransformRotateShiftPoint(vTargetPos, scDegree(m_AlignermentParam.GetCurTargetFixOffset().GetAngle()), m_AlignermentParam.GetCurTargetFixOffset().GetPosX(), m_AlignermentParam.GetCurTargetFixOffset().GetPosY());
						vcpTarPlatPos.at(i).SetAuxPos(j,vFixedTargetPos);
					}
				}
			}
		}	
		else
		{
			CCoordPos TargetFixOffset;
			GetDefaultTargetFixOffset(TargetFixOffset);
			sc2Vector vTargetPos;
			sc2Vector vFixedTargetPos;
			for (int i=0;i<m_iMarkNum && i<vcpTarPlatPos.size();i++)
			{
				vTargetPos.SetX(vcpTarPlatPos.at(i).m_dPosX);
				vTargetPos.SetY(vcpTarPlatPos.at(i).m_dPosY);
				vcpTarPlatPos.at(i).Offset(TargetFixOffset.GetPosX(), TargetFixOffset.GetPosY());
			}
		}

		for (int i=0; i<m_iMarkNum; i++)
		{
			//记录相机目标mark的坐标
			str.Format("固定补偿后目标mark%d平台坐标 X:,%f,Y:,%f,D:,%f,",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
			AlignToolLogRecord(str,nPlatformIndex);
		}
	}

	// 目标修正后格式化日志记录
	{

		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			strTempInfo.Format("修正后目标%d平台坐标 X:%f Y:%f D:%f,", i, vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
			strInfo += strTempInfo;
		}

		sc2Vector pt[4];
		for (int i = m_iMarkNum/2; i < m_iMarkNum; i++)
		{
			pt[i-m_iMarkNum/2] = vcpTarPlatPos[i].GetPos();
		}


		switch(m_iMarkNum)
		{
		case 4:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标23距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 6:
			{
				double dLen[4];
				scRadian raAngle[4];

				memset(dLen, 0, sizeof(double)*4);
				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标34距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;

				dLen[1] = (pt[1] - pt[2]).Length();
				(pt[1] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("目标45距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[3] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标35距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;
			}
			break;

		case 8:
			{
				double dLen[4];
				scRadian raAngle[4];

				dLen[0] = (pt[1] - pt[0]).Length();
				(pt[1] - pt[0]).Angle(raAngle[0]);
				strTempInfo.Format("目标45距离角度 L:%f D:%f,", dLen[0], scDegree(raAngle[0]).ToDouble());
				strInfo += strTempInfo;

				dLen[1] = (pt[3] - pt[2]).Length();
				(pt[3] - pt[2]).Angle(raAngle[1]);
				strTempInfo.Format("目标67距离角度 L:%f D:%f,", dLen[1], scDegree(raAngle[1]).ToDouble());
				strInfo += strTempInfo;

				dLen[2] = (pt[2] - pt[0]).Length();
				(pt[2] - pt[0]).Angle(raAngle[2]);
				strTempInfo.Format("目标46距离角度 L:%f D:%f,", dLen[2], scDegree(raAngle[2]).ToDouble());
				strInfo += strTempInfo;

				dLen[3] = (pt[3] - pt[1]).Length();
				(pt[3] - pt[1]).Angle(raAngle[3]);
				strTempInfo.Format("目标57距离角度 L:%f D:%f,", dLen[3], scDegree(raAngle[3]).ToDouble());
				strInfo += strTempInfo;

			}
			break;

		default:
			{

			}
			break;

		}
	}


	m_PlatformOffset.m_dPosX  = 0;		
	m_PlatformOffset.m_dPosY  = 0;
	m_PlatformOffset.m_dAngle = 0;

	m_ProductOffset.m_dPosX  = 0;		
	m_ProductOffset.m_dPosY  = 0;
	m_ProductOffset.m_dAngle = 0;

	m_ProductOffsetXYPD.m_dPosX  = 0;		
	m_ProductOffsetXYPD.m_dPosY  = 0;
	m_ProductOffsetXYPD.m_dAngle = 0;

	int nPosNum = m_iMarkNum/2;							// 实际对位的位置数量
	std::vector<CCoordPos> vcpObjectPlatformPos;		// 对象位置
	std::vector<CCoordPos> vcpTargetPlatformPos;		// 目标位置
	std::vector<CCoordPos> vcpAlginedObjectPlatformPos; // 对位后对象位置
	std::vector<CCoordPos> vcpAlginedTargetPlatformPos; // 对位后目标位置
	for (int nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
	{
		// 对象位置
		CCoordPos cpObjectPlatformPos;

		cpObjectPlatformPos = vcpObjPlatPos[nPosIndex];

		vcpObjectPlatformPos.push_back(cpObjectPlatformPos);


		// 目标位置
		CCoordPos cpTargetPlatformPos;
		if (m_bInnerAlignBench)
		{	
			// 内部基准对位时的目标位置
			//cpTargetPlatformPos = vcpTarPlatPos[nPosIndex];
			// 修改前：目标对象分离时，下料居中对位使用目标0和1的平台坐标，物理意义是对象图像中心
			// 修改前问题：在使用相机轴功能时，标定结果0和1的相机轴坐标是对象相机轴，而目标0和1的相机轴坐标是0，两者相减相机轴变化会导致对位偏移量异常巨大
			// 修改后：目标对象分离时，下料居中对位使用目标2和3的平台坐标，物理意义是目标图像中心
			cpTargetPlatformPos = vcpTarPlatPos[nPosNum + nPosIndex];
		}
		else
		{
			// 实际目标位置
			cpTargetPlatformPos = vcpTarPlatPos[nPosNum + nPosIndex];

		}

		vcpTargetPlatformPos.push_back(cpTargetPlatformPos);
	}
	vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
	vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;

	if (GetMidPlatformType()==ePlatformXYPD)
	{
		std::vector<CCoordPos> vcpPreTargetPlatformPos;		// 上一次目标位置旋转后新的目标位置
		if (nAlnIndex == 0)
		{
			vcpPreTargetPlatformPos = vcpAlginedTargetPlatformPos;
		}
		else
		{
			for (int j=0;j<nPosNum;j++)
			{
				CCoordPos pos;
				pos.m_dPosX = m_dTargetX[j];
				pos.m_dPosY = m_dTargetY[j];

				vcpPreTargetPlatformPos.push_back(pos);
			}
		}
		CCoordPos tempplatformOffset;

		// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
		if (!GetAlginOffset(vcpObjectPlatformPos, vcpPreTargetPlatformPos, m_ProductOffsetXYPD, tempplatformOffset, 
			vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
		{
			m_nAlignErrNum = -10;

			str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(失败)");
			AlignToolLogRecord(str,nPlatformIndex);

			return FALSE;
		}

		str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(成功)");
		AlignToolLogRecord(str,nPlatformIndex);
	}

	// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
	if (!GetAlginOffset(vcpObjectPlatformPos, vcpTargetPlatformPos, m_ProductOffset, m_PlatformOffset, 
		vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
	{
		m_nAlignErrNum = -10;

		str.Format("------------------------------------------------------------对位计算结束(失败)");
		AlignToolLogRecord(str,nPlatformIndex);

		return FALSE;
	}


	// 对位偏差量日志记录
	{
		if (GetMidPlatformType()==ePlatformXYPD)
		{
			strTempInfo.Format("产品偏差 X:%f Y:%f D:%f,", GetAlignProductOffsetXYPD().GetPosX(), GetAlignProductOffsetXYPD().GetPosY(), GetAlignProductOffsetXYPD().GetAngle());
			strInfo += strTempInfo;
		}
		else
		{
			strTempInfo.Format("产品偏差 X:%f Y:%f D:%f,", GetAlignProductOffset().GetPosX(), GetAlignProductOffset().GetPosY(), GetAlignProductOffset().GetAngle());
			strInfo += strTempInfo;
		}


		strTempInfo.Format("平台偏差 X:%f Y:%f D:%f,", GetAlignPlatformPosOffset().GetPosX(), GetAlignPlatformPosOffset().GetPosY(), GetAlignPlatformPosOffset().GetAngle());
		strInfo += strTempInfo;
	}

	AlignToolLogRecordProduct(strInfo,nPlatformIndex);

	str.Format("------------------------------------------------------------对位计算结束（成功）\n\n");
	AlignToolLogRecord(str,nPlatformIndex);

	return TRUE;

}

// 目标、对象分离，一组目标相机对应两组对象相机
// BOOL vcBaseAlignTool::ExecuteAlign_Case4(int nAlnIndex/* = 0*/, BOOL bInspect /*= TRUE*/)
// {
// 	m_nAlnIndex = nAlnIndex;
// 	m_nAlignErrNum = 0;
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//1. 加各种保护
// 	// 1.1 判断目标是否定位成功
// 	// 1.2 判断对象是否定位成功
// 
// 	// 对象 0 1   2 3
// 	//      | |   | |
// 	// 目标 4 5   6 7
// 	
// 	//加各种保护
// 	int nMark = m_iMarkNum/2;	// 4
// 	int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;		// 0、2
// 
// 	for (int i = 0; i < m_iMarkNum/4; i++)
// 	{
// 		if (eObjectBench != m_AlignermentParam.GetObjectMarkType() && FALSE == m_ObjectSearchResults.GetIsMarkImagePosOK(i + nExMark))
// 		{
// 			m_nAlignErrNum = -1;
// 			return FALSE;
// 		}
// 
// 		if (eTargetOnline == m_AlignermentParam.GetTargetMarkType() && FALSE == m_TargetSearchResults.GetIsMarkImagePosOK(i + nMark + nExMark))
// 		{
// 			m_nAlignErrNum = -2;
// 			return FALSE;
// 		}
// 
// 	}
// 
// 	int nPlatformIndex = m_nPlatformIndex;
// 	CString str;
// 	str.Format(_T("扩展编号为%d对位计算开始:序号[%d]--------------------------------"),m_nAlignnExProductIndex,nAlnIndex);
// 	AlignToolLogRecord(str,nPlatformIndex);
// 
// 
// 	//目标mark坐标补偿时用到这些参数
// 	CPlatformXYDInfo* pPlatformParam = (CPlatformXYDInfo*)m_pPlatformParam;//平台参数
// 
// 	// 对象轴位置信息
// 	std::vector<CPlatformXYDAxisPos*> pObjectPlatformAxisPos;
// 	int k=0;
// 	for (k=0;k<m_pObjectPlatformAxisPos.size();k++)
// 	{
// 		pObjectPlatformAxisPos.push_back((CPlatformXYDAxisPos*)(m_pObjectPlatformAxisPos.at(k)));//搜索对象mark轴位置
// 	}
// 	
// 	for (k=0;k<m_pObjectPlatformAxisPos.size()/4;k++)
// 	{
// 		str.Format("对象mark%d 轴位置 X=%f,Y=%f,D=%f",k + nExMark,pObjectPlatformAxisPos.at(k + nExMark)->m_dPosX,pObjectPlatformAxisPos.at(k + nExMark)->m_dPosY,pObjectPlatformAxisPos.at(k + nExMark)->m_dAngle);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 	}
// 
// 
// 	// 目标轴位置信息
// 	std::vector<CPlatformXYDAxisPos*> pTargetPlatformAxisPos;
// 	for (k=0;k<m_pTargetPlatformAxisPos.size();k++)
// 	{
// 		pTargetPlatformAxisPos.push_back((CPlatformXYDAxisPos*)m_pTargetPlatformAxisPos.at(k));//搜索目标mark轴位置
// 	}
// 	
// 	for (k=0;k<m_pTargetPlatformAxisPos.size()/4;k++)
// 	{
// 		str.Format("目标mark%d 轴位置 X=%f,Y=%f,D=%f",k + nMark + nExMark,pTargetPlatformAxisPos.at(k + nMark + nExMark)->m_dPosX,pTargetPlatformAxisPos.at(k + nMark + nExMark)->m_dPosY,pTargetPlatformAxisPos.at(k + nMark + nExMark)->m_dAngle);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 	}
// 
// 	std::vector<CCoordPos> vcpObjPlatPos;		// 对象位置
// 	std::vector<CCoordPos> vcpTarPlatPos;		// 目标位置
// 
// 	vcpObjPlatPos.resize(8);
// 	vcpTarPlatPos.resize(8);
// 
// 
// 	m_ObjectMarkPlatformPos = GetSpecialObjectMarkPlatformPos();
// 	
// 
// 	if (eTargetBench != m_AlignermentParam.GetTargetMarkType())
// 	{
// 		m_TargetMarkPlatformPos = GetSpecialTargetMarkPlatformPos();
// 	}
// 
// 	for (int i = 0; i < m_iMarkNum/4; i++)
// 	{
// 		if (FALSE == m_ObjectMarkPlatformPos.GetIsMarkPlatformPosOK(i + nExMark))
// 		{
// 			m_nAlignErrNum = -3;
// 			return FALSE;
// 		}
// 
// 		if (FALSE == m_TargetMarkPlatformPos.GetIsMarkPlatformPosOK(i + nMark + nExMark))
// 		{
// 			m_nAlignErrNum = -4;
// 			return FALSE;
// 		}
// 	}
// 
// 	int i=0;
// 	//读取每个相机对应的对象mark和平台mark的坐标值
// 	for (i=0; i<m_iMarkNum; i++)
// 	{
// 		//记录相机对象mark的坐标
// 		vcpObjPlatPos[i] = m_ObjectMarkPlatformPos.m_vPos[i];
// 
// 		if (m_nAlignnExProductIndex == 0)
// 		{
// 			if (i == 0 || i == 1)
// 			{
// 				str.Format("对象图像坐标%d:ObjectImageX=%f,ObjectImageY=%f,ObjectImageD=%f",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				str.Format("对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 		}
// 		else if (m_nAlignnExProductIndex == 1)
// 		{
// 			if (i == 2 || i == 3)
// 			{
// 				str.Format("对象图像坐标%d:ObjectImageX=%f,ObjectImageY=%f,ObjectImageD=%f",i,m_ObjectSearchResults.m_vPos.at(i).m_dPosX,m_ObjectSearchResults.m_vPos.at(i).m_dPosY,m_ObjectSearchResults.m_vPos.at(i).m_dAngle);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				str.Format("对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 		}
// 
// 		
// 		// $1.2 实时对象为虚拟Mark，则将实时对象Mark的平台坐标值转换为虚拟Mark的平台坐标值
// 		if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
// 		{
// 			if (FALSE == ConvertObjectPltfmPtToVirtualPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_VirtualMarkPlatformPos.m_vPos))
// 				return FALSE;
// 
// 			vcpObjPlatPos[i] = m_VirtualMarkPlatformPos.m_vPos[i];
// 
// 			str.Format("虚拟对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 
// 		if (!m_bInnerAlignBench)
// 		{
// 			// $1.3 对象Mark的全局平台坐标值补偿
// 			//当不需要基准修正时，考虑要不要对对象mark进行补偿
// 
// 			CMarkPlatformPos m_ObjectAddRotationOffsetPos;
// 			m_ObjectAddRotationOffsetPos.m_vPos.resize(m_iMarkNum);
// 			m_ObjectAddRotationOffsetPos.m_vbOK.resize(m_iMarkNum);
// 			CMarkPlatformPos m_ObjectAddMoveOffsetPos;
// 			m_ObjectAddMoveOffsetPos.m_vPos.resize(m_iMarkNum);
// 			m_ObjectAddMoveOffsetPos.m_vbOK.resize(m_iMarkNum);
// 
// 			if (eMarkCoord == m_AlignermentParam.GetAlignerOffsetCoordType())// Mark坐标系下补偿
// 			{
// 				// Mark坐标系下旋转角度进行补偿
// 				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
// 					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
// 				{
// 					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
// 						MarkCoordOffsetRotationObjectPlatformPos(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 					else
// 						MarkCoordOffsetRotationObjectPlatformPos(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 
// 
// 					// Mark坐标系下XY轴平移量进行补偿
// 					MarkCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
// 					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
// 
// 				}
// 			}
// 			else if (eMarkCoordDiagonal == m_AlignermentParam.GetAlignerOffsetCoordType())// 对角Mark坐标系下补偿		//20160510增加对角补偿
// 			{
// 				if ( (m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0) 
// 					|| (m_AlignermentParam.GetProductSizeInfo().m_dTargetL2 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dTargetW2 <= 0) )
// 				{
// 					return FALSE;
// 				}
// 
// 				if ( (m_AlignermentParam.GetPositionModeInfo() < 0) || (m_AlignermentParam.GetPositionModeInfo() > 1) )
// 				{
// 					return FALSE;
// 				}
// 
// 				// 对角Mark坐标系下旋转角度进行补偿
// 				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
// 					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
// 				{
// 					scDegree degRotate1 = scDegree(0);
// 					scDegree degRotate2 = scDegree(m_AlignermentParam.GetAlignerOffset().GetAngle()+m_AlignermentParam.GetAlignerBaseOffset().GetAngle());
// 
// 					// 旋转角度
// 					if (m_AlignermentParam.GetProductOffsetInfo().m_bEnableProductOffsetDDirection)
// 					{
// 						degRotate2 = -degRotate2;
// 					}
// 
// 					if (!AngleOffsetCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
// 						m_AlignermentParam.GetProductSizeInfo().m_dTargetL2, m_AlignermentParam.GetProductSizeInfo().m_dTargetW2,
// 						m_AlignermentParam.GetPositionModeInfo(), degRotate1))
// 					{
// 						return FALSE;
// 					}
// 					scDegree degRotate = degRotate1 + degRotate2;
// 
// 					std::vector<CCoordPos> vObjectPlatformCoordPosDirection;
// 
// 					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
// 					{
// 						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 						vObjectPlatformCoordPosDirection = m_VirtualMarkPlatformPos.m_vPos;
// 					}
// 					else
// 					{
// 						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 						vObjectPlatformCoordPosDirection = m_ObjectMarkPlatformPos.m_vPos;
// 					}
// 
// 					// 对角Mark坐标系下XY轴平移量进行补偿
// 					sc2Vector offsetXY = sc2Vector(m_AlignermentParam.GetAlignerOffset().GetPosX()+m_AlignermentParam.GetAlignerBaseOffset().GetPosX(),	m_AlignermentParam.GetAlignerOffset().GetPosY()+m_AlignermentParam.GetAlignerBaseOffset().GetPosY());
// 
// 					// 方向X
// 					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXDirection)
// 					{
// 						offsetXY = sc2Vector(-offsetXY.GetX(), offsetXY.GetY());
// 					}
// 
// 					// 方向Y
// 					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYDirection)
// 					{
// 						offsetXY = sc2Vector(offsetXY.GetX(), -offsetXY.GetY());
// 					}
// 
// 					// X补偿与Y补偿对调
// 					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXSetting/* || m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYSetting*/)
// 					{
// 						offsetXY = sc2Vector(offsetXY.GetY(), offsetXY.GetX());
// 					}
// 
// 					if (m_AlignermentParam.GetProductSizeInfo().m_bOffsetXYEnable)
// 					{
// 						double dOffsetX = 0, dOffsetY = 0;
// 						if (!XYOffsetCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
// 							m_AlignermentParam.GetProductSizeInfo().m_dTargetL2, m_AlignermentParam.GetProductSizeInfo().m_dTargetW2,
// 							m_AlignermentParam.GetProductSizeInfo().m_dF1, m_AlignermentParam.GetProductSizeInfo().m_dF2,
// 							m_AlignermentParam.GetPositionModeInfo(), dOffsetX, dOffsetY))
// 						{
// 							return FALSE;
// 						}
// 						offsetXY += sc2Vector(dOffsetX, dOffsetY);
// 					}
// 					MarkCoordDiagonalOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, vObjectPlatformCoordPosDirection, offsetXY, m_ObjectAddMoveOffsetPos.m_vPos);
// 					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
// 
// 				}
// 
// 				// 辅助位置
// 				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 				{
// 					return FALSE;
// 				}
// 			}
// 			else if (eMarkCoordDiagonal2 == m_AlignermentParam.GetAlignerOffsetCoordType())// 对角Mark坐标系下补偿		//20160510增加对角补偿
// 			{
// 				if ( (m_AlignermentParam.GetProductSizeInfo().m_dObjectL1 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dObjectW1 <= 0) 
// 					|| (m_AlignermentParam.GetProductSizeInfo().m_dTargetL2 <= 0) || (m_AlignermentParam.GetProductSizeInfo().m_dTargetW2 <= 0) )
// 				{
// 					return FALSE;
// 				}
// 
// 				if ( (m_AlignermentParam.GetPositionModeInfo() < 0) || (m_AlignermentParam.GetPositionModeInfo() > 1) )
// 				{
// 					return FALSE;
// 				}
// 
// 				// 对角Mark坐标系下旋转角度进行补偿
// 				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
// 					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
// 				{
// 					scDegree degRotate1 = scDegree(0);
// 					scDegree degRotate2 = scDegree(m_AlignermentParam.GetAlignerOffset().GetAngle()+m_AlignermentParam.GetAlignerBaseOffset().GetAngle());
// 
// 					// 旋转角度
// 					if (m_AlignermentParam.GetProductOffsetInfo().m_bEnableProductOffsetDDirection)
// 					{
// 						degRotate2 = -degRotate2;
// 					}
// 
// 					if (!AngleOffsetCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
// 						m_AlignermentParam.GetProductSizeInfo().m_dTargetL2, m_AlignermentParam.GetProductSizeInfo().m_dTargetW2,
// 						m_AlignermentParam.GetPositionModeInfo(), degRotate1))
// 					{
// 						return FALSE;
// 					}
// 					scDegree degRotate = degRotate1 + degRotate2;
// 
// 					std::vector<CCoordPos> vObjectPlatformCoordPosDirection;
// 
// 					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
// 					{
// 						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 						vObjectPlatformCoordPosDirection = m_VirtualMarkPlatformPos.m_vPos;
// 						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate2, m_VirtualMarkPlatformPos.m_vPos, vObjectPlatformCoordPosDirection);
// 					}
// 					else
// 					{
// 						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate, m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 						vObjectPlatformCoordPosDirection = m_ObjectMarkPlatformPos.m_vPos;
// 						MarkCoordDiagonalOffsetRotationObjectPlatformPos(degRotate2, m_ObjectMarkPlatformPos.m_vPos, vObjectPlatformCoordPosDirection);
// 					}
// 
// 					// 对角Mark坐标系下XY轴平移量进行补偿
// 					sc2Vector offsetXY = sc2Vector(m_AlignermentParam.GetAlignerOffset().GetPosX()+m_AlignermentParam.GetAlignerBaseOffset().GetPosX(),	m_AlignermentParam.GetAlignerOffset().GetPosY()+m_AlignermentParam.GetAlignerBaseOffset().GetPosY());
// 
// 					// 方向X
// 					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXDirection)
// 					{
// 						offsetXY = sc2Vector(-offsetXY.GetX(), offsetXY.GetY());
// 					}
// 
// 					// 方向Y
// 					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYDirection)
// 					{
// 						offsetXY = sc2Vector(offsetXY.GetX(), -offsetXY.GetY());
// 					}
// 
// 					// X补偿与Y补偿对调
// 					if (m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetXSetting/* || m_AlignermentParam.m_ProductOffsetInfo.m_bEnableProductOffsetYSetting*/)
// 					{
// 						offsetXY = sc2Vector(offsetXY.GetY(), offsetXY.GetX());
// 					}
// 
// 					if (m_AlignermentParam.GetProductSizeInfo().m_bOffsetXYEnable)
// 					{
// 						double dOffsetX = 0, dOffsetY = 0;
// 						if (!XYOffsetCalculate(m_AlignermentParam.GetProductSizeInfo().m_dObjectL1, m_AlignermentParam.GetProductSizeInfo().m_dObjectW1, 
// 							m_AlignermentParam.GetProductSizeInfo().m_dTargetL2, m_AlignermentParam.GetProductSizeInfo().m_dTargetW2,
// 							m_AlignermentParam.GetProductSizeInfo().m_dF1, m_AlignermentParam.GetProductSizeInfo().m_dF2,
// 							m_AlignermentParam.GetPositionModeInfo(), dOffsetX, dOffsetY))
// 						{
// 							return FALSE;
// 						}
// 						offsetXY += sc2Vector(dOffsetX, dOffsetY);
// 					}
// 					MarkCoordDiagonalOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, vObjectPlatformCoordPosDirection, offsetXY, m_ObjectAddMoveOffsetPos.m_vPos);
// 					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
// 
// 				}
// 
// 				// 辅助位置
// 				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1
// 					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 				{
// 					return FALSE;
// 				}
// 			}
// 			else if (eMarkPlatformCoord == m_AlignermentParam.GetAlignerOffsetCoordType())// Mark平台混合坐标系下补偿
// 			{
// 				// 全局平台坐标系下旋转角度进行补偿
// 				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
// 					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
// 				{			
// 					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
// 						MarkCoordOffsetRotationObjectPlatformPos(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 					else
// 						MarkCoordOffsetRotationObjectPlatformPos(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 
// 					// 全局平台坐标系下XY轴平移量进行补偿
// 					PltfmCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
// 					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
// 
// 				}
// 			}
// 			else// 平台坐标系下补偿
// 			{
// 				// 全局平台坐标系下旋转角度进行补偿
// 				if (m_AlignermentParam.GetAlignerBaseOffset().GetAngle()||m_AlignermentParam.GetAlignerBaseOffset().GetPosX()||m_AlignermentParam.GetAlignerBaseOffset().GetPosY()
// 					|| m_AlignermentParam.GetAlignerOffset().GetAngle()||m_AlignermentParam.GetAlignerOffset().GetPosX()||m_AlignermentParam.GetAlignerOffset().GetPosY())
// 				{					
// 					if (TRUE == m_AlignermentParam.GetVirtualObjectMarkEnable())
// 						PltfmCoordOffsetRotationObjectPltfmPt(m_VirtualMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 					else
// 						PltfmCoordOffsetRotationObjectPltfmPt(m_ObjectMarkPlatformPos.m_vPos, m_ObjectAddRotationOffsetPos.m_vPos);
// 
// 					PltfmCoordOffsetXYObjectPltfmPt(m_ObjectAddRotationOffsetPos.m_vPos, m_ObjectAddMoveOffsetPos.m_vPos);
// 					vcpObjPlatPos[i] = m_ObjectAddMoveOffsetPos.m_vPos[i];
// 
// 				}
// 			}
// 
// 			if (m_nAlignnExProductIndex == 0)
// 			{
// 				if (i == 0 || i == 1)
// 				{
// 					str.Format("补偿后对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 				}
// 			}
// 			else if (m_nAlignnExProductIndex == 1)
// 			{
// 				if (i == 2 || i == 3)
// 				{
// 					str.Format("补偿后对象平台坐标%d:ObjectX=%f,ObjectY=%f,ObjectD=%f",i,vcpObjPlatPos[i].GetPosX(),vcpObjPlatPos[i].GetPosY(),vcpObjPlatPos[i].GetAngle());
// 					AlignToolLogRecord(str,nPlatformIndex);
// 				}
// 			}
// 
// 		}
// 
// 	}// for
// 
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//8. 对目标平台坐标进行修正
// 	// 8.1 
// 
// 	//读取每个相机对应的对象mark和平台mark的坐标值
// 	for (i=0; i<m_iMarkNum; i++)
// 	{
// 		// $2、实时目标Mark的图像坐标值转化为平台坐标值
// 		// 目标Mark为基准Mark
// 		if (eTargetBench == m_AlignermentParam.GetTargetMarkType())
// 		{	
// 		
// 			//如果没有进行基准修正，则使用标定后的基准mark平台坐标
// 			if (FALSE == m_AlignermentParam.GetBenchTargetMarkFixEnable())
// 			{
// 				CPlatformXYDAxisPos* pBenchPlatformAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(0)->GetPlatformAxisPos());//标定基准轴位置
// 
// 				vcpTarPlatPos[i] = m_vAlignerCalibInfos.at(i)->m_cpMarkPlatformCoordPos;
// 
// 				pTargetPlatformAxisPos.at(i) = pBenchPlatformAxisPos;
// 			}
// 			else//进行基准修正，使用修正后的基准坐标
// 			{
// 				CPlatformXYDAxisPos* pBenchFixPlatformAxisPos = (CPlatformXYDAxisPos*)(m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetFixPlatformPos(i));//基准修正时轴位置
// 				
// 				vcpTarPlatPos[i] = m_AlignermentParam.GetBenchTargetMarkFixInfo()->GetMarkPlatformCoordPos(i);
// 
// 				pTargetPlatformAxisPos.at(i) = pBenchFixPlatformAxisPos;
// 			}
// 		}
// 		else//目标mark为实时mark
// 		{
// 
// 			//记录相机目标mark的坐标
// 			vcpTarPlatPos[i] = m_TargetMarkPlatformPos.m_vPos[i];
// 
// 		}
// 
// 
// 		if (m_nAlignnExProductIndex == 0)
// 		{
// 			if (i == 4 || i == 5)
// 			{
// 				str.Format("目标图像坐标%d:TargetImageX=%f,TargetImageY=%f,TargetImageD=%f",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				str.Format("目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 		}
// 		else if (m_nAlignnExProductIndex == 1)
// 		{
// 			if (i == 6 || i == 7)
// 			{
// 				str.Format("目标图像坐标%d:TargetImageX=%f,TargetImageY=%f,TargetImageD=%f",i,m_TargetSearchResults.m_vPos.at(i).m_dPosX,m_TargetSearchResults.m_vPos.at(i).m_dPosY,m_TargetSearchResults.m_vPos.at(i).m_dAngle);
// 				AlignToolLogRecord(str,nPlatformIndex);
// 
// 				str.Format("目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 		}
// 
// 		// $3、对目标Mark的平台坐标值进行修正(平台XY轴移动影响影响结果)
// 		double dPlatformOffsetX = 0;
// 		double dPlatformOffsetY = 0;
// 		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
// 		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;
// 
// 
// 		
// 		// 对于XYD平台，XY轴运动均会对平台中心产生影响，从而影响目标Mark的平台坐标值。
// 		if (eTargetMoveByPlatform == m_eAlignerTargetMoveType)//判断条件？
// 		{
// 			dPlatformOffsetX = pObjectPlatformAxisPos.at(i)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// 			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 			dPlatformOffsetY = pObjectPlatformAxisPos.at(i)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// 			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// 
// 		}
// 		else
// 		{
// 			dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// 			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 			dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// 			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// 
// 			if (m_bPlatformTarCamWithDiffObjCam)
// 			{
// 				if (m_nAlignnExProductIndex == 0)
// 				{
// 					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// 					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/4-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// 					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// 				}
// 				else if (m_nAlignnExProductIndex == 1)
// 				{
// 					dPlatformOffsetX = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosX - pTargetPlatformAxisPos.at(i)->m_dPosX;
// 					if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;
// 					dPlatformOffsetY = pObjectPlatformAxisPos.at(pObjectPlatformAxisPos.size()/2-1)->m_dPosY - pTargetPlatformAxisPos.at(i)->m_dPosY;
// 					if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
// 				}
// 				else
// 				{
// 					str.Format("计算修正后目标平台坐标补偿序号错误");
// 					AlignToolLogRecord(str,nPlatformIndex);
// 
// 					return FALSE;
// 				}
// 
// 			}
// 
// 		}
// 
// 		if (GetMidPlatformType()==ePlatformXYPD)
// 		{
// 			 dPlatformOffsetX = 0;
// 			 dPlatformOffsetY = 0;
// 
// 		}
// 		else if (GetMidPlatformType()==ePlatformXY)
// 		{
// 			dPlatformOffsetX = 0;
// 			dPlatformOffsetY = 0;
// 		}
// 		
// 		vcpTarPlatPos[i].Offset(-dPlatformOffsetX, -dPlatformOffsetY);
// 
// 
// 		if (m_nAlignnExProductIndex == 0)
// 		{
// 			if (i == 4 || i == 5)
// 			{
// 				str.Format("平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 		}
// 		else if (m_nAlignnExProductIndex == 1)
// 		{
// 			if (i == 6 || i == 7)
// 			{
// 				str.Format("平台轴运动修正后目标平台坐标%d:TargetX=%f,TargetY=%f,TargetD=%f",i,vcpTarPlatPos[i].GetPosX(),vcpTarPlatPos[i].GetPosY(),vcpTarPlatPos[i].GetAngle());
// 				AlignToolLogRecord(str,nPlatformIndex);
// 			}
// 		}
// 
// 	}// for
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//11. 补偿目标位置信息
// 	// 11.1 非内部对位情况下，启用目标补偿（平台坐标系）
// 
// 	if (m_AlignermentParam.m_bCheckAlnTargetOffsetEnable && !m_bInnerAlignBench)
// 	{
// 		if (m_AlignermentParam.m_dAlnTargetOffsetX!=0 || m_AlignermentParam.m_dAlnTargetOffsetY!=0 )
// 		{
// 			for(int k=0;k<m_iMarkNum;k++)
// 			{
// 				vcpTarPlatPos[k].Offset(-m_AlignermentParam.m_dAlnTargetOffsetX, -m_AlignermentParam.m_dAlnTargetOffsetY);
// 			}
// 		}
// 	}
// 
// 
// 	// $4、目标Mark与对象Mark在平台坐标下进行对位，计算旋转角度及XY轴偏移量
// 	if (m_bTargetObjectCamSeparate)
// 	{
// 		m_PlatformOffset.m_dPosX  = 0;		
// 		m_PlatformOffset.m_dPosY  = 0;
// 		m_PlatformOffset.m_dAngle = 0;
// 
// 		m_ProductOffset.m_dPosX  = 0;		
// 		m_ProductOffset.m_dPosY  = 0;
// 		m_ProductOffset.m_dAngle = 0;
// 
// 		int nPosNum = m_iMarkNum/2;							// 实际对位的位置数量
// 		std::vector<CCoordPos> vcpObjectPlatformPos;		// 对象位置
// 		std::vector<CCoordPos> vcpTargetPlatformPos;		// 目标位置
// 		std::vector<CCoordPos> vcpAlginedObjectPlatformPos; // 对位后对象位置
// 		std::vector<CCoordPos> vcpAlginedTargetPlatformPos; // 对位后目标位置
// 		for (int nPosIndex = 0; nPosIndex < nPosNum; nPosIndex++)
// 		{
// 			// 对象位置
//  			CCoordPos cpObjectPlatformPos;
// 
// 			cpObjectPlatformPos = vcpObjPlatPos[nPosIndex];
// 
// 			vcpObjectPlatformPos.push_back(cpObjectPlatformPos);
// 
// 
// 			// 目标位置
// 			CCoordPos cpTargetPlatformPos;
// 			if (m_bInnerAlignBench)
// 			{	
// 				cpTargetPlatformPos = vcpTarPlatPos[nPosIndex];
// 			}
// 			else
// 			{
// 				cpTargetPlatformPos = vcpTarPlatPos[nPosNum + nPosIndex];
// 			}
// 
// 			vcpTargetPlatformPos.push_back(cpTargetPlatformPos);
// 		}
// 		vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
// 		vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;
// 		
// 		if (GetMidPlatformType()==ePlatformXYPD)
// 		{
// 			std::vector<CCoordPos> vcpPreTargetPlatformPos;		// 上一次目标位置旋转后新的目标位置
// 			if (nAlnIndex == 0)
// 			{
// 				vcpPreTargetPlatformPos = vcpAlginedTargetPlatformPos;
// 			}
// 			else
// 			{
// 				for (int j=0;j<nPosNum;j++)
// 				{
// 					CCoordPos pos;
// 					pos.m_dPosX = m_dTargetX[j];
// 					pos.m_dPosY = m_dTargetY[j];
// 
// 					vcpPreTargetPlatformPos.push_back(pos);
// 				}
// 			}
// 			CCoordPos tempplatformOffset;
// 
// 			// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
// 			if (!GetAlginOffset(vcpObjectPlatformPos, vcpPreTargetPlatformPos, m_ProductOffsetXYPD, tempplatformOffset, 
// 				vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
// 			{
// 				str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(失败)");
// 				AlignToolLogRecord(str,nPlatformIndex);
// 				return FALSE;
// 			}
// 
// 			str.Format("------------------------------------------------------------XYPD计算与上次目标产品旋转后新的目标产品偏差结束(成功)");
// 			AlignToolLogRecord(str,nPlatformIndex);
// 		}
// 
// 		// 计算产品旋转角度及XY轴偏移量、平台旋转角度及XY轴偏移量
// 		if (!GetAlginOffset(vcpObjectPlatformPos, vcpTargetPlatformPos, m_ProductOffset, m_PlatformOffset, 
// 			vcpAlginedObjectPlatformPos, vcpAlginedTargetPlatformPos))
// 		{
// 			str.Format(_T("------------------------------------扩展编号为%d对位计算结束(失败)"),m_nAlignnExProductIndex);
// 			AlignToolLogRecord(str,nPlatformIndex);
// 
// 			m_nAlignErrNum = -5;
// 			return FALSE;
// 		}
// 
// 		str.Format(_T("------------------------------------扩展编号为%d对位计算结束(成功)\n\n"),m_nAlignnExProductIndex);
// 		AlignToolLogRecord(str,nPlatformIndex);
// 
// 		return TRUE;
// 	}
// 
// 	return FALSE;
// }


// 高低平面对位
BOOL vcBaseAlignTool::ExecuteAlign_Case5(int nAlnIndex/* = 0*/, BOOL bInspect /*= TRUE*/)
{
	return FALSE;
}

// 八字对位
BOOL vcBaseAlignTool::ExecuteAlign_Case6(int nAlnIndex/* = 0*/, BOOL bInspect /*= TRUE*/)
{
	return FALSE;
}




// 将图像坐标值转换为当前平台坐标值
// 1. 参数1：平台坐标；参数2：索引；参数3：图像坐标；
bool vcBaseAlignTool::ConvertImagePosToCurPlatformPos(CCoordPos& platformCoordPos, int nIndex, CCoordPos imageCoordPos)
{
	if (nIndex<0 || nIndex >= m_iMarkNum*(m_nMultiCalibExtensionMaxNum+1))
		return false;
	if (NULL == m_vAlignerCalibInfos.at(nIndex))
		return false;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
		{
			return false;
		}
	}

	//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
	//相机平台类型没有基类，不用改；
	CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetPlatformAxisPos());
	CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 

	if (NULL == pPlatformBenchAxisPos   || NULL == pPlatformParam)
	{
		return false;
	}

	// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
	//标定参数
	double dTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,0);
	double dTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,1);
	double dTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,0);
	double dTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,1);

	double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosX();
	double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosY();
	//平台各轴的方向	
	int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
	int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

	// 实际平台XY轴偏移量
	// 	double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
	// 	double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;
	// 
	// 	if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
	// 	if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
	// 
	// 	//平台XY平移量对基准mark平台坐标的影响方向相反
	// 	dPlatformBenchMarkX -= dPlatformOffsetX;
	// 	dPlatformBenchMarkY -= dPlatformOffsetY;

	// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
	double dImgOffsetRealDistanceX = 0;
	double dImgOffsetRealDistanceY = 0;
	double dImgOffsetX = imageCoordPos.m_dPosX - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX;
	double dImgOffsetY = imageCoordPos.m_dPosY - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY;
	dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
	dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

	if (m_PlatformCalibType == ePlatformCalib9Point)
	{
		sc2Vector vSrc;
		sc2Vector vDst;
		vSrc.SetX(dImgOffsetX);
		vSrc.SetY(dImgOffsetY);
		vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
		dImgOffsetRealDistanceX = vDst.GetX();
		dImgOffsetRealDistanceY = vDst.GetY();
	}



	// $4、内容相加，即为相机实时Mark的平台坐标值
	platformCoordPos.m_dPosX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
	platformCoordPos.m_dPosY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
	//mark为线时，平台mark线的角度为图像线的角度+图像平台坐标之间的夹角；
	platformCoordPos.m_dAngle = imageCoordPos.GetAngle() + 	m_vAlignerCalibInfos.at(nIndex)->m_dImageToPlatformAnlge;

	return true;
}

// 2. 参数1：平台坐标；参数2：索引；参数3：图像坐标；
//	  参数4：实时轴位置；
bool vcBaseAlignTool::ConvertImagePosToCurPlatformPos(CCoordPos& platformCoordPos, int nIndex, CCoordPos imageCoordPos, 
	CPlatformAxisPos* pPlatformAxisPos)
{
	return ConvertImagePosToCurPlatformPosCommon(platformCoordPos, nIndex, imageCoordPos, pPlatformAxisPos);
}

// 3. 参数1：平台坐标；参数2：索引；参数3：图像坐标；
//    参数4：实时轴位置；参数5：相机轴位置；
bool vcBaseAlignTool::ConvertImagePosToCurPlatformPos(CCoordPos& platformCoordPos, int nIndex, CCoordPos imageCoordPos, 
	CPlatformAxisPos* pPlatformAxisPos, CPlatformAxisPos* pCamPlatformAxisPos)
{
	return ConvertImagePosToCurPlatformPosCommon(platformCoordPos, nIndex, imageCoordPos, pPlatformAxisPos, pCamPlatformAxisPos);
}

// 4. 参数1：平台坐标；参数2：索引；参数3：图像坐标；
//    参数4：平台轴位置；参数5：相机轴位置；参数6：相机轴位置
bool vcBaseAlignTool::ConvertImagePosToCurPlatformPos(CCoordPos& platformCoordPos, int nIndex, CCoordPos imageCoordPos, 
	CPlatformAxisPos* pPlatformAxisPos, CPlatformAxisPos* pCamPlatformAxisPos,CPlatformAxisPos* pCamAxisPlatformAxisPos)
{
	return ConvertImagePosToCurPlatformPosCommon(platformCoordPos, nIndex, imageCoordPos, pPlatformAxisPos, pCamPlatformAxisPos, pCamAxisPlatformAxisPos);
}



// 6. 将图像坐标值转换为当前平台坐标值
// (1).将CCoordPos类型图像坐标值(基础点、辅助点)转换为vector<CCoordPos>类型，
// (2).然后vector<CCoordPos>类型图像坐标值转换为vector<CCoordPos>类型当前平台坐标值,
// (3).最后将vector<CCoordPos>类型当前平台坐标值转换为CCoordPos类型当前平台坐标值
// (4).备注，当不需要相机轴、相机轴所在轴时，可不输入当前相机轴位置和相机轴所在轴位置，函数内部根据相机平台类型进行判断。
bool vcBaseAlignTool::ConvertImagePosToCurPlatformPosCommon(CCoordPos& platformCoordPos, int nIndex, CCoordPos imageCoordPos, 
	CPlatformAxisPos* pPlatformAxisPos, CPlatformAxisPos* pCamPlatformAxisPos/* = NULL*/,CPlatformAxisPos* pCamAxisPlatformAxisPos/* = NULL*/)
{
	int nRemIndex = nIndex%m_iMarkNum;
	int nExProductIndex = nIndex/m_iMarkNum;
	if (NULL == m_vpCalibrateParam.at(nRemIndex))
		return false;

	if(m_vpCalibrateParam.at(nRemIndex)->m_nEnableDisCor)
	{
		CString strOut, strTmp;
		strOut.Format(_T("畸变矫正开始："));
		AlignToolLogRecord(strOut,m_nPlatformIndex);
		
		double p[15];
		memset(p, 0.0, sizeof(double)*15);
		scCalibrateResult result = m_vAlignerCalibInfos.at(nIndex)->m_result;
		result.GetNonlinearProjectResult(p);
		double dRms = result.GetRMS();
		strOut.Format("畸变参数: ");
		for (int i=0;i<15; i++)
		{
			strTmp.Format(_T("P%d:%.6f "), i, p[i]);
			strOut += strTmp;
		}
		strTmp.Format(_T("P15:%.6f "),dRms);
		strOut += strTmp;
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		strOut.Format("畸变校正前图像坐标: ");
		strTmp.Format(_T("Pos(%.6f, %.6f, %.6f) "), imageCoordPos.m_dPosX, imageCoordPos.m_dPosY, imageCoordPos.m_dAngle);
		strOut += strTmp;
		for (int i=0; i<imageCoordPos.m_vdAuxiliaryPosX.size(); i++)
		{
			strTmp.Format(_T("AuxiliaryPos%d(%.6f, %.6f, %.6f) "), i, imageCoordPos.m_vdAuxiliaryPosX.at(i), imageCoordPos.m_vdAuxiliaryPosY.at(i), imageCoordPos.m_vdAuxiliaryAngle.at(i));
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		CCoordPos imageDisCorPos;
		ExecuteDisCorPoint(nIndex, imageCoordPos, imageDisCorPos);
		imageCoordPos = imageDisCorPos;

		strOut.Format("畸变校正后图像坐标: ");
		strTmp.Format(_T("Pos(%.6f, %.6f, %.6f) "), imageCoordPos.m_dPosX, imageCoordPos.m_dPosY, imageCoordPos.m_dAngle);
		strOut += strTmp;
		for (int i=0; i<imageCoordPos.m_vdAuxiliaryPosX.size(); i++)
		{
			strTmp.Format(_T("AuxiliaryPos%d(%.6f, %.6f, %.6f) "), i, imageCoordPos.m_vdAuxiliaryPosX.at(i), imageCoordPos.m_vdAuxiliaryPosY.at(i), imageCoordPos.m_vdAuxiliaryAngle.at(i));
			strOut += strTmp;
		}
		AlignToolLogRecord(strOut,m_nPlatformIndex);

		strOut.Format(_T("畸变矫正结束："));
		AlignToolLogRecord(strOut,m_nPlatformIndex);
	}

	CString str;
	str.Format("图像坐标转平台坐标开始, MarkNum: %d, PosIndex：%d", m_iMarkNum, nIndex);
	AlignToolLogRecord(str,m_nPlatformIndex);

	std::vector<CCoordPos> vPlatformCoordPos;	// 平台坐标数组
	std::vector<CCoordPos> vImageCoordPos;		// 图像坐标数组 

	// 图像坐标imageCoordPos主、辅点，转换为图像坐标数组vImageCoordPos 
	vImageCoordPos.push_back(imageCoordPos);
	int nAuxIndex = 0;
	for (nAuxIndex = 0; nAuxIndex < imageCoordPos.m_vdAuxiliaryPosX.size(); nAuxIndex++)
	{
		CCoordPos pos;
		pos.SetPosAngle(imageCoordPos.GetAuxPos(nAuxIndex), imageCoordPos.GetAngle());
		vImageCoordPos.push_back(pos);
	}

	// 根据图像坐标数组vImageCoordPos，获取平台坐标数组vPlatformCoordPos；
	BOOL bSuccess = TRUE;
	int nPtIndex = 0;
	vPlatformCoordPos.resize(vImageCoordPos.size());
	BOOL bLogRecordEnable = m_bLogRecordEnable;			// 临时记录是否存储日志变量
	for(nPtIndex = 0; nPtIndex < vImageCoordPos.size(); nPtIndex++)
	{
		if (nPtIndex > 0)
		{
			// 辅助点，暂时不存储图像坐标转换详细信息，因为太多了
			if (bLogRecordEnable)
			{
				m_bLogRecordEnable = FALSE;
			}
		}

		bSuccess = bSuccess && ConvertImagePosToCurPlatformPosMainPos(vPlatformCoordPos.at(nPtIndex), nIndex, vImageCoordPos.at(nPtIndex),
			pPlatformAxisPos, pCamPlatformAxisPos, pCamAxisPlatformAxisPos);

		if (nPtIndex > 0)
		{
			// 辅助点，暂时不存储图像坐标转换详细信息，因为太多了
			if (bLogRecordEnable)
			{
				m_bLogRecordEnable = TRUE;
			}
		}

		CCoordPos imgPos = vImageCoordPos.at(nPtIndex);
		CCoordPos platPos = vPlatformCoordPos.at(nPtIndex);
		if (nPtIndex == 0)
		{
			str.Format("PosIndex：%d, 基础点: %d, 图像坐标: X: %f, Y: %f, D: %f", nIndex, nPtIndex, imgPos.GetPosX(), imgPos.GetPosY(), imgPos.GetAngle());
			AlignToolLogRecord(str,m_nPlatformIndex);

			str.Format("PosIndex：%d, 基础点: %d, 平台坐标: X: %f, Y: %f, D: %f", nIndex, nPtIndex, platPos.GetPosX(), platPos.GetPosY(), platPos.GetAngle());
			AlignToolLogRecord(str,m_nPlatformIndex);
		}
		else
		{		
			str.Format("PosIndex：%d, 辅助点: %d, 图像坐标: X: %f, Y: %f, D: %f", nIndex, nPtIndex-1, imgPos.GetPosX(), imgPos.GetPosY(), imgPos.GetAngle());
			AlignToolLogRecord(str,m_nPlatformIndex);

			str.Format("PosIndex：%d, 辅助点: %d, 平台坐标: X: %f, Y: %f, D: %f", nIndex, nPtIndex-1, platPos.GetPosX(), platPos.GetPosY(), platPos.GetAngle());
			AlignToolLogRecord(str,m_nPlatformIndex);
		}
	}

	m_bLogRecordEnable = bLogRecordEnable;

	if(!bSuccess)
	{
		str.Format("图像坐标转平台坐标完成：NG");
		AlignToolLogRecord(str,m_nPlatformIndex);
		return false;
	}

	// 将平台坐标数组vPlatformCoordPos，转换为平台坐标platformCoordPos主、辅点；
	platformCoordPos = vPlatformCoordPos.at(0);
	for(nAuxIndex = 0; nAuxIndex < (vPlatformCoordPos.size()-1) && nAuxIndex < platformCoordPos.m_vdAuxiliaryPosX.size(); nAuxIndex++)
	{
		platformCoordPos.SetAuxPosAngle(nAuxIndex, vPlatformCoordPos.at(nAuxIndex+1).GetPos(), vPlatformCoordPos.at(nAuxIndex+1).GetAngle());
	}	

	str.Format("图像坐标转平台坐标完成：OK");
	AlignToolLogRecord(str,m_nPlatformIndex);

	return bSuccess;
}


// 7. 将图像坐标值转换为当前平台坐标值的实体函数，只针对基础点进行转换
// 备注，当不需要相机轴、相机轴所在轴时，可不输入当前相机轴位置和相机轴所在轴位置，函数内部根据相机平台类型进行判断。
bool vcBaseAlignTool::ConvertImagePosToCurPlatformPosMainPos(CCoordPos& platformCoordPos, int nIndex, CCoordPos imageCoordPos, 
	CPlatformAxisPos* pPlatformAxisPos, CPlatformAxisPos* pCamPlatformAxisPos/* = NULL*/,CPlatformAxisPos* pCamAxisPlatformAxisPos/* = NULL*/)
{
	int nRemIndex = nIndex%m_iMarkNum;
	int nExProductIndex = nIndex/m_iMarkNum;
	if (NULL == m_vpCalibrateParam.at(nRemIndex))
	{
		return false;
	}
		

	if (m_bTargetObjectCamSeparate == TRUE && m_bTarObjCamSepNoAxisCalib == TRUE
		&&((GetMidPlatformType() != ePlatformXYPD && nIndex%m_iMarkNum >= m_iMarkNum/2)||(GetMidPlatformType() == ePlatformXYPD && nIndex%m_iMarkNum < m_iMarkNum/2))
		&& !m_bTargetCalibUseBoard
		)
	{
		int nPlatformIndex = m_nPlatformIndex;
		CString str;


		// 如果是相机分离的，且标定目标（或XY+D平台对象）位置时不用平台轴位置，而是直接将目标相机与对象相机映射的情况
		// 转换图像坐标到平台坐标

		int nBaseIndex = nIndex - m_iMarkNum/2;
		if (GetMidPlatformType() == ePlatformXYPD)
		{
			// 当平台为XY+D平台时，对象图像坐标转换到目标平台坐标系下
			// 例如：4相机2Vs2时，对象位置0、位置1转换到目标位置2、位置3的平台坐标系下，即基础的索引为2、3
			nBaseIndex = nIndex + m_iMarkNum/2;
		}
		else
		{
			// 当平台是XYD平台等（不是XY+D平台）时，目标图像坐标转换到对象平台坐标系下，
			// 例如：4相机2Vs2时，目标位置2、位置3转换到对象位置0、位置1的平台坐标系下，即基础的索引为0、1
			nBaseIndex = nIndex - m_iMarkNum/2;
		}

		if (nIndex<0 || nIndex >= m_iMarkNum*(m_nMultiCalibExtensionMaxNum+1))
			return false;

		if (nIndex >= m_vAlignerCalibInfos.size())
		{
			return false;
		}

		if (nBaseIndex >= m_vAlignerCalibInfos.size())
		{
			return false;
		}

		if (NULL == m_vAlignerCalibInfos.at(nIndex))
		{
			return false;
		}

		if (NULL == m_vAlignerCalibInfos.at(nBaseIndex))
		{
			return false;
		}

		if (m_PlatformCalibType == ePlatformCalib9Point)
		{
			if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
			{
				return false;
			}
			if (!m_vAlignerCalibInfos.at(nBaseIndex)->IsValid())
			{
				return false;
			}
		}

		//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
		//相机平台类型没有基类，不用改；
		CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nBaseIndex)->GetPlatformAxisPos());
		CPlatformXYDAxisPos*  pPlatformXYDAxisPos =		 (CPlatformXYDAxisPos*)pPlatformAxisPos;
		CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 

		if (NULL == pPlatformBenchAxisPos || NULL == pPlatformXYDAxisPos  || NULL == pPlatformParam)
		{
			return false;
		}

		str.Format("平台轴基准坐标： X = %f , Y = %f , D = %f ",pPlatformBenchAxisPos->m_dPosX,pPlatformBenchAxisPos->m_dPosY,pPlatformBenchAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("平台当前轴坐标： X = %f , Y = %f , D = %f",pPlatformXYDAxisPos->m_dPosX,pPlatformXYDAxisPos->m_dPosY,pPlatformXYDAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);


		// 将目标相机的图像坐标转换为对象相机的图像坐标
		sc2Vector vSrcTarget;
		sc2Vector vDstObject;
		vSrcTarget.SetX(imageCoordPos.m_dPosX);
		vSrcTarget.SetY(imageCoordPos.m_dPosY);
		vDstObject = sfHomographyProject(vSrcTarget,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
		CCoordPos imageDstObjectCoordPos;
		imageDstObjectCoordPos.m_dPosX = vDstObject.GetX();
		imageDstObjectCoordPos.m_dPosY = vDstObject.GetY();

		// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
		//标定参数
		double dTranferA11 = m_vAlignerCalibInfos.at(nBaseIndex)->GetPlatformTransferMatrix().GetElement(0,0);
		double dTranferA12 = m_vAlignerCalibInfos.at(nBaseIndex)->GetPlatformTransferMatrix().GetElement(0,1);
		double dTranferA21 = m_vAlignerCalibInfos.at(nBaseIndex)->GetPlatformTransferMatrix().GetElement(1,0);
		double dTranferA22 = m_vAlignerCalibInfos.at(nBaseIndex)->GetPlatformTransferMatrix().GetElement(1,1);

		double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkPlatformCoordPos().GetPosX();
		double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkPlatformCoordPos().GetPosY();

		str.Format("Mark平台基准位置：X = %f , Y = %f ",dPlatformBenchMarkX,dPlatformBenchMarkY);
		AlignToolLogRecord(str,nPlatformIndex);

		//平台各轴的方向	
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

		// 实际平台XY轴偏移量
		double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
		double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;


		if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
		if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
		if ( GetMidPlatformType() ==ePlatformXDPY || GetMidPlatformType() ==ePlatformXDPY1)
		{
			dPlatformOffsetY =0 ;
		}
		else if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
		{

		}
		else if ( GetMidPlatformType() ==ePlatformXYPD)
		{
			dPlatformOffsetX =0 ;
			dPlatformOffsetY =0 ;
		}

		str.Format("轴平移量： X = %f , Y = %f ",dPlatformOffsetX,dPlatformOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);


		//平台XY平移量对基准mark平台坐标的影响方向相反
		dPlatformBenchMarkX -= dPlatformOffsetX;
		dPlatformBenchMarkY -= dPlatformOffsetY;

		// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
		double dImgOffsetRealDistanceX = 0;
		double dImgOffsetRealDistanceY = 0;
		double dImgOffsetX = imageDstObjectCoordPos.m_dPosX - m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosX;
		double dImgOffsetY = imageDstObjectCoordPos.m_dPosY - m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosY;
		dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
		dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

		str.Format("基准图像位置： X = %f , Y = %f ",m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosX,m_vAlignerCalibInfos.at(nBaseIndex)->GetMarkImgCoordPos().m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("当前图像位置： X = %f , Y = %f ",imageCoordPos.m_dPosX,imageCoordPos.m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("映射后当前图像位置： X = %f , Y = %f ",imageDstObjectCoordPos.m_dPosX,imageDstObjectCoordPos.m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("图像像素移动量： X = %f , Y = %f ",dImgOffsetX,dImgOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		{
			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vSrc.SetX(dImgOffsetX);
				vSrc.SetY(dImgOffsetY);
				if (m_vpCalibrateParam.at(nBaseIndex%m_iMarkNum)->GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
				{
					sc2Vector vBoard;
					vBoard = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nBaseIndex)->m_PlatformTranferH1);
					vDst = sfHomographyProject(vBoard,m_vAlignerCalibInfos.at(nBaseIndex)->m_PlatformTranferH2);
				}
				else
				{
					vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nBaseIndex)->m_PlatformTranferH);
				}		
				dImgOffsetRealDistanceX = vDst.GetX();
				dImgOffsetRealDistanceY = vDst.GetY();
			}
		}

		str.Format("图像像素平台移动量： X = %f , Y = %f ",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
		AlignToolLogRecord(str,nPlatformIndex);


		// $4、内容相加，即为相机实时Mark的平台坐标值
		platformCoordPos.m_dPosX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
		platformCoordPos.m_dPosY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
		//mark为线时，平台mark线的角度为图像线的角度+图像平台坐标之间的夹角；
		platformCoordPos.m_dAngle = imageCoordPos.GetAngle() + 	m_vAlignerCalibInfos.at(nIndex)->m_dImageToPlatformAnlge;
	
		
		// $3、根据相机安装方式，计算由相机运动量对实时Mark在平台坐标系中的位置的影响
		if (eCamPlatformSepXY == m_pCamPlatformInfo->GetCamPlatformType() 
			|| eCamPlatformSepX == m_pCamPlatformInfo->GetCamPlatformType()
			|| eCamPlatformShareX == m_pCamPlatformInfo->GetCamPlatformType())
		{
			// $3、根据相机安装方式，计算由相机运动量对实时Mark在平台坐标系中的位置的影响
			
			// 相机轴
			CPlatformXYAxisPos*   pCamPlatformBenchAxisPos = (CPlatformXYAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformAxisPos());
			CPlatformXYAxisPos*   pCamPlatformXYAxisPos =	 (CPlatformXYAxisPos*)pCamPlatformAxisPos;

			// 相机轴所在轴
			CPlatformXYAxisPos*	  pCamAxisPlatformBenchAxisPos = (CPlatformXYAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetCamAxisPlatformAxisPos());
			CPlatformXYAxisPos*   pCamAxisPlatformXYAxisPos = (CPlatformXYAxisPos*)pCamAxisPlatformAxisPos;

			double dCameraMovementX = 0;				// 相机轴运动量X
			double dCameraMovementY = 0;				// 相机轴运动量Y
			double dCameraOffsetRealDistanceX = 0;		// 相机轴运动量对实时Mark在平台坐标系中的位置的影响X
			double dCameraOffsetRealDistanceY = 0;		// 相机轴运动量对实时Mark在平台坐标系中的位置的影响Y

			double dCamAxisPlatformAxisMovementX = 0;	// 相机轴所在轴运动量X
			double dCamAxisPlatformAxisMovementY = 0;	// 相机轴所在轴运动量Y

			// 相机轴运动量对实时Mark在平台坐标系中的位置的影响
			if (NULL != pCamPlatformBenchAxisPos && NULL != pCamPlatformXYAxisPos)
			{
				str.Format("相机轴基准坐标： X = %f , Y = %f ",pCamPlatformBenchAxisPos->m_dPosX,pCamPlatformBenchAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("当前相机轴坐标： X = %f , Y = %f ",pCamPlatformXYAxisPos->m_dPosX,pCamPlatformXYAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);

				int iCamPlatformXCoordType = m_pCamPlatformInfo->GetCamDirectX(nIndex%m_iMarkNum);
				int iCamPlatformYCoordType = m_pCamPlatformInfo->GetCamDirectY(nIndex%m_iMarkNum);


				// 0为固定安装，1为安装在平台X轴上，2为安装在独立的XY轴上，3为安装在单独的X轴上
				int iCameraFixType = m_pCamPlatformInfo->GetCamPlatformType();
				if (eCamPlatformSepFix == iCameraFixType)
				{
					dCameraMovementX = 0;
					dCameraMovementY = 0;

					str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					dCameraOffsetRealDistanceX = dCameraMovementX ;
					dCameraOffsetRealDistanceY = dCameraMovementY ;

					str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);
				}
				else if (eCamPlatformShareX == iCameraFixType)//平台X轴安装，移动量为平台X轴的移动量
				{
					dCameraMovementX =pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
					dCameraMovementY = 0;

					str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if (eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -1*dCameraMovementX;

					dCameraOffsetRealDistanceX = dCameraMovementX;
					dCameraOffsetRealDistanceY = dCameraMovementY;

					str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);

				}
				else if (eCamPlatformSepXY == iCameraFixType)
				{
					double dCamTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,0);
					double dCamTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,1);
					double dCamTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,0);
					double dCamTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,1);

					if(eDirectNone != iCamPlatformXCoordType)
					{
						dCameraMovementX = pCamPlatformXYAxisPos->m_dPosX - pCamPlatformBenchAxisPos->m_dPosX ; 
					}
					if(eDirectNone != iCamPlatformYCoordType)
					{
						dCameraMovementY = pCamPlatformXYAxisPos->m_dPosY - pCamPlatformBenchAxisPos->m_dPosY ; 
					}
					str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);


					//考虑相机平台的方向
					if(eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -dCameraMovementX;
					if(eDirectNegative == iCamPlatformYCoordType) dCameraMovementY = -dCameraMovementY;


					dCameraOffsetRealDistanceX = dCameraMovementX*dCamTranferA11 + dCameraMovementY*dCamTranferA12;
					dCameraOffsetRealDistanceY = dCameraMovementX*dCamTranferA21 + dCameraMovementY*dCamTranferA22;

					str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);

				}
				else if (eCamPlatformSepX == iCameraFixType)
				{
					double dCamTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,0);
					double dCamTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,1);
					double dCamTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,0);
					double dCamTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,1);

					if(eDirectNone != iCamPlatformXCoordType)
					{
						dCameraMovementX = pCamPlatformXYAxisPos->m_dPosX - pCamPlatformBenchAxisPos->m_dPosX ; 
					}
					dCameraMovementY = 0;

					str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					//考虑相机平台的方向
					if(eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -dCameraMovementX;
					if(eDirectNegative == iCamPlatformYCoordType) dCameraMovementY = -dCameraMovementY;

					dCameraOffsetRealDistanceX = dCameraMovementX*dCamTranferA11;
					dCameraOffsetRealDistanceY = dCameraMovementX*dCamTranferA12;

					str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);
				}
			}


			// 相机轴所在轴运动量对实时Mark在平台坐标系中的位置的影响
			if ( NULL != pCamAxisPlatformBenchAxisPos && NULL != pCamAxisPlatformXYAxisPos)
			{
				str.Format("相机平台所在轴基准坐标：X = %f , Y = %f ",pCamAxisPlatformBenchAxisPos->m_dPosX,pCamAxisPlatformBenchAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);

				str.Format("当前相机平台所在轴坐标： X = %f , Y = %f ",pCamAxisPlatformXYAxisPos->m_dPosX,pCamAxisPlatformXYAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);

				int iCamAxisPlatformAxisXCoordType = m_pCamPlatformInfo->GetCamPlatformAxisDirectX(nIndex%m_iMarkNum);
				int iCamAxisPlatformAxisYCoordType = m_pCamPlatformInfo->GetCamPlatformAxisDirectY(nIndex%m_iMarkNum);

				// 0为固定安装，1为安装在平台X轴上，2为安装在独立的XY轴上，3为安装在单独的X轴上
				int iCameraFixType = m_pCamPlatformInfo->GetCamPlatformType();
				if (eCamPlatformSepFix == iCameraFixType)
				{
					dCamAxisPlatformAxisMovementX = 0;
					dCamAxisPlatformAxisMovementY = 0;

					str.Format("相机平台所在轴移动带来平台移动值： X = %f , Y = %f ",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

				}
				else if (eCamPlatformShareX == iCameraFixType)//平台X轴安装，移动量为平台X轴的移动量
				{
					dCamAxisPlatformAxisMovementX = pCamAxisPlatformXYAxisPos->m_dPosX - pCamAxisPlatformBenchAxisPos->m_dPosX ; 
					dCamAxisPlatformAxisMovementY = pCamAxisPlatformXYAxisPos->m_dPosY - pCamAxisPlatformBenchAxisPos->m_dPosY ; 

					str.Format("相机平台所在轴移动带来平台移动值： X = %f , Y = %f ",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if(eDirectNegative == iCamAxisPlatformAxisXCoordType) dCamAxisPlatformAxisMovementX = -dCamAxisPlatformAxisMovementX;
					dCamAxisPlatformAxisMovementY = 0;
				}
				else if (eCamPlatformSepXY == iCameraFixType)
				{
					if(eDirectNone != iCamAxisPlatformAxisXCoordType)
					{
						dCamAxisPlatformAxisMovementX = pCamAxisPlatformXYAxisPos->m_dPosX - pCamAxisPlatformBenchAxisPos->m_dPosX ; 
					}
					if(eDirectNone != iCamAxisPlatformAxisYCoordType)
					{
						dCamAxisPlatformAxisMovementY = pCamAxisPlatformXYAxisPos->m_dPosY - pCamAxisPlatformBenchAxisPos->m_dPosY ; 
					}
					str.Format("相机平台所在轴移动带来平台移动值： X = %f , Y = %f ",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if(eDirectNegative == iCamAxisPlatformAxisXCoordType) dCamAxisPlatformAxisMovementX = -dCamAxisPlatformAxisMovementX;
					if(eDirectNegative == iCamAxisPlatformAxisYCoordType) dCamAxisPlatformAxisMovementY = -dCamAxisPlatformAxisMovementY;
				}
				else if (eCamPlatformSepX == iCameraFixType)
				{
				}
			}

			// $4、三部分内容相加，即为相机实时Mark的平台坐标值
			platformCoordPos.m_dPosX += dCameraOffsetRealDistanceX + dCamAxisPlatformAxisMovementX;
			platformCoordPos.m_dPosY += dCameraOffsetRealDistanceY + dCamAxisPlatformAxisMovementY;
		}


		str.Format("平台坐标值： X = %f , Y = %f , D = %f ",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY,platformCoordPos.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
		
	}
	else if ( (m_bTargetObjectCamSeparate == FALSE) && (m_bTargetCalibUseBoard == TRUE) && (FALSE == m_AlignermentParam.GetBendInfo().m_bBendAlignInspect || FALSE == m_bBendAlignProcess))
	{
		if (eDmCodeCalib == m_AlignermentParam.GetCalibTargetMarkPatternMode())
		{
			if (m_bEnableMultiCalibExtension == TRUE)
			{
				if (nIndex<0 || nIndex >= m_iMarkNum*(m_nMultiCalibExtensionMaxNum+1))
				{
					return false;
				}
			}
			else
			{
				if (nIndex<0 || nIndex >= m_iMarkNum)
				{
					return false;
				}
			}

			if (nIndex >= m_vAlignerCalibInfos.size())
			{
				return false;
			}

			if (NULL == m_vAlignerCalibInfos.at(nIndex))
			{
				return false;
			}

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
				{
					return false;
				}
			}

			int nPlatformIndex = m_nPlatformIndex;
			CString str;

			//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
			//相机平台类型没有基类，不用改；
			CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetPlatformAxisPos());
			CPlatformXYDAxisPos*  pPlatformXYDAxisPos =		 (CPlatformXYDAxisPos*)pPlatformAxisPos;
			CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 

			if (NULL == pPlatformBenchAxisPos || NULL == pPlatformXYDAxisPos  || NULL == pPlatformParam)
			{
				return false;
			}

			str.Format("轴基准坐标： X = %f , Y = %f , D = %f ",pPlatformBenchAxisPos->m_dPosX,pPlatformBenchAxisPos->m_dPosY,pPlatformBenchAxisPos->m_dAngle);
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("当前轴坐标： X = %f , Y = %f , D = %f ",pPlatformXYDAxisPos->m_dPosX,pPlatformXYDAxisPos->m_dPosY,pPlatformXYDAxisPos->m_dAngle);
			AlignToolLogRecord(str,nPlatformIndex);


			double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosX();
			double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosY();

			str.Format("Mark平台基准位置： X = %f , Y = %f ",dPlatformBenchMarkX,dPlatformBenchMarkY);
			AlignToolLogRecord(str,nPlatformIndex);

			//平台各轴的方向	
			int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
			int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;


			// 实际平台XY轴偏移量
			double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
			double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;

			if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
			if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;

			str.Format("轴平移量： X = %f , Y = %f ",dPlatformOffsetX,dPlatformOffsetY);
			AlignToolLogRecord(str,nPlatformIndex);


			//平台XY平移量对基准mark平台坐标的影响方向相反
			dPlatformBenchMarkX -= dPlatformOffsetX;
			dPlatformBenchMarkY -= dPlatformOffsetY;

			dPlatformBenchMarkX = 0.0;
			dPlatformBenchMarkY = 0.0;


			// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
			double dImgOffsetRealDistanceX = 0;
			double dImgOffsetRealDistanceY = 0;
			double dImgOffsetX = imageCoordPos.m_dPosX/* - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX*/;
			double dImgOffsetY = imageCoordPos.m_dPosY/* - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY*/;

			str.Format("基准图像位置： X = %f , Y = %f ",m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX,m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("当前图像位置： X = %f , Y = %f",imageCoordPos.m_dPosX,imageCoordPos.m_dPosY);
			AlignToolLogRecord(str,nPlatformIndex);
			str.Format("图像像素移动量： X = %f , Y = %f ",dImgOffsetX,dImgOffsetY);
			AlignToolLogRecord(str,nPlatformIndex);

			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vSrc.SetX(dImgOffsetX);
				vSrc.SetY(dImgOffsetY);

				vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);

				dImgOffsetRealDistanceX = vDst.GetX();
				dImgOffsetRealDistanceY = vDst.GetY();
			}



			str.Format("图像像素平台移动量： X = %f , Y = %f ",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
			AlignToolLogRecord(str,nPlatformIndex);


			// $4、内容相加，即为相机实时Mark的平台坐标值
			platformCoordPos.m_dPosX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
			platformCoordPos.m_dPosY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
			//mark为线时，平台mark线的角度为图像线的角度+图像平台坐标之间的夹角；
			platformCoordPos.m_dAngle = imageCoordPos.GetAngle() + 	m_vAlignerCalibInfos.at(nIndex)->m_dImageToPlatformAnlge;

			// $3、根据相机安装方式，计算由相机运动量对实时Mark在平台坐标系中的位置的影响
			if (eCamPlatformSepXY == m_pCamPlatformInfo->GetCamPlatformType() 
				|| eCamPlatformSepX == m_pCamPlatformInfo->GetCamPlatformType()
				|| eCamPlatformShareX == m_pCamPlatformInfo->GetCamPlatformType())
			{
				// $3、根据相机安装方式，计算由相机运动量对实时Mark在平台坐标系中的位置的影响

				// 相机轴
				CPlatformXYAxisPos*   pCamPlatformBenchAxisPos = (CPlatformXYAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformAxisPos());
				CPlatformXYAxisPos*   pCamPlatformXYAxisPos =	 (CPlatformXYAxisPos*)pCamPlatformAxisPos;

				// 相机轴所在轴
				CPlatformXYAxisPos*	  pCamAxisPlatformBenchAxisPos = (CPlatformXYAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetCamAxisPlatformAxisPos());
				CPlatformXYAxisPos*   pCamAxisPlatformXYAxisPos = (CPlatformXYAxisPos*)pCamAxisPlatformAxisPos;

				double dCameraMovementX = 0;				// 相机轴运动量X
				double dCameraMovementY = 0;				// 相机轴运动量Y
				double dCameraOffsetRealDistanceX = 0;		// 相机轴运动量对实时Mark在平台坐标系中的位置的影响X
				double dCameraOffsetRealDistanceY = 0;		// 相机轴运动量对实时Mark在平台坐标系中的位置的影响Y

				double dCamAxisPlatformAxisMovementX = 0;	// 相机轴所在轴运动量X
				double dCamAxisPlatformAxisMovementY = 0;	// 相机轴所在轴运动量Y

				// 相机轴运动量对实时Mark在平台坐标系中的位置的影响
				if (NULL != pCamPlatformBenchAxisPos && NULL != pCamPlatformXYAxisPos)
				{
					str.Format("相机轴基准坐标： X = %f , Y = %f ",pCamPlatformBenchAxisPos->m_dPosX,pCamPlatformBenchAxisPos->m_dPosY);
					AlignToolLogRecord(str,nPlatformIndex);
					str.Format("当前相机轴坐标： X = %f , Y = %f ",pCamPlatformXYAxisPos->m_dPosX,pCamPlatformXYAxisPos->m_dPosY);
					AlignToolLogRecord(str,nPlatformIndex);

					int iCamPlatformXCoordType = m_pCamPlatformInfo->GetCamDirectX(nIndex%m_iMarkNum);
					int iCamPlatformYCoordType = m_pCamPlatformInfo->GetCamDirectY(nIndex%m_iMarkNum);


					// 0为固定安装，1为安装在平台X轴上，2为安装在独立的XY轴上，3为安装在单独的X轴上
					int iCameraFixType = m_pCamPlatformInfo->GetCamPlatformType();
					if (eCamPlatformSepFix == iCameraFixType)
					{
						dCameraMovementX = 0;
						dCameraMovementY = 0;

						str.Format("相机移动量：X=%f,Y=%f",dCameraMovementX,dCameraMovementY);
						AlignToolLogRecord(str,nPlatformIndex);

						dCameraOffsetRealDistanceX = dCameraMovementX ;
						dCameraOffsetRealDistanceY = dCameraMovementY ;

						str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
						AlignToolLogRecord(str,nPlatformIndex);
					}
					else if (eCamPlatformShareX == iCameraFixType)//平台X轴安装，移动量为平台X轴的移动量
					{
						dCameraMovementX =pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
						dCameraMovementY = 0;

						str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
						AlignToolLogRecord(str,nPlatformIndex);

						if (eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -1*dCameraMovementX;

						dCameraOffsetRealDistanceX = dCameraMovementX;
						dCameraOffsetRealDistanceY = dCameraMovementY;

						str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
						AlignToolLogRecord(str,nPlatformIndex);

					}
					else if (eCamPlatformSepXY == iCameraFixType)
					{
						double dCamTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,0);
						double dCamTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,1);
						double dCamTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,0);
						double dCamTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,1);
						if(eDirectNone != iCamPlatformXCoordType)
						{
							dCameraMovementX = pCamPlatformXYAxisPos->m_dPosX - pCamPlatformBenchAxisPos->m_dPosX ; 
						}
						if(eDirectNone != iCamPlatformYCoordType)
						{
							dCameraMovementY = pCamPlatformXYAxisPos->m_dPosY - pCamPlatformBenchAxisPos->m_dPosY ; 
						}
						str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
						AlignToolLogRecord(str,nPlatformIndex);


						//考虑相机平台的方向
						if(eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -dCameraMovementX;
						if(eDirectNegative == iCamPlatformYCoordType) dCameraMovementY = -dCameraMovementY;


						dCameraOffsetRealDistanceX = dCameraMovementX*dCamTranferA11 + dCameraMovementY*dCamTranferA12;
						dCameraOffsetRealDistanceY = dCameraMovementX*dCamTranferA21 + dCameraMovementY*dCamTranferA22;

						str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
						AlignToolLogRecord(str,nPlatformIndex);

					}
					else if (eCamPlatformSepX == iCameraFixType)
					{
						double dCamTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,0);
						double dCamTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,1);
						double dCamTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,0);
						double dCamTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,1);
						if(eDirectNone != iCamPlatformXCoordType)
						{
							dCameraMovementX = pCamPlatformXYAxisPos->m_dPosX - pCamPlatformBenchAxisPos->m_dPosX ; 
						}
						dCameraMovementY = 0;

						str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
						AlignToolLogRecord(str,nPlatformIndex);

						//考虑相机平台的方向
						if(eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -dCameraMovementX;
						if(eDirectNegative == iCamPlatformYCoordType) dCameraMovementY = -dCameraMovementY;

						dCameraOffsetRealDistanceX = dCameraMovementX*dCamTranferA11;
						dCameraOffsetRealDistanceY = dCameraMovementX*dCamTranferA12;

						str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
						AlignToolLogRecord(str,nPlatformIndex);
					}
				}

				// 相机轴所在轴运动量对实时Mark在平台坐标系中的位置的影响
				if ( NULL != pCamAxisPlatformBenchAxisPos && NULL != pCamAxisPlatformXYAxisPos)
				{
					str.Format("相机平台所在轴基准坐标： X = %f , Y = %f ",pCamAxisPlatformBenchAxisPos->m_dPosX,pCamAxisPlatformBenchAxisPos->m_dPosY);
					AlignToolLogRecord(str,nPlatformIndex);
					str.Format("当前相机平台所在轴坐标： X = %f , Y = %f ",pCamAxisPlatformXYAxisPos->m_dPosX,pCamAxisPlatformXYAxisPos->m_dPosY);
					AlignToolLogRecord(str,nPlatformIndex);

					int iCamAxisPlatformAxisXCoordType = m_pCamPlatformInfo->GetCamPlatformAxisDirectX(nIndex%m_iMarkNum);
					int iCamAxisPlatformAxisYCoordType = m_pCamPlatformInfo->GetCamPlatformAxisDirectY(nIndex%m_iMarkNum);

					// 0为固定安装，1为安装在平台X轴上，2为安装在独立的XY轴上，3为安装在单独的X轴上
					int iCameraFixType = m_pCamPlatformInfo->GetCamPlatformType();
					if (eCamPlatformSepFix == iCameraFixType)
					{
						dCamAxisPlatformAxisMovementX = 0;
						dCamAxisPlatformAxisMovementY = 0;

						str.Format("相机平台所在轴移动量：X=%f,Y=%f",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
						AlignToolLogRecord(str,nPlatformIndex);
					}
					else if (eCamPlatformShareX == iCameraFixType)//平台X轴安装，移动量为平台X轴的移动量
					{
						dCamAxisPlatformAxisMovementX = pCamAxisPlatformXYAxisPos->m_dPosX - pCamAxisPlatformBenchAxisPos->m_dPosX ; 
						dCamAxisPlatformAxisMovementY = pCamAxisPlatformXYAxisPos->m_dPosY - pCamAxisPlatformBenchAxisPos->m_dPosY ; 

						str.Format("相机平台所在轴移动量： X = %f , Y = %f ",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
						AlignToolLogRecord(str,nPlatformIndex);

						if(eDirectNegative == iCamAxisPlatformAxisXCoordType) dCamAxisPlatformAxisMovementX = -dCamAxisPlatformAxisMovementX;
						dCamAxisPlatformAxisMovementY = 0;
					}
					else if (eCamPlatformSepXY == iCameraFixType)
					{
						if(eDirectNone != iCamAxisPlatformAxisXCoordType)
						{
							dCamAxisPlatformAxisMovementX = pCamAxisPlatformXYAxisPos->m_dPosX - pCamAxisPlatformBenchAxisPos->m_dPosX ; 
						}
						if(eDirectNone != iCamAxisPlatformAxisYCoordType)
						{
							dCamAxisPlatformAxisMovementY = pCamAxisPlatformXYAxisPos->m_dPosY - pCamAxisPlatformBenchAxisPos->m_dPosY ; 
						}
						str.Format("相机平台所在轴移动量： X = %f , Y = %f ",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
						AlignToolLogRecord(str,nPlatformIndex);

						if(eDirectNegative == iCamAxisPlatformAxisXCoordType) dCamAxisPlatformAxisMovementX = -dCamAxisPlatformAxisMovementX;
						if(eDirectNegative == iCamAxisPlatformAxisYCoordType) dCamAxisPlatformAxisMovementY = -dCamAxisPlatformAxisMovementY;
					}
					else if (eCamPlatformSepX == iCameraFixType)
					{
					}
				}

				// $4、三部分内容相加，即为相机实时Mark的平台坐标值
				platformCoordPos.m_dPosX += dCameraOffsetRealDistanceX + dCamAxisPlatformAxisMovementX;
				platformCoordPos.m_dPosY += dCameraOffsetRealDistanceY + dCamAxisPlatformAxisMovementY;
			}

			str.Format("平台坐标值： X = %f , Y = %f , D = %f ",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY,platformCoordPos.m_dAngle);
			AlignToolLogRecord(str,nPlatformIndex);

		}
		// 棋盘格
		else
		{
			// 定制应用
			// 从图像坐标转换平台坐标思路：先从图像转为靶标（2*2矩阵+基准MARK图像/平台坐标），再从靶标转为平台（3*3矩阵）
			// 假设没有进行靶标到平台的关联标定，3*3矩阵默认为单位阵，即认为靶标等于平台，也不影响图像坐标转换和对位计算

		if (nIndex<0 || nIndex >= m_iMarkNum*(m_nMultiCalibExtensionMaxNum+1))
		{
			return false;
		}

		if (nIndex >= m_vAlignerCalibInfos.size())
		{
			return false;
		}

		if (NULL == m_vAlignerCalibInfos.at(nIndex))
		{
			return false;
		}

		if (m_PlatformCalibType == ePlatformCalib9Point)
		{
			if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
			{
				return false;
			}
		}

		int nPlatformIndex = m_nPlatformIndex;
		CString str;

		//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
		//相机平台类型没有基类，不用改；
		CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetPlatformAxisPos());
		CPlatformXYDAxisPos*  pPlatformXYDAxisPos =		 (CPlatformXYDAxisPos*)pPlatformAxisPos;
		CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 
		//	CString str;

		if (NULL == pPlatformBenchAxisPos || NULL == pPlatformXYDAxisPos  || NULL == pPlatformParam)
		{
			return false;
		}

		str.Format("轴基准坐标：X=%f,Y=%f,D=%f",pPlatformBenchAxisPos->m_dPosX,pPlatformBenchAxisPos->m_dPosY,pPlatformBenchAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("当前轴坐标：X=%f,Y=%f,D=%f",pPlatformXYDAxisPos->m_dPosX,pPlatformXYDAxisPos->m_dPosY,pPlatformXYDAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
		//标定参数
		double dTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,0);
		double dTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,1);
		double dTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,0);
		double dTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,1);

		double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosX();
		double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosY();

		str.Format("Mark平台基准位置：X=%f,Y=%f",dPlatformBenchMarkX,dPlatformBenchMarkY);
		AlignToolLogRecord(str,nPlatformIndex);

		//平台各轴的方向	
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;

		// 实际平台XY轴偏移量
		double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
		double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;

		// 实际在使用时，会要求PLC在每次拍照时均发送轴位置0/0/0，靶标标定时轴位置0/0/0，因此轴位置偏差等于0/0/0

		if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
		if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
		if ( GetMidPlatformType() ==ePlatformXDPY || GetMidPlatformType() ==ePlatformXDPY1)
		{
			dPlatformOffsetY =0 ;
		}
		else if ( GetMidPlatformType() ==ePlatformXYPD || GetMidPlatformType() ==ePlatformXY || GetMidPlatformType()==ePlatformX || GetMidPlatformType() == ePlatformY)
		{
			dPlatformOffsetX =0 ;
			dPlatformOffsetY =0 ;
		}

		str.Format("轴平移量：X=%f,Y=%f",dPlatformOffsetX,dPlatformOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		//平台XY平移量对基准mark平台坐标的影响方向相反
		dPlatformBenchMarkX -= dPlatformOffsetX;
		dPlatformBenchMarkY -= dPlatformOffsetY;


		// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
		double dImgOffsetRealDistanceX = 0;
		double dImgOffsetRealDistanceY = 0;
		double dImgOffsetX = imageCoordPos.m_dPosX - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX;
		double dImgOffsetY = imageCoordPos.m_dPosY - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY;
		dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
		dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

		str.Format("基准图像位置：X=%f,Y=%f",m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX,m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("当前图像位置：X=%f,Y=%f",imageCoordPos.m_dPosX,imageCoordPos.m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("图像像素移动量：X=%f,Y=%f",dImgOffsetX,dImgOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("图像像素平台移动量：X=%f,Y=%f",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
		AlignToolLogRecord(str,nPlatformIndex);

		// $4、内容相加，即为相机实时Mark的平台坐标值
		platformCoordPos.m_dPosX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
		platformCoordPos.m_dPosY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
		//mark为线时，平台mark线的角度为图像线的角度+图像平台坐标之间的夹角；
		platformCoordPos.m_dAngle = imageCoordPos.GetAngle() + 	m_vAlignerCalibInfos.at(nIndex)->m_dImageToPlatformAnlge;

		str.Format("平台坐标值：X=%f,Y=%f,D=%f",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY,platformCoordPos.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);



		// 上述计算得到的是靶标坐标，下面根据靶标到平台的单应矩阵，将靶标坐标转换成平台坐标
		// 如果有关联标定，则根据3*3单应矩阵转换即可
		// 如果无关联标定，3*3单应矩阵等于单位矩阵，转换后等于原数值

		str.Format("投影前靶标坐标值：X=%f,Y=%f,D=%f",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY,platformCoordPos.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		// 生成用于单应矩阵投影的平台坐标
		sc2Vector boardPos;
		boardPos.SetX(platformCoordPos.GetPosX());
		boardPos.SetY(platformCoordPos.GetPosY());

		// 得到投影后平台坐标
		sc2Vector platformPos = sfHomographyProject(boardPos, m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);

		// 将投影后平台坐标输出
		platformCoordPos.m_dPosX = platformPos.GetX();
		platformCoordPos.m_dPosY = platformPos.GetY();
		platformCoordPos.m_dAngle = 0;

		str.Format("投影后平台坐标值：X=%f,Y=%f,D=%f",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY,platformCoordPos.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("投影单应矩阵：0=%f,1=%f,2=%f",m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[0],m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[1],m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[2]);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("投影单应矩阵：3=%f,4=%f,5=%f",m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[3],m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[4],m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[5]);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("投影单应矩阵：6=%f,7=%f,8=%f",m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[6],m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[7],m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH[8]);
		AlignToolLogRecord(str,nPlatformIndex);

		
		// $3、根据相机安装方式，计算由相机运动量对实时Mark在平台坐标系中的位置的影响
		if (eCamPlatformSepXY == m_pCamPlatformInfo->GetCamPlatformType() 
			|| eCamPlatformSepX == m_pCamPlatformInfo->GetCamPlatformType()
			|| eCamPlatformShareX == m_pCamPlatformInfo->GetCamPlatformType())
		{
			// $3、根据相机安装方式，计算由相机运动量对实时Mark在平台坐标系中的位置的影响

			// 相机轴
			CPlatformXYAxisPos*   pCamPlatformBenchAxisPos = (CPlatformXYAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformAxisPos());
			CPlatformXYAxisPos*   pCamPlatformXYAxisPos =	 (CPlatformXYAxisPos*)pCamPlatformAxisPos;

			// 相机轴所在轴
			CPlatformXYAxisPos*	  pCamAxisPlatformBenchAxisPos = (CPlatformXYAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetCamAxisPlatformAxisPos());
			CPlatformXYAxisPos*   pCamAxisPlatformXYAxisPos = (CPlatformXYAxisPos*)pCamAxisPlatformAxisPos;

			double dCameraMovementX = 0;				// 相机轴运动量X
			double dCameraMovementY = 0;				// 相机轴运动量Y
			double dCameraOffsetRealDistanceX = 0;		// 相机轴运动量对实时Mark在平台坐标系中的位置的影响X
			double dCameraOffsetRealDistanceY = 0;		// 相机轴运动量对实时Mark在平台坐标系中的位置的影响Y

			double dCamAxisPlatformAxisMovementX = 0;	// 相机轴所在轴运动量X
			double dCamAxisPlatformAxisMovementY = 0;	// 相机轴所在轴运动量Y

			// 相机轴运动量对实时Mark在平台坐标系中的位置的影响
			if (NULL != pCamPlatformBenchAxisPos && NULL != pCamPlatformXYAxisPos)
			{
				str.Format("相机轴基准坐标：X=%f,Y=%f",pCamPlatformBenchAxisPos->m_dPosX,pCamPlatformBenchAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("当前相机轴坐标：X=%f,Y=%f",pCamPlatformXYAxisPos->m_dPosX,pCamPlatformXYAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);

				int iCamPlatformXCoordType = m_pCamPlatformInfo->GetCamDirectX(nIndex%m_iMarkNum);
				int iCamPlatformYCoordType = m_pCamPlatformInfo->GetCamDirectY(nIndex%m_iMarkNum);


				// 0为固定安装，1为安装在平台X轴上，2为安装在独立的XY轴上，3为安装在单独的X轴上
				int iCameraFixType = m_pCamPlatformInfo->GetCamPlatformType();
				if (eCamPlatformSepFix == iCameraFixType)
				{
					dCameraMovementX = 0;
					dCameraMovementY = 0;

					str.Format("相机移动量移动量：X=%f,Y=%f",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					dCameraOffsetRealDistanceX = dCameraMovementX ;
					dCameraOffsetRealDistanceY = dCameraMovementY ;

					str.Format("相机移动带来平台移动值：X=%f,Y=%f",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);
				}
				else if (eCamPlatformShareX == iCameraFixType)//平台X轴安装，移动量为平台X轴的移动量
				{
					dCameraMovementX =pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
					dCameraMovementY = 0;

					str.Format("相机移动量移动量：X=%f,Y=%f",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if (eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -1*dCameraMovementX;

					dCameraOffsetRealDistanceX = dCameraMovementX;
					dCameraOffsetRealDistanceY = dCameraMovementY;

					str.Format("相机移动带来平台移动值：X=%f,Y=%f",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);

				}
				else if (eCamPlatformSepXY == iCameraFixType)
				{
					double dCamTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,0);
					double dCamTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,1);
					double dCamTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,0);
					double dCamTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,1);
					if(eDirectNone != iCamPlatformXCoordType)
					{
						dCameraMovementX = pCamPlatformXYAxisPos->m_dPosX - pCamPlatformBenchAxisPos->m_dPosX ; 
					}
					if(eDirectNone != iCamPlatformYCoordType)
					{
						dCameraMovementY = pCamPlatformXYAxisPos->m_dPosY - pCamPlatformBenchAxisPos->m_dPosY ; 
					}
					str.Format("相机移动量移动量：X=%f,Y=%f",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);


					//考虑相机平台的方向
					if(eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -dCameraMovementX;
					if(eDirectNegative == iCamPlatformYCoordType) dCameraMovementY = -dCameraMovementY;


					dCameraOffsetRealDistanceX = dCameraMovementX*dCamTranferA11 + dCameraMovementY*dCamTranferA12;
					dCameraOffsetRealDistanceY = dCameraMovementX*dCamTranferA21 + dCameraMovementY*dCamTranferA22;

					str.Format("相机移动带来平台移动值：X=%f,Y=%f",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);

				}
				else if (eCamPlatformSepX == iCameraFixType)
				{
					double dCamTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,0);
					double dCamTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,1);
					double dCamTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,0);
					double dCamTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,1);
					if(eDirectNone != iCamPlatformXCoordType)
					{
						dCameraMovementX = pCamPlatformXYAxisPos->m_dPosX - pCamPlatformBenchAxisPos->m_dPosX ; 
					}
					dCameraMovementY = 0;

					str.Format("相机移动量移动量：X=%f,Y=%f",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					//考虑相机平台的方向
					if(eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -dCameraMovementX;
					if(eDirectNegative == iCamPlatformYCoordType) dCameraMovementY = -dCameraMovementY;

					dCameraOffsetRealDistanceX = dCameraMovementX*dCamTranferA11;
					dCameraOffsetRealDistanceY = dCameraMovementX*dCamTranferA12;

					str.Format("相机移动带来平台移动值：X=%f,Y=%f",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);
				}
			}
			else
			{
				return false;
			}

			// 相机轴所在轴运动量对实时Mark在平台坐标系中的位置的影响
			if ( NULL != pCamAxisPlatformBenchAxisPos && NULL != pCamAxisPlatformXYAxisPos)
			{
				str.Format("相机平台所在轴基准坐标：X=%f,Y=%f",pCamAxisPlatformBenchAxisPos->m_dPosX,pCamAxisPlatformBenchAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("当前相机平台所在轴坐标：X=%f,Y=%f",pCamAxisPlatformXYAxisPos->m_dPosX,pCamAxisPlatformXYAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);

				int iCamAxisPlatformAxisXCoordType = m_pCamPlatformInfo->GetCamPlatformAxisDirectX(nIndex%m_iMarkNum);
				int iCamAxisPlatformAxisYCoordType = m_pCamPlatformInfo->GetCamPlatformAxisDirectY(nIndex%m_iMarkNum);

				// 0为固定安装，1为安装在平台X轴上，2为安装在独立的XY轴上，3为安装在单独的X轴上
				int iCameraFixType = m_pCamPlatformInfo->GetCamPlatformType();
				if (eCamPlatformSepFix == iCameraFixType)
				{
					dCamAxisPlatformAxisMovementX = 0;
					dCamAxisPlatformAxisMovementY = 0;

					str.Format("相机平台所在轴移动量：X=%f,Y=%f",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);
				}
				else if (eCamPlatformShareX == iCameraFixType)//平台X轴安装，移动量为平台X轴的移动量
				{
					dCamAxisPlatformAxisMovementX = pCamAxisPlatformXYAxisPos->m_dPosX - pCamAxisPlatformBenchAxisPos->m_dPosX ; 
					dCamAxisPlatformAxisMovementY = pCamAxisPlatformXYAxisPos->m_dPosY - pCamAxisPlatformBenchAxisPos->m_dPosY ; 

					str.Format("相机平台所在轴移动量：X=%f,Y=%f",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if(eDirectNegative == iCamAxisPlatformAxisXCoordType) dCamAxisPlatformAxisMovementX = -dCamAxisPlatformAxisMovementX;
					dCamAxisPlatformAxisMovementY = 0;
				}
				else if (eCamPlatformSepXY == iCameraFixType)
				{
					if(eDirectNone != iCamAxisPlatformAxisXCoordType)
					{
						dCamAxisPlatformAxisMovementX = pCamAxisPlatformXYAxisPos->m_dPosX - pCamAxisPlatformBenchAxisPos->m_dPosX ; 
					}
					if(eDirectNone != iCamAxisPlatformAxisYCoordType)
					{
						dCamAxisPlatformAxisMovementY = pCamAxisPlatformXYAxisPos->m_dPosY - pCamAxisPlatformBenchAxisPos->m_dPosY ; 
					}
					str.Format("相机平台所在轴移动量：X=%f,Y=%f",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if(eDirectNegative == iCamAxisPlatformAxisXCoordType) dCamAxisPlatformAxisMovementX = -dCamAxisPlatformAxisMovementX;
					if(eDirectNegative == iCamAxisPlatformAxisYCoordType) dCamAxisPlatformAxisMovementY = -dCamAxisPlatformAxisMovementY;
				}
				else if (eCamPlatformSepX == iCameraFixType)
				{
				}
			}

			// $4、三部分内容相加，即为相机实时Mark的平台坐标值
			platformCoordPos.m_dPosX += dCameraOffsetRealDistanceX + dCamAxisPlatformAxisMovementX;
			platformCoordPos.m_dPosY += dCameraOffsetRealDistanceY + dCamAxisPlatformAxisMovementY;
		}


		str.Format("平台坐标值：X=%f,Y=%f,D=%f",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY,platformCoordPos.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
		}
	}
	else
	{
		if (m_bEnableMultiCalibExtension == TRUE)
		{
			if (nIndex<0 || nIndex >= m_iMarkNum*(m_nMultiCalibExtensionMaxNum+1))
			{
				return false;
			}
		}
		else
		{
			if (nIndex<0 || nIndex >= m_iMarkNum)
			{
				return false;
			}
		}

		if (nIndex >= m_vAlignerCalibInfos.size())
		{
			return false;
		}

		if (NULL == m_vAlignerCalibInfos.at(nIndex))
		{
			return false;
		}

		if (m_PlatformCalibType == ePlatformCalib9Point)
		{
			if (!m_vAlignerCalibInfos.at(nIndex)->IsValid())
			{
				return false;
			}
		}

		int nPlatformIndex = m_nPlatformIndex;
		CString str;

		//平台、相机平台初始位置；平台、相机平台当前位置；平台参数->转换成相应平台类型
		//相机平台类型没有基类，不用改；
		CPlatformXYDAxisPos*  pPlatformBenchAxisPos =    (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetPlatformAxisPos());
		CPlatformXYDAxisPos*  pPlatformXYDAxisPos =		 (CPlatformXYDAxisPos*)pPlatformAxisPos;
		CPlatformXYDInfo*     pPlatformParam =			 (CPlatformXYDInfo*)m_pPlatformParam; 

		if (NULL == pPlatformBenchAxisPos || NULL == pPlatformXYDAxisPos  || NULL == pPlatformParam)
		{
			return false;
		}

		// 当目标自动标定不关联时，目标标定时轴位置通常是贴合时轴位置，而不是对象拍照时轴位置，
		// 按照目标标定时轴位置计算得到目标平台坐标很大，直接对位计算会超出视野，需要使用目标补偿解决，但是最后一次对位后位置会直接跑到贴合位
		// 使用对象标定时轴位置0/1替换目标标定时轴位置2/3，也可以解决这个问题，而不使用目标补偿
		if (m_bTargetObjectCamSeparate == TRUE && m_bTarObjCamSepNoAxisCalib == FALSE
			&& (GetMidPlatformType() != ePlatformXYPD && nIndex%m_iMarkNum >= m_iMarkNum/2) && m_bTarObjCamSepAutoCalibTar == TRUE && m_eTarAutoCalibAlignMode == eAlignOnObject)
		{
			pPlatformBenchAxisPos = (CPlatformXYDAxisPos*)(m_vAlignerCalibInfos.at(nIndex - m_iMarkNum/2)->GetPlatformAxisPos());
		}

		str.Format("轴基准坐标： X = %f , Y = %f , D = %f ",pPlatformBenchAxisPos->m_dPosX,pPlatformBenchAxisPos->m_dPosY,pPlatformBenchAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("当前轴坐标： X = %f , Y = %f , D = %f ",pPlatformXYDAxisPos->m_dPosX,pPlatformXYDAxisPos->m_dPosY,pPlatformXYDAxisPos->m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);


		// $1、先根据不同的平台类型，修正标定后的基准Mark在平台坐标系中的位置
		//标定参数
		double dTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,0);
		double dTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(0,1);
		double dTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,0);
		double dTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetPlatformTransferMatrix().GetElement(1,1);

		double dPlatformBenchMarkX = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosX();
		double dPlatformBenchMarkY = m_vAlignerCalibInfos.at(nIndex)->GetMarkPlatformCoordPos().GetPosY();

		str.Format("Mark平台基准位置： X = %f , Y = %f ",dPlatformBenchMarkX,dPlatformBenchMarkY);
		AlignToolLogRecord(str,nPlatformIndex);

		//平台各轴的方向	
		int iPlatformXCoordType = pPlatformParam->m_nPlatformXCoordType;
		int iPlatformYCoordType = pPlatformParam->m_nPlatformYCoordType;


		// 实际平台XY轴偏移量
		double dPlatformOffsetX = pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
		double dPlatformOffsetY = pPlatformXYDAxisPos->m_dPosY - pPlatformBenchAxisPos->m_dPosY;

		if (eDirectNegative == iPlatformXCoordType) dPlatformOffsetX = -1*dPlatformOffsetX;	
		if (eDirectNegative == iPlatformYCoordType) dPlatformOffsetY = -1*dPlatformOffsetY;
	
		if ( GetMidPlatformType() ==ePlatformXDPY || GetMidPlatformType() ==ePlatformXDPY1)
		{
			dPlatformOffsetY =0 ;
		}
		else if ( GetMidPlatformType() ==ePlatformXYPD && m_bCalibrateChangeXDirection && m_bCalibrateChangeYDirection)
		{

		}
		else if ( GetMidPlatformType() ==ePlatformXYPD || GetMidPlatformType() ==ePlatformXY || GetMidPlatformType()==ePlatformX || GetMidPlatformType() == ePlatformY)
		{
			dPlatformOffsetX =0 ;
			dPlatformOffsetY =0 ;
		}

		str.Format("轴平移量： X = %f , Y = %f ",dPlatformOffsetX,dPlatformOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);


		//平台XY平移量对基准mark平台坐标的影响方向相反
		dPlatformBenchMarkX -= dPlatformOffsetX;
		dPlatformBenchMarkY -= dPlatformOffsetY;

		// $2、根据标定后得到的变换矩阵和基准Mark的图像坐标值，计算图像上像素位置偏差对应的实际平台移动量
		double dImgOffsetRealDistanceX = 0;
		double dImgOffsetRealDistanceY = 0;
		double dImgOffsetX = imageCoordPos.m_dPosX - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX;
		double dImgOffsetY = imageCoordPos.m_dPosY - m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY;
		dImgOffsetRealDistanceX = dTranferA11*dImgOffsetX + dTranferA12*dImgOffsetY;
		dImgOffsetRealDistanceY = dTranferA21*dImgOffsetX + dTranferA22*dImgOffsetY;

		str.Format("基准图像位置： X = %f , Y = %f ",m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosX,m_vAlignerCalibInfos.at(nIndex)->GetMarkImgCoordPos().m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("当前图像位置： X = %f , Y = %f",imageCoordPos.m_dPosX,imageCoordPos.m_dPosY);
		AlignToolLogRecord(str,nPlatformIndex);
		str.Format("图像像素移动量： X = %f , Y = %f ",dImgOffsetX,dImgOffsetY);
		AlignToolLogRecord(str,nPlatformIndex);

		str.Format("使用2*2矩阵计算图像像素移动量： X = %f , Y = %f ",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
		AlignToolLogRecord(str,nPlatformIndex);

		if (m_bTargetObjectCamSeparate)
		{
			if (GetMidPlatformType() ==ePlatformXYPD)
			{
				// 目标、对象分离，目标平台坐标
				if (nIndex%m_iMarkNum >= m_iMarkNum/2)
				{
					if (m_PlatformCalibType == ePlatformCalib9Point)
					{
						sc2Vector vSrc;
						sc2Vector vDst;
						vSrc.SetX(dImgOffsetX);
						vSrc.SetY(dImgOffsetY);
						if (m_vpCalibrateParam.at(nRemIndex)->GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
						{
							sc2Vector vBoard;
							vBoard = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH1);
							vDst = sfHomographyProject(vBoard,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH2);
						}
						else
						{
							vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
						}						
						dImgOffsetRealDistanceX = vDst.GetX();
						dImgOffsetRealDistanceY = vDst.GetY();
					}
				}
				// 目标、对象分离，对象平台坐标
				else
				{
					if (m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point || m_AlignermentParam.GetCalibTargetMarkPatternMode() == eDmCodeCalib || m_bTarObjCamSepAutoCalibTar == TRUE)
					{
						sc2Vector vSrc;
						sc2Vector vDst;
						vSrc.SetX(dImgOffsetX);
						vSrc.SetY(dImgOffsetY);
						vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
						dImgOffsetRealDistanceX = vDst.GetX();
						dImgOffsetRealDistanceY = vDst.GetY();

						str.Format("使用3*3矩阵计算图像像素移动量： X = %f , Y = %f ",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
						AlignToolLogRecord(str,nPlatformIndex);
					}
					else
					{
						sc2Vector vSrc;
						sc2Vector vDst;
						vSrc.SetX(dImgOffsetX);
						vSrc.SetY(dImgOffsetY);

						double h[9];
						memset(h, 0.0, sizeof(double)*9);
						h[0]=dTranferA11;h[1]=dTranferA12;h[3]=dTranferA21;h[4]=dTranferA22;h[8]=1;

						vDst = sfHomographyProject(vSrc,h);
						dImgOffsetRealDistanceX = vDst.GetX();
						dImgOffsetRealDistanceY = vDst.GetY();

						str.Format("使用3*3矩阵计算图像像素移动量： X = %f , Y = %f ",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
						AlignToolLogRecord(str,nPlatformIndex);
					}
				}
			}
			else
			{
				// 目标、对象分离，对象点平台坐标计算
				if (nIndex%m_iMarkNum < m_iMarkNum/2)
				{
					if (m_PlatformCalibType == ePlatformCalib9Point)
					{
						sc2Vector vSrc;
						sc2Vector vDst;
						vSrc.SetX(dImgOffsetX);
						vSrc.SetY(dImgOffsetY);
						if (m_vpCalibrateParam.at(nRemIndex)->GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
						{
							sc2Vector vBoard;
							vBoard = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH1);
							vDst = sfHomographyProject(vBoard,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH2);
						}
						else
						{
							vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
						}		

						dImgOffsetRealDistanceX = vDst.GetX();
						dImgOffsetRealDistanceY = vDst.GetY();
					}
				}
				// 目标、对象分离，目标点平台坐标计算
				else
				{
                    if (m_AlignermentParam.GetCalibTargetMarkPatternMode() == eSinglePatternGuanlian4Point || m_AlignermentParam.GetCalibTargetMarkPatternMode() == eDmCodeCalib || m_bTarObjCamSepAutoCalibTar == TRUE)
					{
						sc2Vector vSrc;
						sc2Vector vDst;
						vSrc.SetX(dImgOffsetX);
						vSrc.SetY(dImgOffsetY);
						vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
						dImgOffsetRealDistanceX = vDst.GetX();
						dImgOffsetRealDistanceY = vDst.GetY();

						str.Format("使用3*3矩阵计算图像像素移动量： X = %f , Y = %f ",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
						AlignToolLogRecord(str,nPlatformIndex);
					}
					else
					{
						sc2Vector vSrc;
						sc2Vector vDst;
						vSrc.SetX(dImgOffsetX);
						vSrc.SetY(dImgOffsetY);

						double h[9];
						memset(h, 0.0, sizeof(double)*9);
						h[0]=dTranferA11;h[1]=dTranferA12;h[3]=dTranferA21;h[4]=dTranferA22;h[8]=1;

						vDst = sfHomographyProject(vSrc,h);
						dImgOffsetRealDistanceX = vDst.GetX();
						dImgOffsetRealDistanceY = vDst.GetY();

						str.Format("使用3*3矩阵计算图像像素移动量： X = %f , Y = %f ",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
						AlignToolLogRecord(str,nPlatformIndex);
					}
				}
			}

		}
		else
		{
			if (m_PlatformCalibType == ePlatformCalib9Point)
			{
				sc2Vector vSrc;
				sc2Vector vDst;
				vSrc.SetX(dImgOffsetX);
				vSrc.SetY(dImgOffsetY);
				if (m_vpCalibrateParam.at(nRemIndex)->GetCalibMarkPatternMode() == eWholeDmcodeBoardCalib)
				{
					sc2Vector vBoard;
					vBoard = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH1);
					vDst = sfHomographyProject(vBoard,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH2);
				}
				else
				{
					vDst = sfHomographyProject(vSrc,m_vAlignerCalibInfos.at(nIndex)->m_PlatformTranferH);
				}
				
				dImgOffsetRealDistanceX = vDst.GetX();
				dImgOffsetRealDistanceY = vDst.GetY();
			}
		}

		str.Format("图像像素平台移动量： X = %f , Y = %f ",dImgOffsetRealDistanceX,dImgOffsetRealDistanceY);
		AlignToolLogRecord(str,nPlatformIndex);


		// $4、内容相加，即为相机实时Mark的平台坐标值
		platformCoordPos.m_dPosX = dPlatformBenchMarkX + dImgOffsetRealDistanceX ;
		platformCoordPos.m_dPosY = dPlatformBenchMarkY + dImgOffsetRealDistanceY ;
		//mark为线时，平台mark线的角度为图像线的角度+图像平台坐标之间的夹角；
		platformCoordPos.m_dAngle = imageCoordPos.GetAngle() + 	m_vAlignerCalibInfos.at(nIndex)->m_dImageToPlatformAnlge;

		// $3、根据相机安装方式，计算由相机运动量对实时Mark在平台坐标系中的位置的影响
		if (eCamPlatformSepXY == m_pCamPlatformInfo->GetCamPlatformType() 
			|| eCamPlatformSepX == m_pCamPlatformInfo->GetCamPlatformType()
			|| eCamPlatformShareX == m_pCamPlatformInfo->GetCamPlatformType())
		{
			// $3、根据相机安装方式，计算由相机运动量对实时Mark在平台坐标系中的位置的影响

			// 相机轴
			CPlatformXYAxisPos*   pCamPlatformBenchAxisPos = (CPlatformXYAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformAxisPos());
			CPlatformXYAxisPos*   pCamPlatformXYAxisPos =	 (CPlatformXYAxisPos*)pCamPlatformAxisPos;

			// 相机轴所在轴
			CPlatformXYAxisPos*	  pCamAxisPlatformBenchAxisPos = (CPlatformXYAxisPos*)(m_vAlignerCalibInfos.at(nIndex)->GetCamAxisPlatformAxisPos());
			CPlatformXYAxisPos*   pCamAxisPlatformXYAxisPos = (CPlatformXYAxisPos*)pCamAxisPlatformAxisPos;

			double dCameraMovementX = 0;				// 相机轴运动量X
			double dCameraMovementY = 0;				// 相机轴运动量Y
			double dCameraOffsetRealDistanceX = 0;		// 相机轴运动量对实时Mark在平台坐标系中的位置的影响X
			double dCameraOffsetRealDistanceY = 0;		// 相机轴运动量对实时Mark在平台坐标系中的位置的影响Y

			double dCamAxisPlatformAxisMovementX = 0;	// 相机轴所在轴运动量X
			double dCamAxisPlatformAxisMovementY = 0;	// 相机轴所在轴运动量Y

			// 相机轴运动量对实时Mark在平台坐标系中的位置的影响
			if (NULL != pCamPlatformBenchAxisPos && NULL != pCamPlatformXYAxisPos)
			{
				str.Format("相机轴基准坐标： X = %f , Y = %f ",pCamPlatformBenchAxisPos->m_dPosX,pCamPlatformBenchAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("当前相机轴坐标： X = %f , Y = %f ",pCamPlatformXYAxisPos->m_dPosX,pCamPlatformXYAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);

				int iCamPlatformXCoordType = m_pCamPlatformInfo->GetCamDirectX(nIndex%m_iMarkNum);
				int iCamPlatformYCoordType = m_pCamPlatformInfo->GetCamDirectY(nIndex%m_iMarkNum);


				// 0为固定安装，1为安装在平台X轴上，2为安装在独立的XY轴上，3为安装在单独的X轴上
				int iCameraFixType = m_pCamPlatformInfo->GetCamPlatformType();
				if (eCamPlatformSepFix == iCameraFixType)
				{
					dCameraMovementX = 0;
					dCameraMovementY = 0;

					str.Format("相机移动量：X=%f,Y=%f",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					dCameraOffsetRealDistanceX = dCameraMovementX ;
					dCameraOffsetRealDistanceY = dCameraMovementY ;

					str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);
				}
				else if (eCamPlatformShareX == iCameraFixType)//平台X轴安装，移动量为平台X轴的移动量
				{
					dCameraMovementX =pPlatformXYDAxisPos->m_dPosX - pPlatformBenchAxisPos->m_dPosX;
					dCameraMovementY = 0;

					str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if (eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -1*dCameraMovementX;

					dCameraOffsetRealDistanceX = dCameraMovementX;
					dCameraOffsetRealDistanceY = dCameraMovementY;

					str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);

				}
				else if (eCamPlatformSepXY == iCameraFixType)
				{
					double dCamTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,0);
					double dCamTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,1);
					double dCamTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,0);
					double dCamTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,1);
					if(eDirectNone != iCamPlatformXCoordType)
					{
						dCameraMovementX = pCamPlatformXYAxisPos->m_dPosX - pCamPlatformBenchAxisPos->m_dPosX ; 
					}
					if(eDirectNone != iCamPlatformYCoordType)
					{
						dCameraMovementY = pCamPlatformXYAxisPos->m_dPosY - pCamPlatformBenchAxisPos->m_dPosY ; 
					}
					str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);


					//考虑相机平台的方向
					if(eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -dCameraMovementX;
					if(eDirectNegative == iCamPlatformYCoordType) dCameraMovementY = -dCameraMovementY;


					dCameraOffsetRealDistanceX = dCameraMovementX*dCamTranferA11 + dCameraMovementY*dCamTranferA12;
					dCameraOffsetRealDistanceY = dCameraMovementX*dCamTranferA21 + dCameraMovementY*dCamTranferA22;

					str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);

				}
				else if (eCamPlatformSepX == iCameraFixType)
				{
					double dCamTranferA11 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,0);
					double dCamTranferA12 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(0,1);
					double dCamTranferA21 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,0);
					double dCamTranferA22 = m_vAlignerCalibInfos.at(nIndex)->GetCamPlatformTransferMatrix().GetElement(1,1);
					if(eDirectNone != iCamPlatformXCoordType)
					{
						dCameraMovementX = pCamPlatformXYAxisPos->m_dPosX - pCamPlatformBenchAxisPos->m_dPosX ; 
					}
					dCameraMovementY = 0;

					str.Format("相机移动量： X = %f , Y = %f ",dCameraMovementX,dCameraMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					//考虑相机平台的方向
					if(eDirectNegative == iCamPlatformXCoordType) dCameraMovementX = -dCameraMovementX;
					if(eDirectNegative == iCamPlatformYCoordType) dCameraMovementY = -dCameraMovementY;

					dCameraOffsetRealDistanceX = dCameraMovementX*dCamTranferA11;
					dCameraOffsetRealDistanceY = dCameraMovementX*dCamTranferA12;

					str.Format("相机移动带来平台移动值： X = %f , Y = %f ",dCameraOffsetRealDistanceX,dCameraOffsetRealDistanceY);
					AlignToolLogRecord(str,nPlatformIndex);
				}
			}

			// 相机轴所在轴运动量对实时Mark在平台坐标系中的位置的影响
			if ( NULL != pCamAxisPlatformBenchAxisPos && NULL != pCamAxisPlatformXYAxisPos)
			{
				str.Format("相机平台所在轴基准坐标： X = %f , Y = %f ",pCamAxisPlatformBenchAxisPos->m_dPosX,pCamAxisPlatformBenchAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);
				str.Format("当前相机平台所在轴坐标： X = %f , Y = %f ",pCamAxisPlatformXYAxisPos->m_dPosX,pCamAxisPlatformXYAxisPos->m_dPosY);
				AlignToolLogRecord(str,nPlatformIndex);

				int iCamAxisPlatformAxisXCoordType = m_pCamPlatformInfo->GetCamPlatformAxisDirectX(nIndex%m_iMarkNum);
				int iCamAxisPlatformAxisYCoordType = m_pCamPlatformInfo->GetCamPlatformAxisDirectY(nIndex%m_iMarkNum);

				// 0为固定安装，1为安装在平台X轴上，2为安装在独立的XY轴上，3为安装在单独的X轴上
				int iCameraFixType = m_pCamPlatformInfo->GetCamPlatformType();
				if (eCamPlatformSepFix == iCameraFixType)
				{
					dCamAxisPlatformAxisMovementX = 0;
					dCamAxisPlatformAxisMovementY = 0;

					str.Format("相机平台所在轴移动量：X=%f,Y=%f",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);
				}
				else if (eCamPlatformShareX == iCameraFixType)//平台X轴安装，移动量为平台X轴的移动量
				{
					dCamAxisPlatformAxisMovementX = pCamAxisPlatformXYAxisPos->m_dPosX - pCamAxisPlatformBenchAxisPos->m_dPosX ; 
					dCamAxisPlatformAxisMovementY = pCamAxisPlatformXYAxisPos->m_dPosY - pCamAxisPlatformBenchAxisPos->m_dPosY ; 

					str.Format("相机平台所在轴移动量： X = %f , Y = %f ",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if(eDirectNegative == iCamAxisPlatformAxisXCoordType) dCamAxisPlatformAxisMovementX = -dCamAxisPlatformAxisMovementX;
					dCamAxisPlatformAxisMovementY = 0;
				}
				else if (eCamPlatformSepXY == iCameraFixType)
				{
					if(eDirectNone != iCamAxisPlatformAxisXCoordType)
					{
						dCamAxisPlatformAxisMovementX = pCamAxisPlatformXYAxisPos->m_dPosX - pCamAxisPlatformBenchAxisPos->m_dPosX ; 
					}
					if(eDirectNone != iCamAxisPlatformAxisYCoordType)
					{
						dCamAxisPlatformAxisMovementY = pCamAxisPlatformXYAxisPos->m_dPosY - pCamAxisPlatformBenchAxisPos->m_dPosY ; 
					}
					str.Format("相机平台所在轴移动量： X = %f , Y = %f ",dCamAxisPlatformAxisMovementX,dCamAxisPlatformAxisMovementY);
					AlignToolLogRecord(str,nPlatformIndex);

					if(eDirectNegative == iCamAxisPlatformAxisXCoordType) dCamAxisPlatformAxisMovementX = -dCamAxisPlatformAxisMovementX;
					if(eDirectNegative == iCamAxisPlatformAxisYCoordType) dCamAxisPlatformAxisMovementY = -dCamAxisPlatformAxisMovementY;
				}
				else if (eCamPlatformSepX == iCameraFixType)
				{
				}
			}

			// $4、三部分内容相加，即为相机实时Mark的平台坐标值
			platformCoordPos.m_dPosX += dCameraOffsetRealDistanceX + dCamAxisPlatformAxisMovementX;
			platformCoordPos.m_dPosY += dCameraOffsetRealDistanceY + dCamAxisPlatformAxisMovementY;
		}

		str.Format("平台坐标值： X = %f , Y = %f , D = %f ",platformCoordPos.m_dPosX,platformCoordPos.m_dPosY,platformCoordPos.m_dAngle);
		AlignToolLogRecord(str,nPlatformIndex);

	}

	return true;
}


// 获取用于对位的产品位置和角度（特别说明：该角度可能与补偿时获取产品的角度不一致）
BOOL vcBaseAlignTool::GetAlignProductPosAngle(std::vector<CCoordPos> vObjectPlatformCoordPos, sc2Vector& vProductPos, scDegree& degProductAngle, BOOL bAuxiliary,BOOL bCurObject)
{
// 	if (m_bTargetObjectCamSeparate && m_bPlatformTarCamWithDiffObjCam)
// 	{
// 		int nMark = m_iMarkNum/2;
// 		int nExMark = (m_iMarkNum/4) * m_nAlignnExProductIndex;
// 
// 		double dCH0X = vObjectPlatformCoordPos.at(0 + nExMark).m_dPosX;
// 		double dCH0Y = vObjectPlatformCoordPos.at(0 + nExMark).m_dPosY;
// 		double dCH1X = vObjectPlatformCoordPos.at(1 + nExMark).m_dPosX;
// 		double dCH1Y = vObjectPlatformCoordPos.at(1 + nExMark).m_dPosY;
// 
// 		if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto
// 			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12
// 			|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
// 		{				
// 			// 旋转中心
// 			double dRotationCenterX, dRotationCenterY;
// 			dRotationCenterX = (dCH0X + dCH1X)/2.0;
// 			dRotationCenterY = (dCH0Y + dCH1Y)/2.0;
// 
// 			// 产品位置
// 			vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt0;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt1;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_CTo3)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 旋转中心
// 			double dRotationCenterX, dRotationCenterY;
// 			dRotationCenterX = (dCH0X + dCH1X)/2.0;
// 			dRotationCenterY = (dCH0Y + dCH1Y)/2.0;
// 			// 产品位置
// 			if (bCurObject)
// 			{
// 				vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);
// 			}
// 			else
// 			{
// 				vProductPos = pt0;
// 			}
// 
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1L2)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt0;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2L1)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt1;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt0;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg(ptStart, ptEnd);
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1)
// 		{
// 			sc2Vector pt0(dCH0X, dCH0Y);
// 			sc2Vector pt1(dCH1X, dCH1Y);
// 
// 			// 产品位置
// 			vProductPos = pt1;
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg(ptStart, ptEnd);
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1)
// 		{
// 
// 			sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
// 			sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg0(pt00, pt01);
// 			scLineSeg lineSeg1(pt10, pt11);
// 			scLine line0 = lineSeg0.GetLine();
// 			scLine line1 = lineSeg1.GetLine();
// 			svStd vector< sc2Vector > ptCenter;
// 			bool IsInterSect = true;
// 			if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
// 				return FALSE;
// 
// 			// 产品位置
// 			vProductPos = ptCenter.at(0);
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg(ptStart, ptEnd);
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 
// 		}
// 		else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
// 		{
// 			sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
// 			sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg0(pt00, pt01);
// 			scLineSeg lineSeg1(pt10, pt11);
// 			scLine line0 = lineSeg0.GetLine();
// 			scLine line1 = lineSeg1.GetLine();
// 			svStd vector< sc2Vector > ptCenter;
// 			bool IsInterSect = true;
// 			if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
// 				return FALSE;
// 
// 			// 产品位置
// 			vProductPos = ptCenter.at(0);
// 
// 			// 构造实时mark对直线Lx
// 			scLine Lx;
// 			sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
// 			sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
// 			scLineSeg lineSeg(ptStart, ptEnd);
// 			Lx.SetFromLineSeg(lineSeg);
// 
// 			// 产品角度
// 			degProductAngle = scDegree(Lx.GetRotation());
// 		}
// 
// 		return TRUE;
// 	}

	{

		if (m_bTargetObjectCamSeparate)
		{
			if (2 == m_iMarkNum)
			{
				CString str;
				double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
				double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;

				// 产品位置
				vProductPos = sc2Vector(dCH0X, dCH0Y);

				// 产品角度:暂时认为产品角度是0°，后续可根据实际情况增加对位模式
				degProductAngle = scDegree(0);
			}
			else if (4 == m_iMarkNum)
			{
				CString str;
				double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
				double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
				double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
				double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;

				// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);
				// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto
					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12
					|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
				{				
					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH0X + dCH1X)/2.0;
					dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1)
				{
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);

					// 产品位置
					vProductPos = pt0;

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());

				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_CTo3)
				{
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);

					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH0X + dCH1X)/2.0;
					dRotationCenterY = (dCH0Y + dCH1Y)/2.0;
					// 产品位置
					if (bCurObject)
					{
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);
					}
					else
					{
						vProductPos = pt0;
					}


					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2)
				{
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);

					// 产品位置
					vProductPos = pt1;

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1L2)
				{
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);

					// 产品位置
					vProductPos = pt0;

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2L1)
				{
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);

					// 产品位置
					vProductPos = pt1;

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());

				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2)
				{
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);

					// 产品位置
					vProductPos = pt0;

					// 构造实时mark对直线Lx
					scLine Lx;
					sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
					sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
					scLineSeg lineSeg(ptStart, ptEnd);
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1)
				{
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);

					// 产品位置
					vProductPos = pt1;

					// 构造实时mark对直线Lx
					scLine Lx;
					sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
					sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
					scLineSeg lineSeg(ptStart, ptEnd);
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1)
				{

					sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
					sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
					sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
					sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
					scLineSeg lineSeg0(pt00, pt01);
					scLineSeg lineSeg1(pt10, pt11);
					scLine line0 = lineSeg0.GetLine();
					scLine line1 = lineSeg1.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
						return FALSE;

					// 产品位置
					vProductPos = ptCenter.at(0);

					// 构造实时mark对直线Lx
					scLine Lx;
					sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
					sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
					scLineSeg lineSeg(ptStart, ptEnd);
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());

				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
				{
					sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
					sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
					sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
					sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
					scLineSeg lineSeg0(pt00, pt01);
					scLineSeg lineSeg1(pt10, pt11);
					scLine line0 = lineSeg0.GetLine();
					scLine line1 = lineSeg1.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
						return FALSE;

					// 产品位置
					vProductPos = ptCenter.at(0);

					// 构造实时mark对直线Lx
					scLine Lx;
					sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
					sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
					scLineSeg lineSeg(ptStart, ptEnd);
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}
				else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto_Weigth
					||m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1_Weigth
					||m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2_Weigth)//jjh0601
				{
					if (bAuxiliary == FALSE)
					{
						if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto_Weigth)
						{
							// 旋转中心(点12组成的线段中点是旋转中心)
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH1X)/2.0;
							dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1_Weigth)
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2_Weigth)
						{
							// 旋转中心(点2是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
					}
					// 辅助点平台坐标
					else
					{
						// 旋转中心

						double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
						double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
						double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
						double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
						double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
						double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

						double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
						double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
						double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
						double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
						double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
						double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

						svStd vector< sc2Vector > ptCenter;

						// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
						BOOL bCH0_Auxiliary = FALSE;
						BOOL bCH1_Auxiliary = FALSE;

						int nPos = m_AlignermentParam.GetAlignerCirclePos();

						switch(nPos)
						{
						case 0:
							bCH0_Auxiliary = TRUE;
							break;
						case 1:
							bCH1_Auxiliary = TRUE;
							break;
						default:
							bCH0_Auxiliary = TRUE;
							break;
						}

						// 圆辅助点坐标在相机CH0中
						if (bCH0_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));

							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);


							// 产品位置
							vProductPos = ptCenter.at(0);
							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

						// 圆辅助点坐标在相机CH1中
						if (bCH1_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));

							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);


							// 产品位置
							vProductPos = ptCenter.at(0);
							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
					}
				}

			}
			else if (6 == m_iMarkNum)
			{				
				CString str;
				double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
				double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
				double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
				double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
				double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
				double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;

				// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);
				// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);
				// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				if (eAlignerPos123_Auto == m_AlignermentParam.GetAligner3Vs3Type())
				{

					// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector ptCenter = (pt0 + pt1 + pt2) / 3;

					// 产品位置
					vProductPos = ptCenter;

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);
					scLineSeg lineSeg12(pt1,pt2);

					scLine line01;
					scLine line02;
					scLine line12;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);
					line12.SetFromLineSeg(lineSeg12);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();


					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos123_123C1 == m_AlignermentParam.GetAligner3Vs3Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector ptCenter = pt0;

					// 产品位置
					vProductPos = ptCenter;

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);
					scLineSeg lineSeg12(pt1,pt2);

					scLine line01;
					scLine line02;
					scLine line12;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);
					line12.SetFromLineSeg(lineSeg12);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					// 产品角度
					degProductAngle = scDegree(dDegLx);

				}
				else if (eAlignerPos123_123C2 == m_AlignermentParam.GetAligner3Vs3Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector ptCenter = pt1;

					// 产品位置
					vProductPos = ptCenter;

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);
					scLineSeg lineSeg12(pt1,pt2);

					scLine line01;
					scLine line02;
					scLine line12;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);
					line12.SetFromLineSeg(lineSeg12);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos123_123C3 == m_AlignermentParam.GetAligner3Vs3Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector ptCenter = pt2;

					// 产品位置
					vProductPos = ptCenter;

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);
					scLineSeg lineSeg12(pt1,pt2);

					scLine line01;
					scLine line02;
					scLine line12;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);
					line12.SetFromLineSeg(lineSeg12);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos123_123C13L12 == m_AlignermentParam.GetAligner3Vs3Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector ptCenter = (pt0 + pt2)/2;

					// 产品位置
					vProductPos = ptCenter;

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);
					scLineSeg lineSeg12(pt1,pt2);

					double dlineSeg01Length = lineSeg01.Perimeter();	
					double dlineSeg02Length = lineSeg02.Perimeter();	
					double dlineSeg12Length = lineSeg12.Perimeter();	
					// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
					// 			AlignToolLogRecord(str,nPlatformIndex);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg;
					lineSeg.Set(pt0,pt1);


					Lx.SetFromLineSeg(lineSeg);
					double dDegLx = (Lx.GetRotation().SignedNorm()).ToDouble()*180.0/skPI;

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos123_123C13AL12 == m_AlignermentParam.GetAligner3Vs3Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector ptCenter = (pt0 + pt2)/2;

					// 产品位置
					vProductPos = ptCenter;

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);

					double dlineSeg01Length = lineSeg01.Perimeter();	
					double dlineSeg02Length = lineSeg02.Perimeter();	


					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg;
					lineSeg.Set(pt0,pt1);


					Lx.SetFromLineSeg(lineSeg);
					double dDegLx = (Lx.GetRotation().SignedNorm()).ToDouble()*180.0/skPI;

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos123_123C2L13 == m_AlignermentParam.GetAligner3Vs3Type() || eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector ptCenter = (pt1 + pt1)/2;

					// 产品位置
					vProductPos = ptCenter;

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);

					double dlineSeg01Length = lineSeg01.Perimeter();	
					double dlineSeg02Length = lineSeg02.Perimeter();	

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg;
					lineSeg.Set(pt0,pt2);


					Lx.SetFromLineSeg(lineSeg);

					double dDegLx = (Lx.GetRotation().SignedNorm()).ToDouble()*180.0/skPI;
					dDegLx -= 90;

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
					||eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
					||eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())  //jjh0612
				{
					if (!bAuxiliary)  //角点对位 分三种
					{
						// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
						BOOL bCH0_Auxiliary = FALSE;
						BOOL bCH1_Auxiliary = FALSE;
						BOOL bCH2_Auxiliary = FALSE;

						int nPos = m_AlignermentParam.GetAlignerCirclePos();

						switch(nPos)
						{
						case 0:
							bCH0_Auxiliary = TRUE;
							break;
						case 1:
							bCH1_Auxiliary = TRUE;
							break;
						case 2:
							bCH2_Auxiliary = TRUE;
							break;
						default:
							bCH0_Auxiliary = TRUE;
							break;
						}

						if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_Auto_Weigth)//两角点中心对位
						{

							if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
							{
								// 旋转中心
								double dRotationCenterX, dRotationCenterY;
								dRotationCenterX = (dCH1X + dCH2X)/2.0;
								dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

								// 产品位置
								vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}
							else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
							{
								// 旋转中心
								double dRotationCenterX, dRotationCenterY;
								dRotationCenterX = (dCH0X + dCH2X)/2.0;
								dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

								// 产品位置
								vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}
							else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
							{
								// 旋转中心
								double dRotationCenterX, dRotationCenterY;
								dRotationCenterX = (dCH0X + dCH1X)/2.0;
								dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

								// 产品位置
								vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}

						}
						else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C1_Weigth) //角点1对位
						{
							if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
							{
								// 旋转中心(点1是旋转中心)
								// 产品位置
								vProductPos = sc2Vector(dCH1X, dCH1Y); 

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}
							else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
							{
								// 旋转中心(点1是旋转中心)
								// 产品位置
								vProductPos = sc2Vector(dCH0X, dCH0Y); 

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}
							else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
							{
								// 旋转中心(点1是旋转中心)
								// 产品位置
								vProductPos = sc2Vector(dCH0X, dCH0Y); 

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}
						}
						else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C2_Weigth)//角点2对位
						{
							if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
							{
								// 旋转中心(点1是旋转中心)
								// 产品位置
								vProductPos = sc2Vector(dCH2X, dCH2Y); 

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}
							else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
							{
								// 旋转中心(点1是旋转中心)
								// 产品位置
								vProductPos = sc2Vector(dCH2X, dCH2Y); 

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}
							else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
							{
								// 旋转中心(点1是旋转中心)
								// 产品位置
								vProductPos = sc2Vector(dCH1X, dCH1Y); 

								// 构造实时mark对直线Lx
								scLine Lx;
								scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
								Lx.SetFromLineSeg(lineSeg);

								// 产品角度
								degProductAngle = scDegree(Lx.GetRotation());
							}
						}
					}
					else  //圆心对位
					{
						svStd vector< sc2Vector > ptCenter;
						// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

						BOOL bCH0_Auxiliary = FALSE;
						BOOL bCH1_Auxiliary = FALSE;
						BOOL bCH2_Auxiliary = FALSE;

						int nPos = m_AlignermentParam.GetAlignerCirclePos();

						switch(nPos)
						{
						case 0:
							bCH0_Auxiliary = TRUE;
							break;
						case 1:
							bCH1_Auxiliary = TRUE;
							break;
						case 2:
							bCH2_Auxiliary = TRUE;
							break;
						default:
							bCH0_Auxiliary = TRUE;
							break;
						}
						// 圆心坐标在相机CH0中
						if (bCH0_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);


							// 产品位置
							vProductPos = ptCenter.at(0);
							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

						// 圆点坐标在相机CH1中
						if (bCH1_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);


							// 产品位置
							vProductPos = ptCenter.at(0);
							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						// 圆点坐标在相机CH2中
						if (bCH2_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);


							// 产品位置
							vProductPos = ptCenter.at(0);
							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

					}

				}
				else if (eAlignerPos123_Auto_L1C_Weigth == m_AlignermentParam.GetAligner3Vs3Type()) //jjh0619  
				{
					if (!bAuxiliary)  //角点对位 分三种
					{
						// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
						BOOL bCH0_Auxiliary = FALSE;
						BOOL bCH1_Auxiliary = FALSE;
						BOOL bCH2_Auxiliary = FALSE;

						int nPos = m_AlignermentParam.GetAlignerCirclePos();

						switch(nPos)
						{
						case 0:
							bCH0_Auxiliary = TRUE;
							break;
						case 1:
							bCH1_Auxiliary = TRUE;
							break;
						case 2:
							bCH2_Auxiliary = TRUE;
							break;
						default:
							bCH0_Auxiliary = TRUE;
							break;
						}

						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH1X + dCH2X)/2.0;
							dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y)); //圆心和第一个点的连线角度
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH2X)/2.0;
							dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH1X)/2.0;
							dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

					}
					else  //圆心对位
					{
						svStd vector< sc2Vector > ptCenter;
						// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

						BOOL bCH0_Auxiliary = FALSE;
						BOOL bCH1_Auxiliary = FALSE;
						BOOL bCH2_Auxiliary = FALSE;

						int nPos = m_AlignermentParam.GetAlignerCirclePos();

						switch(nPos)
						{
						case 0:
							bCH0_Auxiliary = TRUE;
							break;
						case 1:
							bCH1_Auxiliary = TRUE;
							break;
						case 2:
							bCH2_Auxiliary = TRUE;
							break;
						default:
							bCH0_Auxiliary = TRUE;
							break;
						}
						// 圆心坐标在相机CH0中
						if (bCH0_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));//圆心和第一个点的连线角度
							Lx.SetFromLineSeg(lineSeg);


							// 产品位置
							vProductPos = ptCenter.at(0);
							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

						// 圆点坐标在相机CH1中
						if (bCH1_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
							Lx.SetFromLineSeg(lineSeg);


							// 产品位置
							vProductPos = ptCenter.at(0);
							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						// 圆点坐标在相机CH2中
						if (bCH2_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
							Lx.SetFromLineSeg(lineSeg);


							// 产品位置
							vProductPos = ptCenter.at(0);
							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

					}

				}
			}
			else if (8 == m_iMarkNum)
			{
				CString str;
				double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
				double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
				double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
				double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
				double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
				double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;
				double dCH3X = vObjectPlatformCoordPos.at(3).m_dPosX;
				double dCH3Y = vObjectPlatformCoordPos.at(3).m_dPosY;

				// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);
				// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);
				// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);
				// 			str.Format("vObjectPlatformCoordPos.at(3).m_dPosX=%f, vObjectPlatformCoordPos.at(3).m_dPosY=%f", vObjectPlatformCoordPos.at(3).m_dPosX, vObjectPlatformCoordPos.at(3).m_dPosY);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				if (eAlignerPos1234_Auto == m_AlignermentParam.GetAligner4Vs4Type())
				{
					// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);
					scLineSeg lineSeg12(pt1, pt2);
					scLineSeg lineSeg03(pt0, pt3);
					scLine line12 = lineSeg12.GetLine();
					scLine line03 = lineSeg03.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(line03,line12,IsInterSect,ptCenter))
						return FALSE;

					// 产品位置
					vProductPos = ptCenter.at(0);


					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);

					scLine line01;
					scLine line02;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();


					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos1234_123C1 == m_AlignermentParam.GetAligner4Vs4Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);				

					svStd vector< sc2Vector > ptCenter;
					ptCenter.push_back(pt0);

					// 产品位置
					vProductPos = ptCenter.at(0);

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);

					scLine line01;
					scLine line02;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					// 产品角度
					degProductAngle = scDegree(dDegLx);

				}
				else if (eAlignerPos1234_124C2 == m_AlignermentParam.GetAligner4Vs4Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					svStd vector< sc2Vector > ptCenter;
					ptCenter.push_back(pt1);

					// 产品位置
					vProductPos = ptCenter.at(0);

					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt1,pt3);

					scLine line01;
					scLine line02;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos1234_134C3 == m_AlignermentParam.GetAligner4Vs4Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					svStd vector< sc2Vector > ptCenter;
					ptCenter.push_back(pt2);


					// 产品位置
					vProductPos = ptCenter.at(0);


					//各边的长度
					scLineSeg lineSeg01(pt2,pt3);
					scLineSeg lineSeg02(pt0,pt2);

					scLine line01;
					scLine line02;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (eAlignerPos1234_234C4 == m_AlignermentParam.GetAligner4Vs4Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					svStd vector< sc2Vector > ptCenter;
					ptCenter.push_back(pt3);

					// 产品位置
					vProductPos = ptCenter.at(0);

					//各边的长度
					scLineSeg lineSeg01(pt2,pt3);
					scLineSeg lineSeg02(pt1,pt3);

					scLine line01;
					scLine line02;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else if (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
					|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
					|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4
					|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
					|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Center)
				{
					// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					sc2Vector pt01 = (pt0 + pt1)/2;
					sc2Vector pt23 = (pt2 + pt3)/2;
					sc2Vector pt02 = (pt0 + pt2)/2;
					sc2Vector pt13 = (pt1 + pt3)/2;

					if((pt01==pt23) || (pt02==pt13))
					{
						return FALSE;
					}

					scLineSeg lineVer(pt01,pt23);
					scLineSeg lineHor(pt02,pt13);


					scLine lineV = lineVer.GetLine();
					scLine lineH = lineHor.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
						return FALSE;
					// 产品位置
					vProductPos = ptCenter.at(0);

					//各边的长度
					double d1,d2;
					if(false == sfDistancePoint2Point(pt0,pt1,d1))
						return FALSE;
					if(false == sfDistancePoint2Point(pt0,pt2,d2))
						return FALSE;

					str.Format("pt0到pt1距离=%f,pt0到pt2距离=%f",d1,d2);
					AlignToolLogRecord(str, m_nPlatformIndex);
					double dDegLx = 0;
					if(d1>d2)
					{
						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg23(pt2,pt3);

						scLine line01;
						scLine line23;

						line01.SetFromLineSeg(lineSeg01);
						line23.SetFromLineSeg(lineSeg23);

						dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();

					}
					else
					{
						scLineSeg lineSeg13(pt1,pt3);
						scLineSeg lineSeg02(pt0,pt2);

						scLine line13;
						scLine line02;

						line13.SetFromLineSeg(lineSeg13);
						line02.SetFromLineSeg(lineSeg02);

						dDegLx = (scDegree((line13.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					}
					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				// 均方误差最小对位角度，均方误差最小（X1,Y1）+ 圆（X2,Y2）,根据权重系数计算（X,Y）
				else if (eAlignerPos1234_1234_Weight == m_AlignermentParam.GetAligner4Vs4Type())
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
					double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
					double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
					double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
					double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
					double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

					double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
					double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
					double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
					double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
					double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
					double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

					double dCH2_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(0);
					double dCH2_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(0);
					double dCH2_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(1);
					double dCH2_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(1);
					double dCH2_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(2);
					double dCH2_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(2);

					double dCH3_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(0);
					double dCH3_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(0);
					double dCH3_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(1);
					double dCH3_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(1);
					double dCH3_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(2);
					double dCH3_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(2);

					svStd vector< sc2Vector > ptCenter;

					double dDegLx = 0;

					// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;
					BOOL bCH3_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					case 3:
						bCH3_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					// 圆辅助点坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));

						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg02(pt0,pt2);

						scLine line01;
						scLine line02;

						line01.SetFromLineSeg(lineSeg01);
						line02.SetFromLineSeg(lineSeg02);


						dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					}

					// 圆辅助点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));

						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg02(pt1,pt3);

						scLine line01;
						scLine line02;

						line01.SetFromLineSeg(lineSeg01);
						line02.SetFromLineSeg(lineSeg02);

						dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					}

					// 圆辅助点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2));

						scLineSeg lineSeg01(pt2,pt3);
						scLineSeg lineSeg02(pt0,pt2);

						scLine line01;
						scLine line02;

						line01.SetFromLineSeg(lineSeg01);
						line02.SetFromLineSeg(lineSeg02);

						dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					}

					// 圆辅助点坐标在相机CH3中
					if (bCH3_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH3_AuxiliaryPosX2,dCH3_AuxiliaryPosY2));

						scLineSeg lineSeg01(pt2,pt3);
						scLineSeg lineSeg02(pt1,pt3);

						scLine line01;
						scLine line02;

						line01.SetFromLineSeg(lineSeg01);
						line02.SetFromLineSeg(lineSeg02);

						dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					}

					// 产品位置
					vProductPos = ptCenter.at(0);

					// 产品角度
					degProductAngle = scDegree(dDegLx);

				}

				// 长边对位角度，四个位置组合构成直线，四边中点（X1,Y1）+ 圆（X2,Y2），根据权重系数计算（X,Y）
				else if (eAlignerPos1234_Combine_Weight == m_AlignermentParam.GetAligner4Vs4Type())
				{
					// 平台坐标
					if (bAuxiliary == FALSE)
					{
						// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
						sc2Vector pt0(dCH0X, dCH0Y);
						sc2Vector pt1(dCH1X, dCH1Y);
						sc2Vector pt2(dCH2X, dCH2Y);
						sc2Vector pt3(dCH3X, dCH3Y);

						sc2Vector pt01 = (pt0 + pt1)/2;
						sc2Vector pt23 = (pt2 + pt3)/2;
						sc2Vector pt02 = (pt0 + pt2)/2;
						sc2Vector pt13 = (pt1 + pt3)/2;
						scLineSeg lineVer(pt01,pt23);
						scLineSeg lineHor(pt02,pt13);
						scLine lineV = lineVer.GetLine();
						scLine lineH = lineHor.GetLine();
						svStd vector< sc2Vector > ptCenter;
						bool IsInterSect = true;
						if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
							return FALSE;
						// 产品位置
						vProductPos = ptCenter.at(0);

						//各边的长度
						double d1,d2;
						if(false == sfDistancePoint2Point(pt0,pt1,d1))
							return FALSE;
						if(false == sfDistancePoint2Point(pt0,pt2,d2))
							return FALSE;

						str.Format("pt0到pt1距离=%f,pt0到pt2距离=%f",d1,d2);
						AlignToolLogRecord(str, m_nPlatformIndex);
						double dDegLx = 0;
						if(d1>d2)
						{
							scLineSeg lineSeg01(pt0,pt1);
							scLineSeg lineSeg23(pt2,pt3);

							scLine line01;
							scLine line23;

							line01.SetFromLineSeg(lineSeg01);
							line23.SetFromLineSeg(lineSeg23);

							dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();

						}
						else
						{
							scLineSeg lineSeg13(pt1,pt3);
							scLineSeg lineSeg02(pt0,pt2);

							scLine line13;
							scLine line02;

							line13.SetFromLineSeg(lineSeg13);
							line02.SetFromLineSeg(lineSeg02);

							dDegLx = (scDegree((line13.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

						}
						// 产品角度
						degProductAngle = scDegree(dDegLx);
					}
					// 辅助点平台坐标
					else
					{
						// 旋转中心
						sc2Vector pt0(dCH0X, dCH0Y);
						sc2Vector pt1(dCH1X, dCH1Y);
						sc2Vector pt2(dCH2X, dCH2Y);
						sc2Vector pt3(dCH3X, dCH3Y);

						double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
						double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
						double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
						double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
						double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
						double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

						double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
						double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
						double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
						double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
						double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
						double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

						double dCH2_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(0);
						double dCH2_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(0);
						double dCH2_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(1);
						double dCH2_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(1);
						double dCH2_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(2);
						double dCH2_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(2);

						double dCH3_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(0);
						double dCH3_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(0);
						double dCH3_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(1);
						double dCH3_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(1);
						double dCH3_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(2);
						double dCH3_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(2);


						svStd vector< sc2Vector > ptCenter;
						double dDegLx = 0;

						// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
						BOOL bCH0_Auxiliary = FALSE;
						BOOL bCH1_Auxiliary = FALSE;
						BOOL bCH2_Auxiliary = FALSE;
						BOOL bCH3_Auxiliary = FALSE;

						int nPos = m_AlignermentParam.GetAlignerCirclePos();

						switch(nPos)
						{
						case 0:
							bCH0_Auxiliary = TRUE;
							break;
						case 1:
							bCH1_Auxiliary = TRUE;
							break;
						case 2:
							bCH2_Auxiliary = TRUE;
							break;
						case 3:
							bCH3_Auxiliary = TRUE;
							break;
						default:
							bCH0_Auxiliary = TRUE;
							break;
						}

						// 圆辅助点坐标在相机CH0中
						if (bCH0_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));

							scLineSeg lineSeg01(pt0,pt1);
							scLineSeg lineSeg02(pt0,pt2);

							scLine line01;
							scLine line02;

							line01.SetFromLineSeg(lineSeg01);
							line02.SetFromLineSeg(lineSeg02);


							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
						}

						// 圆辅助点坐标在相机CH1中
						if (bCH1_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));

							scLineSeg lineSeg01(pt0,pt1);
							scLineSeg lineSeg02(pt1,pt3);

							scLine line01;
							scLine line02;

							line01.SetFromLineSeg(lineSeg01);
							line02.SetFromLineSeg(lineSeg02);

							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
						}

						// 圆辅助点坐标在相机CH2中
						if (bCH2_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2));

							scLineSeg lineSeg01(pt2,pt3);
							scLineSeg lineSeg02(pt0,pt2);

							scLine line01;
							scLine line02;

							line01.SetFromLineSeg(lineSeg01);
							line02.SetFromLineSeg(lineSeg02);

							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
						}

						// 圆辅助点坐标在相机CH3中
						if (bCH3_Auxiliary)
						{
							ptCenter.push_back(sc2Vector(dCH3_AuxiliaryPosX2,dCH3_AuxiliaryPosY2));

							scLineSeg lineSeg01(pt2,pt3);
							scLineSeg lineSeg02(pt1,pt3);

							scLine line01;
							scLine line02;

							line01.SetFromLineSeg(lineSeg01);
							line02.SetFromLineSeg(lineSeg02);

							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
						}

						// 						if ( (dCH0_AuxiliaryPosX2 != dCH0_AuxiliaryPosX2) || (dCH0_AuxiliaryPosY2 != dCH0_AuxiliaryPosY2) )
						// 						{
						// 							ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));
						// 
						// 							scLineSeg lineSeg01(pt0,pt1);
						// 							scLineSeg lineSeg02(pt0,pt2);
						// 
						// 							scLine line01;
						// 							scLine line02;
						// 
						// 							line01.SetFromLineSeg(lineSeg01);
						// 							line02.SetFromLineSeg(lineSeg02);
						// 
						// 
						// 							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
						// 
						// 
						// 						}
						// 						else if ( (dCH1_AuxiliaryPosX2 != dCH1_AuxiliaryPosX2) || (dCH1_AuxiliaryPosY2 != dCH1_AuxiliaryPosY2) )
						// 						{
						// 							ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));
						// 
						// 							scLineSeg lineSeg01(pt0,pt1);
						// 							scLineSeg lineSeg02(pt1,pt3);
						// 
						// 							scLine line01;
						// 							scLine line02;
						// 
						// 							line01.SetFromLineSeg(lineSeg01);
						// 							line02.SetFromLineSeg(lineSeg02);
						// 
						// 							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
						// 
						// 						}
						// 						else if ( (dCH2_AuxiliaryPosX2 != dCH2_AuxiliaryPosX2) || (dCH2_AuxiliaryPosY2 != dCH2_AuxiliaryPosY2) )
						// 						{
						// 							ptCenter.push_back(sc2Vector(dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2));
						// 
						// 							scLineSeg lineSeg01(pt2,pt3);
						// 							scLineSeg lineSeg02(pt0,pt2);
						// 
						// 							scLine line01;
						// 							scLine line02;
						// 
						// 							line01.SetFromLineSeg(lineSeg01);
						// 							line02.SetFromLineSeg(lineSeg02);
						// 
						// 							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
						// 
						// 						}
						// 						else if ( (dCH3_AuxiliaryPosX2 != dCH3_AuxiliaryPosX2) || (dCH3_AuxiliaryPosY2 != dCH3_AuxiliaryPosY2) )
						// 						{
						// 							ptCenter.push_back(sc2Vector(dCH3_AuxiliaryPosX2,dCH3_AuxiliaryPosY2));
						// 
						// 							scLineSeg lineSeg01(pt2,pt3);
						// 							scLineSeg lineSeg02(pt1,pt3);
						// 
						// 							scLine line01;
						// 							scLine line02;
						// 
						// 							line01.SetFromLineSeg(lineSeg01);
						// 							line02.SetFromLineSeg(lineSeg02);
						// 
						// 							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
						// 						}
						// 						else
						// 						{				
						// 							ptCenter.push_back(sc2Vector(0, 0));
						// 
						// 							dDegLx = 0;
						// 						}


						// 产品位置
						vProductPos = ptCenter.at(0);

						// 产品角度
						degProductAngle = scDegree(dDegLx);
					}


				}
				else if (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_56_4V2)
				{
					if (bCurObject)
					{
						// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
						sc2Vector pt0(dCH0X, dCH0Y);
						sc2Vector pt1(dCH1X, dCH1Y);
						sc2Vector pt2(dCH2X, dCH2Y);
						sc2Vector pt3(dCH3X, dCH3Y);

						sc2Vector pt01 = (pt0 + pt1)/2;
						sc2Vector pt23 = (pt2 + pt3)/2;
						sc2Vector pt02 = (pt0 + pt2)/2;
						sc2Vector pt13 = (pt1 + pt3)/2;
						scLineSeg lineVer(pt01,pt23);
						scLineSeg lineHor(pt02,pt13);
						scLine lineV = lineVer.GetLine();
						scLine lineH = lineHor.GetLine();
						svStd vector< sc2Vector > ptCenter;
						bool IsInterSect = true;
						if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
							return FALSE;
						// 产品位置
						vProductPos = ptCenter.at(0);

						double dDegLx = 0;

						{
							scLineSeg lineSeg01(pt0,pt1);
							scLineSeg lineSeg23(pt2,pt3);

							scLine line01;
							scLine line23;

							line01.SetFromLineSeg(lineSeg01);
							line23.SetFromLineSeg(lineSeg23);

							dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();

						}

						// 产品角度
						degProductAngle = scDegree(dDegLx);
					}
					else
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}


				}
			}
			else
			{
				return  FALSE;
			}

			return TRUE;
		}

		//m_iMarkNum为mark数量
		if (1 == m_iMarkNum)
		{
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;

			// 产品位置
			vProductPos = sc2Vector(dCH0X, dCH0Y);

			// 产品角度:暂时认为产品角度是0°，后续可根据实际情况增加对位模式
			degProductAngle = scDegree(0);
		}
		else if (2 == m_iMarkNum)
		{
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;

			// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12
				|| m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Combine_C12V)
			{				
				// 旋转中心
				double dRotationCenterX, dRotationCenterY;
				dRotationCenterX = (dCH0X + dCH1X)/2.0;
				dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

				// 产品位置
				vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt0;

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());

			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_CTo3)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 旋转中心
				double dRotationCenterX, dRotationCenterY;
				dRotationCenterX = (dCH0X + dCH1X)/2.0;
				dRotationCenterY = (dCH0Y + dCH1Y)/2.0;
				// 产品位置
				if (bCurObject)
				{
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);
				}
				else
				{
					vProductPos = pt0;
				}


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt1;

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1L2)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt0;

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2L1)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt1;

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());

			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot1L2)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt0;

				// 构造实时mark对直线Lx
				scLine Lx;
				sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
				sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg(ptStart, ptEnd);
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12Dot2L1)
			{
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);

				// 产品位置
				vProductPos = pt1;

				// 构造实时mark对直线Lx
				scLine Lx;
				sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
				sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg(ptStart, ptEnd);
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L1)
			{

				sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
				sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
				sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
				sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg0(pt00, pt01);
				scLineSeg lineSeg1(pt10, pt11);
				scLine line0 = lineSeg0.GetLine();
				scLine line1 = lineSeg1.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
					return FALSE;

				// 产品位置
				vProductPos = ptCenter.at(0);

				// 构造实时mark对直线Lx
				scLine Lx;
				sc2Vector ptStart(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
				sc2Vector ptEnd(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg(ptStart, ptEnd);
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());

			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_L12L2)
			{
				sc2Vector pt00(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0));
				sc2Vector pt01(vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1));
				sc2Vector pt10(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
				sc2Vector pt11(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg0(pt00, pt01);
				scLineSeg lineSeg1(pt10, pt11);
				scLine line0 = lineSeg0.GetLine();
				scLine line1 = lineSeg1.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(line0,line1,IsInterSect,ptCenter) || ptCenter.size() <= 0)
					return FALSE;

				// 产品位置
				vProductPos = ptCenter.at(0);

				// 构造实时mark对直线Lx
				scLine Lx;
				sc2Vector ptStart(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0));
				sc2Vector ptEnd(vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1), vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1));
				scLineSeg lineSeg(ptStart, ptEnd);
				Lx.SetFromLineSeg(lineSeg);

				// 产品角度
				degProductAngle = scDegree(Lx.GetRotation());
			}
			else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto_Weigth
				||m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1_Weigth
				||m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2_Weigth)//jjh0601
			{
				if (bAuxiliary == FALSE)
				{
					if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_Auto_Weigth)
					{
						// 旋转中心(点12组成的线段中点是旋转中心)
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C1_Weigth)
					{
						// 旋转中心(点1是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH0X, dCH0Y);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (m_AlignermentParam.GetAligner2Vs2Type() == eAlignerPos12_12C2_Weigth)
					{
						// 旋转中心(点2是旋转中心)
						// 产品位置
						vProductPos = sc2Vector(dCH1X, dCH1Y);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
				// 辅助点平台坐标
				else
				{
					// 旋转中心

					double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
					double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
					double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
					double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
					double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
					double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

					double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
					double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
					double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
					double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
					double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
					double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

					svStd vector< sc2Vector > ptCenter;

					// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					// 圆辅助点坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆辅助点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
				}
			}

		}
		else if (3 == m_iMarkNum)
		{				
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
			double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
			double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;

			// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			if (eAlignerPos123_Auto == m_AlignermentParam.GetAligner3Vs3Type())
			{

				// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = (pt0 + pt1 + pt2) / 3;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				scLine line01;
				scLine line02;
				scLine line12;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);
				line12.SetFromLineSeg(lineSeg12);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();


				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C1 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = pt0;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				scLine line01;
				scLine line02;
				scLine line12;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);
				line12.SetFromLineSeg(lineSeg12);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

				// 产品角度
				degProductAngle = scDegree(dDegLx);

			}
			else if (eAlignerPos123_123C2 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = pt1;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				scLine line01;
				scLine line02;
				scLine line12;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);
				line12.SetFromLineSeg(lineSeg12);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C3 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = pt2;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				scLine line01;
				scLine line02;
				scLine line12;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);
				line12.SetFromLineSeg(lineSeg12);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C13L12 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = (pt0 + pt2)/2;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);
				scLineSeg lineSeg12(pt1,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	
				double dlineSeg12Length = lineSeg12.Perimeter();	
				// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f,dlineSeg12Length=%f", dlineSeg01Length, dlineSeg02Length, dlineSeg12Length);
				// 			AlignToolLogRecord(str,nPlatformIndex);

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				lineSeg.Set(pt0,pt1);


				Lx.SetFromLineSeg(lineSeg);
				double dDegLx = (Lx.GetRotation().SignedNorm()).ToDouble()*180.0/skPI;

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C13AL12 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = (pt0 + pt2)/2;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	


				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				lineSeg.Set(pt0,pt1);


				Lx.SetFromLineSeg(lineSeg);
				double dDegLx = (Lx.GetRotation().SignedNorm()).ToDouble()*180.0/skPI;

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos123_123C2L13 == m_AlignermentParam.GetAligner3Vs3Type() || eAlignerPos123_123C2TL13 == m_AlignermentParam.GetAligner3Vs3Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector ptCenter = (pt1 + pt1)/2;

				// 产品位置
				vProductPos = ptCenter;

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				double dlineSeg01Length = lineSeg01.Perimeter();	
				double dlineSeg02Length = lineSeg02.Perimeter();	

				// 构造实时mark对直线Lx
				scLine Lx;
				scLineSeg lineSeg;
				lineSeg.Set(pt0,pt2);


				Lx.SetFromLineSeg(lineSeg);

				double dDegLx = (Lx.GetRotation().SignedNorm()).ToDouble()*180.0/skPI;
				dDegLx -= 90;

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			//jjh0612
			else if (eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
				||eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type()
				||eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())  //jjh0612
			{
				if (!bAuxiliary)  //角点对位 分三种
				{
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_Auto_Weigth)//两角点中心对位
					{

						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH1X + dCH2X)/2.0;
							dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH2X)/2.0;
							dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心
							double dRotationCenterX, dRotationCenterY;
							dRotationCenterX = (dCH0X + dCH1X)/2.0;
							dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

							// 产品位置
							vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}

					}
					else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C1_Weigth) //角点1对位
					{
						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH0X, dCH0Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
					}
					else if (m_AlignermentParam.GetAligner3Vs3Type() == eAlignerPos123_123C2_Weigth)//角点2对位
					{
						if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH2X, dCH2Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH2X, dCH2Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
						else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
						{
							// 旋转中心(点1是旋转中心)
							// 产品位置
							vProductPos = sc2Vector(dCH1X, dCH1Y); 

							// 构造实时mark对直线Lx
							scLine Lx;
							scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
							Lx.SetFromLineSeg(lineSeg);

							// 产品角度
							degProductAngle = scDegree(Lx.GetRotation());
						}
					}
				}
				else  //圆心对位
				{
					svStd vector< sc2Vector > ptCenter;
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					// 圆心坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH2X, dCH2Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					// 圆点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

				}

			}
			else if (eAlignerPos123_Auto_L1C_Weigth == m_AlignermentParam.GetAligner3Vs3Type()) //jjh0619  
			{
				if (!bAuxiliary)  //角点对位 分三种
				{
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					if (bCH0_Auxiliary)  //圆在第一个位置   两个角点在第二和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH1X + dCH2X)/2.0;
						dRotationCenterY = (dCH1Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y)); //圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH1_Auxiliary)//圆在第二个位置   两个角点在第一和第三位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH2X)/2.0;
						dRotationCenterY = (dCH0Y + dCH2Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					else if (bCH2_Auxiliary)//圆在第三个位置   两个角点在第一和第二位置中
					{
						// 旋转中心
						double dRotationCenterX, dRotationCenterY;
						dRotationCenterX = (dCH0X + dCH1X)/2.0;
						dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

						// 产品位置
						vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

						// 构造实时mark对直线Lx
						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);

						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

				}
				else  //圆心对位
				{
					svStd vector< sc2Vector > ptCenter;
					// 表征圆在哪个相机中，以下变量只允许一个变量为TUE；

					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}
					// 圆心坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0X,dCH0Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

					// 圆点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1X,dCH1Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH1X, dCH1Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}
					// 圆点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2X,dCH2Y));

						scLine Lx;
						scLineSeg lineSeg(sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH0X, dCH0Y));//圆心和第一个点的连线角度
						Lx.SetFromLineSeg(lineSeg);


						// 产品位置
						vProductPos = ptCenter.at(0);
						// 产品角度
						degProductAngle = scDegree(Lx.GetRotation());
					}

				}

			}
		}
		else if (4 == m_iMarkNum)
		{
			CString str;
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
			double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
			double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;
			double dCH3X = vObjectPlatformCoordPos.at(3).m_dPosX;
			double dCH3Y = vObjectPlatformCoordPos.at(3).m_dPosY;

			// 			str.Format("vObjectPlatformCoordPos.at(0).m_dPosX=%f, vObjectPlatformCoordPos.at(0).m_dPosY=%f", vObjectPlatformCoordPos.at(0).m_dPosX, vObjectPlatformCoordPos.at(0).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(1).m_dPosX=%f, vObjectPlatformCoordPos.at(1).m_dPosY=%f", vObjectPlatformCoordPos.at(1).m_dPosX, vObjectPlatformCoordPos.at(1).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(2).m_dPosX=%f, vObjectPlatformCoordPos.at(2).m_dPosY=%f", vObjectPlatformCoordPos.at(2).m_dPosX, vObjectPlatformCoordPos.at(2).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);
			// 			str.Format("vObjectPlatformCoordPos.at(3).m_dPosX=%f, vObjectPlatformCoordPos.at(3).m_dPosY=%f", vObjectPlatformCoordPos.at(3).m_dPosX, vObjectPlatformCoordPos.at(3).m_dPosY);
			// 			AlignToolLogRecord(str,nPlatformIndex);

			if (eAlignerPos1234_Auto == m_AlignermentParam.GetAligner4Vs4Type()|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Center)
			{
// 				// PCB 定制
// 				if (m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align)
// 				{
// 					str.Format("use PCB 定制 ");
// 					AlignToolLogRecord(str,m_nPlatformIndex);
// 					// 四点对四点；四点中心为旋转中心，长边均值为角度
// 					if (eAligner1234_1234 == m_PointMethodType) 
// 					{
// 						str.Format("use eAligner1234_1234 ");
// 						AlignToolLogRecord(str,m_nPlatformIndex);
// 						// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
// 						sc2Vector pt0(dCH0X, dCH0Y);
// 						sc2Vector pt1(dCH1X, dCH1Y);
// 						sc2Vector pt2(dCH2X, dCH2Y);
// 						sc2Vector pt3(dCH3X, dCH3Y);
// 						sc2Vector pt01 = (pt0 + pt1)/2;
// 						sc2Vector pt23 = (pt2 + pt3)/2;
// 						sc2Vector pt02 = (pt0 + pt2)/2;
// 						sc2Vector pt13 = (pt1 + pt3)/2;
// 
// 						scLineSeg lineVer(pt01,pt23);
// 						scLineSeg lineHor(pt02,pt13);
// 						scLine lineV = lineVer.GetLine();
// 						scLine lineH = lineHor.GetLine();
// 
// 						svStd vector< sc2Vector > ptCenter;
// 						bool IsInterSect = true;
// 						if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
// 							return FALSE;
// 						// 旋转中心
// 						vProductPos = ptCenter.at(0);
// 
// 
// 						//各边的长度
// 						scLineSeg lineSeg01(pt0,pt1);
// 						scLineSeg lineSeg02(pt0,pt2);
// 						double dlineSeg01Length = lineSeg01.Perimeter();	
// 						double dlineSeg02Length = lineSeg02.Perimeter();	
// 						// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 						// 			AlignToolLogRecord(str,nPlatformIndex);
// 						BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 						if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 						{
// 							bHorDirection = FALSE;
// 						}
// 
// 						// 长边均值为角度；
// 						double dDegLx = 0;
// 						if (bHorDirection)
// 						{
// 							scLineSeg lineSeg01(pt0,pt1);
// 							scLineSeg lineSeg23(pt2,pt3);
// 							scLine line01;
// 							scLine line23;
// 							line01.SetFromLineSeg(lineSeg01);
// 							line23.SetFromLineSeg(lineSeg23);
// 							dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();
// 						}
// 						else
// 						{
// 							scLineSeg lineSeg02(pt0,pt2);
// 							scLineSeg lineSeg13(pt1,pt3);
// 							scLine line02;
// 							scLine line13;
// 							line02.SetFromLineSeg(lineSeg02);
// 							line13.SetFromLineSeg(lineSeg13);
// 							dDegLx = (scDegree((line02.GetRotation() + line13.GetRotation())/2)).SignedNorm().ToDouble();
// 						}
// 						// 产品角度
// 						degProductAngle = scDegree(dDegLx);
// 
// 					}
// 					// 2、3、4点组成的三角形中点为旋转中心，单长边为角度
// 					else if (eAligner234_234 == m_PointMethodType) 
// 					{
// 						str.Format("use eAligner234_234 ");
// 						AlignToolLogRecord(str,m_nPlatformIndex);
// 						// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
// 						sc2Vector pt0(dCH0X, dCH0Y);
// 						sc2Vector pt1(dCH1X, dCH1Y);
// 						sc2Vector pt2(dCH2X, dCH2Y);
// 						sc2Vector pt3(dCH3X, dCH3Y);
// 						sc2Vector ptCenter = (pt1 + pt2 + pt3)/3;					
// 						// 旋转中心
// 						vProductPos = ptCenter;
// 
// 
// 						//各边的长度
// 						scLineSeg lineSeg31(pt3,pt1);
// 						scLineSeg lineSeg32(pt3,pt2);
// 						double dlineSeg31Length = lineSeg31.Perimeter();	
// 						double dlineSeg32Length = lineSeg32.Perimeter();	
// 						// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 						// 			AlignToolLogRecord(str,nPlatformIndex);
// 						BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 						if (dlineSeg31Length > dlineSeg32Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 						{
// 							bHorDirection = FALSE;
// 						}
// 
// 						// 长边均值为角度；
// 						double dDegLx = 0;
// 						if (bHorDirection) // 2、3为长边
// 						{
// 							scLineSeg lineSeg23(pt2,pt3);
// 							scLine line23;
// 							line23.SetFromLineSeg(lineSeg23);
// 							dDegLx = (line23.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 						}else  // 1、3为长边
// 						{
// 							scLineSeg lineSeg13(pt1,pt3);
// 							scLine line13;
// 							line13.SetFromLineSeg(lineSeg13);
// 							dDegLx = (line13.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 						}
// 						// 产品角度
// 						degProductAngle = scDegree(dDegLx);	
// 					}
// 					// 1、3、4点组成的三角形中点为旋转中心，单长边为角度
// 					else if (eAligner134_134 == m_PointMethodType) 
// 					{
// 						str.Format("use eAligner134_134 ");
// 						AlignToolLogRecord(str,m_nPlatformIndex);
// 						// 旋转中心
// 						sc2Vector pt0(dCH0X, dCH0Y);
// 						sc2Vector pt1(dCH1X, dCH1Y);
// 						sc2Vector pt2(dCH2X, dCH2Y);
// 						sc2Vector pt3(dCH3X, dCH3Y);
// 						sc2Vector ptCenter = (pt0 + pt2 + pt3)/3;					
// 						// 旋转中心
// 						vProductPos = ptCenter;
// 
// 
// 						//各边的长度
// 						scLineSeg lineSeg20(pt3,pt1);
// 						scLineSeg lineSeg23(pt3,pt2);
// 						double dlineSeg20Length = lineSeg20.Perimeter();	
// 						double dlineSeg23Length = lineSeg23.Perimeter();	
// 						// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 						// 			AlignToolLogRecord(str,nPlatformIndex);
// 						BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 						if (dlineSeg20Length > dlineSeg23Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 						{
// 							bHorDirection = FALSE;
// 						}
// 
// 						// 长边均值为角度；
// 						double dDegLx = 0;
// 						if (bHorDirection) // 2、3为长边
// 						{
// 							scLineSeg lineSeg23(pt2,pt3);
// 							scLine line23;
// 							line23.SetFromLineSeg(lineSeg23);
// 							dDegLx = (line23.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 						}else  // 0、2为长边
// 						{
// 							scLineSeg lineSeg02(pt0,pt2);
// 							scLine line02;
// 							line02.SetFromLineSeg(lineSeg02);
// 							dDegLx = (line02.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 						}
// 						// 产品角度
// 						degProductAngle = scDegree(dDegLx);	
// 
// 					}
// 					//  1、2、4点组成的三角形中点为旋转中心，单长边为角度
// 					else if (eAligner124_124 == m_PointMethodType)
// 					{
// 						str.Format("use eAligner124_124 ");
// 						AlignToolLogRecord(str,m_nPlatformIndex);
// 						// 旋转中心
// 						sc2Vector pt0(dCH0X, dCH0Y);
// 						sc2Vector pt1(dCH1X, dCH1Y);
// 						sc2Vector pt2(dCH2X, dCH2Y);
// 						sc2Vector pt3(dCH3X, dCH3Y);
// 						sc2Vector ptCenter = (pt0 + pt1 + pt3)/3;					
// 						// 旋转中心
// 						vProductPos = ptCenter;
// 
// 
// 						//各边的长度
// 						scLineSeg lineSeg10(pt0,pt1);
// 						scLineSeg lineSeg13(pt3,pt1);
// 						double dlineSeg10Length = lineSeg10.Perimeter();	
// 						double dlineSeg13Length = lineSeg13.Perimeter();	
// 						// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 						// 			AlignToolLogRecord(str,nPlatformIndex);
// 						BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 						if (dlineSeg13Length > dlineSeg10Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 						{
// 							bHorDirection = FALSE;
// 						}
// 
// 						// 长边均值为角度；
// 						double dDegLx = 0;
// 						if (bHorDirection) // 0、1为长边
// 						{
// 							scLineSeg lineSeg01(pt0,pt1);
// 							scLine line01;
// 							line01.SetFromLineSeg(lineSeg01);
// 							dDegLx = (line01.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 						}else  // 1、3为长边
// 						{
// 							scLineSeg lineSeg13(pt1,pt3);
// 							scLine line13;
// 							line13.SetFromLineSeg(lineSeg13);
// 							dDegLx = (line13.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 						}
// 						// 产品角度
// 						degProductAngle = scDegree(dDegLx);	
// 					}
// 					//  1、2、3点组成的三角形中点为旋转中心，单长边为角度
// 					else if (eAligner123_123 == m_PointMethodType)
// 					{
// 						str.Format("use eAligner123_123 ");
// 						AlignToolLogRecord(str,m_nPlatformIndex);
// 						// 旋转中心
// 						sc2Vector pt0(dCH0X, dCH0Y);
// 						sc2Vector pt1(dCH1X, dCH1Y);
// 						sc2Vector pt2(dCH2X, dCH2Y);
// 						sc2Vector pt3(dCH3X, dCH3Y);
// 						sc2Vector ptCenter = (pt0 + pt1 + pt2)/3;					
// 						// 旋转中心
// 						vProductPos = ptCenter;
// 
// 
// 						//各边的长度
// 						scLineSeg lineSeg01(pt0,pt1);
// 						scLineSeg lineSeg02(pt0,pt2);
// 						double dlineSeg01Length = lineSeg01.Perimeter();	
// 						double dlineSeg02Length = lineSeg02.Perimeter();	
// 						// 			str.Format("dlineSeg01Length=%f,dlineSeg02Length=%f", dlineSeg01Length, dlineSeg02Length);
// 						// 			AlignToolLogRecord(str,nPlatformIndex);
// 						BOOL   bHorDirection = TRUE; //水平方向为Mark坐标系X轴
// 						if (dlineSeg02Length > dlineSeg01Length*1.1 /*&& (dlineSeg02Length - dlineSeg01Length > 0.5)*/)
// 						{
// 							bHorDirection = FALSE;
// 						}
// 
// 						// 长边均值为角度；
// 						double dDegLx = 0;
// 						if (bHorDirection) // 0、1为长边
// 						{
// 							scLineSeg lineSeg01(pt0,pt1);
// 							scLine line01;
// 							line01.SetFromLineSeg(lineSeg01);
// 							dDegLx = (line01.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 						}else  // 0、2为长边
// 						{
// 							scLineSeg lineSeg02(pt0,pt2);
// 							scLine line02;
// 							line02.SetFromLineSeg(lineSeg02);
// 							dDegLx = (line02.GetRotation().SignedNormMod180()).ToDouble()*180.0/skPI;
// 						}
// 						// 产品角度
// 						degProductAngle = scDegree(dDegLx);	
// 					}
// 				}
// 				// 通常流程
// 				else
				{
					// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);
					scLineSeg lineSeg12(pt1, pt2);
					scLineSeg lineSeg03(pt0, pt3);
					scLine line12 = lineSeg12.GetLine();
					scLine line03 = lineSeg03.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(line03,line12,IsInterSect,ptCenter))
						return FALSE;

					// 产品位置
					vProductPos = ptCenter.at(0);


					//各边的长度
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg02(pt0,pt2);

					scLine line01;
					scLine line02;

					line01.SetFromLineSeg(lineSeg01);
					line02.SetFromLineSeg(lineSeg02);

					double dDegLx = 0;
					dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();


					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
			}
			else if (eAlignerPos1234_123C1 == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);				

				svStd vector< sc2Vector > ptCenter;
				ptCenter.push_back(pt0);

				// 产品位置
				vProductPos = ptCenter.at(0);

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				scLine line01;
				scLine line02;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

				// 产品角度
				degProductAngle = scDegree(dDegLx);

			}
			else if (eAlignerPos1234_124C2 == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				svStd vector< sc2Vector > ptCenter;
				ptCenter.push_back(pt1);

				// 产品位置
				vProductPos = ptCenter.at(0);

				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt1,pt3);

				scLine line01;
				scLine line02;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos1234_134C3 == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				svStd vector< sc2Vector > ptCenter;
				ptCenter.push_back(pt2);


				// 产品位置
				vProductPos = ptCenter.at(0);


				//各边的长度
				scLineSeg lineSeg01(pt2,pt3);
				scLineSeg lineSeg02(pt0,pt2);

				scLine line01;
				scLine line02;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (eAlignerPos1234_234C4 == m_AlignermentParam.GetAligner4Vs4Type())
			{
				// 旋转中心
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				svStd vector< sc2Vector > ptCenter;
				ptCenter.push_back(pt3);

				// 产品位置
				vProductPos = ptCenter.at(0);

				//各边的长度
				scLineSeg lineSeg01(pt2,pt3);
				scLineSeg lineSeg02(pt1,pt3);

				scLine line01;
				scLine line02;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine 
				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_4Vs4
				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Target_4Vs4
				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Combine_Object_4Vs4
				|| m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_Center)
			{
				// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);

				sc2Vector pt01 = (pt0 + pt1)/2;
				sc2Vector pt23 = (pt2 + pt3)/2;
				sc2Vector pt02 = (pt0 + pt2)/2;
				sc2Vector pt13 = (pt1 + pt3)/2;
				scLineSeg lineVer(pt01,pt23);
				scLineSeg lineHor(pt02,pt13);
				scLine lineV = lineVer.GetLine();
				scLine lineH = lineHor.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
					return FALSE;
				// 产品位置
				vProductPos = ptCenter.at(0);

				//各边的长度
				double d1,d2;
				if(false == sfDistancePoint2Point(pt0,pt1,d1))
					return FALSE;
				if(false == sfDistancePoint2Point(pt0,pt2,d2))
					return FALSE;

				str.Format("pt0到pt1距离=%f,pt0到pt2距离=%f",d1,d2);
				AlignToolLogRecord(str, m_nPlatformIndex);
				double dDegLx = 0;
				if(d1>d2)
				{
					scLineSeg lineSeg01(pt0,pt1);
					scLineSeg lineSeg23(pt2,pt3);

					scLine line01;
					scLine line23;

					line01.SetFromLineSeg(lineSeg01);
					line23.SetFromLineSeg(lineSeg23);

					dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();

				}
				else
				{
					scLineSeg lineSeg13(pt1,pt3);
					scLineSeg lineSeg02(pt0,pt2);

					scLine line13;
					scLine line02;

					line13.SetFromLineSeg(lineSeg13);
					line02.SetFromLineSeg(lineSeg02);

					dDegLx = (scDegree((line13.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

				}
				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
			else if (m_AlignermentParam.GetAligner4Vs4Type() == eAlignerPos1234_56_4V2)
			{
				if (bCurObject)
				{
					// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					sc2Vector pt01 = (pt0 + pt1)/2;
					sc2Vector pt23 = (pt2 + pt3)/2;
					sc2Vector pt02 = (pt0 + pt2)/2;
					sc2Vector pt13 = (pt1 + pt3)/2;
					scLineSeg lineVer(pt01,pt23);
					scLineSeg lineHor(pt02,pt13);
					scLine lineV = lineVer.GetLine();
					scLine lineH = lineHor.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
						return FALSE;
					// 产品位置
					vProductPos = ptCenter.at(0);

					double dDegLx = 0;

					{
						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg23(pt2,pt3);

						scLine line01;
						scLine line23;

						line01.SetFromLineSeg(lineSeg01);
						line23.SetFromLineSeg(lineSeg23);

						dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();

					}

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				else
				{
					// 旋转中心
					double dRotationCenterX, dRotationCenterY;
					dRotationCenterX = (dCH0X + dCH1X)/2.0;
					dRotationCenterY = (dCH0Y + dCH1Y)/2.0;

					// 产品位置
					vProductPos = sc2Vector(dRotationCenterX, dRotationCenterY);

					// 构造实时mark对直线Lx
					scLine Lx;
					scLineSeg lineSeg(sc2Vector(dCH0X, dCH0Y), sc2Vector(dCH1X, dCH1Y));
					Lx.SetFromLineSeg(lineSeg);

					// 产品角度
					degProductAngle = scDegree(Lx.GetRotation());
				}


			}
			//////////////////////////////////////iyo
			//长边对位角度，四个位置组合构成直线，四边中点（X1,Y1）+ 圆（X2,Y2），根据权重系数计算（X,Y）
			else if (eAlignerPos1234_Combine_Weight == m_AlignermentParam.GetAligner4Vs4Type())
			{
				double dDegLx = 0;  // 共用角度 iyo
				// 平台坐标
				if (bAuxiliary == FALSE)
				{
					// 旋转中心(点01组成的线段中点与23组成的线段中点构成竖直线L1；点02组成的线段中点与13组成的线段中点构成竖直线L2，L1与L2交点是旋转中心)
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					sc2Vector pt01 = (pt0 + pt1)/2;
					sc2Vector pt23 = (pt2 + pt3)/2;
					sc2Vector pt02 = (pt0 + pt2)/2;
					sc2Vector pt13 = (pt1 + pt3)/2;
					scLineSeg lineVer(pt01,pt23);
					scLineSeg lineHor(pt02,pt13);
					scLine lineV = lineVer.GetLine();
					scLine lineH = lineHor.GetLine();
					svStd vector< sc2Vector > ptCenter;
					bool IsInterSect = true;
					if (false == sfInterSectLineLine(lineV,lineH,IsInterSect,ptCenter))
						return FALSE;
					// 产品位置
					vProductPos = ptCenter.at(0);

					//各边的长度
					double d1,d2;
					if(false == sfDistancePoint2Point(pt0,pt1,d1))
						return FALSE;
					if(false == sfDistancePoint2Point(pt0,pt2,d2))
						return FALSE;

					str.Format("pt0到pt1距离=%f,pt0到pt2距离=%f",d1,d2);
					AlignToolLogRecord(str, m_nPlatformIndex);
					//double dDegLx = 0;
					if(d1>d2)
					{
						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg23(pt2,pt3);

						scLine line01;
						scLine line23;

						line01.SetFromLineSeg(lineSeg01);
						line23.SetFromLineSeg(lineSeg23);

						dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();

					}
					else
					{
						scLineSeg lineSeg13(pt1,pt3);
						scLineSeg lineSeg02(pt0,pt2);

						scLine line13;
						scLine line02;

						line13.SetFromLineSeg(lineSeg13);
						line02.SetFromLineSeg(lineSeg02);

						dDegLx = (scDegree((line13.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

					}
					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}
				// 辅助点平台坐标
				else
				{
					// 旋转中心
					sc2Vector pt0(dCH0X, dCH0Y);
					sc2Vector pt1(dCH1X, dCH1Y);
					sc2Vector pt2(dCH2X, dCH2Y);
					sc2Vector pt3(dCH3X, dCH3Y);

					double d1,d2;
					if(false == sfDistancePoint2Point(pt0,pt1,d1))
						return FALSE;
					if(false == sfDistancePoint2Point(pt0,pt2,d2))
						return FALSE;
					if(d1>d2)
					{
						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg23(pt2,pt3);
						scLine line01;
						scLine line23;
						line01.SetFromLineSeg(lineSeg01);
						line23.SetFromLineSeg(lineSeg23);
						dDegLx = (scDegree((line01.GetRotation() + line23.GetRotation())/2)).SignedNorm().ToDouble();
					}
					else
					{
						scLineSeg lineSeg13(pt1,pt3);
						scLineSeg lineSeg02(pt0,pt2);
						scLine line13;
						scLine line02;
						line13.SetFromLineSeg(lineSeg13);
						line02.SetFromLineSeg(lineSeg02);
						dDegLx = (scDegree((line13.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					}

					double dCH0_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(0);
					double dCH0_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(0);
					double dCH0_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(1);
					double dCH0_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(1);
					double dCH0_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosX.at(2);
					double dCH0_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(0).m_vdAuxiliaryPosY.at(2);

					double dCH1_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(0);
					double dCH1_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(0);
					double dCH1_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(1);
					double dCH1_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(1);
					double dCH1_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosX.at(2);
					double dCH1_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(1).m_vdAuxiliaryPosY.at(2);

					double dCH2_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(0);
					double dCH2_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(0);
					double dCH2_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(1);
					double dCH2_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(1);
					double dCH2_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosX.at(2);
					double dCH2_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(2).m_vdAuxiliaryPosY.at(2);

					double dCH3_AuxiliaryPosX0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(0);
					double dCH3_AuxiliaryPosY0 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(0);
					double dCH3_AuxiliaryPosX1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(1);
					double dCH3_AuxiliaryPosY1 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(1);
					double dCH3_AuxiliaryPosX2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosX.at(2);
					double dCH3_AuxiliaryPosY2 = vObjectPlatformCoordPos.at(3).m_vdAuxiliaryPosY.at(2);


					svStd vector< sc2Vector > ptCenter;
					//double dDegLx = 0;

					// 表征圆辅助点在哪个相机中，以下变量只允许一个变量为TUE；
					BOOL bCH0_Auxiliary = FALSE;
					BOOL bCH1_Auxiliary = FALSE;
					BOOL bCH2_Auxiliary = FALSE;
					BOOL bCH3_Auxiliary = FALSE;

					int nPos = m_AlignermentParam.GetAlignerCirclePos();

					switch(nPos)
					{
					case 0:
						bCH0_Auxiliary = TRUE;
						break;
					case 1:
						bCH1_Auxiliary = TRUE;
						break;
					case 2:
						bCH2_Auxiliary = TRUE;
						break;
					case 3:
						bCH3_Auxiliary = TRUE;
						break;
					default:
						bCH0_Auxiliary = TRUE;
						break;
					}

					// 圆辅助点坐标在相机CH0中
					if (bCH0_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));

						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg02(pt0,pt2);

						scLine line01;
						scLine line02;

						line01.SetFromLineSeg(lineSeg01);
						line02.SetFromLineSeg(lineSeg02);

						double dClrcleToLineX = pt2.GetX() - dCH2_AuxiliaryPosX2;
						double dClrcleToLineY = pt2.GetY() - dCH2_AuxiliaryPosY2;
						str.Format("圆孔在位置%d,到临边的距离：X = %f,Y = %f,",nPos+1,dClrcleToLineX,dClrcleToLineY);
						AlignToolLogRecord(str, m_nPlatformIndex);

						dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					}

					// 圆辅助点坐标在相机CH1中
					if (bCH1_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));

						scLineSeg lineSeg01(pt0,pt1);
						scLineSeg lineSeg02(pt1,pt3);

						scLine line01;
						scLine line02;

						line01.SetFromLineSeg(lineSeg01);
						line02.SetFromLineSeg(lineSeg02);

						double dClrcleToLineX = pt2.GetX() - dCH2_AuxiliaryPosX2;
						double dClrcleToLineY = pt2.GetY() - dCH2_AuxiliaryPosY2;
						str.Format("圆孔在位置%d,到临边的距离：X = %f,Y = %f,",nPos+1,dClrcleToLineX,dClrcleToLineY);
						AlignToolLogRecord(str, m_nPlatformIndex);
						dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					}

					// 圆辅助点坐标在相机CH2中
					if (bCH2_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2));

						scLineSeg lineSeg01(pt2,pt3);
						scLineSeg lineSeg02(pt0,pt2);

						scLineSeg lineSeg23(pt2,pt3);  //iyo
						scLine line01;
						scLine line02;
						scLine line23;    //iyo

						line01.SetFromLineSeg(lineSeg01);
						line02.SetFromLineSeg(lineSeg02);
						line23.SetFromLineSeg(lineSeg23);
						sc2Vector ProjectToLx02, ProjectToLy23;//iyo
						ProjectToLx02 = line02.Project(ptCenter.at(0));  // 圆心到02点的垂足，x方向-iyo,
						ProjectToLy23 = line23.Project(ptCenter.at(0));// 圆心到23点的垂足-iyo
						scLineSeg lineSegX(ptCenter.at(0),ProjectToLx02);
						scLineSeg lineSegY(ptCenter.at(0),ProjectToLy23);
						str.Format("圆孔在位置%d,到临边的距离：X = %f,Y = %f,",nPos+1,lineSegX.Perimeter(),lineSegY.Perimeter());
						AlignToolLogRecord(str, m_nPlatformIndex);
						AlignToolLogRecord(str,6);//iyo
						//dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();

						double dClrcleToLineX = pt2.GetX() - dCH2_AuxiliaryPosX2;
						double dClrcleToLineY = pt2.GetY() - dCH2_AuxiliaryPosY2;
						str.Format("位置%d处圆孔：X = %f,Y = %f,",nPos+1,dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2);
						AlignToolLogRecord(str, m_nPlatformIndex);
						str.Format("圆孔在位置%d,到临点的距离：X = %f,Y = %f,",nPos+1,dClrcleToLineX,dClrcleToLineY);
						AlignToolLogRecord(str, m_nPlatformIndex);
					}

					// 圆辅助点坐标在相机CH3中
					if (bCH3_Auxiliary)
					{
						ptCenter.push_back(sc2Vector(dCH3_AuxiliaryPosX2,dCH3_AuxiliaryPosY2));

						scLineSeg lineSeg01(pt2,pt3);
						scLineSeg lineSeg02(pt1,pt3);

						scLine line01;
						scLine line02;

						line01.SetFromLineSeg(lineSeg01);
						line02.SetFromLineSeg(lineSeg02);
						double dClrcleToLineX = pt2.GetX() - dCH2_AuxiliaryPosX2;
						double dClrcleToLineY = pt2.GetY() - dCH2_AuxiliaryPosY2;
						str.Format("圆孔在位置%d,到临边的距离：X = %f,Y = %f,",nPos+1,dClrcleToLineX,dClrcleToLineY);
						AlignToolLogRecord(str, m_nPlatformIndex);

						dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					}

					// 						if ( (dCH0_AuxiliaryPosX2 != dCH0_AuxiliaryPosX2) || (dCH0_AuxiliaryPosY2 != dCH0_AuxiliaryPosY2) )
					// 						{
					// 							ptCenter.push_back(sc2Vector(dCH0_AuxiliaryPosX2,dCH0_AuxiliaryPosY2));
					// 
					// 							scLineSeg lineSeg01(pt0,pt1);
					// 							scLineSeg lineSeg02(pt0,pt2);
					// 
					// 							scLine line01;
					// 							scLine line02;
					// 
					// 							line01.SetFromLineSeg(lineSeg01);
					// 							line02.SetFromLineSeg(lineSeg02);
					// 
					// 
					// 							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					// 
					// 
					// 						}
					// 						else if ( (dCH1_AuxiliaryPosX2 != dCH1_AuxiliaryPosX2) || (dCH1_AuxiliaryPosY2 != dCH1_AuxiliaryPosY2) )
					// 						{
					// 							ptCenter.push_back(sc2Vector(dCH1_AuxiliaryPosX2,dCH1_AuxiliaryPosY2));
					// 
					// 							scLineSeg lineSeg01(pt0,pt1);
					// 							scLineSeg lineSeg02(pt1,pt3);
					// 
					// 							scLine line01;
					// 							scLine line02;
					// 
					// 							line01.SetFromLineSeg(lineSeg01);
					// 							line02.SetFromLineSeg(lineSeg02);
					// 
					// 							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					// 
					// 						}
					// 						else if ( (dCH2_AuxiliaryPosX2 != dCH2_AuxiliaryPosX2) || (dCH2_AuxiliaryPosY2 != dCH2_AuxiliaryPosY2) )
					// 						{
					// 							ptCenter.push_back(sc2Vector(dCH2_AuxiliaryPosX2,dCH2_AuxiliaryPosY2));
					// 
					// 							scLineSeg lineSeg01(pt2,pt3);
					// 							scLineSeg lineSeg02(pt0,pt2);
					// 
					// 							scLine line01;
					// 							scLine line02;
					// 
					// 							line01.SetFromLineSeg(lineSeg01);
					// 							line02.SetFromLineSeg(lineSeg02);
					// 
					// 							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					// 
					// 						}
					// 						else if ( (dCH3_AuxiliaryPosX2 != dCH3_AuxiliaryPosX2) || (dCH3_AuxiliaryPosY2 != dCH3_AuxiliaryPosY2) )
					// 						{
					// 							ptCenter.push_back(sc2Vector(dCH3_AuxiliaryPosX2,dCH3_AuxiliaryPosY2));
					// 
					// 							scLineSeg lineSeg01(pt2,pt3);
					// 							scLineSeg lineSeg02(pt1,pt3);
					// 
					// 							scLine line01;
					// 							scLine line02;
					// 
					// 							line01.SetFromLineSeg(lineSeg01);
					// 							line02.SetFromLineSeg(lineSeg02);
					// 
					// 							dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();
					// 						}
					// 						else
					// 						{				
					// 							ptCenter.push_back(sc2Vector(0, 0));
					// 
					// 							dDegLx = 0;
					// 						}


					// 产品位置
					vProductPos = ptCenter.at(0);

					// 产品角度
					degProductAngle = scDegree(dDegLx);
				}


			}
			////////////////////////////////////////////iyo
			else
			{
				// 旋转中心(点12组成的直线，过点03组成的直线的交点是旋转中心)
				sc2Vector pt0(dCH0X, dCH0Y);
				sc2Vector pt1(dCH1X, dCH1Y);
				sc2Vector pt2(dCH2X, dCH2Y);
				sc2Vector pt3(dCH3X, dCH3Y);
				scLineSeg lineSeg12(pt1, pt2);
				scLineSeg lineSeg03(pt0, pt3);
				scLine line12 = lineSeg12.GetLine();
				scLine line03 = lineSeg03.GetLine();
				svStd vector< sc2Vector > ptCenter;
				bool IsInterSect = true;
				if (false == sfInterSectLineLine(line03,line12,IsInterSect,ptCenter))
					return FALSE;

				// 产品位置
				vProductPos = ptCenter.at(0);


				//各边的长度
				scLineSeg lineSeg01(pt0,pt1);
				scLineSeg lineSeg02(pt0,pt2);

				scLine line01;
				scLine line02;

				line01.SetFromLineSeg(lineSeg01);
				line02.SetFromLineSeg(lineSeg02);

				double dDegLx = 0;
				dDegLx = (scDegree((line01.GetRotation() + line02.GetRotation())/2)).SignedNorm().ToDouble();


				// 产品角度
				degProductAngle = scDegree(dDegLx);
			}
		}
		else if (5 == m_iMarkNum)
		{
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
			double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
			double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;
			double dCH3X = vObjectPlatformCoordPos.at(3).m_dPosX;
			double dCH3Y = vObjectPlatformCoordPos.at(3).m_dPosY;
			double dCH4X = vObjectPlatformCoordPos.at(4).m_dPosX;
			double dCH4Y = vObjectPlatformCoordPos.at(4).m_dPosY;


			// 旋转中心
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector pt3(dCH3X, dCH3Y);
			sc2Vector pt4(dCH4X, dCH4Y);
			scLineSeg lineSeg23(pt2, pt3);

			scLine line23 = lineSeg23.GetLine();
			sc2Vector ptCenter = line23.Project(pt4);

			// 产品位置
			vProductPos = ptCenter;

			// 构造实时mark对直线Lx
			scLine Lx;
			scLineSeg lineSeg( sc2Vector(dCH2X, dCH2Y), sc2Vector(dCH3X, dCH3Y));
			Lx.SetFromLineSeg(lineSeg);
			double dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}
		else if (6 == m_iMarkNum)
		{
			double dCH0X = vObjectPlatformCoordPos.at(0).m_dPosX;
			double dCH0Y = vObjectPlatformCoordPos.at(0).m_dPosY;
			double dCH1X = vObjectPlatformCoordPos.at(1).m_dPosX;
			double dCH1Y = vObjectPlatformCoordPos.at(1).m_dPosY;
			double dCH2X = vObjectPlatformCoordPos.at(2).m_dPosX;
			double dCH2Y = vObjectPlatformCoordPos.at(2).m_dPosY;
			double dCH3X = vObjectPlatformCoordPos.at(3).m_dPosX;
			double dCH3Y = vObjectPlatformCoordPos.at(3).m_dPosY;
			double dCH4X = vObjectPlatformCoordPos.at(4).m_dPosX;
			double dCH4Y = vObjectPlatformCoordPos.at(4).m_dPosY;
			double dCH5X = vObjectPlatformCoordPos.at(5).m_dPosX;
			double dCH5Y = vObjectPlatformCoordPos.at(5).m_dPosY;


			// 旋转中心)
			sc2Vector pt0(dCH0X, dCH0Y);
			sc2Vector pt1(dCH1X, dCH1Y);
			sc2Vector pt2(dCH2X, dCH2Y);
			sc2Vector pt3(dCH3X, dCH3Y);
			sc2Vector pt4(dCH4X, dCH4Y);
			sc2Vector pt5(dCH5X, dCH5Y);

			scLineSeg lineSeg01(pt0, pt1);
			scLineSeg lineSeg23(pt2, pt3);
			scLine line01 = lineSeg01.GetLine();
			scLine line23 = lineSeg23.GetLine();

			sc2Vector ptProjectX= line01.Project(pt5);
			sc2Vector ptProjectY = line23.Project(pt4);
			sc2Vector ptCenter(ptProjectX.GetX(), ptProjectY.GetY());

			// 产品位置
			vProductPos = ptCenter;

			// 构造实时mark对直线Lx
			scLine L23,Lx;
			L23.SetFromLineSeg(lineSeg23);
			sc2Vector PtCenter = L23.Project(sc2Vector(dCH4X, dCH4Y));
			scLineSeg lineSeg(PtCenter, sc2Vector(dCH4X, dCH4Y));
			Lx.SetFromLineSeg(lineSeg);		
			double dDegLx = (Lx.GetRotation()).ToDouble()*180.0/skPI;

			// 产品角度
			degProductAngle = scDegree(dDegLx);
		}

		return TRUE;
	}
}


// 根据对象平台位置、目标平台位置、Mark数量、对位模式、平台类型，
// 计算产品偏差、平台偏移量，以及对位调整后临时理论的对象平台位置和目标平台位置
BOOL vcBaseAlignTool::GetAlginOffset(
	std::vector<CCoordPos> vcpObjectPlatformPos,
	std::vector<CCoordPos> vcpTargetPlatformPos,
	CCoordPos& cpProductOffset,
	CCoordPos& cpPlatformOffset,
	std::vector<CCoordPos>& vcpAlginedObjectPlatformPos,
	std::vector<CCoordPos>& vcpAlginedTargetPlatformPos)
{
	CString str;
	str.Format("GetAlginOffset Begin");
	AlignToolLogRecord(str,m_nPlatformIndex);

	for (int i=0;i<vcpObjectPlatformPos.size();i++)
	{
		str.Format("对象%d平台坐标 X=%f,Y=%f",i,vcpObjectPlatformPos.at(i).GetPosX(),vcpObjectPlatformPos.at(i).GetPosY());
		AlignToolLogRecord(str, m_nPlatformIndex);
	}

	for (int i=0;i<vcpTargetPlatformPos.size();i++)
	{
		str.Format("目标%d平台坐标 X=%f,Y=%f",i,vcpTargetPlatformPos.at(i).GetPosX(),vcpTargetPlatformPos.at(i).GetPosY());
		AlignToolLogRecord(str, m_nPlatformIndex);
	}

	scDegree degProductOffsetD;		// 产品角度偏差	
	sc2Vector vProductOffsetXY;		// 产品XY偏移量

	scDegree degPlatformOffsetD;	// 平台角度偏量
	sc2Vector vPlatformOffsetXY;	// 平台XY偏移量

	// 根据对位模式、平台类型等信息进行对位

	// 最优化方法(对位完成后，对象与目标的所有相应对位点的距离平方和最小)
	if (     (FALSE == m_bTargetObjectCamSeparate && 3 == m_iMarkNum && eAlignerPos123_Auto == m_AlignermentParam.GetAligner3Vs3Type())
		||   (FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum && eAlignerPos1234_Auto == m_AlignermentParam.GetAligner4Vs4Type())
		||   (FALSE == m_bTargetObjectCamSeparate && 5 == m_iMarkNum && eAlignerPos12345_Auto == m_AlignermentParam.GetAligner5Vs5Type())
		||   (FALSE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum && eAlignerPos123456_Auto == m_AlignermentParam.GetAligner6Vs6Type())
		||   (TRUE ==  m_bTargetObjectCamSeparate && 6 == m_iMarkNum && eAlignerPos123_Auto == m_AlignermentParam.GetAligner3Vs3Type())
		||   (TRUE ==  m_bTargetObjectCamSeparate && 8 == m_iMarkNum && eAlignerPos1234_Auto == m_AlignermentParam.GetAligner4Vs4Type() /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/)
		|| (((TRUE ==  m_bTargetObjectCamSeparate && 8 == m_iMarkNum)||(FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)) /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/
		&& (eAlignerPos1234_Combine_4Vs4		== m_AlignermentParam.GetAligner4Vs4Type()
		||  eAlignerPos1234_Combine_Target_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type()
		||  eAlignerPos1234_Combine_Object_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type())))
	{
// 		// PCB 定制
// 		if (m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align && 4 == m_iMarkNum)
// 		{
// 
// 			str.Format("m_bShowPCB4To3Align:%d,m_PointMethodType:%d",m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align,m_PointMethodType);
// 			AlignToolLogRecord(str,m_nPlatformIndex);
// 
// 			int nPosNumber = vcpObjectPlatformPos.size();		
// 
// 			std::vector<CCoordPos> vcpTempObjectPlatformPos;
// 			std::vector<CCoordPos> vcpTempTargetPlatformPos;
// 
// 			// 1.记录对象位置和目标位置		
// 			int i=0;
// 			for (i=0;i<nPosNumber;i++)
// 			{
// 				if ((i==0 && m_PointMethodType==eAligner234_234)||(i==1 && m_PointMethodType==eAligner134_134) ||(i==2 && m_PointMethodType==eAligner124_124)||(i==3 && m_PointMethodType==eAligner123_123))
// 				{
// 					continue;
// 				}
// 
// 				vcpTempObjectPlatformPos.push_back(vcpObjectPlatformPos.at(i));
// 				vcpTempTargetPlatformPos.push_back(vcpTargetPlatformPos.at(i));
// 			}
// 
// 			if (!GetAlginOffset_Optimize(vcpObjectPlatformPos,vcpTargetPlatformPos,vProductOffsetXY,degProductOffsetD,vPlatformOffsetXY,degPlatformOffsetD))
// 			{
// 				return FALSE;
// 			}
// 		}
// 		// 非PCB定制，正常流程
// 		else
		{
			if (!GetAlginOffset_Optimize(vcpObjectPlatformPos,vcpTargetPlatformPos,vProductOffsetXY,degProductOffsetD,vPlatformOffsetXY,degPlatformOffsetD))
			{
				return FALSE;
			}
		}
	}
	// 最优化方法+权重(几何方法)
	else if (((TRUE == m_bTargetObjectCamSeparate && 8 == m_iMarkNum )||(FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)) && (eAlignerPos1234_1234_Weight == m_AlignermentParam.GetAligner4Vs4Type()) /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/)
	{
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 1.最优化方法，通过角点，计算位置XY和角度
		scDegree  degTempProductOffsetD_Base = scDegree(0);			// 产品偏差Angle
		sc2Vector vTempProductOffsetXY_Base = sc2Vector(0, 0);		// 产品偏差XY

		scDegree  degTempPlatformOffsetD_Base = scDegree(0);		// 平台偏移量Angle
		sc2Vector vTempPlatformOffsetXY_Base = sc2Vector(0, 0);		// 平台偏移量XY

		// 1.1计算产品角度、XY偏差，计算角度、XY平台偏移量
		if (!GetAlginOffset_Optimize(vcpObjectPlatformPos, vcpTargetPlatformPos, 
			vTempProductOffsetXY_Base, degTempProductOffsetD_Base, vTempPlatformOffsetXY_Base, degTempPlatformOffsetD_Base))
		{
			return FALSE;
		}

		str.Format("(基础点)XYD方向产品偏差(目标位置-对象位置) X=%f,Y=%f,D=%f",
			vTempProductOffsetXY_Base.GetX(),vTempProductOffsetXY_Base.GetY(),degTempProductOffsetD_Base.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		str.Format("(基础点)XYD方向平台移动量 X=%f,Y=%f,D=%f",
			vTempPlatformOffsetXY_Base.GetX(),vTempPlatformOffsetXY_Base.GetY(),degTempPlatformOffsetD_Base.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 2.几何方法，根据权重点，计算位置XY（角度按照上一步骤给出）	
		scDegree  degTempProductOffsetD_Weight = scDegree(0);			// 产品偏差Angle
		sc2Vector vTempProductOffsetXY_Weight = sc2Vector(0, 0);		// 产品偏差XY

		scDegree  degTempPlatformOffsetD_Weight = scDegree(0);			// 产品偏移量Angle
		sc2Vector vTempPlatformOffsetXY_Weight = sc2Vector(0, 0);		// 平台偏移量XY

		// 2.1获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Weight;
		scDegree  degProductObjectAngle_Weight;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Weight, degProductObjectAngle_Weight, TRUE);
		str.Format("产品(权重点)的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Weight.GetX(),vProductObjectPos_Weight.GetY(),degProductObjectAngle_Weight.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.2获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Weight;
		scDegree  degProductTargetAngle_Weight;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Weight, degProductTargetAngle_Weight, TRUE);
		str.Format("产品(权重点)的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Weight.GetX(),vProductTargetPos_Weight.GetY(),degProductTargetAngle_Weight.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.3计算产品角度、XY偏差(辅助圆)
		if(!GetAlginOffset_Geometry(vProductObjectPos_Weight, degProductObjectAngle_Weight, vProductTargetPos_Weight, degProductTargetAngle_Weight,
			vTempProductOffsetXY_Weight, degTempProductOffsetD_Weight, vTempPlatformOffsetXY_Weight, degTempPlatformOffsetD_Weight))
		{
			return FALSE;
		}

		// 2.4计算角度、XY平台偏移量（辅助圆）
		sc2Vector vTempProductTargetPos_Weight;			// 临时目标位置
		scDegree  vTempProductTargetAngle_Weight;		// 临时目标角度
		sc2Vector vTempProductObjectPos_Weight;			// 临时对象位置
		scDegree  vTempProductObjectAngle_Weight;		// 临时对象角度

		// 按照步骤1计算得到的角度，旋转对象或目标（根据平台类型），然后计算得到新的XY平台偏移量
		if (!PlatformTransform(vProductObjectPos_Weight, degProductObjectAngle_Weight, vProductTargetPos_Weight, degProductTargetAngle_Weight,
			degTempPlatformOffsetD_Base, sc2Vector(0,0),
			vTempProductObjectPos_Weight, vTempProductObjectAngle_Weight, vTempProductTargetPos_Weight, vTempProductTargetAngle_Weight))
		{
			return FALSE;
		}
		// 计算得到的角度，XY偏移量
		degTempPlatformOffsetD_Weight = degTempPlatformOffsetD_Base;
		vTempPlatformOffsetXY_Weight = vTempProductTargetPos_Weight - vTempProductObjectPos_Weight;

		str.Format("(权重点)XYD方向产品偏差(目标位置-对象位置) X=%f,Y=%f,D=%f",
			vTempProductOffsetXY_Weight.GetX(),vTempProductOffsetXY_Weight.GetY(),degTempProductOffsetD_Weight.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		str.Format("(权重点)XYD方向平台移动量 X=%f,Y=%f,D=%f",
			vTempPlatformOffsetXY_Weight.GetX(),vTempPlatformOffsetXY_Weight.GetY(),degTempPlatformOffsetD_Weight.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 3.综合上述两种方法，根据权重，计算得到位置偏差XY和角度偏差
		double dCircleWeight = m_AlignermentParam.m_dAlignerWeight;

		str.Format("权重系数: %f",dCircleWeight);
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 产品偏差量
		degProductOffsetD = degTempProductOffsetD_Base;
		vProductOffsetXY = vTempProductOffsetXY_Base * (1 - dCircleWeight) + vTempProductOffsetXY_Weight * dCircleWeight;

		// 平台偏差量
		degPlatformOffsetD = degTempPlatformOffsetD_Base;
		vPlatformOffsetXY = vTempPlatformOffsetXY_Base * (1 - dCircleWeight) + vTempPlatformOffsetXY_Weight * dCircleWeight;

	}
	// 几何方法+权重(几何方法)
	else if ((((TRUE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 2 == m_iMarkNum))&& eAlignerPos12_Auto_Weigth == m_AlignermentParam.GetAligner2Vs2Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 2 == m_iMarkNum))&& eAlignerPos12_12C1_Weigth == m_AlignermentParam.GetAligner2Vs2Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 2 == m_iMarkNum))&& eAlignerPos12_12C2_Weigth == m_AlignermentParam.GetAligner2Vs2Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 3 == m_iMarkNum))&& eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 3 == m_iMarkNum))&& eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 3 == m_iMarkNum))&& eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 8 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum))&& (eAlignerPos1234_Combine_Weight == m_AlignermentParam.GetAligner4Vs4Type()) /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/))
	{
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 1.几何方法，根据角点，计算位置XY和角度
		scDegree degTempProductOffsetD_Base = scDegree(0);			 // 产品偏差Angle
		sc2Vector vTempProductOffsetXY_Base = sc2Vector(0, 0);		 // 产品偏差XY

		scDegree  degTempPlatformOffsetD_Base = scDegree(0);		 // 平台偏移量Angle
		sc2Vector vTempPlatformOffsetXY_Base = sc2Vector(0, 0);		 // 平台偏移量XY

		// 1.1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Base;
		scDegree  degProductObjectAngle_Base;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Base, degProductObjectAngle_Base);
		str.Format("产品(基础点)的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Base.GetX(),vProductObjectPos_Base.GetY(),degProductObjectAngle_Base.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 1.2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Base;
		scDegree  degProductTargetAngle_Base;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Base, degProductTargetAngle_Base);
		str.Format("产品(基础点)的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Base.GetX(),vProductTargetPos_Base.GetY(),degProductTargetAngle_Base.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 1.3计算产品角度、XY偏差，计算角度、XY平台偏移量
		if(!GetAlginOffset_Geometry(vProductObjectPos_Base, degProductObjectAngle_Base, vProductTargetPos_Base, degProductTargetAngle_Base,
			vTempProductOffsetXY_Base, degTempProductOffsetD_Base, vTempPlatformOffsetXY_Base, degTempPlatformOffsetD_Base))
		{
			return FALSE;
		}

		str.Format("(基础点)XYD方向产品偏差(目标位置-对象位置) X=%f,Y=%f,D=%f",
			vTempProductOffsetXY_Base.GetX(),vTempProductOffsetXY_Base.GetY(),degTempProductOffsetD_Base.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		str.Format("(基础点)XYD方向平台移动量 X=%f,Y=%f,D=%f",
			vTempPlatformOffsetXY_Base.GetX(),vTempPlatformOffsetXY_Base.GetY(),degTempPlatformOffsetD_Base.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 2.几何方法，根据权重点，计算位置XY（角度按照上一步骤给出）		
		// 圆辅助点平台坐标
		scDegree degTempProductOffsetD_Weight = scDegree(0);			   // 产品偏差Angle
		sc2Vector vTempProductOffsetXY_Weight = sc2Vector(0, 0);		   // 产品偏差XY

		scDegree  degTempPlatformOffsetD_Weight = scDegree(0);			   // 平台偏移量Angle
		sc2Vector vTempPlatformOffsetXY_Weight = sc2Vector(0, 0);		   // 平台偏移量XY

		// 辅助点坐标（圆）
		// 2.1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Weight;
		scDegree  degProductObjectAngle_Weight;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Weight, degProductObjectAngle_Weight, TRUE);
		str.Format("产品(权重点)的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Weight.GetX(),vProductObjectPos_Weight.GetY(),degProductObjectAngle_Weight.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Weight;
		scDegree  degProductTargetAngle_Weight;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Weight, degProductTargetAngle_Weight, TRUE);
		str.Format("产品(权重点)的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Weight.GetX(),vProductTargetPos_Weight.GetY(),degProductTargetAngle_Weight.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.3.计算产品角度、XY偏差
		if(!GetAlginOffset_Geometry(vProductObjectPos_Weight, degProductObjectAngle_Weight, vProductTargetPos_Weight, degProductTargetAngle_Weight,
			vTempProductOffsetXY_Weight, degTempProductOffsetD_Weight, vTempPlatformOffsetXY_Weight, degTempPlatformOffsetD_Weight))
		{
			return FALSE;
		}

		// 2.4计算角度、XY平台偏移量（辅助圆）
		sc2Vector vTempProductTargetPos_Weight;			// 临时目标位置
		scDegree  vTempProductTargetAngle_Weight;		// 临时目标角度		
		sc2Vector vTempProductObjectPos_Weight;			// 临时对象位置
		scDegree  vTempProductObjectAngle_Weight;		// 临时对象角度

		// 按照步骤1计算得到的角度，旋转对象或目标（根据平台类型），然后计算得到新的XY平台偏移量
		if (!PlatformTransform(vProductObjectPos_Weight, degProductObjectAngle_Weight, vProductTargetPos_Weight, degProductTargetAngle_Weight,
			degTempPlatformOffsetD_Base, sc2Vector(0,0),
			//vTempProductTargetPos_Weight, vTempProductTargetAngle_Weight, vTempProductObjectPos_Weight, vTempProductObjectAngle_Weight))
			vTempProductObjectPos_Weight, vTempProductObjectAngle_Weight, vTempProductTargetPos_Weight, vTempProductTargetAngle_Weight))
		{
			return FALSE;
		}

		// 计算得到的角度，XY偏移量
		degTempPlatformOffsetD_Weight = degTempPlatformOffsetD_Base;
		vTempPlatformOffsetXY_Weight = vTempProductTargetPos_Weight - vTempProductObjectPos_Weight;

		str.Format("(权重点)XYD方向产品偏差(目标位置-对象位置) X=%f,Y=%f,D=%f",
			vTempProductOffsetXY_Weight.GetX(),vTempProductOffsetXY_Weight.GetY(),degTempProductOffsetD_Weight.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		str.Format("(权重点)XYD方向平台移动量 X=%f,Y=%f,D=%f",
			vTempPlatformOffsetXY_Weight.GetX(),vTempPlatformOffsetXY_Weight.GetY(),degTempPlatformOffsetD_Weight.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 3.综合上述两种方法，根据权重，计算得到位置偏差XY和角度偏差
		double dCircleWeight = m_AlignermentParam.m_dAlignerWeight;

		str.Format("权重系数: %f",dCircleWeight);
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 产品偏差量
		degProductOffsetD = degTempProductOffsetD_Base;
		vProductOffsetXY = vTempProductOffsetXY_Base * (1 - dCircleWeight) + vTempProductOffsetXY_Weight * dCircleWeight;

		// 平台偏差量
		degPlatformOffsetD = degTempPlatformOffsetD_Base;
		vPlatformOffsetXY = vTempPlatformOffsetXY_Base * (1 - dCircleWeight) + vTempPlatformOffsetXY_Weight * dCircleWeight;


	}
	// 几何方法(根据目标、对象的位置和角度(姿态)，直接计算对象与目标的产品偏差和平台偏移量)
	else
	{
		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos;
		scDegree  degProductObjectAngle;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos, degProductObjectAngle,FALSE,TRUE);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos.GetX(),vProductObjectPos.GetY(),degProductObjectAngle.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos;
		scDegree  degProductTargetAngle;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos, degProductTargetAngle,FALSE,FALSE);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos.GetX(),vProductTargetPos.GetY(),degProductTargetAngle.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 3计算产品角度、XY偏差，计算角度、XY平台偏移量
		if(!GetAlginOffset_Geometry(vProductObjectPos, degProductObjectAngle, vProductTargetPos, degProductTargetAngle,
			vProductOffsetXY, degProductOffsetD, vPlatformOffsetXY, degPlatformOffsetD))
		{
			return FALSE;
		}
	}

	// 产品偏差
	cpProductOffset.m_dPosX = vProductOffsetXY.GetX();
	cpProductOffset.m_dPosY = vProductOffsetXY.GetY();
	cpProductOffset.m_dAngle = degProductOffsetD.SignedNorm().ToDouble();

	str.Format("XYD方向产品偏差(目标位置-对象位置) X=%f,Y=%f,D=%f",vProductOffsetXY.GetX(),vProductOffsetXY.GetY(),degProductOffsetD.ToDouble());
	AlignToolLogRecord(str, m_nPlatformIndex);

	// 平台移动量
	cpPlatformOffset.m_dPosX = vPlatformOffsetXY.GetX();
	cpPlatformOffset.m_dPosY = vPlatformOffsetXY.GetY();
	cpPlatformOffset.m_dAngle = degPlatformOffsetD.SignedNorm().ToDouble();

	str.Format("XYD方向平台移动量 X=%f,Y=%f,D=%f",vPlatformOffsetXY.GetX(),vPlatformOffsetXY.GetY(),degPlatformOffsetD.ToDouble());
	AlignToolLogRecord(str, m_nPlatformIndex);



	// 根据平台移动量，调整对象位置，得到相对当前旋转中心（原点）的平台坐标
	{
		vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
		int nPosNum = vcpObjectPlatformPos.size();	
		CCoordPos pos;
		sc2Vector vTempObjectPlatformPos;
		scDegree  degTempObjectPlatformAngle;
		sc2Vector vTempAlginedObjectPlatformPos;
		scDegree  degTempAlginedObjectPlatformAngle;
		int i = 0;
		for(i = 0; i < nPosNum; i++)
		{			
			vTempObjectPlatformPos = vcpObjectPlatformPos.at(i).GetPos();
			degTempObjectPlatformAngle = scDegree(vcpObjectPlatformPos.at(i).GetAngle());

			PlatformTransformRotateShiftObject(vTempObjectPlatformPos,degTempObjectPlatformAngle,
				degPlatformOffsetD, vPlatformOffsetXY,
				vTempAlginedObjectPlatformPos, degTempObjectPlatformAngle);

			vcpAlginedObjectPlatformPos.at(i).SetPosAngle(vTempAlginedObjectPlatformPos,degTempAlginedObjectPlatformAngle.ToDouble());

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vcpObjectPlatformPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vTempObjectPlatformPos = vcpObjectPlatformPos.at(i).GetAuxPos(nAuxiPosIndex);
				degTempObjectPlatformAngle = scDegree(vcpObjectPlatformPos.at(i).m_vdAuxiliaryAngle.at(nAuxiPosIndex));

				PlatformTransformRotateShiftObject(vTempObjectPlatformPos,degTempObjectPlatformAngle,
					degPlatformOffsetD, vPlatformOffsetXY,
					vTempAlginedObjectPlatformPos, degTempObjectPlatformAngle);

				vcpAlginedObjectPlatformPos.at(i).SetAuxPosAngle(nAuxiPosIndex, vTempAlginedObjectPlatformPos,degTempAlginedObjectPlatformAngle.ToDouble());
			}

		}

	}

	// 根据平台移动量，调整目标位置，得到相对当前旋转中心（原点）的平台坐标
	{
		vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;
		int nPosNum = vcpTargetPlatformPos.size();	
		CCoordPos pos;
		sc2Vector vTempTargetPlatformPos;
		scDegree  degTempTargetPlatformAngle;
		sc2Vector vTempAlginedTargetPlatformPos;
		scDegree  degTempAlginedTargetPlatformAngle;
		int i = 0;
		for(i = 0; i < nPosNum; i++)
		{			
			vTempTargetPlatformPos = vcpTargetPlatformPos.at(i).GetPos();
			degTempTargetPlatformAngle = scDegree(vcpTargetPlatformPos.at(i).GetAngle());

			PlatformTransformRotateShiftTarget(vTempTargetPlatformPos,degTempTargetPlatformAngle,
				degPlatformOffsetD, vPlatformOffsetXY,
				vTempAlginedTargetPlatformPos, degTempAlginedTargetPlatformAngle);

			vcpAlginedTargetPlatformPos.at(i).SetPosAngle(vTempAlginedTargetPlatformPos,degTempAlginedTargetPlatformAngle.ToDouble());

			vTempTargetPlatformPos.SetX(vcpTargetPlatformPos.at(i).GetPosX());
			vTempTargetPlatformPos.SetY(vcpTargetPlatformPos.at(i).GetPosY());

			if (i<MAXTARGETPOS)
			{
				m_dTargetX[i] = vTempAlginedTargetPlatformPos.GetX();
				m_dTargetY[i] = vTempAlginedTargetPlatformPos.GetY();
			}	


			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vcpTargetPlatformPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vTempTargetPlatformPos = vcpTargetPlatformPos.at(i).GetAuxPos(nAuxiPosIndex);
				degTempTargetPlatformAngle = scDegree(vcpTargetPlatformPos.at(i).m_vdAuxiliaryAngle.at(nAuxiPosIndex));

				PlatformTransformRotateShiftTarget(vTempTargetPlatformPos,degTempTargetPlatformAngle,
					degPlatformOffsetD, vPlatformOffsetXY,
					vTempAlginedTargetPlatformPos, degTempTargetPlatformAngle);

				vcpAlginedTargetPlatformPos.at(i).SetAuxPosAngle(nAuxiPosIndex, vTempAlginedTargetPlatformPos,degTempAlginedTargetPlatformAngle.ToDouble());

			}
		}
	}

	str.Format("GetAlginOffset End");
	AlignToolLogRecord(str,m_nPlatformIndex);

	return TRUE;
}



// 根据对象平台位置、目标平台位置、Mark数量、对位模式、平台类型，
// 计算产品偏差、平台偏移量，以及对位调整后临时理论的对象平台位置和目标平台位置
BOOL vcBaseAlignTool::GetAlginOffsetInline(
	std::vector<CCoordPos> vcpObjectPlatformPos,
	std::vector<CCoordPos> vcpTargetPlatformPos,
	CCoordPos& cpProductOffset,
	CCoordPos& cpPlatformOffset,
	std::vector<CCoordPos>& vcpAlginedObjectPlatformPos,
	std::vector<CCoordPos>& vcpAlginedTargetPlatformPos)
{
	CString str;
	str.Format("GetAlginOffset Begin");
	AlignToolLogRecord(str,m_nPlatformIndex);

	for (int i=0;i<vcpObjectPlatformPos.size();i++)
	{
		str.Format("对象%d平台坐标 X=%f,Y=%f",i,vcpObjectPlatformPos.at(i).GetPosX(),vcpObjectPlatformPos.at(i).GetPosY());
		AlignToolLogRecord(str, m_nPlatformIndex);
	}

	for (int i=0;i<vcpTargetPlatformPos.size();i++)
	{
		str.Format("目标%d平台坐标 X=%f,Y=%f",i,vcpTargetPlatformPos.at(i).GetPosX(),vcpTargetPlatformPos.at(i).GetPosY());
		AlignToolLogRecord(str, m_nPlatformIndex);
	}

	scDegree degProductOffsetD;		// 产品角度偏差	
	sc2Vector vProductOffsetXY;		// 产品XY偏移量

	scDegree degPlatformOffsetD;	// 平台角度偏量
	sc2Vector vPlatformOffsetXY;	// 平台XY偏移量

	// 根据对位模式、平台类型等信息进行对位
	if ((FALSE ==  m_bTargetObjectCamSeparate&& 3 == m_iMarkNum && eAlignerPos123_Auto == m_AlignermentParam.GetAligner3Vs3Type())
		|| (FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum && eAlignerPos1234_Auto == m_AlignermentParam.GetAligner4Vs4Type())
		|| (FALSE == m_bTargetObjectCamSeparate && 5 == m_iMarkNum && eAlignerPos12345_Auto == m_AlignermentParam.GetAligner5Vs5Type())
		|| (FALSE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum && eAlignerPos123456_Auto == m_AlignermentParam.GetAligner6Vs6Type())
		|| (TRUE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum && eAlignerPos123_Auto == m_AlignermentParam.GetAligner3Vs3Type())
		|| (TRUE == m_bTargetObjectCamSeparate && 8 == m_iMarkNum && eAlignerPos1234_Auto == m_AlignermentParam.GetAligner4Vs4Type() /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/)
		|| (((TRUE == m_bTargetObjectCamSeparate && 8 == m_iMarkNum)||(FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)) /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/
		&& ( eAlignerPos1234_Combine_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type()
		|| eAlignerPos1234_Combine_Target_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type()
		|| eAlignerPos1234_Combine_Object_4Vs4 == m_AlignermentParam.GetAligner4Vs4Type())))
	{
// 		// PCB 定制
// 		if (m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align && 4 == m_iMarkNum)
// 		{
// 
// 			str.Format("m_bShowPCB4To3Align:%d,m_PointMethodType:%d",m_AlignermentParam.GetPCBInfo().m_bShowPCB4To3Align,m_PointMethodType);
// 			AlignToolLogRecord(str,m_nPlatformIndex);
// 
// 			int nPosNumber = vcpObjectPlatformPos.size();			
// 
// 			// 1.记录对象位置和目标位置		
// 			svStd vector<sc2Vector> Objpts;
// 			svStd vector<sc2Vector> Tgtpts;
// 			int i=0;
// 			for (i=0;i<nPosNumber;i++)
// 			{
// 				sc2Vector objpt(vcpObjectPlatformPos.at(i).GetPosX(),vcpObjectPlatformPos.at(i).GetPosY());
// 				sc2Vector tgtpt(vcpTargetPlatformPos.at(i).GetPosX(),vcpTargetPlatformPos.at(i).GetPosY());
// 				if ((i==0 && m_PointMethodType==eAligner234_234)||(i==1 && m_PointMethodType==eAligner134_134) ||(i==2 && m_PointMethodType==eAligner124_124)||(i==3 && m_PointMethodType==eAligner123_123))
// 				{
// 					continue;
// 				}
// 
// 				Objpts.push_back(objpt);
// 				Tgtpts.push_back(tgtpt);
// 			}
// 
// 			for (i=0;i<nPosNumber-1;i++)
// 			{
// 				str.Format("Objpts.at(%d).GetX()=%f,Objpts.at(%d).GetY()=%f",i,Objpts.at(i).GetX(),i,Objpts.at(i).GetY());
// 				AlignToolLogRecord(str,m_nPlatformIndex);
// 
// 			}
// 			for (i=0;i<nPosNumber-1;i++)
// 			{
// 				str.Format("Tgtpts.at(%d).GetX()=%f,Tgtpts.at(%d).GetY()=%f",i,Tgtpts.at(i).GetX(),i,Tgtpts.at(i).GetY());
// 				AlignToolLogRecord(str,m_nPlatformIndex);
// 
// 			}
// 
// 			// 2.计算产品角度偏差、产品XY偏移量
// 			double dProductOffsetX = 0;
// 			double dProductOffsetY = 0;
// 			if (!sfGetRigidTransformationProduct(Objpts, Tgtpts, dProductOffsetX, dProductOffsetY, degProductOffsetD))
// 			{
// 				str.Format("sfGetRigidTransformationProduct fail");
// 				AlignToolLogRecord(str,m_nPlatformIndex);
// 				return FALSE;
// 			}
// 			vProductOffsetXY.SetX(dProductOffsetX);
// 			vProductOffsetXY.SetY(dProductOffsetY);
// 
// 			// 3.计算角度、XY平台偏移量
// 			scDegree degTd = scDegree(0);
// 			double dAlignerX = 0;
// 			double dAlignerY = 0;
// 			sc2Vector PtOrigin(0, 0);
// 			if (GetMidPlatformType()==ePlatformXYPD)
// 			{
// 				if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
// 				{
// 					// 对位时，只考虑XY偏差量，不考虑角度D偏差量
// 					// 强制将产品偏差赋值为0
// 					degProductOffsetD = scDegree(0);
// 
// 					// $3.1.计算角度、XY偏移量
// 					degPlatformOffsetD = degProductOffsetD;	// 平台角度偏量
// 					vPlatformOffsetXY = vProductOffsetXY;	// 平台XY偏移量
// 				}
// 				else
// 				{
// 					// $3.1.先计算目标转到对象的角度，旋转中心为平台旋转中心(0,0)					
// 					double dTempAlignerX = 0;
// 					double dTempAlignerY = 0;
// 
// 					if (!sfGetRigidTransformation(Tgtpts, Objpts, dTempAlignerX, dTempAlignerY, degTd, PtOrigin))
// 					{
// 						str.Format("sfGetRigidTransformation fail");
// 						AlignToolLogRecord(str,m_nPlatformIndex);
// 						return FALSE;
// 					}
// 
// 					// $3.2 计算实时目标mark中心按degTd旋转后的新坐标值
// 					svStd vector<sc2Vector> tempObjpts = Objpts;
// 					svStd vector<sc2Vector> tempTgtpts = Tgtpts;
// 					for (int i=0;i<nPosNumber;i++)
// 					{
// 						tempTgtpts.at(i) = vfGetTransformRotateShiftPoint(Tgtpts.at(i), degTd, 0, 0, PtOrigin);
// 					}
// 
// 					// $3.3 计算新的XY平台偏移量
// 					scDegree degTempTd = scDegree(0);
// 					if (!sfGetRigidTransformation(Objpts, tempTgtpts, dAlignerX, dAlignerY, degTempTd, PtOrigin))
// 					{
// 						str.Format("sfGetRigidTransformation fail");
// 						AlignToolLogRecord(str,m_nPlatformIndex);
// 						return FALSE;
// 					}
// 
// 					degPlatformOffsetD = degTd;	// 平台角度偏量
// 					vPlatformOffsetXY = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
// 				}
// 
// 			}
// 			else
// 			{
// 				if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
// 				{
// 					// 对位时，只考虑XY偏差量，不考虑角度D偏差量
// 					// 强制将产品偏差赋值为0
// 					degProductOffsetD = scDegree(0);
// 
// 					str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
// 					AlignToolLogRecord(str,m_nPlatformIndex);
// 
// 					// $3.1.计算角度、XY偏移量
// 					degPlatformOffsetD = degProductOffsetD;	// 平台角度偏量
// 					vPlatformOffsetXY = vProductOffsetXY;	// 平台XY偏移量
// 				}
// 				else
// 				{
// 					// $3.1.计算角度、XY偏移量
// 					if (!sfGetRigidTransformation(Objpts, Tgtpts, dAlignerX, dAlignerY, degTd, PtOrigin))
// 					{
// 						str.Format("sfGetRigidTransformation fail");
// 						AlignToolLogRecord(str,m_nPlatformIndex);
// 						return FALSE;
// 					}
// 
// 					degPlatformOffsetD = degTd;	// 平台角度偏量
// 					vPlatformOffsetXY = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
// 				}			
// 			}
// 
// 			str.Format("sfGetRigidTransformation success");
// 			AlignToolLogRecord(str,m_nPlatformIndex);
// 		}
// 		// 非PCB定制，正常流程
// 		else
		{
			str.Format("目标对象分离，位置数位8，4V4");
			AlignToolLogRecord(str, m_nPlatformIndex);
			int nPosNumber = vcpObjectPlatformPos.size();

			// 1.记录对象位置和目标位置		
			svStd vector<sc2Vector> Objpts;
			svStd vector<sc2Vector> Tgtpts;
			int i=0;
			for (i=0;i<nPosNumber;i++)
			{
				sc2Vector objpt(vcpObjectPlatformPos.at(i).GetPosX(),vcpObjectPlatformPos.at(i).GetPosY());
				sc2Vector tgtpt(vcpTargetPlatformPos.at(i).GetPosX(),vcpTargetPlatformPos.at(i).GetPosY());

				Objpts.push_back(objpt);
				Tgtpts.push_back(tgtpt);
			}

			for (i=0;i<nPosNumber;i++)
			{
				str.Format("Objpts.at(%d).GetX()=%f,Objpts.at(%d).GetY()=%f",i,Objpts.at(i).GetX(),i,Objpts.at(i).GetY());
				AlignToolLogRecord(str,m_nPlatformIndex);

			}
			for (i=0;i<nPosNumber;i++)
			{
				str.Format("Tgtpts.at(%d).GetX()=%f,Tgtpts.at(%d).GetY()=%f",i,Tgtpts.at(i).GetX(),i,Tgtpts.at(i).GetY());
				AlignToolLogRecord(str,m_nPlatformIndex);

			}

			// 2.计算产品角度偏差、产品XY偏移量
			double dProductOffsetX = 0;
			double dProductOffsetY = 0;
			if (!sfGetRigidTransformationProduct(Objpts, Tgtpts, dProductOffsetX, dProductOffsetY, degProductOffsetD))
			{
				str.Format("sfGetRigidTransformationProduct fail");
				AlignToolLogRecord(str,m_nPlatformIndex);
				return FALSE;
			}
			vProductOffsetXY.SetX(dProductOffsetX);
			vProductOffsetXY.SetY(dProductOffsetY);

			// 3.计算角度、XY平台偏移量
			scDegree degTd = scDegree(0);
			double dAlignerX = 0;
			double dAlignerY = 0;
			sc2Vector PtOrigin(0, 0);
			if (GetMidPlatformType()==ePlatformXYPD)
			{
				if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
				{
					// 对位时，只考虑XY偏差量，不考虑角度D偏差量
					// 强制将产品偏差赋值为0
					degProductOffsetD = scDegree(0);

					// $3.1.计算角度、XY偏移量
					degPlatformOffsetD = degProductOffsetD;	// 平台角度偏量
					vPlatformOffsetXY = vProductOffsetXY;	// 平台XY偏移量
				}
				else
				{
					// $3.1.先计算目标转到对象的角度，旋转中心为平台旋转中心(0,0)					
					double dTempAlignerX = 0;
					double dTempAlignerY = 0;

					if (!sfGetRigidTransformation(Tgtpts, Objpts, dTempAlignerX, dTempAlignerY, degTd, PtOrigin))
					{
						str.Format("sfGetRigidTransformation fail");
						AlignToolLogRecord(str,m_nPlatformIndex);
						return FALSE;
					}

					// $3.2 计算实时目标mark中心按degTd旋转后的新坐标值
					svStd vector<sc2Vector> tempObjpts = Objpts;
					svStd vector<sc2Vector> tempTgtpts = Tgtpts;
					for (int i=0;i<nPosNumber;i++)
					{
						tempTgtpts.at(i) = vfGetTransformRotateShiftPoint(Tgtpts.at(i), degTd, 0, 0, PtOrigin);

						str.Format("旋转后产品的目标位置[%d] X=%f,Y=%f",i,tempTgtpts.at(i).GetX(),tempTgtpts.at(i).GetY());
						AlignToolLogRecord(str, m_nPlatformIndex);

					}


					// $3.3 计算新的XY平台偏移量
					scDegree degTempTd = scDegree(0);
					if (!sfGetRigidTransformation(Objpts, tempTgtpts, dAlignerX, dAlignerY, degTempTd, PtOrigin))
					{
						str.Format("sfGetRigidTransformation fail");
						AlignToolLogRecord(str,m_nPlatformIndex);
						return FALSE;
					}

					degPlatformOffsetD = degTd;	// 平台角度偏量
					vPlatformOffsetXY = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
				}

			}
			else
			{
				if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
				{
					// 对位时，只考虑XY偏差量，不考虑角度D偏差量
					// 强制将产品偏差赋值为0
					degProductOffsetD = scDegree(0);

					str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
					AlignToolLogRecord(str,m_nPlatformIndex);

					// $3.1.计算角度、XY偏移量
					degPlatformOffsetD = degProductOffsetD;	// 平台角度偏量
					vPlatformOffsetXY = vProductOffsetXY;	// 平台XY偏移量
				}
				else
				{
					// $3.1.计算角度、XY偏移量
					if (!sfGetRigidTransformation(Objpts, Tgtpts, dAlignerX, dAlignerY, degTd, PtOrigin))
					{
						str.Format("sfGetRigidTransformation fail");
						AlignToolLogRecord(str,m_nPlatformIndex);
						return FALSE;
					}

					degPlatformOffsetD = degTd;	// 平台角度偏量
					vPlatformOffsetXY = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
				}			
			}

			str.Format("sfGetRigidTransformation success");
			AlignToolLogRecord(str,m_nPlatformIndex);

		}
	}
	// 均方误差最小对位角度，均方误差最小（X1,Y1）+ 圆（X2,Y2）,根据权重系数计算（X,Y）
	else if (((TRUE == m_bTargetObjectCamSeparate && 8 == m_iMarkNum )||(FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)) && (eAlignerPos1234_1234_Weight == m_AlignermentParam.GetAligner4Vs4Type()) /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/)
	{
		int nPosNumber = vcpObjectPlatformPos.size();

		// 1.记录对象位置和目标位置		
		svStd vector<sc2Vector> Objpts;
		svStd vector<sc2Vector> Tgtpts;
		int i=0;
		for (i=0;i<nPosNumber;i++)
		{
			sc2Vector objpt(vcpObjectPlatformPos.at(i).GetPosX(),vcpObjectPlatformPos.at(i).GetPosY());
			sc2Vector tgtpt(vcpTargetPlatformPos.at(i).GetPosX(),vcpTargetPlatformPos.at(i).GetPosY());

			Objpts.push_back(objpt);
			Tgtpts.push_back(tgtpt);
		}

		for (i=0;i<nPosNumber;i++)
		{
			str.Format("Objpts.at(%d).GetX()=%f,Objpts.at(%d).GetY()=%f",i,Objpts.at(i).GetX(),i,Objpts.at(i).GetY());
			AlignToolLogRecord(str,m_nPlatformIndex);

		}
		for (i=0;i<nPosNumber;i++)
		{
			str.Format("Tgtpts.at(%d).GetX()=%f,Tgtpts.at(%d).GetY()=%f",i,Tgtpts.at(i).GetX(),i,Tgtpts.at(i).GetY());
			AlignToolLogRecord(str,m_nPlatformIndex);

		}

		// 2.计算产品角度偏差、产品XY偏移量(均方误差最小)
		double dProductOffsetX = 0;
		double dProductOffsetY = 0;

		sc2Vector vTempProductOffsetXY_Aver = sc2Vector(0, 0);
		scDegree  degTempProductOffsetAngle_Aver = scDegree(0);

		if (!sfGetRigidTransformationProduct(Objpts, Tgtpts, dProductOffsetX, dProductOffsetY, degProductOffsetD))
		{
			str.Format("sfGetRigidTransformationProduct fail");
			AlignToolLogRecord(str,m_nPlatformIndex);
			return FALSE;
		}

		vTempProductOffsetXY_Aver.SetX(dProductOffsetX);
		vTempProductOffsetXY_Aver.SetY(dProductOffsetY);
		degTempProductOffsetAngle_Aver = degProductOffsetD;

		// 3.计算角度、XY平台偏移量（均方误差最小）
		scDegree degTd = scDegree(0);
		double dAlignerX = 0;
		double dAlignerY = 0;
		sc2Vector PtOrigin(0, 0);

		sc2Vector vTempPlatformOffsetXY_Aver = sc2Vector(0, 0);
		scDegree  degTempPlatformOffsetAngle_Aver = scDegree(0);

		if ( GetMidPlatformType() == ePlatformXYD )
		{
			// $3.1.计算角度、XY偏移量
			if (!sfGetRigidTransformation(Objpts, Tgtpts, dAlignerX, dAlignerY, degTd, PtOrigin))
			{
				str.Format("sfGetRigidTransformation fail");
				AlignToolLogRecord(str,m_nPlatformIndex);
				return FALSE;
			}

			degTempPlatformOffsetAngle_Aver = degTd;	// 平台角度偏量
			vTempPlatformOffsetXY_Aver = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
		}


		// 		if (GetMidPlatformType()==ePlatformXYPD)
		// 		{
		// 			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
		// 			{
		// 				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
		// 				// 强制将产品偏差赋值为0
		// 				degProductOffsetD = scDegree(0);
		// 
		// 				// $3.1.计算角度、XY偏移量
		// 				degPlatformOffsetD = degProductOffsetD;	// 平台角度偏量
		// 				vPlatformOffsetXY = vProductOffsetXY;	// 平台XY偏移量
		// 			}
		// 			else
		// 			{
		// 				// $3.1.先计算目标转到对象的角度，旋转中心为平台旋转中心(0,0)					
		// 				double dTempAlignerX = 0;
		// 				double dTempAlignerY = 0;
		// 
		// 				if (!sfGetRigidTransformation(Tgtpts, Objpts, dTempAlignerX, dTempAlignerY, degTd, PtOrigin))
		// 				{
		// 					str.Format("sfGetRigidTransformation fail");
		// 					AlignToolLogRecord(str,m_nPlatformIndex);
		// 					return FALSE;
		// 				}
		// 
		// 				// $3.2 计算实时目标mark中心按degTd旋转后的新坐标值
		// 				svStd vector<sc2Vector> tempObjpts = Objpts;
		// 				svStd vector<sc2Vector> tempTgtpts = Tgtpts;
		// 				for (int i=0;i<nPosNumber;i++)
		// 				{
		// 					tempTgtpts.at(i) = vfGetTransformRotateShiftPoint(Tgtpts.at(i), degTd, 0, 0, PtOrigin);
		// 				}
		// 
		// 				// $3.3 计算新的XY平台偏移量
		// 				scDegree degTempTd = scDegree(0);
		// 				if (!sfGetRigidTransformation(Objpts, tempTgtpts, dAlignerX, dAlignerY, degTempTd, PtOrigin))
		// 				{
		// 					str.Format("sfGetRigidTransformation fail");
		// 					AlignToolLogRecord(str,m_nPlatformIndex);
		// 					return FALSE;
		// 				}
		// 
		// 				degPlatformOffsetD = degTd;	// 平台角度偏量
		// 				vPlatformOffsetXY = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
		// 			}
		// 
		// 		}
		// 		else
		//		{
		// 			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
		// 			{
		// 				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
		// 				// 强制将产品偏差赋值为0
		// 				degProductOffsetD = scDegree(0);
		// 
		// 				str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
		// 				AlignToolLogRecord(str,m_nPlatformIndex);
		// 
		// 				// $3.1.计算角度、XY偏移量
		// 				degPlatformOffsetD = degProductOffsetD;	// 平台角度偏量
		// 				vPlatformOffsetXY = vProductOffsetXY;	// 平台XY偏移量
		// 			}
		//			else
		//			{
		// 				// $3.1.计算角度、XY偏移量
		// 				if (!sfGetRigidTransformation(Objpts, Tgtpts, dAlignerX, dAlignerY, degTd, PtOrigin))
		// 				{
		// 					str.Format("sfGetRigidTransformation fail");
		// 					AlignToolLogRecord(str,m_nPlatformIndex);
		// 					return FALSE;
		// 				}
		// 
		// 				degPlatformOffsetD = degTd;	// 平台角度偏量
		// 				vPlatformOffsetXY = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
		//			}			
		//		}

		str.Format("sfGetRigidTransformation success");
		AlignToolLogRecord(str,m_nPlatformIndex);


		// 获取产品的对象位置和角度
		sc2Vector vProductObjectPos;
		scDegree  degProductObjectAngle;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos, degProductObjectAngle);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos.GetX(),vProductObjectPos.GetY(),degProductObjectAngle.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 获取产品的目标位置和角度
		sc2Vector vProductTargetPos;
		scDegree  degProductTargetAngle;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos, degProductTargetAngle);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos.GetX(),vProductTargetPos.GetY(),degProductTargetAngle.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);


		// 4.计算产品角度、XY偏差(辅助圆)
		// 计算产品角度偏差 = 目标角度 - 对象角度
		scDegree degTempProductOffsetAngle_Circle = (degProductTargetAngle - degProductObjectAngle).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		sc2Vector vTempProductOffsetXY_Circle = vProductTargetPos - vProductObjectPos;

		// 5.计算角度、XY平台偏移量（辅助圆）	
		sc2Vector vTempProductTargetPos;		// 临时目标位置
		sc2Vector vTempProductObjectPos;		// 临时对象位置

		sc2Vector vTempPlatformOffsetXY_Circle = sc2Vector(0, 0);
		scDegree  degTempPlatformOffsetAngle_Circle = scDegree(0);
		if ( GetMidPlatformType() == ePlatformXYD )
		{
			// 角度平台移动量；该角度为均方误差最小角度
			degTempPlatformOffsetAngle_Circle = degTempPlatformOffsetAngle_Aver;
			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos = vfGetTransformRotateShiftPoint(vProductObjectPos, degTempPlatformOffsetAngle_Circle, 0, 0);

			// 目标位置
			vTempProductTargetPos = vProductTargetPos;

			// 计算XY偏移量
			vTempPlatformOffsetXY_Circle = vTempProductTargetPos - vTempProductObjectPos;
		}

		double dCircleWeight = m_AlignermentParam.m_dAlignerWeight;

		// 产品偏差量
		degProductOffsetD = degTempProductOffsetAngle_Aver;
		vProductOffsetXY = vTempProductOffsetXY_Aver * (1 - dCircleWeight) + vTempProductOffsetXY_Circle * dCircleWeight;

		// 平台偏差量
		degPlatformOffsetD = degTempPlatformOffsetAngle_Aver;
		vPlatformOffsetXY = vTempPlatformOffsetXY_Aver * (1 - dCircleWeight) + vTempPlatformOffsetXY_Circle * dCircleWeight;

	}
	// 长边对位角度，四个位置组合构成直线，四边中点（X1,Y1）+ 圆（X2,Y2），根据权重系数计算（X,Y）
	else if (((TRUE == m_bTargetObjectCamSeparate && 8 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum))&& (eAlignerPos1234_Combine_Weight == m_AlignermentParam.GetAligner4Vs4Type()) /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/)
	{
		// 定位点坐标
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Combine;
		scDegree  degProductObjectAngle_Combine;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Combine, degProductObjectAngle_Combine);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Combine.GetX(),vProductObjectPos_Combine.GetY(),degProductObjectAngle_Combine.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Combine;
		scDegree  degProductTargetAngle_Combine;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Combine, degProductTargetAngle_Combine);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Combine.GetX(),vProductTargetPos_Combine.GetY(),degProductTargetAngle_Combine.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 3.计算产品角度、XY偏差
		// 计算产品角度偏差 = 目标角度 - 对象角度
		scDegree degTempProductOffsetD_Combine = (degProductTargetAngle_Combine - degProductObjectAngle_Combine).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		sc2Vector vTempProductOffsetXY_Combine = vProductTargetPos_Combine - vProductObjectPos_Combine;

		sc2Vector vTempProductTargetPos_Combine;		// 临时目标位置
		sc2Vector vTempProductObjectPos_Combine;		// 临时对象位置

		sc2Vector vTempPlatformOffsetXY_Combine = sc2Vector(0, 0);
		scDegree  degTempPlatformOffsetD_Combine = scDegree(0);

		if ( GetMidPlatformType()==ePlatformXYD )
		{
			// 角度平台移动量
			degTempPlatformOffsetD_Combine = degTempProductOffsetD_Combine;

			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos_Combine = vfGetTransformRotateShiftPoint(vProductObjectPos_Combine, degTempPlatformOffsetD_Combine, 0, 0);

			// 目标位置
			vTempProductTargetPos_Combine = vProductTargetPos_Combine;

			// 计算XY偏移量
			vTempPlatformOffsetXY_Combine = vTempProductTargetPos_Combine - vTempProductObjectPos_Combine;
		}

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////


		// 圆辅助点平台坐标
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////


		// 辅助点坐标（圆）
		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Auxiliary;
		scDegree  degProductObjectAngle_Auxiliary;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Auxiliary, degProductObjectAngle_Auxiliary, TRUE);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Auxiliary.GetX(),vProductObjectPos_Auxiliary.GetY(),degProductObjectAngle_Auxiliary.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Auxiliary;
		scDegree  degProductTargetAngle_Auxiliary;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Auxiliary, degProductTargetAngle_Auxiliary, TRUE);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Auxiliary.GetX(),vProductTargetPos_Auxiliary.GetY(),degProductTargetAngle_Auxiliary.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 3.计算产品角度、XY偏差
		// 计算产品角度偏差 = 目标角度 - 对象角度
		scDegree degTempProductOffsetD_Auxiliary = (degProductTargetAngle_Auxiliary - degProductObjectAngle_Auxiliary).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		sc2Vector vTempProductOffsetXY_Auxiliary = vProductTargetPos_Auxiliary - vProductObjectPos_Auxiliary;

		sc2Vector vTempProductTargetPos_Auxiliary;		// 临时目标位置
		sc2Vector vTempProductObjectPos_Auxiliary;		// 临时对象位置

		sc2Vector vTempPlatformOffsetXY_Auxiliary = sc2Vector(0, 0);
		scDegree  degTempPlatformOffsetD_Auxiliary = scDegree(0);

		if ( GetMidPlatformType()==ePlatformXYD )
		{
			// 角度平台移动量；该角度为综合对位中长边角度
			degTempPlatformOffsetD_Auxiliary = degTempPlatformOffsetD_Combine;

			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos_Auxiliary = vfGetTransformRotateShiftPoint(vProductObjectPos_Auxiliary, degTempPlatformOffsetD_Auxiliary, 0, 0);

			// 目标位置
			vTempProductTargetPos_Auxiliary = vProductTargetPos_Auxiliary;

			// 计算XY偏移量
			vTempPlatformOffsetXY_Auxiliary = vTempProductTargetPos_Auxiliary - vTempProductObjectPos_Auxiliary;
		}


		double dCircleWeight = m_AlignermentParam.m_dAlignerWeight;

		// 产品偏差量
		degProductOffsetD = degTempPlatformOffsetD_Combine;
		vProductOffsetXY = vTempPlatformOffsetXY_Combine * (1 - dCircleWeight) + vTempProductOffsetXY_Auxiliary * dCircleWeight;

		// 平台偏差量
		degPlatformOffsetD = degTempPlatformOffsetD_Combine;
		vPlatformOffsetXY = vTempPlatformOffsetXY_Combine * (1 - dCircleWeight) + vTempPlatformOffsetXY_Auxiliary * dCircleWeight;

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
	}
	//边两点中的一点或两点的中点（X1,Y1）+ 圆（X2,Y2），根据权重系数计算（X,Y） //jjh0601
	else if ((((TRUE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 2 == m_iMarkNum))&& eAlignerPos12_Auto_Weigth == m_AlignermentParam.GetAligner2Vs2Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 2 == m_iMarkNum))&& eAlignerPos12_12C1_Weigth == m_AlignermentParam.GetAligner2Vs2Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 2 == m_iMarkNum))&& eAlignerPos12_12C2_Weigth == m_AlignermentParam.GetAligner2Vs2Type()))//jjh0601
	{
		// 定位点坐标
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Combine;
		scDegree  degProductObjectAngle_Combine;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Combine, degProductObjectAngle_Combine);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Combine.GetX(),vProductObjectPos_Combine.GetY(),degProductObjectAngle_Combine.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Combine;
		scDegree  degProductTargetAngle_Combine;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Combine, degProductTargetAngle_Combine);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Combine.GetX(),vProductTargetPos_Combine.GetY(),degProductTargetAngle_Combine.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 3.计算产品角度、XY偏差
		// 计算产品角度偏差 = 目标角度 - 对象角度
		scDegree degTempProductOffsetD_Combine = (degProductTargetAngle_Combine - degProductObjectAngle_Combine).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		sc2Vector vTempProductOffsetXY_Combine = vProductTargetPos_Combine - vProductObjectPos_Combine;

		sc2Vector vTempProductTargetPos_Combine;		// 临时目标位置
		sc2Vector vTempProductObjectPos_Combine;		// 临时对象位置

		sc2Vector vTempPlatformOffsetXY_Combine = sc2Vector(0, 0);
		scDegree  degTempPlatformOffsetD_Combine = scDegree(0);

		if ( GetMidPlatformType()==ePlatformXYD )
		{
			// 角度平台移动量
			degTempPlatformOffsetD_Combine = degTempProductOffsetD_Combine;

			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos_Combine = vfGetTransformRotateShiftPoint(vProductObjectPos_Combine, degTempPlatformOffsetD_Combine, 0, 0);

			// 目标位置
			vTempProductTargetPos_Combine = vProductTargetPos_Combine;

			// 计算XY偏移量
			vTempPlatformOffsetXY_Combine = vTempProductTargetPos_Combine - vTempProductObjectPos_Combine;
		}

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////


		// 圆辅助点平台坐标
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////


		// 辅助点坐标（圆）
		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Auxiliary;
		scDegree  degProductObjectAngle_Auxiliary;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Auxiliary, degProductObjectAngle_Auxiliary, TRUE);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Auxiliary.GetX(),vProductObjectPos_Auxiliary.GetY(),degProductObjectAngle_Auxiliary.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Auxiliary;
		scDegree  degProductTargetAngle_Auxiliary;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Auxiliary, degProductTargetAngle_Auxiliary, TRUE);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Auxiliary.GetX(),vProductTargetPos_Auxiliary.GetY(),degProductTargetAngle_Auxiliary.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 3.计算产品角度、XY偏差
		// 计算产品角度偏差 = 目标角度 - 对象角度
		scDegree degTempProductOffsetD_Auxiliary = (degProductTargetAngle_Auxiliary - degProductObjectAngle_Auxiliary).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		sc2Vector vTempProductOffsetXY_Auxiliary = vProductTargetPos_Auxiliary - vProductObjectPos_Auxiliary;

		sc2Vector vTempProductTargetPos_Auxiliary;		// 临时目标位置
		sc2Vector vTempProductObjectPos_Auxiliary;		// 临时对象位置

		sc2Vector vTempPlatformOffsetXY_Auxiliary = sc2Vector(0, 0);
		scDegree  degTempPlatformOffsetD_Auxiliary = scDegree(0);

		if ( GetMidPlatformType()==ePlatformXYD )
		{
			// 角度平台移动量；该角度为综合对位中长边角度
			degTempPlatformOffsetD_Auxiliary = degTempPlatformOffsetD_Combine;

			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos_Auxiliary = vfGetTransformRotateShiftPoint(vProductObjectPos_Auxiliary, degTempPlatformOffsetD_Auxiliary, 0, 0);

			// 目标位置
			vTempProductTargetPos_Auxiliary = vProductTargetPos_Auxiliary;

			// 计算XY偏移量
			vTempPlatformOffsetXY_Auxiliary = vTempProductTargetPos_Auxiliary - vTempProductObjectPos_Auxiliary;
		}


		double dCircleWeight = m_AlignermentParam.m_dAlignerWeight;

		// 产品偏差量
		degProductOffsetD = degTempPlatformOffsetD_Combine;
		//vProductOffsetXY = vTempPlatformOffsetXY_Combine * (1 - dCircleWeight) + vTempProductOffsetXY_Auxiliary * dCircleWeight;  // jjh0602
		vProductOffsetXY = vTempProductOffsetXY_Combine * (1 - dCircleWeight) + vTempProductOffsetXY_Auxiliary * dCircleWeight;

		// 平台偏差量
		degPlatformOffsetD = degTempPlatformOffsetD_Combine;
		vPlatformOffsetXY = vTempPlatformOffsetXY_Combine * (1 - dCircleWeight) + vTempPlatformOffsetXY_Auxiliary * dCircleWeight;

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
	}
	// jjh0612
	else if ((((TRUE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 3 == m_iMarkNum))&& eAlignerPos123_Auto_Weigth == m_AlignermentParam.GetAligner3Vs3Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 3 == m_iMarkNum))&& eAlignerPos123_123C1_Weigth == m_AlignermentParam.GetAligner3Vs3Type())
		||(((TRUE == m_bTargetObjectCamSeparate && 6 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 3 == m_iMarkNum))&& eAlignerPos123_123C2_Weigth == m_AlignermentParam.GetAligner3Vs3Type()))//jjh0612
	{
		// 定位两角点坐标
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Combine;
		scDegree  degProductObjectAngle_Combine;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Combine, degProductObjectAngle_Combine);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Combine.GetX(),vProductObjectPos_Combine.GetY(),degProductObjectAngle_Combine.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Combine;
		scDegree  degProductTargetAngle_Combine;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Combine, degProductTargetAngle_Combine);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Combine.GetX(),vProductTargetPos_Combine.GetY(),degProductTargetAngle_Combine.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 3.计算产品角度、XY偏差
		// 计算产品角度偏差 = 目标角度 - 对象角度
		scDegree degTempProductOffsetD_Combine = (degProductTargetAngle_Combine - degProductObjectAngle_Combine).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		sc2Vector vTempProductOffsetXY_Combine = vProductTargetPos_Combine - vProductObjectPos_Combine;

		sc2Vector vTempProductTargetPos_Combine;		// 临时目标位置
		sc2Vector vTempProductObjectPos_Combine;		// 临时对象位置

		sc2Vector vTempPlatformOffsetXY_Combine = sc2Vector(0, 0);
		scDegree  degTempPlatformOffsetD_Combine = scDegree(0);

		if ( GetMidPlatformType()==ePlatformXYD )
		{
			// 角度平台移动量
			degTempPlatformOffsetD_Combine = degTempProductOffsetD_Combine;

			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos_Combine = vfGetTransformRotateShiftPoint(vProductObjectPos_Combine, degTempPlatformOffsetD_Combine, 0, 0);

			// 目标位置
			vTempProductTargetPos_Combine = vProductTargetPos_Combine;

			// 计算XY偏移量
			vTempPlatformOffsetXY_Combine = vTempProductTargetPos_Combine - vTempProductObjectPos_Combine;
		}

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////


		// 圆辅助点平台坐标
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////


		// 定位圆心坐标
		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos_Auxiliary;
		scDegree  degProductObjectAngle_Auxiliary;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos_Auxiliary, degProductObjectAngle_Auxiliary, TRUE);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos_Auxiliary.GetX(),vProductObjectPos_Auxiliary.GetY(),degProductObjectAngle_Auxiliary.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos_Auxiliary;
		scDegree  degProductTargetAngle_Auxiliary;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos_Auxiliary, degProductTargetAngle_Auxiliary, TRUE);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos_Auxiliary.GetX(),vProductTargetPos_Auxiliary.GetY(),degProductTargetAngle_Auxiliary.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 3.计算产品角度、XY偏差
		// 计算产品角度偏差 = 目标角度 - 对象角度
		scDegree degTempProductOffsetD_Auxiliary = (degProductTargetAngle_Auxiliary - degProductObjectAngle_Auxiliary).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		sc2Vector vTempProductOffsetXY_Auxiliary = vProductTargetPos_Auxiliary - vProductObjectPos_Auxiliary;

		sc2Vector vTempProductTargetPos_Auxiliary;		// 临时目标位置
		sc2Vector vTempProductObjectPos_Auxiliary;		// 临时对象位置

		sc2Vector vTempPlatformOffsetXY_Auxiliary = sc2Vector(0, 0);
		scDegree  degTempPlatformOffsetD_Auxiliary = scDegree(0);

		if ( GetMidPlatformType()==ePlatformXYD )
		{
			// 角度平台移动量；该角度为综合对位中长边角度
			degTempPlatformOffsetD_Auxiliary = degTempPlatformOffsetD_Combine;

			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos_Auxiliary = vfGetTransformRotateShiftPoint(vProductObjectPos_Auxiliary, degTempPlatformOffsetD_Auxiliary, 0, 0);

			// 目标位置
			vTempProductTargetPos_Auxiliary = vProductTargetPos_Auxiliary;

			// 计算XY偏移量
			vTempPlatformOffsetXY_Auxiliary = vTempProductTargetPos_Auxiliary - vTempProductObjectPos_Auxiliary;
		}


		double dCircleWeight = m_AlignermentParam.m_dAlignerWeight;

		// 产品偏差量
		degProductOffsetD = degTempPlatformOffsetD_Combine;
		//vProductOffsetXY = vTempPlatformOffsetXY_Combine * (1 - dCircleWeight) + vTempProductOffsetXY_Auxiliary * dCircleWeight;  // jjh0602
		vProductOffsetXY = vTempProductOffsetXY_Combine * (1 - dCircleWeight) + vTempProductOffsetXY_Auxiliary * dCircleWeight;

		// 平台偏差量
		degPlatformOffsetD = degTempPlatformOffsetD_Combine;
		vPlatformOffsetXY = vTempPlatformOffsetXY_Combine * (1 - dCircleWeight) + vTempPlatformOffsetXY_Auxiliary * dCircleWeight;

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
	}
	else if (((TRUE == m_bTargetObjectCamSeparate && 8 == m_iMarkNum)  ||(FALSE == m_bTargetObjectCamSeparate && 4 == m_iMarkNum)) && (eAlignerPos1234_Center == m_AlignermentParam.GetAligner4Vs4Type()) /*&& FALSE == m_bPlatformTarCamWithDiffObjCam*/)
	{
		str.Format("目标对象分离，位置数位8，长边对位角度，中心对位位移");
		AlignToolLogRecord(str, m_nPlatformIndex);
		// 定位点坐标
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos;
		scDegree  degProductObjectAngle;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos, degProductObjectAngle);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos.GetX(),vProductObjectPos.GetY(),degProductObjectAngle.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos;
		scDegree  degProductTargetAngle;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos, degProductTargetAngle);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos.GetX(),vProductTargetPos.GetY(),degProductTargetAngle.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 3.计算产品角度、XY偏差
		// 计算产品角度偏差 = 目标角度 - 对象角度
		scDegree degTempProductOffsetD = (degProductTargetAngle - degProductObjectAngle).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		sc2Vector vTempProductOffsetXY = vProductTargetPos - vProductObjectPos;

		sc2Vector vTempProductTargetPos;		// 临时目标位置
		sc2Vector vTempProductObjectPos;		// 临时对象位置

		sc2Vector vTempPlatformOffsetXY = vTempProductOffsetXY;
		scDegree  degTempPlatformOffsetD = degTempProductOffsetD;


		if (GetMidPlatformType() == ePlatformXYPD)
		{
			degTempPlatformOffsetD = -degTempProductOffsetD;
			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductTargetPos = vfGetTransformRotateShiftPoint(vProductTargetPos, degTempPlatformOffsetD, 0, 0);

			str.Format("旋转后产品的目标位置 X=%f,Y=%f",vTempProductTargetPos.GetX(),vTempProductTargetPos.GetY());
			AlignToolLogRecord(str, m_nPlatformIndex);

			// 计算XY偏移量
			vTempPlatformOffsetXY = vTempProductTargetPos - vProductObjectPos;
		}
		else
		{
			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos = vfGetTransformRotateShiftPoint(vProductObjectPos, degTempPlatformOffsetD, 0, 0);

			// 目标位置
			vTempProductTargetPos = vProductTargetPos;

			// 计算XY偏移量
			vTempPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
		}
		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
		// 产品偏差量
		degProductOffsetD = degTempPlatformOffsetD;
		vProductOffsetXY = vTempProductOffsetXY ;

		// 平台偏差量
		degPlatformOffsetD = degTempPlatformOffsetD;
		vPlatformOffsetXY = vTempPlatformOffsetXY;

		//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////
	}
	else
	{

		// 1.获取产品的对象位置和角度
		sc2Vector vProductObjectPos;
		scDegree  degProductObjectAngle;
		GetAlignProductPosAngle(vcpObjectPlatformPos, vProductObjectPos, degProductObjectAngle,FALSE,TRUE);
		str.Format("产品的对象位置和角度 X=%f,Y=%f,D=%f",vProductObjectPos.GetX(),vProductObjectPos.GetY(),degProductObjectAngle.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.获取产品的目标位置和角度
		sc2Vector vProductTargetPos;
		scDegree  degProductTargetAngle;
		GetAlignProductPosAngle(vcpTargetPlatformPos, vProductTargetPos, degProductTargetAngle,FALSE,TRUE);
		str.Format("产品的目标位置和角度 X=%f,Y=%f,D=%f",vProductTargetPos.GetX(),vProductTargetPos.GetY(),degProductTargetAngle.ToDouble());
		AlignToolLogRecord(str, m_nPlatformIndex);

		// 2.1如果开启目标与对象角度垂直，则修正目标角度
		if (TRUE == m_AlignermentParam.GetEnableAlignAngleVectical())
		{
			if (0 == m_AlignermentParam.GetAlignAngleVecticalMode())
			{
				// 0:对象到目标Mark角度（+90°），即目标Mark角度-对象Mark角度=90°；
				degProductTargetAngle = degProductTargetAngle - scDegree(90);

				str.Format(_T("启用目标与对象角度相互垂直:目标转换后角度:%f"), degProductTargetAngle.ToDouble());
				AlignToolLogRecord(str, m_nPlatformIndex);
			}
			else
			{
				// 1：对象到目标Mark角度（-90°），即目标Mark角度-对象Mark角度=-90°
				degProductTargetAngle = degProductTargetAngle + scDegree(90);

				str.Format(_T("启用目标与对象角度相互垂直:目标转换后角度:%f"), degProductTargetAngle.ToDouble());
				AlignToolLogRecord(str, m_nPlatformIndex);
			}
		}

		// 3.计算产品角度、XY偏差
		// 计算产品角度偏差 = 目标角度 - 对象角度
		degProductOffsetD = (degProductTargetAngle - degProductObjectAngle).SignedNorm();
		// 计算产品XY偏差 = 目标位置 - 对象位置
		vProductOffsetXY = vProductTargetPos - vProductObjectPos;


		// 4.计算角度、XY平台偏移量		
		sc2Vector vTempProductTargetPos;		// 临时目标位置
		sc2Vector vTempProductObjectPos;		// 临时对象位置
		if (GetMidPlatformType()==ePlatformXYPD)
		{
			if (!m_bInnerAlignBench)
			{
				if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
				{
					// 对位时，只考虑XY偏差量，不考虑角度D偏差量
					// 强制将产品偏差赋值为0
					degProductOffsetD = scDegree(0);

					str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
					AlignToolLogRecord(str,m_nPlatformIndex);
				}

				// 角度平台移动量
				degPlatformOffsetD = -degProductOffsetD;

				// 对象位置
				vTempProductObjectPos = vProductObjectPos;

				// 目标位置：根据角度偏差，调整旋转目标位置
				vTempProductTargetPos = vfGetTransformRotateShiftPoint(vProductTargetPos, degPlatformOffsetD, 0, 0);

				// 计算XY偏移量
				vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
			}
			else
			{
				if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
				{
					// 对位时，只考虑XY偏差量，不考虑角度D偏差量
					// 强制将产品偏差赋值为0
					degProductOffsetD = scDegree(0);

					str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
					AlignToolLogRecord(str,m_nPlatformIndex);
				}

				degProductOffsetD = scDegree(0);

				// 角度平台移动量
				degPlatformOffsetD = degProductOffsetD;


				// 对象位置
				vTempProductObjectPos = vProductObjectPos;

				// 目标位置
				vTempProductTargetPos = vProductTargetPos;

				// 计算XY偏移量
				vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
			}



			// 			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
			// 			{
			// 				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
			// 				// 强制将产品偏差赋值为0
			// 				degProductOffsetD = scDegree(0);
			// 
			// 				str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
			// 				AlignToolLogRecord(str,m_nPlatformIndex);
			// 			}
			// 
			// 			// 角度平台移动量
			// 			degPlatformOffsetD = -degProductOffsetD;
			// 
			// 			// 对象位置
			// 			vTempProductObjectPos = vProductObjectPos;
			// 
			// 			// 目标位置：根据角度偏差，调整旋转目标位置
			// 			vTempProductTargetPos = vfGetTransformRotateShiftPoint(vProductTargetPos, degPlatformOffsetD, 0, 0);
			// 
			// 			// 计算XY偏移量
			// 			vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;

		}
		else if (GetMidPlatformType()==ePlatformXY)
		{
			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
			{
				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
				// 强制将产品偏差赋值为0
				degProductOffsetD = scDegree(0);

				str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
				AlignToolLogRecord(str,m_nPlatformIndex);
			}

			// 角度平台移动量
			degPlatformOffsetD = degProductOffsetD;

			// 对象位置
			vTempProductObjectPos = vProductObjectPos;

			// 目标位置
			vTempProductTargetPos = vProductTargetPos;

			// 计算XY偏移量
			vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;

		}
		else if (GetMidPlatformType()==ePlatformX)
		{
			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
			{
				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
				// 强制将产品偏差赋值为0
				degProductOffsetD = scDegree(0);

				str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
				AlignToolLogRecord(str,m_nPlatformIndex);
			}

			// 角度平台移动量
			degPlatformOffsetD = degProductOffsetD;

			// 对象位置
			vTempProductObjectPos = vProductObjectPos;

			// 目标位置
			vTempProductTargetPos = vProductTargetPos;

			// 计算XY偏移量
			vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
		}
		else if (GetMidPlatformType()==ePlatformY)
		{
			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
			{
				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
				// 强制将产品偏差赋值为0
				degProductOffsetD = scDegree(0);

				str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
				AlignToolLogRecord(str,m_nPlatformIndex);
			}

			// 角度平台移动量
			degPlatformOffsetD = degProductOffsetD;

			// 对象位置
			vTempProductObjectPos = vProductObjectPos;

			// 目标位置
			vTempProductTargetPos = vProductTargetPos;

			// 计算XY偏移量
			vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
		}
		else
		{
			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
			{
				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
				// 强制将产品偏差赋值为0
				degProductOffsetD = scDegree(0);

				str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
				AlignToolLogRecord(str,m_nPlatformIndex);
			}

			// 角度平台移动量
			degPlatformOffsetD = degProductOffsetD;

			// 对象位置：根据角度偏差，调整旋转对象位置
			vTempProductObjectPos = vfGetTransformRotateShiftPoint(vProductObjectPos, degPlatformOffsetD, 0, 0);

			// 目标位置
			vTempProductTargetPos = vProductTargetPos;

			// 计算XY偏移量
			vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
		}


	}

	// 产品偏差
	cpProductOffset.m_dPosX = vProductOffsetXY.GetX();
	cpProductOffset.m_dPosY = vProductOffsetXY.GetY();
	cpProductOffset.m_dAngle = degProductOffsetD.SignedNorm().ToDouble();

	str.Format("XYD方向产品偏差(目标位置-对象位置) X=%f,Y=%f,D=%f",vProductOffsetXY.GetX(),vProductOffsetXY.GetY(),degProductOffsetD.ToDouble());
	AlignToolLogRecord(str, m_nPlatformIndex);

	// 平台移动量
	cpPlatformOffset.m_dPosX = vPlatformOffsetXY.GetX();
	cpPlatformOffset.m_dPosY = vPlatformOffsetXY.GetY();
	cpPlatformOffset.m_dAngle = degPlatformOffsetD.SignedNorm().ToDouble();

	str.Format("XYD方向平台移动量 X=%f,Y=%f,D=%f",vPlatformOffsetXY.GetX(),vPlatformOffsetXY.GetY(),degPlatformOffsetD.ToDouble());
	AlignToolLogRecord(str, m_nPlatformIndex);



	// 根据平台移动量，调整对象位置
	{
		vcpAlginedObjectPlatformPos = vcpObjectPlatformPos;
		int nPosNum = vcpObjectPlatformPos.size();	
		CCoordPos pos;
		sc2Vector vTempObjectPlatformPos;
		sc2Vector vTempAlginedObjectPlatformPos;
		int i = 0;
		for(i = 0; i < nPosNum; i++)
		{			
			vTempObjectPlatformPos.SetX(vcpObjectPlatformPos.at(i).GetPosX());
			vTempObjectPlatformPos.SetY(vcpObjectPlatformPos.at(i).GetPosY());

			if (GetMidPlatformType()==ePlatformXYPD)
			{
				vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
					vTempObjectPlatformPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
			}
			else if (GetMidPlatformType()==ePlatformXY)
			{
				vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
					vTempObjectPlatformPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());

			}
			else if (GetMidPlatformType()==ePlatformX)
			{
				vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
					vTempObjectPlatformPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
			}
			else if (GetMidPlatformType()==ePlatformY)
			{
				vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
					vTempObjectPlatformPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
			}
			else
			{
				vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
					vTempObjectPlatformPos, degPlatformOffsetD, 0, 0);
			}
			pos.m_dPosX = vTempAlginedObjectPlatformPos.GetX();
			pos.m_dPosY = vTempAlginedObjectPlatformPos.GetY();

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vcpObjectPlatformPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vTempObjectPlatformPos.SetX(vcpObjectPlatformPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
				vTempObjectPlatformPos.SetY(vcpObjectPlatformPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
				if (GetMidPlatformType()==ePlatformXYPD)
				{
					vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
						vTempObjectPlatformPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
				}
				else if (GetMidPlatformType()==ePlatformXY)
				{
					vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
						vTempObjectPlatformPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());

				}
				else if (GetMidPlatformType()==ePlatformX)
				{
					vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
						vTempObjectPlatformPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
				}
				else if (GetMidPlatformType()==ePlatformY)
				{
					vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
						vTempObjectPlatformPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
				}
				else
				{
					vTempAlginedObjectPlatformPos = vfGetTransformRotateShiftPoint(
						vTempObjectPlatformPos, degPlatformOffsetD, 0, 0);
				}

				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vTempAlginedObjectPlatformPos.GetX();
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vTempAlginedObjectPlatformPos.GetY();
			}

			vcpAlginedObjectPlatformPos.at(i) = pos;
		}

	}

	// 根据平台移动量，调整目标位置
	{
		vcpAlginedTargetPlatformPos = vcpTargetPlatformPos;
		int nPosNum = vcpTargetPlatformPos.size();	
		CCoordPos pos;
		sc2Vector vTempTargetPlatformPos;
		sc2Vector vTempAlginedTargetPlatformPos;
		int i = 0;
		for(i = 0; i < nPosNum; i++)
		{			
			vTempTargetPlatformPos.SetX(vcpTargetPlatformPos.at(i).GetPosX());
			vTempTargetPlatformPos.SetY(vcpTargetPlatformPos.at(i).GetPosY());

			if (GetMidPlatformType()==ePlatformXYPD)
			{
				vTempAlginedTargetPlatformPos = vfGetTransformRotateShiftPoint(vTempTargetPlatformPos, degPlatformOffsetD, 0, 0);
				if (i<MAXTARGETPOS)
				{
					m_dTargetX[i] = vTempAlginedTargetPlatformPos.GetX();
					m_dTargetY[i] = vTempAlginedTargetPlatformPos.GetY();
				}			

			}
			else if (GetMidPlatformType()==ePlatformXY)
			{
				vTempAlginedTargetPlatformPos = vTempTargetPlatformPos;
			}
			else if (GetMidPlatformType()==ePlatformX)
			{
				vTempAlginedTargetPlatformPos = vTempTargetPlatformPos;
			}
			else if (GetMidPlatformType()==ePlatformY)
			{
				vTempAlginedTargetPlatformPos = vTempTargetPlatformPos;
			}
			else
			{
				vTempAlginedTargetPlatformPos = vTempTargetPlatformPos;
			}
			pos.m_dPosX = vTempAlginedTargetPlatformPos.GetX();
			pos.m_dPosY = vTempAlginedTargetPlatformPos.GetY();

			// 辅助位置
			int nAuxiPosIndex = 0;
			for (nAuxiPosIndex = 0; nAuxiPosIndex < vcpTargetPlatformPos.at(i).m_vdAuxiliaryPosX.size(); nAuxiPosIndex++)
			{
				vTempTargetPlatformPos.SetX(vcpTargetPlatformPos.at(i).m_vdAuxiliaryPosX.at(nAuxiPosIndex));
				vTempTargetPlatformPos.SetY(vcpTargetPlatformPos.at(i).m_vdAuxiliaryPosY.at(nAuxiPosIndex));
				if (GetMidPlatformType()==ePlatformXYPD)
				{
					vTempAlginedTargetPlatformPos = vfGetTransformRotateShiftPoint(vTempTargetPlatformPos, degPlatformOffsetD, 0, 0);
				}
				else if (GetMidPlatformType()==ePlatformXY)
				{
					vTempAlginedTargetPlatformPos = vTempTargetPlatformPos;
				}
				else if (GetMidPlatformType()==ePlatformX)
				{
					vTempAlginedTargetPlatformPos = vTempTargetPlatformPos;
				}
				else if (GetMidPlatformType()==ePlatformY)
				{
					vTempAlginedTargetPlatformPos = vTempTargetPlatformPos;
				}
				else
				{
					vTempAlginedTargetPlatformPos = vTempTargetPlatformPos;
				}

				pos.m_vdAuxiliaryPosX.at(nAuxiPosIndex) = vTempAlginedTargetPlatformPos.GetX();
				pos.m_vdAuxiliaryPosY.at(nAuxiPosIndex) = vTempAlginedTargetPlatformPos.GetY();
			}

			vcpAlginedTargetPlatformPos.at(i) = pos;
		}
	}

	str.Format("GetAlginOffset End");
	AlignToolLogRecord(str,m_nPlatformIndex);

	return TRUE;
}


// 计算产品偏差、平台偏移量，最优化方法(根据目标、对象的所有相应对位点，对位完成后，对象与目标的所有相应对位点的距离平方和最小)
BOOL vcBaseAlignTool::GetAlginOffset_Optimize(
	std::vector<CCoordPos> vcpObjectPlatformPos,
	std::vector<CCoordPos> vcpTargetPlatformPos,
	sc2Vector& vProductOffsetXY, scDegree& degProductOffsetD,
	sc2Vector& vPlatformOffsetXY, scDegree& degPlatformOffsetD)
{
	CString str;
	str.Format("GetAlginOffset_Optimize Begin");
	AlignToolLogRecord(str,m_nPlatformIndex);

	int nPosNumber = vcpObjectPlatformPos.size();

	// 1.记录对象位置和目标位置		
	svStd vector<sc2Vector> Objpts;
	svStd vector<sc2Vector> Tgtpts;
	int i=0;
	for (i=0;i<nPosNumber;i++)
	{
		sc2Vector objpt(vcpObjectPlatformPos.at(i).GetPosX(),vcpObjectPlatformPos.at(i).GetPosY());
		sc2Vector tgtpt(vcpTargetPlatformPos.at(i).GetPosX(),vcpTargetPlatformPos.at(i).GetPosY());

		Objpts.push_back(objpt);
		Tgtpts.push_back(tgtpt);
	}

	for (i=0;i<nPosNumber;i++)
	{
		str.Format("Objpts.at(%d).GetX()=%f,Objpts.at(%d).GetY()=%f",i,Objpts.at(i).GetX(),i,Objpts.at(i).GetY());
		AlignToolLogRecord(str,m_nPlatformIndex);

	}
	for (i=0;i<nPosNumber;i++)
	{
		str.Format("Tgtpts.at(%d).GetX()=%f,Tgtpts.at(%d).GetY()=%f",i,Tgtpts.at(i).GetX(),i,Tgtpts.at(i).GetY());
		AlignToolLogRecord(str,m_nPlatformIndex);

	}

	// 2.计算产品角度偏差、产品XY偏移量
	double dProductOffsetX = 0;
	double dProductOffsetY = 0;
	if (!sfGetRigidTransformationProduct(Objpts, Tgtpts, dProductOffsetX, dProductOffsetY, degProductOffsetD))
	{
		str.Format("sfGetRigidTransformationProduct fail");
		AlignToolLogRecord(str,m_nPlatformIndex);
		return FALSE;
	}
	vProductOffsetXY.SetX(dProductOffsetX);
	vProductOffsetXY.SetY(dProductOffsetY);

	// 3.计算角度、XY平台偏移量
	scDegree degTd = scDegree(0);
	double dAlignerX = 0;
	double dAlignerY = 0;
	sc2Vector PtOrigin(0, 0);
	if (GetMidPlatformType()==ePlatformXYPD)
	{
		if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
		{
			// 对位时，只考虑XY偏差量，不考虑角度D偏差量
			// 强制将产品偏差赋值为0
			degProductOffsetD = scDegree(0);

			// $3.1.计算角度、XY偏移量
			degPlatformOffsetD = degProductOffsetD;	// 平台角度偏量
			vPlatformOffsetXY = vProductOffsetXY;	// 平台XY偏移量
		}
		else
		{
			// $3.1.先计算目标转到对象的角度，旋转中心为平台旋转中心(0,0)					
			double dTempAlignerX = 0;
			double dTempAlignerY = 0;

			if (!sfGetRigidTransformation(Tgtpts, Objpts, dTempAlignerX, dTempAlignerY, degTd, PtOrigin))
			{
				str.Format("sfGetRigidTransformation fail");
				AlignToolLogRecord(str,m_nPlatformIndex);
				return FALSE;
			}

			// $3.2 计算实时目标mark中心按degTd旋转后的新坐标值
			svStd vector<sc2Vector> tempObjpts = Objpts;
			svStd vector<sc2Vector> tempTgtpts = Tgtpts;
			for (int i=0;i<nPosNumber;i++)
			{
				tempTgtpts.at(i) = vfGetTransformRotateShiftPoint(Tgtpts.at(i), degTd, 0, 0, PtOrigin);

				str.Format("旋转后产品的目标位置[%d] X=%f,Y=%f",i,tempTgtpts.at(i).GetX(),tempTgtpts.at(i).GetY());
				AlignToolLogRecord(str, m_nPlatformIndex);

			}


			// $3.3 计算新的XY平台偏移量
			scDegree degTempTd = scDegree(0);
			if (!sfGetRigidTransformation(Objpts, tempTgtpts, dAlignerX, dAlignerY, degTempTd, PtOrigin))
			{
				str.Format("sfGetRigidTransformation fail");
				AlignToolLogRecord(str,m_nPlatformIndex);
				return FALSE;
			}

			degPlatformOffsetD = degTd;	// 平台角度偏量
			vPlatformOffsetXY = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
		}

	}
	else
	{
		if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
		{
			// 对位时，只考虑XY偏差量，不考虑角度D偏差量
			// 强制将产品偏差赋值为0
			degProductOffsetD = scDegree(0);

			str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
			AlignToolLogRecord(str,m_nPlatformIndex);

			// $3.1.计算角度、XY偏移量
			degPlatformOffsetD = degProductOffsetD;	// 平台角度偏量
			vPlatformOffsetXY = vProductOffsetXY;	// 平台XY偏移量
		}
		else
		{
			// $3.1.计算角度、XY偏移量
			if (!sfGetRigidTransformation(Objpts, Tgtpts, dAlignerX, dAlignerY, degTd, PtOrigin))
			{
				str.Format("sfGetRigidTransformation fail");
				AlignToolLogRecord(str,m_nPlatformIndex);
				return FALSE;
			}

			degPlatformOffsetD = degTd;	// 平台角度偏量
			vPlatformOffsetXY = sc2Vector(dAlignerX, dAlignerY);	// 平台XY偏移量
		}			
	}

	str.Format("sfGetRigidTransformation success");
	AlignToolLogRecord(str,m_nPlatformIndex);

	str.Format("GetAlginOffset_Optimize End");
	AlignToolLogRecord(str,m_nPlatformIndex);

	return TRUE;
}


// 计算产品偏差、平台偏移量，几何方法(根据目标、对象的位置和角度(姿态)，直接计算对象与目标的产品偏差和平台偏移量)
BOOL vcBaseAlignTool::GetAlginOffset_Geometry(
	sc2Vector vProductObjectPos, scDegree degProductObjectAngle,
	sc2Vector vProductTargetPos, scDegree degProductTargetAngle,
	sc2Vector& vProductOffsetXY, scDegree& degProductOffsetD,
	sc2Vector& vPlatformOffsetXY, scDegree& degPlatformOffsetD)
{
	CString str;
	str.Format("GetAlginOffset_Geometry Begin");
	AlignToolLogRecord(str,m_nPlatformIndex);

	// 2.1如果开启目标与对象角度垂直，则修正目标角度
	if (TRUE == m_AlignermentParam.GetEnableAlignAngleVectical())
	{
		if (0 == m_AlignermentParam.GetAlignAngleVecticalMode())
		{
			// 0:对象到目标Mark角度（+90°），即目标Mark角度-对象Mark角度=90°；
			degProductTargetAngle = (degProductTargetAngle.SignedNorm() - scDegree(90)).SignedNorm();

			str.Format(_T("启用目标与对象角度相互垂直:目标转换后角度:%f"), degProductTargetAngle.ToDouble());
			AlignToolLogRecord(str, m_nPlatformIndex);
		}
		else
		{
			// 1：对象到目标Mark角度（-90°），即目标Mark角度-对象Mark角度=-90°
			degProductTargetAngle = (degProductTargetAngle.SignedNorm() + scDegree(90)).SignedNorm();

			str.Format(_T("启用目标与对象角度相互垂直:目标转换后角度:%f"), degProductTargetAngle.ToDouble());
			AlignToolLogRecord(str, m_nPlatformIndex);
		}
	}

	// 3.计算产品角度、XY偏差
	// 计算产品角度偏差 = 目标角度 - 对象角度
	degProductOffsetD = (degProductTargetAngle - degProductObjectAngle).SignedNorm();
	// 计算产品XY偏差 = 目标位置 - 对象位置
	vProductOffsetXY = vProductTargetPos - vProductObjectPos;

	// 4.计算角度、XY平台偏移量		
	sc2Vector vTempProductTargetPos;		// 临时目标位置
	sc2Vector vTempProductObjectPos;		// 临时对象位置
	if (GetMidPlatformType()==ePlatformXYPD)
	{
		if (!m_bInnerAlignBench)
		{
			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
			{
				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
				// 强制将产品偏差赋值为0
				degProductOffsetD = scDegree(0);

				str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
				AlignToolLogRecord(str,m_nPlatformIndex);
			}

			// 角度平台移动量
			degPlatformOffsetD = -degProductOffsetD;

			// 对象位置
			vTempProductObjectPos = vProductObjectPos;

			// 目标位置：根据角度偏差，调整旋转目标位置
			vTempProductTargetPos = vfGetTransformRotateShiftPoint(vProductTargetPos, degPlatformOffsetD, 0, 0);

			// 计算XY偏移量
			vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
		}
		else
		{
			if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
			{
				// 对位时，只考虑XY偏差量，不考虑角度D偏差量
				// 强制将产品偏差赋值为0
				degProductOffsetD = scDegree(0);

				str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
				AlignToolLogRecord(str,m_nPlatformIndex);
			}

			degProductOffsetD = scDegree(0);

			// 角度平台移动量
			degPlatformOffsetD = degProductOffsetD;


			// 对象位置
			vTempProductObjectPos = vProductObjectPos;

			// 目标位置
			vTempProductTargetPos = vProductTargetPos;

			// 计算XY偏移量
			vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
		}
	}
	else if (GetMidPlatformType()==ePlatformXY)
	{
		if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
		{
			// 对位时，只考虑XY偏差量，不考虑角度D偏差量
			// 强制将产品偏差赋值为0
			degProductOffsetD = scDegree(0);

			str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
			AlignToolLogRecord(str,m_nPlatformIndex);
		}

		// 角度平台移动量
		degPlatformOffsetD = degProductOffsetD;

		// 对象位置
		vTempProductObjectPos = vProductObjectPos;

		// 目标位置
		vTempProductTargetPos = vProductTargetPos;

		// 计算XY偏移量
		vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;

	}
	else if (GetMidPlatformType()==ePlatformX)
	{
		if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
		{
			// 对位时，只考虑XY偏差量，不考虑角度D偏差量
			// 强制将产品偏差赋值为0
			degProductOffsetD = scDegree(0);

			str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
			AlignToolLogRecord(str,m_nPlatformIndex);
		}

		// 角度平台移动量
		degPlatformOffsetD = degProductOffsetD;

		// 对象位置
		vTempProductObjectPos = vProductObjectPos;

		// 目标位置
		vTempProductTargetPos = vProductTargetPos;

		// 计算XY偏移量
		vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
	}
	else if (GetMidPlatformType()==ePlatformY)
	{
		if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
		{
			// 对位时，只考虑XY偏差量，不考虑角度D偏差量
			// 强制将产品偏差赋值为0
			degProductOffsetD = scDegree(0);

			str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
			AlignToolLogRecord(str,m_nPlatformIndex);
		}

		// 角度平台移动量
		degPlatformOffsetD = degProductOffsetD;

		// 对象位置
		vTempProductObjectPos = vProductObjectPos;

		// 目标位置
		vTempProductTargetPos = vProductTargetPos;

		// 计算XY偏移量
		vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
	}
	else
	{
		if (eAlignerMove_XY == m_AlignermentParam.GetAlignerMoveType())
		{
			// 对位时，只考虑XY偏差量，不考虑角度D偏差量
			// 强制将产品偏差赋值为0
			degProductOffsetD = scDegree(0);

			str.Format("对位时，只考虑XY偏差量，不考虑角度D偏差量, 强制将产品偏差赋值为0");
			AlignToolLogRecord(str,m_nPlatformIndex);
		}

		// 角度平台移动量
		degPlatformOffsetD = degProductOffsetD;

		// 对象位置：根据角度偏差，调整旋转对象位置
		vTempProductObjectPos = vfGetTransformRotateShiftPoint(vProductObjectPos, degPlatformOffsetD, 0, 0);

		// 目标位置
		vTempProductTargetPos = vProductTargetPos;

		// 计算XY偏移量
		vPlatformOffsetXY = vTempProductTargetPos - vTempProductObjectPos;
	}

	str.Format("GetAlginOffset_Geometry End");
	AlignToolLogRecord(str,m_nPlatformIndex);

	return TRUE;
}


// 根据平台类型，旋转平移对象平台坐标，得到相对于当前(原，变换前)坐标系的新平台坐标
BOOL vcBaseAlignTool::PlatformTransformRotateShiftObject(sc2Vector vProductObjectPos, scDegree degProductObjectAngle, 
	scDegree degPlatformOffsetD, sc2Vector vPlatformOffsetXY,
	sc2Vector& vNewProductObjectPos, scDegree& degNewProductObjectAngle)
{
	if (GetMidPlatformType()==ePlatformXYPD)
	{
		vNewProductObjectPos = vfGetTransformRotateShiftPoint(
			vProductObjectPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
		degNewProductObjectAngle = degProductObjectAngle;
	}
	else if (GetMidPlatformType()==ePlatformXY)
	{
		vNewProductObjectPos = vfGetTransformRotateShiftPoint(
			vProductObjectPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
		degNewProductObjectAngle = degProductObjectAngle;
	}
	else if (GetMidPlatformType()==ePlatformX)
	{
		vNewProductObjectPos = vfGetTransformRotateShiftPoint(
			vProductObjectPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
		degNewProductObjectAngle = degProductObjectAngle;
	}
	else if (GetMidPlatformType()==ePlatformY)
	{
		vNewProductObjectPos = vfGetTransformRotateShiftPoint(
			vProductObjectPos, scDegree(0), vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
		degNewProductObjectAngle = degProductObjectAngle;
	}
	else
	{
		vNewProductObjectPos = vfGetTransformRotateShiftPoint(
			vProductObjectPos, degPlatformOffsetD, vPlatformOffsetXY.GetX(), vPlatformOffsetXY.GetY());
		degNewProductObjectAngle = degProductObjectAngle + degPlatformOffsetD;
	}

	return TRUE;
}

// 根据平台类型，旋转平移目标平台坐标，得到相对于当前(原，变换前)坐标系的新平台坐标
BOOL vcBaseAlignTool::PlatformTransformRotateShiftTarget(sc2Vector vProductTargetPos, scDegree degProductTargetAngle, 
	scDegree degPlatformOffsetD, sc2Vector vPlatformOffsetXY,
	sc2Vector& vNewProductTargetPos, scDegree& degNewProductTargetAngle)
{
	if (GetMidPlatformType()==ePlatformXYPD)
	{
		vNewProductTargetPos = vfGetTransformRotateShiftPoint(vProductTargetPos, degPlatformOffsetD, 0, 0);
		degNewProductTargetAngle = degProductTargetAngle + degPlatformOffsetD;
	}
	else if (GetMidPlatformType()==ePlatformXY)
	{
		vNewProductTargetPos = vProductTargetPos;
		degNewProductTargetAngle = degProductTargetAngle;
	}
	else if (GetMidPlatformType()==ePlatformX)
	{
		vNewProductTargetPos = vProductTargetPos;
		degNewProductTargetAngle = degProductTargetAngle;
	}
	else if (GetMidPlatformType()==ePlatformY)
	{
		vNewProductTargetPos = vProductTargetPos;
		degNewProductTargetAngle = degProductTargetAngle;
	}
	else
	{
		vNewProductTargetPos = vProductTargetPos;
		degNewProductTargetAngle = degProductTargetAngle;
	}

	return TRUE;
}

BOOL vcBaseAlignTool::PlatformTransform(sc2Vector vProductObjectPos, scDegree degProductObjectAngle, sc2Vector vProductTargetPos, scDegree degProductTargetAngle, 
	scDegree degPlatformOffsetD, sc2Vector vPlatformOffsetXY,
	sc2Vector& vNewProductObjectPos, scDegree& degNewProductObjectAngle, sc2Vector& vNewProductTargetPos, scDegree& degNewProductTargetAngle)
{
	if (!PlatformTransformRotateShiftObject(vProductObjectPos, degProductObjectAngle, degPlatformOffsetD, vPlatformOffsetXY,
		vNewProductObjectPos, degNewProductObjectAngle))
	{
		return FALSE;
	}

	if (!PlatformTransformRotateShiftTarget(vProductTargetPos, degProductTargetAngle, degPlatformOffsetD, vPlatformOffsetXY,
		vNewProductTargetPos, degNewProductTargetAngle))
	{
		return FALSE;
	}

	return TRUE;
}

// 基准Mark修正
CBenchTargetMarkFixInfo* vcBaseAlignTool::ExacuteBenchMarkFix( std::vector<CCoordPos> imageCoordPoses, 
	std::vector<CPlatformAxisPos*> vPlatformAxisPoses) 
{
	return NULL;
}

CBenchTargetMarkFixInfo* vcBaseAlignTool::ExacuteBenchMarkFix( std::vector<CCoordPos> imageCoordPoses, 
	CPlatformAxisPos* pPlatformAxisPos, std::vector<CPlatformAxisPos*> vCamPlatformAxisPoses)
{
	return NULL;
}

// XY+D拾取
int vcBaseAlignTool::GetCalibCenterPlatformMovePosNum(int nMarkType)
{
	return 0;
}



// XY+D拾取 - XY
int vcBaseAlignTool::GetCalibPlatformPickMovePosNum()
{
	return 0;
}

// XY+D拾取 - D
int vcBaseAlignTool::GetCalibCenterPlatformPickMovePosNum()
{
	return 0;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibPlatformPickMovePos(int nPosIndex)
{
	std::vector<CPlatformAxisPos*> vpPos;
	return vpPos;
}

std::vector<CPlatformAxisPos*> vcBaseAlignTool::GetCalibCenterPlatformPickMovePos(int nPosIndex)
{
	std::vector<CPlatformAxisPos*> vpPos;
	return vpPos;
}

// XY+D平台拾取，XY标定，用9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibratePickSingleCamEX(int nCamIndex)
{
	return FALSE;
}

// XY+D平台拾取，D标定， 用9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateCenterPickSingleCamEX(int nCamIndex)
{
	return FALSE;
}

// XY平台拾取,用9点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXYSingleCamPickEX(int nCamIndex)
{
	return FALSE;
}

// XY平台拾取,用5点H矩阵方式进行标定
BOOL vcBaseAlignTool::ExecuteCalibrateXYSingleCamPick( int nCamIndex )
{
	return FALSE;
}

// 全局二维码标定时拾取XY平台靶标到平台坐标映射
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamXYWholeDmCodeBoardBoardToPlatPick(int nCamIndex)
{
	return FALSE;
}

//全局二维码标定时拾取相机shareXY时靶标到平台坐标映射
BOOL vcBaseAlignTool::ExecuteCalibrateSingleCamWholeDmCodeBoardBoardToPlatPick(int nCamIndex)
{
	return FALSE;
}

CBenchTargetMarkPickInfo* vcBaseAlignTool::ExacuteBenchMarkPick( std::vector<CCoordPos> imageCoordPoses, 
	std::vector<CPlatformAxisPos*> vPlatformAxisPoses, CPlatformAxisPos* pPickPlatformAxisPoses,int nIndex,CBenchTargetMarkPickInfo* OriginFixInfo,int nExProductIndex)
{
	return NULL;

}

BOOL vcBaseAlignTool::ExecuteAlignPick(int nAlnIndex/* = 0*/)
{
	return FALSE;
}

BOOL vcBaseAlignTool::ExeBendInsInfoCalcu(std::vector<sc2Vector>& vTargetPlaftormPos, std::vector<sc2Vector>& vObjectPlatformPos, std::vector<double>& vdDistance)
{
	return FALSE;
}

void vcBaseAlignTool::SetBendAlignProcess(BOOL bBendAlignProcess)
{
}
CString vcBaseAlignTool::GetAlignErrInfo()
{
	CString strErrInfo = _T("");
	strErrInfo.Format(_T("Err:%d "), m_nAlignErrNum);

	switch(m_nAlignErrNum)
	{
	case -1:
		{
			strErrInfo += _T("标定结果为空");
		}
		break;

	case -2:
		{
			strErrInfo += _T("标定信息无效");
		}
		break;

	case -3:
		{
			strErrInfo += _T("对象图像坐标定位失败");
		}
		break;

	case -4:
		{
			strErrInfo += _T("目标图像坐标定位失败");
		}
		break;

	case -5:
		{
			strErrInfo += _T("对象平台坐标计算失败");
		}
		break;

	case -6:
		{
			strErrInfo += _T("对象平台坐标重构点计算失败");
		}
		break;

	case -7:
		{
			strErrInfo += _T("对象补偿计算失败");
		}
		break;

	case -8:
		{
			strErrInfo += _T("目标平台坐标计算失败");
		}
		break;

	case -9:
		{
			strErrInfo += _T("目标平台坐标重构点计算失败");
		}
		break;

	case -10:
		{
			strErrInfo += _T("平台偏差计算失败");
		}
		break;

	default:
		{
			strErrInfo = _T("");
		}
		break;

	}


	return strErrInfo;
}