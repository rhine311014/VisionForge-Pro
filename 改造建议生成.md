# VisionForge Pro 多工位多相机多位置功能改造建议

## 1. 现状分析与痛点
目前 VisionForge Pro 在处理多工位、多相机及多位置场景时，可能存在以下问题：
- **扩展性差**：增加工位或相机可能需要修改大量代码。
- **调试繁琐**：缺乏集中的调试界面，切换不同相机或位置查看图像/状态不便。
- **配置僵化**：参数可能硬编码或分散管理，难以适应不同产线的灵活需求。

## 2. 参考 VisionASM 的实现机制
经过对 VisionASM 源码的分析，其核心优势在于：
- **对象化管理**：将“工位”、“相机”、“位置”抽象为独立类，使用 `std::vector` 容器管理。
- **配置驱动**：通过 XML/配置文件读取结构，系统启动时动态创建对应数量的对象。
- **专用调试工具**：提供了 `DlgManualSearch`（手动调试）和 `DlgCalibTargetPos`（多点标定）等专用界面，极大降低了多位置调试的复杂度。

## 3. 具体的改造实施建议

### 3.1 核心架构重构 (Core Architecture)
**建议：** 废弃硬编码的变量（如 `Camera1`, `Camera2`），采用容器化管理。

*   **定义数据结构**：
    建立清晰的层级关系：`System -> Station (工位) -> Camera (相机) / Position (位置)`。
    ```cpp
    // 示例结构思路
    struct CameraConfig {
        int id;
        std::string name;
        // 相机特定参数...
    };

    struct StationConfig {
        int id;
        std::string name;
        std::vector<CameraConfig> cameras; // 该工位下的相机列表
        int positionCount; // 该工位需要示教/工作的物理位置数量
        // 工位特定逻辑...
    };
    ```
*   **管理器类**：
    创建一个 `StationManager` 单例，维护 `std::vector<StationConfig>`。所有业务逻辑通过 `StationManager::GetStation(id)` 获取上下文，而不是直接操作全局变量。

### 3.2 界面交互优化 (UI/UX)
**建议：** 引入动态布局和向导式操作，解决“调试不方便”的问题。

*   **动态视图 (Dynamic Views)**：
    *   主界面不要固定显示所有相机。使用 `QTabWidget` (Qt) 或类似控件，根据配置动态生成 Tab 页。
    *   每个 Tab 代表一个工位，内部动态排列该工位下的相机画面。
*   **手动调试模式 (Manual Debug Mode)**：
    *   **痛点解决**：多工位调试时，经常需要单独动某个轴或看某个相机。
    *   **方案**：开发一个独立的“手动调试中心”窗口（参考 VisionASM 的 `DlgManualSearch`）。
    *   **功能**：
        1.  下拉选择当前调试的工位和相机。
        2.  提供“单次拍照”、“连续拍照”按钮。
        3.  集成轴控制按钮（上/下/左/右），直接发指令给 PLC 微调位置。
        4.  实时显示当前计算结果（坐标、分数）。
*   **标定向导 (Calibration Wizard)**：
    *   **痛点解决**：多位置标定（如 9 宫格）容易漏做或顺序搞错。
    *   **方案**：设计“分步向导”界面。左侧列出所有步骤（位置1...位置N），右侧显示当前操作指引。用户完成一步，列表自动打钩并跳到下一步。

### 3.3 配置系统升级 (Configuration System)
**建议：** 实现完全的配置驱动，减少重新编译。

*   **配置文件**：使用 JSON 或 XML 描述整线结构。
    ```json
    {
      "stations": [
        {
          "id": 1,
          "name": "上料位",
          "cameras": [ {"id":1, "exposure": 5000}, ... ],
          "positions": [ ... ]
        },
        ...
      ]
    }
    ```
*   **动态加载**：软件启动时读取此配置，自动构建对象和界面。

### 3.4 通信协议标准化 (Communication)
**建议：** 统一指令格式，支持精确寻址。

*   **指令设计**：所有 PLC 指令必须携带 `StationID` 和 `CameraID/PositionID`。
    *   例如：`CMD_CALIBRATE(Station=1, Camera=2, Position=5)`
*   **分发机制**：通信模块收到指令后，解析 ID，直接路由到对应的 `Station` 对象处理。

## 4. 实施路线图
1.  **第一阶段**：定义新的 `Station/Camera` 数据结构，实现配置文件的读取与解析。
2.  **第二阶段**：重构后端逻辑，使用容器替换散乱的变量，打通通信指令的路由分发。
3.  **第三阶段**：重写前端界面，实现动态 Tab 和手动调试窗口。
4.  **第四阶段**：迁移旧项目数据，进行现场验证。
